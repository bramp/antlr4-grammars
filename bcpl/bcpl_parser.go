// Code generated from bcpl.g4 by ANTLR 4.9.3. DO NOT EDIT.

package bcpl // bcpl
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 138, 798,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 3, 2, 3, 2, 3, 3, 3, 3, 3, 4, 3, 4, 3, 5, 3, 5, 3, 6, 3,
	6, 7, 6, 185, 10, 6, 12, 6, 14, 6, 188, 11, 6, 3, 6, 3, 6, 3, 7, 3, 7,
	3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 7, 8, 199, 10, 8, 12, 8, 14, 8, 202, 11,
	8, 3, 9, 3, 9, 3, 9, 7, 9, 207, 10, 9, 12, 9, 14, 9, 210, 11, 9, 3, 10,
	3, 10, 3, 10, 3, 10, 7, 10, 216, 10, 10, 12, 10, 14, 10, 219, 11, 10, 5,
	10, 221, 10, 10, 3, 11, 3, 11, 3, 11, 3, 11, 7, 11, 227, 10, 11, 12, 11,
	14, 11, 230, 11, 11, 3, 12, 3, 12, 5, 12, 234, 10, 12, 3, 13, 3, 13, 3,
	14, 3, 14, 3, 15, 3, 15, 3, 16, 3, 16, 3, 17, 3, 17, 3, 18, 3, 18, 3, 19,
	3, 19, 3, 20, 3, 20, 3, 21, 3, 21, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3,
	23, 3, 23, 3, 23, 5, 23, 262, 10, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24,
	3, 24, 5, 24, 270, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3,
	24, 3, 24, 7, 24, 280, 10, 24, 12, 24, 14, 24, 283, 11, 24, 3, 25, 3, 25,
	3, 25, 3, 25, 3, 25, 3, 25, 7, 25, 291, 10, 25, 12, 25, 14, 25, 294, 11,
	25, 3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 300, 10, 26, 3, 27, 3, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 3, 27, 7, 27, 309, 10, 27, 12, 27, 14, 27, 312, 11,
	27, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 319, 10, 28, 3, 28, 3, 28,
	3, 28, 3, 28, 7, 28, 325, 10, 28, 12, 28, 14, 28, 328, 11, 28, 3, 29, 3,
	29, 3, 29, 3, 29, 7, 29, 334, 10, 29, 12, 29, 14, 29, 337, 11, 29, 3, 30,
	3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 346, 10, 30, 12, 30, 14,
	30, 349, 11, 30, 3, 31, 3, 31, 3, 31, 3, 31, 5, 31, 355, 10, 31, 3, 32,
	3, 32, 3, 32, 3, 32, 7, 32, 361, 10, 32, 12, 32, 14, 32, 364, 11, 32, 3,
	33, 3, 33, 3, 33, 3, 33, 7, 33, 370, 10, 33, 12, 33, 14, 33, 373, 11, 33,
	3, 34, 3, 34, 3, 34, 3, 34, 7, 34, 379, 10, 34, 12, 34, 14, 34, 382, 11,
	34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 391, 10, 35,
	3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 7, 36, 398, 10, 36, 12, 36, 14, 36,
	401, 11, 36, 3, 36, 3, 36, 5, 36, 405, 10, 36, 3, 37, 3, 37, 3, 37, 3,
	37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 416, 10, 37, 3, 38, 3, 38,
	3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 7, 38, 425, 10, 38, 12, 38, 14, 38,
	428, 11, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 435, 10, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 7, 39, 441, 10, 39, 12, 39, 14, 39, 444, 11, 39,
	3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 7, 40, 453, 10, 40, 12,
	40, 14, 40, 456, 11, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41,
	7, 41, 465, 10, 41, 12, 41, 14, 41, 468, 11, 41, 3, 42, 3, 42, 3, 42, 3,
	42, 3, 42, 3, 42, 3, 42, 7, 42, 477, 10, 42, 12, 42, 14, 42, 480, 11, 42,
	3, 43, 3, 43, 3, 43, 7, 43, 485, 10, 43, 12, 43, 14, 43, 488, 11, 43, 3,
	44, 3, 44, 3, 44, 7, 44, 493, 10, 44, 12, 44, 14, 44, 496, 11, 44, 3, 45,
	3, 45, 3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 7, 46, 505, 10, 46, 12, 46, 14,
	46, 508, 11, 46, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 48, 3, 48, 3, 48,
	3, 48, 3, 48, 3, 49, 3, 49, 3, 49, 3, 49, 3, 50, 3, 50, 3, 50, 7, 50, 527,
	10, 50, 12, 50, 14, 50, 530, 11, 50, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51,
	3, 52, 3, 52, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 54, 3,
	54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54,
	3, 54, 5, 54, 559, 10, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3,
	55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 5, 55, 574, 10, 55, 3, 56,
	3, 56, 3, 56, 3, 56, 5, 56, 580, 10, 56, 3, 57, 3, 57, 3, 57, 3, 57, 7,
	57, 586, 10, 57, 12, 57, 14, 57, 589, 11, 57, 3, 58, 3, 58, 3, 58, 3, 58,
	5, 58, 595, 10, 58, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 5,
	59, 604, 10, 59, 3, 60, 3, 60, 3, 60, 7, 60, 609, 10, 60, 12, 60, 14, 60,
	612, 11, 60, 3, 61, 3, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3, 63, 3, 63, 3,
	63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 5, 64,
	632, 10, 64, 3, 65, 3, 65, 3, 65, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3,
	67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67, 651,
	10, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 7, 67,
	661, 10, 67, 12, 67, 14, 67, 664, 11, 67, 3, 68, 3, 68, 3, 68, 3, 68, 3,
	68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68, 677, 10, 68, 3, 69,
	3, 69, 3, 69, 3, 69, 3, 69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 71, 3,
	71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71,
	3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 5, 71, 709, 10,
	71, 3, 72, 3, 72, 3, 72, 3, 72, 5, 72, 715, 10, 72, 3, 73, 3, 73, 3, 73,
	3, 73, 3, 73, 3, 73, 3, 73, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 75, 3,
	75, 3, 75, 3, 75, 3, 75, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76, 738, 10, 76,
	3, 77, 3, 77, 3, 77, 3, 78, 3, 78, 3, 78, 3, 78, 3, 79, 3, 79, 3, 79, 3,
	80, 3, 80, 3, 80, 5, 80, 753, 10, 80, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81,
	5, 81, 760, 10, 81, 3, 82, 3, 82, 3, 82, 7, 82, 765, 10, 82, 12, 82, 14,
	82, 768, 11, 82, 3, 83, 3, 83, 3, 83, 7, 83, 773, 10, 83, 12, 83, 14, 83,
	776, 11, 83, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 85, 3, 85, 3,
	85, 3, 85, 3, 86, 3, 86, 5, 86, 790, 10, 86, 3, 87, 3, 87, 3, 87, 3, 87,
	5, 87, 796, 10, 87, 3, 87, 2, 13, 46, 48, 52, 54, 58, 74, 76, 78, 80, 82,
	132, 88, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
	36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70,
	72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
	106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
	136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164,
	166, 168, 170, 172, 2, 14, 3, 2, 3, 54, 3, 2, 55, 62, 4, 2, 3, 8, 55, 64,
	3, 2, 55, 64, 3, 2, 65, 65, 3, 2, 70, 71, 4, 2, 72, 73, 132, 132, 3, 2,
	74, 75, 3, 2, 76, 81, 3, 2, 82, 83, 3, 2, 133, 134, 3, 2, 103, 107, 2,
	799, 2, 174, 3, 2, 2, 2, 4, 176, 3, 2, 2, 2, 6, 178, 3, 2, 2, 2, 8, 180,
	3, 2, 2, 2, 10, 182, 3, 2, 2, 2, 12, 191, 3, 2, 2, 2, 14, 195, 3, 2, 2,
	2, 16, 203, 3, 2, 2, 2, 18, 220, 3, 2, 2, 2, 20, 222, 3, 2, 2, 2, 22, 233,
	3, 2, 2, 2, 24, 235, 3, 2, 2, 2, 26, 237, 3, 2, 2, 2, 28, 239, 3, 2, 2,
	2, 30, 241, 3, 2, 2, 2, 32, 243, 3, 2, 2, 2, 34, 245, 3, 2, 2, 2, 36, 247,
	3, 2, 2, 2, 38, 249, 3, 2, 2, 2, 40, 251, 3, 2, 2, 2, 42, 253, 3, 2, 2,
	2, 44, 261, 3, 2, 2, 2, 46, 269, 3, 2, 2, 2, 48, 284, 3, 2, 2, 2, 50, 299,
	3, 2, 2, 2, 52, 301, 3, 2, 2, 2, 54, 318, 3, 2, 2, 2, 56, 329, 3, 2, 2,
	2, 58, 338, 3, 2, 2, 2, 60, 354, 3, 2, 2, 2, 62, 356, 3, 2, 2, 2, 64, 365,
	3, 2, 2, 2, 66, 374, 3, 2, 2, 2, 68, 390, 3, 2, 2, 2, 70, 404, 3, 2, 2,
	2, 72, 415, 3, 2, 2, 2, 74, 417, 3, 2, 2, 2, 76, 434, 3, 2, 2, 2, 78, 445,
	3, 2, 2, 2, 80, 457, 3, 2, 2, 2, 82, 469, 3, 2, 2, 2, 84, 481, 3, 2, 2,
	2, 86, 489, 3, 2, 2, 2, 88, 497, 3, 2, 2, 2, 90, 501, 3, 2, 2, 2, 92, 509,
	3, 2, 2, 2, 94, 514, 3, 2, 2, 2, 96, 519, 3, 2, 2, 2, 98, 523, 3, 2, 2,
	2, 100, 531, 3, 2, 2, 2, 102, 536, 3, 2, 2, 2, 104, 540, 3, 2, 2, 2, 106,
	558, 3, 2, 2, 2, 108, 573, 3, 2, 2, 2, 110, 579, 3, 2, 2, 2, 112, 581,
	3, 2, 2, 2, 114, 594, 3, 2, 2, 2, 116, 603, 3, 2, 2, 2, 118, 605, 3, 2,
	2, 2, 120, 613, 3, 2, 2, 2, 122, 617, 3, 2, 2, 2, 124, 619, 3, 2, 2, 2,
	126, 631, 3, 2, 2, 2, 128, 633, 3, 2, 2, 2, 130, 636, 3, 2, 2, 2, 132,
	650, 3, 2, 2, 2, 134, 676, 3, 2, 2, 2, 136, 678, 3, 2, 2, 2, 138, 683,
	3, 2, 2, 2, 140, 708, 3, 2, 2, 2, 142, 714, 3, 2, 2, 2, 144, 716, 3, 2,
	2, 2, 146, 723, 3, 2, 2, 2, 148, 728, 3, 2, 2, 2, 150, 737, 3, 2, 2, 2,
	152, 739, 3, 2, 2, 2, 154, 742, 3, 2, 2, 2, 156, 746, 3, 2, 2, 2, 158,
	752, 3, 2, 2, 2, 160, 759, 3, 2, 2, 2, 162, 761, 3, 2, 2, 2, 164, 769,
	3, 2, 2, 2, 166, 777, 3, 2, 2, 2, 168, 783, 3, 2, 2, 2, 170, 789, 3, 2,
	2, 2, 172, 795, 3, 2, 2, 2, 174, 175, 9, 2, 2, 2, 175, 3, 3, 2, 2, 2, 176,
	177, 9, 3, 2, 2, 177, 5, 3, 2, 2, 2, 178, 179, 9, 4, 2, 2, 179, 7, 3, 2,
	2, 2, 180, 181, 9, 5, 2, 2, 181, 9, 3, 2, 2, 2, 182, 186, 7, 65, 2, 2,
	183, 185, 10, 6, 2, 2, 184, 183, 3, 2, 2, 2, 185, 188, 3, 2, 2, 2, 186,
	184, 3, 2, 2, 2, 186, 187, 3, 2, 2, 2, 187, 189, 3, 2, 2, 2, 188, 186,
	3, 2, 2, 2, 189, 190, 7, 65, 2, 2, 190, 11, 3, 2, 2, 2, 191, 192, 7, 66,
	2, 2, 192, 193, 5, 22, 12, 2, 193, 194, 7, 66, 2, 2, 194, 13, 3, 2, 2,
	2, 195, 196, 7, 67, 2, 2, 196, 200, 5, 4, 3, 2, 197, 199, 5, 4, 3, 2, 198,
	197, 3, 2, 2, 2, 199, 202, 3, 2, 2, 2, 200, 198, 3, 2, 2, 2, 200, 201,
	3, 2, 2, 2, 201, 15, 3, 2, 2, 2, 202, 200, 3, 2, 2, 2, 203, 204, 7, 68,
	2, 2, 204, 208, 5, 6, 4, 2, 205, 207, 5, 6, 4, 2, 206, 205, 3, 2, 2, 2,
	207, 210, 3, 2, 2, 2, 208, 206, 3, 2, 2, 2, 208, 209, 3, 2, 2, 2, 209,
	17, 3, 2, 2, 2, 210, 208, 3, 2, 2, 2, 211, 221, 5, 14, 8, 2, 212, 221,
	5, 16, 9, 2, 213, 217, 5, 8, 5, 2, 214, 216, 5, 8, 5, 2, 215, 214, 3, 2,
	2, 2, 216, 219, 3, 2, 2, 2, 217, 215, 3, 2, 2, 2, 217, 218, 3, 2, 2, 2,
	218, 221, 3, 2, 2, 2, 219, 217, 3, 2, 2, 2, 220, 211, 3, 2, 2, 2, 220,
	212, 3, 2, 2, 2, 220, 213, 3, 2, 2, 2, 221, 19, 3, 2, 2, 2, 222, 228, 5,
	2, 2, 2, 223, 227, 5, 2, 2, 2, 224, 227, 5, 8, 5, 2, 225, 227, 7, 69, 2,
	2, 226, 223, 3, 2, 2, 2, 226, 224, 3, 2, 2, 2, 226, 225, 3, 2, 2, 2, 227,
	230, 3, 2, 2, 2, 228, 226, 3, 2, 2, 2, 228, 229, 3, 2, 2, 2, 229, 21, 3,
	2, 2, 2, 230, 228, 3, 2, 2, 2, 231, 234, 5, 2, 2, 2, 232, 234, 5, 8, 5,
	2, 233, 231, 3, 2, 2, 2, 233, 232, 3, 2, 2, 2, 234, 23, 3, 2, 2, 2, 235,
	236, 5, 20, 11, 2, 236, 25, 3, 2, 2, 2, 237, 238, 9, 7, 2, 2, 238, 27,
	3, 2, 2, 2, 239, 240, 9, 8, 2, 2, 240, 29, 3, 2, 2, 2, 241, 242, 9, 9,
	2, 2, 242, 31, 3, 2, 2, 2, 243, 244, 9, 10, 2, 2, 244, 33, 3, 2, 2, 2,
	245, 246, 9, 11, 2, 2, 246, 35, 3, 2, 2, 2, 247, 248, 7, 84, 2, 2, 248,
	37, 3, 2, 2, 2, 249, 250, 7, 85, 2, 2, 250, 39, 3, 2, 2, 2, 251, 252, 9,
	12, 2, 2, 252, 41, 3, 2, 2, 2, 253, 254, 7, 86, 2, 2, 254, 43, 3, 2, 2,
	2, 255, 262, 5, 12, 7, 2, 256, 262, 5, 10, 6, 2, 257, 262, 5, 18, 10, 2,
	258, 262, 5, 20, 11, 2, 259, 262, 7, 135, 2, 2, 260, 262, 7, 136, 2, 2,
	261, 255, 3, 2, 2, 2, 261, 256, 3, 2, 2, 2, 261, 257, 3, 2, 2, 2, 261,
	258, 3, 2, 2, 2, 261, 259, 3, 2, 2, 2, 261, 260, 3, 2, 2, 2, 262, 45, 3,
	2, 2, 2, 263, 264, 8, 24, 1, 2, 264, 265, 7, 87, 2, 2, 265, 266, 5, 70,
	36, 2, 266, 267, 7, 88, 2, 2, 267, 270, 3, 2, 2, 2, 268, 270, 5, 44, 23,
	2, 269, 263, 3, 2, 2, 2, 269, 268, 3, 2, 2, 2, 270, 281, 3, 2, 2, 2, 271,
	272, 12, 6, 2, 2, 272, 273, 7, 87, 2, 2, 273, 274, 5, 84, 43, 2, 274, 275,
	7, 88, 2, 2, 275, 280, 3, 2, 2, 2, 276, 277, 12, 5, 2, 2, 277, 278, 7,
	87, 2, 2, 278, 280, 7, 88, 2, 2, 279, 271, 3, 2, 2, 2, 279, 276, 3, 2,
	2, 2, 280, 283, 3, 2, 2, 2, 281, 279, 3, 2, 2, 2, 281, 282, 3, 2, 2, 2,
	282, 47, 3, 2, 2, 2, 283, 281, 3, 2, 2, 2, 284, 285, 8, 25, 1, 2, 285,
	286, 5, 46, 24, 2, 286, 292, 3, 2, 2, 2, 287, 288, 12, 4, 2, 2, 288, 289,
	7, 71, 2, 2, 289, 291, 5, 46, 24, 2, 290, 287, 3, 2, 2, 2, 291, 294, 3,
	2, 2, 2, 292, 290, 3, 2, 2, 2, 292, 293, 3, 2, 2, 2, 293, 49, 3, 2, 2,
	2, 294, 292, 3, 2, 2, 2, 295, 296, 5, 26, 14, 2, 296, 297, 5, 50, 26, 2,
	297, 300, 3, 2, 2, 2, 298, 300, 5, 48, 25, 2, 299, 295, 3, 2, 2, 2, 299,
	298, 3, 2, 2, 2, 300, 51, 3, 2, 2, 2, 301, 302, 8, 27, 1, 2, 302, 303,
	5, 50, 26, 2, 303, 310, 3, 2, 2, 2, 304, 305, 12, 4, 2, 2, 305, 306, 5,
	28, 15, 2, 306, 307, 5, 50, 26, 2, 307, 309, 3, 2, 2, 2, 308, 304, 3, 2,
	2, 2, 309, 312, 3, 2, 2, 2, 310, 308, 3, 2, 2, 2, 310, 311, 3, 2, 2, 2,
	311, 53, 3, 2, 2, 2, 312, 310, 3, 2, 2, 2, 313, 314, 8, 28, 1, 2, 314,
	315, 5, 30, 16, 2, 315, 316, 5, 52, 27, 2, 316, 319, 3, 2, 2, 2, 317, 319,
	5, 52, 27, 2, 318, 313, 3, 2, 2, 2, 318, 317, 3, 2, 2, 2, 319, 326, 3,
	2, 2, 2, 320, 321, 12, 5, 2, 2, 321, 322, 5, 30, 16, 2, 322, 323, 5, 52,
	27, 2, 323, 325, 3, 2, 2, 2, 324, 320, 3, 2, 2, 2, 325, 328, 3, 2, 2, 2,
	326, 324, 3, 2, 2, 2, 326, 327, 3, 2, 2, 2, 327, 55, 3, 2, 2, 2, 328, 326,
	3, 2, 2, 2, 329, 335, 5, 54, 28, 2, 330, 331, 5, 32, 17, 2, 331, 332, 5,
	54, 28, 2, 332, 334, 3, 2, 2, 2, 333, 330, 3, 2, 2, 2, 334, 337, 3, 2,
	2, 2, 335, 333, 3, 2, 2, 2, 335, 336, 3, 2, 2, 2, 336, 57, 3, 2, 2, 2,
	337, 335, 3, 2, 2, 2, 338, 339, 8, 30, 1, 2, 339, 340, 5, 56, 29, 2, 340,
	347, 3, 2, 2, 2, 341, 342, 12, 4, 2, 2, 342, 343, 5, 34, 18, 2, 343, 344,
	5, 54, 28, 2, 344, 346, 3, 2, 2, 2, 345, 341, 3, 2, 2, 2, 346, 349, 3,
	2, 2, 2, 347, 345, 3, 2, 2, 2, 347, 348, 3, 2, 2, 2, 348, 59, 3, 2, 2,
	2, 349, 347, 3, 2, 2, 2, 350, 351, 5, 42, 22, 2, 351, 352, 5, 58, 30, 2,
	352, 355, 3, 2, 2, 2, 353, 355, 5, 58, 30, 2, 354, 350, 3, 2, 2, 2, 354,
	353, 3, 2, 2, 2, 355, 61, 3, 2, 2, 2, 356, 362, 5, 60, 31, 2, 357, 358,
	5, 36, 19, 2, 358, 359, 5, 60, 31, 2, 359, 361, 3, 2, 2, 2, 360, 357, 3,
	2, 2, 2, 361, 364, 3, 2, 2, 2, 362, 360, 3, 2, 2, 2, 362, 363, 3, 2, 2,
	2, 363, 63, 3, 2, 2, 2, 364, 362, 3, 2, 2, 2, 365, 371, 5, 62, 32, 2, 366,
	367, 5, 38, 20, 2, 367, 368, 5, 62, 32, 2, 368, 370, 3, 2, 2, 2, 369, 366,
	3, 2, 2, 2, 370, 373, 3, 2, 2, 2, 371, 369, 3, 2, 2, 2, 371, 372, 3, 2,
	2, 2, 372, 65, 3, 2, 2, 2, 373, 371, 3, 2, 2, 2, 374, 380, 5, 64, 33, 2,
	375, 376, 5, 40, 21, 2, 376, 377, 5, 64, 33, 2, 377, 379, 3, 2, 2, 2, 378,
	375, 3, 2, 2, 2, 379, 382, 3, 2, 2, 2, 380, 378, 3, 2, 2, 2, 380, 381,
	3, 2, 2, 2, 381, 67, 3, 2, 2, 2, 382, 380, 3, 2, 2, 2, 383, 384, 5, 66,
	34, 2, 384, 385, 7, 89, 2, 2, 385, 386, 5, 68, 35, 2, 386, 387, 7, 90,
	2, 2, 387, 388, 5, 68, 35, 2, 388, 391, 3, 2, 2, 2, 389, 391, 5, 66, 34,
	2, 390, 383, 3, 2, 2, 2, 390, 389, 3, 2, 2, 2, 391, 69, 3, 2, 2, 2, 392,
	405, 5, 68, 35, 2, 393, 394, 7, 137, 2, 2, 394, 399, 5, 82, 42, 2, 395,
	396, 7, 90, 2, 2, 396, 398, 5, 82, 42, 2, 397, 395, 3, 2, 2, 2, 398, 401,
	3, 2, 2, 2, 399, 397, 3, 2, 2, 2, 399, 400, 3, 2, 2, 2, 400, 405, 3, 2,
	2, 2, 401, 399, 3, 2, 2, 2, 402, 403, 7, 91, 2, 2, 403, 405, 5, 160, 81,
	2, 404, 392, 3, 2, 2, 2, 404, 393, 3, 2, 2, 2, 404, 402, 3, 2, 2, 2, 405,
	71, 3, 2, 2, 2, 406, 416, 5, 12, 7, 2, 407, 416, 5, 18, 10, 2, 408, 416,
	5, 20, 11, 2, 409, 416, 7, 135, 2, 2, 410, 416, 7, 136, 2, 2, 411, 412,
	7, 87, 2, 2, 412, 413, 5, 82, 42, 2, 413, 414, 7, 88, 2, 2, 414, 416, 3,
	2, 2, 2, 415, 406, 3, 2, 2, 2, 415, 407, 3, 2, 2, 2, 415, 408, 3, 2, 2,
	2, 415, 409, 3, 2, 2, 2, 415, 410, 3, 2, 2, 2, 415, 411, 3, 2, 2, 2, 416,
	73, 3, 2, 2, 2, 417, 418, 8, 38, 1, 2, 418, 419, 5, 72, 37, 2, 419, 426,
	3, 2, 2, 2, 420, 421, 12, 4, 2, 2, 421, 422, 5, 28, 15, 2, 422, 423, 5,
	72, 37, 2, 423, 425, 3, 2, 2, 2, 424, 420, 3, 2, 2, 2, 425, 428, 3, 2,
	2, 2, 426, 424, 3, 2, 2, 2, 426, 427, 3, 2, 2, 2, 427, 75, 3, 2, 2, 2,
	428, 426, 3, 2, 2, 2, 429, 430, 8, 39, 1, 2, 430, 431, 5, 30, 16, 2, 431,
	432, 5, 74, 38, 2, 432, 435, 3, 2, 2, 2, 433, 435, 5, 74, 38, 2, 434, 429,
	3, 2, 2, 2, 434, 433, 3, 2, 2, 2, 435, 442, 3, 2, 2, 2, 436, 437, 12, 5,
	2, 2, 437, 438, 5, 30, 16, 2, 438, 439, 5, 74, 38, 2, 439, 441, 3, 2, 2,
	2, 440, 436, 3, 2, 2, 2, 441, 444, 3, 2, 2, 2, 442, 440, 3, 2, 2, 2, 442,
	443, 3, 2, 2, 2, 443, 77, 3, 2, 2, 2, 444, 442, 3, 2, 2, 2, 445, 446, 8,
	40, 1, 2, 446, 447, 5, 76, 39, 2, 447, 454, 3, 2, 2, 2, 448, 449, 12, 4,
	2, 2, 449, 450, 5, 34, 18, 2, 450, 451, 5, 76, 39, 2, 451, 453, 3, 2, 2,
	2, 452, 448, 3, 2, 2, 2, 453, 456, 3, 2, 2, 2, 454, 452, 3, 2, 2, 2, 454,
	455, 3, 2, 2, 2, 455, 79, 3, 2, 2, 2, 456, 454, 3, 2, 2, 2, 457, 458, 8,
	41, 1, 2, 458, 459, 5, 78, 40, 2, 459, 466, 3, 2, 2, 2, 460, 461, 12, 4,
	2, 2, 461, 462, 5, 36, 19, 2, 462, 463, 5, 78, 40, 2, 463, 465, 3, 2, 2,
	2, 464, 460, 3, 2, 2, 2, 465, 468, 3, 2, 2, 2, 466, 464, 3, 2, 2, 2, 466,
	467, 3, 2, 2, 2, 467, 81, 3, 2, 2, 2, 468, 466, 3, 2, 2, 2, 469, 470, 8,
	42, 1, 2, 470, 471, 5, 80, 41, 2, 471, 478, 3, 2, 2, 2, 472, 473, 12, 4,
	2, 2, 473, 474, 5, 38, 20, 2, 474, 475, 5, 80, 41, 2, 475, 477, 3, 2, 2,
	2, 476, 472, 3, 2, 2, 2, 477, 480, 3, 2, 2, 2, 478, 476, 3, 2, 2, 2, 478,
	479, 3, 2, 2, 2, 479, 83, 3, 2, 2, 2, 480, 478, 3, 2, 2, 2, 481, 486, 5,
	70, 36, 2, 482, 483, 7, 90, 2, 2, 483, 485, 5, 70, 36, 2, 484, 482, 3,
	2, 2, 2, 485, 488, 3, 2, 2, 2, 486, 484, 3, 2, 2, 2, 486, 487, 3, 2, 2,
	2, 487, 85, 3, 2, 2, 2, 488, 486, 3, 2, 2, 2, 489, 494, 5, 24, 13, 2, 490,
	491, 7, 90, 2, 2, 491, 493, 5, 24, 13, 2, 492, 490, 3, 2, 2, 2, 493, 496,
	3, 2, 2, 2, 494, 492, 3, 2, 2, 2, 494, 495, 3, 2, 2, 2, 495, 87, 3, 2,
	2, 2, 496, 494, 3, 2, 2, 2, 497, 498, 5, 20, 11, 2, 498, 499, 7, 76, 2,
	2, 499, 500, 5, 82, 42, 2, 500, 89, 3, 2, 2, 2, 501, 506, 5, 88, 45, 2,
	502, 503, 7, 92, 2, 2, 503, 505, 5, 88, 45, 2, 504, 502, 3, 2, 2, 2, 505,
	508, 3, 2, 2, 2, 506, 504, 3, 2, 2, 2, 506, 507, 3, 2, 2, 2, 507, 91, 3,
	2, 2, 2, 508, 506, 3, 2, 2, 2, 509, 510, 7, 93, 2, 2, 510, 511, 7, 138,
	2, 2, 511, 512, 5, 90, 46, 2, 512, 513, 7, 94, 2, 2, 513, 93, 3, 2, 2,
	2, 514, 515, 7, 95, 2, 2, 515, 516, 7, 138, 2, 2, 516, 517, 5, 90, 46,
	2, 517, 518, 7, 94, 2, 2, 518, 95, 3, 2, 2, 2, 519, 520, 5, 20, 11, 2,
	520, 521, 7, 96, 2, 2, 521, 522, 5, 82, 42, 2, 522, 97, 3, 2, 2, 2, 523,
	528, 5, 96, 49, 2, 524, 525, 7, 92, 2, 2, 525, 527, 5, 96, 49, 2, 526,
	524, 3, 2, 2, 2, 527, 530, 3, 2, 2, 2, 528, 526, 3, 2, 2, 2, 528, 529,
	3, 2, 2, 2, 529, 99, 3, 2, 2, 2, 530, 528, 3, 2, 2, 2, 531, 532, 7, 97,
	2, 2, 532, 533, 7, 138, 2, 2, 533, 534, 5, 98, 50, 2, 534, 535, 7, 94,
	2, 2, 535, 101, 3, 2, 2, 2, 536, 537, 5, 86, 44, 2, 537, 538, 7, 76, 2,
	2, 538, 539, 5, 84, 43, 2, 539, 103, 3, 2, 2, 2, 540, 541, 5, 20, 11, 2,
	541, 542, 7, 76, 2, 2, 542, 543, 7, 98, 2, 2, 543, 544, 5, 82, 42, 2, 544,
	105, 3, 2, 2, 2, 545, 546, 5, 20, 11, 2, 546, 547, 7, 87, 2, 2, 547, 548,
	5, 86, 44, 2, 548, 549, 7, 88, 2, 2, 549, 550, 7, 76, 2, 2, 550, 551, 5,
	70, 36, 2, 551, 559, 3, 2, 2, 2, 552, 553, 5, 20, 11, 2, 553, 554, 7, 87,
	2, 2, 554, 555, 7, 88, 2, 2, 555, 556, 7, 76, 2, 2, 556, 557, 5, 70, 36,
	2, 557, 559, 3, 2, 2, 2, 558, 545, 3, 2, 2, 2, 558, 552, 3, 2, 2, 2, 559,
	107, 3, 2, 2, 2, 560, 561, 5, 20, 11, 2, 561, 562, 7, 87, 2, 2, 562, 563,
	5, 86, 44, 2, 563, 564, 7, 88, 2, 2, 564, 565, 7, 99, 2, 2, 565, 566, 5,
	160, 81, 2, 566, 574, 3, 2, 2, 2, 567, 568, 5, 20, 11, 2, 568, 569, 7,
	87, 2, 2, 569, 570, 7, 88, 2, 2, 570, 571, 7, 99, 2, 2, 571, 572, 5, 160,
	81, 2, 572, 574, 3, 2, 2, 2, 573, 560, 3, 2, 2, 2, 573, 567, 3, 2, 2, 2,
	574, 109, 3, 2, 2, 2, 575, 580, 5, 102, 52, 2, 576, 580, 5, 104, 53, 2,
	577, 580, 5, 106, 54, 2, 578, 580, 5, 108, 55, 2, 579, 575, 3, 2, 2, 2,
	579, 576, 3, 2, 2, 2, 579, 577, 3, 2, 2, 2, 579, 578, 3, 2, 2, 2, 580,
	111, 3, 2, 2, 2, 581, 582, 7, 100, 2, 2, 582, 587, 5, 110, 56, 2, 583,
	584, 7, 101, 2, 2, 584, 586, 5, 110, 56, 2, 585, 583, 3, 2, 2, 2, 586,
	589, 3, 2, 2, 2, 587, 585, 3, 2, 2, 2, 587, 588, 3, 2, 2, 2, 588, 113,
	3, 2, 2, 2, 589, 587, 3, 2, 2, 2, 590, 595, 5, 112, 57, 2, 591, 595, 5,
	92, 47, 2, 592, 595, 5, 94, 48, 2, 593, 595, 5, 100, 51, 2, 594, 590, 3,
	2, 2, 2, 594, 591, 3, 2, 2, 2, 594, 592, 3, 2, 2, 2, 594, 593, 3, 2, 2,
	2, 595, 115, 3, 2, 2, 2, 596, 604, 5, 20, 11, 2, 597, 598, 5, 48, 25, 2,
	598, 599, 7, 71, 2, 2, 599, 600, 5, 46, 24, 2, 600, 604, 3, 2, 2, 2, 601,
	602, 7, 71, 2, 2, 602, 604, 5, 46, 24, 2, 603, 596, 3, 2, 2, 2, 603, 597,
	3, 2, 2, 2, 603, 601, 3, 2, 2, 2, 604, 117, 3, 2, 2, 2, 605, 610, 5, 116,
	59, 2, 606, 607, 7, 90, 2, 2, 607, 609, 5, 116, 59, 2, 608, 606, 3, 2,
	2, 2, 609, 612, 3, 2, 2, 2, 610, 608, 3, 2, 2, 2, 610, 611, 3, 2, 2, 2,
	611, 119, 3, 2, 2, 2, 612, 610, 3, 2, 2, 2, 613, 614, 5, 118, 60, 2, 614,
	615, 7, 102, 2, 2, 615, 616, 5, 84, 43, 2, 616, 121, 3, 2, 2, 2, 617, 618,
	9, 13, 2, 2, 618, 123, 3, 2, 2, 2, 619, 620, 7, 108, 2, 2, 620, 621, 5,
	70, 36, 2, 621, 125, 3, 2, 2, 2, 622, 623, 5, 46, 24, 2, 623, 624, 7, 87,
	2, 2, 624, 625, 5, 84, 43, 2, 625, 626, 7, 88, 2, 2, 626, 632, 3, 2, 2,
	2, 627, 628, 5, 46, 24, 2, 628, 629, 7, 87, 2, 2, 629, 630, 7, 88, 2, 2,
	630, 632, 3, 2, 2, 2, 631, 622, 3, 2, 2, 2, 631, 627, 3, 2, 2, 2, 632,
	127, 3, 2, 2, 2, 633, 634, 7, 109, 2, 2, 634, 635, 5, 70, 36, 2, 635, 129,
	3, 2, 2, 2, 636, 637, 7, 110, 2, 2, 637, 638, 5, 70, 36, 2, 638, 639, 7,
	111, 2, 2, 639, 640, 5, 168, 85, 2, 640, 131, 3, 2, 2, 2, 641, 642, 8,
	67, 1, 2, 642, 651, 5, 120, 61, 2, 643, 651, 5, 122, 62, 2, 644, 651, 5,
	124, 63, 2, 645, 651, 5, 126, 64, 2, 646, 651, 5, 128, 65, 2, 647, 651,
	5, 130, 66, 2, 648, 651, 5, 168, 85, 2, 649, 651, 5, 166, 84, 2, 650, 641,
	3, 2, 2, 2, 650, 643, 3, 2, 2, 2, 650, 644, 3, 2, 2, 2, 650, 645, 3, 2,
	2, 2, 650, 646, 3, 2, 2, 2, 650, 647, 3, 2, 2, 2, 650, 648, 3, 2, 2, 2,
	650, 649, 3, 2, 2, 2, 651, 662, 3, 2, 2, 2, 652, 653, 12, 8, 2, 2, 653,
	661, 7, 112, 2, 2, 654, 655, 12, 7, 2, 2, 655, 656, 7, 113, 2, 2, 656,
	661, 5, 70, 36, 2, 657, 658, 12, 6, 2, 2, 658, 659, 7, 114, 2, 2, 659,
	661, 5, 70, 36, 2, 660, 652, 3, 2, 2, 2, 660, 654, 3, 2, 2, 2, 660, 657,
	3, 2, 2, 2, 661, 664, 3, 2, 2, 2, 662, 660, 3, 2, 2, 2, 662, 663, 3, 2,
	2, 2, 663, 133, 3, 2, 2, 2, 664, 662, 3, 2, 2, 2, 665, 666, 5, 132, 67,
	2, 666, 667, 7, 112, 2, 2, 667, 677, 3, 2, 2, 2, 668, 669, 5, 132, 67,
	2, 669, 670, 7, 113, 2, 2, 670, 671, 5, 70, 36, 2, 671, 677, 3, 2, 2, 2,
	672, 673, 5, 132, 67, 2, 673, 674, 7, 114, 2, 2, 674, 675, 5, 70, 36, 2,
	675, 677, 3, 2, 2, 2, 676, 665, 3, 2, 2, 2, 676, 668, 3, 2, 2, 2, 676,
	672, 3, 2, 2, 2, 677, 135, 3, 2, 2, 2, 678, 679, 7, 115, 2, 2, 679, 680,
	5, 70, 36, 2, 680, 681, 7, 116, 2, 2, 681, 682, 5, 160, 81, 2, 682, 137,
	3, 2, 2, 2, 683, 684, 7, 117, 2, 2, 684, 685, 5, 70, 36, 2, 685, 686, 7,
	116, 2, 2, 686, 687, 5, 160, 81, 2, 687, 139, 3, 2, 2, 2, 688, 689, 7,
	118, 2, 2, 689, 690, 5, 20, 11, 2, 690, 691, 7, 76, 2, 2, 691, 692, 5,
	70, 36, 2, 692, 693, 7, 119, 2, 2, 693, 694, 5, 70, 36, 2, 694, 695, 7,
	120, 2, 2, 695, 696, 5, 82, 42, 2, 696, 697, 7, 116, 2, 2, 697, 698, 5,
	160, 81, 2, 698, 709, 3, 2, 2, 2, 699, 700, 7, 118, 2, 2, 700, 701, 5,
	20, 11, 2, 701, 702, 7, 76, 2, 2, 702, 703, 5, 70, 36, 2, 703, 704, 7,
	119, 2, 2, 704, 705, 5, 70, 36, 2, 705, 706, 7, 116, 2, 2, 706, 707, 5,
	160, 81, 2, 707, 709, 3, 2, 2, 2, 708, 688, 3, 2, 2, 2, 708, 699, 3, 2,
	2, 2, 709, 141, 3, 2, 2, 2, 710, 715, 5, 134, 68, 2, 711, 715, 5, 136,
	69, 2, 712, 715, 5, 138, 70, 2, 713, 715, 5, 140, 71, 2, 714, 710, 3, 2,
	2, 2, 714, 711, 3, 2, 2, 2, 714, 712, 3, 2, 2, 2, 714, 713, 3, 2, 2, 2,
	715, 143, 3, 2, 2, 2, 716, 717, 7, 121, 2, 2, 717, 718, 5, 70, 36, 2, 718,
	719, 7, 122, 2, 2, 719, 720, 5, 160, 81, 2, 720, 721, 7, 123, 2, 2, 721,
	722, 5, 160, 81, 2, 722, 145, 3, 2, 2, 2, 723, 724, 7, 124, 2, 2, 724,
	725, 5, 70, 36, 2, 725, 726, 7, 122, 2, 2, 726, 727, 5, 160, 81, 2, 727,
	147, 3, 2, 2, 2, 728, 729, 7, 125, 2, 2, 729, 730, 5, 70, 36, 2, 730, 731,
	7, 122, 2, 2, 731, 732, 5, 160, 81, 2, 732, 149, 3, 2, 2, 2, 733, 738,
	5, 132, 67, 2, 734, 738, 5, 142, 72, 2, 735, 738, 5, 144, 73, 2, 736, 738,
	5, 146, 74, 2, 737, 733, 3, 2, 2, 2, 737, 734, 3, 2, 2, 2, 737, 735, 3,
	2, 2, 2, 737, 736, 3, 2, 2, 2, 738, 151, 3, 2, 2, 2, 739, 740, 5, 20, 11,
	2, 740, 741, 7, 96, 2, 2, 741, 153, 3, 2, 2, 2, 742, 743, 7, 126, 2, 2,
	743, 744, 5, 82, 42, 2, 744, 745, 7, 96, 2, 2, 745, 155, 3, 2, 2, 2, 746,
	747, 7, 127, 2, 2, 747, 748, 7, 96, 2, 2, 748, 157, 3, 2, 2, 2, 749, 753,
	5, 152, 77, 2, 750, 753, 5, 154, 78, 2, 751, 753, 5, 156, 79, 2, 752, 749,
	3, 2, 2, 2, 752, 750, 3, 2, 2, 2, 752, 751, 3, 2, 2, 2, 753, 159, 3, 2,
	2, 2, 754, 760, 5, 150, 76, 2, 755, 756, 5, 158, 80, 2, 756, 757, 5, 160,
	81, 2, 757, 760, 3, 2, 2, 2, 758, 760, 5, 158, 80, 2, 759, 754, 3, 2, 2,
	2, 759, 755, 3, 2, 2, 2, 759, 758, 3, 2, 2, 2, 760, 161, 3, 2, 2, 2, 761,
	766, 5, 160, 81, 2, 762, 763, 7, 92, 2, 2, 763, 765, 5, 160, 81, 2, 764,
	762, 3, 2, 2, 2, 765, 768, 3, 2, 2, 2, 766, 764, 3, 2, 2, 2, 766, 767,
	3, 2, 2, 2, 767, 163, 3, 2, 2, 2, 768, 766, 3, 2, 2, 2, 769, 774, 5, 114,
	58, 2, 770, 771, 7, 92, 2, 2, 771, 773, 5, 114, 58, 2, 772, 770, 3, 2,
	2, 2, 773, 776, 3, 2, 2, 2, 774, 772, 3, 2, 2, 2, 774, 775, 3, 2, 2, 2,
	775, 165, 3, 2, 2, 2, 776, 774, 3, 2, 2, 2, 777, 778, 7, 138, 2, 2, 778,
	779, 5, 164, 83, 2, 779, 780, 7, 92, 2, 2, 780, 781, 5, 162, 82, 2, 781,
	782, 7, 94, 2, 2, 782, 167, 3, 2, 2, 2, 783, 784, 7, 138, 2, 2, 784, 785,
	5, 162, 82, 2, 785, 786, 7, 94, 2, 2, 786, 169, 3, 2, 2, 2, 787, 790, 5,
	164, 83, 2, 788, 790, 5, 172, 87, 2, 789, 787, 3, 2, 2, 2, 789, 788, 3,
	2, 2, 2, 790, 171, 3, 2, 2, 2, 791, 792, 7, 128, 2, 2, 792, 796, 5, 10,
	6, 2, 793, 794, 7, 129, 2, 2, 794, 796, 5, 10, 6, 2, 795, 791, 3, 2, 2,
	2, 795, 793, 3, 2, 2, 2, 796, 173, 3, 2, 2, 2, 60, 186, 200, 208, 217,
	220, 226, 228, 233, 261, 269, 279, 281, 292, 299, 310, 318, 326, 335, 347,
	354, 362, 371, 380, 390, 399, 404, 415, 426, 434, 442, 454, 466, 478, 486,
	494, 506, 528, 558, 573, 579, 587, 594, 603, 610, 631, 650, 660, 662, 676,
	708, 714, 737, 752, 759, 766, 774, 789, 795,
}
var literalNames = []string{
	"", "'A'", "'B'", "'C'", "'D'", "'E'", "'F'", "'G'", "'H'", "'I'", "'J'",
	"'K'", "'L'", "'M'", "'N'", "'O'", "'P'", "'Q'", "'R'", "'S'", "'T'", "'U'",
	"'V'", "'W'", "'X'", "'Y'", "'Z'", "'a'", "'b'", "'c'", "'d'", "'e'", "'f'",
	"'g'", "'h'", "'i'", "'j'", "'k'", "'l'", "'m'", "'n'", "'o'", "'p'", "'q'",
	"'r'", "'s'", "'t'", "'u'", "'v'", "'w'", "'x'", "'y'", "'z'", "'0'", "'1'",
	"'2'", "'3'", "'4'", "'5'", "'6'", "'7'", "'8'", "'9'", "'\"'", "'''",
	"'#'", "'#X'", "'.'", "'@'", "'!'", "'*'", "'/'", "'+'", "'-'", "'='",
	"'\uFFFD='", "'<='", "'>='", "'<'", "'>'", "'<<'", "'>>'", "'&'", "'|'",
	"'\uFFFD'", "'('", "')'", "'->'", "','", "'VALOF'", "';'", "'MANIFEST'",
	"'$)'", "'STATIC'", "':'", "'GLOBAL'", "'VEC'", "'BE'", "'LET'", "'AND'",
	"':='", "'BREAK'", "'LOOP'", "'ENDCASE'", "'RETURN'", "'FINISH'", "'GOTO'",
	"'RESULTIS'", "'SWITCHON'", "'INTO'", "'REPEAT'", "'REPEATUNTIL'", "'REPEATWHILE'",
	"'UNTIL'", "'DO'", "'WHILE'", "'FOR'", "'TO'", "'BY'", "'TEST'", "'THEN'",
	"'ELSE'", "'IF'", "'UNLESS'", "'CASE'", "'DEFAULT'", "'GET'", "'SECTION'",
	"", "", "'REM'", "'EQV'", "'NEQV'", "'TRUE'", "'FALSE'", "'TABLE'", "'$('",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "Comment", "WS", "Rem", "Eqv", "Neqv", "True_", "False_", "Table",
	"Left_dollar_open",
}

var ruleNames = []string{
	"letter", "octal_digit", "hex_digit", "digit", "string_constant", "character_constant",
	"octal_number", "hex_number", "number", "identifier", "one_character",
	"name", "address_op", "mult_op", "add_op", "rel_op", "shift_op", "and_op",
	"or_op", "eqv_op", "not_op", "element", "primary_E", "vector_E", "address_E",
	"mult_E", "add_E", "rel_E", "shift_E", "not_E", "and_E", "or_E", "eqv_E",
	"conditional_E", "expression", "c_element", "c_mult_E", "c_add_E", "c_shift_E",
	"c_and_E", "constant_expression", "expression_list", "name_list", "manifest_item",
	"manifest_list", "manifest_declaration", "static_declaration", "global_item",
	"global_list", "global_declaration", "simple_definition", "vector_definition",
	"function_definition", "routine_definition", "definition", "simultaneous_declaration",
	"declaration", "lhse", "left_hand_side_list", "assignment", "simple_command",
	"goto_command", "routine_command", "resultis_command", "switchon_command",
	"repeatable_command", "repeated_command", "until_command", "while_command",
	"for_command", "repetitive_command", "test_command", "if_command", "unless_command",
	"unlabelled_command", "label_prefix", "case_prefix", "default_prefix",
	"prefix_", "command", "command_list", "declaration_part", "block", "compound_command",
	"program", "directive",
}

type bcplParser struct {
	*antlr.BaseParser
}

// NewbcplParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *bcplParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewbcplParser(input antlr.TokenStream) *bcplParser {
	this := new(bcplParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "bcpl.g4"

	return this
}

// bcplParser tokens.
const (
	bcplParserEOF              = antlr.TokenEOF
	bcplParserT__0             = 1
	bcplParserT__1             = 2
	bcplParserT__2             = 3
	bcplParserT__3             = 4
	bcplParserT__4             = 5
	bcplParserT__5             = 6
	bcplParserT__6             = 7
	bcplParserT__7             = 8
	bcplParserT__8             = 9
	bcplParserT__9             = 10
	bcplParserT__10            = 11
	bcplParserT__11            = 12
	bcplParserT__12            = 13
	bcplParserT__13            = 14
	bcplParserT__14            = 15
	bcplParserT__15            = 16
	bcplParserT__16            = 17
	bcplParserT__17            = 18
	bcplParserT__18            = 19
	bcplParserT__19            = 20
	bcplParserT__20            = 21
	bcplParserT__21            = 22
	bcplParserT__22            = 23
	bcplParserT__23            = 24
	bcplParserT__24            = 25
	bcplParserT__25            = 26
	bcplParserT__26            = 27
	bcplParserT__27            = 28
	bcplParserT__28            = 29
	bcplParserT__29            = 30
	bcplParserT__30            = 31
	bcplParserT__31            = 32
	bcplParserT__32            = 33
	bcplParserT__33            = 34
	bcplParserT__34            = 35
	bcplParserT__35            = 36
	bcplParserT__36            = 37
	bcplParserT__37            = 38
	bcplParserT__38            = 39
	bcplParserT__39            = 40
	bcplParserT__40            = 41
	bcplParserT__41            = 42
	bcplParserT__42            = 43
	bcplParserT__43            = 44
	bcplParserT__44            = 45
	bcplParserT__45            = 46
	bcplParserT__46            = 47
	bcplParserT__47            = 48
	bcplParserT__48            = 49
	bcplParserT__49            = 50
	bcplParserT__50            = 51
	bcplParserT__51            = 52
	bcplParserT__52            = 53
	bcplParserT__53            = 54
	bcplParserT__54            = 55
	bcplParserT__55            = 56
	bcplParserT__56            = 57
	bcplParserT__57            = 58
	bcplParserT__58            = 59
	bcplParserT__59            = 60
	bcplParserT__60            = 61
	bcplParserT__61            = 62
	bcplParserT__62            = 63
	bcplParserT__63            = 64
	bcplParserT__64            = 65
	bcplParserT__65            = 66
	bcplParserT__66            = 67
	bcplParserT__67            = 68
	bcplParserT__68            = 69
	bcplParserT__69            = 70
	bcplParserT__70            = 71
	bcplParserT__71            = 72
	bcplParserT__72            = 73
	bcplParserT__73            = 74
	bcplParserT__74            = 75
	bcplParserT__75            = 76
	bcplParserT__76            = 77
	bcplParserT__77            = 78
	bcplParserT__78            = 79
	bcplParserT__79            = 80
	bcplParserT__80            = 81
	bcplParserT__81            = 82
	bcplParserT__82            = 83
	bcplParserT__83            = 84
	bcplParserT__84            = 85
	bcplParserT__85            = 86
	bcplParserT__86            = 87
	bcplParserT__87            = 88
	bcplParserT__88            = 89
	bcplParserT__89            = 90
	bcplParserT__90            = 91
	bcplParserT__91            = 92
	bcplParserT__92            = 93
	bcplParserT__93            = 94
	bcplParserT__94            = 95
	bcplParserT__95            = 96
	bcplParserT__96            = 97
	bcplParserT__97            = 98
	bcplParserT__98            = 99
	bcplParserT__99            = 100
	bcplParserT__100           = 101
	bcplParserT__101           = 102
	bcplParserT__102           = 103
	bcplParserT__103           = 104
	bcplParserT__104           = 105
	bcplParserT__105           = 106
	bcplParserT__106           = 107
	bcplParserT__107           = 108
	bcplParserT__108           = 109
	bcplParserT__109           = 110
	bcplParserT__110           = 111
	bcplParserT__111           = 112
	bcplParserT__112           = 113
	bcplParserT__113           = 114
	bcplParserT__114           = 115
	bcplParserT__115           = 116
	bcplParserT__116           = 117
	bcplParserT__117           = 118
	bcplParserT__118           = 119
	bcplParserT__119           = 120
	bcplParserT__120           = 121
	bcplParserT__121           = 122
	bcplParserT__122           = 123
	bcplParserT__123           = 124
	bcplParserT__124           = 125
	bcplParserT__125           = 126
	bcplParserT__126           = 127
	bcplParserComment          = 128
	bcplParserWS               = 129
	bcplParserRem              = 130
	bcplParserEqv              = 131
	bcplParserNeqv             = 132
	bcplParserTrue_            = 133
	bcplParserFalse_           = 134
	bcplParserTable            = 135
	bcplParserLeft_dollar_open = 136
)

// bcplParser rules.
const (
	bcplParserRULE_letter                   = 0
	bcplParserRULE_octal_digit              = 1
	bcplParserRULE_hex_digit                = 2
	bcplParserRULE_digit                    = 3
	bcplParserRULE_string_constant          = 4
	bcplParserRULE_character_constant       = 5
	bcplParserRULE_octal_number             = 6
	bcplParserRULE_hex_number               = 7
	bcplParserRULE_number                   = 8
	bcplParserRULE_identifier               = 9
	bcplParserRULE_one_character            = 10
	bcplParserRULE_name                     = 11
	bcplParserRULE_address_op               = 12
	bcplParserRULE_mult_op                  = 13
	bcplParserRULE_add_op                   = 14
	bcplParserRULE_rel_op                   = 15
	bcplParserRULE_shift_op                 = 16
	bcplParserRULE_and_op                   = 17
	bcplParserRULE_or_op                    = 18
	bcplParserRULE_eqv_op                   = 19
	bcplParserRULE_not_op                   = 20
	bcplParserRULE_element                  = 21
	bcplParserRULE_primary_E                = 22
	bcplParserRULE_vector_E                 = 23
	bcplParserRULE_address_E                = 24
	bcplParserRULE_mult_E                   = 25
	bcplParserRULE_add_E                    = 26
	bcplParserRULE_rel_E                    = 27
	bcplParserRULE_shift_E                  = 28
	bcplParserRULE_not_E                    = 29
	bcplParserRULE_and_E                    = 30
	bcplParserRULE_or_E                     = 31
	bcplParserRULE_eqv_E                    = 32
	bcplParserRULE_conditional_E            = 33
	bcplParserRULE_expression               = 34
	bcplParserRULE_c_element                = 35
	bcplParserRULE_c_mult_E                 = 36
	bcplParserRULE_c_add_E                  = 37
	bcplParserRULE_c_shift_E                = 38
	bcplParserRULE_c_and_E                  = 39
	bcplParserRULE_constant_expression      = 40
	bcplParserRULE_expression_list          = 41
	bcplParserRULE_name_list                = 42
	bcplParserRULE_manifest_item            = 43
	bcplParserRULE_manifest_list            = 44
	bcplParserRULE_manifest_declaration     = 45
	bcplParserRULE_static_declaration       = 46
	bcplParserRULE_global_item              = 47
	bcplParserRULE_global_list              = 48
	bcplParserRULE_global_declaration       = 49
	bcplParserRULE_simple_definition        = 50
	bcplParserRULE_vector_definition        = 51
	bcplParserRULE_function_definition      = 52
	bcplParserRULE_routine_definition       = 53
	bcplParserRULE_definition               = 54
	bcplParserRULE_simultaneous_declaration = 55
	bcplParserRULE_declaration              = 56
	bcplParserRULE_lhse                     = 57
	bcplParserRULE_left_hand_side_list      = 58
	bcplParserRULE_assignment               = 59
	bcplParserRULE_simple_command           = 60
	bcplParserRULE_goto_command             = 61
	bcplParserRULE_routine_command          = 62
	bcplParserRULE_resultis_command         = 63
	bcplParserRULE_switchon_command         = 64
	bcplParserRULE_repeatable_command       = 65
	bcplParserRULE_repeated_command         = 66
	bcplParserRULE_until_command            = 67
	bcplParserRULE_while_command            = 68
	bcplParserRULE_for_command              = 69
	bcplParserRULE_repetitive_command       = 70
	bcplParserRULE_test_command             = 71
	bcplParserRULE_if_command               = 72
	bcplParserRULE_unless_command           = 73
	bcplParserRULE_unlabelled_command       = 74
	bcplParserRULE_label_prefix             = 75
	bcplParserRULE_case_prefix              = 76
	bcplParserRULE_default_prefix           = 77
	bcplParserRULE_prefix_                  = 78
	bcplParserRULE_command                  = 79
	bcplParserRULE_command_list             = 80
	bcplParserRULE_declaration_part         = 81
	bcplParserRULE_block                    = 82
	bcplParserRULE_compound_command         = 83
	bcplParserRULE_program                  = 84
	bcplParserRULE_directive                = 85
)

// ILetterContext is an interface to support dynamic dispatch.
type ILetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLetterContext differentiates from other interfaces.
	IsLetterContext()
}

type LetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetterContext() *LetterContext {
	var p = new(LetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_letter
	return p
}

func (*LetterContext) IsLetterContext() {}

func NewLetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetterContext {
	var p = new(LetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_letter

	return p
}

func (s *LetterContext) GetParser() antlr.Parser { return s.parser }
func (s *LetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterLetter(s)
	}
}

func (s *LetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitLetter(s)
	}
}

func (p *bcplParser) Letter() (localctx ILetterContext) {
	this := p
	_ = this

	localctx = NewLetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, bcplParserRULE_letter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(172)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<bcplParserT__0)|(1<<bcplParserT__1)|(1<<bcplParserT__2)|(1<<bcplParserT__3)|(1<<bcplParserT__4)|(1<<bcplParserT__5)|(1<<bcplParserT__6)|(1<<bcplParserT__7)|(1<<bcplParserT__8)|(1<<bcplParserT__9)|(1<<bcplParserT__10)|(1<<bcplParserT__11)|(1<<bcplParserT__12)|(1<<bcplParserT__13)|(1<<bcplParserT__14)|(1<<bcplParserT__15)|(1<<bcplParserT__16)|(1<<bcplParserT__17)|(1<<bcplParserT__18)|(1<<bcplParserT__19)|(1<<bcplParserT__20)|(1<<bcplParserT__21)|(1<<bcplParserT__22)|(1<<bcplParserT__23)|(1<<bcplParserT__24)|(1<<bcplParserT__25)|(1<<bcplParserT__26)|(1<<bcplParserT__27)|(1<<bcplParserT__28)|(1<<bcplParserT__29)|(1<<bcplParserT__30))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(bcplParserT__31-32))|(1<<(bcplParserT__32-32))|(1<<(bcplParserT__33-32))|(1<<(bcplParserT__34-32))|(1<<(bcplParserT__35-32))|(1<<(bcplParserT__36-32))|(1<<(bcplParserT__37-32))|(1<<(bcplParserT__38-32))|(1<<(bcplParserT__39-32))|(1<<(bcplParserT__40-32))|(1<<(bcplParserT__41-32))|(1<<(bcplParserT__42-32))|(1<<(bcplParserT__43-32))|(1<<(bcplParserT__44-32))|(1<<(bcplParserT__45-32))|(1<<(bcplParserT__46-32))|(1<<(bcplParserT__47-32))|(1<<(bcplParserT__48-32))|(1<<(bcplParserT__49-32))|(1<<(bcplParserT__50-32))|(1<<(bcplParserT__51-32)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOctal_digitContext is an interface to support dynamic dispatch.
type IOctal_digitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOctal_digitContext differentiates from other interfaces.
	IsOctal_digitContext()
}

type Octal_digitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOctal_digitContext() *Octal_digitContext {
	var p = new(Octal_digitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_octal_digit
	return p
}

func (*Octal_digitContext) IsOctal_digitContext() {}

func NewOctal_digitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Octal_digitContext {
	var p = new(Octal_digitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_octal_digit

	return p
}

func (s *Octal_digitContext) GetParser() antlr.Parser { return s.parser }
func (s *Octal_digitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Octal_digitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Octal_digitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterOctal_digit(s)
	}
}

func (s *Octal_digitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitOctal_digit(s)
	}
}

func (p *bcplParser) Octal_digit() (localctx IOctal_digitContext) {
	this := p
	_ = this

	localctx = NewOctal_digitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, bcplParserRULE_octal_digit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(174)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(bcplParserT__52-53))|(1<<(bcplParserT__53-53))|(1<<(bcplParserT__54-53))|(1<<(bcplParserT__55-53))|(1<<(bcplParserT__56-53))|(1<<(bcplParserT__57-53))|(1<<(bcplParserT__58-53))|(1<<(bcplParserT__59-53)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IHex_digitContext is an interface to support dynamic dispatch.
type IHex_digitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHex_digitContext differentiates from other interfaces.
	IsHex_digitContext()
}

type Hex_digitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHex_digitContext() *Hex_digitContext {
	var p = new(Hex_digitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_hex_digit
	return p
}

func (*Hex_digitContext) IsHex_digitContext() {}

func NewHex_digitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hex_digitContext {
	var p = new(Hex_digitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_hex_digit

	return p
}

func (s *Hex_digitContext) GetParser() antlr.Parser { return s.parser }
func (s *Hex_digitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hex_digitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hex_digitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterHex_digit(s)
	}
}

func (s *Hex_digitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitHex_digit(s)
	}
}

func (p *bcplParser) Hex_digit() (localctx IHex_digitContext) {
	this := p
	_ = this

	localctx = NewHex_digitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, bcplParserRULE_hex_digit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(176)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<bcplParserT__0)|(1<<bcplParserT__1)|(1<<bcplParserT__2)|(1<<bcplParserT__3)|(1<<bcplParserT__4)|(1<<bcplParserT__5))) != 0) || (((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(bcplParserT__52-53))|(1<<(bcplParserT__53-53))|(1<<(bcplParserT__54-53))|(1<<(bcplParserT__55-53))|(1<<(bcplParserT__56-53))|(1<<(bcplParserT__57-53))|(1<<(bcplParserT__58-53))|(1<<(bcplParserT__59-53))|(1<<(bcplParserT__60-53))|(1<<(bcplParserT__61-53)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDigitContext is an interface to support dynamic dispatch.
type IDigitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDigitContext differentiates from other interfaces.
	IsDigitContext()
}

type DigitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDigitContext() *DigitContext {
	var p = new(DigitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_digit
	return p
}

func (*DigitContext) IsDigitContext() {}

func NewDigitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DigitContext {
	var p = new(DigitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_digit

	return p
}

func (s *DigitContext) GetParser() antlr.Parser { return s.parser }
func (s *DigitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DigitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterDigit(s)
	}
}

func (s *DigitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitDigit(s)
	}
}

func (p *bcplParser) Digit() (localctx IDigitContext) {
	this := p
	_ = this

	localctx = NewDigitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, bcplParserRULE_digit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(178)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(bcplParserT__52-53))|(1<<(bcplParserT__53-53))|(1<<(bcplParserT__54-53))|(1<<(bcplParserT__55-53))|(1<<(bcplParserT__56-53))|(1<<(bcplParserT__57-53))|(1<<(bcplParserT__58-53))|(1<<(bcplParserT__59-53))|(1<<(bcplParserT__60-53))|(1<<(bcplParserT__61-53)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IString_constantContext is an interface to support dynamic dispatch.
type IString_constantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsString_constantContext differentiates from other interfaces.
	IsString_constantContext()
}

type String_constantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_constantContext() *String_constantContext {
	var p = new(String_constantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_string_constant
	return p
}

func (*String_constantContext) IsString_constantContext() {}

func NewString_constantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_constantContext {
	var p = new(String_constantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_string_constant

	return p
}

func (s *String_constantContext) GetParser() antlr.Parser { return s.parser }
func (s *String_constantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_constantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_constantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterString_constant(s)
	}
}

func (s *String_constantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitString_constant(s)
	}
}

func (p *bcplParser) String_constant() (localctx IString_constantContext) {
	this := p
	_ = this

	localctx = NewString_constantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, bcplParserRULE_string_constant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(180)
		p.Match(bcplParserT__62)
	}
	p.SetState(184)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<bcplParserT__0)|(1<<bcplParserT__1)|(1<<bcplParserT__2)|(1<<bcplParserT__3)|(1<<bcplParserT__4)|(1<<bcplParserT__5)|(1<<bcplParserT__6)|(1<<bcplParserT__7)|(1<<bcplParserT__8)|(1<<bcplParserT__9)|(1<<bcplParserT__10)|(1<<bcplParserT__11)|(1<<bcplParserT__12)|(1<<bcplParserT__13)|(1<<bcplParserT__14)|(1<<bcplParserT__15)|(1<<bcplParserT__16)|(1<<bcplParserT__17)|(1<<bcplParserT__18)|(1<<bcplParserT__19)|(1<<bcplParserT__20)|(1<<bcplParserT__21)|(1<<bcplParserT__22)|(1<<bcplParserT__23)|(1<<bcplParserT__24)|(1<<bcplParserT__25)|(1<<bcplParserT__26)|(1<<bcplParserT__27)|(1<<bcplParserT__28)|(1<<bcplParserT__29)|(1<<bcplParserT__30))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(bcplParserT__31-32))|(1<<(bcplParserT__32-32))|(1<<(bcplParserT__33-32))|(1<<(bcplParserT__34-32))|(1<<(bcplParserT__35-32))|(1<<(bcplParserT__36-32))|(1<<(bcplParserT__37-32))|(1<<(bcplParserT__38-32))|(1<<(bcplParserT__39-32))|(1<<(bcplParserT__40-32))|(1<<(bcplParserT__41-32))|(1<<(bcplParserT__42-32))|(1<<(bcplParserT__43-32))|(1<<(bcplParserT__44-32))|(1<<(bcplParserT__45-32))|(1<<(bcplParserT__46-32))|(1<<(bcplParserT__47-32))|(1<<(bcplParserT__48-32))|(1<<(bcplParserT__49-32))|(1<<(bcplParserT__50-32))|(1<<(bcplParserT__51-32))|(1<<(bcplParserT__52-32))|(1<<(bcplParserT__53-32))|(1<<(bcplParserT__54-32))|(1<<(bcplParserT__55-32))|(1<<(bcplParserT__56-32))|(1<<(bcplParserT__57-32))|(1<<(bcplParserT__58-32))|(1<<(bcplParserT__59-32))|(1<<(bcplParserT__60-32))|(1<<(bcplParserT__61-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(bcplParserT__63-64))|(1<<(bcplParserT__64-64))|(1<<(bcplParserT__65-64))|(1<<(bcplParserT__66-64))|(1<<(bcplParserT__67-64))|(1<<(bcplParserT__68-64))|(1<<(bcplParserT__69-64))|(1<<(bcplParserT__70-64))|(1<<(bcplParserT__71-64))|(1<<(bcplParserT__72-64))|(1<<(bcplParserT__73-64))|(1<<(bcplParserT__74-64))|(1<<(bcplParserT__75-64))|(1<<(bcplParserT__76-64))|(1<<(bcplParserT__77-64))|(1<<(bcplParserT__78-64))|(1<<(bcplParserT__79-64))|(1<<(bcplParserT__80-64))|(1<<(bcplParserT__81-64))|(1<<(bcplParserT__82-64))|(1<<(bcplParserT__83-64))|(1<<(bcplParserT__84-64))|(1<<(bcplParserT__85-64))|(1<<(bcplParserT__86-64))|(1<<(bcplParserT__87-64))|(1<<(bcplParserT__88-64))|(1<<(bcplParserT__89-64))|(1<<(bcplParserT__90-64))|(1<<(bcplParserT__91-64))|(1<<(bcplParserT__92-64))|(1<<(bcplParserT__93-64))|(1<<(bcplParserT__94-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(bcplParserT__95-96))|(1<<(bcplParserT__96-96))|(1<<(bcplParserT__97-96))|(1<<(bcplParserT__98-96))|(1<<(bcplParserT__99-96))|(1<<(bcplParserT__100-96))|(1<<(bcplParserT__101-96))|(1<<(bcplParserT__102-96))|(1<<(bcplParserT__103-96))|(1<<(bcplParserT__104-96))|(1<<(bcplParserT__105-96))|(1<<(bcplParserT__106-96))|(1<<(bcplParserT__107-96))|(1<<(bcplParserT__108-96))|(1<<(bcplParserT__109-96))|(1<<(bcplParserT__110-96))|(1<<(bcplParserT__111-96))|(1<<(bcplParserT__112-96))|(1<<(bcplParserT__113-96))|(1<<(bcplParserT__114-96))|(1<<(bcplParserT__115-96))|(1<<(bcplParserT__116-96))|(1<<(bcplParserT__117-96))|(1<<(bcplParserT__118-96))|(1<<(bcplParserT__119-96))|(1<<(bcplParserT__120-96))|(1<<(bcplParserT__121-96))|(1<<(bcplParserT__122-96))|(1<<(bcplParserT__123-96))|(1<<(bcplParserT__124-96))|(1<<(bcplParserT__125-96))|(1<<(bcplParserT__126-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(bcplParserComment-128))|(1<<(bcplParserWS-128))|(1<<(bcplParserRem-128))|(1<<(bcplParserEqv-128))|(1<<(bcplParserNeqv-128))|(1<<(bcplParserTrue_-128))|(1<<(bcplParserFalse_-128))|(1<<(bcplParserTable-128))|(1<<(bcplParserLeft_dollar_open-128)))) != 0) {
		{
			p.SetState(181)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == bcplParserT__62 {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(186)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(187)
		p.Match(bcplParserT__62)
	}

	return localctx
}

// ICharacter_constantContext is an interface to support dynamic dispatch.
type ICharacter_constantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharacter_constantContext differentiates from other interfaces.
	IsCharacter_constantContext()
}

type Character_constantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacter_constantContext() *Character_constantContext {
	var p = new(Character_constantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_character_constant
	return p
}

func (*Character_constantContext) IsCharacter_constantContext() {}

func NewCharacter_constantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Character_constantContext {
	var p = new(Character_constantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_character_constant

	return p
}

func (s *Character_constantContext) GetParser() antlr.Parser { return s.parser }

func (s *Character_constantContext) One_character() IOne_characterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_characterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOne_characterContext)
}

func (s *Character_constantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Character_constantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Character_constantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterCharacter_constant(s)
	}
}

func (s *Character_constantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitCharacter_constant(s)
	}
}

func (p *bcplParser) Character_constant() (localctx ICharacter_constantContext) {
	this := p
	_ = this

	localctx = NewCharacter_constantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, bcplParserRULE_character_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(189)
		p.Match(bcplParserT__63)
	}
	{
		p.SetState(190)
		p.One_character()
	}
	{
		p.SetState(191)
		p.Match(bcplParserT__63)
	}

	return localctx
}

// IOctal_numberContext is an interface to support dynamic dispatch.
type IOctal_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOctal_numberContext differentiates from other interfaces.
	IsOctal_numberContext()
}

type Octal_numberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOctal_numberContext() *Octal_numberContext {
	var p = new(Octal_numberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_octal_number
	return p
}

func (*Octal_numberContext) IsOctal_numberContext() {}

func NewOctal_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Octal_numberContext {
	var p = new(Octal_numberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_octal_number

	return p
}

func (s *Octal_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Octal_numberContext) AllOctal_digit() []IOctal_digitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOctal_digitContext)(nil)).Elem())
	var tst = make([]IOctal_digitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOctal_digitContext)
		}
	}

	return tst
}

func (s *Octal_numberContext) Octal_digit(i int) IOctal_digitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctal_digitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOctal_digitContext)
}

func (s *Octal_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Octal_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Octal_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterOctal_number(s)
	}
}

func (s *Octal_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitOctal_number(s)
	}
}

func (p *bcplParser) Octal_number() (localctx IOctal_numberContext) {
	this := p
	_ = this

	localctx = NewOctal_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, bcplParserRULE_octal_number)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(193)
		p.Match(bcplParserT__64)
	}
	{
		p.SetState(194)
		p.Octal_digit()
	}
	p.SetState(198)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(195)
				p.Octal_digit()
			}

		}
		p.SetState(200)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())
	}

	return localctx
}

// IHex_numberContext is an interface to support dynamic dispatch.
type IHex_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHex_numberContext differentiates from other interfaces.
	IsHex_numberContext()
}

type Hex_numberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHex_numberContext() *Hex_numberContext {
	var p = new(Hex_numberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_hex_number
	return p
}

func (*Hex_numberContext) IsHex_numberContext() {}

func NewHex_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hex_numberContext {
	var p = new(Hex_numberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_hex_number

	return p
}

func (s *Hex_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Hex_numberContext) AllHex_digit() []IHex_digitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHex_digitContext)(nil)).Elem())
	var tst = make([]IHex_digitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHex_digitContext)
		}
	}

	return tst
}

func (s *Hex_numberContext) Hex_digit(i int) IHex_digitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHex_digitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHex_digitContext)
}

func (s *Hex_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hex_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hex_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterHex_number(s)
	}
}

func (s *Hex_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitHex_number(s)
	}
}

func (p *bcplParser) Hex_number() (localctx IHex_numberContext) {
	this := p
	_ = this

	localctx = NewHex_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, bcplParserRULE_hex_number)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(201)
		p.Match(bcplParserT__65)
	}
	{
		p.SetState(202)
		p.Hex_digit()
	}
	p.SetState(206)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(203)
				p.Hex_digit()
			}

		}
		p.SetState(208)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Octal_number() IOctal_numberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctal_numberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOctal_numberContext)
}

func (s *NumberContext) Hex_number() IHex_numberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHex_numberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHex_numberContext)
}

func (s *NumberContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *NumberContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (p *bcplParser) Number() (localctx INumberContext) {
	this := p
	_ = this

	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, bcplParserRULE_number)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(218)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__64:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(209)
			p.Octal_number()
		}

	case bcplParserT__65:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(210)
			p.Hex_number()
		}

	case bcplParserT__52, bcplParserT__53, bcplParserT__54, bcplParserT__55, bcplParserT__56, bcplParserT__57, bcplParserT__58, bcplParserT__59, bcplParserT__60, bcplParserT__61:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(211)
			p.Digit()
		}
		p.SetState(215)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(212)
					p.Digit()
				}

			}
			p.SetState(217)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) AllLetter() []ILetterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILetterContext)(nil)).Elem())
	var tst = make([]ILetterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILetterContext)
		}
	}

	return tst
}

func (s *IdentifierContext) Letter(i int) ILetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILetterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILetterContext)
}

func (s *IdentifierContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *IdentifierContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *bcplParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, bcplParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(220)
		p.Letter()
	}
	p.SetState(226)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(224)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case bcplParserT__0, bcplParserT__1, bcplParserT__2, bcplParserT__3, bcplParserT__4, bcplParserT__5, bcplParserT__6, bcplParserT__7, bcplParserT__8, bcplParserT__9, bcplParserT__10, bcplParserT__11, bcplParserT__12, bcplParserT__13, bcplParserT__14, bcplParserT__15, bcplParserT__16, bcplParserT__17, bcplParserT__18, bcplParserT__19, bcplParserT__20, bcplParserT__21, bcplParserT__22, bcplParserT__23, bcplParserT__24, bcplParserT__25, bcplParserT__26, bcplParserT__27, bcplParserT__28, bcplParserT__29, bcplParserT__30, bcplParserT__31, bcplParserT__32, bcplParserT__33, bcplParserT__34, bcplParserT__35, bcplParserT__36, bcplParserT__37, bcplParserT__38, bcplParserT__39, bcplParserT__40, bcplParserT__41, bcplParserT__42, bcplParserT__43, bcplParserT__44, bcplParserT__45, bcplParserT__46, bcplParserT__47, bcplParserT__48, bcplParserT__49, bcplParserT__50, bcplParserT__51:
				{
					p.SetState(221)
					p.Letter()
				}

			case bcplParserT__52, bcplParserT__53, bcplParserT__54, bcplParserT__55, bcplParserT__56, bcplParserT__57, bcplParserT__58, bcplParserT__59, bcplParserT__60, bcplParserT__61:
				{
					p.SetState(222)
					p.Digit()
				}

			case bcplParserT__66:
				{
					p.SetState(223)
					p.Match(bcplParserT__66)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(228)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}

	return localctx
}

// IOne_characterContext is an interface to support dynamic dispatch.
type IOne_characterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_characterContext differentiates from other interfaces.
	IsOne_characterContext()
}

type One_characterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_characterContext() *One_characterContext {
	var p = new(One_characterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_one_character
	return p
}

func (*One_characterContext) IsOne_characterContext() {}

func NewOne_characterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_characterContext {
	var p = new(One_characterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_one_character

	return p
}

func (s *One_characterContext) GetParser() antlr.Parser { return s.parser }

func (s *One_characterContext) Letter() ILetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILetterContext)
}

func (s *One_characterContext) Digit() IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *One_characterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_characterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_characterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterOne_character(s)
	}
}

func (s *One_characterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitOne_character(s)
	}
}

func (p *bcplParser) One_character() (localctx IOne_characterContext) {
	this := p
	_ = this

	localctx = NewOne_characterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, bcplParserRULE_one_character)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(231)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__0, bcplParserT__1, bcplParserT__2, bcplParserT__3, bcplParserT__4, bcplParserT__5, bcplParserT__6, bcplParserT__7, bcplParserT__8, bcplParserT__9, bcplParserT__10, bcplParserT__11, bcplParserT__12, bcplParserT__13, bcplParserT__14, bcplParserT__15, bcplParserT__16, bcplParserT__17, bcplParserT__18, bcplParserT__19, bcplParserT__20, bcplParserT__21, bcplParserT__22, bcplParserT__23, bcplParserT__24, bcplParserT__25, bcplParserT__26, bcplParserT__27, bcplParserT__28, bcplParserT__29, bcplParserT__30, bcplParserT__31, bcplParserT__32, bcplParserT__33, bcplParserT__34, bcplParserT__35, bcplParserT__36, bcplParserT__37, bcplParserT__38, bcplParserT__39, bcplParserT__40, bcplParserT__41, bcplParserT__42, bcplParserT__43, bcplParserT__44, bcplParserT__45, bcplParserT__46, bcplParserT__47, bcplParserT__48, bcplParserT__49, bcplParserT__50, bcplParserT__51:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(229)
			p.Letter()
		}

	case bcplParserT__52, bcplParserT__53, bcplParserT__54, bcplParserT__55, bcplParserT__56, bcplParserT__57, bcplParserT__58, bcplParserT__59, bcplParserT__60, bcplParserT__61:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(230)
			p.Digit()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_name
	return p
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitName(s)
	}
}

func (p *bcplParser) Name() (localctx INameContext) {
	this := p
	_ = this

	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, bcplParserRULE_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(233)
		p.Identifier()
	}

	return localctx
}

// IAddress_opContext is an interface to support dynamic dispatch.
type IAddress_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddress_opContext differentiates from other interfaces.
	IsAddress_opContext()
}

type Address_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddress_opContext() *Address_opContext {
	var p = new(Address_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_address_op
	return p
}

func (*Address_opContext) IsAddress_opContext() {}

func NewAddress_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Address_opContext {
	var p = new(Address_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_address_op

	return p
}

func (s *Address_opContext) GetParser() antlr.Parser { return s.parser }
func (s *Address_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Address_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Address_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterAddress_op(s)
	}
}

func (s *Address_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitAddress_op(s)
	}
}

func (p *bcplParser) Address_op() (localctx IAddress_opContext) {
	this := p
	_ = this

	localctx = NewAddress_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, bcplParserRULE_address_op)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(235)
		_la = p.GetTokenStream().LA(1)

		if !(_la == bcplParserT__67 || _la == bcplParserT__68) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMult_opContext is an interface to support dynamic dispatch.
type IMult_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMult_opContext differentiates from other interfaces.
	IsMult_opContext()
}

type Mult_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMult_opContext() *Mult_opContext {
	var p = new(Mult_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_mult_op
	return p
}

func (*Mult_opContext) IsMult_opContext() {}

func NewMult_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mult_opContext {
	var p = new(Mult_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_mult_op

	return p
}

func (s *Mult_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Mult_opContext) Rem() antlr.TerminalNode {
	return s.GetToken(bcplParserRem, 0)
}

func (s *Mult_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mult_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mult_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterMult_op(s)
	}
}

func (s *Mult_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitMult_op(s)
	}
}

func (p *bcplParser) Mult_op() (localctx IMult_opContext) {
	this := p
	_ = this

	localctx = NewMult_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, bcplParserRULE_mult_op)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(237)
		_la = p.GetTokenStream().LA(1)

		if !(_la == bcplParserT__69 || _la == bcplParserT__70 || _la == bcplParserRem) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAdd_opContext is an interface to support dynamic dispatch.
type IAdd_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdd_opContext differentiates from other interfaces.
	IsAdd_opContext()
}

type Add_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdd_opContext() *Add_opContext {
	var p = new(Add_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_add_op
	return p
}

func (*Add_opContext) IsAdd_opContext() {}

func NewAdd_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Add_opContext {
	var p = new(Add_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_add_op

	return p
}

func (s *Add_opContext) GetParser() antlr.Parser { return s.parser }
func (s *Add_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Add_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterAdd_op(s)
	}
}

func (s *Add_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitAdd_op(s)
	}
}

func (p *bcplParser) Add_op() (localctx IAdd_opContext) {
	this := p
	_ = this

	localctx = NewAdd_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, bcplParserRULE_add_op)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(239)
		_la = p.GetTokenStream().LA(1)

		if !(_la == bcplParserT__71 || _la == bcplParserT__72) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRel_opContext is an interface to support dynamic dispatch.
type IRel_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRel_opContext differentiates from other interfaces.
	IsRel_opContext()
}

type Rel_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRel_opContext() *Rel_opContext {
	var p = new(Rel_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_rel_op
	return p
}

func (*Rel_opContext) IsRel_opContext() {}

func NewRel_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rel_opContext {
	var p = new(Rel_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_rel_op

	return p
}

func (s *Rel_opContext) GetParser() antlr.Parser { return s.parser }
func (s *Rel_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rel_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rel_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterRel_op(s)
	}
}

func (s *Rel_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitRel_op(s)
	}
}

func (p *bcplParser) Rel_op() (localctx IRel_opContext) {
	this := p
	_ = this

	localctx = NewRel_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, bcplParserRULE_rel_op)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(241)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(bcplParserT__73-74))|(1<<(bcplParserT__74-74))|(1<<(bcplParserT__75-74))|(1<<(bcplParserT__76-74))|(1<<(bcplParserT__77-74))|(1<<(bcplParserT__78-74)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IShift_opContext is an interface to support dynamic dispatch.
type IShift_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_opContext differentiates from other interfaces.
	IsShift_opContext()
}

type Shift_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_opContext() *Shift_opContext {
	var p = new(Shift_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_shift_op
	return p
}

func (*Shift_opContext) IsShift_opContext() {}

func NewShift_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_opContext {
	var p = new(Shift_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_shift_op

	return p
}

func (s *Shift_opContext) GetParser() antlr.Parser { return s.parser }
func (s *Shift_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterShift_op(s)
	}
}

func (s *Shift_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitShift_op(s)
	}
}

func (p *bcplParser) Shift_op() (localctx IShift_opContext) {
	this := p
	_ = this

	localctx = NewShift_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, bcplParserRULE_shift_op)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(243)
		_la = p.GetTokenStream().LA(1)

		if !(_la == bcplParserT__79 || _la == bcplParserT__80) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAnd_opContext is an interface to support dynamic dispatch.
type IAnd_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_opContext differentiates from other interfaces.
	IsAnd_opContext()
}

type And_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_opContext() *And_opContext {
	var p = new(And_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_and_op
	return p
}

func (*And_opContext) IsAnd_opContext() {}

func NewAnd_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_opContext {
	var p = new(And_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_and_op

	return p
}

func (s *And_opContext) GetParser() antlr.Parser { return s.parser }
func (s *And_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *And_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterAnd_op(s)
	}
}

func (s *And_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitAnd_op(s)
	}
}

func (p *bcplParser) And_op() (localctx IAnd_opContext) {
	this := p
	_ = this

	localctx = NewAnd_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, bcplParserRULE_and_op)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(245)
		p.Match(bcplParserT__81)
	}

	return localctx
}

// IOr_opContext is an interface to support dynamic dispatch.
type IOr_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOr_opContext differentiates from other interfaces.
	IsOr_opContext()
}

type Or_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_opContext() *Or_opContext {
	var p = new(Or_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_or_op
	return p
}

func (*Or_opContext) IsOr_opContext() {}

func NewOr_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_opContext {
	var p = new(Or_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_or_op

	return p
}

func (s *Or_opContext) GetParser() antlr.Parser { return s.parser }
func (s *Or_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Or_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterOr_op(s)
	}
}

func (s *Or_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitOr_op(s)
	}
}

func (p *bcplParser) Or_op() (localctx IOr_opContext) {
	this := p
	_ = this

	localctx = NewOr_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, bcplParserRULE_or_op)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(247)
		p.Match(bcplParserT__82)
	}

	return localctx
}

// IEqv_opContext is an interface to support dynamic dispatch.
type IEqv_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEqv_opContext differentiates from other interfaces.
	IsEqv_opContext()
}

type Eqv_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqv_opContext() *Eqv_opContext {
	var p = new(Eqv_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_eqv_op
	return p
}

func (*Eqv_opContext) IsEqv_opContext() {}

func NewEqv_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Eqv_opContext {
	var p = new(Eqv_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_eqv_op

	return p
}

func (s *Eqv_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Eqv_opContext) Eqv() antlr.TerminalNode {
	return s.GetToken(bcplParserEqv, 0)
}

func (s *Eqv_opContext) Neqv() antlr.TerminalNode {
	return s.GetToken(bcplParserNeqv, 0)
}

func (s *Eqv_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Eqv_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Eqv_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterEqv_op(s)
	}
}

func (s *Eqv_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitEqv_op(s)
	}
}

func (p *bcplParser) Eqv_op() (localctx IEqv_opContext) {
	this := p
	_ = this

	localctx = NewEqv_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, bcplParserRULE_eqv_op)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(249)
		_la = p.GetTokenStream().LA(1)

		if !(_la == bcplParserEqv || _la == bcplParserNeqv) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INot_opContext is an interface to support dynamic dispatch.
type INot_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNot_opContext differentiates from other interfaces.
	IsNot_opContext()
}

type Not_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNot_opContext() *Not_opContext {
	var p = new(Not_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_not_op
	return p
}

func (*Not_opContext) IsNot_opContext() {}

func NewNot_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Not_opContext {
	var p = new(Not_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_not_op

	return p
}

func (s *Not_opContext) GetParser() antlr.Parser { return s.parser }
func (s *Not_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Not_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterNot_op(s)
	}
}

func (s *Not_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitNot_op(s)
	}
}

func (p *bcplParser) Not_op() (localctx INot_opContext) {
	this := p
	_ = this

	localctx = NewNot_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, bcplParserRULE_not_op)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(251)
		p.Match(bcplParserT__83)
	}

	return localctx
}

// IElementContext is an interface to support dynamic dispatch.
type IElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementContext differentiates from other interfaces.
	IsElementContext()
}

type ElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementContext() *ElementContext {
	var p = new(ElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_element
	return p
}

func (*ElementContext) IsElementContext() {}

func NewElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementContext {
	var p = new(ElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_element

	return p
}

func (s *ElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementContext) Character_constant() ICharacter_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharacter_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharacter_constantContext)
}

func (s *ElementContext) String_constant() IString_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_constantContext)
}

func (s *ElementContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *ElementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ElementContext) True_() antlr.TerminalNode {
	return s.GetToken(bcplParserTrue_, 0)
}

func (s *ElementContext) False_() antlr.TerminalNode {
	return s.GetToken(bcplParserFalse_, 0)
}

func (s *ElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterElement(s)
	}
}

func (s *ElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitElement(s)
	}
}

func (p *bcplParser) Element() (localctx IElementContext) {
	this := p
	_ = this

	localctx = NewElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, bcplParserRULE_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(259)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__63:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(253)
			p.Character_constant()
		}

	case bcplParserT__62:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(254)
			p.String_constant()
		}

	case bcplParserT__52, bcplParserT__53, bcplParserT__54, bcplParserT__55, bcplParserT__56, bcplParserT__57, bcplParserT__58, bcplParserT__59, bcplParserT__60, bcplParserT__61, bcplParserT__64, bcplParserT__65:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(255)
			p.Number()
		}

	case bcplParserT__0, bcplParserT__1, bcplParserT__2, bcplParserT__3, bcplParserT__4, bcplParserT__5, bcplParserT__6, bcplParserT__7, bcplParserT__8, bcplParserT__9, bcplParserT__10, bcplParserT__11, bcplParserT__12, bcplParserT__13, bcplParserT__14, bcplParserT__15, bcplParserT__16, bcplParserT__17, bcplParserT__18, bcplParserT__19, bcplParserT__20, bcplParserT__21, bcplParserT__22, bcplParserT__23, bcplParserT__24, bcplParserT__25, bcplParserT__26, bcplParserT__27, bcplParserT__28, bcplParserT__29, bcplParserT__30, bcplParserT__31, bcplParserT__32, bcplParserT__33, bcplParserT__34, bcplParserT__35, bcplParserT__36, bcplParserT__37, bcplParserT__38, bcplParserT__39, bcplParserT__40, bcplParserT__41, bcplParserT__42, bcplParserT__43, bcplParserT__44, bcplParserT__45, bcplParserT__46, bcplParserT__47, bcplParserT__48, bcplParserT__49, bcplParserT__50, bcplParserT__51:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(256)
			p.Identifier()
		}

	case bcplParserTrue_:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(257)
			p.Match(bcplParserTrue_)
		}

	case bcplParserFalse_:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(258)
			p.Match(bcplParserFalse_)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPrimary_EContext is an interface to support dynamic dispatch.
type IPrimary_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_EContext differentiates from other interfaces.
	IsPrimary_EContext()
}

type Primary_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_EContext() *Primary_EContext {
	var p = new(Primary_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_primary_E
	return p
}

func (*Primary_EContext) IsPrimary_EContext() {}

func NewPrimary_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_EContext {
	var p = new(Primary_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_primary_E

	return p
}

func (s *Primary_EContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_EContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Primary_EContext) Element() IElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementContext)
}

func (s *Primary_EContext) Primary_E() IPrimary_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_EContext)
}

func (s *Primary_EContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Primary_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterPrimary_E(s)
	}
}

func (s *Primary_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitPrimary_E(s)
	}
}

func (p *bcplParser) Primary_E() (localctx IPrimary_EContext) {
	return p.primary_E(0)
}

func (p *bcplParser) primary_E(_p int) (localctx IPrimary_EContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPrimary_EContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimary_EContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 44
	p.EnterRecursionRule(localctx, 44, bcplParserRULE_primary_E, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(267)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__84:
		{
			p.SetState(262)
			p.Match(bcplParserT__84)
		}
		{
			p.SetState(263)
			p.Expression()
		}
		{
			p.SetState(264)
			p.Match(bcplParserT__85)
		}

	case bcplParserT__0, bcplParserT__1, bcplParserT__2, bcplParserT__3, bcplParserT__4, bcplParserT__5, bcplParserT__6, bcplParserT__7, bcplParserT__8, bcplParserT__9, bcplParserT__10, bcplParserT__11, bcplParserT__12, bcplParserT__13, bcplParserT__14, bcplParserT__15, bcplParserT__16, bcplParserT__17, bcplParserT__18, bcplParserT__19, bcplParserT__20, bcplParserT__21, bcplParserT__22, bcplParserT__23, bcplParserT__24, bcplParserT__25, bcplParserT__26, bcplParserT__27, bcplParserT__28, bcplParserT__29, bcplParserT__30, bcplParserT__31, bcplParserT__32, bcplParserT__33, bcplParserT__34, bcplParserT__35, bcplParserT__36, bcplParserT__37, bcplParserT__38, bcplParserT__39, bcplParserT__40, bcplParserT__41, bcplParserT__42, bcplParserT__43, bcplParserT__44, bcplParserT__45, bcplParserT__46, bcplParserT__47, bcplParserT__48, bcplParserT__49, bcplParserT__50, bcplParserT__51, bcplParserT__52, bcplParserT__53, bcplParserT__54, bcplParserT__55, bcplParserT__56, bcplParserT__57, bcplParserT__58, bcplParserT__59, bcplParserT__60, bcplParserT__61, bcplParserT__62, bcplParserT__63, bcplParserT__64, bcplParserT__65, bcplParserTrue_, bcplParserFalse_:
		{
			p.SetState(266)
			p.Element()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(279)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(277)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPrimary_EContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bcplParserRULE_primary_E)
				p.SetState(269)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(270)
					p.Match(bcplParserT__84)
				}
				{
					p.SetState(271)
					p.Expression_list()
				}
				{
					p.SetState(272)
					p.Match(bcplParserT__85)
				}

			case 2:
				localctx = NewPrimary_EContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bcplParserRULE_primary_E)
				p.SetState(274)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(275)
					p.Match(bcplParserT__84)
				}
				{
					p.SetState(276)
					p.Match(bcplParserT__85)
				}

			}

		}
		p.SetState(281)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext())
	}

	return localctx
}

// IVector_EContext is an interface to support dynamic dispatch.
type IVector_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVector_EContext differentiates from other interfaces.
	IsVector_EContext()
}

type Vector_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVector_EContext() *Vector_EContext {
	var p = new(Vector_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_vector_E
	return p
}

func (*Vector_EContext) IsVector_EContext() {}

func NewVector_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Vector_EContext {
	var p = new(Vector_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_vector_E

	return p
}

func (s *Vector_EContext) GetParser() antlr.Parser { return s.parser }

func (s *Vector_EContext) Primary_E() IPrimary_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_EContext)
}

func (s *Vector_EContext) Vector_E() IVector_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVector_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVector_EContext)
}

func (s *Vector_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Vector_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Vector_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterVector_E(s)
	}
}

func (s *Vector_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitVector_E(s)
	}
}

func (p *bcplParser) Vector_E() (localctx IVector_EContext) {
	return p.vector_E(0)
}

func (p *bcplParser) vector_E(_p int) (localctx IVector_EContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewVector_EContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IVector_EContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 46
	p.EnterRecursionRule(localctx, 46, bcplParserRULE_vector_E, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.primary_E(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(290)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewVector_EContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, bcplParserRULE_vector_E)
			p.SetState(285)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(286)
				p.Match(bcplParserT__68)
			}
			{
				p.SetState(287)
				p.primary_E(0)
			}

		}
		p.SetState(292)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
	}

	return localctx
}

// IAddress_EContext is an interface to support dynamic dispatch.
type IAddress_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddress_EContext differentiates from other interfaces.
	IsAddress_EContext()
}

type Address_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddress_EContext() *Address_EContext {
	var p = new(Address_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_address_E
	return p
}

func (*Address_EContext) IsAddress_EContext() {}

func NewAddress_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Address_EContext {
	var p = new(Address_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_address_E

	return p
}

func (s *Address_EContext) GetParser() antlr.Parser { return s.parser }

func (s *Address_EContext) Address_op() IAddress_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddress_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddress_opContext)
}

func (s *Address_EContext) Address_E() IAddress_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddress_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddress_EContext)
}

func (s *Address_EContext) Vector_E() IVector_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVector_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVector_EContext)
}

func (s *Address_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Address_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Address_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterAddress_E(s)
	}
}

func (s *Address_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitAddress_E(s)
	}
}

func (p *bcplParser) Address_E() (localctx IAddress_EContext) {
	this := p
	_ = this

	localctx = NewAddress_EContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, bcplParserRULE_address_E)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(297)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__67, bcplParserT__68:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(293)
			p.Address_op()
		}
		{
			p.SetState(294)
			p.Address_E()
		}

	case bcplParserT__0, bcplParserT__1, bcplParserT__2, bcplParserT__3, bcplParserT__4, bcplParserT__5, bcplParserT__6, bcplParserT__7, bcplParserT__8, bcplParserT__9, bcplParserT__10, bcplParserT__11, bcplParserT__12, bcplParserT__13, bcplParserT__14, bcplParserT__15, bcplParserT__16, bcplParserT__17, bcplParserT__18, bcplParserT__19, bcplParserT__20, bcplParserT__21, bcplParserT__22, bcplParserT__23, bcplParserT__24, bcplParserT__25, bcplParserT__26, bcplParserT__27, bcplParserT__28, bcplParserT__29, bcplParserT__30, bcplParserT__31, bcplParserT__32, bcplParserT__33, bcplParserT__34, bcplParserT__35, bcplParserT__36, bcplParserT__37, bcplParserT__38, bcplParserT__39, bcplParserT__40, bcplParserT__41, bcplParserT__42, bcplParserT__43, bcplParserT__44, bcplParserT__45, bcplParserT__46, bcplParserT__47, bcplParserT__48, bcplParserT__49, bcplParserT__50, bcplParserT__51, bcplParserT__52, bcplParserT__53, bcplParserT__54, bcplParserT__55, bcplParserT__56, bcplParserT__57, bcplParserT__58, bcplParserT__59, bcplParserT__60, bcplParserT__61, bcplParserT__62, bcplParserT__63, bcplParserT__64, bcplParserT__65, bcplParserT__84, bcplParserTrue_, bcplParserFalse_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(296)
			p.vector_E(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMult_EContext is an interface to support dynamic dispatch.
type IMult_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMult_EContext differentiates from other interfaces.
	IsMult_EContext()
}

type Mult_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMult_EContext() *Mult_EContext {
	var p = new(Mult_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_mult_E
	return p
}

func (*Mult_EContext) IsMult_EContext() {}

func NewMult_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mult_EContext {
	var p = new(Mult_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_mult_E

	return p
}

func (s *Mult_EContext) GetParser() antlr.Parser { return s.parser }

func (s *Mult_EContext) Address_E() IAddress_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddress_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddress_EContext)
}

func (s *Mult_EContext) Mult_E() IMult_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMult_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMult_EContext)
}

func (s *Mult_EContext) Mult_op() IMult_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMult_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMult_opContext)
}

func (s *Mult_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mult_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mult_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterMult_E(s)
	}
}

func (s *Mult_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitMult_E(s)
	}
}

func (p *bcplParser) Mult_E() (localctx IMult_EContext) {
	return p.mult_E(0)
}

func (p *bcplParser) mult_E(_p int) (localctx IMult_EContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewMult_EContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMult_EContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 50
	p.EnterRecursionRule(localctx, 50, bcplParserRULE_mult_E, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(300)
		p.Address_E()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(308)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewMult_EContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, bcplParserRULE_mult_E)
			p.SetState(302)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(303)
				p.Mult_op()
			}
			{
				p.SetState(304)
				p.Address_E()
			}

		}
		p.SetState(310)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext())
	}

	return localctx
}

// IAdd_EContext is an interface to support dynamic dispatch.
type IAdd_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdd_EContext differentiates from other interfaces.
	IsAdd_EContext()
}

type Add_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdd_EContext() *Add_EContext {
	var p = new(Add_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_add_E
	return p
}

func (*Add_EContext) IsAdd_EContext() {}

func NewAdd_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Add_EContext {
	var p = new(Add_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_add_E

	return p
}

func (s *Add_EContext) GetParser() antlr.Parser { return s.parser }

func (s *Add_EContext) Add_op() IAdd_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdd_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdd_opContext)
}

func (s *Add_EContext) Mult_E() IMult_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMult_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMult_EContext)
}

func (s *Add_EContext) Add_E() IAdd_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdd_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdd_EContext)
}

func (s *Add_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Add_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterAdd_E(s)
	}
}

func (s *Add_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitAdd_E(s)
	}
}

func (p *bcplParser) Add_E() (localctx IAdd_EContext) {
	return p.add_E(0)
}

func (p *bcplParser) add_E(_p int) (localctx IAdd_EContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewAdd_EContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAdd_EContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 52
	p.EnterRecursionRule(localctx, 52, bcplParserRULE_add_E, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(316)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__71, bcplParserT__72:
		{
			p.SetState(312)
			p.Add_op()
		}
		{
			p.SetState(313)
			p.mult_E(0)
		}

	case bcplParserT__0, bcplParserT__1, bcplParserT__2, bcplParserT__3, bcplParserT__4, bcplParserT__5, bcplParserT__6, bcplParserT__7, bcplParserT__8, bcplParserT__9, bcplParserT__10, bcplParserT__11, bcplParserT__12, bcplParserT__13, bcplParserT__14, bcplParserT__15, bcplParserT__16, bcplParserT__17, bcplParserT__18, bcplParserT__19, bcplParserT__20, bcplParserT__21, bcplParserT__22, bcplParserT__23, bcplParserT__24, bcplParserT__25, bcplParserT__26, bcplParserT__27, bcplParserT__28, bcplParserT__29, bcplParserT__30, bcplParserT__31, bcplParserT__32, bcplParserT__33, bcplParserT__34, bcplParserT__35, bcplParserT__36, bcplParserT__37, bcplParserT__38, bcplParserT__39, bcplParserT__40, bcplParserT__41, bcplParserT__42, bcplParserT__43, bcplParserT__44, bcplParserT__45, bcplParserT__46, bcplParserT__47, bcplParserT__48, bcplParserT__49, bcplParserT__50, bcplParserT__51, bcplParserT__52, bcplParserT__53, bcplParserT__54, bcplParserT__55, bcplParserT__56, bcplParserT__57, bcplParserT__58, bcplParserT__59, bcplParserT__60, bcplParserT__61, bcplParserT__62, bcplParserT__63, bcplParserT__64, bcplParserT__65, bcplParserT__67, bcplParserT__68, bcplParserT__84, bcplParserTrue_, bcplParserFalse_:
		{
			p.SetState(315)
			p.mult_E(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAdd_EContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, bcplParserRULE_add_E)
			p.SetState(318)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(319)
				p.Add_op()
			}
			{
				p.SetState(320)
				p.mult_E(0)
			}

		}
		p.SetState(326)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
	}

	return localctx
}

// IRel_EContext is an interface to support dynamic dispatch.
type IRel_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRel_EContext differentiates from other interfaces.
	IsRel_EContext()
}

type Rel_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRel_EContext() *Rel_EContext {
	var p = new(Rel_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_rel_E
	return p
}

func (*Rel_EContext) IsRel_EContext() {}

func NewRel_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rel_EContext {
	var p = new(Rel_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_rel_E

	return p
}

func (s *Rel_EContext) GetParser() antlr.Parser { return s.parser }

func (s *Rel_EContext) AllAdd_E() []IAdd_EContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdd_EContext)(nil)).Elem())
	var tst = make([]IAdd_EContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdd_EContext)
		}
	}

	return tst
}

func (s *Rel_EContext) Add_E(i int) IAdd_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdd_EContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdd_EContext)
}

func (s *Rel_EContext) AllRel_op() []IRel_opContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRel_opContext)(nil)).Elem())
	var tst = make([]IRel_opContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRel_opContext)
		}
	}

	return tst
}

func (s *Rel_EContext) Rel_op(i int) IRel_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRel_opContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRel_opContext)
}

func (s *Rel_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rel_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rel_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterRel_E(s)
	}
}

func (s *Rel_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitRel_E(s)
	}
}

func (p *bcplParser) Rel_E() (localctx IRel_EContext) {
	this := p
	_ = this

	localctx = NewRel_EContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, bcplParserRULE_rel_E)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(327)
		p.add_E(0)
	}
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(328)
				p.Rel_op()
			}
			{
				p.SetState(329)
				p.add_E(0)
			}

		}
		p.SetState(335)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())
	}

	return localctx
}

// IShift_EContext is an interface to support dynamic dispatch.
type IShift_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_EContext differentiates from other interfaces.
	IsShift_EContext()
}

type Shift_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_EContext() *Shift_EContext {
	var p = new(Shift_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_shift_E
	return p
}

func (*Shift_EContext) IsShift_EContext() {}

func NewShift_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_EContext {
	var p = new(Shift_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_shift_E

	return p
}

func (s *Shift_EContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_EContext) Rel_E() IRel_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRel_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRel_EContext)
}

func (s *Shift_EContext) Shift_E() IShift_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShift_EContext)
}

func (s *Shift_EContext) Shift_op() IShift_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShift_opContext)
}

func (s *Shift_EContext) Add_E() IAdd_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdd_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdd_EContext)
}

func (s *Shift_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterShift_E(s)
	}
}

func (s *Shift_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitShift_E(s)
	}
}

func (p *bcplParser) Shift_E() (localctx IShift_EContext) {
	return p.shift_E(0)
}

func (p *bcplParser) shift_E(_p int) (localctx IShift_EContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewShift_EContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IShift_EContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 56
	p.EnterRecursionRule(localctx, 56, bcplParserRULE_shift_E, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(337)
		p.Rel_E()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(345)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewShift_EContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, bcplParserRULE_shift_E)
			p.SetState(339)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(340)
				p.Shift_op()
			}
			{
				p.SetState(341)
				p.add_E(0)
			}

		}
		p.SetState(347)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())
	}

	return localctx
}

// INot_EContext is an interface to support dynamic dispatch.
type INot_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNot_EContext differentiates from other interfaces.
	IsNot_EContext()
}

type Not_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNot_EContext() *Not_EContext {
	var p = new(Not_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_not_E
	return p
}

func (*Not_EContext) IsNot_EContext() {}

func NewNot_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Not_EContext {
	var p = new(Not_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_not_E

	return p
}

func (s *Not_EContext) GetParser() antlr.Parser { return s.parser }

func (s *Not_EContext) Not_op() INot_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INot_opContext)
}

func (s *Not_EContext) Shift_E() IShift_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShift_EContext)
}

func (s *Not_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Not_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterNot_E(s)
	}
}

func (s *Not_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitNot_E(s)
	}
}

func (p *bcplParser) Not_E() (localctx INot_EContext) {
	this := p
	_ = this

	localctx = NewNot_EContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, bcplParserRULE_not_E)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(352)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__83:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(348)
			p.Not_op()
		}
		{
			p.SetState(349)
			p.shift_E(0)
		}

	case bcplParserT__0, bcplParserT__1, bcplParserT__2, bcplParserT__3, bcplParserT__4, bcplParserT__5, bcplParserT__6, bcplParserT__7, bcplParserT__8, bcplParserT__9, bcplParserT__10, bcplParserT__11, bcplParserT__12, bcplParserT__13, bcplParserT__14, bcplParserT__15, bcplParserT__16, bcplParserT__17, bcplParserT__18, bcplParserT__19, bcplParserT__20, bcplParserT__21, bcplParserT__22, bcplParserT__23, bcplParserT__24, bcplParserT__25, bcplParserT__26, bcplParserT__27, bcplParserT__28, bcplParserT__29, bcplParserT__30, bcplParserT__31, bcplParserT__32, bcplParserT__33, bcplParserT__34, bcplParserT__35, bcplParserT__36, bcplParserT__37, bcplParserT__38, bcplParserT__39, bcplParserT__40, bcplParserT__41, bcplParserT__42, bcplParserT__43, bcplParserT__44, bcplParserT__45, bcplParserT__46, bcplParserT__47, bcplParserT__48, bcplParserT__49, bcplParserT__50, bcplParserT__51, bcplParserT__52, bcplParserT__53, bcplParserT__54, bcplParserT__55, bcplParserT__56, bcplParserT__57, bcplParserT__58, bcplParserT__59, bcplParserT__60, bcplParserT__61, bcplParserT__62, bcplParserT__63, bcplParserT__64, bcplParserT__65, bcplParserT__67, bcplParserT__68, bcplParserT__71, bcplParserT__72, bcplParserT__84, bcplParserTrue_, bcplParserFalse_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(351)
			p.shift_E(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnd_EContext is an interface to support dynamic dispatch.
type IAnd_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_EContext differentiates from other interfaces.
	IsAnd_EContext()
}

type And_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_EContext() *And_EContext {
	var p = new(And_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_and_E
	return p
}

func (*And_EContext) IsAnd_EContext() {}

func NewAnd_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_EContext {
	var p = new(And_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_and_E

	return p
}

func (s *And_EContext) GetParser() antlr.Parser { return s.parser }

func (s *And_EContext) AllNot_E() []INot_EContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INot_EContext)(nil)).Elem())
	var tst = make([]INot_EContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INot_EContext)
		}
	}

	return tst
}

func (s *And_EContext) Not_E(i int) INot_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_EContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INot_EContext)
}

func (s *And_EContext) AllAnd_op() []IAnd_opContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnd_opContext)(nil)).Elem())
	var tst = make([]IAnd_opContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnd_opContext)
		}
	}

	return tst
}

func (s *And_EContext) And_op(i int) IAnd_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_opContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnd_opContext)
}

func (s *And_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *And_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterAnd_E(s)
	}
}

func (s *And_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitAnd_E(s)
	}
}

func (p *bcplParser) And_E() (localctx IAnd_EContext) {
	this := p
	_ = this

	localctx = NewAnd_EContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, bcplParserRULE_and_E)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(354)
		p.Not_E()
	}
	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(355)
				p.And_op()
			}
			{
				p.SetState(356)
				p.Not_E()
			}

		}
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())
	}

	return localctx
}

// IOr_EContext is an interface to support dynamic dispatch.
type IOr_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOr_EContext differentiates from other interfaces.
	IsOr_EContext()
}

type Or_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_EContext() *Or_EContext {
	var p = new(Or_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_or_E
	return p
}

func (*Or_EContext) IsOr_EContext() {}

func NewOr_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_EContext {
	var p = new(Or_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_or_E

	return p
}

func (s *Or_EContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_EContext) AllAnd_E() []IAnd_EContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnd_EContext)(nil)).Elem())
	var tst = make([]IAnd_EContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnd_EContext)
		}
	}

	return tst
}

func (s *Or_EContext) And_E(i int) IAnd_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_EContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnd_EContext)
}

func (s *Or_EContext) AllOr_op() []IOr_opContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOr_opContext)(nil)).Elem())
	var tst = make([]IOr_opContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOr_opContext)
		}
	}

	return tst
}

func (s *Or_EContext) Or_op(i int) IOr_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_opContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOr_opContext)
}

func (s *Or_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Or_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterOr_E(s)
	}
}

func (s *Or_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitOr_E(s)
	}
}

func (p *bcplParser) Or_E() (localctx IOr_EContext) {
	this := p
	_ = this

	localctx = NewOr_EContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, bcplParserRULE_or_E)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(363)
		p.And_E()
	}
	p.SetState(369)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(364)
				p.Or_op()
			}
			{
				p.SetState(365)
				p.And_E()
			}

		}
		p.SetState(371)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
	}

	return localctx
}

// IEqv_EContext is an interface to support dynamic dispatch.
type IEqv_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEqv_EContext differentiates from other interfaces.
	IsEqv_EContext()
}

type Eqv_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqv_EContext() *Eqv_EContext {
	var p = new(Eqv_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_eqv_E
	return p
}

func (*Eqv_EContext) IsEqv_EContext() {}

func NewEqv_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Eqv_EContext {
	var p = new(Eqv_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_eqv_E

	return p
}

func (s *Eqv_EContext) GetParser() antlr.Parser { return s.parser }

func (s *Eqv_EContext) AllOr_E() []IOr_EContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOr_EContext)(nil)).Elem())
	var tst = make([]IOr_EContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOr_EContext)
		}
	}

	return tst
}

func (s *Eqv_EContext) Or_E(i int) IOr_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_EContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOr_EContext)
}

func (s *Eqv_EContext) AllEqv_op() []IEqv_opContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEqv_opContext)(nil)).Elem())
	var tst = make([]IEqv_opContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEqv_opContext)
		}
	}

	return tst
}

func (s *Eqv_EContext) Eqv_op(i int) IEqv_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqv_opContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEqv_opContext)
}

func (s *Eqv_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Eqv_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Eqv_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterEqv_E(s)
	}
}

func (s *Eqv_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitEqv_E(s)
	}
}

func (p *bcplParser) Eqv_E() (localctx IEqv_EContext) {
	this := p
	_ = this

	localctx = NewEqv_EContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, bcplParserRULE_eqv_E)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)
		p.Or_E()
	}
	p.SetState(378)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(373)
				p.Eqv_op()
			}
			{
				p.SetState(374)
				p.Or_E()
			}

		}
		p.SetState(380)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())
	}

	return localctx
}

// IConditional_EContext is an interface to support dynamic dispatch.
type IConditional_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_EContext differentiates from other interfaces.
	IsConditional_EContext()
}

type Conditional_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_EContext() *Conditional_EContext {
	var p = new(Conditional_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_conditional_E
	return p
}

func (*Conditional_EContext) IsConditional_EContext() {}

func NewConditional_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_EContext {
	var p = new(Conditional_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_conditional_E

	return p
}

func (s *Conditional_EContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_EContext) Eqv_E() IEqv_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqv_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqv_EContext)
}

func (s *Conditional_EContext) AllConditional_E() []IConditional_EContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditional_EContext)(nil)).Elem())
	var tst = make([]IConditional_EContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditional_EContext)
		}
	}

	return tst
}

func (s *Conditional_EContext) Conditional_E(i int) IConditional_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_EContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditional_EContext)
}

func (s *Conditional_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterConditional_E(s)
	}
}

func (s *Conditional_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitConditional_E(s)
	}
}

func (p *bcplParser) Conditional_E() (localctx IConditional_EContext) {
	this := p
	_ = this

	localctx = NewConditional_EContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, bcplParserRULE_conditional_E)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(388)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(381)
			p.Eqv_E()
		}
		{
			p.SetState(382)
			p.Match(bcplParserT__86)
		}
		{
			p.SetState(383)
			p.Conditional_E()
		}
		{
			p.SetState(384)
			p.Match(bcplParserT__87)
		}
		{
			p.SetState(385)
			p.Conditional_E()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(387)
			p.Eqv_E()
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Conditional_E() IConditional_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_EContext)
}

func (s *ExpressionContext) Table() antlr.TerminalNode {
	return s.GetToken(bcplParserTable, 0)
}

func (s *ExpressionContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *ExpressionContext) Command() ICommandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommandContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *bcplParser) Expression() (localctx IExpressionContext) {
	this := p
	_ = this

	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, bcplParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(402)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__0, bcplParserT__1, bcplParserT__2, bcplParserT__3, bcplParserT__4, bcplParserT__5, bcplParserT__6, bcplParserT__7, bcplParserT__8, bcplParserT__9, bcplParserT__10, bcplParserT__11, bcplParserT__12, bcplParserT__13, bcplParserT__14, bcplParserT__15, bcplParserT__16, bcplParserT__17, bcplParserT__18, bcplParserT__19, bcplParserT__20, bcplParserT__21, bcplParserT__22, bcplParserT__23, bcplParserT__24, bcplParserT__25, bcplParserT__26, bcplParserT__27, bcplParserT__28, bcplParserT__29, bcplParserT__30, bcplParserT__31, bcplParserT__32, bcplParserT__33, bcplParserT__34, bcplParserT__35, bcplParserT__36, bcplParserT__37, bcplParserT__38, bcplParserT__39, bcplParserT__40, bcplParserT__41, bcplParserT__42, bcplParserT__43, bcplParserT__44, bcplParserT__45, bcplParserT__46, bcplParserT__47, bcplParserT__48, bcplParserT__49, bcplParserT__50, bcplParserT__51, bcplParserT__52, bcplParserT__53, bcplParserT__54, bcplParserT__55, bcplParserT__56, bcplParserT__57, bcplParserT__58, bcplParserT__59, bcplParserT__60, bcplParserT__61, bcplParserT__62, bcplParserT__63, bcplParserT__64, bcplParserT__65, bcplParserT__67, bcplParserT__68, bcplParserT__71, bcplParserT__72, bcplParserT__83, bcplParserT__84, bcplParserTrue_, bcplParserFalse_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(390)
			p.Conditional_E()
		}

	case bcplParserTable:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(391)
			p.Match(bcplParserTable)
		}
		{
			p.SetState(392)
			p.constant_expression(0)
		}
		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(393)
					p.Match(bcplParserT__87)
				}
				{
					p.SetState(394)
					p.constant_expression(0)
				}

			}
			p.SetState(399)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())
		}

	case bcplParserT__88:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(400)
			p.Match(bcplParserT__88)
		}
		{
			p.SetState(401)
			p.Command()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IC_elementContext is an interface to support dynamic dispatch.
type IC_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsC_elementContext differentiates from other interfaces.
	IsC_elementContext()
}

type C_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyC_elementContext() *C_elementContext {
	var p = new(C_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_c_element
	return p
}

func (*C_elementContext) IsC_elementContext() {}

func NewC_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *C_elementContext {
	var p = new(C_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_c_element

	return p
}

func (s *C_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *C_elementContext) Character_constant() ICharacter_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharacter_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharacter_constantContext)
}

func (s *C_elementContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *C_elementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *C_elementContext) True_() antlr.TerminalNode {
	return s.GetToken(bcplParserTrue_, 0)
}

func (s *C_elementContext) False_() antlr.TerminalNode {
	return s.GetToken(bcplParserFalse_, 0)
}

func (s *C_elementContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *C_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *C_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *C_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterC_element(s)
	}
}

func (s *C_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitC_element(s)
	}
}

func (p *bcplParser) C_element() (localctx IC_elementContext) {
	this := p
	_ = this

	localctx = NewC_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, bcplParserRULE_c_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(413)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__63:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(404)
			p.Character_constant()
		}

	case bcplParserT__52, bcplParserT__53, bcplParserT__54, bcplParserT__55, bcplParserT__56, bcplParserT__57, bcplParserT__58, bcplParserT__59, bcplParserT__60, bcplParserT__61, bcplParserT__64, bcplParserT__65:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(405)
			p.Number()
		}

	case bcplParserT__0, bcplParserT__1, bcplParserT__2, bcplParserT__3, bcplParserT__4, bcplParserT__5, bcplParserT__6, bcplParserT__7, bcplParserT__8, bcplParserT__9, bcplParserT__10, bcplParserT__11, bcplParserT__12, bcplParserT__13, bcplParserT__14, bcplParserT__15, bcplParserT__16, bcplParserT__17, bcplParserT__18, bcplParserT__19, bcplParserT__20, bcplParserT__21, bcplParserT__22, bcplParserT__23, bcplParserT__24, bcplParserT__25, bcplParserT__26, bcplParserT__27, bcplParserT__28, bcplParserT__29, bcplParserT__30, bcplParserT__31, bcplParserT__32, bcplParserT__33, bcplParserT__34, bcplParserT__35, bcplParserT__36, bcplParserT__37, bcplParserT__38, bcplParserT__39, bcplParserT__40, bcplParserT__41, bcplParserT__42, bcplParserT__43, bcplParserT__44, bcplParserT__45, bcplParserT__46, bcplParserT__47, bcplParserT__48, bcplParserT__49, bcplParserT__50, bcplParserT__51:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(406)
			p.Identifier()
		}

	case bcplParserTrue_:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(407)
			p.Match(bcplParserTrue_)
		}

	case bcplParserFalse_:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(408)
			p.Match(bcplParserFalse_)
		}

	case bcplParserT__84:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(409)
			p.Match(bcplParserT__84)
		}
		{
			p.SetState(410)
			p.constant_expression(0)
		}
		{
			p.SetState(411)
			p.Match(bcplParserT__85)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IC_mult_EContext is an interface to support dynamic dispatch.
type IC_mult_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsC_mult_EContext differentiates from other interfaces.
	IsC_mult_EContext()
}

type C_mult_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyC_mult_EContext() *C_mult_EContext {
	var p = new(C_mult_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_c_mult_E
	return p
}

func (*C_mult_EContext) IsC_mult_EContext() {}

func NewC_mult_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *C_mult_EContext {
	var p = new(C_mult_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_c_mult_E

	return p
}

func (s *C_mult_EContext) GetParser() antlr.Parser { return s.parser }

func (s *C_mult_EContext) C_element() IC_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IC_elementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IC_elementContext)
}

func (s *C_mult_EContext) C_mult_E() IC_mult_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IC_mult_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IC_mult_EContext)
}

func (s *C_mult_EContext) Mult_op() IMult_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMult_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMult_opContext)
}

func (s *C_mult_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *C_mult_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *C_mult_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterC_mult_E(s)
	}
}

func (s *C_mult_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitC_mult_E(s)
	}
}

func (p *bcplParser) C_mult_E() (localctx IC_mult_EContext) {
	return p.c_mult_E(0)
}

func (p *bcplParser) c_mult_E(_p int) (localctx IC_mult_EContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewC_mult_EContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IC_mult_EContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 72
	p.EnterRecursionRule(localctx, 72, bcplParserRULE_c_mult_E, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(416)
		p.C_element()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(424)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewC_mult_EContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, bcplParserRULE_c_mult_E)
			p.SetState(418)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(419)
				p.Mult_op()
			}
			{
				p.SetState(420)
				p.C_element()
			}

		}
		p.SetState(426)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())
	}

	return localctx
}

// IC_add_EContext is an interface to support dynamic dispatch.
type IC_add_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsC_add_EContext differentiates from other interfaces.
	IsC_add_EContext()
}

type C_add_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyC_add_EContext() *C_add_EContext {
	var p = new(C_add_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_c_add_E
	return p
}

func (*C_add_EContext) IsC_add_EContext() {}

func NewC_add_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *C_add_EContext {
	var p = new(C_add_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_c_add_E

	return p
}

func (s *C_add_EContext) GetParser() antlr.Parser { return s.parser }

func (s *C_add_EContext) Add_op() IAdd_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdd_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdd_opContext)
}

func (s *C_add_EContext) C_mult_E() IC_mult_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IC_mult_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IC_mult_EContext)
}

func (s *C_add_EContext) C_add_E() IC_add_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IC_add_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IC_add_EContext)
}

func (s *C_add_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *C_add_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *C_add_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterC_add_E(s)
	}
}

func (s *C_add_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitC_add_E(s)
	}
}

func (p *bcplParser) C_add_E() (localctx IC_add_EContext) {
	return p.c_add_E(0)
}

func (p *bcplParser) c_add_E(_p int) (localctx IC_add_EContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewC_add_EContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IC_add_EContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 74
	p.EnterRecursionRule(localctx, 74, bcplParserRULE_c_add_E, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(432)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__71, bcplParserT__72:
		{
			p.SetState(428)
			p.Add_op()
		}
		{
			p.SetState(429)
			p.c_mult_E(0)
		}

	case bcplParserT__0, bcplParserT__1, bcplParserT__2, bcplParserT__3, bcplParserT__4, bcplParserT__5, bcplParserT__6, bcplParserT__7, bcplParserT__8, bcplParserT__9, bcplParserT__10, bcplParserT__11, bcplParserT__12, bcplParserT__13, bcplParserT__14, bcplParserT__15, bcplParserT__16, bcplParserT__17, bcplParserT__18, bcplParserT__19, bcplParserT__20, bcplParserT__21, bcplParserT__22, bcplParserT__23, bcplParserT__24, bcplParserT__25, bcplParserT__26, bcplParserT__27, bcplParserT__28, bcplParserT__29, bcplParserT__30, bcplParserT__31, bcplParserT__32, bcplParserT__33, bcplParserT__34, bcplParserT__35, bcplParserT__36, bcplParserT__37, bcplParserT__38, bcplParserT__39, bcplParserT__40, bcplParserT__41, bcplParserT__42, bcplParserT__43, bcplParserT__44, bcplParserT__45, bcplParserT__46, bcplParserT__47, bcplParserT__48, bcplParserT__49, bcplParserT__50, bcplParserT__51, bcplParserT__52, bcplParserT__53, bcplParserT__54, bcplParserT__55, bcplParserT__56, bcplParserT__57, bcplParserT__58, bcplParserT__59, bcplParserT__60, bcplParserT__61, bcplParserT__63, bcplParserT__64, bcplParserT__65, bcplParserT__84, bcplParserTrue_, bcplParserFalse_:
		{
			p.SetState(431)
			p.c_mult_E(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(440)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewC_add_EContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, bcplParserRULE_c_add_E)
			p.SetState(434)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(435)
				p.Add_op()
			}
			{
				p.SetState(436)
				p.c_mult_E(0)
			}

		}
		p.SetState(442)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())
	}

	return localctx
}

// IC_shift_EContext is an interface to support dynamic dispatch.
type IC_shift_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsC_shift_EContext differentiates from other interfaces.
	IsC_shift_EContext()
}

type C_shift_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyC_shift_EContext() *C_shift_EContext {
	var p = new(C_shift_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_c_shift_E
	return p
}

func (*C_shift_EContext) IsC_shift_EContext() {}

func NewC_shift_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *C_shift_EContext {
	var p = new(C_shift_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_c_shift_E

	return p
}

func (s *C_shift_EContext) GetParser() antlr.Parser { return s.parser }

func (s *C_shift_EContext) C_add_E() IC_add_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IC_add_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IC_add_EContext)
}

func (s *C_shift_EContext) C_shift_E() IC_shift_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IC_shift_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IC_shift_EContext)
}

func (s *C_shift_EContext) Shift_op() IShift_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShift_opContext)
}

func (s *C_shift_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *C_shift_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *C_shift_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterC_shift_E(s)
	}
}

func (s *C_shift_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitC_shift_E(s)
	}
}

func (p *bcplParser) C_shift_E() (localctx IC_shift_EContext) {
	return p.c_shift_E(0)
}

func (p *bcplParser) c_shift_E(_p int) (localctx IC_shift_EContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewC_shift_EContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IC_shift_EContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 76
	p.EnterRecursionRule(localctx, 76, bcplParserRULE_c_shift_E, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(444)
		p.c_add_E(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(452)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewC_shift_EContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, bcplParserRULE_c_shift_E)
			p.SetState(446)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(447)
				p.Shift_op()
			}
			{
				p.SetState(448)
				p.c_add_E(0)
			}

		}
		p.SetState(454)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
	}

	return localctx
}

// IC_and_EContext is an interface to support dynamic dispatch.
type IC_and_EContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsC_and_EContext differentiates from other interfaces.
	IsC_and_EContext()
}

type C_and_EContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyC_and_EContext() *C_and_EContext {
	var p = new(C_and_EContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_c_and_E
	return p
}

func (*C_and_EContext) IsC_and_EContext() {}

func NewC_and_EContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *C_and_EContext {
	var p = new(C_and_EContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_c_and_E

	return p
}

func (s *C_and_EContext) GetParser() antlr.Parser { return s.parser }

func (s *C_and_EContext) C_shift_E() IC_shift_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IC_shift_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IC_shift_EContext)
}

func (s *C_and_EContext) C_and_E() IC_and_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IC_and_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IC_and_EContext)
}

func (s *C_and_EContext) And_op() IAnd_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnd_opContext)
}

func (s *C_and_EContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *C_and_EContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *C_and_EContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterC_and_E(s)
	}
}

func (s *C_and_EContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitC_and_E(s)
	}
}

func (p *bcplParser) C_and_E() (localctx IC_and_EContext) {
	return p.c_and_E(0)
}

func (p *bcplParser) c_and_E(_p int) (localctx IC_and_EContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewC_and_EContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IC_and_EContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 78
	p.EnterRecursionRule(localctx, 78, bcplParserRULE_c_and_E, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(456)
		p.c_shift_E(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewC_and_EContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, bcplParserRULE_c_and_E)
			p.SetState(458)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(459)
				p.And_op()
			}
			{
				p.SetState(460)
				p.c_shift_E(0)
			}

		}
		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())
	}

	return localctx
}

// IConstant_expressionContext is an interface to support dynamic dispatch.
type IConstant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_expressionContext differentiates from other interfaces.
	IsConstant_expressionContext()
}

type Constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_expressionContext() *Constant_expressionContext {
	var p = new(Constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_constant_expression
	return p
}

func (*Constant_expressionContext) IsConstant_expressionContext() {}

func NewConstant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_expressionContext {
	var p = new(Constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_constant_expression

	return p
}

func (s *Constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_expressionContext) C_and_E() IC_and_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IC_and_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IC_and_EContext)
}

func (s *Constant_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_expressionContext) Or_op() IOr_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOr_opContext)
}

func (s *Constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterConstant_expression(s)
	}
}

func (s *Constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitConstant_expression(s)
	}
}

func (p *bcplParser) Constant_expression() (localctx IConstant_expressionContext) {
	return p.constant_expression(0)
}

func (p *bcplParser) constant_expression(_p int) (localctx IConstant_expressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewConstant_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IConstant_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 80
	p.EnterRecursionRule(localctx, 80, bcplParserRULE_constant_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(468)
		p.c_and_E(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewConstant_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, bcplParserRULE_constant_expression)
			p.SetState(470)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(471)
				p.Or_op()
			}
			{
				p.SetState(472)
				p.c_and_E(0)
			}

		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext())
	}

	return localctx
}

// IExpression_listContext is an interface to support dynamic dispatch.
type IExpression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_listContext differentiates from other interfaces.
	IsExpression_listContext()
}

type Expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_listContext() *Expression_listContext {
	var p = new(Expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_expression_list
	return p
}

func (*Expression_listContext) IsExpression_listContext() {}

func NewExpression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_listContext {
	var p = new(Expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_expression_list

	return p
}

func (s *Expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_listContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Expression_listContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterExpression_list(s)
	}
}

func (s *Expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitExpression_list(s)
	}
}

func (p *bcplParser) Expression_list() (localctx IExpression_listContext) {
	this := p
	_ = this

	localctx = NewExpression_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, bcplParserRULE_expression_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(479)
		p.Expression()
	}
	p.SetState(484)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(480)
				p.Match(bcplParserT__87)
			}
			{
				p.SetState(481)
				p.Expression()
			}

		}
		p.SetState(486)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())
	}

	return localctx
}

// IName_listContext is an interface to support dynamic dispatch.
type IName_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_listContext differentiates from other interfaces.
	IsName_listContext()
}

type Name_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_listContext() *Name_listContext {
	var p = new(Name_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_name_list
	return p
}

func (*Name_listContext) IsName_listContext() {}

func NewName_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_listContext {
	var p = new(Name_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_name_list

	return p
}

func (s *Name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_listContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Name_listContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterName_list(s)
	}
}

func (s *Name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitName_list(s)
	}
}

func (p *bcplParser) Name_list() (localctx IName_listContext) {
	this := p
	_ = this

	localctx = NewName_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, bcplParserRULE_name_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.Name()
	}
	p.SetState(492)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == bcplParserT__87 {
		{
			p.SetState(488)
			p.Match(bcplParserT__87)
		}
		{
			p.SetState(489)
			p.Name()
		}

		p.SetState(494)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IManifest_itemContext is an interface to support dynamic dispatch.
type IManifest_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsManifest_itemContext differentiates from other interfaces.
	IsManifest_itemContext()
}

type Manifest_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyManifest_itemContext() *Manifest_itemContext {
	var p = new(Manifest_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_manifest_item
	return p
}

func (*Manifest_itemContext) IsManifest_itemContext() {}

func NewManifest_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Manifest_itemContext {
	var p = new(Manifest_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_manifest_item

	return p
}

func (s *Manifest_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Manifest_itemContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Manifest_itemContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Manifest_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Manifest_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Manifest_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterManifest_item(s)
	}
}

func (s *Manifest_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitManifest_item(s)
	}
}

func (p *bcplParser) Manifest_item() (localctx IManifest_itemContext) {
	this := p
	_ = this

	localctx = NewManifest_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, bcplParserRULE_manifest_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(495)
		p.Identifier()
	}
	{
		p.SetState(496)
		p.Match(bcplParserT__73)
	}
	{
		p.SetState(497)
		p.constant_expression(0)
	}

	return localctx
}

// IManifest_listContext is an interface to support dynamic dispatch.
type IManifest_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsManifest_listContext differentiates from other interfaces.
	IsManifest_listContext()
}

type Manifest_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyManifest_listContext() *Manifest_listContext {
	var p = new(Manifest_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_manifest_list
	return p
}

func (*Manifest_listContext) IsManifest_listContext() {}

func NewManifest_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Manifest_listContext {
	var p = new(Manifest_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_manifest_list

	return p
}

func (s *Manifest_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Manifest_listContext) AllManifest_item() []IManifest_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IManifest_itemContext)(nil)).Elem())
	var tst = make([]IManifest_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IManifest_itemContext)
		}
	}

	return tst
}

func (s *Manifest_listContext) Manifest_item(i int) IManifest_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IManifest_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IManifest_itemContext)
}

func (s *Manifest_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Manifest_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Manifest_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterManifest_list(s)
	}
}

func (s *Manifest_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitManifest_list(s)
	}
}

func (p *bcplParser) Manifest_list() (localctx IManifest_listContext) {
	this := p
	_ = this

	localctx = NewManifest_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, bcplParserRULE_manifest_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(499)
		p.Manifest_item()
	}
	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == bcplParserT__89 {
		{
			p.SetState(500)
			p.Match(bcplParserT__89)
		}
		{
			p.SetState(501)
			p.Manifest_item()
		}

		p.SetState(506)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IManifest_declarationContext is an interface to support dynamic dispatch.
type IManifest_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsManifest_declarationContext differentiates from other interfaces.
	IsManifest_declarationContext()
}

type Manifest_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyManifest_declarationContext() *Manifest_declarationContext {
	var p = new(Manifest_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_manifest_declaration
	return p
}

func (*Manifest_declarationContext) IsManifest_declarationContext() {}

func NewManifest_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Manifest_declarationContext {
	var p = new(Manifest_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_manifest_declaration

	return p
}

func (s *Manifest_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Manifest_declarationContext) Left_dollar_open() antlr.TerminalNode {
	return s.GetToken(bcplParserLeft_dollar_open, 0)
}

func (s *Manifest_declarationContext) Manifest_list() IManifest_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IManifest_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IManifest_listContext)
}

func (s *Manifest_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Manifest_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Manifest_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterManifest_declaration(s)
	}
}

func (s *Manifest_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitManifest_declaration(s)
	}
}

func (p *bcplParser) Manifest_declaration() (localctx IManifest_declarationContext) {
	this := p
	_ = this

	localctx = NewManifest_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, bcplParserRULE_manifest_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(507)
		p.Match(bcplParserT__90)
	}
	{
		p.SetState(508)
		p.Match(bcplParserLeft_dollar_open)
	}
	{
		p.SetState(509)
		p.Manifest_list()
	}
	{
		p.SetState(510)
		p.Match(bcplParserT__91)
	}

	return localctx
}

// IStatic_declarationContext is an interface to support dynamic dispatch.
type IStatic_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatic_declarationContext differentiates from other interfaces.
	IsStatic_declarationContext()
}

type Static_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatic_declarationContext() *Static_declarationContext {
	var p = new(Static_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_static_declaration
	return p
}

func (*Static_declarationContext) IsStatic_declarationContext() {}

func NewStatic_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Static_declarationContext {
	var p = new(Static_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_static_declaration

	return p
}

func (s *Static_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Static_declarationContext) Left_dollar_open() antlr.TerminalNode {
	return s.GetToken(bcplParserLeft_dollar_open, 0)
}

func (s *Static_declarationContext) Manifest_list() IManifest_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IManifest_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IManifest_listContext)
}

func (s *Static_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Static_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Static_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterStatic_declaration(s)
	}
}

func (s *Static_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitStatic_declaration(s)
	}
}

func (p *bcplParser) Static_declaration() (localctx IStatic_declarationContext) {
	this := p
	_ = this

	localctx = NewStatic_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, bcplParserRULE_static_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(512)
		p.Match(bcplParserT__92)
	}
	{
		p.SetState(513)
		p.Match(bcplParserLeft_dollar_open)
	}
	{
		p.SetState(514)
		p.Manifest_list()
	}
	{
		p.SetState(515)
		p.Match(bcplParserT__91)
	}

	return localctx
}

// IGlobal_itemContext is an interface to support dynamic dispatch.
type IGlobal_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobal_itemContext differentiates from other interfaces.
	IsGlobal_itemContext()
}

type Global_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_itemContext() *Global_itemContext {
	var p = new(Global_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_global_item
	return p
}

func (*Global_itemContext) IsGlobal_itemContext() {}

func NewGlobal_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_itemContext {
	var p = new(Global_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_global_item

	return p
}

func (s *Global_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_itemContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Global_itemContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Global_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterGlobal_item(s)
	}
}

func (s *Global_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitGlobal_item(s)
	}
}

func (p *bcplParser) Global_item() (localctx IGlobal_itemContext) {
	this := p
	_ = this

	localctx = NewGlobal_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, bcplParserRULE_global_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(517)
		p.Identifier()
	}
	{
		p.SetState(518)
		p.Match(bcplParserT__93)
	}
	{
		p.SetState(519)
		p.constant_expression(0)
	}

	return localctx
}

// IGlobal_listContext is an interface to support dynamic dispatch.
type IGlobal_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobal_listContext differentiates from other interfaces.
	IsGlobal_listContext()
}

type Global_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_listContext() *Global_listContext {
	var p = new(Global_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_global_list
	return p
}

func (*Global_listContext) IsGlobal_listContext() {}

func NewGlobal_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_listContext {
	var p = new(Global_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_global_list

	return p
}

func (s *Global_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_listContext) AllGlobal_item() []IGlobal_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGlobal_itemContext)(nil)).Elem())
	var tst = make([]IGlobal_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGlobal_itemContext)
		}
	}

	return tst
}

func (s *Global_listContext) Global_item(i int) IGlobal_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobal_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGlobal_itemContext)
}

func (s *Global_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterGlobal_list(s)
	}
}

func (s *Global_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitGlobal_list(s)
	}
}

func (p *bcplParser) Global_list() (localctx IGlobal_listContext) {
	this := p
	_ = this

	localctx = NewGlobal_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, bcplParserRULE_global_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(521)
		p.Global_item()
	}
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == bcplParserT__89 {
		{
			p.SetState(522)
			p.Match(bcplParserT__89)
		}
		{
			p.SetState(523)
			p.Global_item()
		}

		p.SetState(528)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGlobal_declarationContext is an interface to support dynamic dispatch.
type IGlobal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobal_declarationContext differentiates from other interfaces.
	IsGlobal_declarationContext()
}

type Global_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_declarationContext() *Global_declarationContext {
	var p = new(Global_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_global_declaration
	return p
}

func (*Global_declarationContext) IsGlobal_declarationContext() {}

func NewGlobal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_declarationContext {
	var p = new(Global_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_global_declaration

	return p
}

func (s *Global_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_declarationContext) Left_dollar_open() antlr.TerminalNode {
	return s.GetToken(bcplParserLeft_dollar_open, 0)
}

func (s *Global_declarationContext) Global_list() IGlobal_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobal_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobal_listContext)
}

func (s *Global_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterGlobal_declaration(s)
	}
}

func (s *Global_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitGlobal_declaration(s)
	}
}

func (p *bcplParser) Global_declaration() (localctx IGlobal_declarationContext) {
	this := p
	_ = this

	localctx = NewGlobal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, bcplParserRULE_global_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(529)
		p.Match(bcplParserT__94)
	}
	{
		p.SetState(530)
		p.Match(bcplParserLeft_dollar_open)
	}
	{
		p.SetState(531)
		p.Global_list()
	}
	{
		p.SetState(532)
		p.Match(bcplParserT__91)
	}

	return localctx
}

// ISimple_definitionContext is an interface to support dynamic dispatch.
type ISimple_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_definitionContext differentiates from other interfaces.
	IsSimple_definitionContext()
}

type Simple_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_definitionContext() *Simple_definitionContext {
	var p = new(Simple_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_simple_definition
	return p
}

func (*Simple_definitionContext) IsSimple_definitionContext() {}

func NewSimple_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_definitionContext {
	var p = new(Simple_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_simple_definition

	return p
}

func (s *Simple_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_definitionContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Simple_definitionContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Simple_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterSimple_definition(s)
	}
}

func (s *Simple_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitSimple_definition(s)
	}
}

func (p *bcplParser) Simple_definition() (localctx ISimple_definitionContext) {
	this := p
	_ = this

	localctx = NewSimple_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, bcplParserRULE_simple_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(534)
		p.Name_list()
	}
	{
		p.SetState(535)
		p.Match(bcplParserT__73)
	}
	{
		p.SetState(536)
		p.Expression_list()
	}

	return localctx
}

// IVector_definitionContext is an interface to support dynamic dispatch.
type IVector_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVector_definitionContext differentiates from other interfaces.
	IsVector_definitionContext()
}

type Vector_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVector_definitionContext() *Vector_definitionContext {
	var p = new(Vector_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_vector_definition
	return p
}

func (*Vector_definitionContext) IsVector_definitionContext() {}

func NewVector_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Vector_definitionContext {
	var p = new(Vector_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_vector_definition

	return p
}

func (s *Vector_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Vector_definitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Vector_definitionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Vector_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Vector_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Vector_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterVector_definition(s)
	}
}

func (s *Vector_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitVector_definition(s)
	}
}

func (p *bcplParser) Vector_definition() (localctx IVector_definitionContext) {
	this := p
	_ = this

	localctx = NewVector_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, bcplParserRULE_vector_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(538)
		p.Identifier()
	}
	{
		p.SetState(539)
		p.Match(bcplParserT__73)
	}
	{
		p.SetState(540)
		p.Match(bcplParserT__95)
	}
	{
		p.SetState(541)
		p.constant_expression(0)
	}

	return localctx
}

// IFunction_definitionContext is an interface to support dynamic dispatch.
type IFunction_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definitionContext differentiates from other interfaces.
	IsFunction_definitionContext()
}

type Function_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definitionContext() *Function_definitionContext {
	var p = new(Function_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_function_definition
	return p
}

func (*Function_definitionContext) IsFunction_definitionContext() {}

func NewFunction_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definitionContext {
	var p = new(Function_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_function_definition

	return p
}

func (s *Function_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Function_definitionContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Function_definitionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterFunction_definition(s)
	}
}

func (s *Function_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitFunction_definition(s)
	}
}

func (p *bcplParser) Function_definition() (localctx IFunction_definitionContext) {
	this := p
	_ = this

	localctx = NewFunction_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, bcplParserRULE_function_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(543)
			p.Identifier()
		}
		{
			p.SetState(544)
			p.Match(bcplParserT__84)
		}
		{
			p.SetState(545)
			p.Name_list()
		}
		{
			p.SetState(546)
			p.Match(bcplParserT__85)
		}
		{
			p.SetState(547)
			p.Match(bcplParserT__73)
		}
		{
			p.SetState(548)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(550)
			p.Identifier()
		}
		{
			p.SetState(551)
			p.Match(bcplParserT__84)
		}
		{
			p.SetState(552)
			p.Match(bcplParserT__85)
		}
		{
			p.SetState(553)
			p.Match(bcplParserT__73)
		}
		{
			p.SetState(554)
			p.Expression()
		}

	}

	return localctx
}

// IRoutine_definitionContext is an interface to support dynamic dispatch.
type IRoutine_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutine_definitionContext differentiates from other interfaces.
	IsRoutine_definitionContext()
}

type Routine_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutine_definitionContext() *Routine_definitionContext {
	var p = new(Routine_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_routine_definition
	return p
}

func (*Routine_definitionContext) IsRoutine_definitionContext() {}

func NewRoutine_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Routine_definitionContext {
	var p = new(Routine_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_routine_definition

	return p
}

func (s *Routine_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Routine_definitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Routine_definitionContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Routine_definitionContext) Command() ICommandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommandContext)
}

func (s *Routine_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Routine_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Routine_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterRoutine_definition(s)
	}
}

func (s *Routine_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitRoutine_definition(s)
	}
}

func (p *bcplParser) Routine_definition() (localctx IRoutine_definitionContext) {
	this := p
	_ = this

	localctx = NewRoutine_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, bcplParserRULE_routine_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(571)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(558)
			p.Identifier()
		}
		{
			p.SetState(559)
			p.Match(bcplParserT__84)
		}
		{
			p.SetState(560)
			p.Name_list()
		}
		{
			p.SetState(561)
			p.Match(bcplParserT__85)
		}
		{
			p.SetState(562)
			p.Match(bcplParserT__96)
		}
		{
			p.SetState(563)
			p.Command()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(565)
			p.Identifier()
		}
		{
			p.SetState(566)
			p.Match(bcplParserT__84)
		}
		{
			p.SetState(567)
			p.Match(bcplParserT__85)
		}
		{
			p.SetState(568)
			p.Match(bcplParserT__96)
		}
		{
			p.SetState(569)
			p.Command()
		}

	}

	return localctx
}

// IDefinitionContext is an interface to support dynamic dispatch.
type IDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinitionContext differentiates from other interfaces.
	IsDefinitionContext()
}

type DefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionContext() *DefinitionContext {
	var p = new(DefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_definition
	return p
}

func (*DefinitionContext) IsDefinitionContext() {}

func NewDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionContext {
	var p = new(DefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_definition

	return p
}

func (s *DefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionContext) Simple_definition() ISimple_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_definitionContext)
}

func (s *DefinitionContext) Vector_definition() IVector_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVector_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVector_definitionContext)
}

func (s *DefinitionContext) Function_definition() IFunction_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_definitionContext)
}

func (s *DefinitionContext) Routine_definition() IRoutine_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutine_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutine_definitionContext)
}

func (s *DefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterDefinition(s)
	}
}

func (s *DefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitDefinition(s)
	}
}

func (p *bcplParser) Definition() (localctx IDefinitionContext) {
	this := p
	_ = this

	localctx = NewDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, bcplParserRULE_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(573)
			p.Simple_definition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(574)
			p.Vector_definition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(575)
			p.Function_definition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(576)
			p.Routine_definition()
		}

	}

	return localctx
}

// ISimultaneous_declarationContext is an interface to support dynamic dispatch.
type ISimultaneous_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimultaneous_declarationContext differentiates from other interfaces.
	IsSimultaneous_declarationContext()
}

type Simultaneous_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimultaneous_declarationContext() *Simultaneous_declarationContext {
	var p = new(Simultaneous_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_simultaneous_declaration
	return p
}

func (*Simultaneous_declarationContext) IsSimultaneous_declarationContext() {}

func NewSimultaneous_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simultaneous_declarationContext {
	var p = new(Simultaneous_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_simultaneous_declaration

	return p
}

func (s *Simultaneous_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Simultaneous_declarationContext) AllDefinition() []IDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDefinitionContext)(nil)).Elem())
	var tst = make([]IDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDefinitionContext)
		}
	}

	return tst
}

func (s *Simultaneous_declarationContext) Definition(i int) IDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDefinitionContext)
}

func (s *Simultaneous_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simultaneous_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simultaneous_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterSimultaneous_declaration(s)
	}
}

func (s *Simultaneous_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitSimultaneous_declaration(s)
	}
}

func (p *bcplParser) Simultaneous_declaration() (localctx ISimultaneous_declarationContext) {
	this := p
	_ = this

	localctx = NewSimultaneous_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, bcplParserRULE_simultaneous_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(579)
		p.Match(bcplParserT__97)
	}
	{
		p.SetState(580)
		p.Definition()
	}
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == bcplParserT__98 {
		{
			p.SetState(581)
			p.Match(bcplParserT__98)
		}
		{
			p.SetState(582)
			p.Definition()
		}

		p.SetState(587)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) Simultaneous_declaration() ISimultaneous_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_declarationContext)
}

func (s *DeclarationContext) Manifest_declaration() IManifest_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IManifest_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IManifest_declarationContext)
}

func (s *DeclarationContext) Static_declaration() IStatic_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatic_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatic_declarationContext)
}

func (s *DeclarationContext) Global_declaration() IGlobal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobal_declarationContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (p *bcplParser) Declaration() (localctx IDeclarationContext) {
	this := p
	_ = this

	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, bcplParserRULE_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(592)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__97:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(588)
			p.Simultaneous_declaration()
		}

	case bcplParserT__90:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(589)
			p.Manifest_declaration()
		}

	case bcplParserT__92:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(590)
			p.Static_declaration()
		}

	case bcplParserT__94:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(591)
			p.Global_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILhseContext is an interface to support dynamic dispatch.
type ILhseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLhseContext differentiates from other interfaces.
	IsLhseContext()
}

type LhseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLhseContext() *LhseContext {
	var p = new(LhseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_lhse
	return p
}

func (*LhseContext) IsLhseContext() {}

func NewLhseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LhseContext {
	var p = new(LhseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_lhse

	return p
}

func (s *LhseContext) GetParser() antlr.Parser { return s.parser }

func (s *LhseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LhseContext) Vector_E() IVector_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVector_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVector_EContext)
}

func (s *LhseContext) Primary_E() IPrimary_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_EContext)
}

func (s *LhseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LhseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LhseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterLhse(s)
	}
}

func (s *LhseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitLhse(s)
	}
}

func (p *bcplParser) Lhse() (localctx ILhseContext) {
	this := p
	_ = this

	localctx = NewLhseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, bcplParserRULE_lhse)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(601)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(594)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(595)
			p.vector_E(0)
		}
		{
			p.SetState(596)
			p.Match(bcplParserT__68)
		}
		{
			p.SetState(597)
			p.primary_E(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(599)
			p.Match(bcplParserT__68)
		}
		{
			p.SetState(600)
			p.primary_E(0)
		}

	}

	return localctx
}

// ILeft_hand_side_listContext is an interface to support dynamic dispatch.
type ILeft_hand_side_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLeft_hand_side_listContext differentiates from other interfaces.
	IsLeft_hand_side_listContext()
}

type Left_hand_side_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeft_hand_side_listContext() *Left_hand_side_listContext {
	var p = new(Left_hand_side_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_left_hand_side_list
	return p
}

func (*Left_hand_side_listContext) IsLeft_hand_side_listContext() {}

func NewLeft_hand_side_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Left_hand_side_listContext {
	var p = new(Left_hand_side_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_left_hand_side_list

	return p
}

func (s *Left_hand_side_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Left_hand_side_listContext) AllLhse() []ILhseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILhseContext)(nil)).Elem())
	var tst = make([]ILhseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILhseContext)
		}
	}

	return tst
}

func (s *Left_hand_side_listContext) Lhse(i int) ILhseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILhseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILhseContext)
}

func (s *Left_hand_side_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Left_hand_side_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Left_hand_side_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterLeft_hand_side_list(s)
	}
}

func (s *Left_hand_side_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitLeft_hand_side_list(s)
	}
}

func (p *bcplParser) Left_hand_side_list() (localctx ILeft_hand_side_listContext) {
	this := p
	_ = this

	localctx = NewLeft_hand_side_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, bcplParserRULE_left_hand_side_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(603)
		p.Lhse()
	}
	p.SetState(608)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == bcplParserT__87 {
		{
			p.SetState(604)
			p.Match(bcplParserT__87)
		}
		{
			p.SetState(605)
			p.Lhse()
		}

		p.SetState(610)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_assignment
	return p
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) Left_hand_side_list() ILeft_hand_side_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_hand_side_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_hand_side_listContext)
}

func (s *AssignmentContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (p *bcplParser) Assignment() (localctx IAssignmentContext) {
	this := p
	_ = this

	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, bcplParserRULE_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(611)
		p.Left_hand_side_list()
	}
	{
		p.SetState(612)
		p.Match(bcplParserT__99)
	}
	{
		p.SetState(613)
		p.Expression_list()
	}

	return localctx
}

// ISimple_commandContext is an interface to support dynamic dispatch.
type ISimple_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_commandContext differentiates from other interfaces.
	IsSimple_commandContext()
}

type Simple_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_commandContext() *Simple_commandContext {
	var p = new(Simple_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_simple_command
	return p
}

func (*Simple_commandContext) IsSimple_commandContext() {}

func NewSimple_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_commandContext {
	var p = new(Simple_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_simple_command

	return p
}

func (s *Simple_commandContext) GetParser() antlr.Parser { return s.parser }
func (s *Simple_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterSimple_command(s)
	}
}

func (s *Simple_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitSimple_command(s)
	}
}

func (p *bcplParser) Simple_command() (localctx ISimple_commandContext) {
	this := p
	_ = this

	localctx = NewSimple_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, bcplParserRULE_simple_command)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(615)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(bcplParserT__100-101))|(1<<(bcplParserT__101-101))|(1<<(bcplParserT__102-101))|(1<<(bcplParserT__103-101))|(1<<(bcplParserT__104-101)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IGoto_commandContext is an interface to support dynamic dispatch.
type IGoto_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoto_commandContext differentiates from other interfaces.
	IsGoto_commandContext()
}

type Goto_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoto_commandContext() *Goto_commandContext {
	var p = new(Goto_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_goto_command
	return p
}

func (*Goto_commandContext) IsGoto_commandContext() {}

func NewGoto_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Goto_commandContext {
	var p = new(Goto_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_goto_command

	return p
}

func (s *Goto_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Goto_commandContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Goto_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Goto_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Goto_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterGoto_command(s)
	}
}

func (s *Goto_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitGoto_command(s)
	}
}

func (p *bcplParser) Goto_command() (localctx IGoto_commandContext) {
	this := p
	_ = this

	localctx = NewGoto_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, bcplParserRULE_goto_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.Match(bcplParserT__105)
	}
	{
		p.SetState(618)
		p.Expression()
	}

	return localctx
}

// IRoutine_commandContext is an interface to support dynamic dispatch.
type IRoutine_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutine_commandContext differentiates from other interfaces.
	IsRoutine_commandContext()
}

type Routine_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutine_commandContext() *Routine_commandContext {
	var p = new(Routine_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_routine_command
	return p
}

func (*Routine_commandContext) IsRoutine_commandContext() {}

func NewRoutine_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Routine_commandContext {
	var p = new(Routine_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_routine_command

	return p
}

func (s *Routine_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Routine_commandContext) Primary_E() IPrimary_EContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_EContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_EContext)
}

func (s *Routine_commandContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Routine_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Routine_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Routine_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterRoutine_command(s)
	}
}

func (s *Routine_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitRoutine_command(s)
	}
}

func (p *bcplParser) Routine_command() (localctx IRoutine_commandContext) {
	this := p
	_ = this

	localctx = NewRoutine_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, bcplParserRULE_routine_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(620)
			p.primary_E(0)
		}
		{
			p.SetState(621)
			p.Match(bcplParserT__84)
		}
		{
			p.SetState(622)
			p.Expression_list()
		}
		{
			p.SetState(623)
			p.Match(bcplParserT__85)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(625)
			p.primary_E(0)
		}
		{
			p.SetState(626)
			p.Match(bcplParserT__84)
		}
		{
			p.SetState(627)
			p.Match(bcplParserT__85)
		}

	}

	return localctx
}

// IResultis_commandContext is an interface to support dynamic dispatch.
type IResultis_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResultis_commandContext differentiates from other interfaces.
	IsResultis_commandContext()
}

type Resultis_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultis_commandContext() *Resultis_commandContext {
	var p = new(Resultis_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_resultis_command
	return p
}

func (*Resultis_commandContext) IsResultis_commandContext() {}

func NewResultis_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Resultis_commandContext {
	var p = new(Resultis_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_resultis_command

	return p
}

func (s *Resultis_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Resultis_commandContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Resultis_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Resultis_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Resultis_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterResultis_command(s)
	}
}

func (s *Resultis_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitResultis_command(s)
	}
}

func (p *bcplParser) Resultis_command() (localctx IResultis_commandContext) {
	this := p
	_ = this

	localctx = NewResultis_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, bcplParserRULE_resultis_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		p.Match(bcplParserT__106)
	}
	{
		p.SetState(632)
		p.Expression()
	}

	return localctx
}

// ISwitchon_commandContext is an interface to support dynamic dispatch.
type ISwitchon_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchon_commandContext differentiates from other interfaces.
	IsSwitchon_commandContext()
}

type Switchon_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchon_commandContext() *Switchon_commandContext {
	var p = new(Switchon_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_switchon_command
	return p
}

func (*Switchon_commandContext) IsSwitchon_commandContext() {}

func NewSwitchon_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Switchon_commandContext {
	var p = new(Switchon_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_switchon_command

	return p
}

func (s *Switchon_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Switchon_commandContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Switchon_commandContext) Compound_command() ICompound_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_commandContext)
}

func (s *Switchon_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Switchon_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Switchon_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterSwitchon_command(s)
	}
}

func (s *Switchon_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitSwitchon_command(s)
	}
}

func (p *bcplParser) Switchon_command() (localctx ISwitchon_commandContext) {
	this := p
	_ = this

	localctx = NewSwitchon_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, bcplParserRULE_switchon_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(634)
		p.Match(bcplParserT__107)
	}
	{
		p.SetState(635)
		p.Expression()
	}
	{
		p.SetState(636)
		p.Match(bcplParserT__108)
	}
	{
		p.SetState(637)
		p.Compound_command()
	}

	return localctx
}

// IRepeatable_commandContext is an interface to support dynamic dispatch.
type IRepeatable_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRepeatable_commandContext differentiates from other interfaces.
	IsRepeatable_commandContext()
}

type Repeatable_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatable_commandContext() *Repeatable_commandContext {
	var p = new(Repeatable_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_repeatable_command
	return p
}

func (*Repeatable_commandContext) IsRepeatable_commandContext() {}

func NewRepeatable_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Repeatable_commandContext {
	var p = new(Repeatable_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_repeatable_command

	return p
}

func (s *Repeatable_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Repeatable_commandContext) Assignment() IAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *Repeatable_commandContext) Simple_command() ISimple_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_commandContext)
}

func (s *Repeatable_commandContext) Goto_command() IGoto_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoto_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoto_commandContext)
}

func (s *Repeatable_commandContext) Routine_command() IRoutine_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutine_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutine_commandContext)
}

func (s *Repeatable_commandContext) Resultis_command() IResultis_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResultis_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IResultis_commandContext)
}

func (s *Repeatable_commandContext) Switchon_command() ISwitchon_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchon_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchon_commandContext)
}

func (s *Repeatable_commandContext) Compound_command() ICompound_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_commandContext)
}

func (s *Repeatable_commandContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Repeatable_commandContext) Repeatable_command() IRepeatable_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRepeatable_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRepeatable_commandContext)
}

func (s *Repeatable_commandContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Repeatable_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Repeatable_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Repeatable_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterRepeatable_command(s)
	}
}

func (s *Repeatable_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitRepeatable_command(s)
	}
}

func (p *bcplParser) Repeatable_command() (localctx IRepeatable_commandContext) {
	return p.repeatable_command(0)
}

func (p *bcplParser) repeatable_command(_p int) (localctx IRepeatable_commandContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRepeatable_commandContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRepeatable_commandContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 130
	p.EnterRecursionRule(localctx, 130, bcplParserRULE_repeatable_command, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(640)
			p.Assignment()
		}

	case 2:
		{
			p.SetState(641)
			p.Simple_command()
		}

	case 3:
		{
			p.SetState(642)
			p.Goto_command()
		}

	case 4:
		{
			p.SetState(643)
			p.Routine_command()
		}

	case 5:
		{
			p.SetState(644)
			p.Resultis_command()
		}

	case 6:
		{
			p.SetState(645)
			p.Switchon_command()
		}

	case 7:
		{
			p.SetState(646)
			p.Compound_command()
		}

	case 8:
		{
			p.SetState(647)
			p.Block()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(660)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(658)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
			case 1:
				localctx = NewRepeatable_commandContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bcplParserRULE_repeatable_command)
				p.SetState(650)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(651)
					p.Match(bcplParserT__109)
				}

			case 2:
				localctx = NewRepeatable_commandContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bcplParserRULE_repeatable_command)
				p.SetState(652)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(653)
					p.Match(bcplParserT__110)
				}
				{
					p.SetState(654)
					p.Expression()
				}

			case 3:
				localctx = NewRepeatable_commandContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bcplParserRULE_repeatable_command)
				p.SetState(655)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(656)
					p.Match(bcplParserT__111)
				}
				{
					p.SetState(657)
					p.Expression()
				}

			}

		}
		p.SetState(662)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())
	}

	return localctx
}

// IRepeated_commandContext is an interface to support dynamic dispatch.
type IRepeated_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRepeated_commandContext differentiates from other interfaces.
	IsRepeated_commandContext()
}

type Repeated_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeated_commandContext() *Repeated_commandContext {
	var p = new(Repeated_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_repeated_command
	return p
}

func (*Repeated_commandContext) IsRepeated_commandContext() {}

func NewRepeated_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Repeated_commandContext {
	var p = new(Repeated_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_repeated_command

	return p
}

func (s *Repeated_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Repeated_commandContext) Repeatable_command() IRepeatable_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRepeatable_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRepeatable_commandContext)
}

func (s *Repeated_commandContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Repeated_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Repeated_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Repeated_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterRepeated_command(s)
	}
}

func (s *Repeated_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitRepeated_command(s)
	}
}

func (p *bcplParser) Repeated_command() (localctx IRepeated_commandContext) {
	this := p
	_ = this

	localctx = NewRepeated_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, bcplParserRULE_repeated_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(663)
			p.repeatable_command(0)
		}
		{
			p.SetState(664)
			p.Match(bcplParserT__109)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(666)
			p.repeatable_command(0)
		}
		{
			p.SetState(667)
			p.Match(bcplParserT__110)
		}
		{
			p.SetState(668)
			p.Expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(670)
			p.repeatable_command(0)
		}
		{
			p.SetState(671)
			p.Match(bcplParserT__111)
		}
		{
			p.SetState(672)
			p.Expression()
		}

	}

	return localctx
}

// IUntil_commandContext is an interface to support dynamic dispatch.
type IUntil_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUntil_commandContext differentiates from other interfaces.
	IsUntil_commandContext()
}

type Until_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUntil_commandContext() *Until_commandContext {
	var p = new(Until_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_until_command
	return p
}

func (*Until_commandContext) IsUntil_commandContext() {}

func NewUntil_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Until_commandContext {
	var p = new(Until_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_until_command

	return p
}

func (s *Until_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Until_commandContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Until_commandContext) Command() ICommandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommandContext)
}

func (s *Until_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Until_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Until_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterUntil_command(s)
	}
}

func (s *Until_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitUntil_command(s)
	}
}

func (p *bcplParser) Until_command() (localctx IUntil_commandContext) {
	this := p
	_ = this

	localctx = NewUntil_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, bcplParserRULE_until_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(676)
		p.Match(bcplParserT__112)
	}
	{
		p.SetState(677)
		p.Expression()
	}
	{
		p.SetState(678)
		p.Match(bcplParserT__113)
	}
	{
		p.SetState(679)
		p.Command()
	}

	return localctx
}

// IWhile_commandContext is an interface to support dynamic dispatch.
type IWhile_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhile_commandContext differentiates from other interfaces.
	IsWhile_commandContext()
}

type While_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_commandContext() *While_commandContext {
	var p = new(While_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_while_command
	return p
}

func (*While_commandContext) IsWhile_commandContext() {}

func NewWhile_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_commandContext {
	var p = new(While_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_while_command

	return p
}

func (s *While_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *While_commandContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *While_commandContext) Command() ICommandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommandContext)
}

func (s *While_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *While_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterWhile_command(s)
	}
}

func (s *While_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitWhile_command(s)
	}
}

func (p *bcplParser) While_command() (localctx IWhile_commandContext) {
	this := p
	_ = this

	localctx = NewWhile_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, bcplParserRULE_while_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(681)
		p.Match(bcplParserT__114)
	}
	{
		p.SetState(682)
		p.Expression()
	}
	{
		p.SetState(683)
		p.Match(bcplParserT__113)
	}
	{
		p.SetState(684)
		p.Command()
	}

	return localctx
}

// IFor_commandContext is an interface to support dynamic dispatch.
type IFor_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_commandContext differentiates from other interfaces.
	IsFor_commandContext()
}

type For_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_commandContext() *For_commandContext {
	var p = new(For_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_for_command
	return p
}

func (*For_commandContext) IsFor_commandContext() {}

func NewFor_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_commandContext {
	var p = new(For_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_for_command

	return p
}

func (s *For_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *For_commandContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *For_commandContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *For_commandContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *For_commandContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *For_commandContext) Command() ICommandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommandContext)
}

func (s *For_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterFor_command(s)
	}
}

func (s *For_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitFor_command(s)
	}
}

func (p *bcplParser) For_command() (localctx IFor_commandContext) {
	this := p
	_ = this

	localctx = NewFor_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, bcplParserRULE_for_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(706)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(686)
			p.Match(bcplParserT__115)
		}
		{
			p.SetState(687)
			p.Identifier()
		}
		{
			p.SetState(688)
			p.Match(bcplParserT__73)
		}
		{
			p.SetState(689)
			p.Expression()
		}
		{
			p.SetState(690)
			p.Match(bcplParserT__116)
		}
		{
			p.SetState(691)
			p.Expression()
		}
		{
			p.SetState(692)
			p.Match(bcplParserT__117)
		}
		{
			p.SetState(693)
			p.constant_expression(0)
		}
		{
			p.SetState(694)
			p.Match(bcplParserT__113)
		}
		{
			p.SetState(695)
			p.Command()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(697)
			p.Match(bcplParserT__115)
		}
		{
			p.SetState(698)
			p.Identifier()
		}
		{
			p.SetState(699)
			p.Match(bcplParserT__73)
		}
		{
			p.SetState(700)
			p.Expression()
		}
		{
			p.SetState(701)
			p.Match(bcplParserT__116)
		}
		{
			p.SetState(702)
			p.Expression()
		}
		{
			p.SetState(703)
			p.Match(bcplParserT__113)
		}
		{
			p.SetState(704)
			p.Command()
		}

	}

	return localctx
}

// IRepetitive_commandContext is an interface to support dynamic dispatch.
type IRepetitive_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRepetitive_commandContext differentiates from other interfaces.
	IsRepetitive_commandContext()
}

type Repetitive_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepetitive_commandContext() *Repetitive_commandContext {
	var p = new(Repetitive_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_repetitive_command
	return p
}

func (*Repetitive_commandContext) IsRepetitive_commandContext() {}

func NewRepetitive_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Repetitive_commandContext {
	var p = new(Repetitive_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_repetitive_command

	return p
}

func (s *Repetitive_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Repetitive_commandContext) Repeated_command() IRepeated_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRepeated_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRepeated_commandContext)
}

func (s *Repetitive_commandContext) Until_command() IUntil_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUntil_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUntil_commandContext)
}

func (s *Repetitive_commandContext) While_command() IWhile_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhile_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhile_commandContext)
}

func (s *Repetitive_commandContext) For_command() IFor_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_commandContext)
}

func (s *Repetitive_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Repetitive_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Repetitive_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterRepetitive_command(s)
	}
}

func (s *Repetitive_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitRepetitive_command(s)
	}
}

func (p *bcplParser) Repetitive_command() (localctx IRepetitive_commandContext) {
	this := p
	_ = this

	localctx = NewRepetitive_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, bcplParserRULE_repetitive_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(712)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__0, bcplParserT__1, bcplParserT__2, bcplParserT__3, bcplParserT__4, bcplParserT__5, bcplParserT__6, bcplParserT__7, bcplParserT__8, bcplParserT__9, bcplParserT__10, bcplParserT__11, bcplParserT__12, bcplParserT__13, bcplParserT__14, bcplParserT__15, bcplParserT__16, bcplParserT__17, bcplParserT__18, bcplParserT__19, bcplParserT__20, bcplParserT__21, bcplParserT__22, bcplParserT__23, bcplParserT__24, bcplParserT__25, bcplParserT__26, bcplParserT__27, bcplParserT__28, bcplParserT__29, bcplParserT__30, bcplParserT__31, bcplParserT__32, bcplParserT__33, bcplParserT__34, bcplParserT__35, bcplParserT__36, bcplParserT__37, bcplParserT__38, bcplParserT__39, bcplParserT__40, bcplParserT__41, bcplParserT__42, bcplParserT__43, bcplParserT__44, bcplParserT__45, bcplParserT__46, bcplParserT__47, bcplParserT__48, bcplParserT__49, bcplParserT__50, bcplParserT__51, bcplParserT__52, bcplParserT__53, bcplParserT__54, bcplParserT__55, bcplParserT__56, bcplParserT__57, bcplParserT__58, bcplParserT__59, bcplParserT__60, bcplParserT__61, bcplParserT__62, bcplParserT__63, bcplParserT__64, bcplParserT__65, bcplParserT__68, bcplParserT__84, bcplParserT__100, bcplParserT__101, bcplParserT__102, bcplParserT__103, bcplParserT__104, bcplParserT__105, bcplParserT__106, bcplParserT__107, bcplParserTrue_, bcplParserFalse_, bcplParserLeft_dollar_open:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(708)
			p.Repeated_command()
		}

	case bcplParserT__112:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(709)
			p.Until_command()
		}

	case bcplParserT__114:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(710)
			p.While_command()
		}

	case bcplParserT__115:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(711)
			p.For_command()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITest_commandContext is an interface to support dynamic dispatch.
type ITest_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTest_commandContext differentiates from other interfaces.
	IsTest_commandContext()
}

type Test_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTest_commandContext() *Test_commandContext {
	var p = new(Test_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_test_command
	return p
}

func (*Test_commandContext) IsTest_commandContext() {}

func NewTest_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Test_commandContext {
	var p = new(Test_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_test_command

	return p
}

func (s *Test_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Test_commandContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Test_commandContext) AllCommand() []ICommandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICommandContext)(nil)).Elem())
	var tst = make([]ICommandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICommandContext)
		}
	}

	return tst
}

func (s *Test_commandContext) Command(i int) ICommandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICommandContext)
}

func (s *Test_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Test_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Test_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterTest_command(s)
	}
}

func (s *Test_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitTest_command(s)
	}
}

func (p *bcplParser) Test_command() (localctx ITest_commandContext) {
	this := p
	_ = this

	localctx = NewTest_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, bcplParserRULE_test_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(714)
		p.Match(bcplParserT__118)
	}
	{
		p.SetState(715)
		p.Expression()
	}
	{
		p.SetState(716)
		p.Match(bcplParserT__119)
	}
	{
		p.SetState(717)
		p.Command()
	}
	{
		p.SetState(718)
		p.Match(bcplParserT__120)
	}
	{
		p.SetState(719)
		p.Command()
	}

	return localctx
}

// IIf_commandContext is an interface to support dynamic dispatch.
type IIf_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_commandContext differentiates from other interfaces.
	IsIf_commandContext()
}

type If_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_commandContext() *If_commandContext {
	var p = new(If_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_if_command
	return p
}

func (*If_commandContext) IsIf_commandContext() {}

func NewIf_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_commandContext {
	var p = new(If_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_if_command

	return p
}

func (s *If_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *If_commandContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *If_commandContext) Command() ICommandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommandContext)
}

func (s *If_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterIf_command(s)
	}
}

func (s *If_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitIf_command(s)
	}
}

func (p *bcplParser) If_command() (localctx IIf_commandContext) {
	this := p
	_ = this

	localctx = NewIf_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, bcplParserRULE_if_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(721)
		p.Match(bcplParserT__121)
	}
	{
		p.SetState(722)
		p.Expression()
	}
	{
		p.SetState(723)
		p.Match(bcplParserT__119)
	}
	{
		p.SetState(724)
		p.Command()
	}

	return localctx
}

// IUnless_commandContext is an interface to support dynamic dispatch.
type IUnless_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnless_commandContext differentiates from other interfaces.
	IsUnless_commandContext()
}

type Unless_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnless_commandContext() *Unless_commandContext {
	var p = new(Unless_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_unless_command
	return p
}

func (*Unless_commandContext) IsUnless_commandContext() {}

func NewUnless_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unless_commandContext {
	var p = new(Unless_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_unless_command

	return p
}

func (s *Unless_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Unless_commandContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Unless_commandContext) Command() ICommandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommandContext)
}

func (s *Unless_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unless_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unless_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterUnless_command(s)
	}
}

func (s *Unless_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitUnless_command(s)
	}
}

func (p *bcplParser) Unless_command() (localctx IUnless_commandContext) {
	this := p
	_ = this

	localctx = NewUnless_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, bcplParserRULE_unless_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(726)
		p.Match(bcplParserT__122)
	}
	{
		p.SetState(727)
		p.Expression()
	}
	{
		p.SetState(728)
		p.Match(bcplParserT__119)
	}
	{
		p.SetState(729)
		p.Command()
	}

	return localctx
}

// IUnlabelled_commandContext is an interface to support dynamic dispatch.
type IUnlabelled_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnlabelled_commandContext differentiates from other interfaces.
	IsUnlabelled_commandContext()
}

type Unlabelled_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlabelled_commandContext() *Unlabelled_commandContext {
	var p = new(Unlabelled_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_unlabelled_command
	return p
}

func (*Unlabelled_commandContext) IsUnlabelled_commandContext() {}

func NewUnlabelled_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unlabelled_commandContext {
	var p = new(Unlabelled_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_unlabelled_command

	return p
}

func (s *Unlabelled_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Unlabelled_commandContext) Repeatable_command() IRepeatable_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRepeatable_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRepeatable_commandContext)
}

func (s *Unlabelled_commandContext) Repetitive_command() IRepetitive_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRepetitive_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRepetitive_commandContext)
}

func (s *Unlabelled_commandContext) Test_command() ITest_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITest_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITest_commandContext)
}

func (s *Unlabelled_commandContext) If_command() IIf_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_commandContext)
}

func (s *Unlabelled_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unlabelled_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unlabelled_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterUnlabelled_command(s)
	}
}

func (s *Unlabelled_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitUnlabelled_command(s)
	}
}

func (p *bcplParser) Unlabelled_command() (localctx IUnlabelled_commandContext) {
	this := p
	_ = this

	localctx = NewUnlabelled_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, bcplParserRULE_unlabelled_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(731)
			p.repeatable_command(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(732)
			p.Repetitive_command()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(733)
			p.Test_command()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(734)
			p.If_command()
		}

	}

	return localctx
}

// ILabel_prefixContext is an interface to support dynamic dispatch.
type ILabel_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabel_prefixContext differentiates from other interfaces.
	IsLabel_prefixContext()
}

type Label_prefixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabel_prefixContext() *Label_prefixContext {
	var p = new(Label_prefixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_label_prefix
	return p
}

func (*Label_prefixContext) IsLabel_prefixContext() {}

func NewLabel_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Label_prefixContext {
	var p = new(Label_prefixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_label_prefix

	return p
}

func (s *Label_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Label_prefixContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Label_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Label_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Label_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterLabel_prefix(s)
	}
}

func (s *Label_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitLabel_prefix(s)
	}
}

func (p *bcplParser) Label_prefix() (localctx ILabel_prefixContext) {
	this := p
	_ = this

	localctx = NewLabel_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, bcplParserRULE_label_prefix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(737)
		p.Identifier()
	}
	{
		p.SetState(738)
		p.Match(bcplParserT__93)
	}

	return localctx
}

// ICase_prefixContext is an interface to support dynamic dispatch.
type ICase_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_prefixContext differentiates from other interfaces.
	IsCase_prefixContext()
}

type Case_prefixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_prefixContext() *Case_prefixContext {
	var p = new(Case_prefixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_case_prefix
	return p
}

func (*Case_prefixContext) IsCase_prefixContext() {}

func NewCase_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_prefixContext {
	var p = new(Case_prefixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_case_prefix

	return p
}

func (s *Case_prefixContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_prefixContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Case_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterCase_prefix(s)
	}
}

func (s *Case_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitCase_prefix(s)
	}
}

func (p *bcplParser) Case_prefix() (localctx ICase_prefixContext) {
	this := p
	_ = this

	localctx = NewCase_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, bcplParserRULE_case_prefix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(740)
		p.Match(bcplParserT__123)
	}
	{
		p.SetState(741)
		p.constant_expression(0)
	}
	{
		p.SetState(742)
		p.Match(bcplParserT__93)
	}

	return localctx
}

// IDefault_prefixContext is an interface to support dynamic dispatch.
type IDefault_prefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefault_prefixContext differentiates from other interfaces.
	IsDefault_prefixContext()
}

type Default_prefixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefault_prefixContext() *Default_prefixContext {
	var p = new(Default_prefixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_default_prefix
	return p
}

func (*Default_prefixContext) IsDefault_prefixContext() {}

func NewDefault_prefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Default_prefixContext {
	var p = new(Default_prefixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_default_prefix

	return p
}

func (s *Default_prefixContext) GetParser() antlr.Parser { return s.parser }
func (s *Default_prefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Default_prefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Default_prefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterDefault_prefix(s)
	}
}

func (s *Default_prefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitDefault_prefix(s)
	}
}

func (p *bcplParser) Default_prefix() (localctx IDefault_prefixContext) {
	this := p
	_ = this

	localctx = NewDefault_prefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, bcplParserRULE_default_prefix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(744)
		p.Match(bcplParserT__124)
	}
	{
		p.SetState(745)
		p.Match(bcplParserT__93)
	}

	return localctx
}

// IPrefix_Context is an interface to support dynamic dispatch.
type IPrefix_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrefix_Context differentiates from other interfaces.
	IsPrefix_Context()
}

type Prefix_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefix_Context() *Prefix_Context {
	var p = new(Prefix_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_prefix_
	return p
}

func (*Prefix_Context) IsPrefix_Context() {}

func NewPrefix_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Prefix_Context {
	var p = new(Prefix_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_prefix_

	return p
}

func (s *Prefix_Context) GetParser() antlr.Parser { return s.parser }

func (s *Prefix_Context) Label_prefix() ILabel_prefixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_prefixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_prefixContext)
}

func (s *Prefix_Context) Case_prefix() ICase_prefixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_prefixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_prefixContext)
}

func (s *Prefix_Context) Default_prefix() IDefault_prefixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_prefixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_prefixContext)
}

func (s *Prefix_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Prefix_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Prefix_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterPrefix_(s)
	}
}

func (s *Prefix_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitPrefix_(s)
	}
}

func (p *bcplParser) Prefix_() (localctx IPrefix_Context) {
	this := p
	_ = this

	localctx = NewPrefix_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, bcplParserRULE_prefix_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(750)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__0, bcplParserT__1, bcplParserT__2, bcplParserT__3, bcplParserT__4, bcplParserT__5, bcplParserT__6, bcplParserT__7, bcplParserT__8, bcplParserT__9, bcplParserT__10, bcplParserT__11, bcplParserT__12, bcplParserT__13, bcplParserT__14, bcplParserT__15, bcplParserT__16, bcplParserT__17, bcplParserT__18, bcplParserT__19, bcplParserT__20, bcplParserT__21, bcplParserT__22, bcplParserT__23, bcplParserT__24, bcplParserT__25, bcplParserT__26, bcplParserT__27, bcplParserT__28, bcplParserT__29, bcplParserT__30, bcplParserT__31, bcplParserT__32, bcplParserT__33, bcplParserT__34, bcplParserT__35, bcplParserT__36, bcplParserT__37, bcplParserT__38, bcplParserT__39, bcplParserT__40, bcplParserT__41, bcplParserT__42, bcplParserT__43, bcplParserT__44, bcplParserT__45, bcplParserT__46, bcplParserT__47, bcplParserT__48, bcplParserT__49, bcplParserT__50, bcplParserT__51:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(747)
			p.Label_prefix()
		}

	case bcplParserT__123:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(748)
			p.Case_prefix()
		}

	case bcplParserT__124:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(749)
			p.Default_prefix()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICommandContext is an interface to support dynamic dispatch.
type ICommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommandContext differentiates from other interfaces.
	IsCommandContext()
}

type CommandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandContext() *CommandContext {
	var p = new(CommandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_command
	return p
}

func (*CommandContext) IsCommandContext() {}

func NewCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandContext {
	var p = new(CommandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_command

	return p
}

func (s *CommandContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandContext) Unlabelled_command() IUnlabelled_commandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnlabelled_commandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnlabelled_commandContext)
}

func (s *CommandContext) Prefix_() IPrefix_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefix_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefix_Context)
}

func (s *CommandContext) Command() ICommandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommandContext)
}

func (s *CommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterCommand(s)
	}
}

func (s *CommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitCommand(s)
	}
}

func (p *bcplParser) Command() (localctx ICommandContext) {
	this := p
	_ = this

	localctx = NewCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, bcplParserRULE_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(752)
			p.Unlabelled_command()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(753)
			p.Prefix_()
		}
		{
			p.SetState(754)
			p.Command()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(756)
			p.Prefix_()
		}

	}

	return localctx
}

// ICommand_listContext is an interface to support dynamic dispatch.
type ICommand_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommand_listContext differentiates from other interfaces.
	IsCommand_listContext()
}

type Command_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommand_listContext() *Command_listContext {
	var p = new(Command_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_command_list
	return p
}

func (*Command_listContext) IsCommand_listContext() {}

func NewCommand_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Command_listContext {
	var p = new(Command_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_command_list

	return p
}

func (s *Command_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Command_listContext) AllCommand() []ICommandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICommandContext)(nil)).Elem())
	var tst = make([]ICommandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICommandContext)
		}
	}

	return tst
}

func (s *Command_listContext) Command(i int) ICommandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICommandContext)
}

func (s *Command_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Command_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Command_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterCommand_list(s)
	}
}

func (s *Command_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitCommand_list(s)
	}
}

func (p *bcplParser) Command_list() (localctx ICommand_listContext) {
	this := p
	_ = this

	localctx = NewCommand_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, bcplParserRULE_command_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.Command()
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == bcplParserT__89 {
		{
			p.SetState(760)
			p.Match(bcplParserT__89)
		}
		{
			p.SetState(761)
			p.Command()
		}

		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDeclaration_partContext is an interface to support dynamic dispatch.
type IDeclaration_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaration_partContext differentiates from other interfaces.
	IsDeclaration_partContext()
}

type Declaration_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaration_partContext() *Declaration_partContext {
	var p = new(Declaration_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_declaration_part
	return p
}

func (*Declaration_partContext) IsDeclaration_partContext() {}

func NewDeclaration_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_partContext {
	var p = new(Declaration_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_declaration_part

	return p
}

func (s *Declaration_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_partContext) AllDeclaration() []IDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarationContext)(nil)).Elem())
	var tst = make([]IDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarationContext)
		}
	}

	return tst
}

func (s *Declaration_partContext) Declaration(i int) IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *Declaration_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declaration_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterDeclaration_part(s)
	}
}

func (s *Declaration_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitDeclaration_part(s)
	}
}

func (p *bcplParser) Declaration_part() (localctx IDeclaration_partContext) {
	this := p
	_ = this

	localctx = NewDeclaration_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, bcplParserRULE_declaration_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(767)
		p.Declaration()
	}
	p.SetState(772)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(768)
				p.Match(bcplParserT__89)
			}
			{
				p.SetState(769)
				p.Declaration()
			}

		}
		p.SetState(774)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())
	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) Left_dollar_open() antlr.TerminalNode {
	return s.GetToken(bcplParserLeft_dollar_open, 0)
}

func (s *BlockContext) Declaration_part() IDeclaration_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_partContext)
}

func (s *BlockContext) Command_list() ICommand_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommand_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommand_listContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *bcplParser) Block() (localctx IBlockContext) {
	this := p
	_ = this

	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, bcplParserRULE_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.Match(bcplParserLeft_dollar_open)
	}
	{
		p.SetState(776)
		p.Declaration_part()
	}
	{
		p.SetState(777)
		p.Match(bcplParserT__89)
	}
	{
		p.SetState(778)
		p.Command_list()
	}
	{
		p.SetState(779)
		p.Match(bcplParserT__91)
	}

	return localctx
}

// ICompound_commandContext is an interface to support dynamic dispatch.
type ICompound_commandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_commandContext differentiates from other interfaces.
	IsCompound_commandContext()
}

type Compound_commandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_commandContext() *Compound_commandContext {
	var p = new(Compound_commandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_compound_command
	return p
}

func (*Compound_commandContext) IsCompound_commandContext() {}

func NewCompound_commandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_commandContext {
	var p = new(Compound_commandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_compound_command

	return p
}

func (s *Compound_commandContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_commandContext) Left_dollar_open() antlr.TerminalNode {
	return s.GetToken(bcplParserLeft_dollar_open, 0)
}

func (s *Compound_commandContext) Command_list() ICommand_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommand_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommand_listContext)
}

func (s *Compound_commandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_commandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compound_commandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterCompound_command(s)
	}
}

func (s *Compound_commandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitCompound_command(s)
	}
}

func (p *bcplParser) Compound_command() (localctx ICompound_commandContext) {
	this := p
	_ = this

	localctx = NewCompound_commandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, bcplParserRULE_compound_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		p.Match(bcplParserLeft_dollar_open)
	}
	{
		p.SetState(782)
		p.Command_list()
	}
	{
		p.SetState(783)
		p.Match(bcplParserT__91)
	}

	return localctx
}

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_program
	return p
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) Declaration_part() IDeclaration_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_partContext)
}

func (s *ProgramContext) Directive() IDirectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDirectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDirectiveContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (p *bcplParser) Program() (localctx IProgramContext) {
	this := p
	_ = this

	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, bcplParserRULE_program)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(787)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__90, bcplParserT__92, bcplParserT__94, bcplParserT__97:
		{
			p.SetState(785)
			p.Declaration_part()
		}

	case bcplParserT__125, bcplParserT__126:
		{
			p.SetState(786)
			p.Directive()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDirectiveContext is an interface to support dynamic dispatch.
type IDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirectiveContext differentiates from other interfaces.
	IsDirectiveContext()
}

type DirectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectiveContext() *DirectiveContext {
	var p = new(DirectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = bcplParserRULE_directive
	return p
}

func (*DirectiveContext) IsDirectiveContext() {}

func NewDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectiveContext {
	var p = new(DirectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = bcplParserRULE_directive

	return p
}

func (s *DirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectiveContext) String_constant() IString_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_constantContext)
}

func (s *DirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.EnterDirective(s)
	}
}

func (s *DirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bcplListener); ok {
		listenerT.ExitDirective(s)
	}
}

func (p *bcplParser) Directive() (localctx IDirectiveContext) {
	this := p
	_ = this

	localctx = NewDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, bcplParserRULE_directive)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(793)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case bcplParserT__125:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(789)
			p.Match(bcplParserT__125)
		}
		{
			p.SetState(790)
			p.String_constant()
		}

	case bcplParserT__126:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(791)
			p.Match(bcplParserT__126)
		}
		{
			p.SetState(792)
			p.String_constant()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

func (p *bcplParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 22:
		var t *Primary_EContext = nil
		if localctx != nil {
			t = localctx.(*Primary_EContext)
		}
		return p.Primary_E_Sempred(t, predIndex)

	case 23:
		var t *Vector_EContext = nil
		if localctx != nil {
			t = localctx.(*Vector_EContext)
		}
		return p.Vector_E_Sempred(t, predIndex)

	case 25:
		var t *Mult_EContext = nil
		if localctx != nil {
			t = localctx.(*Mult_EContext)
		}
		return p.Mult_E_Sempred(t, predIndex)

	case 26:
		var t *Add_EContext = nil
		if localctx != nil {
			t = localctx.(*Add_EContext)
		}
		return p.Add_E_Sempred(t, predIndex)

	case 28:
		var t *Shift_EContext = nil
		if localctx != nil {
			t = localctx.(*Shift_EContext)
		}
		return p.Shift_E_Sempred(t, predIndex)

	case 36:
		var t *C_mult_EContext = nil
		if localctx != nil {
			t = localctx.(*C_mult_EContext)
		}
		return p.C_mult_E_Sempred(t, predIndex)

	case 37:
		var t *C_add_EContext = nil
		if localctx != nil {
			t = localctx.(*C_add_EContext)
		}
		return p.C_add_E_Sempred(t, predIndex)

	case 38:
		var t *C_shift_EContext = nil
		if localctx != nil {
			t = localctx.(*C_shift_EContext)
		}
		return p.C_shift_E_Sempred(t, predIndex)

	case 39:
		var t *C_and_EContext = nil
		if localctx != nil {
			t = localctx.(*C_and_EContext)
		}
		return p.C_and_E_Sempred(t, predIndex)

	case 40:
		var t *Constant_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Constant_expressionContext)
		}
		return p.Constant_expression_Sempred(t, predIndex)

	case 65:
		var t *Repeatable_commandContext = nil
		if localctx != nil {
			t = localctx.(*Repeatable_commandContext)
		}
		return p.Repeatable_command_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *bcplParser) Primary_E_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *bcplParser) Vector_E_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *bcplParser) Mult_E_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *bcplParser) Add_E_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *bcplParser) Shift_E_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *bcplParser) C_mult_E_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *bcplParser) C_add_E_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *bcplParser) C_shift_E_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *bcplParser) C_and_E_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *bcplParser) Constant_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *bcplParser) Repeatable_command_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
