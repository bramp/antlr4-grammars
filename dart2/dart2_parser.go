// Code generated from Dart2.g4 by ANTLR 4.9.3. DO NOT EDIT.

package dart2 // Dart2
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 128, 1823,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 3, 2, 3, 2, 5, 2, 351, 10, 2, 3, 3, 3, 3, 3, 3, 7, 3, 356, 10,
	3, 12, 3, 14, 3, 359, 11, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 5, 3, 5, 5, 5,
	367, 10, 5, 3, 5, 3, 5, 5, 5, 371, 10, 5, 3, 5, 5, 5, 374, 10, 5, 3, 6,
	3, 6, 5, 6, 378, 10, 6, 3, 7, 3, 7, 3, 7, 5, 7, 383, 10, 7, 3, 7, 3, 7,
	7, 7, 387, 10, 7, 12, 7, 14, 7, 390, 11, 7, 3, 8, 3, 8, 3, 8, 5, 8, 395,
	10, 8, 3, 9, 3, 9, 3, 9, 7, 9, 400, 10, 9, 12, 9, 14, 9, 403, 11, 9, 3,
	10, 3, 10, 5, 10, 407, 10, 10, 3, 10, 3, 10, 3, 10, 3, 11, 5, 11, 413,
	10, 11, 3, 11, 3, 11, 3, 12, 3, 12, 5, 12, 419, 10, 12, 3, 13, 5, 13, 422,
	10, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 429, 10, 13, 3, 13, 5,
	13, 432, 10, 13, 3, 14, 3, 14, 3, 14, 3, 14, 3, 15, 3, 15, 3, 15, 3, 15,
	3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 448, 10, 15, 3, 15, 3,
	15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 456, 10, 15, 3, 16, 3, 16, 3, 16,
	7, 16, 461, 10, 16, 12, 16, 14, 16, 464, 11, 16, 3, 17, 3, 17, 5, 17, 468,
	10, 17, 3, 18, 3, 18, 3, 18, 3, 18, 7, 18, 474, 10, 18, 12, 18, 14, 18,
	477, 11, 18, 3, 18, 5, 18, 480, 10, 18, 3, 18, 3, 18, 3, 19, 3, 19, 3,
	19, 3, 19, 7, 19, 488, 10, 19, 12, 19, 14, 19, 491, 11, 19, 3, 19, 5, 19,
	494, 10, 19, 3, 19, 3, 19, 3, 20, 3, 20, 3, 20, 5, 20, 501, 10, 20, 3,
	21, 3, 21, 5, 21, 505, 10, 21, 3, 21, 5, 21, 508, 10, 21, 3, 21, 3, 21,
	3, 21, 3, 22, 3, 22, 3, 22, 5, 22, 516, 10, 22, 3, 22, 3, 22, 5, 22, 520,
	10, 22, 3, 23, 3, 23, 5, 23, 524, 10, 23, 3, 23, 3, 23, 3, 23, 3, 23, 5,
	23, 530, 10, 23, 3, 24, 3, 24, 3, 24, 5, 24, 535, 10, 24, 3, 25, 3, 25,
	3, 25, 5, 25, 540, 10, 25, 3, 25, 3, 25, 3, 25, 5, 25, 545, 10, 25, 5,
	25, 547, 10, 25, 3, 26, 3, 26, 5, 26, 551, 10, 26, 3, 26, 3, 26, 3, 26,
	5, 26, 556, 10, 26, 3, 26, 5, 26, 559, 10, 26, 3, 26, 5, 26, 562, 10, 26,
	3, 26, 5, 26, 565, 10, 26, 3, 26, 3, 26, 3, 26, 3, 26, 7, 26, 571, 10,
	26, 12, 26, 14, 26, 574, 11, 26, 3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 580,
	10, 26, 3, 26, 3, 26, 3, 26, 5, 26, 585, 10, 26, 3, 27, 3, 27, 3, 27, 3,
	28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 596, 10, 28, 3, 29, 3, 29,
	5, 29, 600, 10, 29, 3, 29, 3, 29, 5, 29, 604, 10, 29, 3, 29, 3, 29, 5,
	29, 608, 10, 29, 3, 29, 3, 29, 5, 29, 612, 10, 29, 3, 29, 3, 29, 5, 29,
	616, 10, 29, 3, 30, 3, 30, 3, 30, 5, 30, 621, 10, 30, 3, 30, 3, 30, 3,
	30, 5, 30, 626, 10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30,
	634, 10, 30, 5, 30, 636, 10, 30, 3, 30, 3, 30, 3, 30, 5, 30, 641, 10, 30,
	5, 30, 643, 10, 30, 3, 30, 3, 30, 5, 30, 647, 10, 30, 3, 30, 3, 30, 3,
	30, 5, 30, 652, 10, 30, 5, 30, 654, 10, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	5, 30, 660, 10, 30, 3, 30, 3, 30, 3, 30, 5, 30, 665, 10, 30, 3, 30, 3,
	30, 5, 30, 669, 10, 30, 3, 30, 3, 30, 5, 30, 673, 10, 30, 3, 30, 5, 30,
	676, 10, 30, 3, 31, 3, 31, 3, 31, 7, 31, 681, 10, 31, 12, 31, 14, 31, 684,
	11, 31, 3, 32, 3, 32, 3, 32, 3, 32, 3, 33, 5, 33, 691, 10, 33, 3, 33, 3,
	33, 3, 33, 3, 33, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 701, 10, 34, 3, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 709, 10, 35, 3, 36, 5, 36, 712,
	10, 36, 3, 36, 3, 36, 3, 36, 3, 37, 5, 37, 718, 10, 37, 3, 37, 3, 37, 3,
	37, 3, 37, 3, 38, 3, 38, 3, 38, 5, 38, 727, 10, 38, 3, 38, 3, 38, 3, 39,
	3, 39, 3, 39, 3, 39, 5, 39, 735, 10, 39, 3, 39, 3, 39, 3, 40, 3, 40, 3,
	40, 3, 40, 7, 40, 743, 10, 40, 12, 40, 14, 40, 746, 11, 40, 3, 41, 3, 41,
	3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 757, 10, 41, 3,
	42, 3, 42, 5, 42, 761, 10, 42, 3, 42, 3, 42, 3, 42, 3, 42, 7, 42, 767,
	10, 42, 12, 42, 14, 42, 770, 11, 42, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43,
	776, 10, 43, 3, 43, 3, 43, 3, 44, 5, 44, 781, 10, 44, 3, 44, 3, 44, 3,
	44, 3, 44, 5, 44, 787, 10, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44,
	794, 10, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 3, 47, 3,
	47, 3, 47, 3, 48, 3, 48, 5, 48, 808, 10, 48, 3, 48, 3, 48, 3, 48, 3, 48,
	3, 49, 3, 49, 3, 49, 5, 49, 817, 10, 49, 3, 50, 3, 50, 3, 50, 3, 50, 3,
	50, 3, 50, 3, 50, 7, 50, 826, 10, 50, 12, 50, 14, 50, 829, 11, 50, 3, 50,
	5, 50, 832, 10, 50, 3, 50, 3, 50, 3, 51, 3, 51, 3, 51, 3, 52, 3, 52, 3,
	52, 3, 52, 5, 52, 843, 10, 52, 3, 53, 3, 53, 3, 53, 3, 53, 7, 53, 849,
	10, 53, 12, 53, 14, 53, 852, 11, 53, 3, 53, 3, 53, 3, 54, 3, 54, 3, 54,
	3, 54, 5, 54, 860, 10, 54, 3, 54, 5, 54, 863, 10, 54, 7, 54, 865, 10, 54,
	12, 54, 14, 54, 868, 11, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55,
	7, 55, 876, 10, 55, 12, 55, 14, 55, 879, 11, 55, 3, 55, 5, 55, 882, 10,
	55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 5, 56, 890, 10, 56, 3, 57,
	3, 57, 3, 57, 7, 57, 895, 10, 57, 12, 57, 14, 57, 898, 11, 57, 3, 58, 3,
	58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58,
	5, 58, 912, 10, 58, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 5,
	59, 921, 10, 59, 3, 60, 3, 60, 3, 61, 3, 61, 3, 62, 3, 62, 3, 63, 6, 63,
	930, 10, 63, 13, 63, 14, 63, 931, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3,
	64, 5, 64, 940, 10, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 7, 65, 947,
	10, 65, 12, 65, 14, 65, 950, 11, 65, 5, 65, 952, 10, 65, 3, 66, 5, 66,
	955, 10, 66, 3, 66, 5, 66, 958, 10, 66, 3, 66, 3, 66, 3, 66, 5, 66, 963,
	10, 66, 5, 66, 965, 10, 66, 3, 66, 3, 66, 3, 67, 5, 67, 970, 10, 67, 3,
	67, 5, 67, 973, 10, 67, 3, 67, 3, 67, 3, 67, 3, 67, 7, 67, 979, 10, 67,
	12, 67, 14, 67, 982, 11, 67, 3, 67, 5, 67, 985, 10, 67, 5, 67, 987, 10,
	67, 3, 67, 3, 67, 3, 68, 3, 68, 3, 68, 3, 68, 3, 69, 3, 69, 3, 69, 3, 70,
	3, 70, 3, 70, 3, 71, 3, 71, 3, 71, 3, 72, 3, 72, 3, 73, 3, 73, 3, 73, 3,
	73, 5, 73, 1010, 10, 73, 3, 73, 3, 73, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74,
	1018, 10, 74, 3, 74, 3, 74, 3, 75, 3, 75, 3, 75, 5, 75, 1025, 10, 75, 5,
	75, 1027, 10, 75, 3, 75, 3, 75, 3, 76, 3, 76, 3, 76, 7, 76, 1034, 10, 76,
	12, 76, 14, 76, 1037, 11, 76, 3, 76, 3, 76, 3, 76, 7, 76, 1042, 10, 76,
	12, 76, 14, 76, 1045, 11, 76, 5, 76, 1047, 10, 76, 3, 77, 3, 77, 3, 77,
	3, 78, 3, 78, 3, 78, 7, 78, 1055, 10, 78, 12, 78, 14, 78, 1058, 11, 78,
	3, 78, 3, 78, 7, 78, 1062, 10, 78, 12, 78, 14, 78, 1065, 11, 78, 7, 78,
	1067, 10, 78, 12, 78, 14, 78, 1070, 11, 78, 3, 78, 3, 78, 3, 78, 5, 78,
	1075, 10, 78, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 5, 79, 1082, 10, 79, 3,
	80, 5, 80, 1085, 10, 80, 3, 80, 3, 80, 3, 81, 3, 81, 5, 81, 1091, 10, 81,
	3, 82, 3, 82, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 5, 83, 1101, 10,
	83, 3, 84, 3, 84, 3, 84, 7, 84, 1106, 10, 84, 12, 84, 14, 84, 1109, 11,
	84, 3, 85, 3, 85, 3, 85, 7, 85, 1114, 10, 85, 12, 85, 14, 85, 1117, 11,
	85, 3, 86, 3, 86, 3, 86, 7, 86, 1122, 10, 86, 12, 86, 14, 86, 1125, 11,
	86, 3, 87, 3, 87, 3, 87, 3, 87, 5, 87, 1131, 10, 87, 3, 87, 3, 87, 3, 87,
	3, 87, 5, 87, 1137, 10, 87, 3, 88, 3, 88, 3, 89, 3, 89, 3, 89, 3, 89, 3,
	89, 3, 89, 5, 89, 1147, 10, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1153,
	10, 89, 3, 90, 3, 90, 3, 91, 3, 91, 3, 91, 7, 91, 1160, 10, 91, 12, 91,
	14, 91, 1163, 11, 91, 3, 91, 3, 91, 3, 91, 6, 91, 1168, 10, 91, 13, 91,
	14, 91, 1169, 5, 91, 1172, 10, 91, 3, 92, 3, 92, 3, 92, 7, 92, 1177, 10,
	92, 12, 92, 14, 92, 1180, 11, 92, 3, 92, 3, 92, 3, 92, 6, 92, 1185, 10,
	92, 13, 92, 14, 92, 1186, 5, 92, 1189, 10, 92, 3, 93, 3, 93, 3, 93, 7,
	93, 1194, 10, 93, 12, 93, 14, 93, 1197, 11, 93, 3, 93, 3, 93, 3, 93, 6,
	93, 1202, 10, 93, 13, 93, 14, 93, 1203, 5, 93, 1206, 10, 93, 3, 94, 3,
	94, 3, 95, 3, 95, 3, 95, 3, 95, 7, 95, 1214, 10, 95, 12, 95, 14, 95, 1217,
	11, 95, 3, 95, 3, 95, 3, 95, 3, 95, 6, 95, 1223, 10, 95, 13, 95, 14, 95,
	1224, 5, 95, 1227, 10, 95, 3, 96, 3, 96, 3, 97, 3, 97, 3, 97, 3, 97, 7,
	97, 1235, 10, 97, 12, 97, 14, 97, 1238, 11, 97, 3, 97, 3, 97, 3, 97, 3,
	97, 6, 97, 1244, 10, 97, 13, 97, 14, 97, 1245, 5, 97, 1248, 10, 97, 3,
	98, 3, 98, 3, 99, 3, 99, 3, 99, 3, 99, 7, 99, 1256, 10, 99, 12, 99, 14,
	99, 1259, 11, 99, 3, 99, 3, 99, 3, 99, 3, 99, 6, 99, 1265, 10, 99, 13,
	99, 14, 99, 1266, 5, 99, 1269, 10, 99, 3, 100, 3, 100, 3, 101, 3, 101,
	3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 5, 101, 1280, 10, 101, 3, 101,
	3, 101, 3, 101, 3, 101, 3, 101, 5, 101, 1287, 10, 101, 3, 102, 3, 102,
	3, 102, 5, 102, 1292, 10, 102, 3, 103, 3, 103, 3, 104, 3, 104, 3, 105,
	3, 105, 3, 106, 3, 106, 3, 106, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107,
	7, 107, 1308, 10, 107, 12, 107, 14, 107, 1311, 11, 107, 5, 107, 1313, 10,
	107, 3, 108, 3, 108, 3, 109, 3, 109, 5, 109, 1319, 10, 109, 3, 110, 3,
	110, 3, 111, 3, 111, 7, 111, 1325, 10, 111, 12, 111, 14, 111, 1328, 11,
	111, 3, 111, 5, 111, 1331, 10, 111, 3, 111, 3, 111, 3, 111, 3, 111, 5,
	111, 1337, 10, 111, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 5,
	112, 1345, 10, 112, 3, 113, 3, 113, 3, 113, 5, 113, 1350, 10, 113, 3, 114,
	3, 114, 3, 115, 3, 115, 3, 115, 5, 115, 1357, 10, 115, 3, 116, 3, 116,
	3, 116, 3, 117, 3, 117, 5, 117, 1364, 10, 117, 3, 118, 3, 118, 3, 118,
	3, 119, 3, 119, 3, 120, 7, 120, 1372, 10, 120, 12, 120, 14, 120, 1375,
	11, 120, 3, 121, 7, 121, 1378, 10, 121, 12, 121, 14, 121, 1381, 11, 121,
	3, 121, 3, 121, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122,
	3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122,
	3, 122, 5, 122, 1402, 10, 122, 3, 123, 5, 123, 1405, 10, 123, 3, 123, 3,
	123, 3, 124, 3, 124, 3, 124, 3, 125, 3, 125, 3, 125, 3, 126, 3, 126, 3,
	126, 3, 126, 3, 126, 3, 126, 3, 126, 5, 126, 1422, 10, 126, 3, 127, 5,
	127, 1425, 10, 127, 3, 127, 3, 127, 3, 127, 3, 127, 3, 127, 3, 127, 3,
	128, 3, 128, 5, 128, 1435, 10, 128, 3, 128, 3, 128, 5, 128, 1439, 10, 128,
	3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 5, 128,
	1449, 10, 128, 3, 129, 3, 129, 5, 129, 1453, 10, 129, 3, 129, 5, 129, 1456,
	10, 129, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 131, 3, 131,
	3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 132, 3, 132, 3, 132,
	3, 132, 3, 132, 3, 132, 7, 132, 1478, 10, 132, 12, 132, 14, 132, 1481,
	11, 132, 3, 132, 5, 132, 1484, 10, 132, 3, 132, 3, 132, 3, 133, 7, 133,
	1489, 10, 133, 12, 133, 14, 133, 1492, 11, 133, 3, 133, 3, 133, 3, 133,
	3, 133, 3, 133, 3, 134, 7, 134, 1500, 10, 134, 12, 134, 14, 134, 1503,
	11, 134, 3, 134, 3, 134, 3, 134, 3, 134, 3, 135, 3, 135, 3, 135, 3, 136,
	3, 136, 3, 136, 6, 136, 1515, 10, 136, 13, 136, 14, 136, 1516, 3, 136,
	5, 136, 1520, 10, 136, 3, 136, 5, 136, 1523, 10, 136, 3, 137, 3, 137, 3,
	137, 3, 137, 3, 137, 3, 137, 5, 137, 1531, 10, 137, 3, 137, 3, 137, 5,
	137, 1535, 10, 137, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 5, 138, 1542,
	10, 138, 3, 138, 3, 138, 3, 139, 3, 139, 3, 139, 3, 140, 3, 140, 5, 140,
	1551, 10, 140, 3, 140, 3, 140, 3, 141, 3, 141, 3, 141, 3, 142, 3, 142,
	5, 142, 1560, 10, 142, 3, 142, 3, 142, 3, 143, 3, 143, 5, 143, 1566, 10,
	143, 3, 143, 3, 143, 3, 144, 3, 144, 3, 144, 3, 144, 3, 145, 3, 145, 3,
	145, 3, 145, 3, 146, 3, 146, 3, 146, 3, 147, 3, 147, 3, 147, 3, 147, 3,
	147, 5, 147, 1586, 10, 147, 3, 147, 5, 147, 1589, 10, 147, 3, 147, 3, 147,
	3, 148, 3, 148, 3, 148, 3, 148, 5, 148, 1597, 10, 148, 3, 148, 3, 148,
	3, 148, 3, 148, 5, 148, 1603, 10, 148, 3, 148, 3, 148, 3, 148, 3, 148,
	5, 148, 1609, 10, 148, 3, 148, 3, 148, 3, 148, 3, 148, 3, 148, 3, 148,
	3, 148, 5, 148, 1618, 10, 148, 3, 148, 3, 148, 3, 148, 3, 148, 3, 148,
	5, 148, 1625, 10, 148, 3, 148, 3, 148, 3, 148, 3, 148, 3, 148, 3, 148,
	3, 148, 5, 148, 1634, 10, 148, 3, 148, 3, 148, 3, 148, 3, 148, 3, 148,
	3, 148, 5, 148, 1642, 10, 148, 3, 149, 3, 149, 3, 150, 5, 150, 1647, 10,
	150, 3, 150, 5, 150, 1650, 10, 150, 3, 150, 7, 150, 1653, 10, 150, 12,
	150, 14, 150, 1656, 11, 150, 3, 150, 7, 150, 1659, 10, 150, 12, 150, 14,
	150, 1662, 11, 150, 3, 150, 7, 150, 1665, 10, 150, 12, 150, 14, 150, 1668,
	11, 150, 3, 151, 3, 151, 7, 151, 1672, 10, 151, 12, 151, 14, 151, 1675,
	11, 151, 3, 151, 3, 151, 3, 152, 3, 152, 3, 152, 3, 152, 3, 152, 3, 153,
	3, 153, 5, 153, 1686, 10, 153, 3, 154, 3, 154, 3, 154, 7, 154, 1691, 10,
	154, 12, 154, 14, 154, 1694, 11, 154, 3, 155, 3, 155, 3, 155, 3, 156, 3,
	156, 3, 156, 3, 156, 5, 156, 1703, 10, 156, 3, 156, 7, 156, 1706, 10, 156,
	12, 156, 14, 156, 1709, 11, 156, 3, 156, 3, 156, 3, 157, 3, 157, 3, 157,
	3, 157, 5, 157, 1717, 10, 157, 3, 158, 3, 158, 3, 158, 7, 158, 1722, 10,
	158, 12, 158, 14, 158, 1725, 11, 158, 3, 159, 3, 159, 3, 159, 3, 159, 7,
	159, 1731, 10, 159, 12, 159, 14, 159, 1734, 11, 159, 3, 159, 3, 159, 3,
	160, 3, 160, 3, 160, 3, 160, 3, 160, 3, 161, 3, 161, 3, 161, 3, 161, 3,
	161, 3, 161, 7, 161, 1749, 10, 161, 12, 161, 14, 161, 1752, 11, 161, 3,
	161, 3, 161, 3, 162, 3, 162, 7, 162, 1758, 10, 162, 12, 162, 14, 162, 1761,
	11, 162, 3, 162, 3, 162, 3, 163, 3, 163, 3, 164, 3, 164, 7, 164, 1769,
	10, 164, 12, 164, 14, 164, 1772, 11, 164, 3, 165, 3, 165, 3, 165, 3, 165,
	3, 165, 3, 165, 3, 166, 3, 166, 3, 166, 5, 166, 1783, 10, 166, 3, 167,
	3, 167, 5, 167, 1787, 10, 167, 3, 168, 3, 168, 5, 168, 1791, 10, 168, 3,
	169, 3, 169, 3, 169, 3, 169, 3, 170, 3, 170, 3, 170, 7, 170, 1800, 10,
	170, 12, 170, 14, 170, 1803, 11, 170, 3, 171, 3, 171, 3, 171, 3, 171, 3,
	172, 3, 172, 3, 173, 3, 173, 5, 173, 1813, 10, 173, 3, 173, 3, 173, 3,
	173, 3, 174, 5, 174, 1819, 10, 174, 3, 174, 3, 174, 3, 174, 2, 2, 175,
	2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
	40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
	76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108,
	110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,
	140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168,
	170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198,
	200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228,
	230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258,
	260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288,
	290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318,
	320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 2,
	18, 4, 2, 9, 9, 12, 13, 3, 2, 4, 5, 4, 2, 20, 20, 27, 27, 3, 2, 121, 122,
	3, 2, 45, 46, 3, 2, 123, 124, 3, 2, 53, 64, 4, 2, 33, 33, 69, 69, 4, 2,
	41, 42, 70, 71, 3, 2, 72, 74, 3, 2, 75, 77, 3, 2, 78, 79, 3, 2, 80, 83,
	3, 2, 86, 87, 3, 2, 34, 35, 3, 2, 125, 125, 2, 1935, 2, 350, 3, 2, 2, 2,
	4, 352, 3, 2, 2, 2, 6, 360, 3, 2, 2, 2, 8, 373, 3, 2, 2, 2, 10, 377, 3,
	2, 2, 2, 12, 379, 3, 2, 2, 2, 14, 391, 3, 2, 2, 2, 16, 396, 3, 2, 2, 2,
	18, 404, 3, 2, 2, 2, 20, 412, 3, 2, 2, 2, 22, 418, 3, 2, 2, 2, 24, 431,
	3, 2, 2, 2, 26, 433, 3, 2, 2, 2, 28, 455, 3, 2, 2, 2, 30, 457, 3, 2, 2,
	2, 32, 467, 3, 2, 2, 2, 34, 469, 3, 2, 2, 2, 36, 483, 3, 2, 2, 2, 38, 500,
	3, 2, 2, 2, 40, 502, 3, 2, 2, 2, 42, 519, 3, 2, 2, 2, 44, 521, 3, 2, 2,
	2, 46, 531, 3, 2, 2, 2, 48, 546, 3, 2, 2, 2, 50, 584, 3, 2, 2, 2, 52, 586,
	3, 2, 2, 2, 54, 595, 3, 2, 2, 2, 56, 615, 3, 2, 2, 2, 58, 675, 3, 2, 2,
	2, 60, 677, 3, 2, 2, 2, 62, 685, 3, 2, 2, 2, 64, 690, 3, 2, 2, 2, 66, 700,
	3, 2, 2, 2, 68, 708, 3, 2, 2, 2, 70, 711, 3, 2, 2, 2, 72, 717, 3, 2, 2,
	2, 74, 723, 3, 2, 2, 2, 76, 730, 3, 2, 2, 2, 78, 738, 3, 2, 2, 2, 80, 756,
	3, 2, 2, 2, 82, 760, 3, 2, 2, 2, 84, 771, 3, 2, 2, 2, 86, 780, 3, 2, 2,
	2, 88, 795, 3, 2, 2, 2, 90, 799, 3, 2, 2, 2, 92, 802, 3, 2, 2, 2, 94, 805,
	3, 2, 2, 2, 96, 813, 3, 2, 2, 2, 98, 818, 3, 2, 2, 2, 100, 835, 3, 2, 2,
	2, 102, 838, 3, 2, 2, 2, 104, 844, 3, 2, 2, 2, 106, 866, 3, 2, 2, 2, 108,
	881, 3, 2, 2, 2, 110, 889, 3, 2, 2, 2, 112, 891, 3, 2, 2, 2, 114, 911,
	3, 2, 2, 2, 116, 920, 3, 2, 2, 2, 118, 922, 3, 2, 2, 2, 120, 924, 3, 2,
	2, 2, 122, 926, 3, 2, 2, 2, 124, 929, 3, 2, 2, 2, 126, 939, 3, 2, 2, 2,
	128, 941, 3, 2, 2, 2, 130, 954, 3, 2, 2, 2, 132, 969, 3, 2, 2, 2, 134,
	990, 3, 2, 2, 2, 136, 994, 3, 2, 2, 2, 138, 997, 3, 2, 2, 2, 140, 1000,
	3, 2, 2, 2, 142, 1003, 3, 2, 2, 2, 144, 1005, 3, 2, 2, 2, 146, 1013, 3,
	2, 2, 2, 148, 1021, 3, 2, 2, 2, 150, 1046, 3, 2, 2, 2, 152, 1048, 3, 2,
	2, 2, 154, 1051, 3, 2, 2, 2, 156, 1081, 3, 2, 2, 2, 158, 1084, 3, 2, 2,
	2, 160, 1090, 3, 2, 2, 2, 162, 1092, 3, 2, 2, 2, 164, 1094, 3, 2, 2, 2,
	166, 1102, 3, 2, 2, 2, 168, 1110, 3, 2, 2, 2, 170, 1118, 3, 2, 2, 2, 172,
	1136, 3, 2, 2, 2, 174, 1138, 3, 2, 2, 2, 176, 1152, 3, 2, 2, 2, 178, 1154,
	3, 2, 2, 2, 180, 1171, 3, 2, 2, 2, 182, 1188, 3, 2, 2, 2, 184, 1205, 3,
	2, 2, 2, 186, 1207, 3, 2, 2, 2, 188, 1226, 3, 2, 2, 2, 190, 1228, 3, 2,
	2, 2, 192, 1247, 3, 2, 2, 2, 194, 1249, 3, 2, 2, 2, 196, 1268, 3, 2, 2,
	2, 198, 1270, 3, 2, 2, 2, 200, 1286, 3, 2, 2, 2, 202, 1291, 3, 2, 2, 2,
	204, 1293, 3, 2, 2, 2, 206, 1295, 3, 2, 2, 2, 208, 1297, 3, 2, 2, 2, 210,
	1299, 3, 2, 2, 2, 212, 1312, 3, 2, 2, 2, 214, 1314, 3, 2, 2, 2, 216, 1318,
	3, 2, 2, 2, 218, 1320, 3, 2, 2, 2, 220, 1336, 3, 2, 2, 2, 222, 1344, 3,
	2, 2, 2, 224, 1349, 3, 2, 2, 2, 226, 1351, 3, 2, 2, 2, 228, 1353, 3, 2,
	2, 2, 230, 1358, 3, 2, 2, 2, 232, 1361, 3, 2, 2, 2, 234, 1365, 3, 2, 2,
	2, 236, 1368, 3, 2, 2, 2, 238, 1373, 3, 2, 2, 2, 240, 1379, 3, 2, 2, 2,
	242, 1401, 3, 2, 2, 2, 244, 1404, 3, 2, 2, 2, 246, 1408, 3, 2, 2, 2, 248,
	1411, 3, 2, 2, 2, 250, 1414, 3, 2, 2, 2, 252, 1424, 3, 2, 2, 2, 254, 1448,
	3, 2, 2, 2, 256, 1455, 3, 2, 2, 2, 258, 1457, 3, 2, 2, 2, 260, 1463, 3,
	2, 2, 2, 262, 1471, 3, 2, 2, 2, 264, 1490, 3, 2, 2, 2, 266, 1501, 3, 2,
	2, 2, 268, 1508, 3, 2, 2, 2, 270, 1511, 3, 2, 2, 2, 272, 1534, 3, 2, 2,
	2, 274, 1536, 3, 2, 2, 2, 276, 1545, 3, 2, 2, 2, 278, 1548, 3, 2, 2, 2,
	280, 1554, 3, 2, 2, 2, 282, 1557, 3, 2, 2, 2, 284, 1563, 3, 2, 2, 2, 286,
	1569, 3, 2, 2, 2, 288, 1573, 3, 2, 2, 2, 290, 1577, 3, 2, 2, 2, 292, 1580,
	3, 2, 2, 2, 294, 1641, 3, 2, 2, 2, 296, 1643, 3, 2, 2, 2, 298, 1646, 3,
	2, 2, 2, 300, 1669, 3, 2, 2, 2, 302, 1678, 3, 2, 2, 2, 304, 1685, 3, 2,
	2, 2, 306, 1687, 3, 2, 2, 2, 308, 1695, 3, 2, 2, 2, 310, 1698, 3, 2, 2,
	2, 312, 1716, 3, 2, 2, 2, 314, 1718, 3, 2, 2, 2, 316, 1726, 3, 2, 2, 2,
	318, 1737, 3, 2, 2, 2, 320, 1742, 3, 2, 2, 2, 322, 1755, 3, 2, 2, 2, 324,
	1764, 3, 2, 2, 2, 326, 1766, 3, 2, 2, 2, 328, 1773, 3, 2, 2, 2, 330, 1779,
	3, 2, 2, 2, 332, 1784, 3, 2, 2, 2, 334, 1790, 3, 2, 2, 2, 336, 1792, 3,
	2, 2, 2, 338, 1796, 3, 2, 2, 2, 340, 1804, 3, 2, 2, 2, 342, 1808, 3, 2,
	2, 2, 344, 1810, 3, 2, 2, 2, 346, 1818, 3, 2, 2, 2, 348, 351, 5, 298, 150,
	2, 349, 351, 5, 322, 162, 2, 350, 348, 3, 2, 2, 2, 350, 349, 3, 2, 2, 2,
	351, 3, 3, 2, 2, 2, 352, 357, 5, 6, 4, 2, 353, 354, 7, 3, 2, 2, 354, 356,
	5, 226, 114, 2, 355, 353, 3, 2, 2, 2, 356, 359, 3, 2, 2, 2, 357, 355, 3,
	2, 2, 2, 357, 358, 3, 2, 2, 2, 358, 5, 3, 2, 2, 2, 359, 357, 3, 2, 2, 2,
	360, 361, 5, 106, 54, 2, 361, 362, 5, 8, 5, 2, 362, 363, 5, 226, 114, 2,
	363, 7, 3, 2, 2, 2, 364, 366, 7, 4, 2, 2, 365, 367, 5, 332, 167, 2, 366,
	365, 3, 2, 2, 2, 366, 367, 3, 2, 2, 2, 367, 374, 3, 2, 2, 2, 368, 370,
	7, 5, 2, 2, 369, 371, 5, 332, 167, 2, 370, 369, 3, 2, 2, 2, 370, 371, 3,
	2, 2, 2, 371, 374, 3, 2, 2, 2, 372, 374, 5, 10, 6, 2, 373, 364, 3, 2, 2,
	2, 373, 368, 3, 2, 2, 2, 373, 372, 3, 2, 2, 2, 374, 9, 3, 2, 2, 2, 375,
	378, 7, 6, 2, 2, 376, 378, 5, 332, 167, 2, 377, 375, 3, 2, 2, 2, 377, 376,
	3, 2, 2, 2, 378, 11, 3, 2, 2, 2, 379, 382, 5, 6, 4, 2, 380, 381, 7, 7,
	2, 2, 381, 383, 5, 108, 55, 2, 382, 380, 3, 2, 2, 2, 382, 383, 3, 2, 2,
	2, 383, 388, 3, 2, 2, 2, 384, 385, 7, 3, 2, 2, 385, 387, 5, 14, 8, 2, 386,
	384, 3, 2, 2, 2, 387, 390, 3, 2, 2, 2, 388, 386, 3, 2, 2, 2, 388, 389,
	3, 2, 2, 2, 389, 13, 3, 2, 2, 2, 390, 388, 3, 2, 2, 2, 391, 394, 5, 226,
	114, 2, 392, 393, 7, 7, 2, 2, 393, 395, 5, 108, 55, 2, 394, 392, 3, 2,
	2, 2, 394, 395, 3, 2, 2, 2, 395, 15, 3, 2, 2, 2, 396, 401, 5, 14, 8, 2,
	397, 398, 7, 3, 2, 2, 398, 400, 5, 14, 8, 2, 399, 397, 3, 2, 2, 2, 400,
	403, 3, 2, 2, 2, 401, 399, 3, 2, 2, 2, 401, 402, 3, 2, 2, 2, 402, 17, 3,
	2, 2, 2, 403, 401, 3, 2, 2, 2, 404, 406, 5, 106, 54, 2, 405, 407, 5, 22,
	12, 2, 406, 405, 3, 2, 2, 2, 406, 407, 3, 2, 2, 2, 407, 408, 3, 2, 2, 2,
	408, 409, 5, 226, 114, 2, 409, 410, 5, 20, 11, 2, 410, 19, 3, 2, 2, 2,
	411, 413, 5, 104, 53, 2, 412, 411, 3, 2, 2, 2, 412, 413, 3, 2, 2, 2, 413,
	414, 3, 2, 2, 2, 414, 415, 5, 28, 15, 2, 415, 21, 3, 2, 2, 2, 416, 419,
	7, 8, 2, 2, 417, 419, 5, 332, 167, 2, 418, 416, 3, 2, 2, 2, 418, 417, 3,
	2, 2, 2, 419, 23, 3, 2, 2, 2, 420, 422, 7, 9, 2, 2, 421, 420, 3, 2, 2,
	2, 421, 422, 3, 2, 2, 2, 422, 423, 3, 2, 2, 2, 423, 424, 7, 10, 2, 2, 424,
	425, 5, 108, 55, 2, 425, 426, 7, 11, 2, 2, 426, 432, 3, 2, 2, 2, 427, 429,
	9, 2, 2, 2, 428, 427, 3, 2, 2, 2, 428, 429, 3, 2, 2, 2, 429, 430, 3, 2,
	2, 2, 430, 432, 5, 26, 14, 2, 431, 421, 3, 2, 2, 2, 431, 428, 3, 2, 2,
	2, 432, 25, 3, 2, 2, 2, 433, 434, 7, 14, 2, 2, 434, 435, 5, 238, 120, 2,
	435, 436, 7, 15, 2, 2, 436, 27, 3, 2, 2, 2, 437, 438, 7, 16, 2, 2, 438,
	456, 7, 17, 2, 2, 439, 440, 7, 16, 2, 2, 440, 441, 5, 30, 16, 2, 441, 442,
	7, 17, 2, 2, 442, 456, 3, 2, 2, 2, 443, 444, 7, 16, 2, 2, 444, 447, 5,
	30, 16, 2, 445, 446, 7, 3, 2, 2, 446, 448, 5, 32, 17, 2, 447, 445, 3, 2,
	2, 2, 447, 448, 3, 2, 2, 2, 448, 449, 3, 2, 2, 2, 449, 450, 7, 17, 2, 2,
	450, 456, 3, 2, 2, 2, 451, 452, 7, 16, 2, 2, 452, 453, 5, 32, 17, 2, 453,
	454, 7, 17, 2, 2, 454, 456, 3, 2, 2, 2, 455, 437, 3, 2, 2, 2, 455, 439,
	3, 2, 2, 2, 455, 443, 3, 2, 2, 2, 455, 451, 3, 2, 2, 2, 456, 29, 3, 2,
	2, 2, 457, 462, 5, 38, 20, 2, 458, 459, 7, 3, 2, 2, 459, 461, 5, 38, 20,
	2, 460, 458, 3, 2, 2, 2, 461, 464, 3, 2, 2, 2, 462, 460, 3, 2, 2, 2, 462,
	463, 3, 2, 2, 2, 463, 31, 3, 2, 2, 2, 464, 462, 3, 2, 2, 2, 465, 468, 5,
	34, 18, 2, 466, 468, 5, 36, 19, 2, 467, 465, 3, 2, 2, 2, 467, 466, 3, 2,
	2, 2, 468, 33, 3, 2, 2, 2, 469, 470, 7, 18, 2, 2, 470, 475, 5, 46, 24,
	2, 471, 472, 7, 3, 2, 2, 472, 474, 5, 46, 24, 2, 473, 471, 3, 2, 2, 2,
	474, 477, 3, 2, 2, 2, 475, 473, 3, 2, 2, 2, 475, 476, 3, 2, 2, 2, 476,
	479, 3, 2, 2, 2, 477, 475, 3, 2, 2, 2, 478, 480, 7, 3, 2, 2, 479, 478,
	3, 2, 2, 2, 479, 480, 3, 2, 2, 2, 480, 481, 3, 2, 2, 2, 481, 482, 7, 19,
	2, 2, 482, 35, 3, 2, 2, 2, 483, 484, 7, 14, 2, 2, 484, 489, 5, 48, 25,
	2, 485, 486, 7, 3, 2, 2, 486, 488, 5, 48, 25, 2, 487, 485, 3, 2, 2, 2,
	488, 491, 3, 2, 2, 2, 489, 487, 3, 2, 2, 2, 489, 490, 3, 2, 2, 2, 490,
	493, 3, 2, 2, 2, 491, 489, 3, 2, 2, 2, 492, 494, 7, 3, 2, 2, 493, 492,
	3, 2, 2, 2, 493, 494, 3, 2, 2, 2, 494, 495, 3, 2, 2, 2, 495, 496, 7, 15,
	2, 2, 496, 37, 3, 2, 2, 2, 497, 501, 5, 40, 21, 2, 498, 501, 5, 44, 23,
	2, 499, 501, 5, 42, 22, 2, 500, 497, 3, 2, 2, 2, 500, 498, 3, 2, 2, 2,
	500, 499, 3, 2, 2, 2, 501, 39, 3, 2, 2, 2, 502, 504, 5, 106, 54, 2, 503,
	505, 7, 20, 2, 2, 504, 503, 3, 2, 2, 2, 504, 505, 3, 2, 2, 2, 505, 507,
	3, 2, 2, 2, 506, 508, 5, 22, 12, 2, 507, 506, 3, 2, 2, 2, 507, 508, 3,
	2, 2, 2, 508, 509, 3, 2, 2, 2, 509, 510, 5, 226, 114, 2, 510, 511, 5, 20,
	11, 2, 511, 41, 3, 2, 2, 2, 512, 520, 5, 6, 4, 2, 513, 515, 5, 106, 54,
	2, 514, 516, 7, 20, 2, 2, 515, 514, 3, 2, 2, 2, 515, 516, 3, 2, 2, 2, 516,
	517, 3, 2, 2, 2, 517, 518, 5, 226, 114, 2, 518, 520, 3, 2, 2, 2, 519, 512,
	3, 2, 2, 2, 519, 513, 3, 2, 2, 2, 520, 43, 3, 2, 2, 2, 521, 523, 5, 106,
	54, 2, 522, 524, 5, 8, 5, 2, 523, 522, 3, 2, 2, 2, 523, 524, 3, 2, 2, 2,
	524, 525, 3, 2, 2, 2, 525, 526, 7, 21, 2, 2, 526, 527, 7, 22, 2, 2, 527,
	529, 5, 226, 114, 2, 528, 530, 5, 20, 11, 2, 529, 528, 3, 2, 2, 2, 529,
	530, 3, 2, 2, 2, 530, 45, 3, 2, 2, 2, 531, 534, 5, 38, 20, 2, 532, 533,
	7, 7, 2, 2, 533, 535, 5, 108, 55, 2, 534, 532, 3, 2, 2, 2, 534, 535, 3,
	2, 2, 2, 535, 47, 3, 2, 2, 2, 536, 539, 5, 38, 20, 2, 537, 538, 7, 7, 2,
	2, 538, 540, 5, 108, 55, 2, 539, 537, 3, 2, 2, 2, 539, 540, 3, 2, 2, 2,
	540, 547, 3, 2, 2, 2, 541, 544, 5, 38, 20, 2, 542, 543, 7, 23, 2, 2, 543,
	545, 5, 108, 55, 2, 544, 542, 3, 2, 2, 2, 544, 545, 3, 2, 2, 2, 545, 547,
	3, 2, 2, 2, 546, 536, 3, 2, 2, 2, 546, 541, 3, 2, 2, 2, 547, 49, 3, 2,
	2, 2, 548, 550, 5, 106, 54, 2, 549, 551, 7, 24, 2, 2, 550, 549, 3, 2, 2,
	2, 550, 551, 3, 2, 2, 2, 551, 552, 3, 2, 2, 2, 552, 553, 7, 25, 2, 2, 553,
	555, 5, 226, 114, 2, 554, 556, 5, 104, 53, 2, 555, 554, 3, 2, 2, 2, 555,
	556, 3, 2, 2, 2, 556, 558, 3, 2, 2, 2, 557, 559, 5, 90, 46, 2, 558, 557,
	3, 2, 2, 2, 558, 559, 3, 2, 2, 2, 559, 561, 3, 2, 2, 2, 560, 562, 5, 52,
	27, 2, 561, 560, 3, 2, 2, 2, 561, 562, 3, 2, 2, 2, 562, 564, 3, 2, 2, 2,
	563, 565, 5, 92, 47, 2, 564, 563, 3, 2, 2, 2, 564, 565, 3, 2, 2, 2, 565,
	566, 3, 2, 2, 2, 566, 572, 7, 14, 2, 2, 567, 568, 5, 106, 54, 2, 568, 569,
	5, 54, 28, 2, 569, 571, 3, 2, 2, 2, 570, 567, 3, 2, 2, 2, 571, 574, 3,
	2, 2, 2, 572, 570, 3, 2, 2, 2, 572, 573, 3, 2, 2, 2, 573, 575, 3, 2, 2,
	2, 574, 572, 3, 2, 2, 2, 575, 576, 7, 15, 2, 2, 576, 585, 3, 2, 2, 2, 577,
	579, 5, 106, 54, 2, 578, 580, 7, 24, 2, 2, 579, 578, 3, 2, 2, 2, 579, 580,
	3, 2, 2, 2, 580, 581, 3, 2, 2, 2, 581, 582, 7, 25, 2, 2, 582, 583, 5, 94,
	48, 2, 583, 585, 3, 2, 2, 2, 584, 548, 3, 2, 2, 2, 584, 577, 3, 2, 2, 2,
	585, 51, 3, 2, 2, 2, 586, 587, 7, 26, 2, 2, 587, 588, 5, 338, 170, 2, 588,
	53, 3, 2, 2, 2, 589, 590, 5, 58, 30, 2, 590, 591, 7, 11, 2, 2, 591, 596,
	3, 2, 2, 2, 592, 593, 5, 56, 29, 2, 593, 594, 5, 24, 13, 2, 594, 596, 3,
	2, 2, 2, 595, 589, 3, 2, 2, 2, 595, 592, 3, 2, 2, 2, 596, 55, 3, 2, 2,
	2, 597, 599, 5, 74, 38, 2, 598, 600, 5, 78, 40, 2, 599, 598, 3, 2, 2, 2,
	599, 600, 3, 2, 2, 2, 600, 616, 3, 2, 2, 2, 601, 616, 5, 84, 43, 2, 602,
	604, 7, 27, 2, 2, 603, 602, 3, 2, 2, 2, 603, 604, 3, 2, 2, 2, 604, 605,
	3, 2, 2, 2, 605, 616, 5, 18, 10, 2, 606, 608, 7, 27, 2, 2, 607, 606, 3,
	2, 2, 2, 607, 608, 3, 2, 2, 2, 608, 609, 3, 2, 2, 2, 609, 616, 5, 70, 36,
	2, 610, 612, 7, 27, 2, 2, 611, 610, 3, 2, 2, 2, 611, 612, 3, 2, 2, 2, 612,
	613, 3, 2, 2, 2, 613, 616, 5, 72, 37, 2, 614, 616, 5, 64, 33, 2, 615, 597,
	3, 2, 2, 2, 615, 601, 3, 2, 2, 2, 615, 603, 3, 2, 2, 2, 615, 607, 3, 2,
	2, 2, 615, 611, 3, 2, 2, 2, 615, 614, 3, 2, 2, 2, 616, 57, 3, 2, 2, 2,
	617, 620, 5, 88, 45, 2, 618, 621, 5, 76, 39, 2, 619, 621, 5, 78, 40, 2,
	620, 618, 3, 2, 2, 2, 620, 619, 3, 2, 2, 2, 620, 621, 3, 2, 2, 2, 621,
	676, 3, 2, 2, 2, 622, 625, 5, 74, 38, 2, 623, 626, 5, 76, 39, 2, 624, 626,
	5, 78, 40, 2, 625, 623, 3, 2, 2, 2, 625, 624, 3, 2, 2, 2, 625, 626, 3,
	2, 2, 2, 626, 676, 3, 2, 2, 2, 627, 628, 7, 28, 2, 2, 628, 676, 5, 88,
	45, 2, 629, 630, 7, 28, 2, 2, 630, 676, 5, 74, 38, 2, 631, 633, 7, 28,
	2, 2, 632, 634, 7, 27, 2, 2, 633, 632, 3, 2, 2, 2, 633, 634, 3, 2, 2, 2,
	634, 636, 3, 2, 2, 2, 635, 631, 3, 2, 2, 2, 635, 636, 3, 2, 2, 2, 636,
	637, 3, 2, 2, 2, 637, 676, 5, 70, 36, 2, 638, 640, 7, 28, 2, 2, 639, 641,
	7, 27, 2, 2, 640, 639, 3, 2, 2, 2, 640, 641, 3, 2, 2, 2, 641, 643, 3, 2,
	2, 2, 642, 638, 3, 2, 2, 2, 642, 643, 3, 2, 2, 2, 643, 644, 3, 2, 2, 2,
	644, 676, 5, 72, 37, 2, 645, 647, 7, 28, 2, 2, 646, 645, 3, 2, 2, 2, 646,
	647, 3, 2, 2, 2, 647, 648, 3, 2, 2, 2, 648, 676, 5, 64, 33, 2, 649, 651,
	7, 28, 2, 2, 650, 652, 7, 27, 2, 2, 651, 650, 3, 2, 2, 2, 651, 652, 3,
	2, 2, 2, 652, 654, 3, 2, 2, 2, 653, 649, 3, 2, 2, 2, 653, 654, 3, 2, 2,
	2, 654, 655, 3, 2, 2, 2, 655, 676, 5, 18, 10, 2, 656, 657, 7, 27, 2, 2,
	657, 659, 9, 3, 2, 2, 658, 660, 5, 332, 167, 2, 659, 658, 3, 2, 2, 2, 659,
	660, 3, 2, 2, 2, 660, 661, 3, 2, 2, 2, 661, 676, 5, 60, 31, 2, 662, 664,
	7, 4, 2, 2, 663, 665, 5, 332, 167, 2, 664, 663, 3, 2, 2, 2, 664, 665, 3,
	2, 2, 2, 665, 666, 3, 2, 2, 2, 666, 676, 5, 16, 9, 2, 667, 669, 9, 4, 2,
	2, 668, 667, 3, 2, 2, 2, 668, 669, 3, 2, 2, 2, 669, 672, 3, 2, 2, 2, 670,
	673, 7, 6, 2, 2, 671, 673, 5, 332, 167, 2, 672, 670, 3, 2, 2, 2, 672, 671,
	3, 2, 2, 2, 673, 674, 3, 2, 2, 2, 674, 676, 5, 16, 9, 2, 675, 617, 3, 2,
	2, 2, 675, 622, 3, 2, 2, 2, 675, 627, 3, 2, 2, 2, 675, 629, 3, 2, 2, 2,
	675, 635, 3, 2, 2, 2, 675, 642, 3, 2, 2, 2, 675, 646, 3, 2, 2, 2, 675,
	653, 3, 2, 2, 2, 675, 656, 3, 2, 2, 2, 675, 662, 3, 2, 2, 2, 675, 668,
	3, 2, 2, 2, 676, 59, 3, 2, 2, 2, 677, 682, 5, 62, 32, 2, 678, 679, 7, 3,
	2, 2, 679, 681, 5, 62, 32, 2, 680, 678, 3, 2, 2, 2, 681, 684, 3, 2, 2,
	2, 682, 680, 3, 2, 2, 2, 682, 683, 3, 2, 2, 2, 683, 61, 3, 2, 2, 2, 684,
	682, 3, 2, 2, 2, 685, 686, 5, 226, 114, 2, 686, 687, 7, 7, 2, 2, 687, 688,
	5, 108, 55, 2, 688, 63, 3, 2, 2, 2, 689, 691, 5, 22, 12, 2, 690, 689, 3,
	2, 2, 2, 690, 691, 3, 2, 2, 2, 691, 692, 3, 2, 2, 2, 692, 693, 7, 29, 2,
	2, 693, 694, 5, 66, 34, 2, 694, 695, 5, 28, 15, 2, 695, 65, 3, 2, 2, 2,
	696, 701, 7, 30, 2, 2, 697, 701, 5, 68, 35, 2, 698, 701, 7, 31, 2, 2, 699,
	701, 7, 32, 2, 2, 700, 696, 3, 2, 2, 2, 700, 697, 3, 2, 2, 2, 700, 698,
	3, 2, 2, 2, 700, 699, 3, 2, 2, 2, 701, 67, 3, 2, 2, 2, 702, 709, 5, 198,
	100, 2, 703, 709, 5, 194, 98, 2, 704, 709, 5, 190, 96, 2, 705, 709, 5,
	178, 90, 2, 706, 709, 7, 33, 2, 2, 707, 709, 5, 186, 94, 2, 708, 702, 3,
	2, 2, 2, 708, 703, 3, 2, 2, 2, 708, 704, 3, 2, 2, 2, 708, 705, 3, 2, 2,
	2, 708, 706, 3, 2, 2, 2, 708, 707, 3, 2, 2, 2, 709, 69, 3, 2, 2, 2, 710,
	712, 5, 22, 12, 2, 711, 710, 3, 2, 2, 2, 711, 712, 3, 2, 2, 2, 712, 713,
	3, 2, 2, 2, 713, 714, 7, 34, 2, 2, 714, 715, 5, 226, 114, 2, 715, 71, 3,
	2, 2, 2, 716, 718, 5, 22, 12, 2, 717, 716, 3, 2, 2, 2, 717, 718, 3, 2,
	2, 2, 718, 719, 3, 2, 2, 2, 719, 720, 7, 35, 2, 2, 720, 721, 5, 226, 114,
	2, 721, 722, 5, 28, 15, 2, 722, 73, 3, 2, 2, 2, 723, 726, 5, 226, 114,
	2, 724, 725, 7, 22, 2, 2, 725, 727, 5, 226, 114, 2, 726, 724, 3, 2, 2,
	2, 726, 727, 3, 2, 2, 2, 727, 728, 3, 2, 2, 2, 728, 729, 5, 28, 15, 2,
	729, 75, 3, 2, 2, 2, 730, 731, 7, 23, 2, 2, 731, 734, 7, 21, 2, 2, 732,
	733, 7, 22, 2, 2, 733, 735, 5, 226, 114, 2, 734, 732, 3, 2, 2, 2, 734,
	735, 3, 2, 2, 2, 735, 736, 3, 2, 2, 2, 736, 737, 5, 148, 75, 2, 737, 77,
	3, 2, 2, 2, 738, 739, 7, 23, 2, 2, 739, 744, 5, 80, 41, 2, 740, 741, 7,
	3, 2, 2, 741, 743, 5, 80, 41, 2, 742, 740, 3, 2, 2, 2, 743, 746, 3, 2,
	2, 2, 744, 742, 3, 2, 2, 2, 744, 745, 3, 2, 2, 2, 745, 79, 3, 2, 2, 2,
	746, 744, 3, 2, 2, 2, 747, 748, 7, 36, 2, 2, 748, 757, 5, 148, 75, 2, 749,
	750, 7, 36, 2, 2, 750, 751, 7, 22, 2, 2, 751, 752, 5, 226, 114, 2, 752,
	753, 5, 148, 75, 2, 753, 757, 3, 2, 2, 2, 754, 757, 5, 82, 42, 2, 755,
	757, 5, 292, 147, 2, 756, 747, 3, 2, 2, 2, 756, 749, 3, 2, 2, 2, 756, 754,
	3, 2, 2, 2, 756, 755, 3, 2, 2, 2, 757, 81, 3, 2, 2, 2, 758, 759, 7, 21,
	2, 2, 759, 761, 7, 22, 2, 2, 760, 758, 3, 2, 2, 2, 760, 761, 3, 2, 2, 2,
	761, 762, 3, 2, 2, 2, 762, 763, 5, 226, 114, 2, 763, 764, 7, 7, 2, 2, 764,
	768, 5, 164, 83, 2, 765, 767, 5, 154, 78, 2, 766, 765, 3, 2, 2, 2, 767,
	770, 3, 2, 2, 2, 768, 766, 3, 2, 2, 2, 768, 769, 3, 2, 2, 2, 769, 83, 3,
	2, 2, 2, 770, 768, 3, 2, 2, 2, 771, 772, 7, 37, 2, 2, 772, 775, 5, 226,
	114, 2, 773, 774, 7, 22, 2, 2, 774, 776, 5, 226, 114, 2, 775, 773, 3, 2,
	2, 2, 775, 776, 3, 2, 2, 2, 776, 777, 3, 2, 2, 2, 777, 778, 5, 28, 15,
	2, 778, 85, 3, 2, 2, 2, 779, 781, 7, 5, 2, 2, 780, 779, 3, 2, 2, 2, 780,
	781, 3, 2, 2, 2, 781, 782, 3, 2, 2, 2, 782, 783, 7, 37, 2, 2, 783, 786,
	5, 226, 114, 2, 784, 785, 7, 22, 2, 2, 785, 787, 5, 226, 114, 2, 786, 784,
	3, 2, 2, 2, 786, 787, 3, 2, 2, 2, 787, 788, 3, 2, 2, 2, 788, 789, 5, 28,
	15, 2, 789, 790, 7, 7, 2, 2, 790, 793, 5, 332, 167, 2, 791, 792, 7, 22,
	2, 2, 792, 794, 5, 226, 114, 2, 793, 791, 3, 2, 2, 2, 793, 794, 3, 2, 2,
	2, 794, 87, 3, 2, 2, 2, 795, 796, 7, 5, 2, 2, 796, 797, 5, 228, 115, 2,
	797, 798, 5, 28, 15, 2, 798, 89, 3, 2, 2, 2, 799, 800, 7, 38, 2, 2, 800,
	801, 5, 332, 167, 2, 801, 91, 3, 2, 2, 2, 802, 803, 7, 39, 2, 2, 803, 804,
	5, 338, 170, 2, 804, 93, 3, 2, 2, 2, 805, 807, 5, 226, 114, 2, 806, 808,
	5, 104, 53, 2, 807, 806, 3, 2, 2, 2, 807, 808, 3, 2, 2, 2, 808, 809, 3,
	2, 2, 2, 809, 810, 7, 7, 2, 2, 810, 811, 5, 96, 49, 2, 811, 812, 7, 11,
	2, 2, 812, 95, 3, 2, 2, 2, 813, 814, 5, 332, 167, 2, 814, 816, 5, 52, 27,
	2, 815, 817, 5, 92, 47, 2, 816, 815, 3, 2, 2, 2, 816, 817, 3, 2, 2, 2,
	817, 97, 3, 2, 2, 2, 818, 819, 5, 106, 54, 2, 819, 820, 7, 40, 2, 2, 820,
	821, 5, 226, 114, 2, 821, 822, 7, 14, 2, 2, 822, 827, 5, 100, 51, 2, 823,
	824, 7, 3, 2, 2, 824, 826, 5, 100, 51, 2, 825, 823, 3, 2, 2, 2, 826, 829,
	3, 2, 2, 2, 827, 825, 3, 2, 2, 2, 827, 828, 3, 2, 2, 2, 828, 831, 3, 2,
	2, 2, 829, 827, 3, 2, 2, 2, 830, 832, 7, 3, 2, 2, 831, 830, 3, 2, 2, 2,
	831, 832, 3, 2, 2, 2, 832, 833, 3, 2, 2, 2, 833, 834, 7, 15, 2, 2, 834,
	99, 3, 2, 2, 2, 835, 836, 5, 106, 54, 2, 836, 837, 5, 226, 114, 2, 837,
	101, 3, 2, 2, 2, 838, 839, 5, 106, 54, 2, 839, 842, 5, 226, 114, 2, 840,
	841, 7, 38, 2, 2, 841, 843, 5, 332, 167, 2, 842, 840, 3, 2, 2, 2, 842,
	843, 3, 2, 2, 2, 843, 103, 3, 2, 2, 2, 844, 845, 7, 41, 2, 2, 845, 850,
	5, 102, 52, 2, 846, 847, 7, 3, 2, 2, 847, 849, 5, 102, 52, 2, 848, 846,
	3, 2, 2, 2, 849, 852, 3, 2, 2, 2, 850, 848, 3, 2, 2, 2, 850, 851, 3, 2,
	2, 2, 851, 853, 3, 2, 2, 2, 852, 850, 3, 2, 2, 2, 853, 854, 7, 42, 2, 2,
	854, 105, 3, 2, 2, 2, 855, 856, 7, 43, 2, 2, 856, 859, 5, 228, 115, 2,
	857, 858, 7, 22, 2, 2, 858, 860, 5, 226, 114, 2, 859, 857, 3, 2, 2, 2,
	859, 860, 3, 2, 2, 2, 860, 862, 3, 2, 2, 2, 861, 863, 5, 148, 75, 2, 862,
	861, 3, 2, 2, 2, 862, 863, 3, 2, 2, 2, 863, 865, 3, 2, 2, 2, 864, 855,
	3, 2, 2, 2, 865, 868, 3, 2, 2, 2, 866, 864, 3, 2, 2, 2, 866, 867, 3, 2,
	2, 2, 867, 107, 3, 2, 2, 2, 868, 866, 3, 2, 2, 2, 869, 870, 5, 220, 111,
	2, 870, 871, 5, 160, 81, 2, 871, 872, 5, 108, 55, 2, 872, 882, 3, 2, 2,
	2, 873, 877, 5, 164, 83, 2, 874, 876, 5, 154, 78, 2, 875, 874, 3, 2, 2,
	2, 876, 879, 3, 2, 2, 2, 877, 875, 3, 2, 2, 2, 877, 878, 3, 2, 2, 2, 878,
	882, 3, 2, 2, 2, 879, 877, 3, 2, 2, 2, 880, 882, 5, 136, 69, 2, 881, 869,
	3, 2, 2, 2, 881, 873, 3, 2, 2, 2, 881, 880, 3, 2, 2, 2, 882, 109, 3, 2,
	2, 2, 883, 884, 5, 220, 111, 2, 884, 885, 5, 160, 81, 2, 885, 886, 5, 110,
	56, 2, 886, 890, 3, 2, 2, 2, 887, 890, 5, 164, 83, 2, 888, 890, 5, 138,
	70, 2, 889, 883, 3, 2, 2, 2, 889, 887, 3, 2, 2, 2, 889, 888, 3, 2, 2, 2,
	890, 111, 3, 2, 2, 2, 891, 896, 5, 108, 55, 2, 892, 893, 7, 3, 2, 2, 893,
	895, 5, 108, 55, 2, 894, 892, 3, 2, 2, 2, 895, 898, 3, 2, 2, 2, 896, 894,
	3, 2, 2, 2, 896, 897, 3, 2, 2, 2, 897, 113, 3, 2, 2, 2, 898, 896, 3, 2,
	2, 2, 899, 912, 5, 142, 72, 2, 900, 901, 7, 36, 2, 2, 901, 912, 5, 222,
	112, 2, 902, 912, 5, 140, 71, 2, 903, 912, 5, 116, 59, 2, 904, 912, 5,
	226, 114, 2, 905, 912, 5, 144, 73, 2, 906, 912, 5, 146, 74, 2, 907, 908,
	7, 16, 2, 2, 908, 909, 5, 108, 55, 2, 909, 910, 7, 17, 2, 2, 910, 912,
	3, 2, 2, 2, 911, 899, 3, 2, 2, 2, 911, 900, 3, 2, 2, 2, 911, 902, 3, 2,
	2, 2, 911, 903, 3, 2, 2, 2, 911, 904, 3, 2, 2, 2, 911, 905, 3, 2, 2, 2,
	911, 906, 3, 2, 2, 2, 911, 907, 3, 2, 2, 2, 912, 115, 3, 2, 2, 2, 913,
	921, 5, 118, 60, 2, 914, 921, 5, 122, 62, 2, 915, 921, 5, 120, 61, 2, 916,
	921, 5, 124, 63, 2, 917, 921, 5, 128, 65, 2, 918, 921, 5, 132, 67, 2, 919,
	921, 5, 130, 66, 2, 920, 913, 3, 2, 2, 2, 920, 914, 3, 2, 2, 2, 920, 915,
	3, 2, 2, 2, 920, 916, 3, 2, 2, 2, 920, 917, 3, 2, 2, 2, 920, 918, 3, 2,
	2, 2, 920, 919, 3, 2, 2, 2, 921, 117, 3, 2, 2, 2, 922, 923, 7, 44, 2, 2,
	923, 119, 3, 2, 2, 2, 924, 925, 9, 5, 2, 2, 925, 121, 3, 2, 2, 2, 926,
	927, 9, 6, 2, 2, 927, 123, 3, 2, 2, 2, 928, 930, 9, 7, 2, 2, 929, 928,
	3, 2, 2, 2, 930, 931, 3, 2, 2, 2, 931, 929, 3, 2, 2, 2, 931, 932, 3, 2,
	2, 2, 932, 125, 3, 2, 2, 2, 933, 934, 7, 47, 2, 2, 934, 940, 5, 226, 114,
	2, 935, 936, 7, 48, 2, 2, 936, 937, 5, 108, 55, 2, 937, 938, 7, 15, 2,
	2, 938, 940, 3, 2, 2, 2, 939, 933, 3, 2, 2, 2, 939, 935, 3, 2, 2, 2, 940,
	127, 3, 2, 2, 2, 941, 951, 7, 49, 2, 2, 942, 952, 5, 66, 34, 2, 943, 948,
	5, 226, 114, 2, 944, 945, 7, 3, 2, 2, 945, 947, 5, 226, 114, 2, 946, 944,
	3, 2, 2, 2, 947, 950, 3, 2, 2, 2, 948, 946, 3, 2, 2, 2, 948, 949, 3, 2,
	2, 2, 949, 952, 3, 2, 2, 2, 950, 948, 3, 2, 2, 2, 951, 942, 3, 2, 2, 2,
	951, 943, 3, 2, 2, 2, 952, 129, 3, 2, 2, 2, 953, 955, 7, 5, 2, 2, 954,
	953, 3, 2, 2, 2, 954, 955, 3, 2, 2, 2, 955, 957, 3, 2, 2, 2, 956, 958,
	5, 336, 169, 2, 957, 956, 3, 2, 2, 2, 957, 958, 3, 2, 2, 2, 958, 959, 3,
	2, 2, 2, 959, 964, 7, 18, 2, 2, 960, 962, 5, 112, 57, 2, 961, 963, 7, 3,
	2, 2, 962, 961, 3, 2, 2, 2, 962, 963, 3, 2, 2, 2, 963, 965, 3, 2, 2, 2,
	964, 960, 3, 2, 2, 2, 964, 965, 3, 2, 2, 2, 965, 966, 3, 2, 2, 2, 966,
	967, 7, 19, 2, 2, 967, 131, 3, 2, 2, 2, 968, 970, 7, 5, 2, 2, 969, 968,
	3, 2, 2, 2, 969, 970, 3, 2, 2, 2, 970, 972, 3, 2, 2, 2, 971, 973, 5, 336,
	169, 2, 972, 971, 3, 2, 2, 2, 972, 973, 3, 2, 2, 2, 973, 974, 3, 2, 2,
	2, 974, 986, 7, 14, 2, 2, 975, 980, 5, 134, 68, 2, 976, 977, 7, 3, 2, 2,
	977, 979, 5, 134, 68, 2, 978, 976, 3, 2, 2, 2, 979, 982, 3, 2, 2, 2, 980,
	978, 3, 2, 2, 2, 980, 981, 3, 2, 2, 2, 981, 984, 3, 2, 2, 2, 982, 980,
	3, 2, 2, 2, 983, 985, 7, 3, 2, 2, 984, 983, 3, 2, 2, 2, 984, 985, 3, 2,
	2, 2, 985, 987, 3, 2, 2, 2, 986, 975, 3, 2, 2, 2, 986, 987, 3, 2, 2, 2,
	987, 988, 3, 2, 2, 2, 988, 989, 7, 15, 2, 2, 989, 133, 3, 2, 2, 2, 990,
	991, 5, 108, 55, 2, 991, 992, 7, 23, 2, 2, 992, 993, 5, 108, 55, 2, 993,
	135, 3, 2, 2, 2, 994, 995, 7, 50, 2, 2, 995, 996, 5, 108, 55, 2, 996, 137,
	3, 2, 2, 2, 997, 998, 7, 50, 2, 2, 998, 999, 5, 110, 56, 2, 999, 139, 3,
	2, 2, 2, 1000, 1001, 5, 20, 11, 2, 1001, 1002, 5, 24, 13, 2, 1002, 141,
	3, 2, 2, 2, 1003, 1004, 7, 21, 2, 2, 1004, 143, 3, 2, 2, 2, 1005, 1006,
	7, 51, 2, 2, 1006, 1009, 5, 332, 167, 2, 1007, 1008, 7, 22, 2, 2, 1008,
	1010, 5, 226, 114, 2, 1009, 1007, 3, 2, 2, 2, 1009, 1010, 3, 2, 2, 2, 1010,
	1011, 3, 2, 2, 2, 1011, 1012, 5, 148, 75, 2, 1012, 145, 3, 2, 2, 2, 1013,
	1014, 7, 5, 2, 2, 1014, 1017, 5, 332, 167, 2, 1015, 1016, 7, 22, 2, 2,
	1016, 1018, 5, 226, 114, 2, 1017, 1015, 3, 2, 2, 2, 1017, 1018, 3, 2, 2,
	2, 1018, 1019, 3, 2, 2, 2, 1019, 1020, 5, 148, 75, 2, 1020, 147, 3, 2,
	2, 2, 1021, 1026, 7, 16, 2, 2, 1022, 1024, 5, 150, 76, 2, 1023, 1025, 7,
	3, 2, 2, 1024, 1023, 3, 2, 2, 2, 1024, 1025, 3, 2, 2, 2, 1025, 1027, 3,
	2, 2, 2, 1026, 1022, 3, 2, 2, 2, 1026, 1027, 3, 2, 2, 2, 1027, 1028, 3,
	2, 2, 2, 1028, 1029, 7, 17, 2, 2, 1029, 149, 3, 2, 2, 2, 1030, 1035, 5,
	152, 77, 2, 1031, 1032, 7, 3, 2, 2, 1032, 1034, 5, 152, 77, 2, 1033, 1031,
	3, 2, 2, 2, 1034, 1037, 3, 2, 2, 2, 1035, 1033, 3, 2, 2, 2, 1035, 1036,
	3, 2, 2, 2, 1036, 1047, 3, 2, 2, 2, 1037, 1035, 3, 2, 2, 2, 1038, 1043,
	5, 112, 57, 2, 1039, 1040, 7, 3, 2, 2, 1040, 1042, 5, 152, 77, 2, 1041,
	1039, 3, 2, 2, 2, 1042, 1045, 3, 2, 2, 2, 1043, 1041, 3, 2, 2, 2, 1043,
	1044, 3, 2, 2, 2, 1044, 1047, 3, 2, 2, 2, 1045, 1043, 3, 2, 2, 2, 1046,
	1030, 3, 2, 2, 2, 1046, 1038, 3, 2, 2, 2, 1047, 151, 3, 2, 2, 2, 1048,
	1049, 5, 280, 141, 2, 1049, 1050, 5, 108, 55, 2, 1050, 153, 3, 2, 2, 2,
	1051, 1052, 7, 52, 2, 2, 1052, 1056, 5, 156, 79, 2, 1053, 1055, 5, 158,
	80, 2, 1054, 1053, 3, 2, 2, 2, 1055, 1058, 3, 2, 2, 2, 1056, 1054, 3, 2,
	2, 2, 1056, 1057, 3, 2, 2, 2, 1057, 1068, 3, 2, 2, 2, 1058, 1056, 3, 2,
	2, 2, 1059, 1063, 5, 224, 113, 2, 1060, 1062, 5, 158, 80, 2, 1061, 1060,
	3, 2, 2, 2, 1062, 1065, 3, 2, 2, 2, 1063, 1061, 3, 2, 2, 2, 1063, 1064,
	3, 2, 2, 2, 1064, 1067, 3, 2, 2, 2, 1065, 1063, 3, 2, 2, 2, 1066, 1059,
	3, 2, 2, 2, 1067, 1070, 3, 2, 2, 2, 1068, 1066, 3, 2, 2, 2, 1068, 1069,
	3, 2, 2, 2, 1069, 1074, 3, 2, 2, 2, 1070, 1068, 3, 2, 2, 2, 1071, 1072,
	5, 160, 81, 2, 1072, 1073, 5, 110, 56, 2, 1073, 1075, 3, 2, 2, 2, 1074,
	1071, 3, 2, 2, 2, 1074, 1075, 3, 2, 2, 2, 1075, 155, 3, 2, 2, 2, 1076,
	1077, 7, 18, 2, 2, 1077, 1078, 5, 108, 55, 2, 1078, 1079, 7, 19, 2, 2,
	1079, 1082, 3, 2, 2, 2, 1080, 1082, 5, 226, 114, 2, 1081, 1076, 3, 2, 2,
	2, 1081, 1080, 3, 2, 2, 2, 1082, 157, 3, 2, 2, 2, 1083, 1085, 5, 336, 169,
	2, 1084, 1083, 3, 2, 2, 2, 1084, 1085, 3, 2, 2, 2, 1085, 1086, 3, 2, 2,
	2, 1086, 1087, 5, 148, 75, 2, 1087, 159, 3, 2, 2, 2, 1088, 1091, 7, 7,
	2, 2, 1089, 1091, 5, 162, 82, 2, 1090, 1088, 3, 2, 2, 2, 1090, 1089, 3,
	2, 2, 2, 1091, 161, 3, 2, 2, 2, 1092, 1093, 9, 8, 2, 2, 1093, 163, 3, 2,
	2, 2, 1094, 1100, 5, 166, 84, 2, 1095, 1096, 7, 65, 2, 2, 1096, 1097, 5,
	110, 56, 2, 1097, 1098, 7, 23, 2, 2, 1098, 1099, 5, 110, 56, 2, 1099, 1101,
	3, 2, 2, 2, 1100, 1095, 3, 2, 2, 2, 1100, 1101, 3, 2, 2, 2, 1101, 165,
	3, 2, 2, 2, 1102, 1107, 5, 168, 85, 2, 1103, 1104, 7, 66, 2, 2, 1104, 1106,
	5, 168, 85, 2, 1105, 1103, 3, 2, 2, 2, 1106, 1109, 3, 2, 2, 2, 1107, 1105,
	3, 2, 2, 2, 1107, 1108, 3, 2, 2, 2, 1108, 167, 3, 2, 2, 2, 1109, 1107,
	3, 2, 2, 2, 1110, 1115, 5, 170, 86, 2, 1111, 1112, 7, 67, 2, 2, 1112, 1114,
	5, 170, 86, 2, 1113, 1111, 3, 2, 2, 2, 1114, 1117, 3, 2, 2, 2, 1115, 1113,
	3, 2, 2, 2, 1115, 1116, 3, 2, 2, 2, 1116, 169, 3, 2, 2, 2, 1117, 1115,
	3, 2, 2, 2, 1118, 1123, 5, 172, 87, 2, 1119, 1120, 7, 68, 2, 2, 1120, 1122,
	5, 172, 87, 2, 1121, 1119, 3, 2, 2, 2, 1122, 1125, 3, 2, 2, 2, 1123, 1121,
	3, 2, 2, 2, 1123, 1124, 3, 2, 2, 2, 1124, 171, 3, 2, 2, 2, 1125, 1123,
	3, 2, 2, 2, 1126, 1130, 5, 176, 89, 2, 1127, 1128, 5, 174, 88, 2, 1128,
	1129, 5, 176, 89, 2, 1129, 1131, 3, 2, 2, 2, 1130, 1127, 3, 2, 2, 2, 1130,
	1131, 3, 2, 2, 2, 1131, 1137, 3, 2, 2, 2, 1132, 1133, 7, 36, 2, 2, 1133,
	1134, 5, 174, 88, 2, 1134, 1135, 5, 176, 89, 2, 1135, 1137, 3, 2, 2, 2,
	1136, 1126, 3, 2, 2, 2, 1136, 1132, 3, 2, 2, 2, 1137, 173, 3, 2, 2, 2,
	1138, 1139, 9, 9, 2, 2, 1139, 175, 3, 2, 2, 2, 1140, 1146, 5, 180, 91,
	2, 1141, 1147, 5, 230, 116, 2, 1142, 1147, 5, 234, 118, 2, 1143, 1144,
	5, 178, 90, 2, 1144, 1145, 5, 180, 91, 2, 1145, 1147, 3, 2, 2, 2, 1146,
	1141, 3, 2, 2, 2, 1146, 1142, 3, 2, 2, 2, 1146, 1143, 3, 2, 2, 2, 1146,
	1147, 3, 2, 2, 2, 1147, 1153, 3, 2, 2, 2, 1148, 1149, 7, 36, 2, 2, 1149,
	1150, 5, 178, 90, 2, 1150, 1151, 5, 180, 91, 2, 1151, 1153, 3, 2, 2, 2,
	1152, 1140, 3, 2, 2, 2, 1152, 1148, 3, 2, 2, 2, 1153, 177, 3, 2, 2, 2,
	1154, 1155, 9, 10, 2, 2, 1155, 179, 3, 2, 2, 2, 1156, 1161, 5, 182, 92,
	2, 1157, 1158, 7, 72, 2, 2, 1158, 1160, 5, 182, 92, 2, 1159, 1157, 3, 2,
	2, 2, 1160, 1163, 3, 2, 2, 2, 1161, 1159, 3, 2, 2, 2, 1161, 1162, 3, 2,
	2, 2, 1162, 1172, 3, 2, 2, 2, 1163, 1161, 3, 2, 2, 2, 1164, 1167, 7, 36,
	2, 2, 1165, 1166, 7, 72, 2, 2, 1166, 1168, 5, 180, 91, 2, 1167, 1165, 3,
	2, 2, 2, 1168, 1169, 3, 2, 2, 2, 1169, 1167, 3, 2, 2, 2, 1169, 1170, 3,
	2, 2, 2, 1170, 1172, 3, 2, 2, 2, 1171, 1156, 3, 2, 2, 2, 1171, 1164, 3,
	2, 2, 2, 1172, 181, 3, 2, 2, 2, 1173, 1178, 5, 184, 93, 2, 1174, 1175,
	7, 73, 2, 2, 1175, 1177, 5, 184, 93, 2, 1176, 1174, 3, 2, 2, 2, 1177, 1180,
	3, 2, 2, 2, 1178, 1176, 3, 2, 2, 2, 1178, 1179, 3, 2, 2, 2, 1179, 1189,
	3, 2, 2, 2, 1180, 1178, 3, 2, 2, 2, 1181, 1184, 7, 36, 2, 2, 1182, 1183,
	7, 73, 2, 2, 1183, 1185, 5, 184, 93, 2, 1184, 1182, 3, 2, 2, 2, 1185, 1186,
	3, 2, 2, 2, 1186, 1184, 3, 2, 2, 2, 1186, 1187, 3, 2, 2, 2, 1187, 1189,
	3, 2, 2, 2, 1188, 1173, 3, 2, 2, 2, 1188, 1181, 3, 2, 2, 2, 1189, 183,
	3, 2, 2, 2, 1190, 1195, 5, 188, 95, 2, 1191, 1192, 7, 74, 2, 2, 1192, 1194,
	5, 188, 95, 2, 1193, 1191, 3, 2, 2, 2, 1194, 1197, 3, 2, 2, 2, 1195, 1193,
	3, 2, 2, 2, 1195, 1196, 3, 2, 2, 2, 1196, 1206, 3, 2, 2, 2, 1197, 1195,
	3, 2, 2, 2, 1198, 1201, 7, 36, 2, 2, 1199, 1200, 7, 74, 2, 2, 1200, 1202,
	5, 188, 95, 2, 1201, 1199, 3, 2, 2, 2, 1202, 1203, 3, 2, 2, 2, 1203, 1201,
	3, 2, 2, 2, 1203, 1204, 3, 2, 2, 2, 1204, 1206, 3, 2, 2, 2, 1205, 1190,
	3, 2, 2, 2, 1205, 1198, 3, 2, 2, 2, 1206, 185, 3, 2, 2, 2, 1207, 1208,
	9, 11, 2, 2, 1208, 187, 3, 2, 2, 2, 1209, 1215, 5, 192, 97, 2, 1210, 1211,
	5, 190, 96, 2, 1211, 1212, 5, 192, 97, 2, 1212, 1214, 3, 2, 2, 2, 1213,
	1210, 3, 2, 2, 2, 1214, 1217, 3, 2, 2, 2, 1215, 1213, 3, 2, 2, 2, 1215,
	1216, 3, 2, 2, 2, 1216, 1227, 3, 2, 2, 2, 1217, 1215, 3, 2, 2, 2, 1218,
	1222, 7, 36, 2, 2, 1219, 1220, 5, 190, 96, 2, 1220, 1221, 5, 192, 97, 2,
	1221, 1223, 3, 2, 2, 2, 1222, 1219, 3, 2, 2, 2, 1223, 1224, 3, 2, 2, 2,
	1224, 1222, 3, 2, 2, 2, 1224, 1225, 3, 2, 2, 2, 1225, 1227, 3, 2, 2, 2,
	1226, 1209, 3, 2, 2, 2, 1226, 1218, 3, 2, 2, 2, 1227, 189, 3, 2, 2, 2,
	1228, 1229, 9, 12, 2, 2, 1229, 191, 3, 2, 2, 2, 1230, 1236, 5, 196, 99,
	2, 1231, 1232, 5, 194, 98, 2, 1232, 1233, 5, 196, 99, 2, 1233, 1235, 3,
	2, 2, 2, 1234, 1231, 3, 2, 2, 2, 1235, 1238, 3, 2, 2, 2, 1236, 1234, 3,
	2, 2, 2, 1236, 1237, 3, 2, 2, 2, 1237, 1248, 3, 2, 2, 2, 1238, 1236, 3,
	2, 2, 2, 1239, 1243, 7, 36, 2, 2, 1240, 1241, 5, 194, 98, 2, 1241, 1242,
	5, 196, 99, 2, 1242, 1244, 3, 2, 2, 2, 1243, 1240, 3, 2, 2, 2, 1244, 1245,
	3, 2, 2, 2, 1245, 1243, 3, 2, 2, 2, 1245, 1246, 3, 2, 2, 2, 1246, 1248,
	3, 2, 2, 2, 1247, 1230, 3, 2, 2, 2, 1247, 1239, 3, 2, 2, 2, 1248, 193,
	3, 2, 2, 2, 1249, 1250, 9, 13, 2, 2, 1250, 195, 3, 2, 2, 2, 1251, 1257,
	5, 200, 101, 2, 1252, 1253, 5, 198, 100, 2, 1253, 1254, 5, 200, 101, 2,
	1254, 1256, 3, 2, 2, 2, 1255, 1252, 3, 2, 2, 2, 1256, 1259, 3, 2, 2, 2,
	1257, 1255, 3, 2, 2, 2, 1257, 1258, 3, 2, 2, 2, 1258, 1269, 3, 2, 2, 2,
	1259, 1257, 3, 2, 2, 2, 1260, 1264, 7, 36, 2, 2, 1261, 1262, 5, 198, 100,
	2, 1262, 1263, 5, 200, 101, 2, 1263, 1265, 3, 2, 2, 2, 1264, 1261, 3, 2,
	2, 2, 1265, 1266, 3, 2, 2, 2, 1266, 1264, 3, 2, 2, 2, 1266, 1267, 3, 2,
	2, 2, 1267, 1269, 3, 2, 2, 2, 1268, 1251, 3, 2, 2, 2, 1268, 1260, 3, 2,
	2, 2, 1269, 197, 3, 2, 2, 2, 1270, 1271, 9, 14, 2, 2, 1271, 199, 3, 2,
	2, 2, 1272, 1273, 5, 202, 102, 2, 1273, 1274, 5, 200, 101, 2, 1274, 1287,
	3, 2, 2, 2, 1275, 1287, 5, 210, 106, 2, 1276, 1287, 5, 212, 107, 2, 1277,
	1280, 5, 204, 103, 2, 1278, 1280, 5, 208, 105, 2, 1279, 1277, 3, 2, 2,
	2, 1279, 1278, 3, 2, 2, 2, 1280, 1281, 3, 2, 2, 2, 1281, 1282, 7, 36, 2,
	2, 1282, 1287, 3, 2, 2, 2, 1283, 1284, 5, 218, 110, 2, 1284, 1285, 5, 220,
	111, 2, 1285, 1287, 3, 2, 2, 2, 1286, 1272, 3, 2, 2, 2, 1286, 1275, 3,
	2, 2, 2, 1286, 1276, 3, 2, 2, 2, 1286, 1279, 3, 2, 2, 2, 1286, 1283, 3,
	2, 2, 2, 1287, 201, 3, 2, 2, 2, 1288, 1292, 5, 204, 103, 2, 1289, 1292,
	5, 206, 104, 2, 1290, 1292, 5, 208, 105, 2, 1291, 1288, 3, 2, 2, 2, 1291,
	1289, 3, 2, 2, 2, 1291, 1290, 3, 2, 2, 2, 1292, 203, 3, 2, 2, 2, 1293,
	1294, 7, 79, 2, 2, 1294, 205, 3, 2, 2, 2, 1295, 1296, 7, 84, 2, 2, 1296,
	207, 3, 2, 2, 2, 1297, 1298, 7, 30, 2, 2, 1298, 209, 3, 2, 2, 2, 1299,
	1300, 7, 85, 2, 2, 1300, 1301, 5, 200, 101, 2, 1301, 211, 3, 2, 2, 2, 1302,
	1303, 5, 220, 111, 2, 1303, 1304, 5, 214, 108, 2, 1304, 1313, 3, 2, 2,
	2, 1305, 1309, 5, 114, 58, 2, 1306, 1308, 5, 216, 109, 2, 1307, 1306, 3,
	2, 2, 2, 1308, 1311, 3, 2, 2, 2, 1309, 1307, 3, 2, 2, 2, 1309, 1310, 3,
	2, 2, 2, 1310, 1313, 3, 2, 2, 2, 1311, 1309, 3, 2, 2, 2, 1312, 1302, 3,
	2, 2, 2, 1312, 1305, 3, 2, 2, 2, 1313, 213, 3, 2, 2, 2, 1314, 1315, 5,
	218, 110, 2, 1315, 215, 3, 2, 2, 2, 1316, 1319, 5, 224, 113, 2, 1317, 1319,
	5, 158, 80, 2, 1318, 1316, 3, 2, 2, 2, 1318, 1317, 3, 2, 2, 2, 1319, 217,
	3, 2, 2, 2, 1320, 1321, 9, 15, 2, 2, 1321, 219, 3, 2, 2, 2, 1322, 1330,
	5, 114, 58, 2, 1323, 1325, 5, 158, 80, 2, 1324, 1323, 3, 2, 2, 2, 1325,
	1328, 3, 2, 2, 2, 1326, 1324, 3, 2, 2, 2, 1326, 1327, 3, 2, 2, 2, 1327,
	1329, 3, 2, 2, 2, 1328, 1326, 3, 2, 2, 2, 1329, 1331, 5, 224, 113, 2, 1330,
	1326, 3, 2, 2, 2, 1330, 1331, 3, 2, 2, 2, 1331, 1337, 3, 2, 2, 2, 1332,
	1333, 7, 36, 2, 2, 1333, 1334, 5, 222, 112, 2, 1334, 1335, 5, 226, 114,
	2, 1335, 1337, 3, 2, 2, 2, 1336, 1322, 3, 2, 2, 2, 1336, 1332, 3, 2, 2,
	2, 1337, 221, 3, 2, 2, 2, 1338, 1339, 7, 18, 2, 2, 1339, 1340, 5, 108,
	55, 2, 1340, 1341, 7, 19, 2, 2, 1341, 1345, 3, 2, 2, 2, 1342, 1343, 7,
	22, 2, 2, 1343, 1345, 5, 226, 114, 2, 1344, 1338, 3, 2, 2, 2, 1344, 1342,
	3, 2, 2, 2, 1345, 223, 3, 2, 2, 2, 1346, 1350, 5, 222, 112, 2, 1347, 1348,
	7, 88, 2, 2, 1348, 1350, 5, 226, 114, 2, 1349, 1346, 3, 2, 2, 2, 1349,
	1347, 3, 2, 2, 2, 1350, 225, 3, 2, 2, 2, 1351, 1352, 7, 126, 2, 2, 1352,
	227, 3, 2, 2, 2, 1353, 1356, 5, 226, 114, 2, 1354, 1355, 7, 22, 2, 2, 1355,
	1357, 5, 226, 114, 2, 1356, 1354, 3, 2, 2, 2, 1356, 1357, 3, 2, 2, 2, 1357,
	229, 3, 2, 2, 2, 1358, 1359, 5, 232, 117, 2, 1359, 1360, 5, 332, 167, 2,
	1360, 231, 3, 2, 2, 2, 1361, 1363, 7, 89, 2, 2, 1362, 1364, 7, 84, 2, 2,
	1363, 1362, 3, 2, 2, 2, 1363, 1364, 3, 2, 2, 2, 1364, 233, 3, 2, 2, 2,
	1365, 1366, 5, 236, 119, 2, 1366, 1367, 5, 332, 167, 2, 1367, 235, 3, 2,
	2, 2, 1368, 1369, 7, 90, 2, 2, 1369, 237, 3, 2, 2, 2, 1370, 1372, 5, 240,
	121, 2, 1371, 1370, 3, 2, 2, 2, 1372, 1375, 3, 2, 2, 2, 1373, 1371, 3,
	2, 2, 2, 1373, 1374, 3, 2, 2, 2, 1374, 239, 3, 2, 2, 2, 1375, 1373, 3,
	2, 2, 2, 1376, 1378, 5, 280, 141, 2, 1377, 1376, 3, 2, 2, 2, 1378, 1381,
	3, 2, 2, 2, 1379, 1377, 3, 2, 2, 2, 1379, 1380, 3, 2, 2, 2, 1380, 1382,
	3, 2, 2, 2, 1381, 1379, 3, 2, 2, 2, 1382, 1383, 5, 242, 122, 2, 1383, 241,
	3, 2, 2, 2, 1384, 1402, 5, 26, 14, 2, 1385, 1402, 5, 246, 124, 2, 1386,
	1402, 5, 252, 127, 2, 1387, 1402, 5, 258, 130, 2, 1388, 1402, 5, 260, 131,
	2, 1389, 1402, 5, 262, 132, 2, 1390, 1402, 5, 250, 126, 2, 1391, 1402,
	5, 268, 135, 2, 1392, 1402, 5, 270, 136, 2, 1393, 1402, 5, 282, 142, 2,
	1394, 1402, 5, 284, 143, 2, 1395, 1402, 5, 278, 140, 2, 1396, 1402, 5,
	286, 144, 2, 1397, 1402, 5, 288, 145, 2, 1398, 1402, 5, 244, 123, 2, 1399,
	1402, 5, 290, 146, 2, 1400, 1402, 5, 248, 125, 2, 1401, 1384, 3, 2, 2,
	2, 1401, 1385, 3, 2, 2, 2, 1401, 1386, 3, 2, 2, 2, 1401, 1387, 3, 2, 2,
	2, 1401, 1388, 3, 2, 2, 2, 1401, 1389, 3, 2, 2, 2, 1401, 1390, 3, 2, 2,
	2, 1401, 1391, 3, 2, 2, 2, 1401, 1392, 3, 2, 2, 2, 1401, 1393, 3, 2, 2,
	2, 1401, 1394, 3, 2, 2, 2, 1401, 1395, 3, 2, 2, 2, 1401, 1396, 3, 2, 2,
	2, 1401, 1397, 3, 2, 2, 2, 1401, 1398, 3, 2, 2, 2, 1401, 1399, 3, 2, 2,
	2, 1401, 1400, 3, 2, 2, 2, 1402, 243, 3, 2, 2, 2, 1403, 1405, 5, 108, 55,
	2, 1404, 1403, 3, 2, 2, 2, 1404, 1405, 3, 2, 2, 2, 1405, 1406, 3, 2, 2,
	2, 1406, 1407, 7, 11, 2, 2, 1407, 245, 3, 2, 2, 2, 1408, 1409, 5, 12, 7,
	2, 1409, 1410, 7, 11, 2, 2, 1410, 247, 3, 2, 2, 2, 1411, 1412, 5, 18, 10,
	2, 1412, 1413, 5, 24, 13, 2, 1413, 249, 3, 2, 2, 2, 1414, 1415, 7, 91,
	2, 2, 1415, 1416, 7, 16, 2, 2, 1416, 1417, 5, 108, 55, 2, 1417, 1418, 7,
	17, 2, 2, 1418, 1421, 5, 240, 121, 2, 1419, 1420, 7, 92, 2, 2, 1420, 1422,
	5, 240, 121, 2, 1421, 1419, 3, 2, 2, 2, 1421, 1422, 3, 2, 2, 2, 1422, 251,
	3, 2, 2, 2, 1423, 1425, 7, 85, 2, 2, 1424, 1423, 3, 2, 2, 2, 1424, 1425,
	3, 2, 2, 2, 1425, 1426, 3, 2, 2, 2, 1426, 1427, 7, 93, 2, 2, 1427, 1428,
	7, 16, 2, 2, 1428, 1429, 5, 254, 128, 2, 1429, 1430, 7, 17, 2, 2, 1430,
	1431, 5, 240, 121, 2, 1431, 253, 3, 2, 2, 2, 1432, 1434, 5, 256, 129, 2,
	1433, 1435, 5, 108, 55, 2, 1434, 1433, 3, 2, 2, 2, 1434, 1435, 3, 2, 2,
	2, 1435, 1436, 3, 2, 2, 2, 1436, 1438, 7, 11, 2, 2, 1437, 1439, 5, 112,
	57, 2, 1438, 1437, 3, 2, 2, 2, 1438, 1439, 3, 2, 2, 2, 1439, 1449, 3, 2,
	2, 2, 1440, 1441, 5, 6, 4, 2, 1441, 1442, 7, 94, 2, 2, 1442, 1443, 5, 108,
	55, 2, 1443, 1449, 3, 2, 2, 2, 1444, 1445, 5, 226, 114, 2, 1445, 1446,
	7, 94, 2, 2, 1446, 1447, 5, 108, 55, 2, 1447, 1449, 3, 2, 2, 2, 1448, 1432,
	3, 2, 2, 2, 1448, 1440, 3, 2, 2, 2, 1448, 1444, 3, 2, 2, 2, 1449, 255,
	3, 2, 2, 2, 1450, 1456, 5, 246, 124, 2, 1451, 1453, 5, 108, 55, 2, 1452,
	1451, 3, 2, 2, 2, 1452, 1453, 3, 2, 2, 2, 1453, 1454, 3, 2, 2, 2, 1454,
	1456, 7, 11, 2, 2, 1455, 1450, 3, 2, 2, 2, 1455, 1452, 3, 2, 2, 2, 1456,
	257, 3, 2, 2, 2, 1457, 1458, 7, 95, 2, 2, 1458, 1459, 7, 16, 2, 2, 1459,
	1460, 5, 108, 55, 2, 1460, 1461, 7, 17, 2, 2, 1461, 1462, 5, 240, 121,
	2, 1462, 259, 3, 2, 2, 2, 1463, 1464, 7, 96, 2, 2, 1464, 1465, 5, 240,
	121, 2, 1465, 1466, 7, 95, 2, 2, 1466, 1467, 7, 16, 2, 2, 1467, 1468, 5,
	108, 55, 2, 1468, 1469, 7, 17, 2, 2, 1469, 1470, 7, 11, 2, 2, 1470, 261,
	3, 2, 2, 2, 1471, 1472, 7, 97, 2, 2, 1472, 1473, 7, 16, 2, 2, 1473, 1474,
	5, 108, 55, 2, 1474, 1475, 7, 17, 2, 2, 1475, 1479, 7, 14, 2, 2, 1476,
	1478, 5, 264, 133, 2, 1477, 1476, 3, 2, 2, 2, 1478, 1481, 3, 2, 2, 2, 1479,
	1477, 3, 2, 2, 2, 1479, 1480, 3, 2, 2, 2, 1480, 1483, 3, 2, 2, 2, 1481,
	1479, 3, 2, 2, 2, 1482, 1484, 5, 266, 134, 2, 1483, 1482, 3, 2, 2, 2, 1483,
	1484, 3, 2, 2, 2, 1484, 1485, 3, 2, 2, 2, 1485, 1486, 7, 15, 2, 2, 1486,
	263, 3, 2, 2, 2, 1487, 1489, 5, 280, 141, 2, 1488, 1487, 3, 2, 2, 2, 1489,
	1492, 3, 2, 2, 2, 1490, 1488, 3, 2, 2, 2, 1490, 1491, 3, 2, 2, 2, 1491,
	1493, 3, 2, 2, 2, 1492, 1490, 3, 2, 2, 2, 1493, 1494, 7, 98, 2, 2, 1494,
	1495, 5, 108, 55, 2, 1495, 1496, 7, 23, 2, 2, 1496, 1497, 5, 238, 120,
	2, 1497, 265, 3, 2, 2, 2, 1498, 1500, 5, 280, 141, 2, 1499, 1498, 3, 2,
	2, 2, 1500, 1503, 3, 2, 2, 2, 1501, 1499, 3, 2, 2, 2, 1501, 1502, 3, 2,
	2, 2, 1502, 1504, 3, 2, 2, 2, 1503, 1501, 3, 2, 2, 2, 1504, 1505, 7, 99,
	2, 2, 1505, 1506, 7, 23, 2, 2, 1506, 1507, 5, 238, 120, 2, 1507, 267, 3,
	2, 2, 2, 1508, 1509, 7, 100, 2, 2, 1509, 1510, 7, 11, 2, 2, 1510, 269,
	3, 2, 2, 2, 1511, 1512, 7, 101, 2, 2, 1512, 1522, 5, 26, 14, 2, 1513, 1515,
	5, 272, 137, 2, 1514, 1513, 3, 2, 2, 2, 1515, 1516, 3, 2, 2, 2, 1516, 1514,
	3, 2, 2, 2, 1516, 1517, 3, 2, 2, 2, 1517, 1519, 3, 2, 2, 2, 1518, 1520,
	5, 276, 139, 2, 1519, 1518, 3, 2, 2, 2, 1519, 1520, 3, 2, 2, 2, 1520, 1523,
	3, 2, 2, 2, 1521, 1523, 5, 276, 139, 2, 1522, 1514, 3, 2, 2, 2, 1522, 1521,
	3, 2, 2, 2, 1523, 271, 3, 2, 2, 2, 1524, 1525, 5, 274, 138, 2, 1525, 1526,
	5, 26, 14, 2, 1526, 1535, 3, 2, 2, 2, 1527, 1528, 7, 102, 2, 2, 1528, 1530,
	5, 332, 167, 2, 1529, 1531, 5, 274, 138, 2, 1530, 1529, 3, 2, 2, 2, 1530,
	1531, 3, 2, 2, 2, 1531, 1532, 3, 2, 2, 2, 1532, 1533, 5, 26, 14, 2, 1533,
	1535, 3, 2, 2, 2, 1534, 1524, 3, 2, 2, 2, 1534, 1527, 3, 2, 2, 2, 1535,
	273, 3, 2, 2, 2, 1536, 1537, 7, 103, 2, 2, 1537, 1538, 7, 16, 2, 2, 1538,
	1541, 5, 226, 114, 2, 1539, 1540, 7, 3, 2, 2, 1540, 1542, 5, 226, 114,
	2, 1541, 1539, 3, 2, 2, 2, 1541, 1542, 3, 2, 2, 2, 1542, 1543, 3, 2, 2,
	2, 1543, 1544, 7, 17, 2, 2, 1544, 275, 3, 2, 2, 2, 1545, 1546, 7, 104,
	2, 2, 1546, 1547, 5, 26, 14, 2, 1547, 277, 3, 2, 2, 2, 1548, 1550, 7, 105,
	2, 2, 1549, 1551, 5, 108, 55, 2, 1550, 1549, 3, 2, 2, 2, 1550, 1551, 3,
	2, 2, 2, 1551, 1552, 3, 2, 2, 2, 1552, 1553, 7, 11, 2, 2, 1553, 279, 3,
	2, 2, 2, 1554, 1555, 5, 226, 114, 2, 1555, 1556, 7, 23, 2, 2, 1556, 281,
	3, 2, 2, 2, 1557, 1559, 7, 106, 2, 2, 1558, 1560, 5, 226, 114, 2, 1559,
	1558, 3, 2, 2, 2, 1559, 1560, 3, 2, 2, 2, 1560, 1561, 3, 2, 2, 2, 1561,
	1562, 7, 11, 2, 2, 1562, 283, 3, 2, 2, 2, 1563, 1565, 7, 107, 2, 2, 1564,
	1566, 5, 226, 114, 2, 1565, 1564, 3, 2, 2, 2, 1565, 1566, 3, 2, 2, 2, 1566,
	1567, 3, 2, 2, 2, 1567, 1568, 7, 11, 2, 2, 1568, 285, 3, 2, 2, 2, 1569,
	1570, 7, 108, 2, 2, 1570, 1571, 5, 108, 55, 2, 1571, 1572, 7, 11, 2, 2,
	1572, 287, 3, 2, 2, 2, 1573, 1574, 7, 109, 2, 2, 1574, 1575, 5, 108, 55,
	2, 1575, 1576, 7, 11, 2, 2, 1576, 289, 3, 2, 2, 2, 1577, 1578, 5, 292,
	147, 2, 1578, 1579, 7, 11, 2, 2, 1579, 291, 3, 2, 2, 2, 1580, 1581, 7,
	110, 2, 2, 1581, 1582, 7, 16, 2, 2, 1582, 1585, 5, 108, 55, 2, 1583, 1584,
	7, 3, 2, 2, 1584, 1586, 5, 108, 55, 2, 1585, 1583, 3, 2, 2, 2, 1585, 1586,
	3, 2, 2, 2, 1586, 1588, 3, 2, 2, 2, 1587, 1589, 7, 3, 2, 2, 1588, 1587,
	3, 2, 2, 2, 1588, 1589, 3, 2, 2, 2, 1589, 1590, 3, 2, 2, 2, 1590, 1591,
	7, 17, 2, 2, 1591, 293, 3, 2, 2, 2, 1592, 1642, 5, 50, 26, 2, 1593, 1642,
	5, 98, 50, 2, 1594, 1642, 5, 340, 171, 2, 1595, 1597, 7, 28, 2, 2, 1596,
	1595, 3, 2, 2, 2, 1596, 1597, 3, 2, 2, 2, 1597, 1598, 3, 2, 2, 2, 1598,
	1599, 5, 18, 10, 2, 1599, 1600, 7, 11, 2, 2, 1600, 1642, 3, 2, 2, 2, 1601,
	1603, 7, 28, 2, 2, 1602, 1601, 3, 2, 2, 2, 1602, 1603, 3, 2, 2, 2, 1603,
	1604, 3, 2, 2, 2, 1604, 1605, 5, 70, 36, 2, 1605, 1606, 7, 11, 2, 2, 1606,
	1642, 3, 2, 2, 2, 1607, 1609, 7, 28, 2, 2, 1608, 1607, 3, 2, 2, 2, 1608,
	1609, 3, 2, 2, 2, 1609, 1610, 3, 2, 2, 2, 1610, 1611, 5, 72, 37, 2, 1611,
	1612, 7, 11, 2, 2, 1612, 1642, 3, 2, 2, 2, 1613, 1614, 5, 18, 10, 2, 1614,
	1615, 5, 24, 13, 2, 1615, 1642, 3, 2, 2, 2, 1616, 1618, 5, 22, 12, 2, 1617,
	1616, 3, 2, 2, 2, 1617, 1618, 3, 2, 2, 2, 1618, 1619, 3, 2, 2, 2, 1619,
	1620, 7, 34, 2, 2, 1620, 1621, 5, 226, 114, 2, 1621, 1622, 5, 24, 13, 2,
	1622, 1642, 3, 2, 2, 2, 1623, 1625, 5, 22, 12, 2, 1624, 1623, 3, 2, 2,
	2, 1624, 1625, 3, 2, 2, 2, 1625, 1626, 3, 2, 2, 2, 1626, 1627, 7, 35, 2,
	2, 1627, 1628, 5, 226, 114, 2, 1628, 1629, 5, 28, 15, 2, 1629, 1630, 5,
	24, 13, 2, 1630, 1642, 3, 2, 2, 2, 1631, 1633, 9, 3, 2, 2, 1632, 1634,
	5, 332, 167, 2, 1633, 1632, 3, 2, 2, 2, 1633, 1634, 3, 2, 2, 2, 1634, 1635,
	3, 2, 2, 2, 1635, 1636, 5, 60, 31, 2, 1636, 1637, 7, 11, 2, 2, 1637, 1642,
	3, 2, 2, 2, 1638, 1639, 5, 4, 3, 2, 1639, 1640, 7, 11, 2, 2, 1640, 1642,
	3, 2, 2, 2, 1641, 1592, 3, 2, 2, 2, 1641, 1593, 3, 2, 2, 2, 1641, 1594,
	3, 2, 2, 2, 1641, 1596, 3, 2, 2, 2, 1641, 1602, 3, 2, 2, 2, 1641, 1608,
	3, 2, 2, 2, 1641, 1613, 3, 2, 2, 2, 1641, 1617, 3, 2, 2, 2, 1641, 1624,
	3, 2, 2, 2, 1641, 1631, 3, 2, 2, 2, 1641, 1638, 3, 2, 2, 2, 1642, 295,
	3, 2, 2, 2, 1643, 1644, 9, 16, 2, 2, 1644, 297, 3, 2, 2, 2, 1645, 1647,
	5, 300, 151, 2, 1646, 1645, 3, 2, 2, 2, 1646, 1647, 3, 2, 2, 2, 1647, 1649,
	3, 2, 2, 2, 1648, 1650, 5, 302, 152, 2, 1649, 1648, 3, 2, 2, 2, 1649, 1650,
	3, 2, 2, 2, 1650, 1654, 3, 2, 2, 2, 1651, 1653, 5, 304, 153, 2, 1652, 1651,
	3, 2, 2, 2, 1653, 1656, 3, 2, 2, 2, 1654, 1652, 3, 2, 2, 2, 1654, 1655,
	3, 2, 2, 2, 1655, 1660, 3, 2, 2, 2, 1656, 1654, 3, 2, 2, 2, 1657, 1659,
	5, 318, 160, 2, 1658, 1657, 3, 2, 2, 2, 1659, 1662, 3, 2, 2, 2, 1660, 1658,
	3, 2, 2, 2, 1660, 1661, 3, 2, 2, 2, 1661, 1666, 3, 2, 2, 2, 1662, 1660,
	3, 2, 2, 2, 1663, 1665, 5, 294, 148, 2, 1664, 1663, 3, 2, 2, 2, 1665, 1668,
	3, 2, 2, 2, 1666, 1664, 3, 2, 2, 2, 1666, 1667, 3, 2, 2, 2, 1667, 299,
	3, 2, 2, 2, 1668, 1666, 3, 2, 2, 2, 1669, 1673, 7, 111, 2, 2, 1670, 1672,
	10, 17, 2, 2, 1671, 1670, 3, 2, 2, 2, 1672, 1675, 3, 2, 2, 2, 1673, 1671,
	3, 2, 2, 2, 1673, 1674, 3, 2, 2, 2, 1674, 1676, 3, 2, 2, 2, 1675, 1673,
	3, 2, 2, 2, 1676, 1677, 7, 125, 2, 2, 1677, 301, 3, 2, 2, 2, 1678, 1679,
	5, 106, 54, 2, 1679, 1680, 7, 112, 2, 2, 1680, 1681, 5, 306, 154, 2, 1681,
	1682, 7, 11, 2, 2, 1682, 303, 3, 2, 2, 2, 1683, 1686, 5, 308, 155, 2, 1684,
	1686, 5, 316, 159, 2, 1685, 1683, 3, 2, 2, 2, 1685, 1684, 3, 2, 2, 2, 1686,
	305, 3, 2, 2, 2, 1687, 1692, 5, 226, 114, 2, 1688, 1689, 7, 3, 2, 2, 1689,
	1691, 5, 226, 114, 2, 1690, 1688, 3, 2, 2, 2, 1691, 1694, 3, 2, 2, 2, 1692,
	1690, 3, 2, 2, 2, 1692, 1693, 3, 2, 2, 2, 1693, 307, 3, 2, 2, 2, 1694,
	1692, 3, 2, 2, 2, 1695, 1696, 5, 106, 54, 2, 1696, 1697, 5, 310, 156, 2,
	1697, 309, 3, 2, 2, 2, 1698, 1699, 7, 113, 2, 2, 1699, 1702, 5, 326, 164,
	2, 1700, 1701, 7, 90, 2, 2, 1701, 1703, 5, 226, 114, 2, 1702, 1700, 3,
	2, 2, 2, 1702, 1703, 3, 2, 2, 2, 1703, 1707, 3, 2, 2, 2, 1704, 1706, 5,
	312, 157, 2, 1705, 1704, 3, 2, 2, 2, 1706, 1709, 3, 2, 2, 2, 1707, 1705,
	3, 2, 2, 2, 1707, 1708, 3, 2, 2, 2, 1708, 1710, 3, 2, 2, 2, 1709, 1707,
	3, 2, 2, 2, 1710, 1711, 7, 11, 2, 2, 1711, 311, 3, 2, 2, 2, 1712, 1713,
	7, 114, 2, 2, 1713, 1717, 5, 314, 158, 2, 1714, 1715, 7, 115, 2, 2, 1715,
	1717, 5, 314, 158, 2, 1716, 1712, 3, 2, 2, 2, 1716, 1714, 3, 2, 2, 2, 1717,
	313, 3, 2, 2, 2, 1718, 1723, 5, 226, 114, 2, 1719, 1720, 7, 3, 2, 2, 1720,
	1722, 5, 226, 114, 2, 1721, 1719, 3, 2, 2, 2, 1722, 1725, 3, 2, 2, 2, 1723,
	1721, 3, 2, 2, 2, 1723, 1724, 3, 2, 2, 2, 1724, 315, 3, 2, 2, 2, 1725,
	1723, 3, 2, 2, 2, 1726, 1727, 5, 106, 54, 2, 1727, 1728, 7, 116, 2, 2,
	1728, 1732, 5, 326, 164, 2, 1729, 1731, 5, 312, 157, 2, 1730, 1729, 3,
	2, 2, 2, 1731, 1734, 3, 2, 2, 2, 1732, 1730, 3, 2, 2, 2, 1732, 1733, 3,
	2, 2, 2, 1733, 1735, 3, 2, 2, 2, 1734, 1732, 3, 2, 2, 2, 1735, 1736, 7,
	11, 2, 2, 1736, 317, 3, 2, 2, 2, 1737, 1738, 5, 106, 54, 2, 1738, 1739,
	7, 117, 2, 2, 1739, 1740, 5, 324, 163, 2, 1740, 1741, 7, 11, 2, 2, 1741,
	319, 3, 2, 2, 2, 1742, 1743, 5, 106, 54, 2, 1743, 1744, 7, 117, 2, 2, 1744,
	1745, 7, 118, 2, 2, 1745, 1750, 5, 226, 114, 2, 1746, 1747, 7, 22, 2, 2,
	1747, 1749, 5, 226, 114, 2, 1748, 1746, 3, 2, 2, 2, 1749, 1752, 3, 2, 2,
	2, 1750, 1748, 3, 2, 2, 2, 1750, 1751, 3, 2, 2, 2, 1751, 1753, 3, 2, 2,
	2, 1752, 1750, 3, 2, 2, 2, 1753, 1754, 7, 11, 2, 2, 1754, 321, 3, 2, 2,
	2, 1755, 1759, 5, 320, 161, 2, 1756, 1758, 5, 294, 148, 2, 1757, 1756,
	3, 2, 2, 2, 1758, 1761, 3, 2, 2, 2, 1759, 1757, 3, 2, 2, 2, 1759, 1760,
	3, 2, 2, 2, 1760, 1762, 3, 2, 2, 2, 1761, 1759, 3, 2, 2, 2, 1762, 1763,
	7, 2, 2, 3, 1763, 323, 3, 2, 2, 2, 1764, 1765, 5, 124, 63, 2, 1765, 325,
	3, 2, 2, 2, 1766, 1770, 5, 324, 163, 2, 1767, 1769, 5, 328, 165, 2, 1768,
	1767, 3, 2, 2, 2, 1769, 1772, 3, 2, 2, 2, 1770, 1768, 3, 2, 2, 2, 1770,
	1771, 3, 2, 2, 2, 1771, 327, 3, 2, 2, 2, 1772, 1770, 3, 2, 2, 2, 1773,
	1774, 7, 91, 2, 2, 1774, 1775, 7, 16, 2, 2, 1775, 1776, 5, 330, 166, 2,
	1776, 1777, 7, 17, 2, 2, 1777, 1778, 5, 324, 163, 2, 1778, 329, 3, 2, 2,
	2, 1779, 1782, 5, 306, 154, 2, 1780, 1781, 7, 33, 2, 2, 1781, 1783, 5,
	124, 63, 2, 1782, 1780, 3, 2, 2, 2, 1782, 1783, 3, 2, 2, 2, 1783, 331,
	3, 2, 2, 2, 1784, 1786, 5, 334, 168, 2, 1785, 1787, 5, 336, 169, 2, 1786,
	1785, 3, 2, 2, 2, 1786, 1787, 3, 2, 2, 2, 1787, 333, 3, 2, 2, 2, 1788,
	1791, 5, 228, 115, 2, 1789, 1791, 7, 8, 2, 2, 1790, 1788, 3, 2, 2, 2, 1790,
	1789, 3, 2, 2, 2, 1791, 335, 3, 2, 2, 2, 1792, 1793, 7, 41, 2, 2, 1793,
	1794, 5, 338, 170, 2, 1794, 1795, 7, 42, 2, 2, 1795, 337, 3, 2, 2, 2, 1796,
	1801, 5, 332, 167, 2, 1797, 1798, 7, 3, 2, 2, 1798, 1800, 5, 332, 167,
	2, 1799, 1797, 3, 2, 2, 2, 1800, 1803, 3, 2, 2, 2, 1801, 1799, 3, 2, 2,
	2, 1801, 1802, 3, 2, 2, 2, 1802, 339, 3, 2, 2, 2, 1803, 1801, 3, 2, 2,
	2, 1804, 1805, 5, 106, 54, 2, 1805, 1806, 7, 119, 2, 2, 1806, 1807, 5,
	342, 172, 2, 1807, 341, 3, 2, 2, 2, 1808, 1809, 5, 344, 173, 2, 1809, 343,
	3, 2, 2, 2, 1810, 1812, 5, 346, 174, 2, 1811, 1813, 5, 104, 53, 2, 1812,
	1811, 3, 2, 2, 2, 1812, 1813, 3, 2, 2, 2, 1813, 1814, 3, 2, 2, 2, 1814,
	1815, 5, 28, 15, 2, 1815, 1816, 7, 11, 2, 2, 1816, 345, 3, 2, 2, 2, 1817,
	1819, 5, 22, 12, 2, 1818, 1817, 3, 2, 2, 2, 1818, 1819, 3, 2, 2, 2, 1819,
	1820, 3, 2, 2, 2, 1820, 1821, 5, 226, 114, 2, 1821, 347, 3, 2, 2, 2, 217,
	350, 357, 366, 370, 373, 377, 382, 388, 394, 401, 406, 412, 418, 421, 428,
	431, 447, 455, 462, 467, 475, 479, 489, 493, 500, 504, 507, 515, 519, 523,
	529, 534, 539, 544, 546, 550, 555, 558, 561, 564, 572, 579, 584, 595, 599,
	603, 607, 611, 615, 620, 625, 633, 635, 640, 642, 646, 651, 653, 659, 664,
	668, 672, 675, 682, 690, 700, 708, 711, 717, 726, 734, 744, 756, 760, 768,
	775, 780, 786, 793, 807, 816, 827, 831, 842, 850, 859, 862, 866, 877, 881,
	889, 896, 911, 920, 931, 939, 948, 951, 954, 957, 962, 964, 969, 972, 980,
	984, 986, 1009, 1017, 1024, 1026, 1035, 1043, 1046, 1056, 1063, 1068, 1074,
	1081, 1084, 1090, 1100, 1107, 1115, 1123, 1130, 1136, 1146, 1152, 1161,
	1169, 1171, 1178, 1186, 1188, 1195, 1203, 1205, 1215, 1224, 1226, 1236,
	1245, 1247, 1257, 1266, 1268, 1279, 1286, 1291, 1309, 1312, 1318, 1326,
	1330, 1336, 1344, 1349, 1356, 1363, 1373, 1379, 1401, 1404, 1421, 1424,
	1434, 1438, 1448, 1452, 1455, 1479, 1483, 1490, 1501, 1516, 1519, 1522,
	1530, 1534, 1541, 1550, 1559, 1565, 1585, 1588, 1596, 1602, 1608, 1617,
	1624, 1633, 1641, 1646, 1649, 1654, 1660, 1666, 1673, 1685, 1692, 1702,
	1707, 1716, 1723, 1732, 1750, 1759, 1770, 1782, 1786, 1790, 1801, 1812,
	1818,
}
var literalNames = []string{
	"", "','", "'final'", "'const'", "'var'", "'='", "'void'", "'async'", "'=>'",
	"';'", "'async*'", "'sync*'", "'{'", "'}'", "'('", "')'", "'['", "']'",
	"'covariant'", "'this'", "'.'", "':'", "'abstract'", "'class'", "'with'",
	"'static'", "'external'", "'operator'", "'~'", "'[]'", "'[]='", "'=='",
	"'get'", "'set'", "'super'", "'factory'", "'extends'", "'implements'",
	"'enum'", "'<'", "'>'", "'@'", "'null'", "'true'", "'false'", "'$'", "'${'",
	"'#'", "'throw'", "'new'", "'..'", "'*='", "'/='", "'~/='", "'%='", "'+='",
	"'<<='", "'>>='", "'>>>='", "'&='", "'^='", "'|='", "'??='", "'?'", "'??'",
	"'||'", "'&&'", "'!='", "'>='", "'<='", "'|'", "'^'", "'&'", "'<<'", "'>>'",
	"'>>>'", "'+'", "'-'", "'*'", "'/'", "'%'", "'~/'", "'!'", "'await'", "'++'",
	"'--'", "'?.'", "'is'", "'as'", "'if'", "'else'", "'for'", "'in'", "'while'",
	"'do'", "'switch'", "'case'", "'default'", "'rethrow'", "'try'", "'on'",
	"'catch'", "'finally'", "'return'", "'break'", "'continue'", "'yield'",
	"'yield*'", "'assert'", "'#!'", "'library'", "'import'", "'show'", "'hide'",
	"'export'", "'part'", "'of'", "'typedef'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "WHITESPACE", "NUMBER", "HEX_NUMBER",
	"SingleLineString", "MultiLineString", "NEWLINE", "IDENTIFIER", "SINGLE_LINE_COMMENT",
	"MULTI_LINE_COMMENT",
}

var ruleNames = []string{
	"compilationUnit", "variableDeclaration", "declaredIdentifier", "finalConstVarOrType",
	"varOrType", "initializedVariableDeclaration", "initializedIdentifier",
	"initializedIdentifierList", "functionSignature", "formalParameterPart",
	"returnType", "functionBody", "block", "formalParameterList", "normalFormalParameters",
	"optionalFormalParameters", "optionalPositionalFormalParameters", "namedFormalParameters",
	"normalFormalParameter", "functionFormalParameter", "simpleFormalParameter",
	"fieldFormalParameter", "defaultFormalParameter", "defaultNamedParameter",
	"classDefinition", "mixins", "classMemberDefinition", "methodSignature",
	"declaration", "staticFinalDeclarationList", "staticFinalDeclaration",
	"operatorSignature", "operator_", "binaryOperator", "getterSignature",
	"setterSignature", "constructorSignature", "redirection", "initializers",
	"initializerListEntry", "fieldInitializer", "factoryConstructorSignature",
	"redirectingFactoryConstructorSignature", "constantConstructorSignature",
	"superclass", "interfaces", "mixinApplicationClass", "mixinApplication",
	"enumType", "enumEntry", "typeParameter", "typeParameters", "metadata",
	"expression", "expressionWithoutCascade", "expressionList", "primary",
	"literal", "nullLiteral", "numericLiteral", "booleanLiteral", "stringLiteral",
	"stringInterpolation", "symbolLiteral", "listLiteral", "mapLiteral", "mapLiteralEntry",
	"throwExpression", "throwExpressionWithoutCascade", "functionExpression",
	"thisExpression", "nayaExpression", "constObjectExpression", "arguments",
	"argumentList", "namedArgument", "cascadeSection", "cascadeSelector", "argumentPart",
	"assignmentOperator", "compoundAssignmentOperator", "conditionalExpression",
	"ifNullExpression", "logicalOrExpression", "logicalAndExpression", "equalityExpression",
	"equalityOperator", "relationalExpression", "relationalOperator", "bitwiseOrExpression",
	"bitwiseXorExpression", "bitwiseAndExpression", "bitwiseOperator", "shiftExpression",
	"shiftOperator", "additiveExpression", "additiveOperator", "multiplicativeExpression",
	"multiplicativeOperator", "unaryExpression", "prefixOperator", "minusOperator",
	"negationOperator", "tildeOperator", "awaitExpression", "postfixExpression",
	"postfixOperator", "selector", "incrementOperator", "assignableExpression",
	"unconditionalAssignableSelector", "assignableSelector", "identifier",
	"qualified", "typeTest", "isOperator", "typeCast", "asOperator", "statements",
	"statement", "nonLabledStatment", "expressionStatement", "localVariableDeclaration",
	"localFunctionDeclaration", "ifStatement", "forStatement", "forLoopParts",
	"forInitializerStatement", "whileStatement", "doStatement", "switchStatement",
	"switchCase", "defaultCase", "rethrowStatment", "tryStatement", "onPart",
	"catchPart", "finallyPart", "returnStatement", "label", "breakStatement",
	"continueStatement", "yieldStatement", "yieldEachStatement", "assertStatement",
	"assertion", "topLevelDefinition", "getOrSet", "libraryDefinition", "scriptTag",
	"libraryName", "importOrExport", "dottedIdentifierList", "libraryimport",
	"importSpecification", "combinator", "identifierList", "libraryExport",
	"partDirective", "partHeader", "partDeclaration", "uri", "configurableUri",
	"configurationUri", "uriTest", "dtype", "typeName", "typeArguments", "typeList",
	"typeAlias", "typeAliasBody", "functionTypeAlias", "functionPrefix",
}

type Dart2Parser struct {
	*antlr.BaseParser
}

// NewDart2Parser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *Dart2Parser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewDart2Parser(input antlr.TokenStream) *Dart2Parser {
	this := new(Dart2Parser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Dart2.g4"

	return this
}

// Dart2Parser tokens.
const (
	Dart2ParserEOF                 = antlr.TokenEOF
	Dart2ParserT__0                = 1
	Dart2ParserT__1                = 2
	Dart2ParserT__2                = 3
	Dart2ParserT__3                = 4
	Dart2ParserT__4                = 5
	Dart2ParserT__5                = 6
	Dart2ParserT__6                = 7
	Dart2ParserT__7                = 8
	Dart2ParserT__8                = 9
	Dart2ParserT__9                = 10
	Dart2ParserT__10               = 11
	Dart2ParserT__11               = 12
	Dart2ParserT__12               = 13
	Dart2ParserT__13               = 14
	Dart2ParserT__14               = 15
	Dart2ParserT__15               = 16
	Dart2ParserT__16               = 17
	Dart2ParserT__17               = 18
	Dart2ParserT__18               = 19
	Dart2ParserT__19               = 20
	Dart2ParserT__20               = 21
	Dart2ParserT__21               = 22
	Dart2ParserT__22               = 23
	Dart2ParserT__23               = 24
	Dart2ParserT__24               = 25
	Dart2ParserT__25               = 26
	Dart2ParserT__26               = 27
	Dart2ParserT__27               = 28
	Dart2ParserT__28               = 29
	Dart2ParserT__29               = 30
	Dart2ParserT__30               = 31
	Dart2ParserT__31               = 32
	Dart2ParserT__32               = 33
	Dart2ParserT__33               = 34
	Dart2ParserT__34               = 35
	Dart2ParserT__35               = 36
	Dart2ParserT__36               = 37
	Dart2ParserT__37               = 38
	Dart2ParserT__38               = 39
	Dart2ParserT__39               = 40
	Dart2ParserT__40               = 41
	Dart2ParserT__41               = 42
	Dart2ParserT__42               = 43
	Dart2ParserT__43               = 44
	Dart2ParserT__44               = 45
	Dart2ParserT__45               = 46
	Dart2ParserT__46               = 47
	Dart2ParserT__47               = 48
	Dart2ParserT__48               = 49
	Dart2ParserT__49               = 50
	Dart2ParserT__50               = 51
	Dart2ParserT__51               = 52
	Dart2ParserT__52               = 53
	Dart2ParserT__53               = 54
	Dart2ParserT__54               = 55
	Dart2ParserT__55               = 56
	Dart2ParserT__56               = 57
	Dart2ParserT__57               = 58
	Dart2ParserT__58               = 59
	Dart2ParserT__59               = 60
	Dart2ParserT__60               = 61
	Dart2ParserT__61               = 62
	Dart2ParserT__62               = 63
	Dart2ParserT__63               = 64
	Dart2ParserT__64               = 65
	Dart2ParserT__65               = 66
	Dart2ParserT__66               = 67
	Dart2ParserT__67               = 68
	Dart2ParserT__68               = 69
	Dart2ParserT__69               = 70
	Dart2ParserT__70               = 71
	Dart2ParserT__71               = 72
	Dart2ParserT__72               = 73
	Dart2ParserT__73               = 74
	Dart2ParserT__74               = 75
	Dart2ParserT__75               = 76
	Dart2ParserT__76               = 77
	Dart2ParserT__77               = 78
	Dart2ParserT__78               = 79
	Dart2ParserT__79               = 80
	Dart2ParserT__80               = 81
	Dart2ParserT__81               = 82
	Dart2ParserT__82               = 83
	Dart2ParserT__83               = 84
	Dart2ParserT__84               = 85
	Dart2ParserT__85               = 86
	Dart2ParserT__86               = 87
	Dart2ParserT__87               = 88
	Dart2ParserT__88               = 89
	Dart2ParserT__89               = 90
	Dart2ParserT__90               = 91
	Dart2ParserT__91               = 92
	Dart2ParserT__92               = 93
	Dart2ParserT__93               = 94
	Dart2ParserT__94               = 95
	Dart2ParserT__95               = 96
	Dart2ParserT__96               = 97
	Dart2ParserT__97               = 98
	Dart2ParserT__98               = 99
	Dart2ParserT__99               = 100
	Dart2ParserT__100              = 101
	Dart2ParserT__101              = 102
	Dart2ParserT__102              = 103
	Dart2ParserT__103              = 104
	Dart2ParserT__104              = 105
	Dart2ParserT__105              = 106
	Dart2ParserT__106              = 107
	Dart2ParserT__107              = 108
	Dart2ParserT__108              = 109
	Dart2ParserT__109              = 110
	Dart2ParserT__110              = 111
	Dart2ParserT__111              = 112
	Dart2ParserT__112              = 113
	Dart2ParserT__113              = 114
	Dart2ParserT__114              = 115
	Dart2ParserT__115              = 116
	Dart2ParserT__116              = 117
	Dart2ParserWHITESPACE          = 118
	Dart2ParserNUMBER              = 119
	Dart2ParserHEX_NUMBER          = 120
	Dart2ParserSingleLineString    = 121
	Dart2ParserMultiLineString     = 122
	Dart2ParserNEWLINE             = 123
	Dart2ParserIDENTIFIER          = 124
	Dart2ParserSINGLE_LINE_COMMENT = 125
	Dart2ParserMULTI_LINE_COMMENT  = 126
)

// Dart2Parser rules.
const (
	Dart2ParserRULE_compilationUnit                        = 0
	Dart2ParserRULE_variableDeclaration                    = 1
	Dart2ParserRULE_declaredIdentifier                     = 2
	Dart2ParserRULE_finalConstVarOrType                    = 3
	Dart2ParserRULE_varOrType                              = 4
	Dart2ParserRULE_initializedVariableDeclaration         = 5
	Dart2ParserRULE_initializedIdentifier                  = 6
	Dart2ParserRULE_initializedIdentifierList              = 7
	Dart2ParserRULE_functionSignature                      = 8
	Dart2ParserRULE_formalParameterPart                    = 9
	Dart2ParserRULE_returnType                             = 10
	Dart2ParserRULE_functionBody                           = 11
	Dart2ParserRULE_block                                  = 12
	Dart2ParserRULE_formalParameterList                    = 13
	Dart2ParserRULE_normalFormalParameters                 = 14
	Dart2ParserRULE_optionalFormalParameters               = 15
	Dart2ParserRULE_optionalPositionalFormalParameters     = 16
	Dart2ParserRULE_namedFormalParameters                  = 17
	Dart2ParserRULE_normalFormalParameter                  = 18
	Dart2ParserRULE_functionFormalParameter                = 19
	Dart2ParserRULE_simpleFormalParameter                  = 20
	Dart2ParserRULE_fieldFormalParameter                   = 21
	Dart2ParserRULE_defaultFormalParameter                 = 22
	Dart2ParserRULE_defaultNamedParameter                  = 23
	Dart2ParserRULE_classDefinition                        = 24
	Dart2ParserRULE_mixins                                 = 25
	Dart2ParserRULE_classMemberDefinition                  = 26
	Dart2ParserRULE_methodSignature                        = 27
	Dart2ParserRULE_declaration                            = 28
	Dart2ParserRULE_staticFinalDeclarationList             = 29
	Dart2ParserRULE_staticFinalDeclaration                 = 30
	Dart2ParserRULE_operatorSignature                      = 31
	Dart2ParserRULE_operator_                              = 32
	Dart2ParserRULE_binaryOperator                         = 33
	Dart2ParserRULE_getterSignature                        = 34
	Dart2ParserRULE_setterSignature                        = 35
	Dart2ParserRULE_constructorSignature                   = 36
	Dart2ParserRULE_redirection                            = 37
	Dart2ParserRULE_initializers                           = 38
	Dart2ParserRULE_initializerListEntry                   = 39
	Dart2ParserRULE_fieldInitializer                       = 40
	Dart2ParserRULE_factoryConstructorSignature            = 41
	Dart2ParserRULE_redirectingFactoryConstructorSignature = 42
	Dart2ParserRULE_constantConstructorSignature           = 43
	Dart2ParserRULE_superclass                             = 44
	Dart2ParserRULE_interfaces                             = 45
	Dart2ParserRULE_mixinApplicationClass                  = 46
	Dart2ParserRULE_mixinApplication                       = 47
	Dart2ParserRULE_enumType                               = 48
	Dart2ParserRULE_enumEntry                              = 49
	Dart2ParserRULE_typeParameter                          = 50
	Dart2ParserRULE_typeParameters                         = 51
	Dart2ParserRULE_metadata                               = 52
	Dart2ParserRULE_expression                             = 53
	Dart2ParserRULE_expressionWithoutCascade               = 54
	Dart2ParserRULE_expressionList                         = 55
	Dart2ParserRULE_primary                                = 56
	Dart2ParserRULE_literal                                = 57
	Dart2ParserRULE_nullLiteral                            = 58
	Dart2ParserRULE_numericLiteral                         = 59
	Dart2ParserRULE_booleanLiteral                         = 60
	Dart2ParserRULE_stringLiteral                          = 61
	Dart2ParserRULE_stringInterpolation                    = 62
	Dart2ParserRULE_symbolLiteral                          = 63
	Dart2ParserRULE_listLiteral                            = 64
	Dart2ParserRULE_mapLiteral                             = 65
	Dart2ParserRULE_mapLiteralEntry                        = 66
	Dart2ParserRULE_throwExpression                        = 67
	Dart2ParserRULE_throwExpressionWithoutCascade          = 68
	Dart2ParserRULE_functionExpression                     = 69
	Dart2ParserRULE_thisExpression                         = 70
	Dart2ParserRULE_nayaExpression                         = 71
	Dart2ParserRULE_constObjectExpression                  = 72
	Dart2ParserRULE_arguments                              = 73
	Dart2ParserRULE_argumentList                           = 74
	Dart2ParserRULE_namedArgument                          = 75
	Dart2ParserRULE_cascadeSection                         = 76
	Dart2ParserRULE_cascadeSelector                        = 77
	Dart2ParserRULE_argumentPart                           = 78
	Dart2ParserRULE_assignmentOperator                     = 79
	Dart2ParserRULE_compoundAssignmentOperator             = 80
	Dart2ParserRULE_conditionalExpression                  = 81
	Dart2ParserRULE_ifNullExpression                       = 82
	Dart2ParserRULE_logicalOrExpression                    = 83
	Dart2ParserRULE_logicalAndExpression                   = 84
	Dart2ParserRULE_equalityExpression                     = 85
	Dart2ParserRULE_equalityOperator                       = 86
	Dart2ParserRULE_relationalExpression                   = 87
	Dart2ParserRULE_relationalOperator                     = 88
	Dart2ParserRULE_bitwiseOrExpression                    = 89
	Dart2ParserRULE_bitwiseXorExpression                   = 90
	Dart2ParserRULE_bitwiseAndExpression                   = 91
	Dart2ParserRULE_bitwiseOperator                        = 92
	Dart2ParserRULE_shiftExpression                        = 93
	Dart2ParserRULE_shiftOperator                          = 94
	Dart2ParserRULE_additiveExpression                     = 95
	Dart2ParserRULE_additiveOperator                       = 96
	Dart2ParserRULE_multiplicativeExpression               = 97
	Dart2ParserRULE_multiplicativeOperator                 = 98
	Dart2ParserRULE_unaryExpression                        = 99
	Dart2ParserRULE_prefixOperator                         = 100
	Dart2ParserRULE_minusOperator                          = 101
	Dart2ParserRULE_negationOperator                       = 102
	Dart2ParserRULE_tildeOperator                          = 103
	Dart2ParserRULE_awaitExpression                        = 104
	Dart2ParserRULE_postfixExpression                      = 105
	Dart2ParserRULE_postfixOperator                        = 106
	Dart2ParserRULE_selector                               = 107
	Dart2ParserRULE_incrementOperator                      = 108
	Dart2ParserRULE_assignableExpression                   = 109
	Dart2ParserRULE_unconditionalAssignableSelector        = 110
	Dart2ParserRULE_assignableSelector                     = 111
	Dart2ParserRULE_identifier                             = 112
	Dart2ParserRULE_qualified                              = 113
	Dart2ParserRULE_typeTest                               = 114
	Dart2ParserRULE_isOperator                             = 115
	Dart2ParserRULE_typeCast                               = 116
	Dart2ParserRULE_asOperator                             = 117
	Dart2ParserRULE_statements                             = 118
	Dart2ParserRULE_statement                              = 119
	Dart2ParserRULE_nonLabledStatment                      = 120
	Dart2ParserRULE_expressionStatement                    = 121
	Dart2ParserRULE_localVariableDeclaration               = 122
	Dart2ParserRULE_localFunctionDeclaration               = 123
	Dart2ParserRULE_ifStatement                            = 124
	Dart2ParserRULE_forStatement                           = 125
	Dart2ParserRULE_forLoopParts                           = 126
	Dart2ParserRULE_forInitializerStatement                = 127
	Dart2ParserRULE_whileStatement                         = 128
	Dart2ParserRULE_doStatement                            = 129
	Dart2ParserRULE_switchStatement                        = 130
	Dart2ParserRULE_switchCase                             = 131
	Dart2ParserRULE_defaultCase                            = 132
	Dart2ParserRULE_rethrowStatment                        = 133
	Dart2ParserRULE_tryStatement                           = 134
	Dart2ParserRULE_onPart                                 = 135
	Dart2ParserRULE_catchPart                              = 136
	Dart2ParserRULE_finallyPart                            = 137
	Dart2ParserRULE_returnStatement                        = 138
	Dart2ParserRULE_label                                  = 139
	Dart2ParserRULE_breakStatement                         = 140
	Dart2ParserRULE_continueStatement                      = 141
	Dart2ParserRULE_yieldStatement                         = 142
	Dart2ParserRULE_yieldEachStatement                     = 143
	Dart2ParserRULE_assertStatement                        = 144
	Dart2ParserRULE_assertion                              = 145
	Dart2ParserRULE_topLevelDefinition                     = 146
	Dart2ParserRULE_getOrSet                               = 147
	Dart2ParserRULE_libraryDefinition                      = 148
	Dart2ParserRULE_scriptTag                              = 149
	Dart2ParserRULE_libraryName                            = 150
	Dart2ParserRULE_importOrExport                         = 151
	Dart2ParserRULE_dottedIdentifierList                   = 152
	Dart2ParserRULE_libraryimport                          = 153
	Dart2ParserRULE_importSpecification                    = 154
	Dart2ParserRULE_combinator                             = 155
	Dart2ParserRULE_identifierList                         = 156
	Dart2ParserRULE_libraryExport                          = 157
	Dart2ParserRULE_partDirective                          = 158
	Dart2ParserRULE_partHeader                             = 159
	Dart2ParserRULE_partDeclaration                        = 160
	Dart2ParserRULE_uri                                    = 161
	Dart2ParserRULE_configurableUri                        = 162
	Dart2ParserRULE_configurationUri                       = 163
	Dart2ParserRULE_uriTest                                = 164
	Dart2ParserRULE_dtype                                  = 165
	Dart2ParserRULE_typeName                               = 166
	Dart2ParserRULE_typeArguments                          = 167
	Dart2ParserRULE_typeList                               = 168
	Dart2ParserRULE_typeAlias                              = 169
	Dart2ParserRULE_typeAliasBody                          = 170
	Dart2ParserRULE_functionTypeAlias                      = 171
	Dart2ParserRULE_functionPrefix                         = 172
)

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_compilationUnit
	return p
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) LibraryDefinition() ILibraryDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryDefinitionContext)
}

func (s *CompilationUnitContext) PartDeclaration() IPartDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartDeclarationContext)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitCompilationUnit(s)
	}
}

func (p *Dart2Parser) CompilationUnit() (localctx ICompilationUnitContext) {
	this := p
	_ = this

	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Dart2ParserRULE_compilationUnit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(348)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(346)
			p.LibraryDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(347)
			p.PartDeclaration()
		}

	}

	return localctx
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_variableDeclaration
	return p
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) DeclaredIdentifier() IDeclaredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaredIdentifierContext)
}

func (s *VariableDeclarationContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *VariableDeclarationContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (p *Dart2Parser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Dart2ParserRULE_variableDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(350)
		p.DeclaredIdentifier()
	}
	p.SetState(355)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__0 {
		{
			p.SetState(351)
			p.Match(Dart2ParserT__0)
		}
		{
			p.SetState(352)
			p.Identifier()
		}

		p.SetState(357)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDeclaredIdentifierContext is an interface to support dynamic dispatch.
type IDeclaredIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaredIdentifierContext differentiates from other interfaces.
	IsDeclaredIdentifierContext()
}

type DeclaredIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaredIdentifierContext() *DeclaredIdentifierContext {
	var p = new(DeclaredIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_declaredIdentifier
	return p
}

func (*DeclaredIdentifierContext) IsDeclaredIdentifierContext() {}

func NewDeclaredIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaredIdentifierContext {
	var p = new(DeclaredIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_declaredIdentifier

	return p
}

func (s *DeclaredIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaredIdentifierContext) Metadata() IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *DeclaredIdentifierContext) FinalConstVarOrType() IFinalConstVarOrTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinalConstVarOrTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinalConstVarOrTypeContext)
}

func (s *DeclaredIdentifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DeclaredIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaredIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaredIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterDeclaredIdentifier(s)
	}
}

func (s *DeclaredIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitDeclaredIdentifier(s)
	}
}

func (p *Dart2Parser) DeclaredIdentifier() (localctx IDeclaredIdentifierContext) {
	this := p
	_ = this

	localctx = NewDeclaredIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Dart2ParserRULE_declaredIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(358)
		p.Metadata()
	}
	{
		p.SetState(359)
		p.FinalConstVarOrType()
	}
	{
		p.SetState(360)
		p.Identifier()
	}

	return localctx
}

// IFinalConstVarOrTypeContext is an interface to support dynamic dispatch.
type IFinalConstVarOrTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinalConstVarOrTypeContext differentiates from other interfaces.
	IsFinalConstVarOrTypeContext()
}

type FinalConstVarOrTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinalConstVarOrTypeContext() *FinalConstVarOrTypeContext {
	var p = new(FinalConstVarOrTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_finalConstVarOrType
	return p
}

func (*FinalConstVarOrTypeContext) IsFinalConstVarOrTypeContext() {}

func NewFinalConstVarOrTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinalConstVarOrTypeContext {
	var p = new(FinalConstVarOrTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_finalConstVarOrType

	return p
}

func (s *FinalConstVarOrTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FinalConstVarOrTypeContext) Dtype() IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *FinalConstVarOrTypeContext) VarOrType() IVarOrTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarOrTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarOrTypeContext)
}

func (s *FinalConstVarOrTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinalConstVarOrTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinalConstVarOrTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterFinalConstVarOrType(s)
	}
}

func (s *FinalConstVarOrTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitFinalConstVarOrType(s)
	}
}

func (p *Dart2Parser) FinalConstVarOrType() (localctx IFinalConstVarOrTypeContext) {
	this := p
	_ = this

	localctx = NewFinalConstVarOrTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Dart2ParserRULE_finalConstVarOrType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(371)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(362)
			p.Match(Dart2ParserT__1)
		}
		p.SetState(364)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(363)
				p.Dtype()
			}

		}

	case Dart2ParserT__2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(366)
			p.Match(Dart2ParserT__2)
		}
		p.SetState(368)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(367)
				p.Dtype()
			}

		}

	case Dart2ParserT__3, Dart2ParserT__5, Dart2ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(370)
			p.VarOrType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVarOrTypeContext is an interface to support dynamic dispatch.
type IVarOrTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarOrTypeContext differentiates from other interfaces.
	IsVarOrTypeContext()
}

type VarOrTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarOrTypeContext() *VarOrTypeContext {
	var p = new(VarOrTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_varOrType
	return p
}

func (*VarOrTypeContext) IsVarOrTypeContext() {}

func NewVarOrTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarOrTypeContext {
	var p = new(VarOrTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_varOrType

	return p
}

func (s *VarOrTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *VarOrTypeContext) Dtype() IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *VarOrTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarOrTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarOrTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterVarOrType(s)
	}
}

func (s *VarOrTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitVarOrType(s)
	}
}

func (p *Dart2Parser) VarOrType() (localctx IVarOrTypeContext) {
	this := p
	_ = this

	localctx = NewVarOrTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Dart2ParserRULE_varOrType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(375)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__3:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(373)
			p.Match(Dart2ParserT__3)
		}

	case Dart2ParserT__5, Dart2ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(374)
			p.Dtype()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInitializedVariableDeclarationContext is an interface to support dynamic dispatch.
type IInitializedVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializedVariableDeclarationContext differentiates from other interfaces.
	IsInitializedVariableDeclarationContext()
}

type InitializedVariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializedVariableDeclarationContext() *InitializedVariableDeclarationContext {
	var p = new(InitializedVariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_initializedVariableDeclaration
	return p
}

func (*InitializedVariableDeclarationContext) IsInitializedVariableDeclarationContext() {}

func NewInitializedVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializedVariableDeclarationContext {
	var p = new(InitializedVariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_initializedVariableDeclaration

	return p
}

func (s *InitializedVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializedVariableDeclarationContext) DeclaredIdentifier() IDeclaredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaredIdentifierContext)
}

func (s *InitializedVariableDeclarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InitializedVariableDeclarationContext) AllInitializedIdentifier() []IInitializedIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInitializedIdentifierContext)(nil)).Elem())
	var tst = make([]IInitializedIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInitializedIdentifierContext)
		}
	}

	return tst
}

func (s *InitializedVariableDeclarationContext) InitializedIdentifier(i int) IInitializedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializedIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInitializedIdentifierContext)
}

func (s *InitializedVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializedVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializedVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterInitializedVariableDeclaration(s)
	}
}

func (s *InitializedVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitInitializedVariableDeclaration(s)
	}
}

func (p *Dart2Parser) InitializedVariableDeclaration() (localctx IInitializedVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewInitializedVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Dart2ParserRULE_initializedVariableDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(377)
		p.DeclaredIdentifier()
	}
	p.SetState(380)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__4 {
		{
			p.SetState(378)
			p.Match(Dart2ParserT__4)
		}
		{
			p.SetState(379)
			p.Expression()
		}

	}
	p.SetState(386)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__0 {
		{
			p.SetState(382)
			p.Match(Dart2ParserT__0)
		}
		{
			p.SetState(383)
			p.InitializedIdentifier()
		}

		p.SetState(388)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInitializedIdentifierContext is an interface to support dynamic dispatch.
type IInitializedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializedIdentifierContext differentiates from other interfaces.
	IsInitializedIdentifierContext()
}

type InitializedIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializedIdentifierContext() *InitializedIdentifierContext {
	var p = new(InitializedIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_initializedIdentifier
	return p
}

func (*InitializedIdentifierContext) IsInitializedIdentifierContext() {}

func NewInitializedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializedIdentifierContext {
	var p = new(InitializedIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_initializedIdentifier

	return p
}

func (s *InitializedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializedIdentifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InitializedIdentifierContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InitializedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterInitializedIdentifier(s)
	}
}

func (s *InitializedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitInitializedIdentifier(s)
	}
}

func (p *Dart2Parser) InitializedIdentifier() (localctx IInitializedIdentifierContext) {
	this := p
	_ = this

	localctx = NewInitializedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Dart2ParserRULE_initializedIdentifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.Identifier()
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__4 {
		{
			p.SetState(390)
			p.Match(Dart2ParserT__4)
		}
		{
			p.SetState(391)
			p.Expression()
		}

	}

	return localctx
}

// IInitializedIdentifierListContext is an interface to support dynamic dispatch.
type IInitializedIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializedIdentifierListContext differentiates from other interfaces.
	IsInitializedIdentifierListContext()
}

type InitializedIdentifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializedIdentifierListContext() *InitializedIdentifierListContext {
	var p = new(InitializedIdentifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_initializedIdentifierList
	return p
}

func (*InitializedIdentifierListContext) IsInitializedIdentifierListContext() {}

func NewInitializedIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializedIdentifierListContext {
	var p = new(InitializedIdentifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_initializedIdentifierList

	return p
}

func (s *InitializedIdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializedIdentifierListContext) AllInitializedIdentifier() []IInitializedIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInitializedIdentifierContext)(nil)).Elem())
	var tst = make([]IInitializedIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInitializedIdentifierContext)
		}
	}

	return tst
}

func (s *InitializedIdentifierListContext) InitializedIdentifier(i int) IInitializedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializedIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInitializedIdentifierContext)
}

func (s *InitializedIdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializedIdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializedIdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterInitializedIdentifierList(s)
	}
}

func (s *InitializedIdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitInitializedIdentifierList(s)
	}
}

func (p *Dart2Parser) InitializedIdentifierList() (localctx IInitializedIdentifierListContext) {
	this := p
	_ = this

	localctx = NewInitializedIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Dart2ParserRULE_initializedIdentifierList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(394)
		p.InitializedIdentifier()
	}
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__0 {
		{
			p.SetState(395)
			p.Match(Dart2ParserT__0)
		}
		{
			p.SetState(396)
			p.InitializedIdentifier()
		}

		p.SetState(401)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFunctionSignatureContext is an interface to support dynamic dispatch.
type IFunctionSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionSignatureContext differentiates from other interfaces.
	IsFunctionSignatureContext()
}

type FunctionSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionSignatureContext() *FunctionSignatureContext {
	var p = new(FunctionSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_functionSignature
	return p
}

func (*FunctionSignatureContext) IsFunctionSignatureContext() {}

func NewFunctionSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionSignatureContext {
	var p = new(FunctionSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_functionSignature

	return p
}

func (s *FunctionSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionSignatureContext) Metadata() IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *FunctionSignatureContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionSignatureContext) FormalParameterPart() IFormalParameterPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterPartContext)
}

func (s *FunctionSignatureContext) ReturnType() IReturnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *FunctionSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterFunctionSignature(s)
	}
}

func (s *FunctionSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitFunctionSignature(s)
	}
}

func (p *Dart2Parser) FunctionSignature() (localctx IFunctionSignatureContext) {
	this := p
	_ = this

	localctx = NewFunctionSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Dart2ParserRULE_functionSignature)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(402)
		p.Metadata()
	}
	p.SetState(404)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(403)
			p.ReturnType()
		}

	}
	{
		p.SetState(406)
		p.Identifier()
	}
	{
		p.SetState(407)
		p.FormalParameterPart()
	}

	return localctx
}

// IFormalParameterPartContext is an interface to support dynamic dispatch.
type IFormalParameterPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterPartContext differentiates from other interfaces.
	IsFormalParameterPartContext()
}

type FormalParameterPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterPartContext() *FormalParameterPartContext {
	var p = new(FormalParameterPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_formalParameterPart
	return p
}

func (*FormalParameterPartContext) IsFormalParameterPartContext() {}

func NewFormalParameterPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterPartContext {
	var p = new(FormalParameterPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_formalParameterPart

	return p
}

func (s *FormalParameterPartContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterPartContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FormalParameterPartContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *FormalParameterPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterFormalParameterPart(s)
	}
}

func (s *FormalParameterPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitFormalParameterPart(s)
	}
}

func (p *Dart2Parser) FormalParameterPart() (localctx IFormalParameterPartContext) {
	this := p
	_ = this

	localctx = NewFormalParameterPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Dart2ParserRULE_formalParameterPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(410)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__38 {
		{
			p.SetState(409)
			p.TypeParameters()
		}

	}
	{
		p.SetState(412)
		p.FormalParameterList()
	}

	return localctx
}

// IReturnTypeContext is an interface to support dynamic dispatch.
type IReturnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnTypeContext differentiates from other interfaces.
	IsReturnTypeContext()
}

type ReturnTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnTypeContext() *ReturnTypeContext {
	var p = new(ReturnTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_returnType
	return p
}

func (*ReturnTypeContext) IsReturnTypeContext() {}

func NewReturnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnTypeContext {
	var p = new(ReturnTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_returnType

	return p
}

func (s *ReturnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnTypeContext) Dtype() IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *ReturnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterReturnType(s)
	}
}

func (s *ReturnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitReturnType(s)
	}
}

func (p *Dart2Parser) ReturnType() (localctx IReturnTypeContext) {
	this := p
	_ = this

	localctx = NewReturnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Dart2ParserRULE_returnType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(416)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(414)
			p.Match(Dart2ParserT__5)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(415)
			p.Dtype()
		}

	}

	return localctx
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_functionBody
	return p
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionBodyContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (p *Dart2Parser) FunctionBody() (localctx IFunctionBodyContext) {
	this := p
	_ = this

	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Dart2ParserRULE_functionBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(429)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(419)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__6 {
			{
				p.SetState(418)
				p.Match(Dart2ParserT__6)
			}

		}
		{
			p.SetState(421)
			p.Match(Dart2ParserT__7)
		}
		{
			p.SetState(422)
			p.Expression()
		}
		{
			p.SetState(423)
			p.Match(Dart2ParserT__8)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(426)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__6)|(1<<Dart2ParserT__9)|(1<<Dart2ParserT__10))) != 0 {
			{
				p.SetState(425)
				_la = p.GetTokenStream().LA(1)

				if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__6)|(1<<Dart2ParserT__9)|(1<<Dart2ParserT__10))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(428)
			p.Block()
		}

	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) Statements() IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *Dart2Parser) Block() (localctx IBlockContext) {
	this := p
	_ = this

	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Dart2ParserRULE_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(431)
		p.Match(Dart2ParserT__11)
	}
	{
		p.SetState(432)
		p.Statements()
	}
	{
		p.SetState(433)
		p.Match(Dart2ParserT__12)
	}

	return localctx
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_formalParameterList
	return p
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) NormalFormalParameters() INormalFormalParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INormalFormalParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INormalFormalParametersContext)
}

func (s *FormalParameterListContext) OptionalFormalParameters() IOptionalFormalParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalFormalParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalFormalParametersContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (p *Dart2Parser) FormalParameterList() (localctx IFormalParameterListContext) {
	this := p
	_ = this

	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Dart2ParserRULE_formalParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(453)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(435)
			p.Match(Dart2ParserT__13)
		}
		{
			p.SetState(436)
			p.Match(Dart2ParserT__14)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(437)
			p.Match(Dart2ParserT__13)
		}
		{
			p.SetState(438)
			p.NormalFormalParameters()
		}
		{
			p.SetState(439)
			p.Match(Dart2ParserT__14)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(441)
			p.Match(Dart2ParserT__13)
		}
		{
			p.SetState(442)
			p.NormalFormalParameters()
		}
		p.SetState(445)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__0 {
			{
				p.SetState(443)
				p.Match(Dart2ParserT__0)
			}
			{
				p.SetState(444)
				p.OptionalFormalParameters()
			}

		}
		{
			p.SetState(447)
			p.Match(Dart2ParserT__14)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(449)
			p.Match(Dart2ParserT__13)
		}
		{
			p.SetState(450)
			p.OptionalFormalParameters()
		}
		{
			p.SetState(451)
			p.Match(Dart2ParserT__14)
		}

	}

	return localctx
}

// INormalFormalParametersContext is an interface to support dynamic dispatch.
type INormalFormalParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNormalFormalParametersContext differentiates from other interfaces.
	IsNormalFormalParametersContext()
}

type NormalFormalParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalFormalParametersContext() *NormalFormalParametersContext {
	var p = new(NormalFormalParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_normalFormalParameters
	return p
}

func (*NormalFormalParametersContext) IsNormalFormalParametersContext() {}

func NewNormalFormalParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalFormalParametersContext {
	var p = new(NormalFormalParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_normalFormalParameters

	return p
}

func (s *NormalFormalParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalFormalParametersContext) AllNormalFormalParameter() []INormalFormalParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INormalFormalParameterContext)(nil)).Elem())
	var tst = make([]INormalFormalParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INormalFormalParameterContext)
		}
	}

	return tst
}

func (s *NormalFormalParametersContext) NormalFormalParameter(i int) INormalFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INormalFormalParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INormalFormalParameterContext)
}

func (s *NormalFormalParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalFormalParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalFormalParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterNormalFormalParameters(s)
	}
}

func (s *NormalFormalParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitNormalFormalParameters(s)
	}
}

func (p *Dart2Parser) NormalFormalParameters() (localctx INormalFormalParametersContext) {
	this := p
	_ = this

	localctx = NewNormalFormalParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Dart2ParserRULE_normalFormalParameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(455)
		p.NormalFormalParameter()
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(456)
				p.Match(Dart2ParserT__0)
			}
			{
				p.SetState(457)
				p.NormalFormalParameter()
			}

		}
		p.SetState(462)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())
	}

	return localctx
}

// IOptionalFormalParametersContext is an interface to support dynamic dispatch.
type IOptionalFormalParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalFormalParametersContext differentiates from other interfaces.
	IsOptionalFormalParametersContext()
}

type OptionalFormalParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalFormalParametersContext() *OptionalFormalParametersContext {
	var p = new(OptionalFormalParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_optionalFormalParameters
	return p
}

func (*OptionalFormalParametersContext) IsOptionalFormalParametersContext() {}

func NewOptionalFormalParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalFormalParametersContext {
	var p = new(OptionalFormalParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_optionalFormalParameters

	return p
}

func (s *OptionalFormalParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalFormalParametersContext) OptionalPositionalFormalParameters() IOptionalPositionalFormalParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalPositionalFormalParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalPositionalFormalParametersContext)
}

func (s *OptionalFormalParametersContext) NamedFormalParameters() INamedFormalParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedFormalParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedFormalParametersContext)
}

func (s *OptionalFormalParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalFormalParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalFormalParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterOptionalFormalParameters(s)
	}
}

func (s *OptionalFormalParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitOptionalFormalParameters(s)
	}
}

func (p *Dart2Parser) OptionalFormalParameters() (localctx IOptionalFormalParametersContext) {
	this := p
	_ = this

	localctx = NewOptionalFormalParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Dart2ParserRULE_optionalFormalParameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(465)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(463)
			p.OptionalPositionalFormalParameters()
		}

	case Dart2ParserT__11:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(464)
			p.NamedFormalParameters()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOptionalPositionalFormalParametersContext is an interface to support dynamic dispatch.
type IOptionalPositionalFormalParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalPositionalFormalParametersContext differentiates from other interfaces.
	IsOptionalPositionalFormalParametersContext()
}

type OptionalPositionalFormalParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalPositionalFormalParametersContext() *OptionalPositionalFormalParametersContext {
	var p = new(OptionalPositionalFormalParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_optionalPositionalFormalParameters
	return p
}

func (*OptionalPositionalFormalParametersContext) IsOptionalPositionalFormalParametersContext() {}

func NewOptionalPositionalFormalParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalPositionalFormalParametersContext {
	var p = new(OptionalPositionalFormalParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_optionalPositionalFormalParameters

	return p
}

func (s *OptionalPositionalFormalParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalPositionalFormalParametersContext) AllDefaultFormalParameter() []IDefaultFormalParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDefaultFormalParameterContext)(nil)).Elem())
	var tst = make([]IDefaultFormalParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDefaultFormalParameterContext)
		}
	}

	return tst
}

func (s *OptionalPositionalFormalParametersContext) DefaultFormalParameter(i int) IDefaultFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefaultFormalParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDefaultFormalParameterContext)
}

func (s *OptionalPositionalFormalParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalPositionalFormalParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalPositionalFormalParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterOptionalPositionalFormalParameters(s)
	}
}

func (s *OptionalPositionalFormalParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitOptionalPositionalFormalParameters(s)
	}
}

func (p *Dart2Parser) OptionalPositionalFormalParameters() (localctx IOptionalPositionalFormalParametersContext) {
	this := p
	_ = this

	localctx = NewOptionalPositionalFormalParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Dart2ParserRULE_optionalPositionalFormalParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(467)
		p.Match(Dart2ParserT__15)
	}
	{
		p.SetState(468)
		p.DefaultFormalParameter()
	}
	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(469)
				p.Match(Dart2ParserT__0)
			}
			{
				p.SetState(470)
				p.DefaultFormalParameter()
			}

		}
		p.SetState(475)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())
	}
	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__0 {
		{
			p.SetState(476)
			p.Match(Dart2ParserT__0)
		}

	}
	{
		p.SetState(479)
		p.Match(Dart2ParserT__16)
	}

	return localctx
}

// INamedFormalParametersContext is an interface to support dynamic dispatch.
type INamedFormalParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedFormalParametersContext differentiates from other interfaces.
	IsNamedFormalParametersContext()
}

type NamedFormalParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedFormalParametersContext() *NamedFormalParametersContext {
	var p = new(NamedFormalParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_namedFormalParameters
	return p
}

func (*NamedFormalParametersContext) IsNamedFormalParametersContext() {}

func NewNamedFormalParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedFormalParametersContext {
	var p = new(NamedFormalParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_namedFormalParameters

	return p
}

func (s *NamedFormalParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedFormalParametersContext) AllDefaultNamedParameter() []IDefaultNamedParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDefaultNamedParameterContext)(nil)).Elem())
	var tst = make([]IDefaultNamedParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDefaultNamedParameterContext)
		}
	}

	return tst
}

func (s *NamedFormalParametersContext) DefaultNamedParameter(i int) IDefaultNamedParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefaultNamedParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDefaultNamedParameterContext)
}

func (s *NamedFormalParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedFormalParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedFormalParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterNamedFormalParameters(s)
	}
}

func (s *NamedFormalParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitNamedFormalParameters(s)
	}
}

func (p *Dart2Parser) NamedFormalParameters() (localctx INamedFormalParametersContext) {
	this := p
	_ = this

	localctx = NewNamedFormalParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Dart2ParserRULE_namedFormalParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(481)
		p.Match(Dart2ParserT__11)
	}
	{
		p.SetState(482)
		p.DefaultNamedParameter()
	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(483)
				p.Match(Dart2ParserT__0)
			}
			{
				p.SetState(484)
				p.DefaultNamedParameter()
			}

		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())
	}
	p.SetState(491)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__0 {
		{
			p.SetState(490)
			p.Match(Dart2ParserT__0)
		}

	}
	{
		p.SetState(493)
		p.Match(Dart2ParserT__12)
	}

	return localctx
}

// INormalFormalParameterContext is an interface to support dynamic dispatch.
type INormalFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNormalFormalParameterContext differentiates from other interfaces.
	IsNormalFormalParameterContext()
}

type NormalFormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalFormalParameterContext() *NormalFormalParameterContext {
	var p = new(NormalFormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_normalFormalParameter
	return p
}

func (*NormalFormalParameterContext) IsNormalFormalParameterContext() {}

func NewNormalFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalFormalParameterContext {
	var p = new(NormalFormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_normalFormalParameter

	return p
}

func (s *NormalFormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalFormalParameterContext) FunctionFormalParameter() IFunctionFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionFormalParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionFormalParameterContext)
}

func (s *NormalFormalParameterContext) FieldFormalParameter() IFieldFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldFormalParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldFormalParameterContext)
}

func (s *NormalFormalParameterContext) SimpleFormalParameter() ISimpleFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleFormalParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleFormalParameterContext)
}

func (s *NormalFormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalFormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalFormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterNormalFormalParameter(s)
	}
}

func (s *NormalFormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitNormalFormalParameter(s)
	}
}

func (p *Dart2Parser) NormalFormalParameter() (localctx INormalFormalParameterContext) {
	this := p
	_ = this

	localctx = NewNormalFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Dart2ParserRULE_normalFormalParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(495)
			p.FunctionFormalParameter()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(496)
			p.FieldFormalParameter()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(497)
			p.SimpleFormalParameter()
		}

	}

	return localctx
}

// IFunctionFormalParameterContext is an interface to support dynamic dispatch.
type IFunctionFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionFormalParameterContext differentiates from other interfaces.
	IsFunctionFormalParameterContext()
}

type FunctionFormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionFormalParameterContext() *FunctionFormalParameterContext {
	var p = new(FunctionFormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_functionFormalParameter
	return p
}

func (*FunctionFormalParameterContext) IsFunctionFormalParameterContext() {}

func NewFunctionFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionFormalParameterContext {
	var p = new(FunctionFormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_functionFormalParameter

	return p
}

func (s *FunctionFormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionFormalParameterContext) Metadata() IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *FunctionFormalParameterContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionFormalParameterContext) FormalParameterPart() IFormalParameterPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterPartContext)
}

func (s *FunctionFormalParameterContext) ReturnType() IReturnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *FunctionFormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionFormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionFormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterFunctionFormalParameter(s)
	}
}

func (s *FunctionFormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitFunctionFormalParameter(s)
	}
}

func (p *Dart2Parser) FunctionFormalParameter() (localctx IFunctionFormalParameterContext) {
	this := p
	_ = this

	localctx = NewFunctionFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Dart2ParserRULE_functionFormalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(500)
		p.Metadata()
	}
	p.SetState(502)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__17 {
		{
			p.SetState(501)
			p.Match(Dart2ParserT__17)
		}

	}
	p.SetState(505)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(504)
			p.ReturnType()
		}

	}
	{
		p.SetState(507)
		p.Identifier()
	}
	{
		p.SetState(508)
		p.FormalParameterPart()
	}

	return localctx
}

// ISimpleFormalParameterContext is an interface to support dynamic dispatch.
type ISimpleFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleFormalParameterContext differentiates from other interfaces.
	IsSimpleFormalParameterContext()
}

type SimpleFormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleFormalParameterContext() *SimpleFormalParameterContext {
	var p = new(SimpleFormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_simpleFormalParameter
	return p
}

func (*SimpleFormalParameterContext) IsSimpleFormalParameterContext() {}

func NewSimpleFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleFormalParameterContext {
	var p = new(SimpleFormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_simpleFormalParameter

	return p
}

func (s *SimpleFormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleFormalParameterContext) DeclaredIdentifier() IDeclaredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaredIdentifierContext)
}

func (s *SimpleFormalParameterContext) Metadata() IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *SimpleFormalParameterContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SimpleFormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleFormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleFormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterSimpleFormalParameter(s)
	}
}

func (s *SimpleFormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitSimpleFormalParameter(s)
	}
}

func (p *Dart2Parser) SimpleFormalParameter() (localctx ISimpleFormalParameterContext) {
	this := p
	_ = this

	localctx = NewSimpleFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Dart2ParserRULE_simpleFormalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(517)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(510)
			p.DeclaredIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(511)
			p.Metadata()
		}
		p.SetState(513)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__17 {
			{
				p.SetState(512)
				p.Match(Dart2ParserT__17)
			}

		}
		{
			p.SetState(515)
			p.Identifier()
		}

	}

	return localctx
}

// IFieldFormalParameterContext is an interface to support dynamic dispatch.
type IFieldFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldFormalParameterContext differentiates from other interfaces.
	IsFieldFormalParameterContext()
}

type FieldFormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldFormalParameterContext() *FieldFormalParameterContext {
	var p = new(FieldFormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_fieldFormalParameter
	return p
}

func (*FieldFormalParameterContext) IsFieldFormalParameterContext() {}

func NewFieldFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldFormalParameterContext {
	var p = new(FieldFormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_fieldFormalParameter

	return p
}

func (s *FieldFormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldFormalParameterContext) Metadata() IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *FieldFormalParameterContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FieldFormalParameterContext) FinalConstVarOrType() IFinalConstVarOrTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinalConstVarOrTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinalConstVarOrTypeContext)
}

func (s *FieldFormalParameterContext) FormalParameterPart() IFormalParameterPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterPartContext)
}

func (s *FieldFormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldFormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldFormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterFieldFormalParameter(s)
	}
}

func (s *FieldFormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitFieldFormalParameter(s)
	}
}

func (p *Dart2Parser) FieldFormalParameter() (localctx IFieldFormalParameterContext) {
	this := p
	_ = this

	localctx = NewFieldFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Dart2ParserRULE_fieldFormalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(519)
		p.Metadata()
	}
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__1)|(1<<Dart2ParserT__2)|(1<<Dart2ParserT__3)|(1<<Dart2ParserT__5))) != 0) || _la == Dart2ParserIDENTIFIER {
		{
			p.SetState(520)
			p.FinalConstVarOrType()
		}

	}
	{
		p.SetState(523)
		p.Match(Dart2ParserT__18)
	}
	{
		p.SetState(524)
		p.Match(Dart2ParserT__19)
	}
	{
		p.SetState(525)
		p.Identifier()
	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__13 || _la == Dart2ParserT__38 {
		{
			p.SetState(526)
			p.FormalParameterPart()
		}

	}

	return localctx
}

// IDefaultFormalParameterContext is an interface to support dynamic dispatch.
type IDefaultFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultFormalParameterContext differentiates from other interfaces.
	IsDefaultFormalParameterContext()
}

type DefaultFormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultFormalParameterContext() *DefaultFormalParameterContext {
	var p = new(DefaultFormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_defaultFormalParameter
	return p
}

func (*DefaultFormalParameterContext) IsDefaultFormalParameterContext() {}

func NewDefaultFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultFormalParameterContext {
	var p = new(DefaultFormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_defaultFormalParameter

	return p
}

func (s *DefaultFormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultFormalParameterContext) NormalFormalParameter() INormalFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INormalFormalParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INormalFormalParameterContext)
}

func (s *DefaultFormalParameterContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultFormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultFormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultFormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterDefaultFormalParameter(s)
	}
}

func (s *DefaultFormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitDefaultFormalParameter(s)
	}
}

func (p *Dart2Parser) DefaultFormalParameter() (localctx IDefaultFormalParameterContext) {
	this := p
	_ = this

	localctx = NewDefaultFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Dart2ParserRULE_defaultFormalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(529)
		p.NormalFormalParameter()
	}
	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__4 {
		{
			p.SetState(530)
			p.Match(Dart2ParserT__4)
		}
		{
			p.SetState(531)
			p.Expression()
		}

	}

	return localctx
}

// IDefaultNamedParameterContext is an interface to support dynamic dispatch.
type IDefaultNamedParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultNamedParameterContext differentiates from other interfaces.
	IsDefaultNamedParameterContext()
}

type DefaultNamedParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultNamedParameterContext() *DefaultNamedParameterContext {
	var p = new(DefaultNamedParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_defaultNamedParameter
	return p
}

func (*DefaultNamedParameterContext) IsDefaultNamedParameterContext() {}

func NewDefaultNamedParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultNamedParameterContext {
	var p = new(DefaultNamedParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_defaultNamedParameter

	return p
}

func (s *DefaultNamedParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultNamedParameterContext) NormalFormalParameter() INormalFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INormalFormalParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INormalFormalParameterContext)
}

func (s *DefaultNamedParameterContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultNamedParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultNamedParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultNamedParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterDefaultNamedParameter(s)
	}
}

func (s *DefaultNamedParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitDefaultNamedParameter(s)
	}
}

func (p *Dart2Parser) DefaultNamedParameter() (localctx IDefaultNamedParameterContext) {
	this := p
	_ = this

	localctx = NewDefaultNamedParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Dart2ParserRULE_defaultNamedParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(544)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(534)
			p.NormalFormalParameter()
		}
		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__4 {
			{
				p.SetState(535)
				p.Match(Dart2ParserT__4)
			}
			{
				p.SetState(536)
				p.Expression()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(539)
			p.NormalFormalParameter()
		}
		p.SetState(542)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__20 {
			{
				p.SetState(540)
				p.Match(Dart2ParserT__20)
			}
			{
				p.SetState(541)
				p.Expression()
			}

		}

	}

	return localctx
}

// IClassDefinitionContext is an interface to support dynamic dispatch.
type IClassDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDefinitionContext differentiates from other interfaces.
	IsClassDefinitionContext()
}

type ClassDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDefinitionContext() *ClassDefinitionContext {
	var p = new(ClassDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_classDefinition
	return p
}

func (*ClassDefinitionContext) IsClassDefinitionContext() {}

func NewClassDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDefinitionContext {
	var p = new(ClassDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_classDefinition

	return p
}

func (s *ClassDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDefinitionContext) AllMetadata() []IMetadataContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMetadataContext)(nil)).Elem())
	var tst = make([]IMetadataContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMetadataContext)
		}
	}

	return tst
}

func (s *ClassDefinitionContext) Metadata(i int) IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *ClassDefinitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassDefinitionContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ClassDefinitionContext) Superclass() ISuperclassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuperclassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuperclassContext)
}

func (s *ClassDefinitionContext) Mixins() IMixinsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMixinsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMixinsContext)
}

func (s *ClassDefinitionContext) Interfaces() IInterfacesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfacesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfacesContext)
}

func (s *ClassDefinitionContext) AllClassMemberDefinition() []IClassMemberDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassMemberDefinitionContext)(nil)).Elem())
	var tst = make([]IClassMemberDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassMemberDefinitionContext)
		}
	}

	return tst
}

func (s *ClassDefinitionContext) ClassMemberDefinition(i int) IClassMemberDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassMemberDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassMemberDefinitionContext)
}

func (s *ClassDefinitionContext) MixinApplicationClass() IMixinApplicationClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMixinApplicationClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMixinApplicationClassContext)
}

func (s *ClassDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterClassDefinition(s)
	}
}

func (s *ClassDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitClassDefinition(s)
	}
}

func (p *Dart2Parser) ClassDefinition() (localctx IClassDefinitionContext) {
	this := p
	_ = this

	localctx = NewClassDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Dart2ParserRULE_classDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(582)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(546)
			p.Metadata()
		}
		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__21 {
			{
				p.SetState(547)
				p.Match(Dart2ParserT__21)
			}

		}
		{
			p.SetState(550)
			p.Match(Dart2ParserT__22)
		}
		{
			p.SetState(551)
			p.Identifier()
		}
		p.SetState(553)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__38 {
			{
				p.SetState(552)
				p.TypeParameters()
			}

		}
		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__35 {
			{
				p.SetState(555)
				p.Superclass()
			}

		}
		p.SetState(559)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__23 {
			{
				p.SetState(558)
				p.Mixins()
			}

		}
		p.SetState(562)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__36 {
			{
				p.SetState(561)
				p.Interfaces()
			}

		}
		{
			p.SetState(564)
			p.Match(Dart2ParserT__11)
		}
		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__1)|(1<<Dart2ParserT__2)|(1<<Dart2ParserT__3)|(1<<Dart2ParserT__5)|(1<<Dart2ParserT__17)|(1<<Dart2ParserT__24)|(1<<Dart2ParserT__25)|(1<<Dart2ParserT__26))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(Dart2ParserT__31-32))|(1<<(Dart2ParserT__32-32))|(1<<(Dart2ParserT__34-32))|(1<<(Dart2ParserT__40-32)))) != 0) || _la == Dart2ParserIDENTIFIER {
			{
				p.SetState(565)
				p.Metadata()
			}
			{
				p.SetState(566)
				p.ClassMemberDefinition()
			}

			p.SetState(572)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(573)
			p.Match(Dart2ParserT__12)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(575)
			p.Metadata()
		}
		p.SetState(577)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__21 {
			{
				p.SetState(576)
				p.Match(Dart2ParserT__21)
			}

		}
		{
			p.SetState(579)
			p.Match(Dart2ParserT__22)
		}
		{
			p.SetState(580)
			p.MixinApplicationClass()
		}

	}

	return localctx
}

// IMixinsContext is an interface to support dynamic dispatch.
type IMixinsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMixinsContext differentiates from other interfaces.
	IsMixinsContext()
}

type MixinsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMixinsContext() *MixinsContext {
	var p = new(MixinsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_mixins
	return p
}

func (*MixinsContext) IsMixinsContext() {}

func NewMixinsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MixinsContext {
	var p = new(MixinsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_mixins

	return p
}

func (s *MixinsContext) GetParser() antlr.Parser { return s.parser }

func (s *MixinsContext) TypeList() ITypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *MixinsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MixinsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MixinsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterMixins(s)
	}
}

func (s *MixinsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitMixins(s)
	}
}

func (p *Dart2Parser) Mixins() (localctx IMixinsContext) {
	this := p
	_ = this

	localctx = NewMixinsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Dart2ParserRULE_mixins)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)
		p.Match(Dart2ParserT__23)
	}
	{
		p.SetState(585)
		p.TypeList()
	}

	return localctx
}

// IClassMemberDefinitionContext is an interface to support dynamic dispatch.
type IClassMemberDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassMemberDefinitionContext differentiates from other interfaces.
	IsClassMemberDefinitionContext()
}

type ClassMemberDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMemberDefinitionContext() *ClassMemberDefinitionContext {
	var p = new(ClassMemberDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_classMemberDefinition
	return p
}

func (*ClassMemberDefinitionContext) IsClassMemberDefinitionContext() {}

func NewClassMemberDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMemberDefinitionContext {
	var p = new(ClassMemberDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_classMemberDefinition

	return p
}

func (s *ClassMemberDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMemberDefinitionContext) Declaration() IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ClassMemberDefinitionContext) MethodSignature() IMethodSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodSignatureContext)
}

func (s *ClassMemberDefinitionContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *ClassMemberDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMemberDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMemberDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterClassMemberDefinition(s)
	}
}

func (s *ClassMemberDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitClassMemberDefinition(s)
	}
}

func (p *Dart2Parser) ClassMemberDefinition() (localctx IClassMemberDefinitionContext) {
	this := p
	_ = this

	localctx = NewClassMemberDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Dart2ParserRULE_classMemberDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(587)
			p.Declaration()
		}
		{
			p.SetState(588)
			p.Match(Dart2ParserT__8)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(590)
			p.MethodSignature()
		}
		{
			p.SetState(591)
			p.FunctionBody()
		}

	}

	return localctx
}

// IMethodSignatureContext is an interface to support dynamic dispatch.
type IMethodSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodSignatureContext differentiates from other interfaces.
	IsMethodSignatureContext()
}

type MethodSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodSignatureContext() *MethodSignatureContext {
	var p = new(MethodSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_methodSignature
	return p
}

func (*MethodSignatureContext) IsMethodSignatureContext() {}

func NewMethodSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodSignatureContext {
	var p = new(MethodSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_methodSignature

	return p
}

func (s *MethodSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodSignatureContext) ConstructorSignature() IConstructorSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructorSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructorSignatureContext)
}

func (s *MethodSignatureContext) Initializers() IInitializersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializersContext)
}

func (s *MethodSignatureContext) FactoryConstructorSignature() IFactoryConstructorSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactoryConstructorSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFactoryConstructorSignatureContext)
}

func (s *MethodSignatureContext) FunctionSignature() IFunctionSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionSignatureContext)
}

func (s *MethodSignatureContext) GetterSignature() IGetterSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGetterSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGetterSignatureContext)
}

func (s *MethodSignatureContext) SetterSignature() ISetterSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetterSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetterSignatureContext)
}

func (s *MethodSignatureContext) OperatorSignature() IOperatorSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperatorSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperatorSignatureContext)
}

func (s *MethodSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterMethodSignature(s)
	}
}

func (s *MethodSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitMethodSignature(s)
	}
}

func (p *Dart2Parser) MethodSignature() (localctx IMethodSignatureContext) {
	this := p
	_ = this

	localctx = NewMethodSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Dart2ParserRULE_methodSignature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(595)
			p.ConstructorSignature()
		}
		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__20 {
			{
				p.SetState(596)
				p.Initializers()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(599)
			p.FactoryConstructorSignature()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(601)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__24 {
			{
				p.SetState(600)
				p.Match(Dart2ParserT__24)
			}

		}
		{
			p.SetState(603)
			p.FunctionSignature()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(605)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__24 {
			{
				p.SetState(604)
				p.Match(Dart2ParserT__24)
			}

		}
		{
			p.SetState(607)
			p.GetterSignature()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(609)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__24 {
			{
				p.SetState(608)
				p.Match(Dart2ParserT__24)
			}

		}
		{
			p.SetState(611)
			p.SetterSignature()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(612)
			p.OperatorSignature()
		}

	}

	return localctx
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) ConstantConstructorSignature() IConstantConstructorSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantConstructorSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantConstructorSignatureContext)
}

func (s *DeclarationContext) Redirection() IRedirectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRedirectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRedirectionContext)
}

func (s *DeclarationContext) Initializers() IInitializersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializersContext)
}

func (s *DeclarationContext) ConstructorSignature() IConstructorSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructorSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructorSignatureContext)
}

func (s *DeclarationContext) GetterSignature() IGetterSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGetterSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGetterSignatureContext)
}

func (s *DeclarationContext) SetterSignature() ISetterSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetterSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetterSignatureContext)
}

func (s *DeclarationContext) OperatorSignature() IOperatorSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperatorSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperatorSignatureContext)
}

func (s *DeclarationContext) FunctionSignature() IFunctionSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionSignatureContext)
}

func (s *DeclarationContext) StaticFinalDeclarationList() IStaticFinalDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStaticFinalDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStaticFinalDeclarationListContext)
}

func (s *DeclarationContext) Dtype() IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *DeclarationContext) InitializedIdentifierList() IInitializedIdentifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializedIdentifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializedIdentifierListContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (p *Dart2Parser) Declaration() (localctx IDeclarationContext) {
	this := p
	_ = this

	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Dart2ParserRULE_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(673)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(615)
			p.ConstantConstructorSignature()
		}
		p.SetState(618)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(616)
				p.Redirection()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(617)
				p.Initializers()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(620)
			p.ConstructorSignature()
		}
		p.SetState(623)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(621)
				p.Redirection()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(622)
				p.Initializers()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(625)
			p.Match(Dart2ParserT__25)
		}
		{
			p.SetState(626)
			p.ConstantConstructorSignature()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(627)
			p.Match(Dart2ParserT__25)
		}
		{
			p.SetState(628)
			p.ConstructorSignature()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(633)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__25 {
			{
				p.SetState(629)
				p.Match(Dart2ParserT__25)
			}
			p.SetState(631)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Dart2ParserT__24 {
				{
					p.SetState(630)
					p.Match(Dart2ParserT__24)
				}

			}

		}
		{
			p.SetState(635)
			p.GetterSignature()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(640)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__25 {
			{
				p.SetState(636)
				p.Match(Dart2ParserT__25)
			}
			p.SetState(638)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Dart2ParserT__24 {
				{
					p.SetState(637)
					p.Match(Dart2ParserT__24)
				}

			}

		}
		{
			p.SetState(642)
			p.SetterSignature()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(644)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__25 {
			{
				p.SetState(643)
				p.Match(Dart2ParserT__25)
			}

		}
		{
			p.SetState(646)
			p.OperatorSignature()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(651)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__25 {
			{
				p.SetState(647)
				p.Match(Dart2ParserT__25)
			}
			p.SetState(649)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Dart2ParserT__24 {
				{
					p.SetState(648)
					p.Match(Dart2ParserT__24)
				}

			}

		}
		{
			p.SetState(653)
			p.FunctionSignature()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(654)
			p.Match(Dart2ParserT__24)
		}
		{
			p.SetState(655)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Dart2ParserT__1 || _la == Dart2ParserT__2) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(657)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(656)
				p.Dtype()
			}

		}
		{
			p.SetState(659)
			p.StaticFinalDeclarationList()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(660)
			p.Match(Dart2ParserT__1)
		}
		p.SetState(662)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(661)
				p.Dtype()
			}

		}
		{
			p.SetState(664)
			p.InitializedIdentifierList()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__17 || _la == Dart2ParserT__24 {
			{
				p.SetState(665)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Dart2ParserT__17 || _la == Dart2ParserT__24) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(670)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Dart2ParserT__3:
			{
				p.SetState(668)
				p.Match(Dart2ParserT__3)
			}

		case Dart2ParserT__5, Dart2ParserIDENTIFIER:
			{
				p.SetState(669)
				p.Dtype()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(672)
			p.InitializedIdentifierList()
		}

	}

	return localctx
}

// IStaticFinalDeclarationListContext is an interface to support dynamic dispatch.
type IStaticFinalDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticFinalDeclarationListContext differentiates from other interfaces.
	IsStaticFinalDeclarationListContext()
}

type StaticFinalDeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticFinalDeclarationListContext() *StaticFinalDeclarationListContext {
	var p = new(StaticFinalDeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_staticFinalDeclarationList
	return p
}

func (*StaticFinalDeclarationListContext) IsStaticFinalDeclarationListContext() {}

func NewStaticFinalDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticFinalDeclarationListContext {
	var p = new(StaticFinalDeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_staticFinalDeclarationList

	return p
}

func (s *StaticFinalDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticFinalDeclarationListContext) AllStaticFinalDeclaration() []IStaticFinalDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStaticFinalDeclarationContext)(nil)).Elem())
	var tst = make([]IStaticFinalDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStaticFinalDeclarationContext)
		}
	}

	return tst
}

func (s *StaticFinalDeclarationListContext) StaticFinalDeclaration(i int) IStaticFinalDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStaticFinalDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStaticFinalDeclarationContext)
}

func (s *StaticFinalDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticFinalDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticFinalDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterStaticFinalDeclarationList(s)
	}
}

func (s *StaticFinalDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitStaticFinalDeclarationList(s)
	}
}

func (p *Dart2Parser) StaticFinalDeclarationList() (localctx IStaticFinalDeclarationListContext) {
	this := p
	_ = this

	localctx = NewStaticFinalDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Dart2ParserRULE_staticFinalDeclarationList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(675)
		p.StaticFinalDeclaration()
	}
	p.SetState(680)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__0 {
		{
			p.SetState(676)
			p.Match(Dart2ParserT__0)
		}
		{
			p.SetState(677)
			p.StaticFinalDeclaration()
		}

		p.SetState(682)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStaticFinalDeclarationContext is an interface to support dynamic dispatch.
type IStaticFinalDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticFinalDeclarationContext differentiates from other interfaces.
	IsStaticFinalDeclarationContext()
}

type StaticFinalDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticFinalDeclarationContext() *StaticFinalDeclarationContext {
	var p = new(StaticFinalDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_staticFinalDeclaration
	return p
}

func (*StaticFinalDeclarationContext) IsStaticFinalDeclarationContext() {}

func NewStaticFinalDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticFinalDeclarationContext {
	var p = new(StaticFinalDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_staticFinalDeclaration

	return p
}

func (s *StaticFinalDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticFinalDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StaticFinalDeclarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StaticFinalDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticFinalDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticFinalDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterStaticFinalDeclaration(s)
	}
}

func (s *StaticFinalDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitStaticFinalDeclaration(s)
	}
}

func (p *Dart2Parser) StaticFinalDeclaration() (localctx IStaticFinalDeclarationContext) {
	this := p
	_ = this

	localctx = NewStaticFinalDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Dart2ParserRULE_staticFinalDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(683)
		p.Identifier()
	}
	{
		p.SetState(684)
		p.Match(Dart2ParserT__4)
	}
	{
		p.SetState(685)
		p.Expression()
	}

	return localctx
}

// IOperatorSignatureContext is an interface to support dynamic dispatch.
type IOperatorSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperatorSignatureContext differentiates from other interfaces.
	IsOperatorSignatureContext()
}

type OperatorSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperatorSignatureContext() *OperatorSignatureContext {
	var p = new(OperatorSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_operatorSignature
	return p
}

func (*OperatorSignatureContext) IsOperatorSignatureContext() {}

func NewOperatorSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperatorSignatureContext {
	var p = new(OperatorSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_operatorSignature

	return p
}

func (s *OperatorSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *OperatorSignatureContext) Operator_() IOperator_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperator_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperator_Context)
}

func (s *OperatorSignatureContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *OperatorSignatureContext) ReturnType() IReturnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *OperatorSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperatorSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperatorSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterOperatorSignature(s)
	}
}

func (s *OperatorSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitOperatorSignature(s)
	}
}

func (p *Dart2Parser) OperatorSignature() (localctx IOperatorSignatureContext) {
	this := p
	_ = this

	localctx = NewOperatorSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Dart2ParserRULE_operatorSignature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__5 || _la == Dart2ParserIDENTIFIER {
		{
			p.SetState(687)
			p.ReturnType()
		}

	}
	{
		p.SetState(690)
		p.Match(Dart2ParserT__26)
	}
	{
		p.SetState(691)
		p.Operator_()
	}
	{
		p.SetState(692)
		p.FormalParameterList()
	}

	return localctx
}

// IOperator_Context is an interface to support dynamic dispatch.
type IOperator_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperator_Context differentiates from other interfaces.
	IsOperator_Context()
}

type Operator_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperator_Context() *Operator_Context {
	var p = new(Operator_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_operator_
	return p
}

func (*Operator_Context) IsOperator_Context() {}

func NewOperator_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Operator_Context {
	var p = new(Operator_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_operator_

	return p
}

func (s *Operator_Context) GetParser() antlr.Parser { return s.parser }

func (s *Operator_Context) BinaryOperator() IBinaryOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinaryOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinaryOperatorContext)
}

func (s *Operator_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Operator_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Operator_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterOperator_(s)
	}
}

func (s *Operator_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitOperator_(s)
	}
}

func (p *Dart2Parser) Operator_() (localctx IOperator_Context) {
	this := p
	_ = this

	localctx = NewOperator_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Dart2ParserRULE_operator_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(698)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__27:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(694)
			p.Match(Dart2ParserT__27)
		}

	case Dart2ParserT__30, Dart2ParserT__38, Dart2ParserT__39, Dart2ParserT__67, Dart2ParserT__68, Dart2ParserT__69, Dart2ParserT__70, Dart2ParserT__71, Dart2ParserT__72, Dart2ParserT__73, Dart2ParserT__74, Dart2ParserT__75, Dart2ParserT__76, Dart2ParserT__77, Dart2ParserT__78, Dart2ParserT__79, Dart2ParserT__80:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(695)
			p.BinaryOperator()
		}

	case Dart2ParserT__28:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(696)
			p.Match(Dart2ParserT__28)
		}

	case Dart2ParserT__29:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(697)
			p.Match(Dart2ParserT__29)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBinaryOperatorContext is an interface to support dynamic dispatch.
type IBinaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinaryOperatorContext differentiates from other interfaces.
	IsBinaryOperatorContext()
}

type BinaryOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryOperatorContext() *BinaryOperatorContext {
	var p = new(BinaryOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_binaryOperator
	return p
}

func (*BinaryOperatorContext) IsBinaryOperatorContext() {}

func NewBinaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryOperatorContext {
	var p = new(BinaryOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_binaryOperator

	return p
}

func (s *BinaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryOperatorContext) MultiplicativeOperator() IMultiplicativeOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicativeOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeOperatorContext)
}

func (s *BinaryOperatorContext) AdditiveOperator() IAdditiveOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditiveOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditiveOperatorContext)
}

func (s *BinaryOperatorContext) ShiftOperator() IShiftOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShiftOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShiftOperatorContext)
}

func (s *BinaryOperatorContext) RelationalOperator() IRelationalOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationalOperatorContext)
}

func (s *BinaryOperatorContext) BitwiseOperator() IBitwiseOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitwiseOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitwiseOperatorContext)
}

func (s *BinaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterBinaryOperator(s)
	}
}

func (s *BinaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitBinaryOperator(s)
	}
}

func (p *Dart2Parser) BinaryOperator() (localctx IBinaryOperatorContext) {
	this := p
	_ = this

	localctx = NewBinaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Dart2ParserRULE_binaryOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(706)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__77, Dart2ParserT__78, Dart2ParserT__79, Dart2ParserT__80:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(700)
			p.MultiplicativeOperator()
		}

	case Dart2ParserT__75, Dart2ParserT__76:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(701)
			p.AdditiveOperator()
		}

	case Dart2ParserT__72, Dart2ParserT__73, Dart2ParserT__74:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(702)
			p.ShiftOperator()
		}

	case Dart2ParserT__38, Dart2ParserT__39, Dart2ParserT__67, Dart2ParserT__68:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(703)
			p.RelationalOperator()
		}

	case Dart2ParserT__30:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(704)
			p.Match(Dart2ParserT__30)
		}

	case Dart2ParserT__69, Dart2ParserT__70, Dart2ParserT__71:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(705)
			p.BitwiseOperator()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGetterSignatureContext is an interface to support dynamic dispatch.
type IGetterSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGetterSignatureContext differentiates from other interfaces.
	IsGetterSignatureContext()
}

type GetterSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetterSignatureContext() *GetterSignatureContext {
	var p = new(GetterSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_getterSignature
	return p
}

func (*GetterSignatureContext) IsGetterSignatureContext() {}

func NewGetterSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetterSignatureContext {
	var p = new(GetterSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_getterSignature

	return p
}

func (s *GetterSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *GetterSignatureContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GetterSignatureContext) ReturnType() IReturnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *GetterSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetterSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterGetterSignature(s)
	}
}

func (s *GetterSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitGetterSignature(s)
	}
}

func (p *Dart2Parser) GetterSignature() (localctx IGetterSignatureContext) {
	this := p
	_ = this

	localctx = NewGetterSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Dart2ParserRULE_getterSignature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(709)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__5 || _la == Dart2ParserIDENTIFIER {
		{
			p.SetState(708)
			p.ReturnType()
		}

	}
	{
		p.SetState(711)
		p.Match(Dart2ParserT__31)
	}
	{
		p.SetState(712)
		p.Identifier()
	}

	return localctx
}

// ISetterSignatureContext is an interface to support dynamic dispatch.
type ISetterSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetterSignatureContext differentiates from other interfaces.
	IsSetterSignatureContext()
}

type SetterSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetterSignatureContext() *SetterSignatureContext {
	var p = new(SetterSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_setterSignature
	return p
}

func (*SetterSignatureContext) IsSetterSignatureContext() {}

func NewSetterSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetterSignatureContext {
	var p = new(SetterSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_setterSignature

	return p
}

func (s *SetterSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *SetterSignatureContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetterSignatureContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *SetterSignatureContext) ReturnType() IReturnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *SetterSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetterSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetterSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterSetterSignature(s)
	}
}

func (s *SetterSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitSetterSignature(s)
	}
}

func (p *Dart2Parser) SetterSignature() (localctx ISetterSignatureContext) {
	this := p
	_ = this

	localctx = NewSetterSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Dart2ParserRULE_setterSignature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__5 || _la == Dart2ParserIDENTIFIER {
		{
			p.SetState(714)
			p.ReturnType()
		}

	}
	{
		p.SetState(717)
		p.Match(Dart2ParserT__32)
	}
	{
		p.SetState(718)
		p.Identifier()
	}
	{
		p.SetState(719)
		p.FormalParameterList()
	}

	return localctx
}

// IConstructorSignatureContext is an interface to support dynamic dispatch.
type IConstructorSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructorSignatureContext differentiates from other interfaces.
	IsConstructorSignatureContext()
}

type ConstructorSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorSignatureContext() *ConstructorSignatureContext {
	var p = new(ConstructorSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_constructorSignature
	return p
}

func (*ConstructorSignatureContext) IsConstructorSignatureContext() {}

func NewConstructorSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorSignatureContext {
	var p = new(ConstructorSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_constructorSignature

	return p
}

func (s *ConstructorSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorSignatureContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ConstructorSignatureContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstructorSignatureContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ConstructorSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterConstructorSignature(s)
	}
}

func (s *ConstructorSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitConstructorSignature(s)
	}
}

func (p *Dart2Parser) ConstructorSignature() (localctx IConstructorSignatureContext) {
	this := p
	_ = this

	localctx = NewConstructorSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Dart2ParserRULE_constructorSignature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(721)
		p.Identifier()
	}
	p.SetState(724)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__19 {
		{
			p.SetState(722)
			p.Match(Dart2ParserT__19)
		}
		{
			p.SetState(723)
			p.Identifier()
		}

	}
	{
		p.SetState(726)
		p.FormalParameterList()
	}

	return localctx
}

// IRedirectionContext is an interface to support dynamic dispatch.
type IRedirectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRedirectionContext differentiates from other interfaces.
	IsRedirectionContext()
}

type RedirectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRedirectionContext() *RedirectionContext {
	var p = new(RedirectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_redirection
	return p
}

func (*RedirectionContext) IsRedirectionContext() {}

func NewRedirectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RedirectionContext {
	var p = new(RedirectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_redirection

	return p
}

func (s *RedirectionContext) GetParser() antlr.Parser { return s.parser }

func (s *RedirectionContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *RedirectionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RedirectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RedirectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RedirectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterRedirection(s)
	}
}

func (s *RedirectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitRedirection(s)
	}
}

func (p *Dart2Parser) Redirection() (localctx IRedirectionContext) {
	this := p
	_ = this

	localctx = NewRedirectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, Dart2ParserRULE_redirection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.Match(Dart2ParserT__20)
	}
	{
		p.SetState(729)
		p.Match(Dart2ParserT__18)
	}
	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__19 {
		{
			p.SetState(730)
			p.Match(Dart2ParserT__19)
		}
		{
			p.SetState(731)
			p.Identifier()
		}

	}
	{
		p.SetState(734)
		p.Arguments()
	}

	return localctx
}

// IInitializersContext is an interface to support dynamic dispatch.
type IInitializersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializersContext differentiates from other interfaces.
	IsInitializersContext()
}

type InitializersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializersContext() *InitializersContext {
	var p = new(InitializersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_initializers
	return p
}

func (*InitializersContext) IsInitializersContext() {}

func NewInitializersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializersContext {
	var p = new(InitializersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_initializers

	return p
}

func (s *InitializersContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializersContext) AllInitializerListEntry() []IInitializerListEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInitializerListEntryContext)(nil)).Elem())
	var tst = make([]IInitializerListEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInitializerListEntryContext)
		}
	}

	return tst
}

func (s *InitializersContext) InitializerListEntry(i int) IInitializerListEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializerListEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInitializerListEntryContext)
}

func (s *InitializersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterInitializers(s)
	}
}

func (s *InitializersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitInitializers(s)
	}
}

func (p *Dart2Parser) Initializers() (localctx IInitializersContext) {
	this := p
	_ = this

	localctx = NewInitializersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, Dart2ParserRULE_initializers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(736)
		p.Match(Dart2ParserT__20)
	}
	{
		p.SetState(737)
		p.InitializerListEntry()
	}
	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__0 {
		{
			p.SetState(738)
			p.Match(Dart2ParserT__0)
		}
		{
			p.SetState(739)
			p.InitializerListEntry()
		}

		p.SetState(744)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInitializerListEntryContext is an interface to support dynamic dispatch.
type IInitializerListEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializerListEntryContext differentiates from other interfaces.
	IsInitializerListEntryContext()
}

type InitializerListEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerListEntryContext() *InitializerListEntryContext {
	var p = new(InitializerListEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_initializerListEntry
	return p
}

func (*InitializerListEntryContext) IsInitializerListEntryContext() {}

func NewInitializerListEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerListEntryContext {
	var p = new(InitializerListEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_initializerListEntry

	return p
}

func (s *InitializerListEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerListEntryContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *InitializerListEntryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InitializerListEntryContext) FieldInitializer() IFieldInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldInitializerContext)
}

func (s *InitializerListEntryContext) Assertion() IAssertionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertionContext)
}

func (s *InitializerListEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerListEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerListEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterInitializerListEntry(s)
	}
}

func (s *InitializerListEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitInitializerListEntry(s)
	}
}

func (p *Dart2Parser) InitializerListEntry() (localctx IInitializerListEntryContext) {
	this := p
	_ = this

	localctx = NewInitializerListEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, Dart2ParserRULE_initializerListEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(745)
			p.Match(Dart2ParserT__33)
		}
		{
			p.SetState(746)
			p.Arguments()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(747)
			p.Match(Dart2ParserT__33)
		}
		{
			p.SetState(748)
			p.Match(Dart2ParserT__19)
		}
		{
			p.SetState(749)
			p.Identifier()
		}
		{
			p.SetState(750)
			p.Arguments()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(752)
			p.FieldInitializer()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(753)
			p.Assertion()
		}

	}

	return localctx
}

// IFieldInitializerContext is an interface to support dynamic dispatch.
type IFieldInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldInitializerContext differentiates from other interfaces.
	IsFieldInitializerContext()
}

type FieldInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldInitializerContext() *FieldInitializerContext {
	var p = new(FieldInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_fieldInitializer
	return p
}

func (*FieldInitializerContext) IsFieldInitializerContext() {}

func NewFieldInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldInitializerContext {
	var p = new(FieldInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_fieldInitializer

	return p
}

func (s *FieldInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldInitializerContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FieldInitializerContext) ConditionalExpression() IConditionalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *FieldInitializerContext) AllCascadeSection() []ICascadeSectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICascadeSectionContext)(nil)).Elem())
	var tst = make([]ICascadeSectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICascadeSectionContext)
		}
	}

	return tst
}

func (s *FieldInitializerContext) CascadeSection(i int) ICascadeSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICascadeSectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICascadeSectionContext)
}

func (s *FieldInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterFieldInitializer(s)
	}
}

func (s *FieldInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitFieldInitializer(s)
	}
}

func (p *Dart2Parser) FieldInitializer() (localctx IFieldInitializerContext) {
	this := p
	_ = this

	localctx = NewFieldInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Dart2ParserRULE_fieldInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(758)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__18 {
		{
			p.SetState(756)
			p.Match(Dart2ParserT__18)
		}
		{
			p.SetState(757)
			p.Match(Dart2ParserT__19)
		}

	}
	{
		p.SetState(760)
		p.Identifier()
	}
	{
		p.SetState(761)
		p.Match(Dart2ParserT__4)
	}
	{
		p.SetState(762)
		p.ConditionalExpression()
	}
	p.SetState(766)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__49 {
		{
			p.SetState(763)
			p.CascadeSection()
		}

		p.SetState(768)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFactoryConstructorSignatureContext is an interface to support dynamic dispatch.
type IFactoryConstructorSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFactoryConstructorSignatureContext differentiates from other interfaces.
	IsFactoryConstructorSignatureContext()
}

type FactoryConstructorSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactoryConstructorSignatureContext() *FactoryConstructorSignatureContext {
	var p = new(FactoryConstructorSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_factoryConstructorSignature
	return p
}

func (*FactoryConstructorSignatureContext) IsFactoryConstructorSignatureContext() {}

func NewFactoryConstructorSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactoryConstructorSignatureContext {
	var p = new(FactoryConstructorSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_factoryConstructorSignature

	return p
}

func (s *FactoryConstructorSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *FactoryConstructorSignatureContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *FactoryConstructorSignatureContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FactoryConstructorSignatureContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FactoryConstructorSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactoryConstructorSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FactoryConstructorSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterFactoryConstructorSignature(s)
	}
}

func (s *FactoryConstructorSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitFactoryConstructorSignature(s)
	}
}

func (p *Dart2Parser) FactoryConstructorSignature() (localctx IFactoryConstructorSignatureContext) {
	this := p
	_ = this

	localctx = NewFactoryConstructorSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Dart2ParserRULE_factoryConstructorSignature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.Match(Dart2ParserT__34)
	}
	{
		p.SetState(770)
		p.Identifier()
	}
	p.SetState(773)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__19 {
		{
			p.SetState(771)
			p.Match(Dart2ParserT__19)
		}
		{
			p.SetState(772)
			p.Identifier()
		}

	}
	{
		p.SetState(775)
		p.FormalParameterList()
	}

	return localctx
}

// IRedirectingFactoryConstructorSignatureContext is an interface to support dynamic dispatch.
type IRedirectingFactoryConstructorSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRedirectingFactoryConstructorSignatureContext differentiates from other interfaces.
	IsRedirectingFactoryConstructorSignatureContext()
}

type RedirectingFactoryConstructorSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRedirectingFactoryConstructorSignatureContext() *RedirectingFactoryConstructorSignatureContext {
	var p = new(RedirectingFactoryConstructorSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_redirectingFactoryConstructorSignature
	return p
}

func (*RedirectingFactoryConstructorSignatureContext) IsRedirectingFactoryConstructorSignatureContext() {
}

func NewRedirectingFactoryConstructorSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RedirectingFactoryConstructorSignatureContext {
	var p = new(RedirectingFactoryConstructorSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_redirectingFactoryConstructorSignature

	return p
}

func (s *RedirectingFactoryConstructorSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *RedirectingFactoryConstructorSignatureContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *RedirectingFactoryConstructorSignatureContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RedirectingFactoryConstructorSignatureContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *RedirectingFactoryConstructorSignatureContext) Dtype() IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *RedirectingFactoryConstructorSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RedirectingFactoryConstructorSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RedirectingFactoryConstructorSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterRedirectingFactoryConstructorSignature(s)
	}
}

func (s *RedirectingFactoryConstructorSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitRedirectingFactoryConstructorSignature(s)
	}
}

func (p *Dart2Parser) RedirectingFactoryConstructorSignature() (localctx IRedirectingFactoryConstructorSignatureContext) {
	this := p
	_ = this

	localctx = NewRedirectingFactoryConstructorSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Dart2ParserRULE_redirectingFactoryConstructorSignature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__2 {
		{
			p.SetState(777)
			p.Match(Dart2ParserT__2)
		}

	}
	{
		p.SetState(780)
		p.Match(Dart2ParserT__34)
	}
	{
		p.SetState(781)
		p.Identifier()
	}
	p.SetState(784)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__19 {
		{
			p.SetState(782)
			p.Match(Dart2ParserT__19)
		}
		{
			p.SetState(783)
			p.Identifier()
		}

	}
	{
		p.SetState(786)
		p.FormalParameterList()
	}
	{
		p.SetState(787)
		p.Match(Dart2ParserT__4)
	}
	{
		p.SetState(788)
		p.Dtype()
	}
	p.SetState(791)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__19 {
		{
			p.SetState(789)
			p.Match(Dart2ParserT__19)
		}
		{
			p.SetState(790)
			p.Identifier()
		}

	}

	return localctx
}

// IConstantConstructorSignatureContext is an interface to support dynamic dispatch.
type IConstantConstructorSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantConstructorSignatureContext differentiates from other interfaces.
	IsConstantConstructorSignatureContext()
}

type ConstantConstructorSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantConstructorSignatureContext() *ConstantConstructorSignatureContext {
	var p = new(ConstantConstructorSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_constantConstructorSignature
	return p
}

func (*ConstantConstructorSignatureContext) IsConstantConstructorSignatureContext() {}

func NewConstantConstructorSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantConstructorSignatureContext {
	var p = new(ConstantConstructorSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_constantConstructorSignature

	return p
}

func (s *ConstantConstructorSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantConstructorSignatureContext) Qualified() IQualifiedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedContext)
}

func (s *ConstantConstructorSignatureContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ConstantConstructorSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantConstructorSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantConstructorSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterConstantConstructorSignature(s)
	}
}

func (s *ConstantConstructorSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitConstantConstructorSignature(s)
	}
}

func (p *Dart2Parser) ConstantConstructorSignature() (localctx IConstantConstructorSignatureContext) {
	this := p
	_ = this

	localctx = NewConstantConstructorSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Dart2ParserRULE_constantConstructorSignature)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(793)
		p.Match(Dart2ParserT__2)
	}
	{
		p.SetState(794)
		p.Qualified()
	}
	{
		p.SetState(795)
		p.FormalParameterList()
	}

	return localctx
}

// ISuperclassContext is an interface to support dynamic dispatch.
type ISuperclassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuperclassContext differentiates from other interfaces.
	IsSuperclassContext()
}

type SuperclassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuperclassContext() *SuperclassContext {
	var p = new(SuperclassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_superclass
	return p
}

func (*SuperclassContext) IsSuperclassContext() {}

func NewSuperclassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuperclassContext {
	var p = new(SuperclassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_superclass

	return p
}

func (s *SuperclassContext) GetParser() antlr.Parser { return s.parser }

func (s *SuperclassContext) Dtype() IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *SuperclassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperclassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuperclassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterSuperclass(s)
	}
}

func (s *SuperclassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitSuperclass(s)
	}
}

func (p *Dart2Parser) Superclass() (localctx ISuperclassContext) {
	this := p
	_ = this

	localctx = NewSuperclassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, Dart2ParserRULE_superclass)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(797)
		p.Match(Dart2ParserT__35)
	}
	{
		p.SetState(798)
		p.Dtype()
	}

	return localctx
}

// IInterfacesContext is an interface to support dynamic dispatch.
type IInterfacesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfacesContext differentiates from other interfaces.
	IsInterfacesContext()
}

type InterfacesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfacesContext() *InterfacesContext {
	var p = new(InterfacesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_interfaces
	return p
}

func (*InterfacesContext) IsInterfacesContext() {}

func NewInterfacesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfacesContext {
	var p = new(InterfacesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_interfaces

	return p
}

func (s *InterfacesContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfacesContext) TypeList() ITypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *InterfacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfacesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterInterfaces(s)
	}
}

func (s *InterfacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitInterfaces(s)
	}
}

func (p *Dart2Parser) Interfaces() (localctx IInterfacesContext) {
	this := p
	_ = this

	localctx = NewInterfacesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Dart2ParserRULE_interfaces)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(800)
		p.Match(Dart2ParserT__36)
	}
	{
		p.SetState(801)
		p.TypeList()
	}

	return localctx
}

// IMixinApplicationClassContext is an interface to support dynamic dispatch.
type IMixinApplicationClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMixinApplicationClassContext differentiates from other interfaces.
	IsMixinApplicationClassContext()
}

type MixinApplicationClassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMixinApplicationClassContext() *MixinApplicationClassContext {
	var p = new(MixinApplicationClassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_mixinApplicationClass
	return p
}

func (*MixinApplicationClassContext) IsMixinApplicationClassContext() {}

func NewMixinApplicationClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MixinApplicationClassContext {
	var p = new(MixinApplicationClassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_mixinApplicationClass

	return p
}

func (s *MixinApplicationClassContext) GetParser() antlr.Parser { return s.parser }

func (s *MixinApplicationClassContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MixinApplicationClassContext) MixinApplication() IMixinApplicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMixinApplicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMixinApplicationContext)
}

func (s *MixinApplicationClassContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *MixinApplicationClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MixinApplicationClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MixinApplicationClassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterMixinApplicationClass(s)
	}
}

func (s *MixinApplicationClassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitMixinApplicationClass(s)
	}
}

func (p *Dart2Parser) MixinApplicationClass() (localctx IMixinApplicationClassContext) {
	this := p
	_ = this

	localctx = NewMixinApplicationClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Dart2ParserRULE_mixinApplicationClass)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(803)
		p.Identifier()
	}
	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__38 {
		{
			p.SetState(804)
			p.TypeParameters()
		}

	}
	{
		p.SetState(807)
		p.Match(Dart2ParserT__4)
	}
	{
		p.SetState(808)
		p.MixinApplication()
	}
	{
		p.SetState(809)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// IMixinApplicationContext is an interface to support dynamic dispatch.
type IMixinApplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMixinApplicationContext differentiates from other interfaces.
	IsMixinApplicationContext()
}

type MixinApplicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMixinApplicationContext() *MixinApplicationContext {
	var p = new(MixinApplicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_mixinApplication
	return p
}

func (*MixinApplicationContext) IsMixinApplicationContext() {}

func NewMixinApplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MixinApplicationContext {
	var p = new(MixinApplicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_mixinApplication

	return p
}

func (s *MixinApplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *MixinApplicationContext) Dtype() IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *MixinApplicationContext) Mixins() IMixinsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMixinsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMixinsContext)
}

func (s *MixinApplicationContext) Interfaces() IInterfacesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfacesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfacesContext)
}

func (s *MixinApplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MixinApplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MixinApplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterMixinApplication(s)
	}
}

func (s *MixinApplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitMixinApplication(s)
	}
}

func (p *Dart2Parser) MixinApplication() (localctx IMixinApplicationContext) {
	this := p
	_ = this

	localctx = NewMixinApplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Dart2ParserRULE_mixinApplication)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(811)
		p.Dtype()
	}
	{
		p.SetState(812)
		p.Mixins()
	}
	p.SetState(814)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__36 {
		{
			p.SetState(813)
			p.Interfaces()
		}

	}

	return localctx
}

// IEnumTypeContext is an interface to support dynamic dispatch.
type IEnumTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumTypeContext differentiates from other interfaces.
	IsEnumTypeContext()
}

type EnumTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumTypeContext() *EnumTypeContext {
	var p = new(EnumTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_enumType
	return p
}

func (*EnumTypeContext) IsEnumTypeContext() {}

func NewEnumTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumTypeContext {
	var p = new(EnumTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_enumType

	return p
}

func (s *EnumTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumTypeContext) Metadata() IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *EnumTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumTypeContext) AllEnumEntry() []IEnumEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumEntryContext)(nil)).Elem())
	var tst = make([]IEnumEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumEntryContext)
		}
	}

	return tst
}

func (s *EnumTypeContext) EnumEntry(i int) IEnumEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumEntryContext)
}

func (s *EnumTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterEnumType(s)
	}
}

func (s *EnumTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitEnumType(s)
	}
}

func (p *Dart2Parser) EnumType() (localctx IEnumTypeContext) {
	this := p
	_ = this

	localctx = NewEnumTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Dart2ParserRULE_enumType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.Metadata()
	}
	{
		p.SetState(817)
		p.Match(Dart2ParserT__37)
	}
	{
		p.SetState(818)
		p.Identifier()
	}
	{
		p.SetState(819)
		p.Match(Dart2ParserT__11)
	}
	{
		p.SetState(820)
		p.EnumEntry()
	}
	p.SetState(825)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(821)
				p.Match(Dart2ParserT__0)
			}
			{
				p.SetState(822)
				p.EnumEntry()
			}

		}
		p.SetState(827)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())
	}
	p.SetState(829)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__0 {
		{
			p.SetState(828)
			p.Match(Dart2ParserT__0)
		}

	}
	{
		p.SetState(831)
		p.Match(Dart2ParserT__12)
	}

	return localctx
}

// IEnumEntryContext is an interface to support dynamic dispatch.
type IEnumEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumEntryContext differentiates from other interfaces.
	IsEnumEntryContext()
}

type EnumEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumEntryContext() *EnumEntryContext {
	var p = new(EnumEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_enumEntry
	return p
}

func (*EnumEntryContext) IsEnumEntryContext() {}

func NewEnumEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumEntryContext {
	var p = new(EnumEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_enumEntry

	return p
}

func (s *EnumEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumEntryContext) Metadata() IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *EnumEntryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterEnumEntry(s)
	}
}

func (s *EnumEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitEnumEntry(s)
	}
}

func (p *Dart2Parser) EnumEntry() (localctx IEnumEntryContext) {
	this := p
	_ = this

	localctx = NewEnumEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Dart2ParserRULE_enumEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(833)
		p.Metadata()
	}
	{
		p.SetState(834)
		p.Identifier()
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) Metadata() IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *TypeParameterContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeParameterContext) Dtype() IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *Dart2Parser) TypeParameter() (localctx ITypeParameterContext) {
	this := p
	_ = this

	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Dart2ParserRULE_typeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(836)
		p.Metadata()
	}
	{
		p.SetState(837)
		p.Identifier()
	}
	p.SetState(840)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__35 {
		{
			p.SetState(838)
			p.Match(Dart2ParserT__35)
		}
		{
			p.SetState(839)
			p.Dtype()
		}

	}

	return localctx
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_typeParameters
	return p
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) AllTypeParameter() []ITypeParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem())
	var tst = make([]ITypeParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterContext)
		}
	}

	return tst
}

func (s *TypeParametersContext) TypeParameter(i int) ITypeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (p *Dart2Parser) TypeParameters() (localctx ITypeParametersContext) {
	this := p
	_ = this

	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Dart2ParserRULE_typeParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(842)
		p.Match(Dart2ParserT__38)
	}
	{
		p.SetState(843)
		p.TypeParameter()
	}
	p.SetState(848)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__0 {
		{
			p.SetState(844)
			p.Match(Dart2ParserT__0)
		}
		{
			p.SetState(845)
			p.TypeParameter()
		}

		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(851)
		p.Match(Dart2ParserT__39)
	}

	return localctx
}

// IMetadataContext is an interface to support dynamic dispatch.
type IMetadataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMetadataContext differentiates from other interfaces.
	IsMetadataContext()
}

type MetadataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMetadataContext() *MetadataContext {
	var p = new(MetadataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_metadata
	return p
}

func (*MetadataContext) IsMetadataContext() {}

func NewMetadataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetadataContext {
	var p = new(MetadataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_metadata

	return p
}

func (s *MetadataContext) GetParser() antlr.Parser { return s.parser }

func (s *MetadataContext) AllQualified() []IQualifiedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedContext)(nil)).Elem())
	var tst = make([]IQualifiedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedContext)
		}
	}

	return tst
}

func (s *MetadataContext) Qualified(i int) IQualifiedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedContext)
}

func (s *MetadataContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *MetadataContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MetadataContext) AllArguments() []IArgumentsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentsContext)(nil)).Elem())
	var tst = make([]IArgumentsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentsContext)
		}
	}

	return tst
}

func (s *MetadataContext) Arguments(i int) IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *MetadataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetadataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetadataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterMetadata(s)
	}
}

func (s *MetadataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitMetadata(s)
	}
}

func (p *Dart2Parser) Metadata() (localctx IMetadataContext) {
	this := p
	_ = this

	localctx = NewMetadataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Dart2ParserRULE_metadata)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(864)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(853)
				p.Match(Dart2ParserT__40)
			}
			{
				p.SetState(854)
				p.Qualified()
			}
			p.SetState(857)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Dart2ParserT__19 {
				{
					p.SetState(855)
					p.Match(Dart2ParserT__19)
				}
				{
					p.SetState(856)
					p.Identifier()
				}

			}
			p.SetState(860)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Dart2ParserT__13 {
				{
					p.SetState(859)
					p.Arguments()
				}

			}

		}
		p.SetState(866)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) AssignableExpression() IAssignableExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignableExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignableExpressionContext)
}

func (s *ExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *ExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) ConditionalExpression() IConditionalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *ExpressionContext) AllCascadeSection() []ICascadeSectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICascadeSectionContext)(nil)).Elem())
	var tst = make([]ICascadeSectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICascadeSectionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) CascadeSection(i int) ICascadeSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICascadeSectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICascadeSectionContext)
}

func (s *ExpressionContext) ThrowExpression() IThrowExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrowExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrowExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *Dart2Parser) Expression() (localctx IExpressionContext) {
	this := p
	_ = this

	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Dart2ParserRULE_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(867)
			p.AssignableExpression()
		}
		{
			p.SetState(868)
			p.AssignmentOperator()
		}
		{
			p.SetState(869)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(871)
			p.ConditionalExpression()
		}
		p.SetState(875)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Dart2ParserT__49 {
			{
				p.SetState(872)
				p.CascadeSection()
			}

			p.SetState(877)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(878)
			p.ThrowExpression()
		}

	}

	return localctx
}

// IExpressionWithoutCascadeContext is an interface to support dynamic dispatch.
type IExpressionWithoutCascadeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionWithoutCascadeContext differentiates from other interfaces.
	IsExpressionWithoutCascadeContext()
}

type ExpressionWithoutCascadeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionWithoutCascadeContext() *ExpressionWithoutCascadeContext {
	var p = new(ExpressionWithoutCascadeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_expressionWithoutCascade
	return p
}

func (*ExpressionWithoutCascadeContext) IsExpressionWithoutCascadeContext() {}

func NewExpressionWithoutCascadeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionWithoutCascadeContext {
	var p = new(ExpressionWithoutCascadeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_expressionWithoutCascade

	return p
}

func (s *ExpressionWithoutCascadeContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionWithoutCascadeContext) AssignableExpression() IAssignableExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignableExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignableExpressionContext)
}

func (s *ExpressionWithoutCascadeContext) AssignmentOperator() IAssignmentOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *ExpressionWithoutCascadeContext) ExpressionWithoutCascade() IExpressionWithoutCascadeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionWithoutCascadeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionWithoutCascadeContext)
}

func (s *ExpressionWithoutCascadeContext) ConditionalExpression() IConditionalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *ExpressionWithoutCascadeContext) ThrowExpressionWithoutCascade() IThrowExpressionWithoutCascadeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrowExpressionWithoutCascadeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrowExpressionWithoutCascadeContext)
}

func (s *ExpressionWithoutCascadeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionWithoutCascadeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionWithoutCascadeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterExpressionWithoutCascade(s)
	}
}

func (s *ExpressionWithoutCascadeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitExpressionWithoutCascade(s)
	}
}

func (p *Dart2Parser) ExpressionWithoutCascade() (localctx IExpressionWithoutCascadeContext) {
	this := p
	_ = this

	localctx = NewExpressionWithoutCascadeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Dart2ParserRULE_expressionWithoutCascade)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(887)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(881)
			p.AssignableExpression()
		}
		{
			p.SetState(882)
			p.AssignmentOperator()
		}
		{
			p.SetState(883)
			p.ExpressionWithoutCascade()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(885)
			p.ConditionalExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(886)
			p.ThrowExpressionWithoutCascade()
		}

	}

	return localctx
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (p *Dart2Parser) ExpressionList() (localctx IExpressionListContext) {
	this := p
	_ = this

	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Dart2ParserRULE_expressionList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(889)
		p.Expression()
	}
	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(890)
				p.Match(Dart2ParserT__0)
			}
			{
				p.SetState(891)
				p.Expression()
			}

		}
		p.SetState(896)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) ThisExpression() IThisExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThisExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThisExpressionContext)
}

func (s *PrimaryContext) UnconditionalAssignableSelector() IUnconditionalAssignableSelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnconditionalAssignableSelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnconditionalAssignableSelectorContext)
}

func (s *PrimaryContext) FunctionExpression() IFunctionExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionExpressionContext)
}

func (s *PrimaryContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrimaryContext) NayaExpression() INayaExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INayaExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INayaExpressionContext)
}

func (s *PrimaryContext) ConstObjectExpression() IConstObjectExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstObjectExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstObjectExpressionContext)
}

func (s *PrimaryContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (p *Dart2Parser) Primary() (localctx IPrimaryContext) {
	this := p
	_ = this

	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Dart2ParserRULE_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(909)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(897)
			p.ThisExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(898)
			p.Match(Dart2ParserT__33)
		}
		{
			p.SetState(899)
			p.UnconditionalAssignableSelector()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(900)
			p.FunctionExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(901)
			p.Literal()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(902)
			p.Identifier()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(903)
			p.NayaExpression()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(904)
			p.ConstObjectExpression()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(905)
			p.Match(Dart2ParserT__13)
		}
		{
			p.SetState(906)
			p.Expression()
		}
		{
			p.SetState(907)
			p.Match(Dart2ParserT__14)
		}

	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NullLiteral() INullLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullLiteralContext)
}

func (s *LiteralContext) BooleanLiteral() IBooleanLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LiteralContext) NumericLiteral() INumericLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *LiteralContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralContext) SymbolLiteral() ISymbolLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolLiteralContext)
}

func (s *LiteralContext) MapLiteral() IMapLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *LiteralContext) ListLiteral() IListLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *Dart2Parser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Dart2ParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(918)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(911)
			p.NullLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(912)
			p.BooleanLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(913)
			p.NumericLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(914)
			p.StringLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(915)
			p.SymbolLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(916)
			p.MapLiteral()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(917)
			p.ListLiteral()
		}

	}

	return localctx
}

// INullLiteralContext is an interface to support dynamic dispatch.
type INullLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNullLiteralContext differentiates from other interfaces.
	IsNullLiteralContext()
}

type NullLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullLiteralContext() *NullLiteralContext {
	var p = new(NullLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_nullLiteral
	return p
}

func (*NullLiteralContext) IsNullLiteralContext() {}

func NewNullLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullLiteralContext {
	var p = new(NullLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_nullLiteral

	return p
}

func (s *NullLiteralContext) GetParser() antlr.Parser { return s.parser }
func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

func (p *Dart2Parser) NullLiteral() (localctx INullLiteralContext) {
	this := p
	_ = this

	localctx = NewNullLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Dart2ParserRULE_nullLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(920)
		p.Match(Dart2ParserT__41)
	}

	return localctx
}

// INumericLiteralContext is an interface to support dynamic dispatch.
type INumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericLiteralContext differentiates from other interfaces.
	IsNumericLiteralContext()
}

type NumericLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericLiteralContext() *NumericLiteralContext {
	var p = new(NumericLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_numericLiteral
	return p
}

func (*NumericLiteralContext) IsNumericLiteralContext() {}

func NewNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_numericLiteral

	return p
}

func (s *NumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericLiteralContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Dart2ParserNUMBER, 0)
}

func (s *NumericLiteralContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(Dart2ParserHEX_NUMBER, 0)
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (p *Dart2Parser) NumericLiteral() (localctx INumericLiteralContext) {
	this := p
	_ = this

	localctx = NewNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, Dart2ParserRULE_numericLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(922)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Dart2ParserNUMBER || _la == Dart2ParserHEX_NUMBER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }
func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *Dart2Parser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	this := p
	_ = this

	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, Dart2ParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(924)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Dart2ParserT__42 || _la == Dart2ParserT__43) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllMultiLineString() []antlr.TerminalNode {
	return s.GetTokens(Dart2ParserMultiLineString)
}

func (s *StringLiteralContext) MultiLineString(i int) antlr.TerminalNode {
	return s.GetToken(Dart2ParserMultiLineString, i)
}

func (s *StringLiteralContext) AllSingleLineString() []antlr.TerminalNode {
	return s.GetTokens(Dart2ParserSingleLineString)
}

func (s *StringLiteralContext) SingleLineString(i int) antlr.TerminalNode {
	return s.GetToken(Dart2ParserSingleLineString, i)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *Dart2Parser) StringLiteral() (localctx IStringLiteralContext) {
	this := p
	_ = this

	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, Dart2ParserRULE_stringLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(927)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Dart2ParserSingleLineString || _la == Dart2ParserMultiLineString {
		{
			p.SetState(926)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Dart2ParserSingleLineString || _la == Dart2ParserMultiLineString) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(929)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStringInterpolationContext is an interface to support dynamic dispatch.
type IStringInterpolationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringInterpolationContext differentiates from other interfaces.
	IsStringInterpolationContext()
}

type StringInterpolationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringInterpolationContext() *StringInterpolationContext {
	var p = new(StringInterpolationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_stringInterpolation
	return p
}

func (*StringInterpolationContext) IsStringInterpolationContext() {}

func NewStringInterpolationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringInterpolationContext {
	var p = new(StringInterpolationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_stringInterpolation

	return p
}

func (s *StringInterpolationContext) GetParser() antlr.Parser { return s.parser }

func (s *StringInterpolationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringInterpolationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StringInterpolationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringInterpolationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringInterpolationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterStringInterpolation(s)
	}
}

func (s *StringInterpolationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitStringInterpolation(s)
	}
}

func (p *Dart2Parser) StringInterpolation() (localctx IStringInterpolationContext) {
	this := p
	_ = this

	localctx = NewStringInterpolationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, Dart2ParserRULE_stringInterpolation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(937)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__44:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(931)
			p.Match(Dart2ParserT__44)
		}
		{
			p.SetState(932)
			p.Identifier()
		}

	case Dart2ParserT__45:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(933)
			p.Match(Dart2ParserT__45)
		}
		{
			p.SetState(934)
			p.Expression()
		}
		{
			p.SetState(935)
			p.Match(Dart2ParserT__12)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISymbolLiteralContext is an interface to support dynamic dispatch.
type ISymbolLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolLiteralContext differentiates from other interfaces.
	IsSymbolLiteralContext()
}

type SymbolLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolLiteralContext() *SymbolLiteralContext {
	var p = new(SymbolLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_symbolLiteral
	return p
}

func (*SymbolLiteralContext) IsSymbolLiteralContext() {}

func NewSymbolLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolLiteralContext {
	var p = new(SymbolLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_symbolLiteral

	return p
}

func (s *SymbolLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolLiteralContext) Operator_() IOperator_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperator_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperator_Context)
}

func (s *SymbolLiteralContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *SymbolLiteralContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SymbolLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterSymbolLiteral(s)
	}
}

func (s *SymbolLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitSymbolLiteral(s)
	}
}

func (p *Dart2Parser) SymbolLiteral() (localctx ISymbolLiteralContext) {
	this := p
	_ = this

	localctx = NewSymbolLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, Dart2ParserRULE_symbolLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(939)
		p.Match(Dart2ParserT__46)
	}
	p.SetState(949)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__27, Dart2ParserT__28, Dart2ParserT__29, Dart2ParserT__30, Dart2ParserT__38, Dart2ParserT__39, Dart2ParserT__67, Dart2ParserT__68, Dart2ParserT__69, Dart2ParserT__70, Dart2ParserT__71, Dart2ParserT__72, Dart2ParserT__73, Dart2ParserT__74, Dart2ParserT__75, Dart2ParserT__76, Dart2ParserT__77, Dart2ParserT__78, Dart2ParserT__79, Dart2ParserT__80:
		{
			p.SetState(940)
			p.Operator_()
		}

	case Dart2ParserIDENTIFIER:
		{
			p.SetState(941)
			p.Identifier()
		}
		p.SetState(946)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(942)
					p.Match(Dart2ParserT__0)
				}
				{
					p.SetState(943)
					p.Identifier()
				}

			}
			p.SetState(948)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IListLiteralContext is an interface to support dynamic dispatch.
type IListLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListLiteralContext differentiates from other interfaces.
	IsListLiteralContext()
}

type ListLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListLiteralContext() *ListLiteralContext {
	var p = new(ListLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_listLiteral
	return p
}

func (*ListLiteralContext) IsListLiteralContext() {}

func NewListLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListLiteralContext {
	var p = new(ListLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_listLiteral

	return p
}

func (s *ListLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ListLiteralContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ListLiteralContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ListLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterListLiteral(s)
	}
}

func (s *ListLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitListLiteral(s)
	}
}

func (p *Dart2Parser) ListLiteral() (localctx IListLiteralContext) {
	this := p
	_ = this

	localctx = NewListLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, Dart2ParserRULE_listLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__2 {
		{
			p.SetState(951)
			p.Match(Dart2ParserT__2)
		}

	}
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__38 {
		{
			p.SetState(954)
			p.TypeArguments()
		}

	}
	{
		p.SetState(957)
		p.Match(Dart2ParserT__15)
	}
	p.SetState(962)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__2)|(1<<Dart2ParserT__11)|(1<<Dart2ParserT__13)|(1<<Dart2ParserT__15)|(1<<Dart2ParserT__18)|(1<<Dart2ParserT__27))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Dart2ParserT__33-34))|(1<<(Dart2ParserT__38-34))|(1<<(Dart2ParserT__41-34))|(1<<(Dart2ParserT__42-34))|(1<<(Dart2ParserT__43-34))|(1<<(Dart2ParserT__46-34))|(1<<(Dart2ParserT__47-34))|(1<<(Dart2ParserT__48-34)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(Dart2ParserT__76-77))|(1<<(Dart2ParserT__81-77))|(1<<(Dart2ParserT__82-77))|(1<<(Dart2ParserT__83-77))|(1<<(Dart2ParserT__84-77)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(Dart2ParserNUMBER-119))|(1<<(Dart2ParserHEX_NUMBER-119))|(1<<(Dart2ParserSingleLineString-119))|(1<<(Dart2ParserMultiLineString-119))|(1<<(Dart2ParserIDENTIFIER-119)))) != 0) {
		{
			p.SetState(958)
			p.ExpressionList()
		}
		p.SetState(960)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__0 {
			{
				p.SetState(959)
				p.Match(Dart2ParserT__0)
			}

		}

	}
	{
		p.SetState(964)
		p.Match(Dart2ParserT__16)
	}

	return localctx
}

// IMapLiteralContext is an interface to support dynamic dispatch.
type IMapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapLiteralContext differentiates from other interfaces.
	IsMapLiteralContext()
}

type MapLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapLiteralContext() *MapLiteralContext {
	var p = new(MapLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_mapLiteral
	return p
}

func (*MapLiteralContext) IsMapLiteralContext() {}

func NewMapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralContext {
	var p = new(MapLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_mapLiteral

	return p
}

func (s *MapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *MapLiteralContext) AllMapLiteralEntry() []IMapLiteralEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMapLiteralEntryContext)(nil)).Elem())
	var tst = make([]IMapLiteralEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMapLiteralEntryContext)
		}
	}

	return tst
}

func (s *MapLiteralContext) MapLiteralEntry(i int) IMapLiteralEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapLiteralEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMapLiteralEntryContext)
}

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterMapLiteral(s)
	}
}

func (s *MapLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitMapLiteral(s)
	}
}

func (p *Dart2Parser) MapLiteral() (localctx IMapLiteralContext) {
	this := p
	_ = this

	localctx = NewMapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, Dart2ParserRULE_mapLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(967)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__2 {
		{
			p.SetState(966)
			p.Match(Dart2ParserT__2)
		}

	}
	p.SetState(970)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__38 {
		{
			p.SetState(969)
			p.TypeArguments()
		}

	}
	{
		p.SetState(972)
		p.Match(Dart2ParserT__11)
	}
	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__2)|(1<<Dart2ParserT__11)|(1<<Dart2ParserT__13)|(1<<Dart2ParserT__15)|(1<<Dart2ParserT__18)|(1<<Dart2ParserT__27))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Dart2ParserT__33-34))|(1<<(Dart2ParserT__38-34))|(1<<(Dart2ParserT__41-34))|(1<<(Dart2ParserT__42-34))|(1<<(Dart2ParserT__43-34))|(1<<(Dart2ParserT__46-34))|(1<<(Dart2ParserT__47-34))|(1<<(Dart2ParserT__48-34)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(Dart2ParserT__76-77))|(1<<(Dart2ParserT__81-77))|(1<<(Dart2ParserT__82-77))|(1<<(Dart2ParserT__83-77))|(1<<(Dart2ParserT__84-77)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(Dart2ParserNUMBER-119))|(1<<(Dart2ParserHEX_NUMBER-119))|(1<<(Dart2ParserSingleLineString-119))|(1<<(Dart2ParserMultiLineString-119))|(1<<(Dart2ParserIDENTIFIER-119)))) != 0) {
		{
			p.SetState(973)
			p.MapLiteralEntry()
		}
		p.SetState(978)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(974)
					p.Match(Dart2ParserT__0)
				}
				{
					p.SetState(975)
					p.MapLiteralEntry()
				}

			}
			p.SetState(980)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())
		}
		p.SetState(982)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__0 {
			{
				p.SetState(981)
				p.Match(Dart2ParserT__0)
			}

		}

	}
	{
		p.SetState(986)
		p.Match(Dart2ParserT__12)
	}

	return localctx
}

// IMapLiteralEntryContext is an interface to support dynamic dispatch.
type IMapLiteralEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapLiteralEntryContext differentiates from other interfaces.
	IsMapLiteralEntryContext()
}

type MapLiteralEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapLiteralEntryContext() *MapLiteralEntryContext {
	var p = new(MapLiteralEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_mapLiteralEntry
	return p
}

func (*MapLiteralEntryContext) IsMapLiteralEntryContext() {}

func NewMapLiteralEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralEntryContext {
	var p = new(MapLiteralEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_mapLiteralEntry

	return p
}

func (s *MapLiteralEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralEntryContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *MapLiteralEntryContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapLiteralEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapLiteralEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterMapLiteralEntry(s)
	}
}

func (s *MapLiteralEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitMapLiteralEntry(s)
	}
}

func (p *Dart2Parser) MapLiteralEntry() (localctx IMapLiteralEntryContext) {
	this := p
	_ = this

	localctx = NewMapLiteralEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, Dart2ParserRULE_mapLiteralEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(988)
		p.Expression()
	}
	{
		p.SetState(989)
		p.Match(Dart2ParserT__20)
	}
	{
		p.SetState(990)
		p.Expression()
	}

	return localctx
}

// IThrowExpressionContext is an interface to support dynamic dispatch.
type IThrowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrowExpressionContext differentiates from other interfaces.
	IsThrowExpressionContext()
}

type ThrowExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowExpressionContext() *ThrowExpressionContext {
	var p = new(ThrowExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_throwExpression
	return p
}

func (*ThrowExpressionContext) IsThrowExpressionContext() {}

func NewThrowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowExpressionContext {
	var p = new(ThrowExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_throwExpression

	return p
}

func (s *ThrowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ThrowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterThrowExpression(s)
	}
}

func (s *ThrowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitThrowExpression(s)
	}
}

func (p *Dart2Parser) ThrowExpression() (localctx IThrowExpressionContext) {
	this := p
	_ = this

	localctx = NewThrowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, Dart2ParserRULE_throwExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(992)
		p.Match(Dart2ParserT__47)
	}
	{
		p.SetState(993)
		p.Expression()
	}

	return localctx
}

// IThrowExpressionWithoutCascadeContext is an interface to support dynamic dispatch.
type IThrowExpressionWithoutCascadeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrowExpressionWithoutCascadeContext differentiates from other interfaces.
	IsThrowExpressionWithoutCascadeContext()
}

type ThrowExpressionWithoutCascadeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowExpressionWithoutCascadeContext() *ThrowExpressionWithoutCascadeContext {
	var p = new(ThrowExpressionWithoutCascadeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_throwExpressionWithoutCascade
	return p
}

func (*ThrowExpressionWithoutCascadeContext) IsThrowExpressionWithoutCascadeContext() {}

func NewThrowExpressionWithoutCascadeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowExpressionWithoutCascadeContext {
	var p = new(ThrowExpressionWithoutCascadeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_throwExpressionWithoutCascade

	return p
}

func (s *ThrowExpressionWithoutCascadeContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowExpressionWithoutCascadeContext) ExpressionWithoutCascade() IExpressionWithoutCascadeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionWithoutCascadeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionWithoutCascadeContext)
}

func (s *ThrowExpressionWithoutCascadeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowExpressionWithoutCascadeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowExpressionWithoutCascadeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterThrowExpressionWithoutCascade(s)
	}
}

func (s *ThrowExpressionWithoutCascadeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitThrowExpressionWithoutCascade(s)
	}
}

func (p *Dart2Parser) ThrowExpressionWithoutCascade() (localctx IThrowExpressionWithoutCascadeContext) {
	this := p
	_ = this

	localctx = NewThrowExpressionWithoutCascadeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, Dart2ParserRULE_throwExpressionWithoutCascade)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(995)
		p.Match(Dart2ParserT__47)
	}
	{
		p.SetState(996)
		p.ExpressionWithoutCascade()
	}

	return localctx
}

// IFunctionExpressionContext is an interface to support dynamic dispatch.
type IFunctionExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionExpressionContext differentiates from other interfaces.
	IsFunctionExpressionContext()
}

type FunctionExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionExpressionContext() *FunctionExpressionContext {
	var p = new(FunctionExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_functionExpression
	return p
}

func (*FunctionExpressionContext) IsFunctionExpressionContext() {}

func NewFunctionExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionExpressionContext {
	var p = new(FunctionExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_functionExpression

	return p
}

func (s *FunctionExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionExpressionContext) FormalParameterPart() IFormalParameterPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterPartContext)
}

func (s *FunctionExpressionContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterFunctionExpression(s)
	}
}

func (s *FunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitFunctionExpression(s)
	}
}

func (p *Dart2Parser) FunctionExpression() (localctx IFunctionExpressionContext) {
	this := p
	_ = this

	localctx = NewFunctionExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, Dart2ParserRULE_functionExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(998)
		p.FormalParameterPart()
	}
	{
		p.SetState(999)
		p.FunctionBody()
	}

	return localctx
}

// IThisExpressionContext is an interface to support dynamic dispatch.
type IThisExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThisExpressionContext differentiates from other interfaces.
	IsThisExpressionContext()
}

type ThisExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThisExpressionContext() *ThisExpressionContext {
	var p = new(ThisExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_thisExpression
	return p
}

func (*ThisExpressionContext) IsThisExpressionContext() {}

func NewThisExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThisExpressionContext {
	var p = new(ThisExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_thisExpression

	return p
}

func (s *ThisExpressionContext) GetParser() antlr.Parser { return s.parser }
func (s *ThisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterThisExpression(s)
	}
}

func (s *ThisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitThisExpression(s)
	}
}

func (p *Dart2Parser) ThisExpression() (localctx IThisExpressionContext) {
	this := p
	_ = this

	localctx = NewThisExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, Dart2ParserRULE_thisExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1001)
		p.Match(Dart2ParserT__18)
	}

	return localctx
}

// INayaExpressionContext is an interface to support dynamic dispatch.
type INayaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNayaExpressionContext differentiates from other interfaces.
	IsNayaExpressionContext()
}

type NayaExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNayaExpressionContext() *NayaExpressionContext {
	var p = new(NayaExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_nayaExpression
	return p
}

func (*NayaExpressionContext) IsNayaExpressionContext() {}

func NewNayaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NayaExpressionContext {
	var p = new(NayaExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_nayaExpression

	return p
}

func (s *NayaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NayaExpressionContext) Dtype() IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *NayaExpressionContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *NayaExpressionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NayaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NayaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NayaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterNayaExpression(s)
	}
}

func (s *NayaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitNayaExpression(s)
	}
}

func (p *Dart2Parser) NayaExpression() (localctx INayaExpressionContext) {
	this := p
	_ = this

	localctx = NewNayaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, Dart2ParserRULE_nayaExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1003)
		p.Match(Dart2ParserT__48)
	}
	{
		p.SetState(1004)
		p.Dtype()
	}
	p.SetState(1007)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__19 {
		{
			p.SetState(1005)
			p.Match(Dart2ParserT__19)
		}
		{
			p.SetState(1006)
			p.Identifier()
		}

	}
	{
		p.SetState(1009)
		p.Arguments()
	}

	return localctx
}

// IConstObjectExpressionContext is an interface to support dynamic dispatch.
type IConstObjectExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstObjectExpressionContext differentiates from other interfaces.
	IsConstObjectExpressionContext()
}

type ConstObjectExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstObjectExpressionContext() *ConstObjectExpressionContext {
	var p = new(ConstObjectExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_constObjectExpression
	return p
}

func (*ConstObjectExpressionContext) IsConstObjectExpressionContext() {}

func NewConstObjectExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstObjectExpressionContext {
	var p = new(ConstObjectExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_constObjectExpression

	return p
}

func (s *ConstObjectExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstObjectExpressionContext) Dtype() IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *ConstObjectExpressionContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ConstObjectExpressionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstObjectExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstObjectExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstObjectExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterConstObjectExpression(s)
	}
}

func (s *ConstObjectExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitConstObjectExpression(s)
	}
}

func (p *Dart2Parser) ConstObjectExpression() (localctx IConstObjectExpressionContext) {
	this := p
	_ = this

	localctx = NewConstObjectExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, Dart2ParserRULE_constObjectExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1011)
		p.Match(Dart2ParserT__2)
	}
	{
		p.SetState(1012)
		p.Dtype()
	}
	p.SetState(1015)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__19 {
		{
			p.SetState(1013)
			p.Match(Dart2ParserT__19)
		}
		{
			p.SetState(1014)
			p.Identifier()
		}

	}
	{
		p.SetState(1017)
		p.Arguments()
	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitArguments(s)
	}
}

func (p *Dart2Parser) Arguments() (localctx IArgumentsContext) {
	this := p
	_ = this

	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, Dart2ParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1019)
		p.Match(Dart2ParserT__13)
	}
	p.SetState(1024)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__2)|(1<<Dart2ParserT__11)|(1<<Dart2ParserT__13)|(1<<Dart2ParserT__15)|(1<<Dart2ParserT__18)|(1<<Dart2ParserT__27))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Dart2ParserT__33-34))|(1<<(Dart2ParserT__38-34))|(1<<(Dart2ParserT__41-34))|(1<<(Dart2ParserT__42-34))|(1<<(Dart2ParserT__43-34))|(1<<(Dart2ParserT__46-34))|(1<<(Dart2ParserT__47-34))|(1<<(Dart2ParserT__48-34)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(Dart2ParserT__76-77))|(1<<(Dart2ParserT__81-77))|(1<<(Dart2ParserT__82-77))|(1<<(Dart2ParserT__83-77))|(1<<(Dart2ParserT__84-77)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(Dart2ParserNUMBER-119))|(1<<(Dart2ParserHEX_NUMBER-119))|(1<<(Dart2ParserSingleLineString-119))|(1<<(Dart2ParserMultiLineString-119))|(1<<(Dart2ParserIDENTIFIER-119)))) != 0) {
		{
			p.SetState(1020)
			p.ArgumentList()
		}
		p.SetState(1022)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__0 {
			{
				p.SetState(1021)
				p.Match(Dart2ParserT__0)
			}

		}

	}
	{
		p.SetState(1026)
		p.Match(Dart2ParserT__14)
	}

	return localctx
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_argumentList
	return p
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllNamedArgument() []INamedArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedArgumentContext)(nil)).Elem())
	var tst = make([]INamedArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedArgumentContext)
		}
	}

	return tst
}

func (s *ArgumentListContext) NamedArgument(i int) INamedArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedArgumentContext)
}

func (s *ArgumentListContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *Dart2Parser) ArgumentList() (localctx IArgumentListContext) {
	this := p
	_ = this

	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, Dart2ParserRULE_argumentList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1044)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1028)
			p.NamedArgument()
		}
		p.SetState(1033)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1029)
					p.Match(Dart2ParserT__0)
				}
				{
					p.SetState(1030)
					p.NamedArgument()
				}

			}
			p.SetState(1035)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1036)
			p.ExpressionList()
		}
		p.SetState(1041)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1037)
					p.Match(Dart2ParserT__0)
				}
				{
					p.SetState(1038)
					p.NamedArgument()
				}

			}
			p.SetState(1043)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext())
		}

	}

	return localctx
}

// INamedArgumentContext is an interface to support dynamic dispatch.
type INamedArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedArgumentContext differentiates from other interfaces.
	IsNamedArgumentContext()
}

type NamedArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedArgumentContext() *NamedArgumentContext {
	var p = new(NamedArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_namedArgument
	return p
}

func (*NamedArgumentContext) IsNamedArgumentContext() {}

func NewNamedArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgumentContext {
	var p = new(NamedArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_namedArgument

	return p
}

func (s *NamedArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgumentContext) Label() ILabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *NamedArgumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterNamedArgument(s)
	}
}

func (s *NamedArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitNamedArgument(s)
	}
}

func (p *Dart2Parser) NamedArgument() (localctx INamedArgumentContext) {
	this := p
	_ = this

	localctx = NewNamedArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, Dart2ParserRULE_namedArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1046)
		p.Label()
	}
	{
		p.SetState(1047)
		p.Expression()
	}

	return localctx
}

// ICascadeSectionContext is an interface to support dynamic dispatch.
type ICascadeSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCascadeSectionContext differentiates from other interfaces.
	IsCascadeSectionContext()
}

type CascadeSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCascadeSectionContext() *CascadeSectionContext {
	var p = new(CascadeSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_cascadeSection
	return p
}

func (*CascadeSectionContext) IsCascadeSectionContext() {}

func NewCascadeSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CascadeSectionContext {
	var p = new(CascadeSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_cascadeSection

	return p
}

func (s *CascadeSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *CascadeSectionContext) CascadeSelector() ICascadeSelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICascadeSelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICascadeSelectorContext)
}

func (s *CascadeSectionContext) AllAssignableSelector() []IAssignableSelectorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignableSelectorContext)(nil)).Elem())
	var tst = make([]IAssignableSelectorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignableSelectorContext)
		}
	}

	return tst
}

func (s *CascadeSectionContext) AssignableSelector(i int) IAssignableSelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignableSelectorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignableSelectorContext)
}

func (s *CascadeSectionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *CascadeSectionContext) ExpressionWithoutCascade() IExpressionWithoutCascadeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionWithoutCascadeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionWithoutCascadeContext)
}

func (s *CascadeSectionContext) AllArgumentPart() []IArgumentPartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentPartContext)(nil)).Elem())
	var tst = make([]IArgumentPartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentPartContext)
		}
	}

	return tst
}

func (s *CascadeSectionContext) ArgumentPart(i int) IArgumentPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentPartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentPartContext)
}

func (s *CascadeSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CascadeSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CascadeSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterCascadeSection(s)
	}
}

func (s *CascadeSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitCascadeSection(s)
	}
}

func (p *Dart2Parser) CascadeSection() (localctx ICascadeSectionContext) {
	this := p
	_ = this

	localctx = NewCascadeSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, Dart2ParserRULE_cascadeSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1049)
		p.Match(Dart2ParserT__49)
	}

	{
		p.SetState(1050)
		p.CascadeSelector()
	}
	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__13 || _la == Dart2ParserT__38 {
		{
			p.SetState(1051)
			p.ArgumentPart()
		}

		p.SetState(1056)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	p.SetState(1066)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__15 || _la == Dart2ParserT__19 || _la == Dart2ParserT__85 {
		{
			p.SetState(1057)
			p.AssignableSelector()
		}
		p.SetState(1061)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Dart2ParserT__13 || _la == Dart2ParserT__38 {
			{
				p.SetState(1058)
				p.ArgumentPart()
			}

			p.SetState(1063)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(1068)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1072)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__4 || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(Dart2ParserT__50-51))|(1<<(Dart2ParserT__51-51))|(1<<(Dart2ParserT__52-51))|(1<<(Dart2ParserT__53-51))|(1<<(Dart2ParserT__54-51))|(1<<(Dart2ParserT__55-51))|(1<<(Dart2ParserT__56-51))|(1<<(Dart2ParserT__57-51))|(1<<(Dart2ParserT__58-51))|(1<<(Dart2ParserT__59-51))|(1<<(Dart2ParserT__60-51))|(1<<(Dart2ParserT__61-51)))) != 0) {
		{
			p.SetState(1069)
			p.AssignmentOperator()
		}
		{
			p.SetState(1070)
			p.ExpressionWithoutCascade()
		}

	}

	return localctx
}

// ICascadeSelectorContext is an interface to support dynamic dispatch.
type ICascadeSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCascadeSelectorContext differentiates from other interfaces.
	IsCascadeSelectorContext()
}

type CascadeSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCascadeSelectorContext() *CascadeSelectorContext {
	var p = new(CascadeSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_cascadeSelector
	return p
}

func (*CascadeSelectorContext) IsCascadeSelectorContext() {}

func NewCascadeSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CascadeSelectorContext {
	var p = new(CascadeSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_cascadeSelector

	return p
}

func (s *CascadeSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *CascadeSelectorContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CascadeSelectorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CascadeSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CascadeSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CascadeSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterCascadeSelector(s)
	}
}

func (s *CascadeSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitCascadeSelector(s)
	}
}

func (p *Dart2Parser) CascadeSelector() (localctx ICascadeSelectorContext) {
	this := p
	_ = this

	localctx = NewCascadeSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, Dart2ParserRULE_cascadeSelector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1079)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1074)
			p.Match(Dart2ParserT__15)
		}
		{
			p.SetState(1075)
			p.Expression()
		}
		{
			p.SetState(1076)
			p.Match(Dart2ParserT__16)
		}

	case Dart2ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1078)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentPartContext is an interface to support dynamic dispatch.
type IArgumentPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentPartContext differentiates from other interfaces.
	IsArgumentPartContext()
}

type ArgumentPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentPartContext() *ArgumentPartContext {
	var p = new(ArgumentPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_argumentPart
	return p
}

func (*ArgumentPartContext) IsArgumentPartContext() {}

func NewArgumentPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentPartContext {
	var p = new(ArgumentPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_argumentPart

	return p
}

func (s *ArgumentPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentPartContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ArgumentPartContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ArgumentPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterArgumentPart(s)
	}
}

func (s *ArgumentPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitArgumentPart(s)
	}
}

func (p *Dart2Parser) ArgumentPart() (localctx IArgumentPartContext) {
	this := p
	_ = this

	localctx = NewArgumentPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, Dart2ParserRULE_argumentPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1082)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__38 {
		{
			p.SetState(1081)
			p.TypeArguments()
		}

	}
	{
		p.SetState(1084)
		p.Arguments()
	}

	return localctx
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_assignmentOperator
	return p
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) CompoundAssignmentOperator() ICompoundAssignmentOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundAssignmentOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundAssignmentOperatorContext)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitAssignmentOperator(s)
	}
}

func (p *Dart2Parser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	this := p
	_ = this

	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, Dart2ParserRULE_assignmentOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1088)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__4:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1086)
			p.Match(Dart2ParserT__4)
		}

	case Dart2ParserT__50, Dart2ParserT__51, Dart2ParserT__52, Dart2ParserT__53, Dart2ParserT__54, Dart2ParserT__55, Dart2ParserT__56, Dart2ParserT__57, Dart2ParserT__58, Dart2ParserT__59, Dart2ParserT__60, Dart2ParserT__61:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1087)
			p.CompoundAssignmentOperator()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICompoundAssignmentOperatorContext is an interface to support dynamic dispatch.
type ICompoundAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompoundAssignmentOperatorContext differentiates from other interfaces.
	IsCompoundAssignmentOperatorContext()
}

type CompoundAssignmentOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundAssignmentOperatorContext() *CompoundAssignmentOperatorContext {
	var p = new(CompoundAssignmentOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_compoundAssignmentOperator
	return p
}

func (*CompoundAssignmentOperatorContext) IsCompoundAssignmentOperatorContext() {}

func NewCompoundAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundAssignmentOperatorContext {
	var p = new(CompoundAssignmentOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_compoundAssignmentOperator

	return p
}

func (s *CompoundAssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *CompoundAssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundAssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundAssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterCompoundAssignmentOperator(s)
	}
}

func (s *CompoundAssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitCompoundAssignmentOperator(s)
	}
}

func (p *Dart2Parser) CompoundAssignmentOperator() (localctx ICompoundAssignmentOperatorContext) {
	this := p
	_ = this

	localctx = NewCompoundAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, Dart2ParserRULE_compoundAssignmentOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1090)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(Dart2ParserT__50-51))|(1<<(Dart2ParserT__51-51))|(1<<(Dart2ParserT__52-51))|(1<<(Dart2ParserT__53-51))|(1<<(Dart2ParserT__54-51))|(1<<(Dart2ParserT__55-51))|(1<<(Dart2ParserT__56-51))|(1<<(Dart2ParserT__57-51))|(1<<(Dart2ParserT__58-51))|(1<<(Dart2ParserT__59-51))|(1<<(Dart2ParserT__60-51))|(1<<(Dart2ParserT__61-51)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IConditionalExpressionContext is an interface to support dynamic dispatch.
type IConditionalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionalExpressionContext differentiates from other interfaces.
	IsConditionalExpressionContext()
}

type ConditionalExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalExpressionContext() *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_conditionalExpression
	return p
}

func (*ConditionalExpressionContext) IsConditionalExpressionContext() {}

func NewConditionalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_conditionalExpression

	return p
}

func (s *ConditionalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalExpressionContext) IfNullExpression() IIfNullExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfNullExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfNullExpressionContext)
}

func (s *ConditionalExpressionContext) AllExpressionWithoutCascade() []IExpressionWithoutCascadeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionWithoutCascadeContext)(nil)).Elem())
	var tst = make([]IExpressionWithoutCascadeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionWithoutCascadeContext)
		}
	}

	return tst
}

func (s *ConditionalExpressionContext) ExpressionWithoutCascade(i int) IExpressionWithoutCascadeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionWithoutCascadeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionWithoutCascadeContext)
}

func (s *ConditionalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterConditionalExpression(s)
	}
}

func (s *ConditionalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitConditionalExpression(s)
	}
}

func (p *Dart2Parser) ConditionalExpression() (localctx IConditionalExpressionContext) {
	this := p
	_ = this

	localctx = NewConditionalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, Dart2ParserRULE_conditionalExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1092)
		p.IfNullExpression()
	}
	p.SetState(1098)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__62 {
		{
			p.SetState(1093)
			p.Match(Dart2ParserT__62)
		}
		{
			p.SetState(1094)
			p.ExpressionWithoutCascade()
		}
		{
			p.SetState(1095)
			p.Match(Dart2ParserT__20)
		}
		{
			p.SetState(1096)
			p.ExpressionWithoutCascade()
		}

	}

	return localctx
}

// IIfNullExpressionContext is an interface to support dynamic dispatch.
type IIfNullExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfNullExpressionContext differentiates from other interfaces.
	IsIfNullExpressionContext()
}

type IfNullExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNullExpressionContext() *IfNullExpressionContext {
	var p = new(IfNullExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_ifNullExpression
	return p
}

func (*IfNullExpressionContext) IsIfNullExpressionContext() {}

func NewIfNullExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNullExpressionContext {
	var p = new(IfNullExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_ifNullExpression

	return p
}

func (s *IfNullExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNullExpressionContext) AllLogicalOrExpression() []ILogicalOrExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILogicalOrExpressionContext)(nil)).Elem())
	var tst = make([]ILogicalOrExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILogicalOrExpressionContext)
		}
	}

	return tst
}

func (s *IfNullExpressionContext) LogicalOrExpression(i int) ILogicalOrExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogicalOrExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILogicalOrExpressionContext)
}

func (s *IfNullExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNullExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNullExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterIfNullExpression(s)
	}
}

func (s *IfNullExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitIfNullExpression(s)
	}
}

func (p *Dart2Parser) IfNullExpression() (localctx IIfNullExpressionContext) {
	this := p
	_ = this

	localctx = NewIfNullExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, Dart2ParserRULE_ifNullExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1100)
		p.LogicalOrExpression()
	}
	p.SetState(1105)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__63 {
		{
			p.SetState(1101)
			p.Match(Dart2ParserT__63)
		}
		{
			p.SetState(1102)
			p.LogicalOrExpression()
		}

		p.SetState(1107)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILogicalOrExpressionContext is an interface to support dynamic dispatch.
type ILogicalOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogicalOrExpressionContext differentiates from other interfaces.
	IsLogicalOrExpressionContext()
}

type LogicalOrExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalOrExpressionContext() *LogicalOrExpressionContext {
	var p = new(LogicalOrExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_logicalOrExpression
	return p
}

func (*LogicalOrExpressionContext) IsLogicalOrExpressionContext() {}

func NewLogicalOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOrExpressionContext {
	var p = new(LogicalOrExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_logicalOrExpression

	return p
}

func (s *LogicalOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOrExpressionContext) AllLogicalAndExpression() []ILogicalAndExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILogicalAndExpressionContext)(nil)).Elem())
	var tst = make([]ILogicalAndExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILogicalAndExpressionContext)
		}
	}

	return tst
}

func (s *LogicalOrExpressionContext) LogicalAndExpression(i int) ILogicalAndExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogicalAndExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILogicalAndExpressionContext)
}

func (s *LogicalOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitLogicalOrExpression(s)
	}
}

func (p *Dart2Parser) LogicalOrExpression() (localctx ILogicalOrExpressionContext) {
	this := p
	_ = this

	localctx = NewLogicalOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, Dart2ParserRULE_logicalOrExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1108)
		p.LogicalAndExpression()
	}
	p.SetState(1113)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__64 {
		{
			p.SetState(1109)
			p.Match(Dart2ParserT__64)
		}
		{
			p.SetState(1110)
			p.LogicalAndExpression()
		}

		p.SetState(1115)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILogicalAndExpressionContext is an interface to support dynamic dispatch.
type ILogicalAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogicalAndExpressionContext differentiates from other interfaces.
	IsLogicalAndExpressionContext()
}

type LogicalAndExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalAndExpressionContext() *LogicalAndExpressionContext {
	var p = new(LogicalAndExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_logicalAndExpression
	return p
}

func (*LogicalAndExpressionContext) IsLogicalAndExpressionContext() {}

func NewLogicalAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalAndExpressionContext {
	var p = new(LogicalAndExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_logicalAndExpression

	return p
}

func (s *LogicalAndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalAndExpressionContext) AllEqualityExpression() []IEqualityExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEqualityExpressionContext)(nil)).Elem())
	var tst = make([]IEqualityExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEqualityExpressionContext)
		}
	}

	return tst
}

func (s *LogicalAndExpressionContext) EqualityExpression(i int) IEqualityExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqualityExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEqualityExpressionContext)
}

func (s *LogicalAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitLogicalAndExpression(s)
	}
}

func (p *Dart2Parser) LogicalAndExpression() (localctx ILogicalAndExpressionContext) {
	this := p
	_ = this

	localctx = NewLogicalAndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, Dart2ParserRULE_logicalAndExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1116)
		p.EqualityExpression()
	}
	p.SetState(1121)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__65 {
		{
			p.SetState(1117)
			p.Match(Dart2ParserT__65)
		}
		{
			p.SetState(1118)
			p.EqualityExpression()
		}

		p.SetState(1123)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEqualityExpressionContext is an interface to support dynamic dispatch.
type IEqualityExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEqualityExpressionContext differentiates from other interfaces.
	IsEqualityExpressionContext()
}

type EqualityExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualityExpressionContext() *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_equalityExpression
	return p
}

func (*EqualityExpressionContext) IsEqualityExpressionContext() {}

func NewEqualityExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_equalityExpression

	return p
}

func (s *EqualityExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityExpressionContext) AllRelationalExpression() []IRelationalExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationalExpressionContext)(nil)).Elem())
	var tst = make([]IRelationalExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationalExpressionContext)
		}
	}

	return tst
}

func (s *EqualityExpressionContext) RelationalExpression(i int) IRelationalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationalExpressionContext)
}

func (s *EqualityExpressionContext) EqualityOperator() IEqualityOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqualityOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqualityOperatorContext)
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}

func (p *Dart2Parser) EqualityExpression() (localctx IEqualityExpressionContext) {
	this := p
	_ = this

	localctx = NewEqualityExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, Dart2ParserRULE_equalityExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1134)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1124)
			p.RelationalExpression()
		}
		p.SetState(1128)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__30 || _la == Dart2ParserT__66 {
			{
				p.SetState(1125)
				p.EqualityOperator()
			}
			{
				p.SetState(1126)
				p.RelationalExpression()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1130)
			p.Match(Dart2ParserT__33)
		}
		{
			p.SetState(1131)
			p.EqualityOperator()
		}
		{
			p.SetState(1132)
			p.RelationalExpression()
		}

	}

	return localctx
}

// IEqualityOperatorContext is an interface to support dynamic dispatch.
type IEqualityOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEqualityOperatorContext differentiates from other interfaces.
	IsEqualityOperatorContext()
}

type EqualityOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualityOperatorContext() *EqualityOperatorContext {
	var p = new(EqualityOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_equalityOperator
	return p
}

func (*EqualityOperatorContext) IsEqualityOperatorContext() {}

func NewEqualityOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityOperatorContext {
	var p = new(EqualityOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_equalityOperator

	return p
}

func (s *EqualityOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *EqualityOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterEqualityOperator(s)
	}
}

func (s *EqualityOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitEqualityOperator(s)
	}
}

func (p *Dart2Parser) EqualityOperator() (localctx IEqualityOperatorContext) {
	this := p
	_ = this

	localctx = NewEqualityOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, Dart2ParserRULE_equalityOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1136)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Dart2ParserT__30 || _la == Dart2ParserT__66) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRelationalExpressionContext is an interface to support dynamic dispatch.
type IRelationalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationalExpressionContext differentiates from other interfaces.
	IsRelationalExpressionContext()
}

type RelationalExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationalExpressionContext() *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_relationalExpression
	return p
}

func (*RelationalExpressionContext) IsRelationalExpressionContext() {}

func NewRelationalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_relationalExpression

	return p
}

func (s *RelationalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationalExpressionContext) AllBitwiseOrExpression() []IBitwiseOrExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBitwiseOrExpressionContext)(nil)).Elem())
	var tst = make([]IBitwiseOrExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBitwiseOrExpressionContext)
		}
	}

	return tst
}

func (s *RelationalExpressionContext) BitwiseOrExpression(i int) IBitwiseOrExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitwiseOrExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBitwiseOrExpressionContext)
}

func (s *RelationalExpressionContext) TypeTest() ITypeTestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTestContext)
}

func (s *RelationalExpressionContext) TypeCast() ITypeCastContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeCastContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeCastContext)
}

func (s *RelationalExpressionContext) RelationalOperator() IRelationalOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationalOperatorContext)
}

func (s *RelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitRelationalExpression(s)
	}
}

func (p *Dart2Parser) RelationalExpression() (localctx IRelationalExpressionContext) {
	this := p
	_ = this

	localctx = NewRelationalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, Dart2ParserRULE_relationalExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1150)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1138)
			p.BitwiseOrExpression()
		}
		p.SetState(1144)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Dart2ParserT__86:
			{
				p.SetState(1139)
				p.TypeTest()
			}

		case Dart2ParserT__87:
			{
				p.SetState(1140)
				p.TypeCast()
			}

		case Dart2ParserT__38, Dart2ParserT__39, Dart2ParserT__67, Dart2ParserT__68:
			{
				p.SetState(1141)
				p.RelationalOperator()
			}
			{
				p.SetState(1142)
				p.BitwiseOrExpression()
			}

		case Dart2ParserT__0, Dart2ParserT__6, Dart2ParserT__7, Dart2ParserT__8, Dart2ParserT__9, Dart2ParserT__10, Dart2ParserT__11, Dart2ParserT__12, Dart2ParserT__14, Dart2ParserT__16, Dart2ParserT__20, Dart2ParserT__30, Dart2ParserT__49, Dart2ParserT__62, Dart2ParserT__63, Dart2ParserT__64, Dart2ParserT__65, Dart2ParserT__66:

		default:
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1146)
			p.Match(Dart2ParserT__33)
		}
		{
			p.SetState(1147)
			p.RelationalOperator()
		}
		{
			p.SetState(1148)
			p.BitwiseOrExpression()
		}

	}

	return localctx
}

// IRelationalOperatorContext is an interface to support dynamic dispatch.
type IRelationalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationalOperatorContext differentiates from other interfaces.
	IsRelationalOperatorContext()
}

type RelationalOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationalOperatorContext() *RelationalOperatorContext {
	var p = new(RelationalOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_relationalOperator
	return p
}

func (*RelationalOperatorContext) IsRelationalOperatorContext() {}

func NewRelationalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationalOperatorContext {
	var p = new(RelationalOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_relationalOperator

	return p
}

func (s *RelationalOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *RelationalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationalOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterRelationalOperator(s)
	}
}

func (s *RelationalOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitRelationalOperator(s)
	}
}

func (p *Dart2Parser) RelationalOperator() (localctx IRelationalOperatorContext) {
	this := p
	_ = this

	localctx = NewRelationalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, Dart2ParserRULE_relationalOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1152)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(Dart2ParserT__38-39))|(1<<(Dart2ParserT__39-39))|(1<<(Dart2ParserT__67-39))|(1<<(Dart2ParserT__68-39)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBitwiseOrExpressionContext is an interface to support dynamic dispatch.
type IBitwiseOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitwiseOrExpressionContext differentiates from other interfaces.
	IsBitwiseOrExpressionContext()
}

type BitwiseOrExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitwiseOrExpressionContext() *BitwiseOrExpressionContext {
	var p = new(BitwiseOrExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_bitwiseOrExpression
	return p
}

func (*BitwiseOrExpressionContext) IsBitwiseOrExpressionContext() {}

func NewBitwiseOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseOrExpressionContext {
	var p = new(BitwiseOrExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_bitwiseOrExpression

	return p
}

func (s *BitwiseOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseOrExpressionContext) AllBitwiseXorExpression() []IBitwiseXorExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBitwiseXorExpressionContext)(nil)).Elem())
	var tst = make([]IBitwiseXorExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBitwiseXorExpressionContext)
		}
	}

	return tst
}

func (s *BitwiseOrExpressionContext) BitwiseXorExpression(i int) IBitwiseXorExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitwiseXorExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBitwiseXorExpressionContext)
}

func (s *BitwiseOrExpressionContext) AllBitwiseOrExpression() []IBitwiseOrExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBitwiseOrExpressionContext)(nil)).Elem())
	var tst = make([]IBitwiseOrExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBitwiseOrExpressionContext)
		}
	}

	return tst
}

func (s *BitwiseOrExpressionContext) BitwiseOrExpression(i int) IBitwiseOrExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitwiseOrExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBitwiseOrExpressionContext)
}

func (s *BitwiseOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterBitwiseOrExpression(s)
	}
}

func (s *BitwiseOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitBitwiseOrExpression(s)
	}
}

func (p *Dart2Parser) BitwiseOrExpression() (localctx IBitwiseOrExpressionContext) {
	this := p
	_ = this

	localctx = NewBitwiseOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, Dart2ParserRULE_bitwiseOrExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1169)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1154)
			p.BitwiseXorExpression()
		}
		p.SetState(1159)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1155)
					p.Match(Dart2ParserT__69)
				}
				{
					p.SetState(1156)
					p.BitwiseXorExpression()
				}

			}
			p.SetState(1161)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1162)
			p.Match(Dart2ParserT__33)
		}
		p.SetState(1165)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1163)
					p.Match(Dart2ParserT__69)
				}
				{
					p.SetState(1164)
					p.BitwiseOrExpression()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1167)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IBitwiseXorExpressionContext is an interface to support dynamic dispatch.
type IBitwiseXorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitwiseXorExpressionContext differentiates from other interfaces.
	IsBitwiseXorExpressionContext()
}

type BitwiseXorExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitwiseXorExpressionContext() *BitwiseXorExpressionContext {
	var p = new(BitwiseXorExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_bitwiseXorExpression
	return p
}

func (*BitwiseXorExpressionContext) IsBitwiseXorExpressionContext() {}

func NewBitwiseXorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseXorExpressionContext {
	var p = new(BitwiseXorExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_bitwiseXorExpression

	return p
}

func (s *BitwiseXorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseXorExpressionContext) AllBitwiseAndExpression() []IBitwiseAndExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBitwiseAndExpressionContext)(nil)).Elem())
	var tst = make([]IBitwiseAndExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBitwiseAndExpressionContext)
		}
	}

	return tst
}

func (s *BitwiseXorExpressionContext) BitwiseAndExpression(i int) IBitwiseAndExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitwiseAndExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBitwiseAndExpressionContext)
}

func (s *BitwiseXorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseXorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseXorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterBitwiseXorExpression(s)
	}
}

func (s *BitwiseXorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitBitwiseXorExpression(s)
	}
}

func (p *Dart2Parser) BitwiseXorExpression() (localctx IBitwiseXorExpressionContext) {
	this := p
	_ = this

	localctx = NewBitwiseXorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, Dart2ParserRULE_bitwiseXorExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1186)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1171)
			p.BitwiseAndExpression()
		}
		p.SetState(1176)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Dart2ParserT__70 {
			{
				p.SetState(1172)
				p.Match(Dart2ParserT__70)
			}
			{
				p.SetState(1173)
				p.BitwiseAndExpression()
			}

			p.SetState(1178)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1179)
			p.Match(Dart2ParserT__33)
		}
		p.SetState(1182)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Dart2ParserT__70 {
			{
				p.SetState(1180)
				p.Match(Dart2ParserT__70)
			}
			{
				p.SetState(1181)
				p.BitwiseAndExpression()
			}

			p.SetState(1184)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IBitwiseAndExpressionContext is an interface to support dynamic dispatch.
type IBitwiseAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitwiseAndExpressionContext differentiates from other interfaces.
	IsBitwiseAndExpressionContext()
}

type BitwiseAndExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitwiseAndExpressionContext() *BitwiseAndExpressionContext {
	var p = new(BitwiseAndExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_bitwiseAndExpression
	return p
}

func (*BitwiseAndExpressionContext) IsBitwiseAndExpressionContext() {}

func NewBitwiseAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseAndExpressionContext {
	var p = new(BitwiseAndExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_bitwiseAndExpression

	return p
}

func (s *BitwiseAndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseAndExpressionContext) AllShiftExpression() []IShiftExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IShiftExpressionContext)(nil)).Elem())
	var tst = make([]IShiftExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IShiftExpressionContext)
		}
	}

	return tst
}

func (s *BitwiseAndExpressionContext) ShiftExpression(i int) IShiftExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShiftExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IShiftExpressionContext)
}

func (s *BitwiseAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseAndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterBitwiseAndExpression(s)
	}
}

func (s *BitwiseAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitBitwiseAndExpression(s)
	}
}

func (p *Dart2Parser) BitwiseAndExpression() (localctx IBitwiseAndExpressionContext) {
	this := p
	_ = this

	localctx = NewBitwiseAndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, Dart2ParserRULE_bitwiseAndExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1203)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1188)
			p.ShiftExpression()
		}
		p.SetState(1193)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Dart2ParserT__71 {
			{
				p.SetState(1189)
				p.Match(Dart2ParserT__71)
			}
			{
				p.SetState(1190)
				p.ShiftExpression()
			}

			p.SetState(1195)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1196)
			p.Match(Dart2ParserT__33)
		}
		p.SetState(1199)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Dart2ParserT__71 {
			{
				p.SetState(1197)
				p.Match(Dart2ParserT__71)
			}
			{
				p.SetState(1198)
				p.ShiftExpression()
			}

			p.SetState(1201)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IBitwiseOperatorContext is an interface to support dynamic dispatch.
type IBitwiseOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitwiseOperatorContext differentiates from other interfaces.
	IsBitwiseOperatorContext()
}

type BitwiseOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitwiseOperatorContext() *BitwiseOperatorContext {
	var p = new(BitwiseOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_bitwiseOperator
	return p
}

func (*BitwiseOperatorContext) IsBitwiseOperatorContext() {}

func NewBitwiseOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseOperatorContext {
	var p = new(BitwiseOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_bitwiseOperator

	return p
}

func (s *BitwiseOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *BitwiseOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterBitwiseOperator(s)
	}
}

func (s *BitwiseOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitBitwiseOperator(s)
	}
}

func (p *Dart2Parser) BitwiseOperator() (localctx IBitwiseOperatorContext) {
	this := p
	_ = this

	localctx = NewBitwiseOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, Dart2ParserRULE_bitwiseOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1205)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Dart2ParserT__69-70))|(1<<(Dart2ParserT__70-70))|(1<<(Dart2ParserT__71-70)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IShiftExpressionContext is an interface to support dynamic dispatch.
type IShiftExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShiftExpressionContext differentiates from other interfaces.
	IsShiftExpressionContext()
}

type ShiftExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShiftExpressionContext() *ShiftExpressionContext {
	var p = new(ShiftExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_shiftExpression
	return p
}

func (*ShiftExpressionContext) IsShiftExpressionContext() {}

func NewShiftExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShiftExpressionContext {
	var p = new(ShiftExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_shiftExpression

	return p
}

func (s *ShiftExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ShiftExpressionContext) AllAdditiveExpression() []IAdditiveExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdditiveExpressionContext)(nil)).Elem())
	var tst = make([]IAdditiveExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdditiveExpressionContext)
		}
	}

	return tst
}

func (s *ShiftExpressionContext) AdditiveExpression(i int) IAdditiveExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditiveExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *ShiftExpressionContext) AllShiftOperator() []IShiftOperatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IShiftOperatorContext)(nil)).Elem())
	var tst = make([]IShiftOperatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IShiftOperatorContext)
		}
	}

	return tst
}

func (s *ShiftExpressionContext) ShiftOperator(i int) IShiftOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShiftOperatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IShiftOperatorContext)
}

func (s *ShiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShiftExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterShiftExpression(s)
	}
}

func (s *ShiftExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitShiftExpression(s)
	}
}

func (p *Dart2Parser) ShiftExpression() (localctx IShiftExpressionContext) {
	this := p
	_ = this

	localctx = NewShiftExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, Dart2ParserRULE_shiftExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1224)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1207)
			p.AdditiveExpression()
		}
		p.SetState(1213)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(Dart2ParserT__72-73))|(1<<(Dart2ParserT__73-73))|(1<<(Dart2ParserT__74-73)))) != 0 {
			{
				p.SetState(1208)
				p.ShiftOperator()
			}
			{
				p.SetState(1209)
				p.AdditiveExpression()
			}

			p.SetState(1215)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1216)
			p.Match(Dart2ParserT__33)
		}
		p.SetState(1220)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(Dart2ParserT__72-73))|(1<<(Dart2ParserT__73-73))|(1<<(Dart2ParserT__74-73)))) != 0) {
			{
				p.SetState(1217)
				p.ShiftOperator()
			}
			{
				p.SetState(1218)
				p.AdditiveExpression()
			}

			p.SetState(1222)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IShiftOperatorContext is an interface to support dynamic dispatch.
type IShiftOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShiftOperatorContext differentiates from other interfaces.
	IsShiftOperatorContext()
}

type ShiftOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShiftOperatorContext() *ShiftOperatorContext {
	var p = new(ShiftOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_shiftOperator
	return p
}

func (*ShiftOperatorContext) IsShiftOperatorContext() {}

func NewShiftOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShiftOperatorContext {
	var p = new(ShiftOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_shiftOperator

	return p
}

func (s *ShiftOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *ShiftOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShiftOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterShiftOperator(s)
	}
}

func (s *ShiftOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitShiftOperator(s)
	}
}

func (p *Dart2Parser) ShiftOperator() (localctx IShiftOperatorContext) {
	this := p
	_ = this

	localctx = NewShiftOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, Dart2ParserRULE_shiftOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1226)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(Dart2ParserT__72-73))|(1<<(Dart2ParserT__73-73))|(1<<(Dart2ParserT__74-73)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAdditiveExpressionContext is an interface to support dynamic dispatch.
type IAdditiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditiveExpressionContext differentiates from other interfaces.
	IsAdditiveExpressionContext()
}

type AdditiveExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExpressionContext() *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_additiveExpression
	return p
}

func (*AdditiveExpressionContext) IsAdditiveExpressionContext() {}

func NewAdditiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_additiveExpression

	return p
}

func (s *AdditiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExpressionContext) AllMultiplicativeExpression() []IMultiplicativeExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplicativeExpressionContext)(nil)).Elem())
	var tst = make([]IMultiplicativeExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplicativeExpressionContext)
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) MultiplicativeExpression(i int) IMultiplicativeExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicativeExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *AdditiveExpressionContext) AllAdditiveOperator() []IAdditiveOperatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdditiveOperatorContext)(nil)).Elem())
	var tst = make([]IAdditiveOperatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdditiveOperatorContext)
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) AdditiveOperator(i int) IAdditiveOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditiveOperatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdditiveOperatorContext)
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (p *Dart2Parser) AdditiveExpression() (localctx IAdditiveExpressionContext) {
	this := p
	_ = this

	localctx = NewAdditiveExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, Dart2ParserRULE_additiveExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1245)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1228)
			p.MultiplicativeExpression()
		}
		p.SetState(1234)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Dart2ParserT__75 || _la == Dart2ParserT__76 {
			{
				p.SetState(1229)
				p.AdditiveOperator()
			}
			{
				p.SetState(1230)
				p.MultiplicativeExpression()
			}

			p.SetState(1236)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1237)
			p.Match(Dart2ParserT__33)
		}
		p.SetState(1241)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Dart2ParserT__75 || _la == Dart2ParserT__76 {
			{
				p.SetState(1238)
				p.AdditiveOperator()
			}
			{
				p.SetState(1239)
				p.MultiplicativeExpression()
			}

			p.SetState(1243)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IAdditiveOperatorContext is an interface to support dynamic dispatch.
type IAdditiveOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditiveOperatorContext differentiates from other interfaces.
	IsAdditiveOperatorContext()
}

type AdditiveOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveOperatorContext() *AdditiveOperatorContext {
	var p = new(AdditiveOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_additiveOperator
	return p
}

func (*AdditiveOperatorContext) IsAdditiveOperatorContext() {}

func NewAdditiveOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveOperatorContext {
	var p = new(AdditiveOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_additiveOperator

	return p
}

func (s *AdditiveOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *AdditiveOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterAdditiveOperator(s)
	}
}

func (s *AdditiveOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitAdditiveOperator(s)
	}
}

func (p *Dart2Parser) AdditiveOperator() (localctx IAdditiveOperatorContext) {
	this := p
	_ = this

	localctx = NewAdditiveOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, Dart2ParserRULE_additiveOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1247)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Dart2ParserT__75 || _la == Dart2ParserT__76) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMultiplicativeExpressionContext is an interface to support dynamic dispatch.
type IMultiplicativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplicativeExpressionContext differentiates from other interfaces.
	IsMultiplicativeExpressionContext()
}

type MultiplicativeExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExpressionContext() *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_multiplicativeExpression
	return p
}

func (*MultiplicativeExpressionContext) IsMultiplicativeExpressionContext() {}

func NewMultiplicativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_multiplicativeExpression

	return p
}

func (s *MultiplicativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExpressionContext) AllUnaryExpression() []IUnaryExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnaryExpressionContext)(nil)).Elem())
	var tst = make([]IUnaryExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnaryExpressionContext)
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) UnaryExpression(i int) IUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *MultiplicativeExpressionContext) AllMultiplicativeOperator() []IMultiplicativeOperatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplicativeOperatorContext)(nil)).Elem())
	var tst = make([]IMultiplicativeOperatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplicativeOperatorContext)
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) MultiplicativeOperator(i int) IMultiplicativeOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicativeOperatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeOperatorContext)
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (p *Dart2Parser) MultiplicativeExpression() (localctx IMultiplicativeExpressionContext) {
	this := p
	_ = this

	localctx = NewMultiplicativeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, Dart2ParserRULE_multiplicativeExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1266)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1249)
			p.UnaryExpression()
		}
		p.SetState(1255)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(Dart2ParserT__77-78))|(1<<(Dart2ParserT__78-78))|(1<<(Dart2ParserT__79-78))|(1<<(Dart2ParserT__80-78)))) != 0 {
			{
				p.SetState(1250)
				p.MultiplicativeOperator()
			}
			{
				p.SetState(1251)
				p.UnaryExpression()
			}

			p.SetState(1257)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1258)
			p.Match(Dart2ParserT__33)
		}
		p.SetState(1262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(Dart2ParserT__77-78))|(1<<(Dart2ParserT__78-78))|(1<<(Dart2ParserT__79-78))|(1<<(Dart2ParserT__80-78)))) != 0) {
			{
				p.SetState(1259)
				p.MultiplicativeOperator()
			}
			{
				p.SetState(1260)
				p.UnaryExpression()
			}

			p.SetState(1264)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IMultiplicativeOperatorContext is an interface to support dynamic dispatch.
type IMultiplicativeOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplicativeOperatorContext differentiates from other interfaces.
	IsMultiplicativeOperatorContext()
}

type MultiplicativeOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeOperatorContext() *MultiplicativeOperatorContext {
	var p = new(MultiplicativeOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_multiplicativeOperator
	return p
}

func (*MultiplicativeOperatorContext) IsMultiplicativeOperatorContext() {}

func NewMultiplicativeOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeOperatorContext {
	var p = new(MultiplicativeOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_multiplicativeOperator

	return p
}

func (s *MultiplicativeOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *MultiplicativeOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterMultiplicativeOperator(s)
	}
}

func (s *MultiplicativeOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitMultiplicativeOperator(s)
	}
}

func (p *Dart2Parser) MultiplicativeOperator() (localctx IMultiplicativeOperatorContext) {
	this := p
	_ = this

	localctx = NewMultiplicativeOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, Dart2ParserRULE_multiplicativeOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1268)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(Dart2ParserT__77-78))|(1<<(Dart2ParserT__78-78))|(1<<(Dart2ParserT__79-78))|(1<<(Dart2ParserT__80-78)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUnaryExpressionContext is an interface to support dynamic dispatch.
type IUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryExpressionContext differentiates from other interfaces.
	IsUnaryExpressionContext()
}

type UnaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExpressionContext() *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_unaryExpression
	return p
}

func (*UnaryExpressionContext) IsUnaryExpressionContext() {}

func NewUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_unaryExpression

	return p
}

func (s *UnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExpressionContext) PrefixOperator() IPrefixOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefixOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefixOperatorContext)
}

func (s *UnaryExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *UnaryExpressionContext) AwaitExpression() IAwaitExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAwaitExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAwaitExpressionContext)
}

func (s *UnaryExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *UnaryExpressionContext) MinusOperator() IMinusOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMinusOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMinusOperatorContext)
}

func (s *UnaryExpressionContext) TildeOperator() ITildeOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITildeOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITildeOperatorContext)
}

func (s *UnaryExpressionContext) IncrementOperator() IIncrementOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIncrementOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIncrementOperatorContext)
}

func (s *UnaryExpressionContext) AssignableExpression() IAssignableExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignableExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignableExpressionContext)
}

func (s *UnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitUnaryExpression(s)
	}
}

func (p *Dart2Parser) UnaryExpression() (localctx IUnaryExpressionContext) {
	this := p
	_ = this

	localctx = NewUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, Dart2ParserRULE_unaryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1284)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1270)
			p.PrefixOperator()
		}
		{
			p.SetState(1271)
			p.UnaryExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1273)
			p.AwaitExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1274)
			p.PostfixExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1277)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Dart2ParserT__76:
			{
				p.SetState(1275)
				p.MinusOperator()
			}

		case Dart2ParserT__27:
			{
				p.SetState(1276)
				p.TildeOperator()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1279)
			p.Match(Dart2ParserT__33)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1281)
			p.IncrementOperator()
		}
		{
			p.SetState(1282)
			p.AssignableExpression()
		}

	}

	return localctx
}

// IPrefixOperatorContext is an interface to support dynamic dispatch.
type IPrefixOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrefixOperatorContext differentiates from other interfaces.
	IsPrefixOperatorContext()
}

type PrefixOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixOperatorContext() *PrefixOperatorContext {
	var p = new(PrefixOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_prefixOperator
	return p
}

func (*PrefixOperatorContext) IsPrefixOperatorContext() {}

func NewPrefixOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixOperatorContext {
	var p = new(PrefixOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_prefixOperator

	return p
}

func (s *PrefixOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixOperatorContext) MinusOperator() IMinusOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMinusOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMinusOperatorContext)
}

func (s *PrefixOperatorContext) NegationOperator() INegationOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INegationOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INegationOperatorContext)
}

func (s *PrefixOperatorContext) TildeOperator() ITildeOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITildeOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITildeOperatorContext)
}

func (s *PrefixOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterPrefixOperator(s)
	}
}

func (s *PrefixOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitPrefixOperator(s)
	}
}

func (p *Dart2Parser) PrefixOperator() (localctx IPrefixOperatorContext) {
	this := p
	_ = this

	localctx = NewPrefixOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, Dart2ParserRULE_prefixOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1289)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__76:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1286)
			p.MinusOperator()
		}

	case Dart2ParserT__81:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1287)
			p.NegationOperator()
		}

	case Dart2ParserT__27:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1288)
			p.TildeOperator()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMinusOperatorContext is an interface to support dynamic dispatch.
type IMinusOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMinusOperatorContext differentiates from other interfaces.
	IsMinusOperatorContext()
}

type MinusOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMinusOperatorContext() *MinusOperatorContext {
	var p = new(MinusOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_minusOperator
	return p
}

func (*MinusOperatorContext) IsMinusOperatorContext() {}

func NewMinusOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinusOperatorContext {
	var p = new(MinusOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_minusOperator

	return p
}

func (s *MinusOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *MinusOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinusOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinusOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterMinusOperator(s)
	}
}

func (s *MinusOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitMinusOperator(s)
	}
}

func (p *Dart2Parser) MinusOperator() (localctx IMinusOperatorContext) {
	this := p
	_ = this

	localctx = NewMinusOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, Dart2ParserRULE_minusOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1291)
		p.Match(Dart2ParserT__76)
	}

	return localctx
}

// INegationOperatorContext is an interface to support dynamic dispatch.
type INegationOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNegationOperatorContext differentiates from other interfaces.
	IsNegationOperatorContext()
}

type NegationOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNegationOperatorContext() *NegationOperatorContext {
	var p = new(NegationOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_negationOperator
	return p
}

func (*NegationOperatorContext) IsNegationOperatorContext() {}

func NewNegationOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NegationOperatorContext {
	var p = new(NegationOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_negationOperator

	return p
}

func (s *NegationOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *NegationOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NegationOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NegationOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterNegationOperator(s)
	}
}

func (s *NegationOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitNegationOperator(s)
	}
}

func (p *Dart2Parser) NegationOperator() (localctx INegationOperatorContext) {
	this := p
	_ = this

	localctx = NewNegationOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, Dart2ParserRULE_negationOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1293)
		p.Match(Dart2ParserT__81)
	}

	return localctx
}

// ITildeOperatorContext is an interface to support dynamic dispatch.
type ITildeOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTildeOperatorContext differentiates from other interfaces.
	IsTildeOperatorContext()
}

type TildeOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTildeOperatorContext() *TildeOperatorContext {
	var p = new(TildeOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_tildeOperator
	return p
}

func (*TildeOperatorContext) IsTildeOperatorContext() {}

func NewTildeOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TildeOperatorContext {
	var p = new(TildeOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_tildeOperator

	return p
}

func (s *TildeOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *TildeOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TildeOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TildeOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterTildeOperator(s)
	}
}

func (s *TildeOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitTildeOperator(s)
	}
}

func (p *Dart2Parser) TildeOperator() (localctx ITildeOperatorContext) {
	this := p
	_ = this

	localctx = NewTildeOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, Dart2ParserRULE_tildeOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1295)
		p.Match(Dart2ParserT__27)
	}

	return localctx
}

// IAwaitExpressionContext is an interface to support dynamic dispatch.
type IAwaitExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAwaitExpressionContext differentiates from other interfaces.
	IsAwaitExpressionContext()
}

type AwaitExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAwaitExpressionContext() *AwaitExpressionContext {
	var p = new(AwaitExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_awaitExpression
	return p
}

func (*AwaitExpressionContext) IsAwaitExpressionContext() {}

func NewAwaitExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AwaitExpressionContext {
	var p = new(AwaitExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_awaitExpression

	return p
}

func (s *AwaitExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AwaitExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *AwaitExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AwaitExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AwaitExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterAwaitExpression(s)
	}
}

func (s *AwaitExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitAwaitExpression(s)
	}
}

func (p *Dart2Parser) AwaitExpression() (localctx IAwaitExpressionContext) {
	this := p
	_ = this

	localctx = NewAwaitExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, Dart2ParserRULE_awaitExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1297)
		p.Match(Dart2ParserT__82)
	}
	{
		p.SetState(1298)
		p.UnaryExpression()
	}

	return localctx
}

// IPostfixExpressionContext is an interface to support dynamic dispatch.
type IPostfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixExpressionContext differentiates from other interfaces.
	IsPostfixExpressionContext()
}

type PostfixExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExpressionContext() *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_postfixExpression
	return p
}

func (*PostfixExpressionContext) IsPostfixExpressionContext() {}

func NewPostfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_postfixExpression

	return p
}

func (s *PostfixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionContext) AssignableExpression() IAssignableExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignableExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignableExpressionContext)
}

func (s *PostfixExpressionContext) PostfixOperator() IPostfixOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixOperatorContext)
}

func (s *PostfixExpressionContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *PostfixExpressionContext) AllSelector() []ISelectorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectorContext)(nil)).Elem())
	var tst = make([]ISelectorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectorContext)
		}
	}

	return tst
}

func (s *PostfixExpressionContext) Selector(i int) ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *PostfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterPostfixExpression(s)
	}
}

func (s *PostfixExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitPostfixExpression(s)
	}
}

func (p *Dart2Parser) PostfixExpression() (localctx IPostfixExpressionContext) {
	this := p
	_ = this

	localctx = NewPostfixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, Dart2ParserRULE_postfixExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1310)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1300)
			p.AssignableExpression()
		}
		{
			p.SetState(1301)
			p.PostfixOperator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1303)
			p.Primary()
		}
		p.SetState(1307)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1304)
					p.Selector()
				}

			}
			p.SetState(1309)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IPostfixOperatorContext is an interface to support dynamic dispatch.
type IPostfixOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixOperatorContext differentiates from other interfaces.
	IsPostfixOperatorContext()
}

type PostfixOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixOperatorContext() *PostfixOperatorContext {
	var p = new(PostfixOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_postfixOperator
	return p
}

func (*PostfixOperatorContext) IsPostfixOperatorContext() {}

func NewPostfixOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixOperatorContext {
	var p = new(PostfixOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_postfixOperator

	return p
}

func (s *PostfixOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixOperatorContext) IncrementOperator() IIncrementOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIncrementOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIncrementOperatorContext)
}

func (s *PostfixOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterPostfixOperator(s)
	}
}

func (s *PostfixOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitPostfixOperator(s)
	}
}

func (p *Dart2Parser) PostfixOperator() (localctx IPostfixOperatorContext) {
	this := p
	_ = this

	localctx = NewPostfixOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, Dart2ParserRULE_postfixOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1312)
		p.IncrementOperator()
	}

	return localctx
}

// ISelectorContext is an interface to support dynamic dispatch.
type ISelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectorContext differentiates from other interfaces.
	IsSelectorContext()
}

type SelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectorContext() *SelectorContext {
	var p = new(SelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_selector
	return p
}

func (*SelectorContext) IsSelectorContext() {}

func NewSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectorContext {
	var p = new(SelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_selector

	return p
}

func (s *SelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectorContext) AssignableSelector() IAssignableSelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignableSelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignableSelectorContext)
}

func (s *SelectorContext) ArgumentPart() IArgumentPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentPartContext)
}

func (s *SelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterSelector(s)
	}
}

func (s *SelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitSelector(s)
	}
}

func (p *Dart2Parser) Selector() (localctx ISelectorContext) {
	this := p
	_ = this

	localctx = NewSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, Dart2ParserRULE_selector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1316)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__15, Dart2ParserT__19, Dart2ParserT__85:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1314)
			p.AssignableSelector()
		}

	case Dart2ParserT__13, Dart2ParserT__38:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1315)
			p.ArgumentPart()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIncrementOperatorContext is an interface to support dynamic dispatch.
type IIncrementOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIncrementOperatorContext differentiates from other interfaces.
	IsIncrementOperatorContext()
}

type IncrementOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncrementOperatorContext() *IncrementOperatorContext {
	var p = new(IncrementOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_incrementOperator
	return p
}

func (*IncrementOperatorContext) IsIncrementOperatorContext() {}

func NewIncrementOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncrementOperatorContext {
	var p = new(IncrementOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_incrementOperator

	return p
}

func (s *IncrementOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *IncrementOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncrementOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IncrementOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterIncrementOperator(s)
	}
}

func (s *IncrementOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitIncrementOperator(s)
	}
}

func (p *Dart2Parser) IncrementOperator() (localctx IIncrementOperatorContext) {
	this := p
	_ = this

	localctx = NewIncrementOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, Dart2ParserRULE_incrementOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1318)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Dart2ParserT__83 || _la == Dart2ParserT__84) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAssignableExpressionContext is an interface to support dynamic dispatch.
type IAssignableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignableExpressionContext differentiates from other interfaces.
	IsAssignableExpressionContext()
}

type AssignableExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableExpressionContext() *AssignableExpressionContext {
	var p = new(AssignableExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_assignableExpression
	return p
}

func (*AssignableExpressionContext) IsAssignableExpressionContext() {}

func NewAssignableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableExpressionContext {
	var p = new(AssignableExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_assignableExpression

	return p
}

func (s *AssignableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableExpressionContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *AssignableExpressionContext) AssignableSelector() IAssignableSelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignableSelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignableSelectorContext)
}

func (s *AssignableExpressionContext) AllArgumentPart() []IArgumentPartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentPartContext)(nil)).Elem())
	var tst = make([]IArgumentPartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentPartContext)
		}
	}

	return tst
}

func (s *AssignableExpressionContext) ArgumentPart(i int) IArgumentPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentPartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentPartContext)
}

func (s *AssignableExpressionContext) UnconditionalAssignableSelector() IUnconditionalAssignableSelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnconditionalAssignableSelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnconditionalAssignableSelectorContext)
}

func (s *AssignableExpressionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssignableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterAssignableExpression(s)
	}
}

func (s *AssignableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitAssignableExpression(s)
	}
}

func (p *Dart2Parser) AssignableExpression() (localctx IAssignableExpressionContext) {
	this := p
	_ = this

	localctx = NewAssignableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, Dart2ParserRULE_assignableExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1334)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1320)
			p.Primary()
		}
		p.SetState(1328)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) == 1 {
			p.SetState(1324)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == Dart2ParserT__13 || _la == Dart2ParserT__38 {
				{
					p.SetState(1321)
					p.ArgumentPart()
				}

				p.SetState(1326)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1327)
				p.AssignableSelector()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1330)
			p.Match(Dart2ParserT__33)
		}
		{
			p.SetState(1331)
			p.UnconditionalAssignableSelector()
		}
		{
			p.SetState(1332)
			p.Identifier()
		}

	}

	return localctx
}

// IUnconditionalAssignableSelectorContext is an interface to support dynamic dispatch.
type IUnconditionalAssignableSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnconditionalAssignableSelectorContext differentiates from other interfaces.
	IsUnconditionalAssignableSelectorContext()
}

type UnconditionalAssignableSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnconditionalAssignableSelectorContext() *UnconditionalAssignableSelectorContext {
	var p = new(UnconditionalAssignableSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_unconditionalAssignableSelector
	return p
}

func (*UnconditionalAssignableSelectorContext) IsUnconditionalAssignableSelectorContext() {}

func NewUnconditionalAssignableSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnconditionalAssignableSelectorContext {
	var p = new(UnconditionalAssignableSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_unconditionalAssignableSelector

	return p
}

func (s *UnconditionalAssignableSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnconditionalAssignableSelectorContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnconditionalAssignableSelectorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnconditionalAssignableSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnconditionalAssignableSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnconditionalAssignableSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterUnconditionalAssignableSelector(s)
	}
}

func (s *UnconditionalAssignableSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitUnconditionalAssignableSelector(s)
	}
}

func (p *Dart2Parser) UnconditionalAssignableSelector() (localctx IUnconditionalAssignableSelectorContext) {
	this := p
	_ = this

	localctx = NewUnconditionalAssignableSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, Dart2ParserRULE_unconditionalAssignableSelector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1342)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1336)
			p.Match(Dart2ParserT__15)
		}
		{
			p.SetState(1337)
			p.Expression()
		}
		{
			p.SetState(1338)
			p.Match(Dart2ParserT__16)
		}

	case Dart2ParserT__19:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1340)
			p.Match(Dart2ParserT__19)
		}
		{
			p.SetState(1341)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssignableSelectorContext is an interface to support dynamic dispatch.
type IAssignableSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignableSelectorContext differentiates from other interfaces.
	IsAssignableSelectorContext()
}

type AssignableSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableSelectorContext() *AssignableSelectorContext {
	var p = new(AssignableSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_assignableSelector
	return p
}

func (*AssignableSelectorContext) IsAssignableSelectorContext() {}

func NewAssignableSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableSelectorContext {
	var p = new(AssignableSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_assignableSelector

	return p
}

func (s *AssignableSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableSelectorContext) UnconditionalAssignableSelector() IUnconditionalAssignableSelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnconditionalAssignableSelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnconditionalAssignableSelectorContext)
}

func (s *AssignableSelectorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssignableSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterAssignableSelector(s)
	}
}

func (s *AssignableSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitAssignableSelector(s)
	}
}

func (p *Dart2Parser) AssignableSelector() (localctx IAssignableSelectorContext) {
	this := p
	_ = this

	localctx = NewAssignableSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, Dart2ParserRULE_assignableSelector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1347)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__15, Dart2ParserT__19:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1344)
			p.UnconditionalAssignableSelector()
		}

	case Dart2ParserT__85:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1345)
			p.Match(Dart2ParserT__85)
		}
		{
			p.SetState(1346)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(Dart2ParserIDENTIFIER, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *Dart2Parser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, Dart2ParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1349)
		p.Match(Dart2ParserIDENTIFIER)
	}

	return localctx
}

// IQualifiedContext is an interface to support dynamic dispatch.
type IQualifiedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedContext differentiates from other interfaces.
	IsQualifiedContext()
}

type QualifiedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedContext() *QualifiedContext {
	var p = new(QualifiedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_qualified
	return p
}

func (*QualifiedContext) IsQualifiedContext() {}

func NewQualifiedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedContext {
	var p = new(QualifiedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_qualified

	return p
}

func (s *QualifiedContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *QualifiedContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterQualified(s)
	}
}

func (s *QualifiedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitQualified(s)
	}
}

func (p *Dart2Parser) Qualified() (localctx IQualifiedContext) {
	this := p
	_ = this

	localctx = NewQualifiedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, Dart2ParserRULE_qualified)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1351)
		p.Identifier()
	}
	p.SetState(1354)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1352)
			p.Match(Dart2ParserT__19)
		}
		{
			p.SetState(1353)
			p.Identifier()
		}

	}

	return localctx
}

// ITypeTestContext is an interface to support dynamic dispatch.
type ITypeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeTestContext differentiates from other interfaces.
	IsTypeTestContext()
}

type TypeTestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTestContext() *TypeTestContext {
	var p = new(TypeTestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_typeTest
	return p
}

func (*TypeTestContext) IsTypeTestContext() {}

func NewTypeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTestContext {
	var p = new(TypeTestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_typeTest

	return p
}

func (s *TypeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTestContext) IsOperator() IIsOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIsOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIsOperatorContext)
}

func (s *TypeTestContext) Dtype() IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *TypeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterTypeTest(s)
	}
}

func (s *TypeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitTypeTest(s)
	}
}

func (p *Dart2Parser) TypeTest() (localctx ITypeTestContext) {
	this := p
	_ = this

	localctx = NewTypeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, Dart2ParserRULE_typeTest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1356)
		p.IsOperator()
	}
	{
		p.SetState(1357)
		p.Dtype()
	}

	return localctx
}

// IIsOperatorContext is an interface to support dynamic dispatch.
type IIsOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIsOperatorContext differentiates from other interfaces.
	IsIsOperatorContext()
}

type IsOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsOperatorContext() *IsOperatorContext {
	var p = new(IsOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_isOperator
	return p
}

func (*IsOperatorContext) IsIsOperatorContext() {}

func NewIsOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsOperatorContext {
	var p = new(IsOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_isOperator

	return p
}

func (s *IsOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *IsOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IsOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterIsOperator(s)
	}
}

func (s *IsOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitIsOperator(s)
	}
}

func (p *Dart2Parser) IsOperator() (localctx IIsOperatorContext) {
	this := p
	_ = this

	localctx = NewIsOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, Dart2ParserRULE_isOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1359)
		p.Match(Dart2ParserT__86)
	}
	p.SetState(1361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__81 {
		{
			p.SetState(1360)
			p.Match(Dart2ParserT__81)
		}

	}

	return localctx
}

// ITypeCastContext is an interface to support dynamic dispatch.
type ITypeCastContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeCastContext differentiates from other interfaces.
	IsTypeCastContext()
}

type TypeCastContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeCastContext() *TypeCastContext {
	var p = new(TypeCastContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_typeCast
	return p
}

func (*TypeCastContext) IsTypeCastContext() {}

func NewTypeCastContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeCastContext {
	var p = new(TypeCastContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_typeCast

	return p
}

func (s *TypeCastContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeCastContext) AsOperator() IAsOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsOperatorContext)
}

func (s *TypeCastContext) Dtype() IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *TypeCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeCastContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterTypeCast(s)
	}
}

func (s *TypeCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitTypeCast(s)
	}
}

func (p *Dart2Parser) TypeCast() (localctx ITypeCastContext) {
	this := p
	_ = this

	localctx = NewTypeCastContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, Dart2ParserRULE_typeCast)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1363)
		p.AsOperator()
	}
	{
		p.SetState(1364)
		p.Dtype()
	}

	return localctx
}

// IAsOperatorContext is an interface to support dynamic dispatch.
type IAsOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsOperatorContext differentiates from other interfaces.
	IsAsOperatorContext()
}

type AsOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsOperatorContext() *AsOperatorContext {
	var p = new(AsOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_asOperator
	return p
}

func (*AsOperatorContext) IsAsOperatorContext() {}

func NewAsOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsOperatorContext {
	var p = new(AsOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_asOperator

	return p
}

func (s *AsOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *AsOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterAsOperator(s)
	}
}

func (s *AsOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitAsOperator(s)
	}
}

func (p *Dart2Parser) AsOperator() (localctx IAsOperatorContext) {
	this := p
	_ = this

	localctx = NewAsOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, Dart2ParserRULE_asOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1366)
		p.Match(Dart2ParserT__87)
	}

	return localctx
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_statements
	return p
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *StatementsContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *Dart2Parser) Statements() (localctx IStatementsContext) {
	this := p
	_ = this

	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, Dart2ParserRULE_statements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1371)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1368)
				p.Statement()
			}

		}
		p.SetState(1373)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext())
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) NonLabledStatment() INonLabledStatmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonLabledStatmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonLabledStatmentContext)
}

func (s *StatementContext) AllLabel() []ILabelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILabelContext)(nil)).Elem())
	var tst = make([]ILabelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILabelContext)
		}
	}

	return tst
}

func (s *StatementContext) Label(i int) ILabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *Dart2Parser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, Dart2ParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1377)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1374)
				p.Label()
			}

		}
		p.SetState(1379)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext())
	}
	{
		p.SetState(1380)
		p.NonLabledStatment()
	}

	return localctx
}

// INonLabledStatmentContext is an interface to support dynamic dispatch.
type INonLabledStatmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonLabledStatmentContext differentiates from other interfaces.
	IsNonLabledStatmentContext()
}

type NonLabledStatmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonLabledStatmentContext() *NonLabledStatmentContext {
	var p = new(NonLabledStatmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_nonLabledStatment
	return p
}

func (*NonLabledStatmentContext) IsNonLabledStatmentContext() {}

func NewNonLabledStatmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonLabledStatmentContext {
	var p = new(NonLabledStatmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_nonLabledStatment

	return p
}

func (s *NonLabledStatmentContext) GetParser() antlr.Parser { return s.parser }

func (s *NonLabledStatmentContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *NonLabledStatmentContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *NonLabledStatmentContext) ForStatement() IForStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *NonLabledStatmentContext) WhileStatement() IWhileStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhileStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *NonLabledStatmentContext) DoStatement() IDoStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoStatementContext)
}

func (s *NonLabledStatmentContext) SwitchStatement() ISwitchStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *NonLabledStatmentContext) IfStatement() IIfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *NonLabledStatmentContext) RethrowStatment() IRethrowStatmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRethrowStatmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRethrowStatmentContext)
}

func (s *NonLabledStatmentContext) TryStatement() ITryStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *NonLabledStatmentContext) BreakStatement() IBreakStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreakStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *NonLabledStatmentContext) ContinueStatement() IContinueStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinueStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *NonLabledStatmentContext) ReturnStatement() IReturnStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *NonLabledStatmentContext) YieldStatement() IYieldStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYieldStatementContext)
}

func (s *NonLabledStatmentContext) YieldEachStatement() IYieldEachStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldEachStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYieldEachStatementContext)
}

func (s *NonLabledStatmentContext) ExpressionStatement() IExpressionStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *NonLabledStatmentContext) AssertStatement() IAssertStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertStatementContext)
}

func (s *NonLabledStatmentContext) LocalFunctionDeclaration() ILocalFunctionDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalFunctionDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalFunctionDeclarationContext)
}

func (s *NonLabledStatmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonLabledStatmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonLabledStatmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterNonLabledStatment(s)
	}
}

func (s *NonLabledStatmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitNonLabledStatment(s)
	}
}

func (p *Dart2Parser) NonLabledStatment() (localctx INonLabledStatmentContext) {
	this := p
	_ = this

	localctx = NewNonLabledStatmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, Dart2ParserRULE_nonLabledStatment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1399)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1382)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1383)
			p.LocalVariableDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1384)
			p.ForStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1385)
			p.WhileStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1386)
			p.DoStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1387)
			p.SwitchStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1388)
			p.IfStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1389)
			p.RethrowStatment()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1390)
			p.TryStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1391)
			p.BreakStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1392)
			p.ContinueStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1393)
			p.ReturnStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1394)
			p.YieldStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1395)
			p.YieldEachStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1396)
			p.ExpressionStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1397)
			p.AssertStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1398)
			p.LocalFunctionDeclaration()
		}

	}

	return localctx
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (p *Dart2Parser) ExpressionStatement() (localctx IExpressionStatementContext) {
	this := p
	_ = this

	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, Dart2ParserRULE_expressionStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__2)|(1<<Dart2ParserT__11)|(1<<Dart2ParserT__13)|(1<<Dart2ParserT__15)|(1<<Dart2ParserT__18)|(1<<Dart2ParserT__27))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Dart2ParserT__33-34))|(1<<(Dart2ParserT__38-34))|(1<<(Dart2ParserT__41-34))|(1<<(Dart2ParserT__42-34))|(1<<(Dart2ParserT__43-34))|(1<<(Dart2ParserT__46-34))|(1<<(Dart2ParserT__47-34))|(1<<(Dart2ParserT__48-34)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(Dart2ParserT__76-77))|(1<<(Dart2ParserT__81-77))|(1<<(Dart2ParserT__82-77))|(1<<(Dart2ParserT__83-77))|(1<<(Dart2ParserT__84-77)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(Dart2ParserNUMBER-119))|(1<<(Dart2ParserHEX_NUMBER-119))|(1<<(Dart2ParserSingleLineString-119))|(1<<(Dart2ParserMultiLineString-119))|(1<<(Dart2ParserIDENTIFIER-119)))) != 0) {
		{
			p.SetState(1401)
			p.Expression()
		}

	}
	{
		p.SetState(1404)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// ILocalVariableDeclarationContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalVariableDeclarationContext differentiates from other interfaces.
	IsLocalVariableDeclarationContext()
}

type LocalVariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationContext() *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_localVariableDeclaration
	return p
}

func (*LocalVariableDeclarationContext) IsLocalVariableDeclarationContext() {}

func NewLocalVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_localVariableDeclaration

	return p
}

func (s *LocalVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationContext) InitializedVariableDeclaration() IInitializedVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializedVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializedVariableDeclarationContext)
}

func (s *LocalVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterLocalVariableDeclaration(s)
	}
}

func (s *LocalVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitLocalVariableDeclaration(s)
	}
}

func (p *Dart2Parser) LocalVariableDeclaration() (localctx ILocalVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewLocalVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, Dart2ParserRULE_localVariableDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1406)
		p.InitializedVariableDeclaration()
	}
	{
		p.SetState(1407)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// ILocalFunctionDeclarationContext is an interface to support dynamic dispatch.
type ILocalFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalFunctionDeclarationContext differentiates from other interfaces.
	IsLocalFunctionDeclarationContext()
}

type LocalFunctionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalFunctionDeclarationContext() *LocalFunctionDeclarationContext {
	var p = new(LocalFunctionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_localFunctionDeclaration
	return p
}

func (*LocalFunctionDeclarationContext) IsLocalFunctionDeclarationContext() {}

func NewLocalFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalFunctionDeclarationContext {
	var p = new(LocalFunctionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_localFunctionDeclaration

	return p
}

func (s *LocalFunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalFunctionDeclarationContext) FunctionSignature() IFunctionSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionSignatureContext)
}

func (s *LocalFunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *LocalFunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalFunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalFunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterLocalFunctionDeclaration(s)
	}
}

func (s *LocalFunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitLocalFunctionDeclaration(s)
	}
}

func (p *Dart2Parser) LocalFunctionDeclaration() (localctx ILocalFunctionDeclarationContext) {
	this := p
	_ = this

	localctx = NewLocalFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, Dart2ParserRULE_localFunctionDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1409)
		p.FunctionSignature()
	}
	{
		p.SetState(1410)
		p.FunctionBody()
	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (p *Dart2Parser) IfStatement() (localctx IIfStatementContext) {
	this := p
	_ = this

	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, Dart2ParserRULE_ifStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1412)
		p.Match(Dart2ParserT__88)
	}
	{
		p.SetState(1413)
		p.Match(Dart2ParserT__13)
	}
	{
		p.SetState(1414)
		p.Expression()
	}
	{
		p.SetState(1415)
		p.Match(Dart2ParserT__14)
	}
	{
		p.SetState(1416)
		p.Statement()
	}
	p.SetState(1419)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1417)
			p.Match(Dart2ParserT__89)
		}
		{
			p.SetState(1418)
			p.Statement()
		}

	}

	return localctx
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_forStatement
	return p
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) ForLoopParts() IForLoopPartsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForLoopPartsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForLoopPartsContext)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *Dart2Parser) ForStatement() (localctx IForStatementContext) {
	this := p
	_ = this

	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, Dart2ParserRULE_forStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1422)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__82 {
		{
			p.SetState(1421)
			p.Match(Dart2ParserT__82)
		}

	}
	{
		p.SetState(1424)
		p.Match(Dart2ParserT__90)
	}
	{
		p.SetState(1425)
		p.Match(Dart2ParserT__13)
	}
	{
		p.SetState(1426)
		p.ForLoopParts()
	}
	{
		p.SetState(1427)
		p.Match(Dart2ParserT__14)
	}
	{
		p.SetState(1428)
		p.Statement()
	}

	return localctx
}

// IForLoopPartsContext is an interface to support dynamic dispatch.
type IForLoopPartsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForLoopPartsContext differentiates from other interfaces.
	IsForLoopPartsContext()
}

type ForLoopPartsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForLoopPartsContext() *ForLoopPartsContext {
	var p = new(ForLoopPartsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_forLoopParts
	return p
}

func (*ForLoopPartsContext) IsForLoopPartsContext() {}

func NewForLoopPartsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForLoopPartsContext {
	var p = new(ForLoopPartsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_forLoopParts

	return p
}

func (s *ForLoopPartsContext) GetParser() antlr.Parser { return s.parser }

func (s *ForLoopPartsContext) ForInitializerStatement() IForInitializerStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForInitializerStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForInitializerStatementContext)
}

func (s *ForLoopPartsContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForLoopPartsContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForLoopPartsContext) DeclaredIdentifier() IDeclaredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaredIdentifierContext)
}

func (s *ForLoopPartsContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ForLoopPartsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForLoopPartsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForLoopPartsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterForLoopParts(s)
	}
}

func (s *ForLoopPartsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitForLoopParts(s)
	}
}

func (p *Dart2Parser) ForLoopParts() (localctx IForLoopPartsContext) {
	this := p
	_ = this

	localctx = NewForLoopPartsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, Dart2ParserRULE_forLoopParts)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1446)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1430)
			p.ForInitializerStatement()
		}
		p.SetState(1432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__2)|(1<<Dart2ParserT__11)|(1<<Dart2ParserT__13)|(1<<Dart2ParserT__15)|(1<<Dart2ParserT__18)|(1<<Dart2ParserT__27))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Dart2ParserT__33-34))|(1<<(Dart2ParserT__38-34))|(1<<(Dart2ParserT__41-34))|(1<<(Dart2ParserT__42-34))|(1<<(Dart2ParserT__43-34))|(1<<(Dart2ParserT__46-34))|(1<<(Dart2ParserT__47-34))|(1<<(Dart2ParserT__48-34)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(Dart2ParserT__76-77))|(1<<(Dart2ParserT__81-77))|(1<<(Dart2ParserT__82-77))|(1<<(Dart2ParserT__83-77))|(1<<(Dart2ParserT__84-77)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(Dart2ParserNUMBER-119))|(1<<(Dart2ParserHEX_NUMBER-119))|(1<<(Dart2ParserSingleLineString-119))|(1<<(Dart2ParserMultiLineString-119))|(1<<(Dart2ParserIDENTIFIER-119)))) != 0) {
			{
				p.SetState(1431)
				p.Expression()
			}

		}
		{
			p.SetState(1434)
			p.Match(Dart2ParserT__8)
		}
		p.SetState(1436)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__2)|(1<<Dart2ParserT__11)|(1<<Dart2ParserT__13)|(1<<Dart2ParserT__15)|(1<<Dart2ParserT__18)|(1<<Dart2ParserT__27))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Dart2ParserT__33-34))|(1<<(Dart2ParserT__38-34))|(1<<(Dart2ParserT__41-34))|(1<<(Dart2ParserT__42-34))|(1<<(Dart2ParserT__43-34))|(1<<(Dart2ParserT__46-34))|(1<<(Dart2ParserT__47-34))|(1<<(Dart2ParserT__48-34)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(Dart2ParserT__76-77))|(1<<(Dart2ParserT__81-77))|(1<<(Dart2ParserT__82-77))|(1<<(Dart2ParserT__83-77))|(1<<(Dart2ParserT__84-77)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(Dart2ParserNUMBER-119))|(1<<(Dart2ParserHEX_NUMBER-119))|(1<<(Dart2ParserSingleLineString-119))|(1<<(Dart2ParserMultiLineString-119))|(1<<(Dart2ParserIDENTIFIER-119)))) != 0) {
			{
				p.SetState(1435)
				p.ExpressionList()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1438)
			p.DeclaredIdentifier()
		}
		{
			p.SetState(1439)
			p.Match(Dart2ParserT__91)
		}
		{
			p.SetState(1440)
			p.Expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1442)
			p.Identifier()
		}
		{
			p.SetState(1443)
			p.Match(Dart2ParserT__91)
		}
		{
			p.SetState(1444)
			p.Expression()
		}

	}

	return localctx
}

// IForInitializerStatementContext is an interface to support dynamic dispatch.
type IForInitializerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForInitializerStatementContext differentiates from other interfaces.
	IsForInitializerStatementContext()
}

type ForInitializerStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitializerStatementContext() *ForInitializerStatementContext {
	var p = new(ForInitializerStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_forInitializerStatement
	return p
}

func (*ForInitializerStatementContext) IsForInitializerStatementContext() {}

func NewForInitializerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitializerStatementContext {
	var p = new(ForInitializerStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_forInitializerStatement

	return p
}

func (s *ForInitializerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitializerStatementContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ForInitializerStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForInitializerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitializerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitializerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterForInitializerStatement(s)
	}
}

func (s *ForInitializerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitForInitializerStatement(s)
	}
}

func (p *Dart2Parser) ForInitializerStatement() (localctx IForInitializerStatementContext) {
	this := p
	_ = this

	localctx = NewForInitializerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, Dart2ParserRULE_forInitializerStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1453)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1448)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1450)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__2)|(1<<Dart2ParserT__11)|(1<<Dart2ParserT__13)|(1<<Dart2ParserT__15)|(1<<Dart2ParserT__18)|(1<<Dart2ParserT__27))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Dart2ParserT__33-34))|(1<<(Dart2ParserT__38-34))|(1<<(Dart2ParserT__41-34))|(1<<(Dart2ParserT__42-34))|(1<<(Dart2ParserT__43-34))|(1<<(Dart2ParserT__46-34))|(1<<(Dart2ParserT__47-34))|(1<<(Dart2ParserT__48-34)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(Dart2ParserT__76-77))|(1<<(Dart2ParserT__81-77))|(1<<(Dart2ParserT__82-77))|(1<<(Dart2ParserT__83-77))|(1<<(Dart2ParserT__84-77)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(Dart2ParserNUMBER-119))|(1<<(Dart2ParserHEX_NUMBER-119))|(1<<(Dart2ParserSingleLineString-119))|(1<<(Dart2ParserMultiLineString-119))|(1<<(Dart2ParserIDENTIFIER-119)))) != 0) {
			{
				p.SetState(1449)
				p.Expression()
			}

		}
		{
			p.SetState(1452)
			p.Match(Dart2ParserT__8)
		}

	}

	return localctx
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_whileStatement
	return p
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *Dart2Parser) WhileStatement() (localctx IWhileStatementContext) {
	this := p
	_ = this

	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, Dart2ParserRULE_whileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1455)
		p.Match(Dart2ParserT__92)
	}
	{
		p.SetState(1456)
		p.Match(Dart2ParserT__13)
	}
	{
		p.SetState(1457)
		p.Expression()
	}
	{
		p.SetState(1458)
		p.Match(Dart2ParserT__14)
	}
	{
		p.SetState(1459)
		p.Statement()
	}

	return localctx
}

// IDoStatementContext is an interface to support dynamic dispatch.
type IDoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoStatementContext differentiates from other interfaces.
	IsDoStatementContext()
}

type DoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoStatementContext() *DoStatementContext {
	var p = new(DoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_doStatement
	return p
}

func (*DoStatementContext) IsDoStatementContext() {}

func NewDoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoStatementContext {
	var p = new(DoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_doStatement

	return p
}

func (s *DoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitDoStatement(s)
	}
}

func (p *Dart2Parser) DoStatement() (localctx IDoStatementContext) {
	this := p
	_ = this

	localctx = NewDoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, Dart2ParserRULE_doStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1461)
		p.Match(Dart2ParserT__93)
	}
	{
		p.SetState(1462)
		p.Statement()
	}
	{
		p.SetState(1463)
		p.Match(Dart2ParserT__92)
	}
	{
		p.SetState(1464)
		p.Match(Dart2ParserT__13)
	}
	{
		p.SetState(1465)
		p.Expression()
	}
	{
		p.SetState(1466)
		p.Match(Dart2ParserT__14)
	}
	{
		p.SetState(1467)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_switchStatement
	return p
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchStatementContext) AllSwitchCase() []ISwitchCaseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISwitchCaseContext)(nil)).Elem())
	var tst = make([]ISwitchCaseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISwitchCaseContext)
		}
	}

	return tst
}

func (s *SwitchStatementContext) SwitchCase(i int) ISwitchCaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchCaseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISwitchCaseContext)
}

func (s *SwitchStatementContext) DefaultCase() IDefaultCaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefaultCaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefaultCaseContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (p *Dart2Parser) SwitchStatement() (localctx ISwitchStatementContext) {
	this := p
	_ = this

	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, Dart2ParserRULE_switchStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1469)
		p.Match(Dart2ParserT__94)
	}
	{
		p.SetState(1470)
		p.Match(Dart2ParserT__13)
	}
	{
		p.SetState(1471)
		p.Expression()
	}
	{
		p.SetState(1472)
		p.Match(Dart2ParserT__14)
	}
	{
		p.SetState(1473)
		p.Match(Dart2ParserT__11)
	}
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1474)
				p.SwitchCase()
			}

		}
		p.SetState(1479)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext())
	}
	p.SetState(1481)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__96 || _la == Dart2ParserIDENTIFIER {
		{
			p.SetState(1480)
			p.DefaultCase()
		}

	}
	{
		p.SetState(1483)
		p.Match(Dart2ParserT__12)
	}

	return localctx
}

// ISwitchCaseContext is an interface to support dynamic dispatch.
type ISwitchCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchCaseContext differentiates from other interfaces.
	IsSwitchCaseContext()
}

type SwitchCaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchCaseContext() *SwitchCaseContext {
	var p = new(SwitchCaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_switchCase
	return p
}

func (*SwitchCaseContext) IsSwitchCaseContext() {}

func NewSwitchCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchCaseContext {
	var p = new(SwitchCaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_switchCase

	return p
}

func (s *SwitchCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchCaseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchCaseContext) Statements() IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *SwitchCaseContext) AllLabel() []ILabelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILabelContext)(nil)).Elem())
	var tst = make([]ILabelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILabelContext)
		}
	}

	return tst
}

func (s *SwitchCaseContext) Label(i int) ILabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *SwitchCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterSwitchCase(s)
	}
}

func (s *SwitchCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitSwitchCase(s)
	}
}

func (p *Dart2Parser) SwitchCase() (localctx ISwitchCaseContext) {
	this := p
	_ = this

	localctx = NewSwitchCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, Dart2ParserRULE_switchCase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1488)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserIDENTIFIER {
		{
			p.SetState(1485)
			p.Label()
		}

		p.SetState(1490)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1491)
		p.Match(Dart2ParserT__95)
	}
	{
		p.SetState(1492)
		p.Expression()
	}
	{
		p.SetState(1493)
		p.Match(Dart2ParserT__20)
	}
	{
		p.SetState(1494)
		p.Statements()
	}

	return localctx
}

// IDefaultCaseContext is an interface to support dynamic dispatch.
type IDefaultCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultCaseContext differentiates from other interfaces.
	IsDefaultCaseContext()
}

type DefaultCaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultCaseContext() *DefaultCaseContext {
	var p = new(DefaultCaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_defaultCase
	return p
}

func (*DefaultCaseContext) IsDefaultCaseContext() {}

func NewDefaultCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultCaseContext {
	var p = new(DefaultCaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_defaultCase

	return p
}

func (s *DefaultCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultCaseContext) Statements() IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *DefaultCaseContext) AllLabel() []ILabelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILabelContext)(nil)).Elem())
	var tst = make([]ILabelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILabelContext)
		}
	}

	return tst
}

func (s *DefaultCaseContext) Label(i int) ILabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *DefaultCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterDefaultCase(s)
	}
}

func (s *DefaultCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitDefaultCase(s)
	}
}

func (p *Dart2Parser) DefaultCase() (localctx IDefaultCaseContext) {
	this := p
	_ = this

	localctx = NewDefaultCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, Dart2ParserRULE_defaultCase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1499)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserIDENTIFIER {
		{
			p.SetState(1496)
			p.Label()
		}

		p.SetState(1501)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1502)
		p.Match(Dart2ParserT__96)
	}
	{
		p.SetState(1503)
		p.Match(Dart2ParserT__20)
	}
	{
		p.SetState(1504)
		p.Statements()
	}

	return localctx
}

// IRethrowStatmentContext is an interface to support dynamic dispatch.
type IRethrowStatmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRethrowStatmentContext differentiates from other interfaces.
	IsRethrowStatmentContext()
}

type RethrowStatmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRethrowStatmentContext() *RethrowStatmentContext {
	var p = new(RethrowStatmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_rethrowStatment
	return p
}

func (*RethrowStatmentContext) IsRethrowStatmentContext() {}

func NewRethrowStatmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RethrowStatmentContext {
	var p = new(RethrowStatmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_rethrowStatment

	return p
}

func (s *RethrowStatmentContext) GetParser() antlr.Parser { return s.parser }
func (s *RethrowStatmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RethrowStatmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RethrowStatmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterRethrowStatment(s)
	}
}

func (s *RethrowStatmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitRethrowStatment(s)
	}
}

func (p *Dart2Parser) RethrowStatment() (localctx IRethrowStatmentContext) {
	this := p
	_ = this

	localctx = NewRethrowStatmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, Dart2ParserRULE_rethrowStatment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1506)
		p.Match(Dart2ParserT__97)
	}
	{
		p.SetState(1507)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_tryStatement
	return p
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) FinallyPart() IFinallyPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinallyPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinallyPartContext)
}

func (s *TryStatementContext) AllOnPart() []IOnPartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnPartContext)(nil)).Elem())
	var tst = make([]IOnPartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnPartContext)
		}
	}

	return tst
}

func (s *TryStatementContext) OnPart(i int) IOnPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnPartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnPartContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitTryStatement(s)
	}
}

func (p *Dart2Parser) TryStatement() (localctx ITryStatementContext) {
	this := p
	_ = this

	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, Dart2ParserRULE_tryStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1509)
		p.Match(Dart2ParserT__98)
	}
	{
		p.SetState(1510)
		p.Block()
	}
	p.SetState(1520)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__99, Dart2ParserT__100:
		p.SetState(1512)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Dart2ParserT__99 || _la == Dart2ParserT__100 {
			{
				p.SetState(1511)
				p.OnPart()
			}

			p.SetState(1514)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1517)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__101 {
			{
				p.SetState(1516)
				p.FinallyPart()
			}

		}

	case Dart2ParserT__101:
		{
			p.SetState(1519)
			p.FinallyPart()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOnPartContext is an interface to support dynamic dispatch.
type IOnPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnPartContext differentiates from other interfaces.
	IsOnPartContext()
}

type OnPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnPartContext() *OnPartContext {
	var p = new(OnPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_onPart
	return p
}

func (*OnPartContext) IsOnPartContext() {}

func NewOnPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnPartContext {
	var p = new(OnPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_onPart

	return p
}

func (s *OnPartContext) GetParser() antlr.Parser { return s.parser }

func (s *OnPartContext) CatchPart() ICatchPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICatchPartContext)
}

func (s *OnPartContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *OnPartContext) Dtype() IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *OnPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterOnPart(s)
	}
}

func (s *OnPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitOnPart(s)
	}
}

func (p *Dart2Parser) OnPart() (localctx IOnPartContext) {
	this := p
	_ = this

	localctx = NewOnPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, Dart2ParserRULE_onPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1532)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__100:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1522)
			p.CatchPart()
		}
		{
			p.SetState(1523)
			p.Block()
		}

	case Dart2ParserT__99:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1525)
			p.Match(Dart2ParserT__99)
		}
		{
			p.SetState(1526)
			p.Dtype()
		}
		p.SetState(1528)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__100 {
			{
				p.SetState(1527)
				p.CatchPart()
			}

		}
		{
			p.SetState(1530)
			p.Block()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICatchPartContext is an interface to support dynamic dispatch.
type ICatchPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchPartContext differentiates from other interfaces.
	IsCatchPartContext()
}

type CatchPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchPartContext() *CatchPartContext {
	var p = new(CatchPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_catchPart
	return p
}

func (*CatchPartContext) IsCatchPartContext() {}

func NewCatchPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchPartContext {
	var p = new(CatchPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_catchPart

	return p
}

func (s *CatchPartContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchPartContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *CatchPartContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CatchPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterCatchPart(s)
	}
}

func (s *CatchPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitCatchPart(s)
	}
}

func (p *Dart2Parser) CatchPart() (localctx ICatchPartContext) {
	this := p
	_ = this

	localctx = NewCatchPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, Dart2ParserRULE_catchPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1534)
		p.Match(Dart2ParserT__100)
	}
	{
		p.SetState(1535)
		p.Match(Dart2ParserT__13)
	}
	{
		p.SetState(1536)
		p.Identifier()
	}
	p.SetState(1539)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__0 {
		{
			p.SetState(1537)
			p.Match(Dart2ParserT__0)
		}
		{
			p.SetState(1538)
			p.Identifier()
		}

	}
	{
		p.SetState(1541)
		p.Match(Dart2ParserT__14)
	}

	return localctx
}

// IFinallyPartContext is an interface to support dynamic dispatch.
type IFinallyPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinallyPartContext differentiates from other interfaces.
	IsFinallyPartContext()
}

type FinallyPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyPartContext() *FinallyPartContext {
	var p = new(FinallyPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_finallyPart
	return p
}

func (*FinallyPartContext) IsFinallyPartContext() {}

func NewFinallyPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyPartContext {
	var p = new(FinallyPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_finallyPart

	return p
}

func (s *FinallyPartContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyPartContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterFinallyPart(s)
	}
}

func (s *FinallyPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitFinallyPart(s)
	}
}

func (p *Dart2Parser) FinallyPart() (localctx IFinallyPartContext) {
	this := p
	_ = this

	localctx = NewFinallyPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, Dart2ParserRULE_finallyPart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1543)
		p.Match(Dart2ParserT__101)
	}
	{
		p.SetState(1544)
		p.Block()
	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *Dart2Parser) ReturnStatement() (localctx IReturnStatementContext) {
	this := p
	_ = this

	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, Dart2ParserRULE_returnStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1546)
		p.Match(Dart2ParserT__102)
	}
	p.SetState(1548)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__2)|(1<<Dart2ParserT__11)|(1<<Dart2ParserT__13)|(1<<Dart2ParserT__15)|(1<<Dart2ParserT__18)|(1<<Dart2ParserT__27))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(Dart2ParserT__33-34))|(1<<(Dart2ParserT__38-34))|(1<<(Dart2ParserT__41-34))|(1<<(Dart2ParserT__42-34))|(1<<(Dart2ParserT__43-34))|(1<<(Dart2ParserT__46-34))|(1<<(Dart2ParserT__47-34))|(1<<(Dart2ParserT__48-34)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(Dart2ParserT__76-77))|(1<<(Dart2ParserT__81-77))|(1<<(Dart2ParserT__82-77))|(1<<(Dart2ParserT__83-77))|(1<<(Dart2ParserT__84-77)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(Dart2ParserNUMBER-119))|(1<<(Dart2ParserHEX_NUMBER-119))|(1<<(Dart2ParserSingleLineString-119))|(1<<(Dart2ParserMultiLineString-119))|(1<<(Dart2ParserIDENTIFIER-119)))) != 0) {
		{
			p.SetState(1547)
			p.Expression()
		}

	}
	{
		p.SetState(1550)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_label
	return p
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitLabel(s)
	}
}

func (p *Dart2Parser) Label() (localctx ILabelContext) {
	this := p
	_ = this

	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, Dart2ParserRULE_label)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1552)
		p.Identifier()
	}
	{
		p.SetState(1553)
		p.Match(Dart2ParserT__20)
	}

	return localctx
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (p *Dart2Parser) BreakStatement() (localctx IBreakStatementContext) {
	this := p
	_ = this

	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, Dart2ParserRULE_breakStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1555)
		p.Match(Dart2ParserT__103)
	}
	p.SetState(1557)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserIDENTIFIER {
		{
			p.SetState(1556)
			p.Identifier()
		}

	}
	{
		p.SetState(1559)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (p *Dart2Parser) ContinueStatement() (localctx IContinueStatementContext) {
	this := p
	_ = this

	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, Dart2ParserRULE_continueStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1561)
		p.Match(Dart2ParserT__104)
	}
	p.SetState(1563)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserIDENTIFIER {
		{
			p.SetState(1562)
			p.Identifier()
		}

	}
	{
		p.SetState(1565)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// IYieldStatementContext is an interface to support dynamic dispatch.
type IYieldStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYieldStatementContext differentiates from other interfaces.
	IsYieldStatementContext()
}

type YieldStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldStatementContext() *YieldStatementContext {
	var p = new(YieldStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_yieldStatement
	return p
}

func (*YieldStatementContext) IsYieldStatementContext() {}

func NewYieldStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldStatementContext {
	var p = new(YieldStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_yieldStatement

	return p
}

func (s *YieldStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *YieldStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterYieldStatement(s)
	}
}

func (s *YieldStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitYieldStatement(s)
	}
}

func (p *Dart2Parser) YieldStatement() (localctx IYieldStatementContext) {
	this := p
	_ = this

	localctx = NewYieldStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, Dart2ParserRULE_yieldStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1567)
		p.Match(Dart2ParserT__105)
	}
	{
		p.SetState(1568)
		p.Expression()
	}
	{
		p.SetState(1569)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// IYieldEachStatementContext is an interface to support dynamic dispatch.
type IYieldEachStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYieldEachStatementContext differentiates from other interfaces.
	IsYieldEachStatementContext()
}

type YieldEachStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldEachStatementContext() *YieldEachStatementContext {
	var p = new(YieldEachStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_yieldEachStatement
	return p
}

func (*YieldEachStatementContext) IsYieldEachStatementContext() {}

func NewYieldEachStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldEachStatementContext {
	var p = new(YieldEachStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_yieldEachStatement

	return p
}

func (s *YieldEachStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldEachStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *YieldEachStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldEachStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldEachStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterYieldEachStatement(s)
	}
}

func (s *YieldEachStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitYieldEachStatement(s)
	}
}

func (p *Dart2Parser) YieldEachStatement() (localctx IYieldEachStatementContext) {
	this := p
	_ = this

	localctx = NewYieldEachStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, Dart2ParserRULE_yieldEachStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1571)
		p.Match(Dart2ParserT__106)
	}
	{
		p.SetState(1572)
		p.Expression()
	}
	{
		p.SetState(1573)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// IAssertStatementContext is an interface to support dynamic dispatch.
type IAssertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssertStatementContext differentiates from other interfaces.
	IsAssertStatementContext()
}

type AssertStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertStatementContext() *AssertStatementContext {
	var p = new(AssertStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_assertStatement
	return p
}

func (*AssertStatementContext) IsAssertStatementContext() {}

func NewAssertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssertStatementContext {
	var p = new(AssertStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_assertStatement

	return p
}

func (s *AssertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssertStatementContext) Assertion() IAssertionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertionContext)
}

func (s *AssertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterAssertStatement(s)
	}
}

func (s *AssertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitAssertStatement(s)
	}
}

func (p *Dart2Parser) AssertStatement() (localctx IAssertStatementContext) {
	this := p
	_ = this

	localctx = NewAssertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, Dart2ParserRULE_assertStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1575)
		p.Assertion()
	}
	{
		p.SetState(1576)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// IAssertionContext is an interface to support dynamic dispatch.
type IAssertionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssertionContext differentiates from other interfaces.
	IsAssertionContext()
}

type AssertionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertionContext() *AssertionContext {
	var p = new(AssertionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_assertion
	return p
}

func (*AssertionContext) IsAssertionContext() {}

func NewAssertionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssertionContext {
	var p = new(AssertionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_assertion

	return p
}

func (s *AssertionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssertionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *AssertionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssertionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssertionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterAssertion(s)
	}
}

func (s *AssertionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitAssertion(s)
	}
}

func (p *Dart2Parser) Assertion() (localctx IAssertionContext) {
	this := p
	_ = this

	localctx = NewAssertionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, Dart2ParserRULE_assertion)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1578)
		p.Match(Dart2ParserT__107)
	}
	{
		p.SetState(1579)
		p.Match(Dart2ParserT__13)
	}
	{
		p.SetState(1580)
		p.Expression()
	}
	p.SetState(1583)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1581)
			p.Match(Dart2ParserT__0)
		}
		{
			p.SetState(1582)
			p.Expression()
		}

	}
	p.SetState(1586)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__0 {
		{
			p.SetState(1585)
			p.Match(Dart2ParserT__0)
		}

	}
	{
		p.SetState(1588)
		p.Match(Dart2ParserT__14)
	}

	return localctx
}

// ITopLevelDefinitionContext is an interface to support dynamic dispatch.
type ITopLevelDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopLevelDefinitionContext differentiates from other interfaces.
	IsTopLevelDefinitionContext()
}

type TopLevelDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopLevelDefinitionContext() *TopLevelDefinitionContext {
	var p = new(TopLevelDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_topLevelDefinition
	return p
}

func (*TopLevelDefinitionContext) IsTopLevelDefinitionContext() {}

func NewTopLevelDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopLevelDefinitionContext {
	var p = new(TopLevelDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_topLevelDefinition

	return p
}

func (s *TopLevelDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TopLevelDefinitionContext) ClassDefinition() IClassDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDefinitionContext)
}

func (s *TopLevelDefinitionContext) EnumType() IEnumTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumTypeContext)
}

func (s *TopLevelDefinitionContext) TypeAlias() ITypeAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeAliasContext)
}

func (s *TopLevelDefinitionContext) FunctionSignature() IFunctionSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionSignatureContext)
}

func (s *TopLevelDefinitionContext) GetterSignature() IGetterSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGetterSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGetterSignatureContext)
}

func (s *TopLevelDefinitionContext) SetterSignature() ISetterSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetterSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetterSignatureContext)
}

func (s *TopLevelDefinitionContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *TopLevelDefinitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TopLevelDefinitionContext) ReturnType() IReturnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *TopLevelDefinitionContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *TopLevelDefinitionContext) StaticFinalDeclarationList() IStaticFinalDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStaticFinalDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStaticFinalDeclarationListContext)
}

func (s *TopLevelDefinitionContext) Dtype() IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *TopLevelDefinitionContext) VariableDeclaration() IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *TopLevelDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopLevelDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopLevelDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterTopLevelDefinition(s)
	}
}

func (s *TopLevelDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitTopLevelDefinition(s)
	}
}

func (p *Dart2Parser) TopLevelDefinition() (localctx ITopLevelDefinitionContext) {
	this := p
	_ = this

	localctx = NewTopLevelDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, Dart2ParserRULE_topLevelDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1639)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 192, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1590)
			p.ClassDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1591)
			p.EnumType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1592)
			p.TypeAlias()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1594)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__25 {
			{
				p.SetState(1593)
				p.Match(Dart2ParserT__25)
			}

		}
		{
			p.SetState(1596)
			p.FunctionSignature()
		}
		{
			p.SetState(1597)
			p.Match(Dart2ParserT__8)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1600)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__25 {
			{
				p.SetState(1599)
				p.Match(Dart2ParserT__25)
			}

		}
		{
			p.SetState(1602)
			p.GetterSignature()
		}
		{
			p.SetState(1603)
			p.Match(Dart2ParserT__8)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1606)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__25 {
			{
				p.SetState(1605)
				p.Match(Dart2ParserT__25)
			}

		}
		{
			p.SetState(1608)
			p.SetterSignature()
		}
		{
			p.SetState(1609)
			p.Match(Dart2ParserT__8)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1611)
			p.FunctionSignature()
		}
		{
			p.SetState(1612)
			p.FunctionBody()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(1615)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__5 || _la == Dart2ParserIDENTIFIER {
			{
				p.SetState(1614)
				p.ReturnType()
			}

		}
		{
			p.SetState(1617)
			p.Match(Dart2ParserT__31)
		}
		{
			p.SetState(1618)
			p.Identifier()
		}
		{
			p.SetState(1619)
			p.FunctionBody()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(1622)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Dart2ParserT__5 || _la == Dart2ParserIDENTIFIER {
			{
				p.SetState(1621)
				p.ReturnType()
			}

		}
		{
			p.SetState(1624)
			p.Match(Dart2ParserT__32)
		}
		{
			p.SetState(1625)
			p.Identifier()
		}
		{
			p.SetState(1626)
			p.FormalParameterList()
		}
		{
			p.SetState(1627)
			p.FunctionBody()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1629)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Dart2ParserT__1 || _la == Dart2ParserT__2) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1631)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1630)
				p.Dtype()
			}

		}
		{
			p.SetState(1633)
			p.StaticFinalDeclarationList()
		}
		{
			p.SetState(1634)
			p.Match(Dart2ParserT__8)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1636)
			p.VariableDeclaration()
		}
		{
			p.SetState(1637)
			p.Match(Dart2ParserT__8)
		}

	}

	return localctx
}

// IGetOrSetContext is an interface to support dynamic dispatch.
type IGetOrSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGetOrSetContext differentiates from other interfaces.
	IsGetOrSetContext()
}

type GetOrSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetOrSetContext() *GetOrSetContext {
	var p = new(GetOrSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_getOrSet
	return p
}

func (*GetOrSetContext) IsGetOrSetContext() {}

func NewGetOrSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetOrSetContext {
	var p = new(GetOrSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_getOrSet

	return p
}

func (s *GetOrSetContext) GetParser() antlr.Parser { return s.parser }
func (s *GetOrSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetOrSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetOrSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterGetOrSet(s)
	}
}

func (s *GetOrSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitGetOrSet(s)
	}
}

func (p *Dart2Parser) GetOrSet() (localctx IGetOrSetContext) {
	this := p
	_ = this

	localctx = NewGetOrSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, Dart2ParserRULE_getOrSet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1641)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Dart2ParserT__31 || _la == Dart2ParserT__32) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILibraryDefinitionContext is an interface to support dynamic dispatch.
type ILibraryDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryDefinitionContext differentiates from other interfaces.
	IsLibraryDefinitionContext()
}

type LibraryDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryDefinitionContext() *LibraryDefinitionContext {
	var p = new(LibraryDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_libraryDefinition
	return p
}

func (*LibraryDefinitionContext) IsLibraryDefinitionContext() {}

func NewLibraryDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryDefinitionContext {
	var p = new(LibraryDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_libraryDefinition

	return p
}

func (s *LibraryDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryDefinitionContext) ScriptTag() IScriptTagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScriptTagContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScriptTagContext)
}

func (s *LibraryDefinitionContext) LibraryName() ILibraryNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryNameContext)
}

func (s *LibraryDefinitionContext) AllImportOrExport() []IImportOrExportContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImportOrExportContext)(nil)).Elem())
	var tst = make([]IImportOrExportContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImportOrExportContext)
		}
	}

	return tst
}

func (s *LibraryDefinitionContext) ImportOrExport(i int) IImportOrExportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportOrExportContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImportOrExportContext)
}

func (s *LibraryDefinitionContext) AllPartDirective() []IPartDirectiveContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPartDirectiveContext)(nil)).Elem())
	var tst = make([]IPartDirectiveContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPartDirectiveContext)
		}
	}

	return tst
}

func (s *LibraryDefinitionContext) PartDirective(i int) IPartDirectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartDirectiveContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPartDirectiveContext)
}

func (s *LibraryDefinitionContext) AllTopLevelDefinition() []ITopLevelDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITopLevelDefinitionContext)(nil)).Elem())
	var tst = make([]ITopLevelDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITopLevelDefinitionContext)
		}
	}

	return tst
}

func (s *LibraryDefinitionContext) TopLevelDefinition(i int) ITopLevelDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopLevelDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITopLevelDefinitionContext)
}

func (s *LibraryDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterLibraryDefinition(s)
	}
}

func (s *LibraryDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitLibraryDefinition(s)
	}
}

func (p *Dart2Parser) LibraryDefinition() (localctx ILibraryDefinitionContext) {
	this := p
	_ = this

	localctx = NewLibraryDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, Dart2ParserRULE_libraryDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1644)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__108 {
		{
			p.SetState(1643)
			p.ScriptTag()
		}

	}
	p.SetState(1647)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1646)
			p.LibraryName()
		}

	}
	p.SetState(1652)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 195, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1649)
				p.ImportOrExport()
			}

		}
		p.SetState(1654)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 195, p.GetParserRuleContext())
	}
	p.SetState(1658)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1655)
				p.PartDirective()
			}

		}
		p.SetState(1660)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext())
	}
	p.SetState(1664)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__1)|(1<<Dart2ParserT__2)|(1<<Dart2ParserT__3)|(1<<Dart2ParserT__5)|(1<<Dart2ParserT__21)|(1<<Dart2ParserT__22)|(1<<Dart2ParserT__25))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(Dart2ParserT__31-32))|(1<<(Dart2ParserT__32-32))|(1<<(Dart2ParserT__37-32))|(1<<(Dart2ParserT__40-32)))) != 0) || _la == Dart2ParserT__116 || _la == Dart2ParserIDENTIFIER {
		{
			p.SetState(1661)
			p.TopLevelDefinition()
		}

		p.SetState(1666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IScriptTagContext is an interface to support dynamic dispatch.
type IScriptTagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScriptTagContext differentiates from other interfaces.
	IsScriptTagContext()
}

type ScriptTagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptTagContext() *ScriptTagContext {
	var p = new(ScriptTagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_scriptTag
	return p
}

func (*ScriptTagContext) IsScriptTagContext() {}

func NewScriptTagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptTagContext {
	var p = new(ScriptTagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_scriptTag

	return p
}

func (s *ScriptTagContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptTagContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Dart2ParserNEWLINE)
}

func (s *ScriptTagContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Dart2ParserNEWLINE, i)
}

func (s *ScriptTagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptTagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptTagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterScriptTag(s)
	}
}

func (s *ScriptTagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitScriptTag(s)
	}
}

func (p *Dart2Parser) ScriptTag() (localctx IScriptTagContext) {
	this := p
	_ = this

	localctx = NewScriptTagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, Dart2ParserRULE_scriptTag)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1667)
		p.Match(Dart2ParserT__108)
	}
	p.SetState(1671)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__0)|(1<<Dart2ParserT__1)|(1<<Dart2ParserT__2)|(1<<Dart2ParserT__3)|(1<<Dart2ParserT__4)|(1<<Dart2ParserT__5)|(1<<Dart2ParserT__6)|(1<<Dart2ParserT__7)|(1<<Dart2ParserT__8)|(1<<Dart2ParserT__9)|(1<<Dart2ParserT__10)|(1<<Dart2ParserT__11)|(1<<Dart2ParserT__12)|(1<<Dart2ParserT__13)|(1<<Dart2ParserT__14)|(1<<Dart2ParserT__15)|(1<<Dart2ParserT__16)|(1<<Dart2ParserT__17)|(1<<Dart2ParserT__18)|(1<<Dart2ParserT__19)|(1<<Dart2ParserT__20)|(1<<Dart2ParserT__21)|(1<<Dart2ParserT__22)|(1<<Dart2ParserT__23)|(1<<Dart2ParserT__24)|(1<<Dart2ParserT__25)|(1<<Dart2ParserT__26)|(1<<Dart2ParserT__27)|(1<<Dart2ParserT__28)|(1<<Dart2ParserT__29)|(1<<Dart2ParserT__30))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(Dart2ParserT__31-32))|(1<<(Dart2ParserT__32-32))|(1<<(Dart2ParserT__33-32))|(1<<(Dart2ParserT__34-32))|(1<<(Dart2ParserT__35-32))|(1<<(Dart2ParserT__36-32))|(1<<(Dart2ParserT__37-32))|(1<<(Dart2ParserT__38-32))|(1<<(Dart2ParserT__39-32))|(1<<(Dart2ParserT__40-32))|(1<<(Dart2ParserT__41-32))|(1<<(Dart2ParserT__42-32))|(1<<(Dart2ParserT__43-32))|(1<<(Dart2ParserT__44-32))|(1<<(Dart2ParserT__45-32))|(1<<(Dart2ParserT__46-32))|(1<<(Dart2ParserT__47-32))|(1<<(Dart2ParserT__48-32))|(1<<(Dart2ParserT__49-32))|(1<<(Dart2ParserT__50-32))|(1<<(Dart2ParserT__51-32))|(1<<(Dart2ParserT__52-32))|(1<<(Dart2ParserT__53-32))|(1<<(Dart2ParserT__54-32))|(1<<(Dart2ParserT__55-32))|(1<<(Dart2ParserT__56-32))|(1<<(Dart2ParserT__57-32))|(1<<(Dart2ParserT__58-32))|(1<<(Dart2ParserT__59-32))|(1<<(Dart2ParserT__60-32))|(1<<(Dart2ParserT__61-32))|(1<<(Dart2ParserT__62-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(Dart2ParserT__63-64))|(1<<(Dart2ParserT__64-64))|(1<<(Dart2ParserT__65-64))|(1<<(Dart2ParserT__66-64))|(1<<(Dart2ParserT__67-64))|(1<<(Dart2ParserT__68-64))|(1<<(Dart2ParserT__69-64))|(1<<(Dart2ParserT__70-64))|(1<<(Dart2ParserT__71-64))|(1<<(Dart2ParserT__72-64))|(1<<(Dart2ParserT__73-64))|(1<<(Dart2ParserT__74-64))|(1<<(Dart2ParserT__75-64))|(1<<(Dart2ParserT__76-64))|(1<<(Dart2ParserT__77-64))|(1<<(Dart2ParserT__78-64))|(1<<(Dart2ParserT__79-64))|(1<<(Dart2ParserT__80-64))|(1<<(Dart2ParserT__81-64))|(1<<(Dart2ParserT__82-64))|(1<<(Dart2ParserT__83-64))|(1<<(Dart2ParserT__84-64))|(1<<(Dart2ParserT__85-64))|(1<<(Dart2ParserT__86-64))|(1<<(Dart2ParserT__87-64))|(1<<(Dart2ParserT__88-64))|(1<<(Dart2ParserT__89-64))|(1<<(Dart2ParserT__90-64))|(1<<(Dart2ParserT__91-64))|(1<<(Dart2ParserT__92-64))|(1<<(Dart2ParserT__93-64))|(1<<(Dart2ParserT__94-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(Dart2ParserT__95-96))|(1<<(Dart2ParserT__96-96))|(1<<(Dart2ParserT__97-96))|(1<<(Dart2ParserT__98-96))|(1<<(Dart2ParserT__99-96))|(1<<(Dart2ParserT__100-96))|(1<<(Dart2ParserT__101-96))|(1<<(Dart2ParserT__102-96))|(1<<(Dart2ParserT__103-96))|(1<<(Dart2ParserT__104-96))|(1<<(Dart2ParserT__105-96))|(1<<(Dart2ParserT__106-96))|(1<<(Dart2ParserT__107-96))|(1<<(Dart2ParserT__108-96))|(1<<(Dart2ParserT__109-96))|(1<<(Dart2ParserT__110-96))|(1<<(Dart2ParserT__111-96))|(1<<(Dart2ParserT__112-96))|(1<<(Dart2ParserT__113-96))|(1<<(Dart2ParserT__114-96))|(1<<(Dart2ParserT__115-96))|(1<<(Dart2ParserT__116-96))|(1<<(Dart2ParserWHITESPACE-96))|(1<<(Dart2ParserNUMBER-96))|(1<<(Dart2ParserHEX_NUMBER-96))|(1<<(Dart2ParserSingleLineString-96))|(1<<(Dart2ParserMultiLineString-96))|(1<<(Dart2ParserIDENTIFIER-96))|(1<<(Dart2ParserSINGLE_LINE_COMMENT-96))|(1<<(Dart2ParserMULTI_LINE_COMMENT-96)))) != 0) {
		{
			p.SetState(1668)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == Dart2ParserNEWLINE {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(1673)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1674)
		p.Match(Dart2ParserNEWLINE)
	}

	return localctx
}

// ILibraryNameContext is an interface to support dynamic dispatch.
type ILibraryNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryNameContext differentiates from other interfaces.
	IsLibraryNameContext()
}

type LibraryNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryNameContext() *LibraryNameContext {
	var p = new(LibraryNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_libraryName
	return p
}

func (*LibraryNameContext) IsLibraryNameContext() {}

func NewLibraryNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryNameContext {
	var p = new(LibraryNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_libraryName

	return p
}

func (s *LibraryNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryNameContext) Metadata() IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *LibraryNameContext) DottedIdentifierList() IDottedIdentifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDottedIdentifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDottedIdentifierListContext)
}

func (s *LibraryNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterLibraryName(s)
	}
}

func (s *LibraryNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitLibraryName(s)
	}
}

func (p *Dart2Parser) LibraryName() (localctx ILibraryNameContext) {
	this := p
	_ = this

	localctx = NewLibraryNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, Dart2ParserRULE_libraryName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1676)
		p.Metadata()
	}
	{
		p.SetState(1677)
		p.Match(Dart2ParserT__109)
	}
	{
		p.SetState(1678)
		p.DottedIdentifierList()
	}
	{
		p.SetState(1679)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// IImportOrExportContext is an interface to support dynamic dispatch.
type IImportOrExportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportOrExportContext differentiates from other interfaces.
	IsImportOrExportContext()
}

type ImportOrExportContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportOrExportContext() *ImportOrExportContext {
	var p = new(ImportOrExportContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_importOrExport
	return p
}

func (*ImportOrExportContext) IsImportOrExportContext() {}

func NewImportOrExportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportOrExportContext {
	var p = new(ImportOrExportContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_importOrExport

	return p
}

func (s *ImportOrExportContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportOrExportContext) Libraryimport() ILibraryimportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryimportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryimportContext)
}

func (s *ImportOrExportContext) LibraryExport() ILibraryExportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryExportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryExportContext)
}

func (s *ImportOrExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportOrExportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportOrExportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterImportOrExport(s)
	}
}

func (s *ImportOrExportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitImportOrExport(s)
	}
}

func (p *Dart2Parser) ImportOrExport() (localctx IImportOrExportContext) {
	this := p
	_ = this

	localctx = NewImportOrExportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, Dart2ParserRULE_importOrExport)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1683)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 199, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1681)
			p.Libraryimport()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1682)
			p.LibraryExport()
		}

	}

	return localctx
}

// IDottedIdentifierListContext is an interface to support dynamic dispatch.
type IDottedIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDottedIdentifierListContext differentiates from other interfaces.
	IsDottedIdentifierListContext()
}

type DottedIdentifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDottedIdentifierListContext() *DottedIdentifierListContext {
	var p = new(DottedIdentifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_dottedIdentifierList
	return p
}

func (*DottedIdentifierListContext) IsDottedIdentifierListContext() {}

func NewDottedIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DottedIdentifierListContext {
	var p = new(DottedIdentifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_dottedIdentifierList

	return p
}

func (s *DottedIdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *DottedIdentifierListContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *DottedIdentifierListContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DottedIdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DottedIdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DottedIdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterDottedIdentifierList(s)
	}
}

func (s *DottedIdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitDottedIdentifierList(s)
	}
}

func (p *Dart2Parser) DottedIdentifierList() (localctx IDottedIdentifierListContext) {
	this := p
	_ = this

	localctx = NewDottedIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, Dart2ParserRULE_dottedIdentifierList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1685)
		p.Identifier()
	}
	p.SetState(1690)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__0 {
		{
			p.SetState(1686)
			p.Match(Dart2ParserT__0)
		}
		{
			p.SetState(1687)
			p.Identifier()
		}

		p.SetState(1692)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILibraryimportContext is an interface to support dynamic dispatch.
type ILibraryimportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryimportContext differentiates from other interfaces.
	IsLibraryimportContext()
}

type LibraryimportContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryimportContext() *LibraryimportContext {
	var p = new(LibraryimportContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_libraryimport
	return p
}

func (*LibraryimportContext) IsLibraryimportContext() {}

func NewLibraryimportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryimportContext {
	var p = new(LibraryimportContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_libraryimport

	return p
}

func (s *LibraryimportContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryimportContext) Metadata() IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *LibraryimportContext) ImportSpecification() IImportSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportSpecificationContext)
}

func (s *LibraryimportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryimportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryimportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterLibraryimport(s)
	}
}

func (s *LibraryimportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitLibraryimport(s)
	}
}

func (p *Dart2Parser) Libraryimport() (localctx ILibraryimportContext) {
	this := p
	_ = this

	localctx = NewLibraryimportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, Dart2ParserRULE_libraryimport)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1693)
		p.Metadata()
	}
	{
		p.SetState(1694)
		p.ImportSpecification()
	}

	return localctx
}

// IImportSpecificationContext is an interface to support dynamic dispatch.
type IImportSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportSpecificationContext differentiates from other interfaces.
	IsImportSpecificationContext()
}

type ImportSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportSpecificationContext() *ImportSpecificationContext {
	var p = new(ImportSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_importSpecification
	return p
}

func (*ImportSpecificationContext) IsImportSpecificationContext() {}

func NewImportSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportSpecificationContext {
	var p = new(ImportSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_importSpecification

	return p
}

func (s *ImportSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportSpecificationContext) ConfigurableUri() IConfigurableUriContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfigurableUriContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfigurableUriContext)
}

func (s *ImportSpecificationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportSpecificationContext) AllCombinator() []ICombinatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICombinatorContext)(nil)).Elem())
	var tst = make([]ICombinatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICombinatorContext)
		}
	}

	return tst
}

func (s *ImportSpecificationContext) Combinator(i int) ICombinatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICombinatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICombinatorContext)
}

func (s *ImportSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterImportSpecification(s)
	}
}

func (s *ImportSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitImportSpecification(s)
	}
}

func (p *Dart2Parser) ImportSpecification() (localctx IImportSpecificationContext) {
	this := p
	_ = this

	localctx = NewImportSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, Dart2ParserRULE_importSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1696)
		p.Match(Dart2ParserT__110)
	}
	{
		p.SetState(1697)
		p.ConfigurableUri()
	}
	p.SetState(1700)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__87 {
		{
			p.SetState(1698)
			p.Match(Dart2ParserT__87)
		}
		{
			p.SetState(1699)
			p.Identifier()
		}

	}
	p.SetState(1705)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__111 || _la == Dart2ParserT__112 {
		{
			p.SetState(1702)
			p.Combinator()
		}

		p.SetState(1707)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1708)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// ICombinatorContext is an interface to support dynamic dispatch.
type ICombinatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCombinatorContext differentiates from other interfaces.
	IsCombinatorContext()
}

type CombinatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCombinatorContext() *CombinatorContext {
	var p = new(CombinatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_combinator
	return p
}

func (*CombinatorContext) IsCombinatorContext() {}

func NewCombinatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CombinatorContext {
	var p = new(CombinatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_combinator

	return p
}

func (s *CombinatorContext) GetParser() antlr.Parser { return s.parser }

func (s *CombinatorContext) IdentifierList() IIdentifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CombinatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CombinatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CombinatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterCombinator(s)
	}
}

func (s *CombinatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitCombinator(s)
	}
}

func (p *Dart2Parser) Combinator() (localctx ICombinatorContext) {
	this := p
	_ = this

	localctx = NewCombinatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, Dart2ParserRULE_combinator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1714)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserT__111:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1710)
			p.Match(Dart2ParserT__111)
		}
		{
			p.SetState(1711)
			p.IdentifierList()
		}

	case Dart2ParserT__112:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1712)
			p.Match(Dart2ParserT__112)
		}
		{
			p.SetState(1713)
			p.IdentifierList()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_identifierList
	return p
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (p *Dart2Parser) IdentifierList() (localctx IIdentifierListContext) {
	this := p
	_ = this

	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, Dart2ParserRULE_identifierList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1716)
		p.Identifier()
	}
	p.SetState(1721)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__0 {
		{
			p.SetState(1717)
			p.Match(Dart2ParserT__0)
		}
		{
			p.SetState(1718)
			p.Identifier()
		}

		p.SetState(1723)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILibraryExportContext is an interface to support dynamic dispatch.
type ILibraryExportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryExportContext differentiates from other interfaces.
	IsLibraryExportContext()
}

type LibraryExportContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryExportContext() *LibraryExportContext {
	var p = new(LibraryExportContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_libraryExport
	return p
}

func (*LibraryExportContext) IsLibraryExportContext() {}

func NewLibraryExportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryExportContext {
	var p = new(LibraryExportContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_libraryExport

	return p
}

func (s *LibraryExportContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryExportContext) Metadata() IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *LibraryExportContext) ConfigurableUri() IConfigurableUriContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfigurableUriContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfigurableUriContext)
}

func (s *LibraryExportContext) AllCombinator() []ICombinatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICombinatorContext)(nil)).Elem())
	var tst = make([]ICombinatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICombinatorContext)
		}
	}

	return tst
}

func (s *LibraryExportContext) Combinator(i int) ICombinatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICombinatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICombinatorContext)
}

func (s *LibraryExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryExportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryExportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterLibraryExport(s)
	}
}

func (s *LibraryExportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitLibraryExport(s)
	}
}

func (p *Dart2Parser) LibraryExport() (localctx ILibraryExportContext) {
	this := p
	_ = this

	localctx = NewLibraryExportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, Dart2ParserRULE_libraryExport)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1724)
		p.Metadata()
	}
	{
		p.SetState(1725)
		p.Match(Dart2ParserT__113)
	}
	{
		p.SetState(1726)
		p.ConfigurableUri()
	}
	p.SetState(1730)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__111 || _la == Dart2ParserT__112 {
		{
			p.SetState(1727)
			p.Combinator()
		}

		p.SetState(1732)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1733)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// IPartDirectiveContext is an interface to support dynamic dispatch.
type IPartDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartDirectiveContext differentiates from other interfaces.
	IsPartDirectiveContext()
}

type PartDirectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartDirectiveContext() *PartDirectiveContext {
	var p = new(PartDirectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_partDirective
	return p
}

func (*PartDirectiveContext) IsPartDirectiveContext() {}

func NewPartDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartDirectiveContext {
	var p = new(PartDirectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_partDirective

	return p
}

func (s *PartDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *PartDirectiveContext) Metadata() IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *PartDirectiveContext) Uri() IUriContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUriContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUriContext)
}

func (s *PartDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterPartDirective(s)
	}
}

func (s *PartDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitPartDirective(s)
	}
}

func (p *Dart2Parser) PartDirective() (localctx IPartDirectiveContext) {
	this := p
	_ = this

	localctx = NewPartDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, Dart2ParserRULE_partDirective)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1735)
		p.Metadata()
	}
	{
		p.SetState(1736)
		p.Match(Dart2ParserT__114)
	}
	{
		p.SetState(1737)
		p.Uri()
	}
	{
		p.SetState(1738)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// IPartHeaderContext is an interface to support dynamic dispatch.
type IPartHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartHeaderContext differentiates from other interfaces.
	IsPartHeaderContext()
}

type PartHeaderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartHeaderContext() *PartHeaderContext {
	var p = new(PartHeaderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_partHeader
	return p
}

func (*PartHeaderContext) IsPartHeaderContext() {}

func NewPartHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartHeaderContext {
	var p = new(PartHeaderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_partHeader

	return p
}

func (s *PartHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *PartHeaderContext) Metadata() IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *PartHeaderContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *PartHeaderContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterPartHeader(s)
	}
}

func (s *PartHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitPartHeader(s)
	}
}

func (p *Dart2Parser) PartHeader() (localctx IPartHeaderContext) {
	this := p
	_ = this

	localctx = NewPartHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, Dart2ParserRULE_partHeader)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1740)
		p.Metadata()
	}
	{
		p.SetState(1741)
		p.Match(Dart2ParserT__114)
	}
	{
		p.SetState(1742)
		p.Match(Dart2ParserT__115)
	}
	{
		p.SetState(1743)
		p.Identifier()
	}
	p.SetState(1748)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__19 {
		{
			p.SetState(1744)
			p.Match(Dart2ParserT__19)
		}
		{
			p.SetState(1745)
			p.Identifier()
		}

		p.SetState(1750)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1751)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// IPartDeclarationContext is an interface to support dynamic dispatch.
type IPartDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartDeclarationContext differentiates from other interfaces.
	IsPartDeclarationContext()
}

type PartDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartDeclarationContext() *PartDeclarationContext {
	var p = new(PartDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_partDeclaration
	return p
}

func (*PartDeclarationContext) IsPartDeclarationContext() {}

func NewPartDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartDeclarationContext {
	var p = new(PartDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_partDeclaration

	return p
}

func (s *PartDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PartDeclarationContext) PartHeader() IPartHeaderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartHeaderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartHeaderContext)
}

func (s *PartDeclarationContext) EOF() antlr.TerminalNode {
	return s.GetToken(Dart2ParserEOF, 0)
}

func (s *PartDeclarationContext) AllTopLevelDefinition() []ITopLevelDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITopLevelDefinitionContext)(nil)).Elem())
	var tst = make([]ITopLevelDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITopLevelDefinitionContext)
		}
	}

	return tst
}

func (s *PartDeclarationContext) TopLevelDefinition(i int) ITopLevelDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopLevelDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITopLevelDefinitionContext)
}

func (s *PartDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterPartDeclaration(s)
	}
}

func (s *PartDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitPartDeclaration(s)
	}
}

func (p *Dart2Parser) PartDeclaration() (localctx IPartDeclarationContext) {
	this := p
	_ = this

	localctx = NewPartDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, Dart2ParserRULE_partDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1753)
		p.PartHeader()
	}
	p.SetState(1757)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Dart2ParserT__1)|(1<<Dart2ParserT__2)|(1<<Dart2ParserT__3)|(1<<Dart2ParserT__5)|(1<<Dart2ParserT__21)|(1<<Dart2ParserT__22)|(1<<Dart2ParserT__25))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(Dart2ParserT__31-32))|(1<<(Dart2ParserT__32-32))|(1<<(Dart2ParserT__37-32))|(1<<(Dart2ParserT__40-32)))) != 0) || _la == Dart2ParserT__116 || _la == Dart2ParserIDENTIFIER {
		{
			p.SetState(1754)
			p.TopLevelDefinition()
		}

		p.SetState(1759)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1760)
		p.Match(Dart2ParserEOF)
	}

	return localctx
}

// IUriContext is an interface to support dynamic dispatch.
type IUriContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUriContext differentiates from other interfaces.
	IsUriContext()
}

type UriContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUriContext() *UriContext {
	var p = new(UriContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_uri
	return p
}

func (*UriContext) IsUriContext() {}

func NewUriContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UriContext {
	var p = new(UriContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_uri

	return p
}

func (s *UriContext) GetParser() antlr.Parser { return s.parser }

func (s *UriContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *UriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UriContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UriContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterUri(s)
	}
}

func (s *UriContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitUri(s)
	}
}

func (p *Dart2Parser) Uri() (localctx IUriContext) {
	this := p
	_ = this

	localctx = NewUriContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, Dart2ParserRULE_uri)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1762)
		p.StringLiteral()
	}

	return localctx
}

// IConfigurableUriContext is an interface to support dynamic dispatch.
type IConfigurableUriContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfigurableUriContext differentiates from other interfaces.
	IsConfigurableUriContext()
}

type ConfigurableUriContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfigurableUriContext() *ConfigurableUriContext {
	var p = new(ConfigurableUriContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_configurableUri
	return p
}

func (*ConfigurableUriContext) IsConfigurableUriContext() {}

func NewConfigurableUriContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConfigurableUriContext {
	var p = new(ConfigurableUriContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_configurableUri

	return p
}

func (s *ConfigurableUriContext) GetParser() antlr.Parser { return s.parser }

func (s *ConfigurableUriContext) Uri() IUriContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUriContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUriContext)
}

func (s *ConfigurableUriContext) AllConfigurationUri() []IConfigurationUriContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConfigurationUriContext)(nil)).Elem())
	var tst = make([]IConfigurationUriContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConfigurationUriContext)
		}
	}

	return tst
}

func (s *ConfigurableUriContext) ConfigurationUri(i int) IConfigurationUriContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfigurationUriContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConfigurationUriContext)
}

func (s *ConfigurableUriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConfigurableUriContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConfigurableUriContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterConfigurableUri(s)
	}
}

func (s *ConfigurableUriContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitConfigurableUri(s)
	}
}

func (p *Dart2Parser) ConfigurableUri() (localctx IConfigurableUriContext) {
	this := p
	_ = this

	localctx = NewConfigurableUriContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, Dart2ParserRULE_configurableUri)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1764)
		p.Uri()
	}
	p.SetState(1768)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__88 {
		{
			p.SetState(1765)
			p.ConfigurationUri()
		}

		p.SetState(1770)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IConfigurationUriContext is an interface to support dynamic dispatch.
type IConfigurationUriContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfigurationUriContext differentiates from other interfaces.
	IsConfigurationUriContext()
}

type ConfigurationUriContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfigurationUriContext() *ConfigurationUriContext {
	var p = new(ConfigurationUriContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_configurationUri
	return p
}

func (*ConfigurationUriContext) IsConfigurationUriContext() {}

func NewConfigurationUriContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConfigurationUriContext {
	var p = new(ConfigurationUriContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_configurationUri

	return p
}

func (s *ConfigurationUriContext) GetParser() antlr.Parser { return s.parser }

func (s *ConfigurationUriContext) UriTest() IUriTestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUriTestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUriTestContext)
}

func (s *ConfigurationUriContext) Uri() IUriContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUriContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUriContext)
}

func (s *ConfigurationUriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConfigurationUriContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConfigurationUriContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterConfigurationUri(s)
	}
}

func (s *ConfigurationUriContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitConfigurationUri(s)
	}
}

func (p *Dart2Parser) ConfigurationUri() (localctx IConfigurationUriContext) {
	this := p
	_ = this

	localctx = NewConfigurationUriContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, Dart2ParserRULE_configurationUri)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1771)
		p.Match(Dart2ParserT__88)
	}
	{
		p.SetState(1772)
		p.Match(Dart2ParserT__13)
	}
	{
		p.SetState(1773)
		p.UriTest()
	}
	{
		p.SetState(1774)
		p.Match(Dart2ParserT__14)
	}
	{
		p.SetState(1775)
		p.Uri()
	}

	return localctx
}

// IUriTestContext is an interface to support dynamic dispatch.
type IUriTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUriTestContext differentiates from other interfaces.
	IsUriTestContext()
}

type UriTestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUriTestContext() *UriTestContext {
	var p = new(UriTestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_uriTest
	return p
}

func (*UriTestContext) IsUriTestContext() {}

func NewUriTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UriTestContext {
	var p = new(UriTestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_uriTest

	return p
}

func (s *UriTestContext) GetParser() antlr.Parser { return s.parser }

func (s *UriTestContext) DottedIdentifierList() IDottedIdentifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDottedIdentifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDottedIdentifierListContext)
}

func (s *UriTestContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *UriTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UriTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UriTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterUriTest(s)
	}
}

func (s *UriTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitUriTest(s)
	}
}

func (p *Dart2Parser) UriTest() (localctx IUriTestContext) {
	this := p
	_ = this

	localctx = NewUriTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, Dart2ParserRULE_uriTest)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1777)
		p.DottedIdentifierList()
	}
	p.SetState(1780)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__30 {
		{
			p.SetState(1778)
			p.Match(Dart2ParserT__30)
		}
		{
			p.SetState(1779)
			p.StringLiteral()
		}

	}

	return localctx
}

// IDtypeContext is an interface to support dynamic dispatch.
type IDtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDtypeContext differentiates from other interfaces.
	IsDtypeContext()
}

type DtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtypeContext() *DtypeContext {
	var p = new(DtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_dtype
	return p
}

func (*DtypeContext) IsDtypeContext() {}

func NewDtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DtypeContext {
	var p = new(DtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_dtype

	return p
}

func (s *DtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DtypeContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *DtypeContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *DtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterDtype(s)
	}
}

func (s *DtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitDtype(s)
	}
}

func (p *Dart2Parser) Dtype() (localctx IDtypeContext) {
	this := p
	_ = this

	localctx = NewDtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, Dart2ParserRULE_dtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1782)
		p.TypeName()
	}
	p.SetState(1784)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__38 {
		{
			p.SetState(1783)
			p.TypeArguments()
		}

	}

	return localctx
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_typeName
	return p
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) Qualified() IQualifiedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedContext)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (p *Dart2Parser) TypeName() (localctx ITypeNameContext) {
	this := p
	_ = this

	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, Dart2ParserRULE_typeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1788)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Dart2ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1786)
			p.Qualified()
		}

	case Dart2ParserT__5:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1787)
			p.Match(Dart2ParserT__5)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_typeArguments
	return p
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) TypeList() ITypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitTypeArguments(s)
	}
}

func (p *Dart2Parser) TypeArguments() (localctx ITypeArgumentsContext) {
	this := p
	_ = this

	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, Dart2ParserRULE_typeArguments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1790)
		p.Match(Dart2ParserT__38)
	}
	{
		p.SetState(1791)
		p.TypeList()
	}
	{
		p.SetState(1792)
		p.Match(Dart2ParserT__39)
	}

	return localctx
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_typeList
	return p
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllDtype() []IDtypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDtypeContext)(nil)).Elem())
	var tst = make([]IDtypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDtypeContext)
		}
	}

	return tst
}

func (s *TypeListContext) Dtype(i int) IDtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (p *Dart2Parser) TypeList() (localctx ITypeListContext) {
	this := p
	_ = this

	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, Dart2ParserRULE_typeList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1794)
		p.Dtype()
	}
	p.SetState(1799)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Dart2ParserT__0 {
		{
			p.SetState(1795)
			p.Match(Dart2ParserT__0)
		}
		{
			p.SetState(1796)
			p.Dtype()
		}

		p.SetState(1801)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeAliasContext is an interface to support dynamic dispatch.
type ITypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeAliasContext differentiates from other interfaces.
	IsTypeAliasContext()
}

type TypeAliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasContext() *TypeAliasContext {
	var p = new(TypeAliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_typeAlias
	return p
}

func (*TypeAliasContext) IsTypeAliasContext() {}

func NewTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasContext {
	var p = new(TypeAliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_typeAlias

	return p
}

func (s *TypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasContext) Metadata() IMetadataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetadataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetadataContext)
}

func (s *TypeAliasContext) TypeAliasBody() ITypeAliasBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeAliasBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeAliasBodyContext)
}

func (s *TypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterTypeAlias(s)
	}
}

func (s *TypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitTypeAlias(s)
	}
}

func (p *Dart2Parser) TypeAlias() (localctx ITypeAliasContext) {
	this := p
	_ = this

	localctx = NewTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, Dart2ParserRULE_typeAlias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1802)
		p.Metadata()
	}
	{
		p.SetState(1803)
		p.Match(Dart2ParserT__116)
	}
	{
		p.SetState(1804)
		p.TypeAliasBody()
	}

	return localctx
}

// ITypeAliasBodyContext is an interface to support dynamic dispatch.
type ITypeAliasBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeAliasBodyContext differentiates from other interfaces.
	IsTypeAliasBodyContext()
}

type TypeAliasBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasBodyContext() *TypeAliasBodyContext {
	var p = new(TypeAliasBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_typeAliasBody
	return p
}

func (*TypeAliasBodyContext) IsTypeAliasBodyContext() {}

func NewTypeAliasBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasBodyContext {
	var p = new(TypeAliasBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_typeAliasBody

	return p
}

func (s *TypeAliasBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasBodyContext) FunctionTypeAlias() IFunctionTypeAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionTypeAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeAliasContext)
}

func (s *TypeAliasBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterTypeAliasBody(s)
	}
}

func (s *TypeAliasBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitTypeAliasBody(s)
	}
}

func (p *Dart2Parser) TypeAliasBody() (localctx ITypeAliasBodyContext) {
	this := p
	_ = this

	localctx = NewTypeAliasBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, Dart2ParserRULE_typeAliasBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1806)
		p.FunctionTypeAlias()
	}

	return localctx
}

// IFunctionTypeAliasContext is an interface to support dynamic dispatch.
type IFunctionTypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionTypeAliasContext differentiates from other interfaces.
	IsFunctionTypeAliasContext()
}

type FunctionTypeAliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeAliasContext() *FunctionTypeAliasContext {
	var p = new(FunctionTypeAliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_functionTypeAlias
	return p
}

func (*FunctionTypeAliasContext) IsFunctionTypeAliasContext() {}

func NewFunctionTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeAliasContext {
	var p = new(FunctionTypeAliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_functionTypeAlias

	return p
}

func (s *FunctionTypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeAliasContext) FunctionPrefix() IFunctionPrefixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionPrefixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionPrefixContext)
}

func (s *FunctionTypeAliasContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionTypeAliasContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *FunctionTypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterFunctionTypeAlias(s)
	}
}

func (s *FunctionTypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitFunctionTypeAlias(s)
	}
}

func (p *Dart2Parser) FunctionTypeAlias() (localctx IFunctionTypeAliasContext) {
	this := p
	_ = this

	localctx = NewFunctionTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, Dart2ParserRULE_functionTypeAlias)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1808)
		p.FunctionPrefix()
	}
	p.SetState(1810)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Dart2ParserT__38 {
		{
			p.SetState(1809)
			p.TypeParameters()
		}

	}
	{
		p.SetState(1812)
		p.FormalParameterList()
	}
	{
		p.SetState(1813)
		p.Match(Dart2ParserT__8)
	}

	return localctx
}

// IFunctionPrefixContext is an interface to support dynamic dispatch.
type IFunctionPrefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionPrefixContext differentiates from other interfaces.
	IsFunctionPrefixContext()
}

type FunctionPrefixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionPrefixContext() *FunctionPrefixContext {
	var p = new(FunctionPrefixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Dart2ParserRULE_functionPrefix
	return p
}

func (*FunctionPrefixContext) IsFunctionPrefixContext() {}

func NewFunctionPrefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionPrefixContext {
	var p = new(FunctionPrefixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Dart2ParserRULE_functionPrefix

	return p
}

func (s *FunctionPrefixContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionPrefixContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionPrefixContext) ReturnType() IReturnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *FunctionPrefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionPrefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionPrefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.EnterFunctionPrefix(s)
	}
}

func (s *FunctionPrefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Dart2Listener); ok {
		listenerT.ExitFunctionPrefix(s)
	}
}

func (p *Dart2Parser) FunctionPrefix() (localctx IFunctionPrefixContext) {
	this := p
	_ = this

	localctx = NewFunctionPrefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, Dart2ParserRULE_functionPrefix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1816)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 214, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1815)
			p.ReturnType()
		}

	}
	{
		p.SetState(1818)
		p.Identifier()
	}

	return localctx
}
