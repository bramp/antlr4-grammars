// Code generated from ASN.g4 by ANTLR 4.7.2. DO NOT EDIT.

package asn // ASN
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 106, 1263,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 3, 2, 6, 2, 298, 10, 2, 13, 2, 14, 2, 299, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 308, 10, 3, 12, 3, 14, 3, 311, 11,
	3, 3, 3, 5, 3, 314, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 4, 3, 4, 5, 4, 326, 10, 4, 3, 5, 3, 5, 5, 5, 330, 10, 5, 3, 6, 3,
	6, 3, 6, 3, 6, 5, 6, 336, 10, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3,
	7, 5, 7, 345, 10, 7, 3, 8, 5, 8, 348, 10, 8, 3, 9, 3, 9, 3, 9, 3, 9, 5,
	9, 354, 10, 9, 3, 10, 5, 10, 357, 10, 10, 3, 11, 3, 11, 7, 11, 361, 10,
	11, 12, 11, 14, 11, 364, 11, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 13, 3,
	13, 3, 13, 3, 14, 3, 14, 3, 15, 3, 15, 3, 15, 7, 15, 378, 10, 15, 12, 15,
	14, 15, 381, 11, 15, 3, 16, 3, 16, 3, 16, 5, 16, 386, 10, 16, 3, 17, 3,
	17, 7, 17, 390, 10, 17, 12, 17, 14, 17, 393, 11, 17, 3, 18, 3, 18, 3, 18,
	3, 18, 3, 18, 5, 18, 400, 10, 18, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3,
	19, 5, 19, 408, 10, 19, 3, 19, 3, 19, 3, 20, 3, 20, 5, 20, 414, 10, 20,
	3, 21, 3, 21, 5, 21, 418, 10, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3,
	22, 3, 22, 3, 22, 5, 22, 428, 10, 22, 5, 22, 430, 10, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 438, 10, 22, 5, 22, 440, 10, 22, 3,
	23, 3, 23, 3, 24, 3, 24, 3, 24, 7, 24, 447, 10, 24, 12, 24, 14, 24, 450,
	11, 24, 3, 25, 3, 25, 3, 25, 3, 25, 5, 25, 456, 10, 25, 3, 25, 3, 25, 3,
	25, 5, 25, 461, 10, 25, 3, 26, 3, 26, 5, 26, 465, 10, 26, 3, 27, 3, 27,
	3, 27, 7, 27, 470, 10, 27, 12, 27, 14, 27, 473, 11, 27, 3, 28, 3, 28, 5,
	28, 477, 10, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 30, 3, 30, 5, 30,
	486, 10, 30, 3, 31, 3, 31, 3, 31, 3, 31, 5, 31, 492, 10, 31, 3, 31, 3,
	31, 5, 31, 496, 10, 31, 3, 31, 3, 31, 3, 31, 5, 31, 501, 10, 31, 3, 32,
	3, 32, 3, 32, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 511, 10, 33, 3,
	33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 518, 10, 33, 5, 33, 520, 10, 33,
	3, 34, 3, 34, 3, 34, 3, 34, 7, 34, 526, 10, 34, 12, 34, 14, 34, 529, 11,
	34, 3, 34, 3, 34, 3, 35, 3, 35, 3, 35, 5, 35, 536, 10, 35, 3, 35, 3, 35,
	3, 36, 3, 36, 5, 36, 542, 10, 36, 3, 37, 3, 37, 5, 37, 546, 10, 37, 3,
	38, 3, 38, 3, 38, 3, 39, 3, 39, 5, 39, 553, 10, 39, 3, 40, 3, 40, 5, 40,
	557, 10, 40, 3, 40, 3, 40, 3, 40, 5, 40, 562, 10, 40, 3, 41, 3, 41, 3,
	42, 3, 42, 3, 42, 3, 42, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 7, 43, 575,
	10, 43, 12, 43, 14, 43, 578, 11, 43, 3, 43, 3, 43, 5, 43, 582, 10, 43,
	3, 44, 3, 44, 3, 44, 3, 44, 3, 45, 3, 45, 6, 45, 590, 10, 45, 13, 45, 14,
	45, 591, 3, 45, 3, 45, 3, 46, 3, 46, 5, 46, 598, 10, 46, 3, 47, 3, 47,
	6, 47, 602, 10, 47, 13, 47, 14, 47, 603, 3, 47, 3, 47, 3, 48, 3, 48, 5,
	48, 610, 10, 48, 3, 49, 3, 49, 3, 50, 3, 50, 3, 50, 3, 51, 3, 51, 3, 51,
	5, 51, 620, 10, 51, 3, 51, 3, 51, 5, 51, 624, 10, 51, 3, 51, 5, 51, 627,
	10, 51, 3, 51, 5, 51, 630, 10, 51, 5, 51, 632, 10, 51, 3, 51, 3, 51, 3,
	51, 3, 51, 3, 51, 5, 51, 639, 10, 51, 5, 51, 641, 10, 51, 3, 51, 3, 51,
	3, 51, 3, 51, 3, 51, 5, 51, 648, 10, 51, 5, 51, 650, 10, 51, 5, 51, 652,
	10, 51, 3, 52, 3, 52, 3, 52, 5, 52, 657, 10, 52, 3, 53, 3, 53, 3, 53, 5,
	53, 662, 10, 53, 3, 54, 3, 54, 3, 54, 3, 54, 5, 54, 668, 10, 54, 3, 54,
	5, 54, 671, 10, 54, 3, 55, 3, 55, 3, 55, 5, 55, 676, 10, 55, 3, 56, 3,
	56, 3, 56, 3, 56, 5, 56, 682, 10, 56, 3, 57, 3, 57, 3, 57, 3, 57, 5, 57,
	688, 10, 57, 3, 58, 3, 58, 3, 58, 5, 58, 693, 10, 58, 3, 59, 3, 59, 5,
	59, 697, 10, 59, 3, 60, 3, 60, 3, 60, 3, 61, 3, 61, 5, 61, 704, 10, 61,
	3, 62, 3, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 5, 63, 715,
	10, 63, 5, 63, 717, 10, 63, 3, 63, 3, 63, 3, 63, 5, 63, 722, 10, 63, 5,
	63, 724, 10, 63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 7, 64, 732,
	10, 64, 12, 64, 14, 64, 735, 11, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 66,
	3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 746, 10, 66, 5, 66, 748, 10, 66, 3,
	67, 3, 67, 3, 68, 3, 68, 3, 69, 3, 69, 3, 69, 5, 69, 757, 10, 69, 3, 70,
	3, 70, 3, 70, 3, 70, 7, 70, 763, 10, 70, 12, 70, 14, 70, 766, 11, 70, 3,
	71, 3, 71, 3, 71, 3, 72, 3, 72, 3, 72, 3, 72, 7, 72, 775, 10, 72, 12, 72,
	14, 72, 778, 11, 72, 3, 73, 3, 73, 3, 74, 3, 74, 3, 75, 3, 75, 3, 76, 3,
	76, 5, 76, 788, 10, 76, 3, 77, 3, 77, 5, 77, 792, 10, 77, 3, 78, 3, 78,
	5, 78, 796, 10, 78, 3, 78, 5, 78, 799, 10, 78, 3, 78, 3, 78, 5, 78, 803,
	10, 78, 3, 78, 3, 78, 5, 78, 807, 10, 78, 3, 78, 3, 78, 3, 78, 3, 78, 5,
	78, 813, 10, 78, 3, 79, 3, 79, 3, 79, 3, 79, 5, 79, 819, 10, 79, 3, 80,
	3, 80, 3, 80, 3, 80, 5, 80, 825, 10, 80, 3, 81, 3, 81, 3, 81, 5, 81, 830,
	10, 81, 3, 82, 3, 82, 3, 82, 3, 82, 5, 82, 836, 10, 82, 3, 83, 3, 83, 3,
	83, 5, 83, 841, 10, 83, 3, 84, 3, 84, 3, 84, 3, 85, 3, 85, 3, 85, 3, 85,
	3, 86, 3, 86, 5, 86, 852, 10, 86, 3, 86, 7, 86, 855, 10, 86, 12, 86, 14,
	86, 858, 11, 86, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87,
	3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 5, 87, 873, 10, 87, 3, 88, 3, 88, 3,
	88, 3, 88, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 885, 10, 89,
	3, 89, 3, 89, 3, 90, 3, 90, 3, 90, 5, 90, 892, 10, 90, 3, 90, 3, 90, 3,
	90, 5, 90, 897, 10, 90, 3, 91, 3, 91, 3, 92, 3, 92, 3, 92, 5, 92, 904,
	10, 92, 3, 92, 5, 92, 907, 10, 92, 3, 93, 3, 93, 3, 93, 5, 93, 912, 10,
	93, 3, 93, 3, 93, 3, 94, 3, 94, 5, 94, 918, 10, 94, 3, 95, 3, 95, 3, 95,
	3, 95, 3, 95, 3, 95, 7, 95, 926, 10, 95, 12, 95, 14, 95, 929, 11, 95, 3,
	95, 3, 95, 3, 96, 3, 96, 3, 96, 5, 96, 936, 10, 96, 3, 97, 3, 97, 3, 97,
	3, 97, 3, 97, 3, 97, 5, 97, 944, 10, 97, 3, 98, 3, 98, 3, 99, 3, 99, 3,
	100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3,
	100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 5, 100, 967,
	10, 100, 3, 101, 5, 101, 970, 10, 101, 3, 101, 3, 101, 3, 101, 3, 101,
	5, 101, 976, 10, 101, 5, 101, 978, 10, 101, 3, 101, 3, 101, 3, 101, 5,
	101, 983, 10, 101, 5, 101, 985, 10, 101, 3, 102, 3, 102, 3, 102, 7, 102,
	990, 10, 102, 12, 102, 14, 102, 993, 11, 102, 3, 103, 3, 103, 3, 103, 3,
	104, 3, 104, 3, 105, 3, 105, 3, 106, 3, 106, 3, 106, 3, 106, 3, 106, 3,
	106, 3, 106, 5, 106, 1009, 10, 106, 3, 107, 3, 107, 3, 107, 3, 107, 3,
	108, 3, 108, 7, 108, 1017, 10, 108, 12, 108, 14, 108, 1020, 11, 108, 3,
	109, 3, 109, 3, 109, 3, 109, 3, 109, 5, 109, 1027, 10, 109, 3, 109, 5,
	109, 1030, 10, 109, 3, 109, 5, 109, 1033, 10, 109, 3, 110, 3, 110, 5, 110,
	1037, 10, 110, 3, 111, 3, 111, 3, 111, 3, 111, 3, 112, 3, 112, 3, 113,
	5, 113, 1046, 10, 113, 3, 113, 3, 113, 3, 114, 3, 114, 3, 114, 3, 114,
	3, 114, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 5, 115, 1061, 10,
	115, 3, 116, 3, 116, 5, 116, 1065, 10, 116, 3, 117, 3, 117, 3, 117, 7,
	117, 1070, 10, 117, 12, 117, 14, 117, 1073, 11, 117, 3, 118, 3, 118, 5,
	118, 1077, 10, 118, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 120, 3,
	120, 3, 121, 3, 121, 3, 121, 7, 121, 1089, 10, 121, 12, 121, 14, 121, 1092,
	11, 121, 3, 122, 3, 122, 3, 122, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123,
	3, 124, 3, 124, 3, 124, 3, 124, 5, 124, 1106, 10, 124, 3, 124, 3, 124,
	5, 124, 1110, 10, 124, 5, 124, 1112, 10, 124, 3, 125, 3, 125, 3, 126, 3,
	126, 3, 126, 7, 126, 1119, 10, 126, 12, 126, 14, 126, 1122, 11, 126, 3,
	127, 3, 127, 3, 127, 5, 127, 1127, 10, 127, 3, 128, 3, 128, 3, 128, 3,
	128, 5, 128, 1133, 10, 128, 3, 128, 3, 128, 3, 129, 3, 129, 3, 130, 3,
	130, 5, 130, 1141, 10, 130, 3, 131, 3, 131, 3, 131, 5, 131, 1146, 10, 131,
	3, 132, 3, 132, 3, 132, 3, 132, 7, 132, 1152, 10, 132, 12, 132, 14, 132,
	1155, 11, 132, 3, 132, 3, 132, 3, 133, 3, 133, 5, 133, 1161, 10, 133, 3,
	134, 3, 134, 3, 134, 3, 135, 3, 135, 3, 135, 3, 135, 3, 135, 3, 135, 5,
	135, 1172, 10, 135, 3, 136, 3, 136, 3, 137, 3, 137, 3, 137, 3, 137, 3,
	137, 5, 137, 1181, 10, 137, 3, 138, 3, 138, 3, 138, 7, 138, 1186, 10, 138,
	12, 138, 14, 138, 1189, 11, 138, 3, 139, 3, 139, 3, 139, 3, 140, 3, 140,
	3, 140, 3, 140, 5, 140, 1198, 10, 140, 3, 140, 3, 140, 3, 140, 3, 140,
	3, 140, 7, 140, 1205, 10, 140, 12, 140, 14, 140, 1208, 11, 140, 3, 140,
	3, 140, 5, 140, 1212, 10, 140, 3, 141, 3, 141, 3, 141, 5, 141, 1217, 10,
	141, 3, 141, 3, 141, 3, 142, 3, 142, 5, 142, 1223, 10, 142, 3, 143, 3,
	143, 3, 143, 7, 143, 1228, 10, 143, 12, 143, 14, 143, 1231, 11, 143, 3,
	144, 3, 144, 3, 144, 3, 145, 3, 145, 3, 145, 3, 145, 3, 145, 3, 145, 3,
	145, 5, 145, 1243, 10, 145, 3, 146, 3, 146, 3, 146, 7, 146, 1248, 10, 146,
	12, 146, 14, 146, 1251, 11, 146, 3, 147, 3, 147, 3, 147, 3, 147, 5, 147,
	1257, 10, 147, 3, 147, 3, 147, 3, 148, 3, 148, 3, 148, 2, 2, 149, 2, 4,
	6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
	44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
	80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
	114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
	144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
	174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
	204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232,
	234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262,
	264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292,
	294, 2, 9, 4, 2, 72, 72, 74, 75, 3, 2, 59, 60, 4, 2, 23, 23, 106, 106,
	3, 2, 46, 47, 4, 2, 45, 45, 48, 48, 3, 2, 56, 57, 4, 2, 7, 8, 18, 19, 2,
	1300, 2, 297, 3, 2, 2, 2, 4, 301, 3, 2, 2, 2, 6, 325, 3, 2, 2, 2, 8, 329,
	3, 2, 2, 2, 10, 335, 3, 2, 2, 2, 12, 344, 3, 2, 2, 2, 14, 347, 3, 2, 2,
	2, 16, 353, 3, 2, 2, 2, 18, 356, 3, 2, 2, 2, 20, 358, 3, 2, 2, 2, 22, 365,
	3, 2, 2, 2, 24, 369, 3, 2, 2, 2, 26, 372, 3, 2, 2, 2, 28, 374, 3, 2, 2,
	2, 30, 382, 3, 2, 2, 2, 32, 387, 3, 2, 2, 2, 34, 394, 3, 2, 2, 2, 36, 401,
	3, 2, 2, 2, 38, 411, 3, 2, 2, 2, 40, 417, 3, 2, 2, 2, 42, 439, 3, 2, 2,
	2, 44, 441, 3, 2, 2, 2, 46, 443, 3, 2, 2, 2, 48, 460, 3, 2, 2, 2, 50, 464,
	3, 2, 2, 2, 52, 466, 3, 2, 2, 2, 54, 476, 3, 2, 2, 2, 56, 478, 3, 2, 2,
	2, 58, 485, 3, 2, 2, 2, 60, 487, 3, 2, 2, 2, 62, 502, 3, 2, 2, 2, 64, 519,
	3, 2, 2, 2, 66, 521, 3, 2, 2, 2, 68, 535, 3, 2, 2, 2, 70, 541, 3, 2, 2,
	2, 72, 545, 3, 2, 2, 2, 74, 547, 3, 2, 2, 2, 76, 552, 3, 2, 2, 2, 78, 561,
	3, 2, 2, 2, 80, 563, 3, 2, 2, 2, 82, 565, 3, 2, 2, 2, 84, 569, 3, 2, 2,
	2, 86, 583, 3, 2, 2, 2, 88, 587, 3, 2, 2, 2, 90, 597, 3, 2, 2, 2, 92, 599,
	3, 2, 2, 2, 94, 609, 3, 2, 2, 2, 96, 611, 3, 2, 2, 2, 98, 613, 3, 2, 2,
	2, 100, 616, 3, 2, 2, 2, 102, 653, 3, 2, 2, 2, 104, 661, 3, 2, 2, 2, 106,
	663, 3, 2, 2, 2, 108, 675, 3, 2, 2, 2, 110, 677, 3, 2, 2, 2, 112, 683,
	3, 2, 2, 2, 114, 692, 3, 2, 2, 2, 116, 696, 3, 2, 2, 2, 118, 698, 3, 2,
	2, 2, 120, 701, 3, 2, 2, 2, 122, 705, 3, 2, 2, 2, 124, 723, 3, 2, 2, 2,
	126, 725, 3, 2, 2, 2, 128, 736, 3, 2, 2, 2, 130, 740, 3, 2, 2, 2, 132,
	749, 3, 2, 2, 2, 134, 751, 3, 2, 2, 2, 136, 756, 3, 2, 2, 2, 138, 758,
	3, 2, 2, 2, 140, 767, 3, 2, 2, 2, 142, 770, 3, 2, 2, 2, 144, 779, 3, 2,
	2, 2, 146, 781, 3, 2, 2, 2, 148, 783, 3, 2, 2, 2, 150, 787, 3, 2, 2, 2,
	152, 789, 3, 2, 2, 2, 154, 812, 3, 2, 2, 2, 156, 814, 3, 2, 2, 2, 158,
	820, 3, 2, 2, 2, 160, 829, 3, 2, 2, 2, 162, 831, 3, 2, 2, 2, 164, 840,
	3, 2, 2, 2, 166, 842, 3, 2, 2, 2, 168, 845, 3, 2, 2, 2, 170, 851, 3, 2,
	2, 2, 172, 872, 3, 2, 2, 2, 174, 874, 3, 2, 2, 2, 176, 878, 3, 2, 2, 2,
	178, 888, 3, 2, 2, 2, 180, 898, 3, 2, 2, 2, 182, 900, 3, 2, 2, 2, 184,
	908, 3, 2, 2, 2, 186, 917, 3, 2, 2, 2, 188, 919, 3, 2, 2, 2, 190, 935,
	3, 2, 2, 2, 192, 937, 3, 2, 2, 2, 194, 945, 3, 2, 2, 2, 196, 947, 3, 2,
	2, 2, 198, 966, 3, 2, 2, 2, 200, 984, 3, 2, 2, 2, 202, 986, 3, 2, 2, 2,
	204, 994, 3, 2, 2, 2, 206, 997, 3, 2, 2, 2, 208, 999, 3, 2, 2, 2, 210,
	1008, 3, 2, 2, 2, 212, 1010, 3, 2, 2, 2, 214, 1014, 3, 2, 2, 2, 216, 1032,
	3, 2, 2, 2, 218, 1036, 3, 2, 2, 2, 220, 1038, 3, 2, 2, 2, 222, 1042, 3,
	2, 2, 2, 224, 1045, 3, 2, 2, 2, 226, 1049, 3, 2, 2, 2, 228, 1054, 3, 2,
	2, 2, 230, 1064, 3, 2, 2, 2, 232, 1066, 3, 2, 2, 2, 234, 1076, 3, 2, 2,
	2, 236, 1078, 3, 2, 2, 2, 238, 1083, 3, 2, 2, 2, 240, 1085, 3, 2, 2, 2,
	242, 1093, 3, 2, 2, 2, 244, 1096, 3, 2, 2, 2, 246, 1101, 3, 2, 2, 2, 248,
	1113, 3, 2, 2, 2, 250, 1115, 3, 2, 2, 2, 252, 1126, 3, 2, 2, 2, 254, 1128,
	3, 2, 2, 2, 256, 1136, 3, 2, 2, 2, 258, 1138, 3, 2, 2, 2, 260, 1142, 3,
	2, 2, 2, 262, 1147, 3, 2, 2, 2, 264, 1160, 3, 2, 2, 2, 266, 1162, 3, 2,
	2, 2, 268, 1171, 3, 2, 2, 2, 270, 1173, 3, 2, 2, 2, 272, 1175, 3, 2, 2,
	2, 274, 1182, 3, 2, 2, 2, 276, 1190, 3, 2, 2, 2, 278, 1193, 3, 2, 2, 2,
	280, 1216, 3, 2, 2, 2, 282, 1222, 3, 2, 2, 2, 284, 1224, 3, 2, 2, 2, 286,
	1232, 3, 2, 2, 2, 288, 1235, 3, 2, 2, 2, 290, 1244, 3, 2, 2, 2, 292, 1252,
	3, 2, 2, 2, 294, 1260, 3, 2, 2, 2, 296, 298, 5, 4, 3, 2, 297, 296, 3, 2,
	2, 2, 298, 299, 3, 2, 2, 2, 299, 297, 3, 2, 2, 2, 299, 300, 3, 2, 2, 2,
	300, 3, 3, 2, 2, 2, 301, 313, 7, 106, 2, 2, 302, 309, 7, 21, 2, 2, 303,
	304, 7, 106, 2, 2, 304, 305, 7, 24, 2, 2, 305, 306, 7, 100, 2, 2, 306,
	308, 7, 25, 2, 2, 307, 303, 3, 2, 2, 2, 308, 311, 3, 2, 2, 2, 309, 307,
	3, 2, 2, 2, 309, 310, 3, 2, 2, 2, 310, 312, 3, 2, 2, 2, 311, 309, 3, 2,
	2, 2, 312, 314, 7, 22, 2, 2, 313, 302, 3, 2, 2, 2, 313, 314, 3, 2, 2, 2,
	314, 315, 3, 2, 2, 2, 315, 316, 7, 76, 2, 2, 316, 317, 5, 6, 4, 2, 317,
	318, 5, 8, 5, 2, 318, 319, 7, 5, 2, 2, 319, 320, 7, 77, 2, 2, 320, 321,
	5, 10, 6, 2, 321, 322, 7, 78, 2, 2, 322, 5, 3, 2, 2, 2, 323, 324, 9, 2,
	2, 2, 324, 326, 7, 73, 2, 2, 325, 323, 3, 2, 2, 2, 325, 326, 3, 2, 2, 2,
	326, 7, 3, 2, 2, 2, 327, 328, 7, 70, 2, 2, 328, 330, 7, 71, 2, 2, 329,
	327, 3, 2, 2, 2, 329, 330, 3, 2, 2, 2, 330, 9, 3, 2, 2, 2, 331, 332, 5,
	12, 7, 2, 332, 333, 5, 16, 9, 2, 333, 334, 5, 32, 17, 2, 334, 336, 3, 2,
	2, 2, 335, 331, 3, 2, 2, 2, 335, 336, 3, 2, 2, 2, 336, 11, 3, 2, 2, 2,
	337, 338, 7, 69, 2, 2, 338, 339, 5, 14, 8, 2, 339, 340, 7, 67, 2, 2, 340,
	345, 3, 2, 2, 2, 341, 342, 7, 69, 2, 2, 342, 343, 7, 43, 2, 2, 343, 345,
	7, 67, 2, 2, 344, 337, 3, 2, 2, 2, 344, 341, 3, 2, 2, 2, 344, 345, 3, 2,
	2, 2, 345, 13, 3, 2, 2, 2, 346, 348, 5, 28, 15, 2, 347, 346, 3, 2, 2, 2,
	347, 348, 3, 2, 2, 2, 348, 15, 3, 2, 2, 2, 349, 350, 7, 68, 2, 2, 350,
	351, 5, 18, 10, 2, 351, 352, 7, 67, 2, 2, 352, 354, 3, 2, 2, 2, 353, 349,
	3, 2, 2, 2, 353, 354, 3, 2, 2, 2, 354, 17, 3, 2, 2, 2, 355, 357, 5, 20,
	11, 2, 356, 355, 3, 2, 2, 2, 356, 357, 3, 2, 2, 2, 357, 19, 3, 2, 2, 2,
	358, 362, 5, 22, 12, 2, 359, 361, 5, 22, 12, 2, 360, 359, 3, 2, 2, 2, 361,
	364, 3, 2, 2, 2, 362, 360, 3, 2, 2, 2, 362, 363, 3, 2, 2, 2, 363, 21, 3,
	2, 2, 2, 364, 362, 3, 2, 2, 2, 365, 366, 5, 28, 15, 2, 366, 367, 7, 53,
	2, 2, 367, 368, 5, 24, 13, 2, 368, 23, 3, 2, 2, 2, 369, 370, 7, 106, 2,
	2, 370, 371, 5, 26, 14, 2, 371, 25, 3, 2, 2, 2, 372, 373, 3, 2, 2, 2, 373,
	27, 3, 2, 2, 2, 374, 379, 5, 30, 16, 2, 375, 376, 7, 23, 2, 2, 376, 378,
	5, 30, 16, 2, 377, 375, 3, 2, 2, 2, 378, 381, 3, 2, 2, 2, 379, 377, 3,
	2, 2, 2, 379, 380, 3, 2, 2, 2, 380, 29, 3, 2, 2, 2, 381, 379, 3, 2, 2,
	2, 382, 385, 7, 106, 2, 2, 383, 384, 7, 21, 2, 2, 384, 386, 7, 22, 2, 2,
	385, 383, 3, 2, 2, 2, 385, 386, 3, 2, 2, 2, 386, 31, 3, 2, 2, 2, 387, 391,
	5, 34, 18, 2, 388, 390, 5, 34, 18, 2, 389, 388, 3, 2, 2, 2, 390, 393, 3,
	2, 2, 2, 391, 389, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 33, 3, 2, 2,
	2, 393, 391, 3, 2, 2, 2, 394, 399, 7, 106, 2, 2, 395, 400, 5, 168, 85,
	2, 396, 400, 5, 166, 84, 2, 397, 400, 5, 64, 33, 2, 398, 400, 5, 74, 38,
	2, 399, 395, 3, 2, 2, 2, 399, 396, 3, 2, 2, 2, 399, 397, 3, 2, 2, 2, 399,
	398, 3, 2, 2, 2, 400, 35, 3, 2, 2, 2, 401, 402, 7, 36, 2, 2, 402, 407,
	7, 21, 2, 2, 403, 404, 5, 38, 20, 2, 404, 405, 5, 40, 21, 2, 405, 408,
	3, 2, 2, 2, 406, 408, 5, 42, 22, 2, 407, 403, 3, 2, 2, 2, 407, 406, 3,
	2, 2, 2, 407, 408, 3, 2, 2, 2, 408, 409, 3, 2, 2, 2, 409, 410, 7, 22, 2,
	2, 410, 37, 3, 2, 2, 2, 411, 413, 7, 11, 2, 2, 412, 414, 5, 266, 134, 2,
	413, 412, 3, 2, 2, 2, 413, 414, 3, 2, 2, 2, 414, 39, 3, 2, 2, 2, 415, 416,
	7, 23, 2, 2, 416, 418, 7, 11, 2, 2, 417, 415, 3, 2, 2, 2, 417, 418, 3,
	2, 2, 2, 418, 41, 3, 2, 2, 2, 419, 429, 5, 44, 23, 2, 420, 421, 7, 23,
	2, 2, 421, 422, 5, 38, 20, 2, 422, 427, 5, 50, 26, 2, 423, 428, 5, 40,
	21, 2, 424, 425, 7, 99, 2, 2, 425, 426, 7, 23, 2, 2, 426, 428, 5, 44, 23,
	2, 427, 423, 3, 2, 2, 2, 427, 424, 3, 2, 2, 2, 428, 430, 3, 2, 2, 2, 429,
	420, 3, 2, 2, 2, 429, 430, 3, 2, 2, 2, 430, 440, 3, 2, 2, 2, 431, 432,
	5, 38, 20, 2, 432, 437, 5, 50, 26, 2, 433, 438, 5, 40, 21, 2, 434, 435,
	7, 99, 2, 2, 435, 436, 7, 23, 2, 2, 436, 438, 5, 44, 23, 2, 437, 433, 3,
	2, 2, 2, 437, 434, 3, 2, 2, 2, 438, 440, 3, 2, 2, 2, 439, 419, 3, 2, 2,
	2, 439, 431, 3, 2, 2, 2, 440, 43, 3, 2, 2, 2, 441, 442, 5, 46, 24, 2, 442,
	45, 3, 2, 2, 2, 443, 448, 5, 48, 25, 2, 444, 445, 7, 23, 2, 2, 445, 447,
	5, 48, 25, 2, 446, 444, 3, 2, 2, 2, 447, 450, 3, 2, 2, 2, 448, 446, 3,
	2, 2, 2, 448, 449, 3, 2, 2, 2, 449, 47, 3, 2, 2, 2, 450, 448, 3, 2, 2,
	2, 451, 455, 5, 242, 122, 2, 452, 456, 7, 37, 2, 2, 453, 454, 7, 38, 2,
	2, 454, 456, 5, 208, 105, 2, 455, 452, 3, 2, 2, 2, 455, 453, 3, 2, 2, 2,
	455, 456, 3, 2, 2, 2, 456, 461, 3, 2, 2, 2, 457, 458, 7, 39, 2, 2, 458,
	459, 7, 40, 2, 2, 459, 461, 5, 170, 86, 2, 460, 451, 3, 2, 2, 2, 460, 457,
	3, 2, 2, 2, 461, 49, 3, 2, 2, 2, 462, 463, 7, 23, 2, 2, 463, 465, 5, 52,
	27, 2, 464, 462, 3, 2, 2, 2, 464, 465, 3, 2, 2, 2, 465, 51, 3, 2, 2, 2,
	466, 471, 5, 54, 28, 2, 467, 468, 7, 23, 2, 2, 468, 470, 5, 54, 28, 2,
	469, 467, 3, 2, 2, 2, 470, 473, 3, 2, 2, 2, 471, 469, 3, 2, 2, 2, 471,
	472, 3, 2, 2, 2, 472, 53, 3, 2, 2, 2, 473, 471, 3, 2, 2, 2, 474, 477, 5,
	48, 25, 2, 475, 477, 5, 56, 29, 2, 476, 474, 3, 2, 2, 2, 476, 475, 3, 2,
	2, 2, 477, 55, 3, 2, 2, 2, 478, 479, 7, 79, 2, 2, 479, 480, 5, 58, 30,
	2, 480, 481, 5, 46, 24, 2, 481, 482, 7, 80, 2, 2, 482, 57, 3, 2, 2, 2,
	483, 484, 7, 100, 2, 2, 484, 486, 7, 81, 2, 2, 485, 483, 3, 2, 2, 2, 485,
	486, 3, 2, 2, 2, 486, 59, 3, 2, 2, 2, 487, 495, 7, 36, 2, 2, 488, 491,
	7, 24, 2, 2, 489, 492, 5, 184, 93, 2, 490, 492, 5, 62, 32, 2, 491, 489,
	3, 2, 2, 2, 491, 490, 3, 2, 2, 2, 492, 493, 3, 2, 2, 2, 493, 494, 7, 25,
	2, 2, 494, 496, 3, 2, 2, 2, 495, 488, 3, 2, 2, 2, 495, 496, 3, 2, 2, 2,
	496, 497, 3, 2, 2, 2, 497, 500, 7, 40, 2, 2, 498, 501, 5, 170, 86, 2, 499,
	501, 5, 242, 122, 2, 500, 498, 3, 2, 2, 2, 500, 499, 3, 2, 2, 2, 501, 61,
	3, 2, 2, 2, 502, 503, 7, 52, 2, 2, 503, 504, 5, 184, 93, 2, 504, 63, 3,
	2, 2, 2, 505, 506, 5, 66, 34, 2, 506, 510, 7, 5, 2, 2, 507, 511, 5, 170,
	86, 2, 508, 511, 5, 208, 105, 2, 509, 511, 5, 128, 65, 2, 510, 507, 3,
	2, 2, 2, 510, 508, 3, 2, 2, 2, 510, 509, 3, 2, 2, 2, 511, 520, 3, 2, 2,
	2, 512, 513, 5, 78, 40, 2, 513, 517, 7, 5, 2, 2, 514, 518, 5, 116, 59,
	2, 515, 518, 5, 76, 39, 2, 516, 518, 5, 122, 62, 2, 517, 514, 3, 2, 2,
	2, 517, 515, 3, 2, 2, 2, 517, 516, 3, 2, 2, 2, 518, 520, 3, 2, 2, 2, 519,
	505, 3, 2, 2, 2, 519, 512, 3, 2, 2, 2, 520, 65, 3, 2, 2, 2, 521, 522, 7,
	21, 2, 2, 522, 527, 5, 68, 35, 2, 523, 524, 7, 23, 2, 2, 524, 526, 5, 68,
	35, 2, 525, 523, 3, 2, 2, 2, 526, 529, 3, 2, 2, 2, 527, 525, 3, 2, 2, 2,
	527, 528, 3, 2, 2, 2, 528, 530, 3, 2, 2, 2, 529, 527, 3, 2, 2, 2, 530,
	531, 7, 22, 2, 2, 531, 67, 3, 2, 2, 2, 532, 533, 5, 70, 36, 2, 533, 534,
	7, 81, 2, 2, 534, 536, 3, 2, 2, 2, 535, 532, 3, 2, 2, 2, 535, 536, 3, 2,
	2, 2, 536, 537, 3, 2, 2, 2, 537, 538, 7, 106, 2, 2, 538, 69, 3, 2, 2, 2,
	539, 542, 5, 72, 37, 2, 540, 542, 7, 106, 2, 2, 541, 539, 3, 2, 2, 2, 541,
	540, 3, 2, 2, 2, 542, 71, 3, 2, 2, 2, 543, 546, 5, 170, 86, 2, 544, 546,
	5, 78, 40, 2, 545, 543, 3, 2, 2, 2, 545, 544, 3, 2, 2, 2, 546, 73, 3, 2,
	2, 2, 547, 548, 7, 5, 2, 2, 548, 549, 5, 76, 39, 2, 549, 75, 3, 2, 2, 2,
	550, 553, 5, 78, 40, 2, 551, 553, 5, 84, 43, 2, 552, 550, 3, 2, 2, 2, 552,
	551, 3, 2, 2, 2, 553, 77, 3, 2, 2, 2, 554, 555, 7, 106, 2, 2, 555, 557,
	7, 9, 2, 2, 556, 554, 3, 2, 2, 2, 556, 557, 3, 2, 2, 2, 557, 558, 3, 2,
	2, 2, 558, 562, 7, 106, 2, 2, 559, 562, 7, 59, 2, 2, 560, 562, 7, 60, 2,
	2, 561, 556, 3, 2, 2, 2, 561, 559, 3, 2, 2, 2, 561, 560, 3, 2, 2, 2, 562,
	79, 3, 2, 2, 2, 563, 564, 9, 3, 2, 2, 564, 81, 3, 2, 2, 2, 565, 566, 7,
	106, 2, 2, 566, 567, 7, 9, 2, 2, 567, 568, 7, 106, 2, 2, 568, 83, 3, 2,
	2, 2, 569, 570, 7, 61, 2, 2, 570, 571, 7, 21, 2, 2, 571, 576, 5, 100, 51,
	2, 572, 573, 7, 23, 2, 2, 573, 575, 5, 100, 51, 2, 574, 572, 3, 2, 2, 2,
	575, 578, 3, 2, 2, 2, 576, 574, 3, 2, 2, 2, 576, 577, 3, 2, 2, 2, 577,
	579, 3, 2, 2, 2, 578, 576, 3, 2, 2, 2, 579, 581, 7, 22, 2, 2, 580, 582,
	5, 86, 44, 2, 581, 580, 3, 2, 2, 2, 581, 582, 3, 2, 2, 2, 582, 85, 3, 2,
	2, 2, 583, 584, 7, 54, 2, 2, 584, 585, 7, 63, 2, 2, 585, 586, 5, 88, 45,
	2, 586, 87, 3, 2, 2, 2, 587, 589, 7, 21, 2, 2, 588, 590, 5, 90, 46, 2,
	589, 588, 3, 2, 2, 2, 590, 591, 3, 2, 2, 2, 591, 589, 3, 2, 2, 2, 591,
	592, 3, 2, 2, 2, 592, 593, 3, 2, 2, 2, 593, 594, 7, 22, 2, 2, 594, 89,
	3, 2, 2, 2, 595, 598, 5, 94, 48, 2, 596, 598, 5, 92, 47, 2, 597, 595, 3,
	2, 2, 2, 597, 596, 3, 2, 2, 2, 598, 91, 3, 2, 2, 2, 599, 601, 7, 64, 2,
	2, 600, 602, 5, 90, 46, 2, 601, 600, 3, 2, 2, 2, 602, 603, 3, 2, 2, 2,
	603, 601, 3, 2, 2, 2, 603, 604, 3, 2, 2, 2, 604, 605, 3, 2, 2, 2, 605,
	606, 7, 65, 2, 2, 606, 93, 3, 2, 2, 2, 607, 610, 5, 96, 49, 2, 608, 610,
	5, 98, 50, 2, 609, 607, 3, 2, 2, 2, 609, 608, 3, 2, 2, 2, 610, 95, 3, 2,
	2, 2, 611, 612, 9, 4, 2, 2, 612, 97, 3, 2, 2, 2, 613, 614, 7, 13, 2, 2,
	614, 615, 7, 106, 2, 2, 615, 99, 3, 2, 2, 2, 616, 617, 7, 13, 2, 2, 617,
	651, 7, 106, 2, 2, 618, 620, 5, 104, 53, 2, 619, 618, 3, 2, 2, 2, 619,
	620, 3, 2, 2, 2, 620, 652, 3, 2, 2, 2, 621, 631, 5, 170, 86, 2, 622, 624,
	5, 114, 58, 2, 623, 622, 3, 2, 2, 2, 623, 624, 3, 2, 2, 2, 624, 632, 3,
	2, 2, 2, 625, 627, 7, 62, 2, 2, 626, 625, 3, 2, 2, 2, 626, 627, 3, 2, 2,
	2, 627, 629, 3, 2, 2, 2, 628, 630, 5, 108, 55, 2, 629, 628, 3, 2, 2, 2,
	629, 630, 3, 2, 2, 2, 630, 632, 3, 2, 2, 2, 631, 623, 3, 2, 2, 2, 631,
	626, 3, 2, 2, 2, 632, 652, 3, 2, 2, 2, 633, 640, 5, 126, 64, 2, 634, 641,
	7, 37, 2, 2, 635, 638, 7, 38, 2, 2, 636, 639, 5, 128, 65, 2, 637, 639,
	5, 208, 105, 2, 638, 636, 3, 2, 2, 2, 638, 637, 3, 2, 2, 2, 639, 641, 3,
	2, 2, 2, 640, 634, 3, 2, 2, 2, 640, 635, 3, 2, 2, 2, 640, 641, 3, 2, 2,
	2, 641, 652, 3, 2, 2, 2, 642, 649, 5, 78, 40, 2, 643, 650, 7, 37, 2, 2,
	644, 647, 7, 38, 2, 2, 645, 648, 5, 122, 62, 2, 646, 648, 5, 116, 59, 2,
	647, 645, 3, 2, 2, 2, 647, 646, 3, 2, 2, 2, 648, 650, 3, 2, 2, 2, 649,
	643, 3, 2, 2, 2, 649, 644, 3, 2, 2, 2, 649, 650, 3, 2, 2, 2, 650, 652,
	3, 2, 2, 2, 651, 619, 3, 2, 2, 2, 651, 621, 3, 2, 2, 2, 651, 633, 3, 2,
	2, 2, 651, 642, 3, 2, 2, 2, 652, 101, 3, 2, 2, 2, 653, 654, 7, 13, 2, 2,
	654, 656, 7, 106, 2, 2, 655, 657, 5, 104, 53, 2, 656, 655, 3, 2, 2, 2,
	656, 657, 3, 2, 2, 2, 657, 103, 3, 2, 2, 2, 658, 662, 7, 37, 2, 2, 659,
	660, 7, 38, 2, 2, 660, 662, 5, 170, 86, 2, 661, 658, 3, 2, 2, 2, 661, 659,
	3, 2, 2, 2, 662, 105, 3, 2, 2, 2, 663, 664, 7, 13, 2, 2, 664, 665, 7, 106,
	2, 2, 665, 667, 5, 170, 86, 2, 666, 668, 7, 62, 2, 2, 667, 666, 3, 2, 2,
	2, 667, 668, 3, 2, 2, 2, 668, 670, 3, 2, 2, 2, 669, 671, 5, 108, 55, 2,
	670, 669, 3, 2, 2, 2, 670, 671, 3, 2, 2, 2, 671, 107, 3, 2, 2, 2, 672,
	676, 7, 37, 2, 2, 673, 674, 7, 38, 2, 2, 674, 676, 5, 208, 105, 2, 675,
	672, 3, 2, 2, 2, 675, 673, 3, 2, 2, 2, 676, 109, 3, 2, 2, 2, 677, 678,
	7, 13, 2, 2, 678, 679, 7, 106, 2, 2, 679, 681, 5, 126, 64, 2, 680, 682,
	5, 108, 55, 2, 681, 680, 3, 2, 2, 2, 681, 682, 3, 2, 2, 2, 682, 111, 3,
	2, 2, 2, 683, 684, 7, 13, 2, 2, 684, 685, 7, 106, 2, 2, 685, 687, 5, 170,
	86, 2, 686, 688, 5, 114, 58, 2, 687, 686, 3, 2, 2, 2, 687, 688, 3, 2, 2,
	2, 688, 113, 3, 2, 2, 2, 689, 693, 7, 37, 2, 2, 690, 691, 7, 38, 2, 2,
	691, 693, 5, 128, 65, 2, 692, 689, 3, 2, 2, 2, 692, 690, 3, 2, 2, 2, 693,
	115, 3, 2, 2, 2, 694, 697, 5, 120, 61, 2, 695, 697, 5, 118, 60, 2, 696,
	694, 3, 2, 2, 2, 696, 695, 3, 2, 2, 2, 697, 117, 3, 2, 2, 2, 698, 699,
	5, 120, 61, 2, 699, 700, 5, 262, 132, 2, 700, 119, 3, 2, 2, 2, 701, 703,
	7, 106, 2, 2, 702, 704, 7, 9, 2, 2, 703, 702, 3, 2, 2, 2, 703, 704, 3,
	2, 2, 2, 704, 121, 3, 2, 2, 2, 705, 706, 7, 21, 2, 2, 706, 707, 5, 124,
	63, 2, 707, 708, 7, 22, 2, 2, 708, 123, 3, 2, 2, 2, 709, 716, 5, 132, 67,
	2, 710, 711, 7, 23, 2, 2, 711, 714, 7, 11, 2, 2, 712, 713, 7, 23, 2, 2,
	713, 715, 5, 134, 68, 2, 714, 712, 3, 2, 2, 2, 714, 715, 3, 2, 2, 2, 715,
	717, 3, 2, 2, 2, 716, 710, 3, 2, 2, 2, 716, 717, 3, 2, 2, 2, 717, 724,
	3, 2, 2, 2, 718, 721, 7, 11, 2, 2, 719, 720, 7, 23, 2, 2, 720, 722, 5,
	134, 68, 2, 721, 719, 3, 2, 2, 2, 721, 722, 3, 2, 2, 2, 722, 724, 3, 2,
	2, 2, 723, 709, 3, 2, 2, 2, 723, 718, 3, 2, 2, 2, 724, 125, 3, 2, 2, 2,
	725, 726, 7, 13, 2, 2, 726, 727, 7, 106, 2, 2, 727, 733, 3, 2, 2, 2, 728,
	729, 7, 13, 2, 2, 729, 730, 7, 106, 2, 2, 730, 732, 7, 9, 2, 2, 731, 728,
	3, 2, 2, 2, 732, 735, 3, 2, 2, 2, 733, 731, 3, 2, 2, 2, 733, 734, 3, 2,
	2, 2, 734, 127, 3, 2, 2, 2, 735, 733, 3, 2, 2, 2, 736, 737, 7, 21, 2, 2,
	737, 738, 5, 130, 66, 2, 738, 739, 7, 22, 2, 2, 739, 129, 3, 2, 2, 2, 740,
	747, 5, 132, 67, 2, 741, 742, 7, 23, 2, 2, 742, 745, 7, 11, 2, 2, 743,
	744, 7, 23, 2, 2, 744, 746, 5, 134, 68, 2, 745, 743, 3, 2, 2, 2, 745, 746,
	3, 2, 2, 2, 746, 748, 3, 2, 2, 2, 747, 741, 3, 2, 2, 2, 747, 748, 3, 2,
	2, 2, 748, 131, 3, 2, 2, 2, 749, 750, 5, 136, 69, 2, 750, 133, 3, 2, 2,
	2, 751, 752, 5, 136, 69, 2, 752, 135, 3, 2, 2, 2, 753, 757, 5, 138, 70,
	2, 754, 755, 7, 43, 2, 2, 755, 757, 5, 140, 71, 2, 756, 753, 3, 2, 2, 2,
	756, 754, 3, 2, 2, 2, 757, 137, 3, 2, 2, 2, 758, 764, 5, 142, 72, 2, 759,
	760, 5, 144, 73, 2, 760, 761, 5, 142, 72, 2, 761, 763, 3, 2, 2, 2, 762,
	759, 3, 2, 2, 2, 763, 766, 3, 2, 2, 2, 764, 762, 3, 2, 2, 2, 764, 765,
	3, 2, 2, 2, 765, 139, 3, 2, 2, 2, 766, 764, 3, 2, 2, 2, 767, 768, 7, 44,
	2, 2, 768, 769, 5, 148, 75, 2, 769, 141, 3, 2, 2, 2, 770, 776, 5, 152,
	77, 2, 771, 772, 5, 146, 74, 2, 772, 773, 5, 152, 77, 2, 773, 775, 3, 2,
	2, 2, 774, 771, 3, 2, 2, 2, 775, 778, 3, 2, 2, 2, 776, 774, 3, 2, 2, 2,
	776, 777, 3, 2, 2, 2, 777, 143, 3, 2, 2, 2, 778, 776, 3, 2, 2, 2, 779,
	780, 9, 5, 2, 2, 780, 145, 3, 2, 2, 2, 781, 782, 9, 6, 2, 2, 782, 147,
	3, 2, 2, 2, 783, 784, 5, 154, 78, 2, 784, 149, 3, 2, 2, 2, 785, 788, 5,
	116, 59, 2, 786, 788, 5, 120, 61, 2, 787, 785, 3, 2, 2, 2, 787, 786, 3,
	2, 2, 2, 788, 151, 3, 2, 2, 2, 789, 791, 5, 148, 75, 2, 790, 792, 5, 140,
	71, 2, 791, 790, 3, 2, 2, 2, 791, 792, 3, 2, 2, 2, 792, 153, 3, 2, 2, 2,
	793, 796, 5, 208, 105, 2, 794, 796, 7, 50, 2, 2, 795, 793, 3, 2, 2, 2,
	795, 794, 3, 2, 2, 2, 796, 798, 3, 2, 2, 2, 797, 799, 7, 14, 2, 2, 798,
	797, 3, 2, 2, 2, 798, 799, 3, 2, 2, 2, 799, 800, 3, 2, 2, 2, 800, 802,
	7, 10, 2, 2, 801, 803, 7, 14, 2, 2, 802, 801, 3, 2, 2, 2, 802, 803, 3,
	2, 2, 2, 803, 806, 3, 2, 2, 2, 804, 807, 5, 208, 105, 2, 805, 807, 7, 51,
	2, 2, 806, 804, 3, 2, 2, 2, 806, 805, 3, 2, 2, 2, 807, 813, 3, 2, 2, 2,
	808, 813, 5, 62, 32, 2, 809, 810, 7, 58, 2, 2, 810, 813, 5, 208, 105, 2,
	811, 813, 5, 208, 105, 2, 812, 795, 3, 2, 2, 2, 812, 808, 3, 2, 2, 2, 812,
	809, 3, 2, 2, 2, 812, 811, 3, 2, 2, 2, 813, 155, 3, 2, 2, 2, 814, 815,
	7, 13, 2, 2, 815, 816, 7, 106, 2, 2, 816, 818, 5, 126, 64, 2, 817, 819,
	5, 114, 58, 2, 818, 817, 3, 2, 2, 2, 818, 819, 3, 2, 2, 2, 819, 157, 3,
	2, 2, 2, 820, 821, 7, 13, 2, 2, 821, 822, 7, 106, 2, 2, 822, 824, 5, 78,
	40, 2, 823, 825, 5, 160, 81, 2, 824, 823, 3, 2, 2, 2, 824, 825, 3, 2, 2,
	2, 825, 159, 3, 2, 2, 2, 826, 830, 7, 37, 2, 2, 827, 828, 7, 38, 2, 2,
	828, 830, 5, 116, 59, 2, 829, 826, 3, 2, 2, 2, 829, 827, 3, 2, 2, 2, 830,
	161, 3, 2, 2, 2, 831, 832, 7, 13, 2, 2, 832, 833, 7, 106, 2, 2, 833, 835,
	5, 78, 40, 2, 834, 836, 5, 164, 83, 2, 835, 834, 3, 2, 2, 2, 835, 836,
	3, 2, 2, 2, 836, 163, 3, 2, 2, 2, 837, 841, 7, 37, 2, 2, 838, 839, 7, 38,
	2, 2, 839, 841, 5, 122, 62, 2, 840, 837, 3, 2, 2, 2, 840, 838, 3, 2, 2,
	2, 841, 165, 3, 2, 2, 2, 842, 843, 7, 5, 2, 2, 843, 844, 5, 170, 86, 2,
	844, 167, 3, 2, 2, 2, 845, 846, 5, 170, 86, 2, 846, 847, 7, 5, 2, 2, 847,
	848, 5, 208, 105, 2, 848, 169, 3, 2, 2, 2, 849, 852, 5, 172, 87, 2, 850,
	852, 5, 180, 91, 2, 851, 849, 3, 2, 2, 2, 851, 850, 3, 2, 2, 2, 852, 856,
	3, 2, 2, 2, 853, 855, 5, 184, 93, 2, 854, 853, 3, 2, 2, 2, 855, 858, 3,
	2, 2, 2, 856, 854, 3, 2, 2, 2, 856, 857, 3, 2, 2, 2, 857, 171, 3, 2, 2,
	2, 858, 856, 3, 2, 2, 2, 859, 873, 5, 286, 144, 2, 860, 873, 5, 288, 145,
	2, 861, 873, 5, 226, 114, 2, 862, 873, 5, 244, 123, 2, 863, 873, 5, 272,
	137, 2, 864, 873, 5, 36, 19, 2, 865, 873, 5, 60, 31, 2, 866, 873, 5, 176,
	89, 2, 867, 873, 5, 178, 90, 2, 868, 873, 5, 276, 139, 2, 869, 873, 5,
	174, 88, 2, 870, 873, 7, 6, 2, 2, 871, 873, 7, 35, 2, 2, 872, 859, 3, 2,
	2, 2, 872, 860, 3, 2, 2, 2, 872, 861, 3, 2, 2, 2, 872, 862, 3, 2, 2, 2,
	872, 863, 3, 2, 2, 2, 872, 864, 3, 2, 2, 2, 872, 865, 3, 2, 2, 2, 872,
	866, 3, 2, 2, 2, 872, 867, 3, 2, 2, 2, 872, 868, 3, 2, 2, 2, 872, 869,
	3, 2, 2, 2, 872, 870, 3, 2, 2, 2, 872, 871, 3, 2, 2, 2, 873, 173, 3, 2,
	2, 2, 874, 875, 5, 78, 40, 2, 875, 876, 7, 9, 2, 2, 876, 877, 5, 126, 64,
	2, 877, 175, 3, 2, 2, 2, 878, 879, 7, 41, 2, 2, 879, 884, 7, 21, 2, 2,
	880, 881, 5, 38, 20, 2, 881, 882, 5, 40, 21, 2, 882, 885, 3, 2, 2, 2, 883,
	885, 5, 42, 22, 2, 884, 880, 3, 2, 2, 2, 884, 883, 3, 2, 2, 2, 884, 885,
	3, 2, 2, 2, 885, 886, 3, 2, 2, 2, 886, 887, 7, 22, 2, 2, 887, 177, 3, 2,
	2, 2, 888, 891, 7, 41, 2, 2, 889, 892, 5, 184, 93, 2, 890, 892, 5, 62,
	32, 2, 891, 889, 3, 2, 2, 2, 891, 890, 3, 2, 2, 2, 891, 892, 3, 2, 2, 2,
	892, 893, 3, 2, 2, 2, 893, 896, 7, 40, 2, 2, 894, 897, 5, 170, 86, 2, 895,
	897, 5, 242, 122, 2, 896, 894, 3, 2, 2, 2, 896, 895, 3, 2, 2, 2, 897, 179,
	3, 2, 2, 2, 898, 899, 5, 182, 92, 2, 899, 181, 3, 2, 2, 2, 900, 903, 7,
	106, 2, 2, 901, 902, 7, 9, 2, 2, 902, 904, 7, 106, 2, 2, 903, 901, 3, 2,
	2, 2, 903, 904, 3, 2, 2, 2, 904, 906, 3, 2, 2, 2, 905, 907, 5, 262, 132,
	2, 906, 905, 3, 2, 2, 2, 906, 907, 3, 2, 2, 2, 907, 183, 3, 2, 2, 2, 908,
	909, 7, 24, 2, 2, 909, 911, 5, 186, 94, 2, 910, 912, 5, 266, 134, 2, 911,
	910, 3, 2, 2, 2, 911, 912, 3, 2, 2, 2, 912, 913, 3, 2, 2, 2, 913, 914,
	7, 25, 2, 2, 914, 185, 3, 2, 2, 2, 915, 918, 5, 190, 96, 2, 916, 918, 5,
	206, 104, 2, 917, 915, 3, 2, 2, 2, 917, 916, 3, 2, 2, 2, 918, 187, 3, 2,
	2, 2, 919, 920, 7, 93, 2, 2, 920, 921, 7, 94, 2, 2, 921, 922, 7, 21, 2,
	2, 922, 927, 5, 192, 97, 2, 923, 924, 7, 23, 2, 2, 924, 926, 5, 192, 97,
	2, 925, 923, 3, 2, 2, 2, 926, 929, 3, 2, 2, 2, 927, 925, 3, 2, 2, 2, 927,
	928, 3, 2, 2, 2, 928, 930, 3, 2, 2, 2, 929, 927, 3, 2, 2, 2, 930, 931,
	7, 22, 2, 2, 931, 189, 3, 2, 2, 2, 932, 936, 5, 188, 95, 2, 933, 936, 5,
	194, 98, 2, 934, 936, 5, 198, 100, 2, 935, 932, 3, 2, 2, 2, 935, 933, 3,
	2, 2, 2, 935, 934, 3, 2, 2, 2, 936, 191, 3, 2, 2, 2, 937, 943, 5, 72, 37,
	2, 938, 939, 7, 81, 2, 2, 939, 944, 5, 208, 105, 2, 940, 944, 5, 128, 65,
	2, 941, 944, 5, 116, 59, 2, 942, 944, 5, 122, 62, 2, 943, 938, 3, 2, 2,
	2, 943, 940, 3, 2, 2, 2, 943, 941, 3, 2, 2, 2, 943, 942, 3, 2, 2, 2, 943,
	944, 3, 2, 2, 2, 944, 193, 3, 2, 2, 2, 945, 946, 5, 278, 140, 2, 946, 195,
	3, 2, 2, 2, 947, 948, 5, 122, 62, 2, 948, 197, 3, 2, 2, 2, 949, 950, 7,
	33, 2, 2, 950, 967, 5, 170, 86, 2, 951, 952, 7, 96, 2, 2, 952, 953, 7,
	94, 2, 2, 953, 967, 5, 208, 105, 2, 954, 955, 7, 33, 2, 2, 955, 956, 5,
	170, 86, 2, 956, 957, 7, 96, 2, 2, 957, 958, 7, 94, 2, 2, 958, 959, 5,
	208, 105, 2, 959, 967, 3, 2, 2, 2, 960, 961, 7, 54, 2, 2, 961, 962, 7,
	39, 2, 2, 962, 963, 7, 21, 2, 2, 963, 964, 5, 200, 101, 2, 964, 965, 7,
	22, 2, 2, 965, 967, 3, 2, 2, 2, 966, 949, 3, 2, 2, 2, 966, 951, 3, 2, 2,
	2, 966, 954, 3, 2, 2, 2, 966, 960, 3, 2, 2, 2, 967, 199, 3, 2, 2, 2, 968,
	970, 5, 202, 102, 2, 969, 968, 3, 2, 2, 2, 969, 970, 3, 2, 2, 2, 970, 977,
	3, 2, 2, 2, 971, 972, 7, 23, 2, 2, 972, 975, 7, 11, 2, 2, 973, 974, 7,
	23, 2, 2, 974, 976, 5, 202, 102, 2, 975, 973, 3, 2, 2, 2, 975, 976, 3,
	2, 2, 2, 976, 978, 3, 2, 2, 2, 977, 971, 3, 2, 2, 2, 977, 978, 3, 2, 2,
	2, 978, 985, 3, 2, 2, 2, 979, 982, 7, 11, 2, 2, 980, 981, 7, 23, 2, 2,
	981, 983, 5, 202, 102, 2, 982, 980, 3, 2, 2, 2, 982, 983, 3, 2, 2, 2, 983,
	985, 3, 2, 2, 2, 984, 969, 3, 2, 2, 2, 984, 979, 3, 2, 2, 2, 985, 201,
	3, 2, 2, 2, 986, 991, 5, 204, 103, 2, 987, 988, 7, 23, 2, 2, 988, 990,
	5, 204, 103, 2, 989, 987, 3, 2, 2, 2, 990, 993, 3, 2, 2, 2, 991, 989, 3,
	2, 2, 2, 991, 992, 3, 2, 2, 2, 992, 203, 3, 2, 2, 2, 993, 991, 3, 2, 2,
	2, 994, 995, 7, 106, 2, 2, 995, 996, 9, 7, 2, 2, 996, 205, 3, 2, 2, 2,
	997, 998, 5, 130, 66, 2, 998, 207, 3, 2, 2, 2, 999, 1000, 5, 210, 106,
	2, 1000, 209, 3, 2, 2, 2, 1001, 1009, 5, 222, 112, 2, 1002, 1009, 5, 218,
	110, 2, 1003, 1009, 5, 220, 111, 2, 1004, 1009, 5, 212, 107, 2, 1005, 1009,
	5, 294, 148, 2, 1006, 1009, 7, 105, 2, 2, 1007, 1009, 7, 103, 2, 2, 1008,
	1001, 3, 2, 2, 2, 1008, 1002, 3, 2, 2, 2, 1008, 1003, 3, 2, 2, 2, 1008,
	1004, 3, 2, 2, 2, 1008, 1005, 3, 2, 2, 2, 1008, 1006, 3, 2, 2, 2, 1008,
	1007, 3, 2, 2, 2, 1009, 211, 3, 2, 2, 2, 1010, 1011, 7, 21, 2, 2, 1011,
	1012, 5, 214, 108, 2, 1012, 1013, 7, 22, 2, 2, 1013, 213, 3, 2, 2, 2, 1014,
	1018, 5, 216, 109, 2, 1015, 1017, 5, 216, 109, 2, 1016, 1015, 3, 2, 2,
	2, 1017, 1020, 3, 2, 2, 2, 1018, 1016, 3, 2, 2, 2, 1018, 1019, 3, 2, 2,
	2, 1019, 215, 3, 2, 2, 2, 1020, 1018, 3, 2, 2, 2, 1021, 1033, 7, 100, 2,
	2, 1022, 1029, 7, 106, 2, 2, 1023, 1026, 7, 24, 2, 2, 1024, 1027, 7, 100,
	2, 2, 1025, 1027, 5, 256, 129, 2, 1026, 1024, 3, 2, 2, 2, 1026, 1025, 3,
	2, 2, 2, 1027, 1028, 3, 2, 2, 2, 1028, 1030, 7, 25, 2, 2, 1029, 1023, 3,
	2, 2, 2, 1029, 1030, 3, 2, 2, 2, 1030, 1033, 3, 2, 2, 2, 1031, 1033, 5,
	256, 129, 2, 1032, 1021, 3, 2, 2, 2, 1032, 1022, 3, 2, 2, 2, 1032, 1031,
	3, 2, 2, 2, 1033, 217, 3, 2, 2, 2, 1034, 1037, 5, 224, 113, 2, 1035, 1037,
	7, 106, 2, 2, 1036, 1034, 3, 2, 2, 2, 1036, 1035, 3, 2, 2, 2, 1037, 219,
	3, 2, 2, 2, 1038, 1039, 7, 106, 2, 2, 1039, 1040, 7, 81, 2, 2, 1040, 1041,
	5, 208, 105, 2, 1041, 221, 3, 2, 2, 2, 1042, 1043, 7, 106, 2, 2, 1043,
	223, 3, 2, 2, 2, 1044, 1046, 7, 26, 2, 2, 1045, 1044, 3, 2, 2, 2, 1045,
	1046, 3, 2, 2, 2, 1046, 1047, 3, 2, 2, 2, 1047, 1048, 7, 100, 2, 2, 1048,
	225, 3, 2, 2, 2, 1049, 1050, 7, 82, 2, 2, 1050, 1051, 7, 21, 2, 2, 1051,
	1052, 5, 228, 115, 2, 1052, 1053, 7, 22, 2, 2, 1053, 227, 3, 2, 2, 2, 1054,
	1060, 5, 238, 120, 2, 1055, 1056, 7, 23, 2, 2, 1056, 1057, 5, 38, 20, 2,
	1057, 1058, 5, 230, 116, 2, 1058, 1059, 5, 40, 21, 2, 1059, 1061, 3, 2,
	2, 2, 1060, 1055, 3, 2, 2, 2, 1060, 1061, 3, 2, 2, 2, 1061, 229, 3, 2,
	2, 2, 1062, 1063, 7, 23, 2, 2, 1063, 1065, 5, 232, 117, 2, 1064, 1062,
	3, 2, 2, 2, 1064, 1065, 3, 2, 2, 2, 1065, 231, 3, 2, 2, 2, 1066, 1071,
	5, 234, 118, 2, 1067, 1068, 7, 23, 2, 2, 1068, 1070, 5, 234, 118, 2, 1069,
	1067, 3, 2, 2, 2, 1070, 1073, 3, 2, 2, 2, 1071, 1069, 3, 2, 2, 2, 1071,
	1072, 3, 2, 2, 2, 1072, 233, 3, 2, 2, 2, 1073, 1071, 3, 2, 2, 2, 1074,
	1077, 5, 236, 119, 2, 1075, 1077, 5, 242, 122, 2, 1076, 1074, 3, 2, 2,
	2, 1076, 1075, 3, 2, 2, 2, 1077, 235, 3, 2, 2, 2, 1078, 1079, 7, 79, 2,
	2, 1079, 1080, 5, 58, 30, 2, 1080, 1081, 5, 240, 121, 2, 1081, 1082, 7,
	80, 2, 2, 1082, 237, 3, 2, 2, 2, 1083, 1084, 5, 240, 121, 2, 1084, 239,
	3, 2, 2, 2, 1085, 1090, 5, 242, 122, 2, 1086, 1087, 7, 23, 2, 2, 1087,
	1089, 5, 242, 122, 2, 1088, 1086, 3, 2, 2, 2, 1089, 1092, 3, 2, 2, 2, 1090,
	1088, 3, 2, 2, 2, 1090, 1091, 3, 2, 2, 2, 1091, 241, 3, 2, 2, 2, 1092,
	1090, 3, 2, 2, 2, 1093, 1094, 7, 106, 2, 2, 1094, 1095, 5, 170, 86, 2,
	1095, 243, 3, 2, 2, 2, 1096, 1097, 7, 27, 2, 2, 1097, 1098, 7, 21, 2, 2,
	1098, 1099, 5, 246, 124, 2, 1099, 1100, 7, 22, 2, 2, 1100, 245, 3, 2, 2,
	2, 1101, 1111, 5, 248, 125, 2, 1102, 1103, 7, 23, 2, 2, 1103, 1105, 7,
	11, 2, 2, 1104, 1106, 5, 266, 134, 2, 1105, 1104, 3, 2, 2, 2, 1105, 1106,
	3, 2, 2, 2, 1106, 1109, 3, 2, 2, 2, 1107, 1108, 7, 23, 2, 2, 1108, 1110,
	5, 270, 136, 2, 1109, 1107, 3, 2, 2, 2, 1109, 1110, 3, 2, 2, 2, 1110, 1112,
	3, 2, 2, 2, 1111, 1102, 3, 2, 2, 2, 1111, 1112, 3, 2, 2, 2, 1112, 247,
	3, 2, 2, 2, 1113, 1114, 5, 250, 126, 2, 1114, 249, 3, 2, 2, 2, 1115, 1120,
	5, 252, 127, 2, 1116, 1117, 7, 23, 2, 2, 1117, 1119, 5, 252, 127, 2, 1118,
	1116, 3, 2, 2, 2, 1119, 1122, 3, 2, 2, 2, 1120, 1118, 3, 2, 2, 2, 1120,
	1121, 3, 2, 2, 2, 1121, 251, 3, 2, 2, 2, 1122, 1120, 3, 2, 2, 2, 1123,
	1127, 7, 106, 2, 2, 1124, 1127, 5, 254, 128, 2, 1125, 1127, 5, 208, 105,
	2, 1126, 1123, 3, 2, 2, 2, 1126, 1124, 3, 2, 2, 2, 1126, 1125, 3, 2, 2,
	2, 1127, 253, 3, 2, 2, 2, 1128, 1129, 7, 106, 2, 2, 1129, 1132, 7, 24,
	2, 2, 1130, 1133, 5, 224, 113, 2, 1131, 1133, 5, 256, 129, 2, 1132, 1130,
	3, 2, 2, 2, 1132, 1131, 3, 2, 2, 2, 1133, 1134, 3, 2, 2, 2, 1134, 1135,
	7, 25, 2, 2, 1135, 255, 3, 2, 2, 2, 1136, 1137, 5, 258, 130, 2, 1137, 257,
	3, 2, 2, 2, 1138, 1140, 5, 260, 131, 2, 1139, 1141, 5, 262, 132, 2, 1140,
	1139, 3, 2, 2, 2, 1140, 1141, 3, 2, 2, 2, 1141, 259, 3, 2, 2, 2, 1142,
	1145, 7, 106, 2, 2, 1143, 1144, 7, 9, 2, 2, 1144, 1146, 7, 106, 2, 2, 1145,
	1143, 3, 2, 2, 2, 1145, 1146, 3, 2, 2, 2, 1146, 261, 3, 2, 2, 2, 1147,
	1148, 7, 21, 2, 2, 1148, 1153, 5, 264, 133, 2, 1149, 1150, 7, 23, 2, 2,
	1150, 1152, 5, 264, 133, 2, 1151, 1149, 3, 2, 2, 2, 1152, 1155, 3, 2, 2,
	2, 1153, 1151, 3, 2, 2, 2, 1153, 1154, 3, 2, 2, 2, 1154, 1156, 3, 2, 2,
	2, 1155, 1153, 3, 2, 2, 2, 1156, 1157, 7, 22, 2, 2, 1157, 263, 3, 2, 2,
	2, 1158, 1161, 5, 170, 86, 2, 1159, 1161, 5, 208, 105, 2, 1160, 1158, 3,
	2, 2, 2, 1160, 1159, 3, 2, 2, 2, 1161, 265, 3, 2, 2, 2, 1162, 1163, 7,
	42, 2, 2, 1163, 1164, 5, 268, 135, 2, 1164, 267, 3, 2, 2, 2, 1165, 1172,
	5, 224, 113, 2, 1166, 1172, 5, 256, 129, 2, 1167, 1168, 5, 170, 86, 2,
	1168, 1169, 7, 81, 2, 2, 1169, 1170, 5, 208, 105, 2, 1170, 1172, 3, 2,
	2, 2, 1171, 1165, 3, 2, 2, 2, 1171, 1166, 3, 2, 2, 2, 1171, 1167, 3, 2,
	2, 2, 1172, 269, 3, 2, 2, 2, 1173, 1174, 5, 250, 126, 2, 1174, 271, 3,
	2, 2, 2, 1175, 1180, 7, 20, 2, 2, 1176, 1177, 7, 21, 2, 2, 1177, 1178,
	5, 274, 138, 2, 1178, 1179, 7, 22, 2, 2, 1179, 1181, 3, 2, 2, 2, 1180,
	1176, 3, 2, 2, 2, 1180, 1181, 3, 2, 2, 2, 1181, 273, 3, 2, 2, 2, 1182,
	1187, 5, 254, 128, 2, 1183, 1184, 7, 23, 2, 2, 1184, 1186, 5, 254, 128,
	2, 1185, 1183, 3, 2, 2, 2, 1186, 1189, 3, 2, 2, 2, 1187, 1185, 3, 2, 2,
	2, 1187, 1188, 3, 2, 2, 2, 1188, 275, 3, 2, 2, 2, 1189, 1187, 3, 2, 2,
	2, 1190, 1191, 7, 89, 2, 2, 1191, 1192, 7, 90, 2, 2, 1192, 277, 3, 2, 2,
	2, 1193, 1194, 7, 21, 2, 2, 1194, 1197, 7, 106, 2, 2, 1195, 1196, 7, 9,
	2, 2, 1196, 1198, 7, 106, 2, 2, 1197, 1195, 3, 2, 2, 2, 1197, 1198, 3,
	2, 2, 2, 1198, 1199, 3, 2, 2, 2, 1199, 1211, 7, 22, 2, 2, 1200, 1201, 7,
	21, 2, 2, 1201, 1206, 5, 280, 141, 2, 1202, 1203, 7, 23, 2, 2, 1203, 1205,
	5, 280, 141, 2, 1204, 1202, 3, 2, 2, 2, 1205, 1208, 3, 2, 2, 2, 1206, 1204,
	3, 2, 2, 2, 1206, 1207, 3, 2, 2, 2, 1207, 1209, 3, 2, 2, 2, 1208, 1206,
	3, 2, 2, 2, 1209, 1210, 7, 22, 2, 2, 1210, 1212, 3, 2, 2, 2, 1211, 1200,
	3, 2, 2, 2, 1211, 1212, 3, 2, 2, 2, 1212, 279, 3, 2, 2, 2, 1213, 1217,
	7, 3, 2, 2, 1214, 1215, 7, 95, 2, 2, 1215, 1217, 5, 282, 142, 2, 1216,
	1213, 3, 2, 2, 2, 1216, 1214, 3, 2, 2, 2, 1217, 1218, 3, 2, 2, 2, 1218,
	1219, 5, 284, 143, 2, 1219, 281, 3, 2, 2, 2, 1220, 1221, 7, 9, 2, 2, 1221,
	1223, 5, 282, 142, 2, 1222, 1220, 3, 2, 2, 2, 1222, 1223, 3, 2, 2, 2, 1223,
	283, 3, 2, 2, 2, 1224, 1229, 7, 106, 2, 2, 1225, 1226, 7, 9, 2, 2, 1226,
	1228, 7, 106, 2, 2, 1227, 1225, 3, 2, 2, 2, 1228, 1231, 3, 2, 2, 2, 1229,
	1227, 3, 2, 2, 2, 1229, 1230, 3, 2, 2, 2, 1230, 285, 3, 2, 2, 2, 1231,
	1229, 3, 2, 2, 2, 1232, 1233, 7, 34, 2, 2, 1233, 1234, 7, 32, 2, 2, 1234,
	287, 3, 2, 2, 2, 1235, 1236, 7, 31, 2, 2, 1236, 1237, 7, 32, 2, 2, 1237,
	1242, 3, 2, 2, 2, 1238, 1239, 7, 21, 2, 2, 1239, 1240, 5, 290, 146, 2,
	1240, 1241, 7, 22, 2, 2, 1241, 1243, 3, 2, 2, 2, 1242, 1238, 3, 2, 2, 2,
	1242, 1243, 3, 2, 2, 2, 1243, 289, 3, 2, 2, 2, 1244, 1249, 5, 292, 147,
	2, 1245, 1246, 7, 23, 2, 2, 1246, 1248, 5, 292, 147, 2, 1247, 1245, 3,
	2, 2, 2, 1248, 1251, 3, 2, 2, 2, 1249, 1247, 3, 2, 2, 2, 1249, 1250, 3,
	2, 2, 2, 1250, 291, 3, 2, 2, 2, 1251, 1249, 3, 2, 2, 2, 1252, 1253, 7,
	106, 2, 2, 1253, 1256, 7, 24, 2, 2, 1254, 1257, 7, 100, 2, 2, 1255, 1257,
	5, 256, 129, 2, 1256, 1254, 3, 2, 2, 2, 1256, 1255, 3, 2, 2, 2, 1257, 1258,
	3, 2, 2, 2, 1258, 1259, 7, 25, 2, 2, 1259, 293, 3, 2, 2, 2, 1260, 1261,
	9, 8, 2, 2, 1261, 295, 3, 2, 2, 2, 146, 299, 309, 313, 325, 329, 335, 344,
	347, 353, 356, 362, 379, 385, 391, 399, 407, 413, 417, 427, 429, 437, 439,
	448, 455, 460, 464, 471, 476, 485, 491, 495, 500, 510, 517, 519, 527, 535,
	541, 545, 552, 556, 561, 576, 581, 591, 597, 603, 609, 619, 623, 626, 629,
	631, 638, 640, 647, 649, 651, 656, 661, 667, 670, 675, 681, 687, 692, 696,
	703, 714, 716, 721, 723, 733, 745, 747, 756, 764, 776, 787, 791, 795, 798,
	802, 806, 812, 818, 824, 829, 835, 840, 851, 856, 872, 884, 891, 896, 903,
	906, 911, 917, 927, 935, 943, 966, 969, 975, 977, 982, 984, 991, 1008,
	1018, 1026, 1029, 1032, 1036, 1045, 1060, 1064, 1071, 1076, 1090, 1105,
	1109, 1111, 1120, 1126, 1132, 1140, 1145, 1153, 1160, 1171, 1180, 1187,
	1197, 1206, 1211, 1216, 1222, 1229, 1242, 1249, 1256,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'@'", "'*'", "'::='", "'BOOLEAN'", "'TRUE'", "'FALSE'", "'.'", "'..'",
	"'...'", "'''", "'&'", "'<'", "'>'", "'</'", "'/>'", "'true'", "'false'",
	"'INTEGER'", "'{'", "'}'", "','", "'('", "')'", "'-'", "'ENUMERATED'",
	"'REAL'", "'PLUS-INFINITY'", "'MINUS-INFINITY'", "'BIT'", "'STRING'", "'CONTAINING'",
	"'OCTET'", "'NULL'", "'SEQUENCE'", "'OPTIONAL'", "'DEFAULT'", "'COMPONENTS'",
	"'OF'", "'SET'", "'!'", "'ALL'", "'EXCEPT'", "'^'", "'|'", "'UNION'", "'INTERSECTION'",
	"'INCLUDES'", "'MIN'", "'MAX'", "'SIZE'", "'FROM'", "'WITH'", "'COMPONENT'",
	"'PRESENT'", "'ABSENT'", "'PATTERN'", "'TYPE-Identifier'", "'ABSTRACT-SYNTAX'",
	"'CLASS'", "'UNIQUE'", "'SYNTAX'", "'['", "']'", "'INSTANCE'", "';'", "'IMPORTS'",
	"'EXPORTS'", "'EXTENSIBILITY'", "'IMPLIED'", "'EXPLICIT'", "'TAGS'", "'IMPLICIT'",
	"'AUTOMATIC'", "'DEFINITIONS'", "'BEGIN'", "'END'", "'[['", "']]'", "':'",
	"'CHOICE'", "'UNIVERSAL'", "'APPLICATION'", "'PRIVATE'", "'EMBEDDED'",
	"'PDV'", "'EXTERNAL'", "'OBJECT'", "'IDENTIFIER'", "'RELATIVE-OID'", "'CHARACTER'",
	"'CONSTRAINED'", "'BY'", "'@.'", "'ENCODED'", "'--'",
}
var symbolicNames = []string{
	"", "A_ROND", "STAR", "ASSIGN_OP", "BOOLEAN_LITERAL", "TRUE_LITERAL", "FALSE_LITERAL",
	"DOT", "DOUBLE_DOT", "ELLIPSIS", "APOSTROPHE", "AMPERSAND", "LESS_THAN",
	"GREATER_THAN", "LESS_THAN_SLASH", "SLASH_GREATER_THAN", "TRUE_SMALL_LITERAL",
	"FALSE_SMALL_LITERAL", "INTEGER_LITERAL", "L_BRACE", "R_BRACE", "COMMA",
	"L_PARAN", "R_PARAN", "MINUS", "ENUMERATED_LITERAL", "REAL_LITERAL", "PLUS_INFINITY_LITERAL",
	"MINUS_INFINITY_LITERAL", "BIT_LITERAL", "STRING_LITERAL", "CONTAINING_LITERAL",
	"OCTET_LITERAL", "NULL_LITERAL", "SEQUENCE_LITERAL", "OPTIONAL_LITERAL",
	"DEFAULT_LITERAL", "COMPONENTS_LITERAL", "OF_LITERAL", "SET_LITERAL", "EXCLAM",
	"ALL_LITERAL", "EXCEPT_LITERAL", "POWER", "PIPE", "UNION_LITERAL", "INTERSECTION_LITERAL",
	"INCLUDES_LITERAL", "MIN_LITERAL", "MAX_LITERAL", "SIZE_LITERAL", "FROM_LITERAL",
	"WITH_LITERAL", "COMPONENT_LITERAL", "PRESENT_LITERAL", "ABSENT_LITERAL",
	"PATTERN_LITERAL", "TYPE_IDENTIFIER_LITERAL", "ABSTRACT_SYNTAX_LITERAL",
	"CLASS_LITERAL", "UNIQUE_LITERAL", "SYNTAX_LITERAL", "L_BRACKET", "R_BRACKET",
	"INSTANCE_LITERAL", "SEMI_COLON", "IMPORTS_LITERAL", "EXPORTS_LITERAL",
	"EXTENSIBILITY_LITERAL", "IMPLIED_LITERAL", "EXPLICIT_LITERAL", "TAGS_LITERAL",
	"IMPLICIT_LITERAL", "AUTOMATIC_LITERAL", "DEFINITIONS_LITERAL", "BEGIN_LITERAL",
	"END_LITERAL", "DOUBLE_L_BRACKET", "DOUBLE_R_BRACKET", "COLON", "CHOICE_LITERAL",
	"UNIVERSAL_LITERAL", "APPLICATION_LITERAL", "PRIVATE_LITERAL", "EMBEDDED_LITERAL",
	"PDV_LITERAL", "EXTERNAL_LITERAL", "OBJECT_LITERAL", "IDENTIFIER_LITERAL",
	"RELATIVE_OID_LITERAL", "CHARACTER_LITERAL", "CONSTRAINED_LITERAL", "BY_LITERAL",
	"A_ROND_DOT", "ENCODED_LITERAL", "COMMENT", "UNRESTRICTEDCHARACTERSTRINGTYPE",
	"EXTENSTIONENDMARKER", "NUMBER", "WS", "LINE_COMMENT", "BSTRING", "HSTRING",
	"CSTRING", "IDENTIFIER",
}

var ruleNames = []string{
	"modules", "moduleDefinition", "tagDefault", "extensionDefault", "moduleBody",
	"exports", "symbolsExported", "imports", "symbolsImported", "symbolsFromModuleList",
	"symbolsFromModule", "globalModuleReference", "assignedIdentifier", "symbolList",
	"symbol", "assignmentList", "assignment", "sequenceType", "extensionAndException",
	"optionalExtensionMarker", "componentTypeLists", "rootComponentTypeList",
	"componentTypeList", "componentType", "extensionAdditions", "extensionAdditionList",
	"extensionAddition", "extensionAdditionGroup", "versionNumber", "sequenceOfType",
	"sizeConstraint", "parameterizedAssignment", "parameterList", "parameter",
	"paramGovernor", "governor", "objectClassAssignment", "objectClass", "definedObjectClass",
	"usefulObjectClassReference", "externalObjectClassReference", "objectClassDefn",
	"withSyntaxSpec", "syntaxList", "tokenOrGroupSpec", "optionalGroup", "requiredToken",
	"literal", "primitiveFieldName", "fieldSpec", "typeFieldSpec", "typeOptionalitySpec",
	"fixedTypeValueFieldSpec", "valueOptionalitySpec", "variableTypeValueFieldSpec",
	"fixedTypeValueSetFieldSpec", "valueSetOptionalitySpec", "object", "parameterizedObject",
	"definedObject", "objectSet", "objectSetSpec", "fieldName", "valueSet",
	"elementSetSpecs", "rootElementSetSpec", "additionalElementSetSpec", "elementSetSpec",
	"unions", "exclusions", "intersections", "unionMark", "intersectionMark",
	"elements", "objectSetElements", "intersectionElements", "subtypeElements",
	"variableTypeValueSetFieldSpec", "objectFieldSpec", "objectOptionalitySpec",
	"objectSetFieldSpec", "objectSetOptionalitySpec", "typeAssignment", "valueAssignment",
	"asnType", "builtinType", "objectClassFieldType", "setType", "setOfType",
	"referencedType", "definedType", "constraint", "constraintSpec", "userDefinedConstraint",
	"generalConstraint", "userDefinedConstraintParameter", "tableConstraint",
	"simpleTableConstraint", "contentsConstraint", "componentPresenceLists",
	"componentPresenceList", "componentPresence", "subtypeConstraint", "value",
	"builtinValue", "objectIdentifierValue", "objIdComponentsList", "objIdComponents",
	"integerValue", "choiceValue", "enumeratedValue", "signedNumber", "choiceType",
	"alternativeTypeLists", "extensionAdditionAlternatives", "extensionAdditionAlternativesList",
	"extensionAdditionAlternative", "extensionAdditionAlternativesGroup", "rootAlternativeTypeList",
	"alternativeTypeList", "namedType", "enumeratedType", "enumerations", "rootEnumeration",
	"enumeration", "enumerationItem", "namedNumber", "definedValue", "parameterizedValue",
	"simpleDefinedValue", "actualParameterList", "actualParameter", "exceptionSpec",
	"exceptionIdentification", "additionalEnumeration", "integerType", "namedNumberList",
	"objectidentifiertype", "componentRelationConstraint", "atNotation", "level",
	"componentIdList", "octetStringType", "bitStringType", "namedBitList",
	"namedBit", "booleanValue",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type ASNParser struct {
	*antlr.BaseParser
}

func NewASNParser(input antlr.TokenStream) *ASNParser {
	this := new(ASNParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ASN.g4"

	return this
}

// ASNParser tokens.
const (
	ASNParserEOF                             = antlr.TokenEOF
	ASNParserA_ROND                          = 1
	ASNParserSTAR                            = 2
	ASNParserASSIGN_OP                       = 3
	ASNParserBOOLEAN_LITERAL                 = 4
	ASNParserTRUE_LITERAL                    = 5
	ASNParserFALSE_LITERAL                   = 6
	ASNParserDOT                             = 7
	ASNParserDOUBLE_DOT                      = 8
	ASNParserELLIPSIS                        = 9
	ASNParserAPOSTROPHE                      = 10
	ASNParserAMPERSAND                       = 11
	ASNParserLESS_THAN                       = 12
	ASNParserGREATER_THAN                    = 13
	ASNParserLESS_THAN_SLASH                 = 14
	ASNParserSLASH_GREATER_THAN              = 15
	ASNParserTRUE_SMALL_LITERAL              = 16
	ASNParserFALSE_SMALL_LITERAL             = 17
	ASNParserINTEGER_LITERAL                 = 18
	ASNParserL_BRACE                         = 19
	ASNParserR_BRACE                         = 20
	ASNParserCOMMA                           = 21
	ASNParserL_PARAN                         = 22
	ASNParserR_PARAN                         = 23
	ASNParserMINUS                           = 24
	ASNParserENUMERATED_LITERAL              = 25
	ASNParserREAL_LITERAL                    = 26
	ASNParserPLUS_INFINITY_LITERAL           = 27
	ASNParserMINUS_INFINITY_LITERAL          = 28
	ASNParserBIT_LITERAL                     = 29
	ASNParserSTRING_LITERAL                  = 30
	ASNParserCONTAINING_LITERAL              = 31
	ASNParserOCTET_LITERAL                   = 32
	ASNParserNULL_LITERAL                    = 33
	ASNParserSEQUENCE_LITERAL                = 34
	ASNParserOPTIONAL_LITERAL                = 35
	ASNParserDEFAULT_LITERAL                 = 36
	ASNParserCOMPONENTS_LITERAL              = 37
	ASNParserOF_LITERAL                      = 38
	ASNParserSET_LITERAL                     = 39
	ASNParserEXCLAM                          = 40
	ASNParserALL_LITERAL                     = 41
	ASNParserEXCEPT_LITERAL                  = 42
	ASNParserPOWER                           = 43
	ASNParserPIPE                            = 44
	ASNParserUNION_LITERAL                   = 45
	ASNParserINTERSECTION_LITERAL            = 46
	ASNParserINCLUDES_LITERAL                = 47
	ASNParserMIN_LITERAL                     = 48
	ASNParserMAX_LITERAL                     = 49
	ASNParserSIZE_LITERAL                    = 50
	ASNParserFROM_LITERAL                    = 51
	ASNParserWITH_LITERAL                    = 52
	ASNParserCOMPONENT_LITERAL               = 53
	ASNParserPRESENT_LITERAL                 = 54
	ASNParserABSENT_LITERAL                  = 55
	ASNParserPATTERN_LITERAL                 = 56
	ASNParserTYPE_IDENTIFIER_LITERAL         = 57
	ASNParserABSTRACT_SYNTAX_LITERAL         = 58
	ASNParserCLASS_LITERAL                   = 59
	ASNParserUNIQUE_LITERAL                  = 60
	ASNParserSYNTAX_LITERAL                  = 61
	ASNParserL_BRACKET                       = 62
	ASNParserR_BRACKET                       = 63
	ASNParserINSTANCE_LITERAL                = 64
	ASNParserSEMI_COLON                      = 65
	ASNParserIMPORTS_LITERAL                 = 66
	ASNParserEXPORTS_LITERAL                 = 67
	ASNParserEXTENSIBILITY_LITERAL           = 68
	ASNParserIMPLIED_LITERAL                 = 69
	ASNParserEXPLICIT_LITERAL                = 70
	ASNParserTAGS_LITERAL                    = 71
	ASNParserIMPLICIT_LITERAL                = 72
	ASNParserAUTOMATIC_LITERAL               = 73
	ASNParserDEFINITIONS_LITERAL             = 74
	ASNParserBEGIN_LITERAL                   = 75
	ASNParserEND_LITERAL                     = 76
	ASNParserDOUBLE_L_BRACKET                = 77
	ASNParserDOUBLE_R_BRACKET                = 78
	ASNParserCOLON                           = 79
	ASNParserCHOICE_LITERAL                  = 80
	ASNParserUNIVERSAL_LITERAL               = 81
	ASNParserAPPLICATION_LITERAL             = 82
	ASNParserPRIVATE_LITERAL                 = 83
	ASNParserEMBEDDED_LITERAL                = 84
	ASNParserPDV_LITERAL                     = 85
	ASNParserEXTERNAL_LITERAL                = 86
	ASNParserOBJECT_LITERAL                  = 87
	ASNParserIDENTIFIER_LITERAL              = 88
	ASNParserRELATIVE_OID_LITERAL            = 89
	ASNParserCHARACTER_LITERAL               = 90
	ASNParserCONSTRAINED_LITERAL             = 91
	ASNParserBY_LITERAL                      = 92
	ASNParserA_ROND_DOT                      = 93
	ASNParserENCODED_LITERAL                 = 94
	ASNParserCOMMENT                         = 95
	ASNParserUNRESTRICTEDCHARACTERSTRINGTYPE = 96
	ASNParserEXTENSTIONENDMARKER             = 97
	ASNParserNUMBER                          = 98
	ASNParserWS                              = 99
	ASNParserLINE_COMMENT                    = 100
	ASNParserBSTRING                         = 101
	ASNParserHSTRING                         = 102
	ASNParserCSTRING                         = 103
	ASNParserIDENTIFIER                      = 104
)

// ASNParser rules.
const (
	ASNParserRULE_modules                            = 0
	ASNParserRULE_moduleDefinition                   = 1
	ASNParserRULE_tagDefault                         = 2
	ASNParserRULE_extensionDefault                   = 3
	ASNParserRULE_moduleBody                         = 4
	ASNParserRULE_exports                            = 5
	ASNParserRULE_symbolsExported                    = 6
	ASNParserRULE_imports                            = 7
	ASNParserRULE_symbolsImported                    = 8
	ASNParserRULE_symbolsFromModuleList              = 9
	ASNParserRULE_symbolsFromModule                  = 10
	ASNParserRULE_globalModuleReference              = 11
	ASNParserRULE_assignedIdentifier                 = 12
	ASNParserRULE_symbolList                         = 13
	ASNParserRULE_symbol                             = 14
	ASNParserRULE_assignmentList                     = 15
	ASNParserRULE_assignment                         = 16
	ASNParserRULE_sequenceType                       = 17
	ASNParserRULE_extensionAndException              = 18
	ASNParserRULE_optionalExtensionMarker            = 19
	ASNParserRULE_componentTypeLists                 = 20
	ASNParserRULE_rootComponentTypeList              = 21
	ASNParserRULE_componentTypeList                  = 22
	ASNParserRULE_componentType                      = 23
	ASNParserRULE_extensionAdditions                 = 24
	ASNParserRULE_extensionAdditionList              = 25
	ASNParserRULE_extensionAddition                  = 26
	ASNParserRULE_extensionAdditionGroup             = 27
	ASNParserRULE_versionNumber                      = 28
	ASNParserRULE_sequenceOfType                     = 29
	ASNParserRULE_sizeConstraint                     = 30
	ASNParserRULE_parameterizedAssignment            = 31
	ASNParserRULE_parameterList                      = 32
	ASNParserRULE_parameter                          = 33
	ASNParserRULE_paramGovernor                      = 34
	ASNParserRULE_governor                           = 35
	ASNParserRULE_objectClassAssignment              = 36
	ASNParserRULE_objectClass                        = 37
	ASNParserRULE_definedObjectClass                 = 38
	ASNParserRULE_usefulObjectClassReference         = 39
	ASNParserRULE_externalObjectClassReference       = 40
	ASNParserRULE_objectClassDefn                    = 41
	ASNParserRULE_withSyntaxSpec                     = 42
	ASNParserRULE_syntaxList                         = 43
	ASNParserRULE_tokenOrGroupSpec                   = 44
	ASNParserRULE_optionalGroup                      = 45
	ASNParserRULE_requiredToken                      = 46
	ASNParserRULE_literal                            = 47
	ASNParserRULE_primitiveFieldName                 = 48
	ASNParserRULE_fieldSpec                          = 49
	ASNParserRULE_typeFieldSpec                      = 50
	ASNParserRULE_typeOptionalitySpec                = 51
	ASNParserRULE_fixedTypeValueFieldSpec            = 52
	ASNParserRULE_valueOptionalitySpec               = 53
	ASNParserRULE_variableTypeValueFieldSpec         = 54
	ASNParserRULE_fixedTypeValueSetFieldSpec         = 55
	ASNParserRULE_valueSetOptionalitySpec            = 56
	ASNParserRULE_object                             = 57
	ASNParserRULE_parameterizedObject                = 58
	ASNParserRULE_definedObject                      = 59
	ASNParserRULE_objectSet                          = 60
	ASNParserRULE_objectSetSpec                      = 61
	ASNParserRULE_fieldName                          = 62
	ASNParserRULE_valueSet                           = 63
	ASNParserRULE_elementSetSpecs                    = 64
	ASNParserRULE_rootElementSetSpec                 = 65
	ASNParserRULE_additionalElementSetSpec           = 66
	ASNParserRULE_elementSetSpec                     = 67
	ASNParserRULE_unions                             = 68
	ASNParserRULE_exclusions                         = 69
	ASNParserRULE_intersections                      = 70
	ASNParserRULE_unionMark                          = 71
	ASNParserRULE_intersectionMark                   = 72
	ASNParserRULE_elements                           = 73
	ASNParserRULE_objectSetElements                  = 74
	ASNParserRULE_intersectionElements               = 75
	ASNParserRULE_subtypeElements                    = 76
	ASNParserRULE_variableTypeValueSetFieldSpec      = 77
	ASNParserRULE_objectFieldSpec                    = 78
	ASNParserRULE_objectOptionalitySpec              = 79
	ASNParserRULE_objectSetFieldSpec                 = 80
	ASNParserRULE_objectSetOptionalitySpec           = 81
	ASNParserRULE_typeAssignment                     = 82
	ASNParserRULE_valueAssignment                    = 83
	ASNParserRULE_asnType                            = 84
	ASNParserRULE_builtinType                        = 85
	ASNParserRULE_objectClassFieldType               = 86
	ASNParserRULE_setType                            = 87
	ASNParserRULE_setOfType                          = 88
	ASNParserRULE_referencedType                     = 89
	ASNParserRULE_definedType                        = 90
	ASNParserRULE_constraint                         = 91
	ASNParserRULE_constraintSpec                     = 92
	ASNParserRULE_userDefinedConstraint              = 93
	ASNParserRULE_generalConstraint                  = 94
	ASNParserRULE_userDefinedConstraintParameter     = 95
	ASNParserRULE_tableConstraint                    = 96
	ASNParserRULE_simpleTableConstraint              = 97
	ASNParserRULE_contentsConstraint                 = 98
	ASNParserRULE_componentPresenceLists             = 99
	ASNParserRULE_componentPresenceList              = 100
	ASNParserRULE_componentPresence                  = 101
	ASNParserRULE_subtypeConstraint                  = 102
	ASNParserRULE_value                              = 103
	ASNParserRULE_builtinValue                       = 104
	ASNParserRULE_objectIdentifierValue              = 105
	ASNParserRULE_objIdComponentsList                = 106
	ASNParserRULE_objIdComponents                    = 107
	ASNParserRULE_integerValue                       = 108
	ASNParserRULE_choiceValue                        = 109
	ASNParserRULE_enumeratedValue                    = 110
	ASNParserRULE_signedNumber                       = 111
	ASNParserRULE_choiceType                         = 112
	ASNParserRULE_alternativeTypeLists               = 113
	ASNParserRULE_extensionAdditionAlternatives      = 114
	ASNParserRULE_extensionAdditionAlternativesList  = 115
	ASNParserRULE_extensionAdditionAlternative       = 116
	ASNParserRULE_extensionAdditionAlternativesGroup = 117
	ASNParserRULE_rootAlternativeTypeList            = 118
	ASNParserRULE_alternativeTypeList                = 119
	ASNParserRULE_namedType                          = 120
	ASNParserRULE_enumeratedType                     = 121
	ASNParserRULE_enumerations                       = 122
	ASNParserRULE_rootEnumeration                    = 123
	ASNParserRULE_enumeration                        = 124
	ASNParserRULE_enumerationItem                    = 125
	ASNParserRULE_namedNumber                        = 126
	ASNParserRULE_definedValue                       = 127
	ASNParserRULE_parameterizedValue                 = 128
	ASNParserRULE_simpleDefinedValue                 = 129
	ASNParserRULE_actualParameterList                = 130
	ASNParserRULE_actualParameter                    = 131
	ASNParserRULE_exceptionSpec                      = 132
	ASNParserRULE_exceptionIdentification            = 133
	ASNParserRULE_additionalEnumeration              = 134
	ASNParserRULE_integerType                        = 135
	ASNParserRULE_namedNumberList                    = 136
	ASNParserRULE_objectidentifiertype               = 137
	ASNParserRULE_componentRelationConstraint        = 138
	ASNParserRULE_atNotation                         = 139
	ASNParserRULE_level                              = 140
	ASNParserRULE_componentIdList                    = 141
	ASNParserRULE_octetStringType                    = 142
	ASNParserRULE_bitStringType                      = 143
	ASNParserRULE_namedBitList                       = 144
	ASNParserRULE_namedBit                           = 145
	ASNParserRULE_booleanValue                       = 146
)

// IModulesContext is an interface to support dynamic dispatch.
type IModulesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModulesContext differentiates from other interfaces.
	IsModulesContext()
}

type ModulesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModulesContext() *ModulesContext {
	var p = new(ModulesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_modules
	return p
}

func (*ModulesContext) IsModulesContext() {}

func NewModulesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModulesContext {
	var p = new(ModulesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_modules

	return p
}

func (s *ModulesContext) GetParser() antlr.Parser { return s.parser }

func (s *ModulesContext) AllModuleDefinition() []IModuleDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleDefinitionContext)(nil)).Elem())
	var tst = make([]IModuleDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleDefinitionContext)
		}
	}

	return tst
}

func (s *ModulesContext) ModuleDefinition(i int) IModuleDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleDefinitionContext)
}

func (s *ModulesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModulesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModulesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterModules(s)
	}
}

func (s *ModulesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitModules(s)
	}
}

func (p *ASNParser) Modules() (localctx IModulesContext) {
	localctx = NewModulesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ASNParserRULE_modules)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(295)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ASNParserIDENTIFIER {
		{
			p.SetState(294)
			p.ModuleDefinition()
		}

		p.SetState(297)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IModuleDefinitionContext is an interface to support dynamic dispatch.
type IModuleDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleDefinitionContext differentiates from other interfaces.
	IsModuleDefinitionContext()
}

type ModuleDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDefinitionContext() *ModuleDefinitionContext {
	var p = new(ModuleDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_moduleDefinition
	return p
}

func (*ModuleDefinitionContext) IsModuleDefinitionContext() {}

func NewModuleDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDefinitionContext {
	var p = new(ModuleDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_moduleDefinition

	return p
}

func (s *ModuleDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDefinitionContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *ModuleDefinitionContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *ModuleDefinitionContext) DEFINITIONS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFINITIONS_LITERAL, 0)
}

func (s *ModuleDefinitionContext) TagDefault() ITagDefaultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITagDefaultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITagDefaultContext)
}

func (s *ModuleDefinitionContext) ExtensionDefault() IExtensionDefaultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionDefaultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionDefaultContext)
}

func (s *ModuleDefinitionContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASNParserASSIGN_OP, 0)
}

func (s *ModuleDefinitionContext) BEGIN_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserBEGIN_LITERAL, 0)
}

func (s *ModuleDefinitionContext) ModuleBody() IModuleBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleBodyContext)
}

func (s *ModuleDefinitionContext) END_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserEND_LITERAL, 0)
}

func (s *ModuleDefinitionContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ModuleDefinitionContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ModuleDefinitionContext) AllL_PARAN() []antlr.TerminalNode {
	return s.GetTokens(ASNParserL_PARAN)
}

func (s *ModuleDefinitionContext) L_PARAN(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserL_PARAN, i)
}

func (s *ModuleDefinitionContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserNUMBER)
}

func (s *ModuleDefinitionContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserNUMBER, i)
}

func (s *ModuleDefinitionContext) AllR_PARAN() []antlr.TerminalNode {
	return s.GetTokens(ASNParserR_PARAN)
}

func (s *ModuleDefinitionContext) R_PARAN(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserR_PARAN, i)
}

func (s *ModuleDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterModuleDefinition(s)
	}
}

func (s *ModuleDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitModuleDefinition(s)
	}
}

func (p *ASNParser) ModuleDefinition() (localctx IModuleDefinitionContext) {
	localctx = NewModuleDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ASNParserRULE_moduleDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(299)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(311)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserL_BRACE {
		{
			p.SetState(300)
			p.Match(ASNParserL_BRACE)
		}
		p.SetState(307)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ASNParserIDENTIFIER {
			{
				p.SetState(301)
				p.Match(ASNParserIDENTIFIER)
			}
			{
				p.SetState(302)
				p.Match(ASNParserL_PARAN)
			}
			{
				p.SetState(303)
				p.Match(ASNParserNUMBER)
			}
			{
				p.SetState(304)
				p.Match(ASNParserR_PARAN)
			}

			p.SetState(309)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(310)
			p.Match(ASNParserR_BRACE)
		}

	}
	{
		p.SetState(313)
		p.Match(ASNParserDEFINITIONS_LITERAL)
	}
	{
		p.SetState(314)
		p.TagDefault()
	}
	{
		p.SetState(315)
		p.ExtensionDefault()
	}
	{
		p.SetState(316)
		p.Match(ASNParserASSIGN_OP)
	}
	{
		p.SetState(317)
		p.Match(ASNParserBEGIN_LITERAL)
	}
	{
		p.SetState(318)
		p.ModuleBody()
	}
	{
		p.SetState(319)
		p.Match(ASNParserEND_LITERAL)
	}

	return localctx
}

// ITagDefaultContext is an interface to support dynamic dispatch.
type ITagDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTagDefaultContext differentiates from other interfaces.
	IsTagDefaultContext()
}

type TagDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTagDefaultContext() *TagDefaultContext {
	var p = new(TagDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_tagDefault
	return p
}

func (*TagDefaultContext) IsTagDefaultContext() {}

func NewTagDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagDefaultContext {
	var p = new(TagDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_tagDefault

	return p
}

func (s *TagDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *TagDefaultContext) TAGS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserTAGS_LITERAL, 0)
}

func (s *TagDefaultContext) EXPLICIT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserEXPLICIT_LITERAL, 0)
}

func (s *TagDefaultContext) IMPLICIT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserIMPLICIT_LITERAL, 0)
}

func (s *TagDefaultContext) AUTOMATIC_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserAUTOMATIC_LITERAL, 0)
}

func (s *TagDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterTagDefault(s)
	}
}

func (s *TagDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitTagDefault(s)
	}
}

func (p *ASNParser) TagDefault() (localctx ITagDefaultContext) {
	localctx = NewTagDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ASNParserRULE_tagDefault)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(323)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(ASNParserEXPLICIT_LITERAL-70))|(1<<(ASNParserIMPLICIT_LITERAL-70))|(1<<(ASNParserAUTOMATIC_LITERAL-70)))) != 0 {
		{
			p.SetState(321)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(ASNParserEXPLICIT_LITERAL-70))|(1<<(ASNParserIMPLICIT_LITERAL-70))|(1<<(ASNParserAUTOMATIC_LITERAL-70)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(322)
			p.Match(ASNParserTAGS_LITERAL)
		}

	}

	return localctx
}

// IExtensionDefaultContext is an interface to support dynamic dispatch.
type IExtensionDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionDefaultContext differentiates from other interfaces.
	IsExtensionDefaultContext()
}

type ExtensionDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionDefaultContext() *ExtensionDefaultContext {
	var p = new(ExtensionDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionDefault
	return p
}

func (*ExtensionDefaultContext) IsExtensionDefaultContext() {}

func NewExtensionDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionDefaultContext {
	var p = new(ExtensionDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionDefault

	return p
}

func (s *ExtensionDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionDefaultContext) EXTENSIBILITY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserEXTENSIBILITY_LITERAL, 0)
}

func (s *ExtensionDefaultContext) IMPLIED_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserIMPLIED_LITERAL, 0)
}

func (s *ExtensionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionDefault(s)
	}
}

func (s *ExtensionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionDefault(s)
	}
}

func (p *ASNParser) ExtensionDefault() (localctx IExtensionDefaultContext) {
	localctx = NewExtensionDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ASNParserRULE_extensionDefault)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserEXTENSIBILITY_LITERAL {
		{
			p.SetState(325)
			p.Match(ASNParserEXTENSIBILITY_LITERAL)
		}
		{
			p.SetState(326)
			p.Match(ASNParserIMPLIED_LITERAL)
		}

	}

	return localctx
}

// IModuleBodyContext is an interface to support dynamic dispatch.
type IModuleBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleBodyContext differentiates from other interfaces.
	IsModuleBodyContext()
}

type ModuleBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleBodyContext() *ModuleBodyContext {
	var p = new(ModuleBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_moduleBody
	return p
}

func (*ModuleBodyContext) IsModuleBodyContext() {}

func NewModuleBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleBodyContext {
	var p = new(ModuleBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_moduleBody

	return p
}

func (s *ModuleBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleBodyContext) Exports() IExportsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExportsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExportsContext)
}

func (s *ModuleBodyContext) Imports() IImportsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportsContext)
}

func (s *ModuleBodyContext) AssignmentList() IAssignmentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *ModuleBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterModuleBody(s)
	}
}

func (s *ModuleBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitModuleBody(s)
	}
}

func (p *ASNParser) ModuleBody() (localctx IModuleBodyContext) {
	localctx = NewModuleBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ASNParserRULE_moduleBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserIMPORTS_LITERAL || _la == ASNParserEXPORTS_LITERAL || _la == ASNParserIDENTIFIER {
		{
			p.SetState(329)
			p.Exports()
		}
		{
			p.SetState(330)
			p.Imports()
		}
		{
			p.SetState(331)
			p.AssignmentList()
		}

	}

	return localctx
}

// IExportsContext is an interface to support dynamic dispatch.
type IExportsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExportsContext differentiates from other interfaces.
	IsExportsContext()
}

type ExportsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportsContext() *ExportsContext {
	var p = new(ExportsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_exports
	return p
}

func (*ExportsContext) IsExportsContext() {}

func NewExportsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportsContext {
	var p = new(ExportsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_exports

	return p
}

func (s *ExportsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportsContext) EXPORTS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserEXPORTS_LITERAL, 0)
}

func (s *ExportsContext) SymbolsExported() ISymbolsExportedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolsExportedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolsExportedContext)
}

func (s *ExportsContext) SEMI_COLON() antlr.TerminalNode {
	return s.GetToken(ASNParserSEMI_COLON, 0)
}

func (s *ExportsContext) ALL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserALL_LITERAL, 0)
}

func (s *ExportsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExports(s)
	}
}

func (s *ExportsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExports(s)
	}
}

func (p *ASNParser) Exports() (localctx IExportsContext) {
	localctx = NewExportsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ASNParserRULE_exports)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(342)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(335)
			p.Match(ASNParserEXPORTS_LITERAL)
		}
		{
			p.SetState(336)
			p.SymbolsExported()
		}
		{
			p.SetState(337)
			p.Match(ASNParserSEMI_COLON)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(339)
			p.Match(ASNParserEXPORTS_LITERAL)
		}
		{
			p.SetState(340)
			p.Match(ASNParserALL_LITERAL)
		}
		{
			p.SetState(341)
			p.Match(ASNParserSEMI_COLON)
		}

	}

	return localctx
}

// ISymbolsExportedContext is an interface to support dynamic dispatch.
type ISymbolsExportedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolsExportedContext differentiates from other interfaces.
	IsSymbolsExportedContext()
}

type SymbolsExportedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolsExportedContext() *SymbolsExportedContext {
	var p = new(SymbolsExportedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_symbolsExported
	return p
}

func (*SymbolsExportedContext) IsSymbolsExportedContext() {}

func NewSymbolsExportedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolsExportedContext {
	var p = new(SymbolsExportedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_symbolsExported

	return p
}

func (s *SymbolsExportedContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolsExportedContext) SymbolList() ISymbolListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolListContext)
}

func (s *SymbolsExportedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolsExportedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolsExportedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSymbolsExported(s)
	}
}

func (s *SymbolsExportedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSymbolsExported(s)
	}
}

func (p *ASNParser) SymbolsExported() (localctx ISymbolsExportedContext) {
	localctx = NewSymbolsExportedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ASNParserRULE_symbolsExported)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(345)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserIDENTIFIER {
		{
			p.SetState(344)
			p.SymbolList()
		}

	}

	return localctx
}

// IImportsContext is an interface to support dynamic dispatch.
type IImportsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportsContext differentiates from other interfaces.
	IsImportsContext()
}

type ImportsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportsContext() *ImportsContext {
	var p = new(ImportsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_imports
	return p
}

func (*ImportsContext) IsImportsContext() {}

func NewImportsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportsContext {
	var p = new(ImportsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_imports

	return p
}

func (s *ImportsContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportsContext) IMPORTS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserIMPORTS_LITERAL, 0)
}

func (s *ImportsContext) SymbolsImported() ISymbolsImportedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolsImportedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolsImportedContext)
}

func (s *ImportsContext) SEMI_COLON() antlr.TerminalNode {
	return s.GetToken(ASNParserSEMI_COLON, 0)
}

func (s *ImportsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterImports(s)
	}
}

func (s *ImportsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitImports(s)
	}
}

func (p *ASNParser) Imports() (localctx IImportsContext) {
	localctx = NewImportsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ASNParserRULE_imports)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(351)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserIMPORTS_LITERAL {
		{
			p.SetState(347)
			p.Match(ASNParserIMPORTS_LITERAL)
		}
		{
			p.SetState(348)
			p.SymbolsImported()
		}
		{
			p.SetState(349)
			p.Match(ASNParserSEMI_COLON)
		}

	}

	return localctx
}

// ISymbolsImportedContext is an interface to support dynamic dispatch.
type ISymbolsImportedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolsImportedContext differentiates from other interfaces.
	IsSymbolsImportedContext()
}

type SymbolsImportedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolsImportedContext() *SymbolsImportedContext {
	var p = new(SymbolsImportedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_symbolsImported
	return p
}

func (*SymbolsImportedContext) IsSymbolsImportedContext() {}

func NewSymbolsImportedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolsImportedContext {
	var p = new(SymbolsImportedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_symbolsImported

	return p
}

func (s *SymbolsImportedContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolsImportedContext) SymbolsFromModuleList() ISymbolsFromModuleListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolsFromModuleListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolsFromModuleListContext)
}

func (s *SymbolsImportedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolsImportedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolsImportedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSymbolsImported(s)
	}
}

func (s *SymbolsImportedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSymbolsImported(s)
	}
}

func (p *ASNParser) SymbolsImported() (localctx ISymbolsImportedContext) {
	localctx = NewSymbolsImportedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ASNParserRULE_symbolsImported)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserIDENTIFIER {
		{
			p.SetState(353)
			p.SymbolsFromModuleList()
		}

	}

	return localctx
}

// ISymbolsFromModuleListContext is an interface to support dynamic dispatch.
type ISymbolsFromModuleListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolsFromModuleListContext differentiates from other interfaces.
	IsSymbolsFromModuleListContext()
}

type SymbolsFromModuleListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolsFromModuleListContext() *SymbolsFromModuleListContext {
	var p = new(SymbolsFromModuleListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_symbolsFromModuleList
	return p
}

func (*SymbolsFromModuleListContext) IsSymbolsFromModuleListContext() {}

func NewSymbolsFromModuleListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolsFromModuleListContext {
	var p = new(SymbolsFromModuleListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_symbolsFromModuleList

	return p
}

func (s *SymbolsFromModuleListContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolsFromModuleListContext) AllSymbolsFromModule() []ISymbolsFromModuleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolsFromModuleContext)(nil)).Elem())
	var tst = make([]ISymbolsFromModuleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolsFromModuleContext)
		}
	}

	return tst
}

func (s *SymbolsFromModuleListContext) SymbolsFromModule(i int) ISymbolsFromModuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolsFromModuleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolsFromModuleContext)
}

func (s *SymbolsFromModuleListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolsFromModuleListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolsFromModuleListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSymbolsFromModuleList(s)
	}
}

func (s *SymbolsFromModuleListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSymbolsFromModuleList(s)
	}
}

func (p *ASNParser) SymbolsFromModuleList() (localctx ISymbolsFromModuleListContext) {
	localctx = NewSymbolsFromModuleListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ASNParserRULE_symbolsFromModuleList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(356)
		p.SymbolsFromModule()
	}

	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserIDENTIFIER {
		{
			p.SetState(357)
			p.SymbolsFromModule()
		}

		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISymbolsFromModuleContext is an interface to support dynamic dispatch.
type ISymbolsFromModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolsFromModuleContext differentiates from other interfaces.
	IsSymbolsFromModuleContext()
}

type SymbolsFromModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolsFromModuleContext() *SymbolsFromModuleContext {
	var p = new(SymbolsFromModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_symbolsFromModule
	return p
}

func (*SymbolsFromModuleContext) IsSymbolsFromModuleContext() {}

func NewSymbolsFromModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolsFromModuleContext {
	var p = new(SymbolsFromModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_symbolsFromModule

	return p
}

func (s *SymbolsFromModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolsFromModuleContext) SymbolList() ISymbolListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolListContext)
}

func (s *SymbolsFromModuleContext) FROM_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserFROM_LITERAL, 0)
}

func (s *SymbolsFromModuleContext) GlobalModuleReference() IGlobalModuleReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobalModuleReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobalModuleReferenceContext)
}

func (s *SymbolsFromModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolsFromModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolsFromModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSymbolsFromModule(s)
	}
}

func (s *SymbolsFromModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSymbolsFromModule(s)
	}
}

func (p *ASNParser) SymbolsFromModule() (localctx ISymbolsFromModuleContext) {
	localctx = NewSymbolsFromModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ASNParserRULE_symbolsFromModule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(363)
		p.SymbolList()
	}
	{
		p.SetState(364)
		p.Match(ASNParserFROM_LITERAL)
	}
	{
		p.SetState(365)
		p.GlobalModuleReference()
	}

	return localctx
}

// IGlobalModuleReferenceContext is an interface to support dynamic dispatch.
type IGlobalModuleReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalModuleReferenceContext differentiates from other interfaces.
	IsGlobalModuleReferenceContext()
}

type GlobalModuleReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalModuleReferenceContext() *GlobalModuleReferenceContext {
	var p = new(GlobalModuleReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_globalModuleReference
	return p
}

func (*GlobalModuleReferenceContext) IsGlobalModuleReferenceContext() {}

func NewGlobalModuleReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalModuleReferenceContext {
	var p = new(GlobalModuleReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_globalModuleReference

	return p
}

func (s *GlobalModuleReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalModuleReferenceContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *GlobalModuleReferenceContext) AssignedIdentifier() IAssignedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignedIdentifierContext)
}

func (s *GlobalModuleReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalModuleReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalModuleReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterGlobalModuleReference(s)
	}
}

func (s *GlobalModuleReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitGlobalModuleReference(s)
	}
}

func (p *ASNParser) GlobalModuleReference() (localctx IGlobalModuleReferenceContext) {
	localctx = NewGlobalModuleReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ASNParserRULE_globalModuleReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(367)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(368)
		p.AssignedIdentifier()
	}

	return localctx
}

// IAssignedIdentifierContext is an interface to support dynamic dispatch.
type IAssignedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignedIdentifierContext differentiates from other interfaces.
	IsAssignedIdentifierContext()
}

type AssignedIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignedIdentifierContext() *AssignedIdentifierContext {
	var p = new(AssignedIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_assignedIdentifier
	return p
}

func (*AssignedIdentifierContext) IsAssignedIdentifierContext() {}

func NewAssignedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignedIdentifierContext {
	var p = new(AssignedIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_assignedIdentifier

	return p
}

func (s *AssignedIdentifierContext) GetParser() antlr.Parser { return s.parser }
func (s *AssignedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAssignedIdentifier(s)
	}
}

func (s *AssignedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAssignedIdentifier(s)
	}
}

func (p *ASNParser) AssignedIdentifier() (localctx IAssignedIdentifierContext) {
	localctx = NewAssignedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ASNParserRULE_assignedIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// ISymbolListContext is an interface to support dynamic dispatch.
type ISymbolListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolListContext differentiates from other interfaces.
	IsSymbolListContext()
}

type SymbolListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolListContext() *SymbolListContext {
	var p = new(SymbolListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_symbolList
	return p
}

func (*SymbolListContext) IsSymbolListContext() {}

func NewSymbolListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolListContext {
	var p = new(SymbolListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_symbolList

	return p
}

func (s *SymbolListContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolListContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *SymbolListContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *SymbolListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *SymbolListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *SymbolListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSymbolList(s)
	}
}

func (s *SymbolListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSymbolList(s)
	}
}

func (p *ASNParser) SymbolList() (localctx ISymbolListContext) {
	localctx = NewSymbolListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ASNParserRULE_symbolList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)
		p.Symbol()
	}

	p.SetState(377)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserCOMMA {
		{
			p.SetState(373)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(374)
			p.Symbol()
		}

		p.SetState(379)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISymbolContext is an interface to support dynamic dispatch.
type ISymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolContext differentiates from other interfaces.
	IsSymbolContext()
}

type SymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolContext() *SymbolContext {
	var p = new(SymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_symbol
	return p
}

func (*SymbolContext) IsSymbolContext() {}

func NewSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolContext {
	var p = new(SymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_symbol

	return p
}

func (s *SymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *SymbolContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *SymbolContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *SymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSymbol(s)
	}
}

func (s *SymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSymbol(s)
	}
}

func (p *ASNParser) Symbol() (localctx ISymbolContext) {
	localctx = NewSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ASNParserRULE_symbol)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(380)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(383)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserL_BRACE {
		{
			p.SetState(381)
			p.Match(ASNParserL_BRACE)
		}
		{
			p.SetState(382)
			p.Match(ASNParserR_BRACE)
		}

	}

	return localctx
}

// IAssignmentListContext is an interface to support dynamic dispatch.
type IAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentListContext differentiates from other interfaces.
	IsAssignmentListContext()
}

type AssignmentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListContext() *AssignmentListContext {
	var p = new(AssignmentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_assignmentList
	return p
}

func (*AssignmentListContext) IsAssignmentListContext() {}

func NewAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListContext {
	var p = new(AssignmentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_assignmentList

	return p
}

func (s *AssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListContext) AllAssignment() []IAssignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentContext)(nil)).Elem())
	var tst = make([]IAssignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentContext)
		}
	}

	return tst
}

func (s *AssignmentListContext) Assignment(i int) IAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *AssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAssignmentList(s)
	}
}

func (s *AssignmentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAssignmentList(s)
	}
}

func (p *ASNParser) AssignmentList() (localctx IAssignmentListContext) {
	localctx = NewAssignmentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ASNParserRULE_assignmentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(385)
		p.Assignment()
	}

	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserIDENTIFIER {
		{
			p.SetState(386)
			p.Assignment()
		}

		p.SetState(391)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_assignment
	return p
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *AssignmentContext) ValueAssignment() IValueAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueAssignmentContext)
}

func (s *AssignmentContext) TypeAssignment() ITypeAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeAssignmentContext)
}

func (s *AssignmentContext) ParameterizedAssignment() IParameterizedAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterizedAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterizedAssignmentContext)
}

func (s *AssignmentContext) ObjectClassAssignment() IObjectClassAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassAssignmentContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (p *ASNParser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ASNParserRULE_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(393)
			p.ValueAssignment()
		}

	case 2:
		{
			p.SetState(394)
			p.TypeAssignment()
		}

	case 3:
		{
			p.SetState(395)
			p.ParameterizedAssignment()
		}

	case 4:
		{
			p.SetState(396)
			p.ObjectClassAssignment()
		}

	}

	return localctx
}

// ISequenceTypeContext is an interface to support dynamic dispatch.
type ISequenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequenceTypeContext differentiates from other interfaces.
	IsSequenceTypeContext()
}

type SequenceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceTypeContext() *SequenceTypeContext {
	var p = new(SequenceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_sequenceType
	return p
}

func (*SequenceTypeContext) IsSequenceTypeContext() {}

func NewSequenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceTypeContext {
	var p = new(SequenceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_sequenceType

	return p
}

func (s *SequenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceTypeContext) SEQUENCE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSEQUENCE_LITERAL, 0)
}

func (s *SequenceTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *SequenceTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *SequenceTypeContext) ExtensionAndException() IExtensionAndExceptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAndExceptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAndExceptionContext)
}

func (s *SequenceTypeContext) OptionalExtensionMarker() IOptionalExtensionMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalExtensionMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalExtensionMarkerContext)
}

func (s *SequenceTypeContext) ComponentTypeLists() IComponentTypeListsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeListsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeListsContext)
}

func (s *SequenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSequenceType(s)
	}
}

func (s *SequenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSequenceType(s)
	}
}

func (p *ASNParser) SequenceType() (localctx ISequenceTypeContext) {
	localctx = NewSequenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ASNParserRULE_sequenceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(399)
		p.Match(ASNParserSEQUENCE_LITERAL)
	}
	{
		p.SetState(400)
		p.Match(ASNParserL_BRACE)
	}
	p.SetState(405)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(401)
			p.ExtensionAndException()
		}
		{
			p.SetState(402)
			p.OptionalExtensionMarker()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(404)
			p.ComponentTypeLists()
		}

	}
	{
		p.SetState(407)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IExtensionAndExceptionContext is an interface to support dynamic dispatch.
type IExtensionAndExceptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAndExceptionContext differentiates from other interfaces.
	IsExtensionAndExceptionContext()
}

type ExtensionAndExceptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAndExceptionContext() *ExtensionAndExceptionContext {
	var p = new(ExtensionAndExceptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAndException
	return p
}

func (*ExtensionAndExceptionContext) IsExtensionAndExceptionContext() {}

func NewExtensionAndExceptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAndExceptionContext {
	var p = new(ExtensionAndExceptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAndException

	return p
}

func (s *ExtensionAndExceptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAndExceptionContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASNParserELLIPSIS, 0)
}

func (s *ExtensionAndExceptionContext) ExceptionSpec() IExceptionSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExceptionSpecContext)
}

func (s *ExtensionAndExceptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAndExceptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAndExceptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAndException(s)
	}
}

func (s *ExtensionAndExceptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAndException(s)
	}
}

func (p *ASNParser) ExtensionAndException() (localctx IExtensionAndExceptionContext) {
	localctx = NewExtensionAndExceptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ASNParserRULE_extensionAndException)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(409)
		p.Match(ASNParserELLIPSIS)
	}
	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserEXCLAM {
		{
			p.SetState(410)
			p.ExceptionSpec()
		}

	}

	return localctx
}

// IOptionalExtensionMarkerContext is an interface to support dynamic dispatch.
type IOptionalExtensionMarkerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalExtensionMarkerContext differentiates from other interfaces.
	IsOptionalExtensionMarkerContext()
}

type OptionalExtensionMarkerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalExtensionMarkerContext() *OptionalExtensionMarkerContext {
	var p = new(OptionalExtensionMarkerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_optionalExtensionMarker
	return p
}

func (*OptionalExtensionMarkerContext) IsOptionalExtensionMarkerContext() {}

func NewOptionalExtensionMarkerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalExtensionMarkerContext {
	var p = new(OptionalExtensionMarkerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_optionalExtensionMarker

	return p
}

func (s *OptionalExtensionMarkerContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalExtensionMarkerContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, 0)
}

func (s *OptionalExtensionMarkerContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASNParserELLIPSIS, 0)
}

func (s *OptionalExtensionMarkerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalExtensionMarkerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalExtensionMarkerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterOptionalExtensionMarker(s)
	}
}

func (s *OptionalExtensionMarkerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitOptionalExtensionMarker(s)
	}
}

func (p *ASNParser) OptionalExtensionMarker() (localctx IOptionalExtensionMarkerContext) {
	localctx = NewOptionalExtensionMarkerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ASNParserRULE_optionalExtensionMarker)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(415)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserCOMMA {
		{
			p.SetState(413)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(414)
			p.Match(ASNParserELLIPSIS)
		}

	}

	return localctx
}

// IComponentTypeListsContext is an interface to support dynamic dispatch.
type IComponentTypeListsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentTypeListsContext differentiates from other interfaces.
	IsComponentTypeListsContext()
}

type ComponentTypeListsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentTypeListsContext() *ComponentTypeListsContext {
	var p = new(ComponentTypeListsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_componentTypeLists
	return p
}

func (*ComponentTypeListsContext) IsComponentTypeListsContext() {}

func NewComponentTypeListsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentTypeListsContext {
	var p = new(ComponentTypeListsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_componentTypeLists

	return p
}

func (s *ComponentTypeListsContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentTypeListsContext) AllRootComponentTypeList() []IRootComponentTypeListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRootComponentTypeListContext)(nil)).Elem())
	var tst = make([]IRootComponentTypeListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRootComponentTypeListContext)
		}
	}

	return tst
}

func (s *ComponentTypeListsContext) RootComponentTypeList(i int) IRootComponentTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootComponentTypeListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRootComponentTypeListContext)
}

func (s *ComponentTypeListsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ComponentTypeListsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ComponentTypeListsContext) ExtensionAndException() IExtensionAndExceptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAndExceptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAndExceptionContext)
}

func (s *ComponentTypeListsContext) ExtensionAdditions() IExtensionAdditionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionsContext)
}

func (s *ComponentTypeListsContext) OptionalExtensionMarker() IOptionalExtensionMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalExtensionMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalExtensionMarkerContext)
}

func (s *ComponentTypeListsContext) EXTENSTIONENDMARKER() antlr.TerminalNode {
	return s.GetToken(ASNParserEXTENSTIONENDMARKER, 0)
}

func (s *ComponentTypeListsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentTypeListsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentTypeListsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterComponentTypeLists(s)
	}
}

func (s *ComponentTypeListsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitComponentTypeLists(s)
	}
}

func (p *ASNParser) ComponentTypeLists() (localctx IComponentTypeListsContext) {
	localctx = NewComponentTypeListsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ASNParserRULE_componentTypeLists)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(437)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserCOMPONENTS_LITERAL, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(417)
			p.RootComponentTypeList()
		}
		p.SetState(427)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserCOMMA {
			{
				p.SetState(418)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(419)
				p.ExtensionAndException()
			}
			{
				p.SetState(420)
				p.ExtensionAdditions()
			}
			p.SetState(425)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ASNParserR_BRACE, ASNParserCOMMA:
				{
					p.SetState(421)
					p.OptionalExtensionMarker()
				}

			case ASNParserEXTENSTIONENDMARKER:
				{
					p.SetState(422)
					p.Match(ASNParserEXTENSTIONENDMARKER)
				}
				{
					p.SetState(423)
					p.Match(ASNParserCOMMA)
				}
				{
					p.SetState(424)
					p.RootComponentTypeList()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}

	case ASNParserELLIPSIS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(429)
			p.ExtensionAndException()
		}
		{
			p.SetState(430)
			p.ExtensionAdditions()
		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASNParserR_BRACE, ASNParserCOMMA:
			{
				p.SetState(431)
				p.OptionalExtensionMarker()
			}

		case ASNParserEXTENSTIONENDMARKER:
			{
				p.SetState(432)
				p.Match(ASNParserEXTENSTIONENDMARKER)
			}
			{
				p.SetState(433)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(434)
				p.RootComponentTypeList()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRootComponentTypeListContext is an interface to support dynamic dispatch.
type IRootComponentTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootComponentTypeListContext differentiates from other interfaces.
	IsRootComponentTypeListContext()
}

type RootComponentTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootComponentTypeListContext() *RootComponentTypeListContext {
	var p = new(RootComponentTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_rootComponentTypeList
	return p
}

func (*RootComponentTypeListContext) IsRootComponentTypeListContext() {}

func NewRootComponentTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootComponentTypeListContext {
	var p = new(RootComponentTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_rootComponentTypeList

	return p
}

func (s *RootComponentTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *RootComponentTypeListContext) ComponentTypeList() IComponentTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeListContext)
}

func (s *RootComponentTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootComponentTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootComponentTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterRootComponentTypeList(s)
	}
}

func (s *RootComponentTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitRootComponentTypeList(s)
	}
}

func (p *ASNParser) RootComponentTypeList() (localctx IRootComponentTypeListContext) {
	localctx = NewRootComponentTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ASNParserRULE_rootComponentTypeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(439)
		p.ComponentTypeList()
	}

	return localctx
}

// IComponentTypeListContext is an interface to support dynamic dispatch.
type IComponentTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentTypeListContext differentiates from other interfaces.
	IsComponentTypeListContext()
}

type ComponentTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentTypeListContext() *ComponentTypeListContext {
	var p = new(ComponentTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_componentTypeList
	return p
}

func (*ComponentTypeListContext) IsComponentTypeListContext() {}

func NewComponentTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentTypeListContext {
	var p = new(ComponentTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_componentTypeList

	return p
}

func (s *ComponentTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentTypeListContext) AllComponentType() []IComponentTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComponentTypeContext)(nil)).Elem())
	var tst = make([]IComponentTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComponentTypeContext)
		}
	}

	return tst
}

func (s *ComponentTypeListContext) ComponentType(i int) IComponentTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeContext)
}

func (s *ComponentTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ComponentTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ComponentTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterComponentTypeList(s)
	}
}

func (s *ComponentTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitComponentTypeList(s)
	}
}

func (p *ASNParser) ComponentTypeList() (localctx IComponentTypeListContext) {
	localctx = NewComponentTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ASNParserRULE_componentTypeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(441)
		p.ComponentType()
	}

	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(442)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(443)
				p.ComponentType()
			}

		}
		p.SetState(448)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())
	}

	return localctx
}

// IComponentTypeContext is an interface to support dynamic dispatch.
type IComponentTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentTypeContext differentiates from other interfaces.
	IsComponentTypeContext()
}

type ComponentTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentTypeContext() *ComponentTypeContext {
	var p = new(ComponentTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_componentType
	return p
}

func (*ComponentTypeContext) IsComponentTypeContext() {}

func NewComponentTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentTypeContext {
	var p = new(ComponentTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_componentType

	return p
}

func (s *ComponentTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentTypeContext) NamedType() INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *ComponentTypeContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOPTIONAL_LITERAL, 0)
}

func (s *ComponentTypeContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFAULT_LITERAL, 0)
}

func (s *ComponentTypeContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ComponentTypeContext) COMPONENTS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserCOMPONENTS_LITERAL, 0)
}

func (s *ComponentTypeContext) OF_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOF_LITERAL, 0)
}

func (s *ComponentTypeContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ComponentTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterComponentType(s)
	}
}

func (s *ComponentTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitComponentType(s)
	}
}

func (p *ASNParser) ComponentType() (localctx IComponentTypeContext) {
	localctx = NewComponentTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ASNParserRULE_componentType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(458)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(449)
			p.NamedType()
		}
		p.SetState(453)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASNParserOPTIONAL_LITERAL:
			{
				p.SetState(450)
				p.Match(ASNParserOPTIONAL_LITERAL)
			}

		case ASNParserDEFAULT_LITERAL:
			{
				p.SetState(451)
				p.Match(ASNParserDEFAULT_LITERAL)
			}
			{
				p.SetState(452)
				p.Value()
			}

		case ASNParserR_BRACE, ASNParserCOMMA, ASNParserDOUBLE_R_BRACKET, ASNParserEXTENSTIONENDMARKER:

		default:
		}

	case ASNParserCOMPONENTS_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(455)
			p.Match(ASNParserCOMPONENTS_LITERAL)
		}
		{
			p.SetState(456)
			p.Match(ASNParserOF_LITERAL)
		}
		{
			p.SetState(457)
			p.AsnType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtensionAdditionsContext is an interface to support dynamic dispatch.
type IExtensionAdditionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionsContext differentiates from other interfaces.
	IsExtensionAdditionsContext()
}

type ExtensionAdditionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionsContext() *ExtensionAdditionsContext {
	var p = new(ExtensionAdditionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAdditions
	return p
}

func (*ExtensionAdditionsContext) IsExtensionAdditionsContext() {}

func NewExtensionAdditionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionsContext {
	var p = new(ExtensionAdditionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAdditions

	return p
}

func (s *ExtensionAdditionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, 0)
}

func (s *ExtensionAdditionsContext) ExtensionAdditionList() IExtensionAdditionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionListContext)
}

func (s *ExtensionAdditionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAdditions(s)
	}
}

func (s *ExtensionAdditionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAdditions(s)
	}
}

func (p *ASNParser) ExtensionAdditions() (localctx IExtensionAdditionsContext) {
	localctx = NewExtensionAdditionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ASNParserRULE_extensionAdditions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(462)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(460)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(461)
			p.ExtensionAdditionList()
		}

	}

	return localctx
}

// IExtensionAdditionListContext is an interface to support dynamic dispatch.
type IExtensionAdditionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionListContext differentiates from other interfaces.
	IsExtensionAdditionListContext()
}

type ExtensionAdditionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionListContext() *ExtensionAdditionListContext {
	var p = new(ExtensionAdditionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAdditionList
	return p
}

func (*ExtensionAdditionListContext) IsExtensionAdditionListContext() {}

func NewExtensionAdditionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionListContext {
	var p = new(ExtensionAdditionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAdditionList

	return p
}

func (s *ExtensionAdditionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionListContext) AllExtensionAddition() []IExtensionAdditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExtensionAdditionContext)(nil)).Elem())
	var tst = make([]IExtensionAdditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExtensionAdditionContext)
		}
	}

	return tst
}

func (s *ExtensionAdditionListContext) ExtensionAddition(i int) IExtensionAdditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionContext)
}

func (s *ExtensionAdditionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ExtensionAdditionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ExtensionAdditionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAdditionList(s)
	}
}

func (s *ExtensionAdditionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAdditionList(s)
	}
}

func (p *ASNParser) ExtensionAdditionList() (localctx IExtensionAdditionListContext) {
	localctx = NewExtensionAdditionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ASNParserRULE_extensionAdditionList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(464)
		p.ExtensionAddition()
	}

	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(465)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(466)
				p.ExtensionAddition()
			}

		}
		p.SetState(471)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext())
	}

	return localctx
}

// IExtensionAdditionContext is an interface to support dynamic dispatch.
type IExtensionAdditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionContext differentiates from other interfaces.
	IsExtensionAdditionContext()
}

type ExtensionAdditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionContext() *ExtensionAdditionContext {
	var p = new(ExtensionAdditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAddition
	return p
}

func (*ExtensionAdditionContext) IsExtensionAdditionContext() {}

func NewExtensionAdditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionContext {
	var p = new(ExtensionAdditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAddition

	return p
}

func (s *ExtensionAdditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionContext) ComponentType() IComponentTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeContext)
}

func (s *ExtensionAdditionContext) ExtensionAdditionGroup() IExtensionAdditionGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionGroupContext)
}

func (s *ExtensionAdditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAddition(s)
	}
}

func (s *ExtensionAdditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAddition(s)
	}
}

func (p *ASNParser) ExtensionAddition() (localctx IExtensionAdditionContext) {
	localctx = NewExtensionAdditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ASNParserRULE_extensionAddition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(474)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserCOMPONENTS_LITERAL, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(472)
			p.ComponentType()
		}

	case ASNParserDOUBLE_L_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(473)
			p.ExtensionAdditionGroup()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtensionAdditionGroupContext is an interface to support dynamic dispatch.
type IExtensionAdditionGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionGroupContext differentiates from other interfaces.
	IsExtensionAdditionGroupContext()
}

type ExtensionAdditionGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionGroupContext() *ExtensionAdditionGroupContext {
	var p = new(ExtensionAdditionGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAdditionGroup
	return p
}

func (*ExtensionAdditionGroupContext) IsExtensionAdditionGroupContext() {}

func NewExtensionAdditionGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionGroupContext {
	var p = new(ExtensionAdditionGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAdditionGroup

	return p
}

func (s *ExtensionAdditionGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionGroupContext) DOUBLE_L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASNParserDOUBLE_L_BRACKET, 0)
}

func (s *ExtensionAdditionGroupContext) VersionNumber() IVersionNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVersionNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVersionNumberContext)
}

func (s *ExtensionAdditionGroupContext) ComponentTypeList() IComponentTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeListContext)
}

func (s *ExtensionAdditionGroupContext) DOUBLE_R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASNParserDOUBLE_R_BRACKET, 0)
}

func (s *ExtensionAdditionGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAdditionGroup(s)
	}
}

func (s *ExtensionAdditionGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAdditionGroup(s)
	}
}

func (p *ASNParser) ExtensionAdditionGroup() (localctx IExtensionAdditionGroupContext) {
	localctx = NewExtensionAdditionGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ASNParserRULE_extensionAdditionGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(476)
		p.Match(ASNParserDOUBLE_L_BRACKET)
	}
	{
		p.SetState(477)
		p.VersionNumber()
	}
	{
		p.SetState(478)
		p.ComponentTypeList()
	}
	{
		p.SetState(479)
		p.Match(ASNParserDOUBLE_R_BRACKET)
	}

	return localctx
}

// IVersionNumberContext is an interface to support dynamic dispatch.
type IVersionNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVersionNumberContext differentiates from other interfaces.
	IsVersionNumberContext()
}

type VersionNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionNumberContext() *VersionNumberContext {
	var p = new(VersionNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_versionNumber
	return p
}

func (*VersionNumberContext) IsVersionNumberContext() {}

func NewVersionNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionNumberContext {
	var p = new(VersionNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_versionNumber

	return p
}

func (s *VersionNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionNumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(ASNParserNUMBER, 0)
}

func (s *VersionNumberContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASNParserCOLON, 0)
}

func (s *VersionNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterVersionNumber(s)
	}
}

func (s *VersionNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitVersionNumber(s)
	}
}

func (p *ASNParser) VersionNumber() (localctx IVersionNumberContext) {
	localctx = NewVersionNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ASNParserRULE_versionNumber)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserNUMBER {
		{
			p.SetState(481)
			p.Match(ASNParserNUMBER)
		}
		{
			p.SetState(482)
			p.Match(ASNParserCOLON)
		}

	}

	return localctx
}

// ISequenceOfTypeContext is an interface to support dynamic dispatch.
type ISequenceOfTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequenceOfTypeContext differentiates from other interfaces.
	IsSequenceOfTypeContext()
}

type SequenceOfTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceOfTypeContext() *SequenceOfTypeContext {
	var p = new(SequenceOfTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_sequenceOfType
	return p
}

func (*SequenceOfTypeContext) IsSequenceOfTypeContext() {}

func NewSequenceOfTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceOfTypeContext {
	var p = new(SequenceOfTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_sequenceOfType

	return p
}

func (s *SequenceOfTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceOfTypeContext) SEQUENCE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSEQUENCE_LITERAL, 0)
}

func (s *SequenceOfTypeContext) OF_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOF_LITERAL, 0)
}

func (s *SequenceOfTypeContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *SequenceOfTypeContext) NamedType() INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *SequenceOfTypeContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserL_PARAN, 0)
}

func (s *SequenceOfTypeContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserR_PARAN, 0)
}

func (s *SequenceOfTypeContext) Constraint() IConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *SequenceOfTypeContext) SizeConstraint() ISizeConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISizeConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISizeConstraintContext)
}

func (s *SequenceOfTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceOfTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceOfTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSequenceOfType(s)
	}
}

func (s *SequenceOfTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSequenceOfType(s)
	}
}

func (p *ASNParser) SequenceOfType() (localctx ISequenceOfTypeContext) {
	localctx = NewSequenceOfTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ASNParserRULE_sequenceOfType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Match(ASNParserSEQUENCE_LITERAL)
	}
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserL_PARAN {
		{
			p.SetState(486)
			p.Match(ASNParserL_PARAN)
		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASNParserL_PARAN:
			{
				p.SetState(487)
				p.Constraint()
			}

		case ASNParserSIZE_LITERAL:
			{
				p.SetState(488)
				p.SizeConstraint()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(491)
			p.Match(ASNParserR_PARAN)
		}

	}
	{
		p.SetState(495)
		p.Match(ASNParserOF_LITERAL)
	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(496)
			p.AsnType()
		}

	case 2:
		{
			p.SetState(497)
			p.NamedType()
		}

	}

	return localctx
}

// ISizeConstraintContext is an interface to support dynamic dispatch.
type ISizeConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSizeConstraintContext differentiates from other interfaces.
	IsSizeConstraintContext()
}

type SizeConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySizeConstraintContext() *SizeConstraintContext {
	var p = new(SizeConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_sizeConstraint
	return p
}

func (*SizeConstraintContext) IsSizeConstraintContext() {}

func NewSizeConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SizeConstraintContext {
	var p = new(SizeConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_sizeConstraint

	return p
}

func (s *SizeConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *SizeConstraintContext) SIZE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSIZE_LITERAL, 0)
}

func (s *SizeConstraintContext) Constraint() IConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *SizeConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SizeConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SizeConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSizeConstraint(s)
	}
}

func (s *SizeConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSizeConstraint(s)
	}
}

func (p *ASNParser) SizeConstraint() (localctx ISizeConstraintContext) {
	localctx = NewSizeConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ASNParserRULE_sizeConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(500)
		p.Match(ASNParserSIZE_LITERAL)
	}
	{
		p.SetState(501)
		p.Constraint()
	}

	return localctx
}

// IParameterizedAssignmentContext is an interface to support dynamic dispatch.
type IParameterizedAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterizedAssignmentContext differentiates from other interfaces.
	IsParameterizedAssignmentContext()
}

type ParameterizedAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterizedAssignmentContext() *ParameterizedAssignmentContext {
	var p = new(ParameterizedAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_parameterizedAssignment
	return p
}

func (*ParameterizedAssignmentContext) IsParameterizedAssignmentContext() {}

func NewParameterizedAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterizedAssignmentContext {
	var p = new(ParameterizedAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_parameterizedAssignment

	return p
}

func (s *ParameterizedAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterizedAssignmentContext) ParameterList() IParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ParameterizedAssignmentContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASNParserASSIGN_OP, 0)
}

func (s *ParameterizedAssignmentContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ParameterizedAssignmentContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ParameterizedAssignmentContext) ValueSet() IValueSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetContext)
}

func (s *ParameterizedAssignmentContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ParameterizedAssignmentContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *ParameterizedAssignmentContext) ObjectClass() IObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassContext)
}

func (s *ParameterizedAssignmentContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *ParameterizedAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterizedAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterizedAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterParameterizedAssignment(s)
	}
}

func (s *ParameterizedAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitParameterizedAssignment(s)
	}
}

func (p *ASNParser) ParameterizedAssignment() (localctx IParameterizedAssignmentContext) {
	localctx = NewParameterizedAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ASNParserRULE_parameterizedAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(517)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserL_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(503)
			p.ParameterList()
		}

		{
			p.SetState(504)
			p.Match(ASNParserASSIGN_OP)
		}
		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(505)
				p.AsnType()
			}

		case 2:
			{
				p.SetState(506)
				p.Value()
			}

		case 3:
			{
				p.SetState(507)
				p.ValueSet()
			}

		}

	case ASNParserTYPE_IDENTIFIER_LITERAL, ASNParserABSTRACT_SYNTAX_LITERAL, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(510)
			p.DefinedObjectClass()
		}
		{
			p.SetState(511)
			p.Match(ASNParserASSIGN_OP)
		}
		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(512)
				p.Object()
			}

		case 2:
			{
				p.SetState(513)
				p.ObjectClass()
			}

		case 3:
			{
				p.SetState(514)
				p.ObjectSet()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_parameterList
	return p
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ParameterListContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *ParameterListContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *ParameterListContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (p *ASNParser) ParameterList() (localctx IParameterListContext) {
	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ASNParserRULE_parameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(519)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(520)
		p.Parameter()
	}
	p.SetState(525)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserCOMMA {
		{
			p.SetState(521)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(522)
			p.Parameter()
		}

		p.SetState(527)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(528)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *ParameterContext) ParamGovernor() IParamGovernorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamGovernorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamGovernorContext)
}

func (s *ParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASNParserCOLON, 0)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (p *ASNParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ASNParserRULE_parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(533)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(530)
			p.ParamGovernor()
		}
		{
			p.SetState(531)
			p.Match(ASNParserCOLON)
		}

	}
	{
		p.SetState(535)
		p.Match(ASNParserIDENTIFIER)
	}

	return localctx
}

// IParamGovernorContext is an interface to support dynamic dispatch.
type IParamGovernorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamGovernorContext differentiates from other interfaces.
	IsParamGovernorContext()
}

type ParamGovernorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamGovernorContext() *ParamGovernorContext {
	var p = new(ParamGovernorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_paramGovernor
	return p
}

func (*ParamGovernorContext) IsParamGovernorContext() {}

func NewParamGovernorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamGovernorContext {
	var p = new(ParamGovernorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_paramGovernor

	return p
}

func (s *ParamGovernorContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamGovernorContext) Governor() IGovernorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGovernorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGovernorContext)
}

func (s *ParamGovernorContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *ParamGovernorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamGovernorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamGovernorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterParamGovernor(s)
	}
}

func (s *ParamGovernorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitParamGovernor(s)
	}
}

func (p *ASNParser) ParamGovernor() (localctx IParamGovernorContext) {
	localctx = NewParamGovernorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ASNParserRULE_paramGovernor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(537)
			p.Governor()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(538)
			p.Match(ASNParserIDENTIFIER)
		}

	}

	return localctx
}

// IGovernorContext is an interface to support dynamic dispatch.
type IGovernorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGovernorContext differentiates from other interfaces.
	IsGovernorContext()
}

type GovernorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGovernorContext() *GovernorContext {
	var p = new(GovernorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_governor
	return p
}

func (*GovernorContext) IsGovernorContext() {}

func NewGovernorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GovernorContext {
	var p = new(GovernorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_governor

	return p
}

func (s *GovernorContext) GetParser() antlr.Parser { return s.parser }

func (s *GovernorContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *GovernorContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *GovernorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GovernorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GovernorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterGovernor(s)
	}
}

func (s *GovernorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitGovernor(s)
	}
}

func (p *ASNParser) Governor() (localctx IGovernorContext) {
	localctx = NewGovernorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ASNParserRULE_governor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(543)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(541)
			p.AsnType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(542)
			p.DefinedObjectClass()
		}

	}

	return localctx
}

// IObjectClassAssignmentContext is an interface to support dynamic dispatch.
type IObjectClassAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectClassAssignmentContext differentiates from other interfaces.
	IsObjectClassAssignmentContext()
}

type ObjectClassAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectClassAssignmentContext() *ObjectClassAssignmentContext {
	var p = new(ObjectClassAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectClassAssignment
	return p
}

func (*ObjectClassAssignmentContext) IsObjectClassAssignmentContext() {}

func NewObjectClassAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectClassAssignmentContext {
	var p = new(ObjectClassAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectClassAssignment

	return p
}

func (s *ObjectClassAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectClassAssignmentContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASNParserASSIGN_OP, 0)
}

func (s *ObjectClassAssignmentContext) ObjectClass() IObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassContext)
}

func (s *ObjectClassAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectClassAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectClassAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectClassAssignment(s)
	}
}

func (s *ObjectClassAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectClassAssignment(s)
	}
}

func (p *ASNParser) ObjectClassAssignment() (localctx IObjectClassAssignmentContext) {
	localctx = NewObjectClassAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ASNParserRULE_objectClassAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(545)
		p.Match(ASNParserASSIGN_OP)
	}
	{
		p.SetState(546)
		p.ObjectClass()
	}

	return localctx
}

// IObjectClassContext is an interface to support dynamic dispatch.
type IObjectClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectClassContext differentiates from other interfaces.
	IsObjectClassContext()
}

type ObjectClassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectClassContext() *ObjectClassContext {
	var p = new(ObjectClassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectClass
	return p
}

func (*ObjectClassContext) IsObjectClassContext() {}

func NewObjectClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectClassContext {
	var p = new(ObjectClassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectClass

	return p
}

func (s *ObjectClassContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectClassContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ObjectClassContext) ObjectClassDefn() IObjectClassDefnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassDefnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassDefnContext)
}

func (s *ObjectClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectClassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectClass(s)
	}
}

func (s *ObjectClassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectClass(s)
	}
}

func (p *ASNParser) ObjectClass() (localctx IObjectClassContext) {
	localctx = NewObjectClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ASNParserRULE_objectClass)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(550)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserTYPE_IDENTIFIER_LITERAL, ASNParserABSTRACT_SYNTAX_LITERAL, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(548)
			p.DefinedObjectClass()
		}

	case ASNParserCLASS_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(549)
			p.ObjectClassDefn()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDefinedObjectClassContext is an interface to support dynamic dispatch.
type IDefinedObjectClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinedObjectClassContext differentiates from other interfaces.
	IsDefinedObjectClassContext()
}

type DefinedObjectClassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinedObjectClassContext() *DefinedObjectClassContext {
	var p = new(DefinedObjectClassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_definedObjectClass
	return p
}

func (*DefinedObjectClassContext) IsDefinedObjectClassContext() {}

func NewDefinedObjectClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinedObjectClassContext {
	var p = new(DefinedObjectClassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_definedObjectClass

	return p
}

func (s *DefinedObjectClassContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinedObjectClassContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *DefinedObjectClassContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *DefinedObjectClassContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *DefinedObjectClassContext) TYPE_IDENTIFIER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserTYPE_IDENTIFIER_LITERAL, 0)
}

func (s *DefinedObjectClassContext) ABSTRACT_SYNTAX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserABSTRACT_SYNTAX_LITERAL, 0)
}

func (s *DefinedObjectClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinedObjectClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinedObjectClassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterDefinedObjectClass(s)
	}
}

func (s *DefinedObjectClassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitDefinedObjectClass(s)
	}
}

func (p *ASNParser) DefinedObjectClass() (localctx IDefinedObjectClassContext) {
	localctx = NewDefinedObjectClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ASNParserRULE_definedObjectClass)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(559)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(554)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(552)
				p.Match(ASNParserIDENTIFIER)
			}
			{
				p.SetState(553)
				p.Match(ASNParserDOT)
			}

		}
		{
			p.SetState(556)
			p.Match(ASNParserIDENTIFIER)
		}

	case ASNParserTYPE_IDENTIFIER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(557)
			p.Match(ASNParserTYPE_IDENTIFIER_LITERAL)
		}

	case ASNParserABSTRACT_SYNTAX_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(558)
			p.Match(ASNParserABSTRACT_SYNTAX_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUsefulObjectClassReferenceContext is an interface to support dynamic dispatch.
type IUsefulObjectClassReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUsefulObjectClassReferenceContext differentiates from other interfaces.
	IsUsefulObjectClassReferenceContext()
}

type UsefulObjectClassReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsefulObjectClassReferenceContext() *UsefulObjectClassReferenceContext {
	var p = new(UsefulObjectClassReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_usefulObjectClassReference
	return p
}

func (*UsefulObjectClassReferenceContext) IsUsefulObjectClassReferenceContext() {}

func NewUsefulObjectClassReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsefulObjectClassReferenceContext {
	var p = new(UsefulObjectClassReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_usefulObjectClassReference

	return p
}

func (s *UsefulObjectClassReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *UsefulObjectClassReferenceContext) TYPE_IDENTIFIER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserTYPE_IDENTIFIER_LITERAL, 0)
}

func (s *UsefulObjectClassReferenceContext) ABSTRACT_SYNTAX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserABSTRACT_SYNTAX_LITERAL, 0)
}

func (s *UsefulObjectClassReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsefulObjectClassReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsefulObjectClassReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterUsefulObjectClassReference(s)
	}
}

func (s *UsefulObjectClassReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitUsefulObjectClassReference(s)
	}
}

func (p *ASNParser) UsefulObjectClassReference() (localctx IUsefulObjectClassReferenceContext) {
	localctx = NewUsefulObjectClassReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ASNParserRULE_usefulObjectClassReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(561)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASNParserTYPE_IDENTIFIER_LITERAL || _la == ASNParserABSTRACT_SYNTAX_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExternalObjectClassReferenceContext is an interface to support dynamic dispatch.
type IExternalObjectClassReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternalObjectClassReferenceContext differentiates from other interfaces.
	IsExternalObjectClassReferenceContext()
}

type ExternalObjectClassReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalObjectClassReferenceContext() *ExternalObjectClassReferenceContext {
	var p = new(ExternalObjectClassReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_externalObjectClassReference
	return p
}

func (*ExternalObjectClassReferenceContext) IsExternalObjectClassReferenceContext() {}

func NewExternalObjectClassReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalObjectClassReferenceContext {
	var p = new(ExternalObjectClassReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_externalObjectClassReference

	return p
}

func (s *ExternalObjectClassReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalObjectClassReferenceContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *ExternalObjectClassReferenceContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *ExternalObjectClassReferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *ExternalObjectClassReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalObjectClassReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalObjectClassReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExternalObjectClassReference(s)
	}
}

func (s *ExternalObjectClassReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExternalObjectClassReference(s)
	}
}

func (p *ASNParser) ExternalObjectClassReference() (localctx IExternalObjectClassReferenceContext) {
	localctx = NewExternalObjectClassReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ASNParserRULE_externalObjectClassReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(563)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(564)
		p.Match(ASNParserDOT)
	}
	{
		p.SetState(565)
		p.Match(ASNParserIDENTIFIER)
	}

	return localctx
}

// IObjectClassDefnContext is an interface to support dynamic dispatch.
type IObjectClassDefnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectClassDefnContext differentiates from other interfaces.
	IsObjectClassDefnContext()
}

type ObjectClassDefnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectClassDefnContext() *ObjectClassDefnContext {
	var p = new(ObjectClassDefnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectClassDefn
	return p
}

func (*ObjectClassDefnContext) IsObjectClassDefnContext() {}

func NewObjectClassDefnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectClassDefnContext {
	var p = new(ObjectClassDefnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectClassDefn

	return p
}

func (s *ObjectClassDefnContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectClassDefnContext) CLASS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserCLASS_LITERAL, 0)
}

func (s *ObjectClassDefnContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ObjectClassDefnContext) AllFieldSpec() []IFieldSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldSpecContext)(nil)).Elem())
	var tst = make([]IFieldSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldSpecContext)
		}
	}

	return tst
}

func (s *ObjectClassDefnContext) FieldSpec(i int) IFieldSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldSpecContext)
}

func (s *ObjectClassDefnContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ObjectClassDefnContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ObjectClassDefnContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ObjectClassDefnContext) WithSyntaxSpec() IWithSyntaxSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithSyntaxSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithSyntaxSpecContext)
}

func (s *ObjectClassDefnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectClassDefnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectClassDefnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectClassDefn(s)
	}
}

func (s *ObjectClassDefnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectClassDefn(s)
	}
}

func (p *ASNParser) ObjectClassDefn() (localctx IObjectClassDefnContext) {
	localctx = NewObjectClassDefnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ASNParserRULE_objectClassDefn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(567)
		p.Match(ASNParserCLASS_LITERAL)
	}
	{
		p.SetState(568)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(569)
		p.FieldSpec()
	}
	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserCOMMA {
		{
			p.SetState(570)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(571)
			p.FieldSpec()
		}

		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(577)
		p.Match(ASNParserR_BRACE)
	}
	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserWITH_LITERAL {
		{
			p.SetState(578)
			p.WithSyntaxSpec()
		}

	}

	return localctx
}

// IWithSyntaxSpecContext is an interface to support dynamic dispatch.
type IWithSyntaxSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithSyntaxSpecContext differentiates from other interfaces.
	IsWithSyntaxSpecContext()
}

type WithSyntaxSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithSyntaxSpecContext() *WithSyntaxSpecContext {
	var p = new(WithSyntaxSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_withSyntaxSpec
	return p
}

func (*WithSyntaxSpecContext) IsWithSyntaxSpecContext() {}

func NewWithSyntaxSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithSyntaxSpecContext {
	var p = new(WithSyntaxSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_withSyntaxSpec

	return p
}

func (s *WithSyntaxSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WithSyntaxSpecContext) WITH_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserWITH_LITERAL, 0)
}

func (s *WithSyntaxSpecContext) SYNTAX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSYNTAX_LITERAL, 0)
}

func (s *WithSyntaxSpecContext) SyntaxList() ISyntaxListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISyntaxListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISyntaxListContext)
}

func (s *WithSyntaxSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithSyntaxSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithSyntaxSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterWithSyntaxSpec(s)
	}
}

func (s *WithSyntaxSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitWithSyntaxSpec(s)
	}
}

func (p *ASNParser) WithSyntaxSpec() (localctx IWithSyntaxSpecContext) {
	localctx = NewWithSyntaxSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ASNParserRULE_withSyntaxSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(581)
		p.Match(ASNParserWITH_LITERAL)
	}
	{
		p.SetState(582)
		p.Match(ASNParserSYNTAX_LITERAL)
	}
	{
		p.SetState(583)
		p.SyntaxList()
	}

	return localctx
}

// ISyntaxListContext is an interface to support dynamic dispatch.
type ISyntaxListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSyntaxListContext differentiates from other interfaces.
	IsSyntaxListContext()
}

type SyntaxListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxListContext() *SyntaxListContext {
	var p = new(SyntaxListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_syntaxList
	return p
}

func (*SyntaxListContext) IsSyntaxListContext() {}

func NewSyntaxListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxListContext {
	var p = new(SyntaxListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_syntaxList

	return p
}

func (s *SyntaxListContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxListContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *SyntaxListContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *SyntaxListContext) AllTokenOrGroupSpec() []ITokenOrGroupSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITokenOrGroupSpecContext)(nil)).Elem())
	var tst = make([]ITokenOrGroupSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITokenOrGroupSpecContext)
		}
	}

	return tst
}

func (s *SyntaxListContext) TokenOrGroupSpec(i int) ITokenOrGroupSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokenOrGroupSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITokenOrGroupSpecContext)
}

func (s *SyntaxListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSyntaxList(s)
	}
}

func (s *SyntaxListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSyntaxList(s)
	}
}

func (p *ASNParser) SyntaxList() (localctx ISyntaxListContext) {
	localctx = NewSyntaxListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ASNParserRULE_syntaxList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(585)
		p.Match(ASNParserL_BRACE)
	}
	p.SetState(587)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ASNParserAMPERSAND || _la == ASNParserCOMMA || _la == ASNParserL_BRACKET || _la == ASNParserIDENTIFIER {
		{
			p.SetState(586)
			p.TokenOrGroupSpec()
		}

		p.SetState(589)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(591)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// ITokenOrGroupSpecContext is an interface to support dynamic dispatch.
type ITokenOrGroupSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTokenOrGroupSpecContext differentiates from other interfaces.
	IsTokenOrGroupSpecContext()
}

type TokenOrGroupSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTokenOrGroupSpecContext() *TokenOrGroupSpecContext {
	var p = new(TokenOrGroupSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_tokenOrGroupSpec
	return p
}

func (*TokenOrGroupSpecContext) IsTokenOrGroupSpecContext() {}

func NewTokenOrGroupSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TokenOrGroupSpecContext {
	var p = new(TokenOrGroupSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_tokenOrGroupSpec

	return p
}

func (s *TokenOrGroupSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TokenOrGroupSpecContext) RequiredToken() IRequiredTokenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRequiredTokenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRequiredTokenContext)
}

func (s *TokenOrGroupSpecContext) OptionalGroup() IOptionalGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalGroupContext)
}

func (s *TokenOrGroupSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TokenOrGroupSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TokenOrGroupSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterTokenOrGroupSpec(s)
	}
}

func (s *TokenOrGroupSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitTokenOrGroupSpec(s)
	}
}

func (p *ASNParser) TokenOrGroupSpec() (localctx ITokenOrGroupSpecContext) {
	localctx = NewTokenOrGroupSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ASNParserRULE_tokenOrGroupSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(595)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserAMPERSAND, ASNParserCOMMA, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(593)
			p.RequiredToken()
		}

	case ASNParserL_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(594)
			p.OptionalGroup()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOptionalGroupContext is an interface to support dynamic dispatch.
type IOptionalGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalGroupContext differentiates from other interfaces.
	IsOptionalGroupContext()
}

type OptionalGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalGroupContext() *OptionalGroupContext {
	var p = new(OptionalGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_optionalGroup
	return p
}

func (*OptionalGroupContext) IsOptionalGroupContext() {}

func NewOptionalGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalGroupContext {
	var p = new(OptionalGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_optionalGroup

	return p
}

func (s *OptionalGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalGroupContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACKET, 0)
}

func (s *OptionalGroupContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACKET, 0)
}

func (s *OptionalGroupContext) AllTokenOrGroupSpec() []ITokenOrGroupSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITokenOrGroupSpecContext)(nil)).Elem())
	var tst = make([]ITokenOrGroupSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITokenOrGroupSpecContext)
		}
	}

	return tst
}

func (s *OptionalGroupContext) TokenOrGroupSpec(i int) ITokenOrGroupSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokenOrGroupSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITokenOrGroupSpecContext)
}

func (s *OptionalGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterOptionalGroup(s)
	}
}

func (s *OptionalGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitOptionalGroup(s)
	}
}

func (p *ASNParser) OptionalGroup() (localctx IOptionalGroupContext) {
	localctx = NewOptionalGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ASNParserRULE_optionalGroup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(597)
		p.Match(ASNParserL_BRACKET)
	}
	p.SetState(599)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ASNParserAMPERSAND || _la == ASNParserCOMMA || _la == ASNParserL_BRACKET || _la == ASNParserIDENTIFIER {
		{
			p.SetState(598)
			p.TokenOrGroupSpec()
		}

		p.SetState(601)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(603)
		p.Match(ASNParserR_BRACKET)
	}

	return localctx
}

// IRequiredTokenContext is an interface to support dynamic dispatch.
type IRequiredTokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRequiredTokenContext differentiates from other interfaces.
	IsRequiredTokenContext()
}

type RequiredTokenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequiredTokenContext() *RequiredTokenContext {
	var p = new(RequiredTokenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_requiredToken
	return p
}

func (*RequiredTokenContext) IsRequiredTokenContext() {}

func NewRequiredTokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequiredTokenContext {
	var p = new(RequiredTokenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_requiredToken

	return p
}

func (s *RequiredTokenContext) GetParser() antlr.Parser { return s.parser }

func (s *RequiredTokenContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *RequiredTokenContext) PrimitiveFieldName() IPrimitiveFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveFieldNameContext)
}

func (s *RequiredTokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequiredTokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequiredTokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterRequiredToken(s)
	}
}

func (s *RequiredTokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitRequiredToken(s)
	}
}

func (p *ASNParser) RequiredToken() (localctx IRequiredTokenContext) {
	localctx = NewRequiredTokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ASNParserRULE_requiredToken)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(607)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserCOMMA, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(605)
			p.Literal()
		}

	case ASNParserAMPERSAND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(606)
			p.PrimitiveFieldName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *LiteralContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *ASNParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ASNParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(609)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASNParserCOMMA || _la == ASNParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrimitiveFieldNameContext is an interface to support dynamic dispatch.
type IPrimitiveFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveFieldNameContext differentiates from other interfaces.
	IsPrimitiveFieldNameContext()
}

type PrimitiveFieldNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveFieldNameContext() *PrimitiveFieldNameContext {
	var p = new(PrimitiveFieldNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_primitiveFieldName
	return p
}

func (*PrimitiveFieldNameContext) IsPrimitiveFieldNameContext() {}

func NewPrimitiveFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveFieldNameContext {
	var p = new(PrimitiveFieldNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_primitiveFieldName

	return p
}

func (s *PrimitiveFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveFieldNameContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *PrimitiveFieldNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *PrimitiveFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveFieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterPrimitiveFieldName(s)
	}
}

func (s *PrimitiveFieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitPrimitiveFieldName(s)
	}
}

func (p *ASNParser) PrimitiveFieldName() (localctx IPrimitiveFieldNameContext) {
	localctx = NewPrimitiveFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ASNParserRULE_primitiveFieldName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(611)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(612)
		p.Match(ASNParserIDENTIFIER)
	}

	return localctx
}

// IFieldSpecContext is an interface to support dynamic dispatch.
type IFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldSpecContext differentiates from other interfaces.
	IsFieldSpecContext()
}

type FieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldSpecContext() *FieldSpecContext {
	var p = new(FieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_fieldSpec
	return p
}

func (*FieldSpecContext) IsFieldSpecContext() {}

func NewFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldSpecContext {
	var p = new(FieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_fieldSpec

	return p
}

func (s *FieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *FieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *FieldSpecContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *FieldSpecContext) FieldName() IFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FieldSpecContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *FieldSpecContext) TypeOptionalitySpec() ITypeOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeOptionalitySpecContext)
}

func (s *FieldSpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOPTIONAL_LITERAL, 0)
}

func (s *FieldSpecContext) ValueSetOptionalitySpec() IValueSetOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetOptionalitySpecContext)
}

func (s *FieldSpecContext) UNIQUE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserUNIQUE_LITERAL, 0)
}

func (s *FieldSpecContext) ValueOptionalitySpec() IValueOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueOptionalitySpecContext)
}

func (s *FieldSpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFAULT_LITERAL, 0)
}

func (s *FieldSpecContext) ValueSet() IValueSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetContext)
}

func (s *FieldSpecContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *FieldSpecContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *FieldSpecContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *FieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterFieldSpec(s)
	}
}

func (s *FieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitFieldSpec(s)
	}
}

func (p *ASNParser) FieldSpec() (localctx IFieldSpecContext) {
	localctx = NewFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ASNParserRULE_fieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(614)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(615)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.SetState(617)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
			{
				p.SetState(616)
				p.TypeOptionalitySpec()
			}

		}

	case 2:
		{
			p.SetState(619)
			p.AsnType()
		}
		p.SetState(629)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
		case 1:
			p.SetState(621)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
				{
					p.SetState(620)
					p.ValueSetOptionalitySpec()
				}

			}

		case 2:
			p.SetState(624)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASNParserUNIQUE_LITERAL {
				{
					p.SetState(623)
					p.Match(ASNParserUNIQUE_LITERAL)
				}

			}
			p.SetState(627)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
				{
					p.SetState(626)
					p.ValueOptionalitySpec()
				}

			}

		}

	case 3:
		{
			p.SetState(631)
			p.FieldName()
		}
		p.SetState(638)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASNParserOPTIONAL_LITERAL:
			{
				p.SetState(632)
				p.Match(ASNParserOPTIONAL_LITERAL)
			}

		case ASNParserDEFAULT_LITERAL:
			{
				p.SetState(633)
				p.Match(ASNParserDEFAULT_LITERAL)
			}
			p.SetState(636)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(634)
					p.ValueSet()
				}

			case 2:
				{
					p.SetState(635)
					p.Value()
				}

			}

		case ASNParserR_BRACE, ASNParserCOMMA:

		default:
		}

	case 4:
		{
			p.SetState(640)
			p.DefinedObjectClass()
		}
		p.SetState(647)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASNParserOPTIONAL_LITERAL:
			{
				p.SetState(641)
				p.Match(ASNParserOPTIONAL_LITERAL)
			}

		case ASNParserDEFAULT_LITERAL:
			{
				p.SetState(642)
				p.Match(ASNParserDEFAULT_LITERAL)
			}
			p.SetState(645)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ASNParserL_BRACE:
				{
					p.SetState(643)
					p.ObjectSet()
				}

			case ASNParserIDENTIFIER:
				{
					p.SetState(644)
					p.Object()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		case ASNParserR_BRACE, ASNParserCOMMA:

		default:
		}

	}

	return localctx
}

// ITypeFieldSpecContext is an interface to support dynamic dispatch.
type ITypeFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeFieldSpecContext differentiates from other interfaces.
	IsTypeFieldSpecContext()
}

type TypeFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeFieldSpecContext() *TypeFieldSpecContext {
	var p = new(TypeFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_typeFieldSpec
	return p
}

func (*TypeFieldSpecContext) IsTypeFieldSpecContext() {}

func NewTypeFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeFieldSpecContext {
	var p = new(TypeFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_typeFieldSpec

	return p
}

func (s *TypeFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *TypeFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *TypeFieldSpecContext) TypeOptionalitySpec() ITypeOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeOptionalitySpecContext)
}

func (s *TypeFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterTypeFieldSpec(s)
	}
}

func (s *TypeFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitTypeFieldSpec(s)
	}
}

func (p *ASNParser) TypeFieldSpec() (localctx ITypeFieldSpecContext) {
	localctx = NewTypeFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ASNParserRULE_typeFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(651)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(652)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
		{
			p.SetState(653)
			p.TypeOptionalitySpec()
		}

	}

	return localctx
}

// ITypeOptionalitySpecContext is an interface to support dynamic dispatch.
type ITypeOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeOptionalitySpecContext differentiates from other interfaces.
	IsTypeOptionalitySpecContext()
}

type TypeOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeOptionalitySpecContext() *TypeOptionalitySpecContext {
	var p = new(TypeOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_typeOptionalitySpec
	return p
}

func (*TypeOptionalitySpecContext) IsTypeOptionalitySpecContext() {}

func NewTypeOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeOptionalitySpecContext {
	var p = new(TypeOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_typeOptionalitySpec

	return p
}

func (s *TypeOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOPTIONAL_LITERAL, 0)
}

func (s *TypeOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFAULT_LITERAL, 0)
}

func (s *TypeOptionalitySpecContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *TypeOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterTypeOptionalitySpec(s)
	}
}

func (s *TypeOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitTypeOptionalitySpec(s)
	}
}

func (p *ASNParser) TypeOptionalitySpec() (localctx ITypeOptionalitySpecContext) {
	localctx = NewTypeOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ASNParserRULE_typeOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(659)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(656)
			p.Match(ASNParserOPTIONAL_LITERAL)
		}

	case ASNParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(657)
			p.Match(ASNParserDEFAULT_LITERAL)
		}
		{
			p.SetState(658)
			p.AsnType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFixedTypeValueFieldSpecContext is an interface to support dynamic dispatch.
type IFixedTypeValueFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFixedTypeValueFieldSpecContext differentiates from other interfaces.
	IsFixedTypeValueFieldSpecContext()
}

type FixedTypeValueFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixedTypeValueFieldSpecContext() *FixedTypeValueFieldSpecContext {
	var p = new(FixedTypeValueFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_fixedTypeValueFieldSpec
	return p
}

func (*FixedTypeValueFieldSpecContext) IsFixedTypeValueFieldSpecContext() {}

func NewFixedTypeValueFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FixedTypeValueFieldSpecContext {
	var p = new(FixedTypeValueFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_fixedTypeValueFieldSpec

	return p
}

func (s *FixedTypeValueFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FixedTypeValueFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *FixedTypeValueFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *FixedTypeValueFieldSpecContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *FixedTypeValueFieldSpecContext) UNIQUE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserUNIQUE_LITERAL, 0)
}

func (s *FixedTypeValueFieldSpecContext) ValueOptionalitySpec() IValueOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueOptionalitySpecContext)
}

func (s *FixedTypeValueFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixedTypeValueFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FixedTypeValueFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterFixedTypeValueFieldSpec(s)
	}
}

func (s *FixedTypeValueFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitFixedTypeValueFieldSpec(s)
	}
}

func (p *ASNParser) FixedTypeValueFieldSpec() (localctx IFixedTypeValueFieldSpecContext) {
	localctx = NewFixedTypeValueFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ASNParserRULE_fixedTypeValueFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(661)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(662)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(663)
		p.AsnType()
	}
	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserUNIQUE_LITERAL {
		{
			p.SetState(664)
			p.Match(ASNParserUNIQUE_LITERAL)
		}

	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
		{
			p.SetState(667)
			p.ValueOptionalitySpec()
		}

	}

	return localctx
}

// IValueOptionalitySpecContext is an interface to support dynamic dispatch.
type IValueOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueOptionalitySpecContext differentiates from other interfaces.
	IsValueOptionalitySpecContext()
}

type ValueOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueOptionalitySpecContext() *ValueOptionalitySpecContext {
	var p = new(ValueOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_valueOptionalitySpec
	return p
}

func (*ValueOptionalitySpecContext) IsValueOptionalitySpecContext() {}

func NewValueOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueOptionalitySpecContext {
	var p = new(ValueOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_valueOptionalitySpec

	return p
}

func (s *ValueOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOPTIONAL_LITERAL, 0)
}

func (s *ValueOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFAULT_LITERAL, 0)
}

func (s *ValueOptionalitySpecContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ValueOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterValueOptionalitySpec(s)
	}
}

func (s *ValueOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitValueOptionalitySpec(s)
	}
}

func (p *ASNParser) ValueOptionalitySpec() (localctx IValueOptionalitySpecContext) {
	localctx = NewValueOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ASNParserRULE_valueOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(673)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(670)
			p.Match(ASNParserOPTIONAL_LITERAL)
		}

	case ASNParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(671)
			p.Match(ASNParserDEFAULT_LITERAL)
		}
		{
			p.SetState(672)
			p.Value()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableTypeValueFieldSpecContext is an interface to support dynamic dispatch.
type IVariableTypeValueFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableTypeValueFieldSpecContext differentiates from other interfaces.
	IsVariableTypeValueFieldSpecContext()
}

type VariableTypeValueFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableTypeValueFieldSpecContext() *VariableTypeValueFieldSpecContext {
	var p = new(VariableTypeValueFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_variableTypeValueFieldSpec
	return p
}

func (*VariableTypeValueFieldSpecContext) IsVariableTypeValueFieldSpecContext() {}

func NewVariableTypeValueFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableTypeValueFieldSpecContext {
	var p = new(VariableTypeValueFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_variableTypeValueFieldSpec

	return p
}

func (s *VariableTypeValueFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableTypeValueFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *VariableTypeValueFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *VariableTypeValueFieldSpecContext) FieldName() IFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *VariableTypeValueFieldSpecContext) ValueOptionalitySpec() IValueOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueOptionalitySpecContext)
}

func (s *VariableTypeValueFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableTypeValueFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableTypeValueFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterVariableTypeValueFieldSpec(s)
	}
}

func (s *VariableTypeValueFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitVariableTypeValueFieldSpec(s)
	}
}

func (p *ASNParser) VariableTypeValueFieldSpec() (localctx IVariableTypeValueFieldSpecContext) {
	localctx = NewVariableTypeValueFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ASNParserRULE_variableTypeValueFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(675)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(676)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(677)
		p.FieldName()
	}
	p.SetState(679)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
		{
			p.SetState(678)
			p.ValueOptionalitySpec()
		}

	}

	return localctx
}

// IFixedTypeValueSetFieldSpecContext is an interface to support dynamic dispatch.
type IFixedTypeValueSetFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFixedTypeValueSetFieldSpecContext differentiates from other interfaces.
	IsFixedTypeValueSetFieldSpecContext()
}

type FixedTypeValueSetFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixedTypeValueSetFieldSpecContext() *FixedTypeValueSetFieldSpecContext {
	var p = new(FixedTypeValueSetFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_fixedTypeValueSetFieldSpec
	return p
}

func (*FixedTypeValueSetFieldSpecContext) IsFixedTypeValueSetFieldSpecContext() {}

func NewFixedTypeValueSetFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FixedTypeValueSetFieldSpecContext {
	var p = new(FixedTypeValueSetFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_fixedTypeValueSetFieldSpec

	return p
}

func (s *FixedTypeValueSetFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FixedTypeValueSetFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *FixedTypeValueSetFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *FixedTypeValueSetFieldSpecContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *FixedTypeValueSetFieldSpecContext) ValueSetOptionalitySpec() IValueSetOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetOptionalitySpecContext)
}

func (s *FixedTypeValueSetFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixedTypeValueSetFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FixedTypeValueSetFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterFixedTypeValueSetFieldSpec(s)
	}
}

func (s *FixedTypeValueSetFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitFixedTypeValueSetFieldSpec(s)
	}
}

func (p *ASNParser) FixedTypeValueSetFieldSpec() (localctx IFixedTypeValueSetFieldSpecContext) {
	localctx = NewFixedTypeValueSetFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ASNParserRULE_fixedTypeValueSetFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(681)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(682)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(683)
		p.AsnType()
	}
	p.SetState(685)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
		{
			p.SetState(684)
			p.ValueSetOptionalitySpec()
		}

	}

	return localctx
}

// IValueSetOptionalitySpecContext is an interface to support dynamic dispatch.
type IValueSetOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueSetOptionalitySpecContext differentiates from other interfaces.
	IsValueSetOptionalitySpecContext()
}

type ValueSetOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueSetOptionalitySpecContext() *ValueSetOptionalitySpecContext {
	var p = new(ValueSetOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_valueSetOptionalitySpec
	return p
}

func (*ValueSetOptionalitySpecContext) IsValueSetOptionalitySpecContext() {}

func NewValueSetOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueSetOptionalitySpecContext {
	var p = new(ValueSetOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_valueSetOptionalitySpec

	return p
}

func (s *ValueSetOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueSetOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOPTIONAL_LITERAL, 0)
}

func (s *ValueSetOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFAULT_LITERAL, 0)
}

func (s *ValueSetOptionalitySpecContext) ValueSet() IValueSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetContext)
}

func (s *ValueSetOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueSetOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueSetOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterValueSetOptionalitySpec(s)
	}
}

func (s *ValueSetOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitValueSetOptionalitySpec(s)
	}
}

func (p *ASNParser) ValueSetOptionalitySpec() (localctx IValueSetOptionalitySpecContext) {
	localctx = NewValueSetOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ASNParserRULE_valueSetOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(690)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(687)
			p.Match(ASNParserOPTIONAL_LITERAL)
		}

	case ASNParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(688)
			p.Match(ASNParserDEFAULT_LITERAL)
		}
		{
			p.SetState(689)
			p.ValueSet()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObjectContext is an interface to support dynamic dispatch.
type IObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectContext differentiates from other interfaces.
	IsObjectContext()
}

type ObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectContext() *ObjectContext {
	var p = new(ObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_object
	return p
}

func (*ObjectContext) IsObjectContext() {}

func NewObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectContext {
	var p = new(ObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_object

	return p
}

func (s *ObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectContext) DefinedObject() IDefinedObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectContext)
}

func (s *ObjectContext) ParameterizedObject() IParameterizedObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterizedObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterizedObjectContext)
}

func (s *ObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObject(s)
	}
}

func (s *ObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObject(s)
	}
}

func (p *ASNParser) Object() (localctx IObjectContext) {
	localctx = NewObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ASNParserRULE_object)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(694)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(692)
			p.DefinedObject()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(693)
			p.ParameterizedObject()
		}

	}

	return localctx
}

// IParameterizedObjectContext is an interface to support dynamic dispatch.
type IParameterizedObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterizedObjectContext differentiates from other interfaces.
	IsParameterizedObjectContext()
}

type ParameterizedObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterizedObjectContext() *ParameterizedObjectContext {
	var p = new(ParameterizedObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_parameterizedObject
	return p
}

func (*ParameterizedObjectContext) IsParameterizedObjectContext() {}

func NewParameterizedObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterizedObjectContext {
	var p = new(ParameterizedObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_parameterizedObject

	return p
}

func (s *ParameterizedObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterizedObjectContext) DefinedObject() IDefinedObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectContext)
}

func (s *ParameterizedObjectContext) ActualParameterList() IActualParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActualParameterListContext)
}

func (s *ParameterizedObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterizedObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterizedObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterParameterizedObject(s)
	}
}

func (s *ParameterizedObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitParameterizedObject(s)
	}
}

func (p *ASNParser) ParameterizedObject() (localctx IParameterizedObjectContext) {
	localctx = NewParameterizedObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ASNParserRULE_parameterizedObject)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(696)
		p.DefinedObject()
	}
	{
		p.SetState(697)
		p.ActualParameterList()
	}

	return localctx
}

// IDefinedObjectContext is an interface to support dynamic dispatch.
type IDefinedObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinedObjectContext differentiates from other interfaces.
	IsDefinedObjectContext()
}

type DefinedObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinedObjectContext() *DefinedObjectContext {
	var p = new(DefinedObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_definedObject
	return p
}

func (*DefinedObjectContext) IsDefinedObjectContext() {}

func NewDefinedObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinedObjectContext {
	var p = new(DefinedObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_definedObject

	return p
}

func (s *DefinedObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinedObjectContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *DefinedObjectContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *DefinedObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinedObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinedObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterDefinedObject(s)
	}
}

func (s *DefinedObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitDefinedObject(s)
	}
}

func (p *ASNParser) DefinedObject() (localctx IDefinedObjectContext) {
	localctx = NewDefinedObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ASNParserRULE_definedObject)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(699)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserDOT {
		{
			p.SetState(700)
			p.Match(ASNParserDOT)
		}

	}

	return localctx
}

// IObjectSetContext is an interface to support dynamic dispatch.
type IObjectSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetContext differentiates from other interfaces.
	IsObjectSetContext()
}

type ObjectSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetContext() *ObjectSetContext {
	var p = new(ObjectSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectSet
	return p
}

func (*ObjectSetContext) IsObjectSetContext() {}

func NewObjectSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetContext {
	var p = new(ObjectSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectSet

	return p
}

func (s *ObjectSetContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ObjectSetContext) ObjectSetSpec() IObjectSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetSpecContext)
}

func (s *ObjectSetContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ObjectSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectSet(s)
	}
}

func (s *ObjectSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectSet(s)
	}
}

func (p *ASNParser) ObjectSet() (localctx IObjectSetContext) {
	localctx = NewObjectSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ASNParserRULE_objectSet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(703)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(704)
		p.ObjectSetSpec()
	}
	{
		p.SetState(705)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IObjectSetSpecContext is an interface to support dynamic dispatch.
type IObjectSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetSpecContext differentiates from other interfaces.
	IsObjectSetSpecContext()
}

type ObjectSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetSpecContext() *ObjectSetSpecContext {
	var p = new(ObjectSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectSetSpec
	return p
}

func (*ObjectSetSpecContext) IsObjectSetSpecContext() {}

func NewObjectSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetSpecContext {
	var p = new(ObjectSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectSetSpec

	return p
}

func (s *ObjectSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetSpecContext) RootElementSetSpec() IRootElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRootElementSetSpecContext)
}

func (s *ObjectSetSpecContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ObjectSetSpecContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ObjectSetSpecContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASNParserELLIPSIS, 0)
}

func (s *ObjectSetSpecContext) AdditionalElementSetSpec() IAdditionalElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditionalElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditionalElementSetSpecContext)
}

func (s *ObjectSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectSetSpec(s)
	}
}

func (s *ObjectSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectSetSpec(s)
	}
}

func (p *ASNParser) ObjectSetSpec() (localctx IObjectSetSpecContext) {
	localctx = NewObjectSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ASNParserRULE_objectSetSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(721)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserTRUE_LITERAL, ASNParserFALSE_LITERAL, ASNParserTRUE_SMALL_LITERAL, ASNParserFALSE_SMALL_LITERAL, ASNParserL_BRACE, ASNParserMINUS, ASNParserALL_LITERAL, ASNParserMIN_LITERAL, ASNParserSIZE_LITERAL, ASNParserPATTERN_LITERAL, ASNParserNUMBER, ASNParserBSTRING, ASNParserCSTRING, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(707)
			p.RootElementSetSpec()
		}
		p.SetState(714)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserCOMMA {
			{
				p.SetState(708)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(709)
				p.Match(ASNParserELLIPSIS)
			}
			p.SetState(712)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASNParserCOMMA {
				{
					p.SetState(710)
					p.Match(ASNParserCOMMA)
				}
				{
					p.SetState(711)
					p.AdditionalElementSetSpec()
				}

			}

		}

	case ASNParserELLIPSIS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(716)
			p.Match(ASNParserELLIPSIS)
		}
		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserCOMMA {
			{
				p.SetState(717)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(718)
				p.AdditionalElementSetSpec()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFieldNameContext is an interface to support dynamic dispatch.
type IFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldNameContext differentiates from other interfaces.
	IsFieldNameContext()
}

type FieldNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldNameContext() *FieldNameContext {
	var p = new(FieldNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_fieldName
	return p
}

func (*FieldNameContext) IsFieldNameContext() {}

func NewFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldNameContext {
	var p = new(FieldNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_fieldName

	return p
}

func (s *FieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldNameContext) AllAMPERSAND() []antlr.TerminalNode {
	return s.GetTokens(ASNParserAMPERSAND)
}

func (s *FieldNameContext) AMPERSAND(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, i)
}

func (s *FieldNameContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *FieldNameContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *FieldNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ASNParserDOT)
}

func (s *FieldNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, i)
}

func (s *FieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterFieldName(s)
	}
}

func (s *FieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitFieldName(s)
	}
}

func (p *ASNParser) FieldName() (localctx IFieldNameContext) {
	localctx = NewFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ASNParserRULE_fieldName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(723)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(724)
		p.Match(ASNParserIDENTIFIER)
	}

	p.SetState(731)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserAMPERSAND {
		{
			p.SetState(726)
			p.Match(ASNParserAMPERSAND)
		}
		{
			p.SetState(727)
			p.Match(ASNParserIDENTIFIER)
		}
		{
			p.SetState(728)
			p.Match(ASNParserDOT)
		}

		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IValueSetContext is an interface to support dynamic dispatch.
type IValueSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueSetContext differentiates from other interfaces.
	IsValueSetContext()
}

type ValueSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueSetContext() *ValueSetContext {
	var p = new(ValueSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_valueSet
	return p
}

func (*ValueSetContext) IsValueSetContext() {}

func NewValueSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueSetContext {
	var p = new(ValueSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_valueSet

	return p
}

func (s *ValueSetContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueSetContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ValueSetContext) ElementSetSpecs() IElementSetSpecsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementSetSpecsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementSetSpecsContext)
}

func (s *ValueSetContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ValueSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterValueSet(s)
	}
}

func (s *ValueSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitValueSet(s)
	}
}

func (p *ASNParser) ValueSet() (localctx IValueSetContext) {
	localctx = NewValueSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ASNParserRULE_valueSet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(734)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(735)
		p.ElementSetSpecs()
	}
	{
		p.SetState(736)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IElementSetSpecsContext is an interface to support dynamic dispatch.
type IElementSetSpecsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementSetSpecsContext differentiates from other interfaces.
	IsElementSetSpecsContext()
}

type ElementSetSpecsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementSetSpecsContext() *ElementSetSpecsContext {
	var p = new(ElementSetSpecsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_elementSetSpecs
	return p
}

func (*ElementSetSpecsContext) IsElementSetSpecsContext() {}

func NewElementSetSpecsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementSetSpecsContext {
	var p = new(ElementSetSpecsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_elementSetSpecs

	return p
}

func (s *ElementSetSpecsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementSetSpecsContext) RootElementSetSpec() IRootElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRootElementSetSpecContext)
}

func (s *ElementSetSpecsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ElementSetSpecsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ElementSetSpecsContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASNParserELLIPSIS, 0)
}

func (s *ElementSetSpecsContext) AdditionalElementSetSpec() IAdditionalElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditionalElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditionalElementSetSpecContext)
}

func (s *ElementSetSpecsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementSetSpecsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementSetSpecsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterElementSetSpecs(s)
	}
}

func (s *ElementSetSpecsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitElementSetSpecs(s)
	}
}

func (p *ASNParser) ElementSetSpecs() (localctx IElementSetSpecsContext) {
	localctx = NewElementSetSpecsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ASNParserRULE_elementSetSpecs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.RootElementSetSpec()
	}
	p.SetState(745)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserCOMMA {
		{
			p.SetState(739)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(740)
			p.Match(ASNParserELLIPSIS)
		}
		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserCOMMA {
			{
				p.SetState(741)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(742)
				p.AdditionalElementSetSpec()
			}

		}

	}

	return localctx
}

// IRootElementSetSpecContext is an interface to support dynamic dispatch.
type IRootElementSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootElementSetSpecContext differentiates from other interfaces.
	IsRootElementSetSpecContext()
}

type RootElementSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootElementSetSpecContext() *RootElementSetSpecContext {
	var p = new(RootElementSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_rootElementSetSpec
	return p
}

func (*RootElementSetSpecContext) IsRootElementSetSpecContext() {}

func NewRootElementSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootElementSetSpecContext {
	var p = new(RootElementSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_rootElementSetSpec

	return p
}

func (s *RootElementSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RootElementSetSpecContext) ElementSetSpec() IElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementSetSpecContext)
}

func (s *RootElementSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootElementSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootElementSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterRootElementSetSpec(s)
	}
}

func (s *RootElementSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitRootElementSetSpec(s)
	}
}

func (p *ASNParser) RootElementSetSpec() (localctx IRootElementSetSpecContext) {
	localctx = NewRootElementSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ASNParserRULE_rootElementSetSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.ElementSetSpec()
	}

	return localctx
}

// IAdditionalElementSetSpecContext is an interface to support dynamic dispatch.
type IAdditionalElementSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditionalElementSetSpecContext differentiates from other interfaces.
	IsAdditionalElementSetSpecContext()
}

type AdditionalElementSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditionalElementSetSpecContext() *AdditionalElementSetSpecContext {
	var p = new(AdditionalElementSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_additionalElementSetSpec
	return p
}

func (*AdditionalElementSetSpecContext) IsAdditionalElementSetSpecContext() {}

func NewAdditionalElementSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditionalElementSetSpecContext {
	var p = new(AdditionalElementSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_additionalElementSetSpec

	return p
}

func (s *AdditionalElementSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditionalElementSetSpecContext) ElementSetSpec() IElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementSetSpecContext)
}

func (s *AdditionalElementSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditionalElementSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditionalElementSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAdditionalElementSetSpec(s)
	}
}

func (s *AdditionalElementSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAdditionalElementSetSpec(s)
	}
}

func (p *ASNParser) AdditionalElementSetSpec() (localctx IAdditionalElementSetSpecContext) {
	localctx = NewAdditionalElementSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ASNParserRULE_additionalElementSetSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(749)
		p.ElementSetSpec()
	}

	return localctx
}

// IElementSetSpecContext is an interface to support dynamic dispatch.
type IElementSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementSetSpecContext differentiates from other interfaces.
	IsElementSetSpecContext()
}

type ElementSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementSetSpecContext() *ElementSetSpecContext {
	var p = new(ElementSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_elementSetSpec
	return p
}

func (*ElementSetSpecContext) IsElementSetSpecContext() {}

func NewElementSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementSetSpecContext {
	var p = new(ElementSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_elementSetSpec

	return p
}

func (s *ElementSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementSetSpecContext) Unions() IUnionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionsContext)
}

func (s *ElementSetSpecContext) ALL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserALL_LITERAL, 0)
}

func (s *ElementSetSpecContext) Exclusions() IExclusionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclusionsContext)
}

func (s *ElementSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterElementSetSpec(s)
	}
}

func (s *ElementSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitElementSetSpec(s)
	}
}

func (p *ASNParser) ElementSetSpec() (localctx IElementSetSpecContext) {
	localctx = NewElementSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ASNParserRULE_elementSetSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(754)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserTRUE_LITERAL, ASNParserFALSE_LITERAL, ASNParserTRUE_SMALL_LITERAL, ASNParserFALSE_SMALL_LITERAL, ASNParserL_BRACE, ASNParserMINUS, ASNParserMIN_LITERAL, ASNParserSIZE_LITERAL, ASNParserPATTERN_LITERAL, ASNParserNUMBER, ASNParserBSTRING, ASNParserCSTRING, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(751)
			p.Unions()
		}

	case ASNParserALL_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(752)
			p.Match(ASNParserALL_LITERAL)
		}
		{
			p.SetState(753)
			p.Exclusions()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnionsContext is an interface to support dynamic dispatch.
type IUnionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionsContext differentiates from other interfaces.
	IsUnionsContext()
}

type UnionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionsContext() *UnionsContext {
	var p = new(UnionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_unions
	return p
}

func (*UnionsContext) IsUnionsContext() {}

func NewUnionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionsContext {
	var p = new(UnionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_unions

	return p
}

func (s *UnionsContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionsContext) AllIntersections() []IIntersectionsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntersectionsContext)(nil)).Elem())
	var tst = make([]IIntersectionsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntersectionsContext)
		}
	}

	return tst
}

func (s *UnionsContext) Intersections(i int) IIntersectionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntersectionsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntersectionsContext)
}

func (s *UnionsContext) AllUnionMark() []IUnionMarkContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionMarkContext)(nil)).Elem())
	var tst = make([]IUnionMarkContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionMarkContext)
		}
	}

	return tst
}

func (s *UnionsContext) UnionMark(i int) IUnionMarkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionMarkContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionMarkContext)
}

func (s *UnionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterUnions(s)
	}
}

func (s *UnionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitUnions(s)
	}
}

func (p *ASNParser) Unions() (localctx IUnionsContext) {
	localctx = NewUnionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ASNParserRULE_unions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(756)
		p.Intersections()
	}

	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserPIPE || _la == ASNParserUNION_LITERAL {
		{
			p.SetState(757)
			p.UnionMark()
		}
		{
			p.SetState(758)
			p.Intersections()
		}

		p.SetState(764)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExclusionsContext is an interface to support dynamic dispatch.
type IExclusionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExclusionsContext differentiates from other interfaces.
	IsExclusionsContext()
}

type ExclusionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusionsContext() *ExclusionsContext {
	var p = new(ExclusionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_exclusions
	return p
}

func (*ExclusionsContext) IsExclusionsContext() {}

func NewExclusionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExclusionsContext {
	var p = new(ExclusionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_exclusions

	return p
}

func (s *ExclusionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExclusionsContext) EXCEPT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserEXCEPT_LITERAL, 0)
}

func (s *ExclusionsContext) Elements() IElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementsContext)
}

func (s *ExclusionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclusionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExclusionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExclusions(s)
	}
}

func (s *ExclusionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExclusions(s)
	}
}

func (p *ASNParser) Exclusions() (localctx IExclusionsContext) {
	localctx = NewExclusionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ASNParserRULE_exclusions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(765)
		p.Match(ASNParserEXCEPT_LITERAL)
	}
	{
		p.SetState(766)
		p.Elements()
	}

	return localctx
}

// IIntersectionsContext is an interface to support dynamic dispatch.
type IIntersectionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntersectionsContext differentiates from other interfaces.
	IsIntersectionsContext()
}

type IntersectionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntersectionsContext() *IntersectionsContext {
	var p = new(IntersectionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_intersections
	return p
}

func (*IntersectionsContext) IsIntersectionsContext() {}

func NewIntersectionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntersectionsContext {
	var p = new(IntersectionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_intersections

	return p
}

func (s *IntersectionsContext) GetParser() antlr.Parser { return s.parser }

func (s *IntersectionsContext) AllIntersectionElements() []IIntersectionElementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntersectionElementsContext)(nil)).Elem())
	var tst = make([]IIntersectionElementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntersectionElementsContext)
		}
	}

	return tst
}

func (s *IntersectionsContext) IntersectionElements(i int) IIntersectionElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntersectionElementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntersectionElementsContext)
}

func (s *IntersectionsContext) AllIntersectionMark() []IIntersectionMarkContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntersectionMarkContext)(nil)).Elem())
	var tst = make([]IIntersectionMarkContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntersectionMarkContext)
		}
	}

	return tst
}

func (s *IntersectionsContext) IntersectionMark(i int) IIntersectionMarkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntersectionMarkContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntersectionMarkContext)
}

func (s *IntersectionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntersectionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterIntersections(s)
	}
}

func (s *IntersectionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitIntersections(s)
	}
}

func (p *ASNParser) Intersections() (localctx IIntersectionsContext) {
	localctx = NewIntersectionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ASNParserRULE_intersections)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(768)
		p.IntersectionElements()
	}

	p.SetState(774)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserPOWER || _la == ASNParserINTERSECTION_LITERAL {
		{
			p.SetState(769)
			p.IntersectionMark()
		}
		{
			p.SetState(770)
			p.IntersectionElements()
		}

		p.SetState(776)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUnionMarkContext is an interface to support dynamic dispatch.
type IUnionMarkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionMarkContext differentiates from other interfaces.
	IsUnionMarkContext()
}

type UnionMarkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionMarkContext() *UnionMarkContext {
	var p = new(UnionMarkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_unionMark
	return p
}

func (*UnionMarkContext) IsUnionMarkContext() {}

func NewUnionMarkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionMarkContext {
	var p = new(UnionMarkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_unionMark

	return p
}

func (s *UnionMarkContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionMarkContext) PIPE() antlr.TerminalNode {
	return s.GetToken(ASNParserPIPE, 0)
}

func (s *UnionMarkContext) UNION_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserUNION_LITERAL, 0)
}

func (s *UnionMarkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionMarkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionMarkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterUnionMark(s)
	}
}

func (s *UnionMarkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitUnionMark(s)
	}
}

func (p *ASNParser) UnionMark() (localctx IUnionMarkContext) {
	localctx = NewUnionMarkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ASNParserRULE_unionMark)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(777)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASNParserPIPE || _la == ASNParserUNION_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIntersectionMarkContext is an interface to support dynamic dispatch.
type IIntersectionMarkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntersectionMarkContext differentiates from other interfaces.
	IsIntersectionMarkContext()
}

type IntersectionMarkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntersectionMarkContext() *IntersectionMarkContext {
	var p = new(IntersectionMarkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_intersectionMark
	return p
}

func (*IntersectionMarkContext) IsIntersectionMarkContext() {}

func NewIntersectionMarkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntersectionMarkContext {
	var p = new(IntersectionMarkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_intersectionMark

	return p
}

func (s *IntersectionMarkContext) GetParser() antlr.Parser { return s.parser }

func (s *IntersectionMarkContext) POWER() antlr.TerminalNode {
	return s.GetToken(ASNParserPOWER, 0)
}

func (s *IntersectionMarkContext) INTERSECTION_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserINTERSECTION_LITERAL, 0)
}

func (s *IntersectionMarkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectionMarkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntersectionMarkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterIntersectionMark(s)
	}
}

func (s *IntersectionMarkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitIntersectionMark(s)
	}
}

func (p *ASNParser) IntersectionMark() (localctx IIntersectionMarkContext) {
	localctx = NewIntersectionMarkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ASNParserRULE_intersectionMark)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASNParserPOWER || _la == ASNParserINTERSECTION_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IElementsContext is an interface to support dynamic dispatch.
type IElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementsContext differentiates from other interfaces.
	IsElementsContext()
}

type ElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementsContext() *ElementsContext {
	var p = new(ElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_elements
	return p
}

func (*ElementsContext) IsElementsContext() {}

func NewElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementsContext {
	var p = new(ElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_elements

	return p
}

func (s *ElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementsContext) SubtypeElements() ISubtypeElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtypeElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtypeElementsContext)
}

func (s *ElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterElements(s)
	}
}

func (s *ElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitElements(s)
	}
}

func (p *ASNParser) Elements() (localctx IElementsContext) {
	localctx = NewElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ASNParserRULE_elements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		p.SubtypeElements()
	}

	return localctx
}

// IObjectSetElementsContext is an interface to support dynamic dispatch.
type IObjectSetElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetElementsContext differentiates from other interfaces.
	IsObjectSetElementsContext()
}

type ObjectSetElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetElementsContext() *ObjectSetElementsContext {
	var p = new(ObjectSetElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectSetElements
	return p
}

func (*ObjectSetElementsContext) IsObjectSetElementsContext() {}

func NewObjectSetElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetElementsContext {
	var p = new(ObjectSetElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectSetElements

	return p
}

func (s *ObjectSetElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetElementsContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *ObjectSetElementsContext) DefinedObject() IDefinedObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectContext)
}

func (s *ObjectSetElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectSetElements(s)
	}
}

func (s *ObjectSetElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectSetElements(s)
	}
}

func (p *ASNParser) ObjectSetElements() (localctx IObjectSetElementsContext) {
	localctx = NewObjectSetElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ASNParserRULE_objectSetElements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(785)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(783)
			p.Object()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(784)
			p.DefinedObject()
		}

	}

	return localctx
}

// IIntersectionElementsContext is an interface to support dynamic dispatch.
type IIntersectionElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntersectionElementsContext differentiates from other interfaces.
	IsIntersectionElementsContext()
}

type IntersectionElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntersectionElementsContext() *IntersectionElementsContext {
	var p = new(IntersectionElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_intersectionElements
	return p
}

func (*IntersectionElementsContext) IsIntersectionElementsContext() {}

func NewIntersectionElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntersectionElementsContext {
	var p = new(IntersectionElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_intersectionElements

	return p
}

func (s *IntersectionElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *IntersectionElementsContext) Elements() IElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementsContext)
}

func (s *IntersectionElementsContext) Exclusions() IExclusionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclusionsContext)
}

func (s *IntersectionElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectionElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntersectionElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterIntersectionElements(s)
	}
}

func (s *IntersectionElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitIntersectionElements(s)
	}
}

func (p *ASNParser) IntersectionElements() (localctx IIntersectionElementsContext) {
	localctx = NewIntersectionElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ASNParserRULE_intersectionElements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(787)
		p.Elements()
	}
	p.SetState(789)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserEXCEPT_LITERAL {
		{
			p.SetState(788)
			p.Exclusions()
		}

	}

	return localctx
}

// ISubtypeElementsContext is an interface to support dynamic dispatch.
type ISubtypeElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtypeElementsContext differentiates from other interfaces.
	IsSubtypeElementsContext()
}

type SubtypeElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtypeElementsContext() *SubtypeElementsContext {
	var p = new(SubtypeElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_subtypeElements
	return p
}

func (*SubtypeElementsContext) IsSubtypeElementsContext() {}

func NewSubtypeElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtypeElementsContext {
	var p = new(SubtypeElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_subtypeElements

	return p
}

func (s *SubtypeElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtypeElementsContext) DOUBLE_DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOUBLE_DOT, 0)
}

func (s *SubtypeElementsContext) AllValue() []IValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueContext)(nil)).Elem())
	var tst = make([]IValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueContext)
		}
	}

	return tst
}

func (s *SubtypeElementsContext) Value(i int) IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *SubtypeElementsContext) MIN_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserMIN_LITERAL, 0)
}

func (s *SubtypeElementsContext) MAX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserMAX_LITERAL, 0)
}

func (s *SubtypeElementsContext) AllLESS_THAN() []antlr.TerminalNode {
	return s.GetTokens(ASNParserLESS_THAN)
}

func (s *SubtypeElementsContext) LESS_THAN(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserLESS_THAN, i)
}

func (s *SubtypeElementsContext) SizeConstraint() ISizeConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISizeConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISizeConstraintContext)
}

func (s *SubtypeElementsContext) PATTERN_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserPATTERN_LITERAL, 0)
}

func (s *SubtypeElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtypeElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtypeElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSubtypeElements(s)
	}
}

func (s *SubtypeElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSubtypeElements(s)
	}
}

func (p *ASNParser) SubtypeElements() (localctx ISubtypeElementsContext) {
	localctx = NewSubtypeElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ASNParserRULE_subtypeElements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(793)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASNParserTRUE_LITERAL, ASNParserFALSE_LITERAL, ASNParserTRUE_SMALL_LITERAL, ASNParserFALSE_SMALL_LITERAL, ASNParserL_BRACE, ASNParserMINUS, ASNParserNUMBER, ASNParserBSTRING, ASNParserCSTRING, ASNParserIDENTIFIER:
			{
				p.SetState(791)
				p.Value()
			}

		case ASNParserMIN_LITERAL:
			{
				p.SetState(792)
				p.Match(ASNParserMIN_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(796)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserLESS_THAN {
			{
				p.SetState(795)
				p.Match(ASNParserLESS_THAN)
			}

		}
		{
			p.SetState(798)
			p.Match(ASNParserDOUBLE_DOT)
		}
		p.SetState(800)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserLESS_THAN {
			{
				p.SetState(799)
				p.Match(ASNParserLESS_THAN)
			}

		}
		p.SetState(804)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASNParserTRUE_LITERAL, ASNParserFALSE_LITERAL, ASNParserTRUE_SMALL_LITERAL, ASNParserFALSE_SMALL_LITERAL, ASNParserL_BRACE, ASNParserMINUS, ASNParserNUMBER, ASNParserBSTRING, ASNParserCSTRING, ASNParserIDENTIFIER:
			{
				p.SetState(802)
				p.Value()
			}

		case ASNParserMAX_LITERAL:
			{
				p.SetState(803)
				p.Match(ASNParserMAX_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(806)
			p.SizeConstraint()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(807)
			p.Match(ASNParserPATTERN_LITERAL)
		}
		{
			p.SetState(808)
			p.Value()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(809)
			p.Value()
		}

	}

	return localctx
}

// IVariableTypeValueSetFieldSpecContext is an interface to support dynamic dispatch.
type IVariableTypeValueSetFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableTypeValueSetFieldSpecContext differentiates from other interfaces.
	IsVariableTypeValueSetFieldSpecContext()
}

type VariableTypeValueSetFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableTypeValueSetFieldSpecContext() *VariableTypeValueSetFieldSpecContext {
	var p = new(VariableTypeValueSetFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_variableTypeValueSetFieldSpec
	return p
}

func (*VariableTypeValueSetFieldSpecContext) IsVariableTypeValueSetFieldSpecContext() {}

func NewVariableTypeValueSetFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableTypeValueSetFieldSpecContext {
	var p = new(VariableTypeValueSetFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_variableTypeValueSetFieldSpec

	return p
}

func (s *VariableTypeValueSetFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableTypeValueSetFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *VariableTypeValueSetFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *VariableTypeValueSetFieldSpecContext) FieldName() IFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *VariableTypeValueSetFieldSpecContext) ValueSetOptionalitySpec() IValueSetOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetOptionalitySpecContext)
}

func (s *VariableTypeValueSetFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableTypeValueSetFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableTypeValueSetFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterVariableTypeValueSetFieldSpec(s)
	}
}

func (s *VariableTypeValueSetFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitVariableTypeValueSetFieldSpec(s)
	}
}

func (p *ASNParser) VariableTypeValueSetFieldSpec() (localctx IVariableTypeValueSetFieldSpecContext) {
	localctx = NewVariableTypeValueSetFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ASNParserRULE_variableTypeValueSetFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(813)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(814)
		p.FieldName()
	}
	p.SetState(816)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
		{
			p.SetState(815)
			p.ValueSetOptionalitySpec()
		}

	}

	return localctx
}

// IObjectFieldSpecContext is an interface to support dynamic dispatch.
type IObjectFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectFieldSpecContext differentiates from other interfaces.
	IsObjectFieldSpecContext()
}

type ObjectFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldSpecContext() *ObjectFieldSpecContext {
	var p = new(ObjectFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectFieldSpec
	return p
}

func (*ObjectFieldSpecContext) IsObjectFieldSpecContext() {}

func NewObjectFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldSpecContext {
	var p = new(ObjectFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectFieldSpec

	return p
}

func (s *ObjectFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *ObjectFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *ObjectFieldSpecContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ObjectFieldSpecContext) ObjectOptionalitySpec() IObjectOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectOptionalitySpecContext)
}

func (s *ObjectFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectFieldSpec(s)
	}
}

func (s *ObjectFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectFieldSpec(s)
	}
}

func (p *ASNParser) ObjectFieldSpec() (localctx IObjectFieldSpecContext) {
	localctx = NewObjectFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ASNParserRULE_objectFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(818)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(819)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(820)
		p.DefinedObjectClass()
	}
	p.SetState(822)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
		{
			p.SetState(821)
			p.ObjectOptionalitySpec()
		}

	}

	return localctx
}

// IObjectOptionalitySpecContext is an interface to support dynamic dispatch.
type IObjectOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectOptionalitySpecContext differentiates from other interfaces.
	IsObjectOptionalitySpecContext()
}

type ObjectOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectOptionalitySpecContext() *ObjectOptionalitySpecContext {
	var p = new(ObjectOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectOptionalitySpec
	return p
}

func (*ObjectOptionalitySpecContext) IsObjectOptionalitySpecContext() {}

func NewObjectOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectOptionalitySpecContext {
	var p = new(ObjectOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectOptionalitySpec

	return p
}

func (s *ObjectOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOPTIONAL_LITERAL, 0)
}

func (s *ObjectOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFAULT_LITERAL, 0)
}

func (s *ObjectOptionalitySpecContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *ObjectOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectOptionalitySpec(s)
	}
}

func (s *ObjectOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectOptionalitySpec(s)
	}
}

func (p *ASNParser) ObjectOptionalitySpec() (localctx IObjectOptionalitySpecContext) {
	localctx = NewObjectOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ASNParserRULE_objectOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(827)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(824)
			p.Match(ASNParserOPTIONAL_LITERAL)
		}

	case ASNParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(825)
			p.Match(ASNParserDEFAULT_LITERAL)
		}
		{
			p.SetState(826)
			p.Object()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObjectSetFieldSpecContext is an interface to support dynamic dispatch.
type IObjectSetFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetFieldSpecContext differentiates from other interfaces.
	IsObjectSetFieldSpecContext()
}

type ObjectSetFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetFieldSpecContext() *ObjectSetFieldSpecContext {
	var p = new(ObjectSetFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectSetFieldSpec
	return p
}

func (*ObjectSetFieldSpecContext) IsObjectSetFieldSpecContext() {}

func NewObjectSetFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetFieldSpecContext {
	var p = new(ObjectSetFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectSetFieldSpec

	return p
}

func (s *ObjectSetFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *ObjectSetFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *ObjectSetFieldSpecContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ObjectSetFieldSpecContext) ObjectSetOptionalitySpec() IObjectSetOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetOptionalitySpecContext)
}

func (s *ObjectSetFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectSetFieldSpec(s)
	}
}

func (s *ObjectSetFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectSetFieldSpec(s)
	}
}

func (p *ASNParser) ObjectSetFieldSpec() (localctx IObjectSetFieldSpecContext) {
	localctx = NewObjectSetFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ASNParserRULE_objectSetFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(829)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(830)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(831)
		p.DefinedObjectClass()
	}
	p.SetState(833)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
		{
			p.SetState(832)
			p.ObjectSetOptionalitySpec()
		}

	}

	return localctx
}

// IObjectSetOptionalitySpecContext is an interface to support dynamic dispatch.
type IObjectSetOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetOptionalitySpecContext differentiates from other interfaces.
	IsObjectSetOptionalitySpecContext()
}

type ObjectSetOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetOptionalitySpecContext() *ObjectSetOptionalitySpecContext {
	var p = new(ObjectSetOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectSetOptionalitySpec
	return p
}

func (*ObjectSetOptionalitySpecContext) IsObjectSetOptionalitySpecContext() {}

func NewObjectSetOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetOptionalitySpecContext {
	var p = new(ObjectSetOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectSetOptionalitySpec

	return p
}

func (s *ObjectSetOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOPTIONAL_LITERAL, 0)
}

func (s *ObjectSetOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFAULT_LITERAL, 0)
}

func (s *ObjectSetOptionalitySpecContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *ObjectSetOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectSetOptionalitySpec(s)
	}
}

func (s *ObjectSetOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectSetOptionalitySpec(s)
	}
}

func (p *ASNParser) ObjectSetOptionalitySpec() (localctx IObjectSetOptionalitySpecContext) {
	localctx = NewObjectSetOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ASNParserRULE_objectSetOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(838)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(835)
			p.Match(ASNParserOPTIONAL_LITERAL)
		}

	case ASNParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(836)
			p.Match(ASNParserDEFAULT_LITERAL)
		}
		{
			p.SetState(837)
			p.ObjectSet()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeAssignmentContext is an interface to support dynamic dispatch.
type ITypeAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeAssignmentContext differentiates from other interfaces.
	IsTypeAssignmentContext()
}

type TypeAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAssignmentContext() *TypeAssignmentContext {
	var p = new(TypeAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_typeAssignment
	return p
}

func (*TypeAssignmentContext) IsTypeAssignmentContext() {}

func NewTypeAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAssignmentContext {
	var p = new(TypeAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_typeAssignment

	return p
}

func (s *TypeAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAssignmentContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASNParserASSIGN_OP, 0)
}

func (s *TypeAssignmentContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *TypeAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterTypeAssignment(s)
	}
}

func (s *TypeAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitTypeAssignment(s)
	}
}

func (p *ASNParser) TypeAssignment() (localctx ITypeAssignmentContext) {
	localctx = NewTypeAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ASNParserRULE_typeAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(840)
		p.Match(ASNParserASSIGN_OP)
	}
	{
		p.SetState(841)
		p.AsnType()
	}

	return localctx
}

// IValueAssignmentContext is an interface to support dynamic dispatch.
type IValueAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueAssignmentContext differentiates from other interfaces.
	IsValueAssignmentContext()
}

type ValueAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueAssignmentContext() *ValueAssignmentContext {
	var p = new(ValueAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_valueAssignment
	return p
}

func (*ValueAssignmentContext) IsValueAssignmentContext() {}

func NewValueAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueAssignmentContext {
	var p = new(ValueAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_valueAssignment

	return p
}

func (s *ValueAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueAssignmentContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ValueAssignmentContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASNParserASSIGN_OP, 0)
}

func (s *ValueAssignmentContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ValueAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterValueAssignment(s)
	}
}

func (s *ValueAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitValueAssignment(s)
	}
}

func (p *ASNParser) ValueAssignment() (localctx IValueAssignmentContext) {
	localctx = NewValueAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ASNParserRULE_valueAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(843)
		p.AsnType()
	}
	{
		p.SetState(844)
		p.Match(ASNParserASSIGN_OP)
	}
	{
		p.SetState(845)
		p.Value()
	}

	return localctx
}

// IAsnTypeContext is an interface to support dynamic dispatch.
type IAsnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsnTypeContext differentiates from other interfaces.
	IsAsnTypeContext()
}

type AsnTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsnTypeContext() *AsnTypeContext {
	var p = new(AsnTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_asnType
	return p
}

func (*AsnTypeContext) IsAsnTypeContext() {}

func NewAsnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsnTypeContext {
	var p = new(AsnTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_asnType

	return p
}

func (s *AsnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AsnTypeContext) BuiltinType() IBuiltinTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBuiltinTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBuiltinTypeContext)
}

func (s *AsnTypeContext) ReferencedType() IReferencedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferencedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferencedTypeContext)
}

func (s *AsnTypeContext) AllConstraint() []IConstraintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstraintContext)(nil)).Elem())
	var tst = make([]IConstraintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstraintContext)
		}
	}

	return tst
}

func (s *AsnTypeContext) Constraint(i int) IConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *AsnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAsnType(s)
	}
}

func (s *AsnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAsnType(s)
	}
}

func (p *ASNParser) AsnType() (localctx IAsnTypeContext) {
	localctx = NewAsnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ASNParserRULE_asnType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(849)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(847)
			p.BuiltinType()
		}

	case 2:
		{
			p.SetState(848)
			p.ReferencedType()
		}

	}
	p.SetState(854)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(851)
				p.Constraint()
			}

		}
		p.SetState(856)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())
	}

	return localctx
}

// IBuiltinTypeContext is an interface to support dynamic dispatch.
type IBuiltinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBuiltinTypeContext differentiates from other interfaces.
	IsBuiltinTypeContext()
}

type BuiltinTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuiltinTypeContext() *BuiltinTypeContext {
	var p = new(BuiltinTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_builtinType
	return p
}

func (*BuiltinTypeContext) IsBuiltinTypeContext() {}

func NewBuiltinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuiltinTypeContext {
	var p = new(BuiltinTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_builtinType

	return p
}

func (s *BuiltinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BuiltinTypeContext) OctetStringType() IOctetStringTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctetStringTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOctetStringTypeContext)
}

func (s *BuiltinTypeContext) BitStringType() IBitStringTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitStringTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitStringTypeContext)
}

func (s *BuiltinTypeContext) ChoiceType() IChoiceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoiceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChoiceTypeContext)
}

func (s *BuiltinTypeContext) EnumeratedType() IEnumeratedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeratedTypeContext)
}

func (s *BuiltinTypeContext) IntegerType() IIntegerTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerTypeContext)
}

func (s *BuiltinTypeContext) SequenceType() ISequenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *BuiltinTypeContext) SequenceOfType() ISequenceOfTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceOfTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceOfTypeContext)
}

func (s *BuiltinTypeContext) SetType() ISetTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetTypeContext)
}

func (s *BuiltinTypeContext) SetOfType() ISetOfTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetOfTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetOfTypeContext)
}

func (s *BuiltinTypeContext) Objectidentifiertype() IObjectidentifiertypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectidentifiertypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectidentifiertypeContext)
}

func (s *BuiltinTypeContext) ObjectClassFieldType() IObjectClassFieldTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassFieldTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassFieldTypeContext)
}

func (s *BuiltinTypeContext) BOOLEAN_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserBOOLEAN_LITERAL, 0)
}

func (s *BuiltinTypeContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserNULL_LITERAL, 0)
}

func (s *BuiltinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuiltinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuiltinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterBuiltinType(s)
	}
}

func (s *BuiltinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitBuiltinType(s)
	}
}

func (p *ASNParser) BuiltinType() (localctx IBuiltinTypeContext) {
	localctx = NewBuiltinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ASNParserRULE_builtinType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(857)
			p.OctetStringType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(858)
			p.BitStringType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(859)
			p.ChoiceType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(860)
			p.EnumeratedType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(861)
			p.IntegerType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(862)
			p.SequenceType()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(863)
			p.SequenceOfType()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(864)
			p.SetType()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(865)
			p.SetOfType()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(866)
			p.Objectidentifiertype()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(867)
			p.ObjectClassFieldType()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(868)
			p.Match(ASNParserBOOLEAN_LITERAL)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(869)
			p.Match(ASNParserNULL_LITERAL)
		}

	}

	return localctx
}

// IObjectClassFieldTypeContext is an interface to support dynamic dispatch.
type IObjectClassFieldTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectClassFieldTypeContext differentiates from other interfaces.
	IsObjectClassFieldTypeContext()
}

type ObjectClassFieldTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectClassFieldTypeContext() *ObjectClassFieldTypeContext {
	var p = new(ObjectClassFieldTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectClassFieldType
	return p
}

func (*ObjectClassFieldTypeContext) IsObjectClassFieldTypeContext() {}

func NewObjectClassFieldTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectClassFieldTypeContext {
	var p = new(ObjectClassFieldTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectClassFieldType

	return p
}

func (s *ObjectClassFieldTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectClassFieldTypeContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ObjectClassFieldTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *ObjectClassFieldTypeContext) FieldName() IFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *ObjectClassFieldTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectClassFieldTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectClassFieldTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectClassFieldType(s)
	}
}

func (s *ObjectClassFieldTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectClassFieldType(s)
	}
}

func (p *ASNParser) ObjectClassFieldType() (localctx IObjectClassFieldTypeContext) {
	localctx = NewObjectClassFieldTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ASNParserRULE_objectClassFieldType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(872)
		p.DefinedObjectClass()
	}
	{
		p.SetState(873)
		p.Match(ASNParserDOT)
	}
	{
		p.SetState(874)
		p.FieldName()
	}

	return localctx
}

// ISetTypeContext is an interface to support dynamic dispatch.
type ISetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetTypeContext differentiates from other interfaces.
	IsSetTypeContext()
}

type SetTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetTypeContext() *SetTypeContext {
	var p = new(SetTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_setType
	return p
}

func (*SetTypeContext) IsSetTypeContext() {}

func NewSetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTypeContext {
	var p = new(SetTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_setType

	return p
}

func (s *SetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTypeContext) SET_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSET_LITERAL, 0)
}

func (s *SetTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *SetTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *SetTypeContext) ExtensionAndException() IExtensionAndExceptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAndExceptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAndExceptionContext)
}

func (s *SetTypeContext) OptionalExtensionMarker() IOptionalExtensionMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalExtensionMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalExtensionMarkerContext)
}

func (s *SetTypeContext) ComponentTypeLists() IComponentTypeListsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeListsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeListsContext)
}

func (s *SetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSetType(s)
	}
}

func (s *SetTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSetType(s)
	}
}

func (p *ASNParser) SetType() (localctx ISetTypeContext) {
	localctx = NewSetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ASNParserRULE_setType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(876)
		p.Match(ASNParserSET_LITERAL)
	}
	{
		p.SetState(877)
		p.Match(ASNParserL_BRACE)
	}
	p.SetState(882)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(878)
			p.ExtensionAndException()
		}
		{
			p.SetState(879)
			p.OptionalExtensionMarker()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(881)
			p.ComponentTypeLists()
		}

	}
	{
		p.SetState(884)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// ISetOfTypeContext is an interface to support dynamic dispatch.
type ISetOfTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetOfTypeContext differentiates from other interfaces.
	IsSetOfTypeContext()
}

type SetOfTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetOfTypeContext() *SetOfTypeContext {
	var p = new(SetOfTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_setOfType
	return p
}

func (*SetOfTypeContext) IsSetOfTypeContext() {}

func NewSetOfTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetOfTypeContext {
	var p = new(SetOfTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_setOfType

	return p
}

func (s *SetOfTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetOfTypeContext) SET_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSET_LITERAL, 0)
}

func (s *SetOfTypeContext) OF_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOF_LITERAL, 0)
}

func (s *SetOfTypeContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *SetOfTypeContext) NamedType() INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *SetOfTypeContext) Constraint() IConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *SetOfTypeContext) SizeConstraint() ISizeConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISizeConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISizeConstraintContext)
}

func (s *SetOfTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOfTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetOfTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSetOfType(s)
	}
}

func (s *SetOfTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSetOfType(s)
	}
}

func (p *ASNParser) SetOfType() (localctx ISetOfTypeContext) {
	localctx = NewSetOfTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ASNParserRULE_setOfType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(886)
		p.Match(ASNParserSET_LITERAL)
	}
	p.SetState(889)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserL_PARAN:
		{
			p.SetState(887)
			p.Constraint()
		}

	case ASNParserSIZE_LITERAL:
		{
			p.SetState(888)
			p.SizeConstraint()
		}

	case ASNParserOF_LITERAL:

	default:
	}
	{
		p.SetState(891)
		p.Match(ASNParserOF_LITERAL)
	}
	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(892)
			p.AsnType()
		}

	case 2:
		{
			p.SetState(893)
			p.NamedType()
		}

	}

	return localctx
}

// IReferencedTypeContext is an interface to support dynamic dispatch.
type IReferencedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferencedTypeContext differentiates from other interfaces.
	IsReferencedTypeContext()
}

type ReferencedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferencedTypeContext() *ReferencedTypeContext {
	var p = new(ReferencedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_referencedType
	return p
}

func (*ReferencedTypeContext) IsReferencedTypeContext() {}

func NewReferencedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferencedTypeContext {
	var p = new(ReferencedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_referencedType

	return p
}

func (s *ReferencedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferencedTypeContext) DefinedType() IDefinedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedTypeContext)
}

func (s *ReferencedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferencedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferencedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterReferencedType(s)
	}
}

func (s *ReferencedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitReferencedType(s)
	}
}

func (p *ASNParser) ReferencedType() (localctx IReferencedTypeContext) {
	localctx = NewReferencedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ASNParserRULE_referencedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(896)
		p.DefinedType()
	}

	return localctx
}

// IDefinedTypeContext is an interface to support dynamic dispatch.
type IDefinedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinedTypeContext differentiates from other interfaces.
	IsDefinedTypeContext()
}

type DefinedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinedTypeContext() *DefinedTypeContext {
	var p = new(DefinedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_definedType
	return p
}

func (*DefinedTypeContext) IsDefinedTypeContext() {}

func NewDefinedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinedTypeContext {
	var p = new(DefinedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_definedType

	return p
}

func (s *DefinedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinedTypeContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *DefinedTypeContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *DefinedTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *DefinedTypeContext) ActualParameterList() IActualParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActualParameterListContext)
}

func (s *DefinedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterDefinedType(s)
	}
}

func (s *DefinedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitDefinedType(s)
	}
}

func (p *ASNParser) DefinedType() (localctx IDefinedTypeContext) {
	localctx = NewDefinedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ASNParserRULE_definedType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(898)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(901)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserDOT {
		{
			p.SetState(899)
			p.Match(ASNParserDOT)
		}
		{
			p.SetState(900)
			p.Match(ASNParserIDENTIFIER)
		}

	}
	p.SetState(904)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(903)
			p.ActualParameterList()
		}

	}

	return localctx
}

// IConstraintContext is an interface to support dynamic dispatch.
type IConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintContext differentiates from other interfaces.
	IsConstraintContext()
}

type ConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintContext() *ConstraintContext {
	var p = new(ConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_constraint
	return p
}

func (*ConstraintContext) IsConstraintContext() {}

func NewConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintContext {
	var p = new(ConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_constraint

	return p
}

func (s *ConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserL_PARAN, 0)
}

func (s *ConstraintContext) ConstraintSpec() IConstraintSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintSpecContext)
}

func (s *ConstraintContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserR_PARAN, 0)
}

func (s *ConstraintContext) ExceptionSpec() IExceptionSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExceptionSpecContext)
}

func (s *ConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterConstraint(s)
	}
}

func (s *ConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitConstraint(s)
	}
}

func (p *ASNParser) Constraint() (localctx IConstraintContext) {
	localctx = NewConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ASNParserRULE_constraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(906)
		p.Match(ASNParserL_PARAN)
	}
	{
		p.SetState(907)
		p.ConstraintSpec()
	}
	p.SetState(909)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserEXCLAM {
		{
			p.SetState(908)
			p.ExceptionSpec()
		}

	}
	{
		p.SetState(911)
		p.Match(ASNParserR_PARAN)
	}

	return localctx
}

// IConstraintSpecContext is an interface to support dynamic dispatch.
type IConstraintSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintSpecContext differentiates from other interfaces.
	IsConstraintSpecContext()
}

type ConstraintSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintSpecContext() *ConstraintSpecContext {
	var p = new(ConstraintSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_constraintSpec
	return p
}

func (*ConstraintSpecContext) IsConstraintSpecContext() {}

func NewConstraintSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintSpecContext {
	var p = new(ConstraintSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_constraintSpec

	return p
}

func (s *ConstraintSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintSpecContext) GeneralConstraint() IGeneralConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneralConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneralConstraintContext)
}

func (s *ConstraintSpecContext) SubtypeConstraint() ISubtypeConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtypeConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtypeConstraintContext)
}

func (s *ConstraintSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterConstraintSpec(s)
	}
}

func (s *ConstraintSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitConstraintSpec(s)
	}
}

func (p *ASNParser) ConstraintSpec() (localctx IConstraintSpecContext) {
	localctx = NewConstraintSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ASNParserRULE_constraintSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(913)
			p.GeneralConstraint()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(914)
			p.SubtypeConstraint()
		}

	}

	return localctx
}

// IUserDefinedConstraintContext is an interface to support dynamic dispatch.
type IUserDefinedConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUserDefinedConstraintContext differentiates from other interfaces.
	IsUserDefinedConstraintContext()
}

type UserDefinedConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserDefinedConstraintContext() *UserDefinedConstraintContext {
	var p = new(UserDefinedConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_userDefinedConstraint
	return p
}

func (*UserDefinedConstraintContext) IsUserDefinedConstraintContext() {}

func NewUserDefinedConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserDefinedConstraintContext {
	var p = new(UserDefinedConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_userDefinedConstraint

	return p
}

func (s *UserDefinedConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *UserDefinedConstraintContext) CONSTRAINED_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserCONSTRAINED_LITERAL, 0)
}

func (s *UserDefinedConstraintContext) BY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserBY_LITERAL, 0)
}

func (s *UserDefinedConstraintContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *UserDefinedConstraintContext) AllUserDefinedConstraintParameter() []IUserDefinedConstraintParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUserDefinedConstraintParameterContext)(nil)).Elem())
	var tst = make([]IUserDefinedConstraintParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUserDefinedConstraintParameterContext)
		}
	}

	return tst
}

func (s *UserDefinedConstraintContext) UserDefinedConstraintParameter(i int) IUserDefinedConstraintParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserDefinedConstraintParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUserDefinedConstraintParameterContext)
}

func (s *UserDefinedConstraintContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *UserDefinedConstraintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *UserDefinedConstraintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *UserDefinedConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserDefinedConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserDefinedConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterUserDefinedConstraint(s)
	}
}

func (s *UserDefinedConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitUserDefinedConstraint(s)
	}
}

func (p *ASNParser) UserDefinedConstraint() (localctx IUserDefinedConstraintContext) {
	localctx = NewUserDefinedConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ASNParserRULE_userDefinedConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(917)
		p.Match(ASNParserCONSTRAINED_LITERAL)
	}
	{
		p.SetState(918)
		p.Match(ASNParserBY_LITERAL)
	}
	{
		p.SetState(919)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(920)
		p.UserDefinedConstraintParameter()
	}
	p.SetState(925)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserCOMMA {
		{
			p.SetState(921)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(922)
			p.UserDefinedConstraintParameter()
		}

		p.SetState(927)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(928)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IGeneralConstraintContext is an interface to support dynamic dispatch.
type IGeneralConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneralConstraintContext differentiates from other interfaces.
	IsGeneralConstraintContext()
}

type GeneralConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralConstraintContext() *GeneralConstraintContext {
	var p = new(GeneralConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_generalConstraint
	return p
}

func (*GeneralConstraintContext) IsGeneralConstraintContext() {}

func NewGeneralConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralConstraintContext {
	var p = new(GeneralConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_generalConstraint

	return p
}

func (s *GeneralConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralConstraintContext) UserDefinedConstraint() IUserDefinedConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserDefinedConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserDefinedConstraintContext)
}

func (s *GeneralConstraintContext) TableConstraint() ITableConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *GeneralConstraintContext) ContentsConstraint() IContentsConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContentsConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContentsConstraintContext)
}

func (s *GeneralConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterGeneralConstraint(s)
	}
}

func (s *GeneralConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitGeneralConstraint(s)
	}
}

func (p *ASNParser) GeneralConstraint() (localctx IGeneralConstraintContext) {
	localctx = NewGeneralConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ASNParserRULE_generalConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(933)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserCONSTRAINED_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(930)
			p.UserDefinedConstraint()
		}

	case ASNParserL_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(931)
			p.TableConstraint()
		}

	case ASNParserCONTAINING_LITERAL, ASNParserWITH_LITERAL, ASNParserENCODED_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(932)
			p.ContentsConstraint()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUserDefinedConstraintParameterContext is an interface to support dynamic dispatch.
type IUserDefinedConstraintParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUserDefinedConstraintParameterContext differentiates from other interfaces.
	IsUserDefinedConstraintParameterContext()
}

type UserDefinedConstraintParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserDefinedConstraintParameterContext() *UserDefinedConstraintParameterContext {
	var p = new(UserDefinedConstraintParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_userDefinedConstraintParameter
	return p
}

func (*UserDefinedConstraintParameterContext) IsUserDefinedConstraintParameterContext() {}

func NewUserDefinedConstraintParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserDefinedConstraintParameterContext {
	var p = new(UserDefinedConstraintParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_userDefinedConstraintParameter

	return p
}

func (s *UserDefinedConstraintParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *UserDefinedConstraintParameterContext) Governor() IGovernorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGovernorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGovernorContext)
}

func (s *UserDefinedConstraintParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASNParserCOLON, 0)
}

func (s *UserDefinedConstraintParameterContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *UserDefinedConstraintParameterContext) ValueSet() IValueSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetContext)
}

func (s *UserDefinedConstraintParameterContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *UserDefinedConstraintParameterContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *UserDefinedConstraintParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserDefinedConstraintParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserDefinedConstraintParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterUserDefinedConstraintParameter(s)
	}
}

func (s *UserDefinedConstraintParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitUserDefinedConstraintParameter(s)
	}
}

func (p *ASNParser) UserDefinedConstraintParameter() (localctx IUserDefinedConstraintParameterContext) {
	localctx = NewUserDefinedConstraintParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ASNParserRULE_userDefinedConstraintParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(935)
		p.Governor()
	}
	p.SetState(941)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(936)
			p.Match(ASNParserCOLON)
		}
		{
			p.SetState(937)
			p.Value()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(938)
			p.ValueSet()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(939)
			p.Object()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(940)
			p.ObjectSet()
		}

	}

	return localctx
}

// ITableConstraintContext is an interface to support dynamic dispatch.
type ITableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableConstraintContext differentiates from other interfaces.
	IsTableConstraintContext()
}

type TableConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintContext() *TableConstraintContext {
	var p = new(TableConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_tableConstraint
	return p
}

func (*TableConstraintContext) IsTableConstraintContext() {}

func NewTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintContext {
	var p = new(TableConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_tableConstraint

	return p
}

func (s *TableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintContext) ComponentRelationConstraint() IComponentRelationConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentRelationConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentRelationConstraintContext)
}

func (s *TableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterTableConstraint(s)
	}
}

func (s *TableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitTableConstraint(s)
	}
}

func (p *ASNParser) TableConstraint() (localctx ITableConstraintContext) {
	localctx = NewTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ASNParserRULE_tableConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(943)
		p.ComponentRelationConstraint()
	}

	return localctx
}

// ISimpleTableConstraintContext is an interface to support dynamic dispatch.
type ISimpleTableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleTableConstraintContext differentiates from other interfaces.
	IsSimpleTableConstraintContext()
}

type SimpleTableConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTableConstraintContext() *SimpleTableConstraintContext {
	var p = new(SimpleTableConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_simpleTableConstraint
	return p
}

func (*SimpleTableConstraintContext) IsSimpleTableConstraintContext() {}

func NewSimpleTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTableConstraintContext {
	var p = new(SimpleTableConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_simpleTableConstraint

	return p
}

func (s *SimpleTableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTableConstraintContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *SimpleTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSimpleTableConstraint(s)
	}
}

func (s *SimpleTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSimpleTableConstraint(s)
	}
}

func (p *ASNParser) SimpleTableConstraint() (localctx ISimpleTableConstraintContext) {
	localctx = NewSimpleTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ASNParserRULE_simpleTableConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(945)
		p.ObjectSet()
	}

	return localctx
}

// IContentsConstraintContext is an interface to support dynamic dispatch.
type IContentsConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContentsConstraintContext differentiates from other interfaces.
	IsContentsConstraintContext()
}

type ContentsConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContentsConstraintContext() *ContentsConstraintContext {
	var p = new(ContentsConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_contentsConstraint
	return p
}

func (*ContentsConstraintContext) IsContentsConstraintContext() {}

func NewContentsConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContentsConstraintContext {
	var p = new(ContentsConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_contentsConstraint

	return p
}

func (s *ContentsConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ContentsConstraintContext) CONTAINING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserCONTAINING_LITERAL, 0)
}

func (s *ContentsConstraintContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ContentsConstraintContext) ENCODED_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserENCODED_LITERAL, 0)
}

func (s *ContentsConstraintContext) BY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserBY_LITERAL, 0)
}

func (s *ContentsConstraintContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ContentsConstraintContext) WITH_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserWITH_LITERAL, 0)
}

func (s *ContentsConstraintContext) COMPONENTS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserCOMPONENTS_LITERAL, 0)
}

func (s *ContentsConstraintContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ContentsConstraintContext) ComponentPresenceLists() IComponentPresenceListsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentPresenceListsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentPresenceListsContext)
}

func (s *ContentsConstraintContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ContentsConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContentsConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContentsConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterContentsConstraint(s)
	}
}

func (s *ContentsConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitContentsConstraint(s)
	}
}

func (p *ASNParser) ContentsConstraint() (localctx IContentsConstraintContext) {
	localctx = NewContentsConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ASNParserRULE_contentsConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(964)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(947)
			p.Match(ASNParserCONTAINING_LITERAL)
		}
		{
			p.SetState(948)
			p.AsnType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(949)
			p.Match(ASNParserENCODED_LITERAL)
		}
		{
			p.SetState(950)
			p.Match(ASNParserBY_LITERAL)
		}
		{
			p.SetState(951)
			p.Value()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(952)
			p.Match(ASNParserCONTAINING_LITERAL)
		}
		{
			p.SetState(953)
			p.AsnType()
		}
		{
			p.SetState(954)
			p.Match(ASNParserENCODED_LITERAL)
		}
		{
			p.SetState(955)
			p.Match(ASNParserBY_LITERAL)
		}
		{
			p.SetState(956)
			p.Value()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(958)
			p.Match(ASNParserWITH_LITERAL)
		}
		{
			p.SetState(959)
			p.Match(ASNParserCOMPONENTS_LITERAL)
		}
		{
			p.SetState(960)
			p.Match(ASNParserL_BRACE)
		}
		{
			p.SetState(961)
			p.ComponentPresenceLists()
		}
		{
			p.SetState(962)
			p.Match(ASNParserR_BRACE)
		}

	}

	return localctx
}

// IComponentPresenceListsContext is an interface to support dynamic dispatch.
type IComponentPresenceListsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentPresenceListsContext differentiates from other interfaces.
	IsComponentPresenceListsContext()
}

type ComponentPresenceListsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentPresenceListsContext() *ComponentPresenceListsContext {
	var p = new(ComponentPresenceListsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_componentPresenceLists
	return p
}

func (*ComponentPresenceListsContext) IsComponentPresenceListsContext() {}

func NewComponentPresenceListsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentPresenceListsContext {
	var p = new(ComponentPresenceListsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_componentPresenceLists

	return p
}

func (s *ComponentPresenceListsContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentPresenceListsContext) AllComponentPresenceList() []IComponentPresenceListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComponentPresenceListContext)(nil)).Elem())
	var tst = make([]IComponentPresenceListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComponentPresenceListContext)
		}
	}

	return tst
}

func (s *ComponentPresenceListsContext) ComponentPresenceList(i int) IComponentPresenceListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentPresenceListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComponentPresenceListContext)
}

func (s *ComponentPresenceListsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ComponentPresenceListsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ComponentPresenceListsContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASNParserELLIPSIS, 0)
}

func (s *ComponentPresenceListsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentPresenceListsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentPresenceListsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterComponentPresenceLists(s)
	}
}

func (s *ComponentPresenceListsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitComponentPresenceLists(s)
	}
}

func (p *ASNParser) ComponentPresenceLists() (localctx IComponentPresenceListsContext) {
	localctx = NewComponentPresenceListsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ASNParserRULE_componentPresenceLists)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(982)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserR_BRACE, ASNParserCOMMA, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(967)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserIDENTIFIER {
			{
				p.SetState(966)
				p.ComponentPresenceList()
			}

		}
		p.SetState(975)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserCOMMA {
			{
				p.SetState(969)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(970)
				p.Match(ASNParserELLIPSIS)
			}
			p.SetState(973)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASNParserCOMMA {
				{
					p.SetState(971)
					p.Match(ASNParserCOMMA)
				}
				{
					p.SetState(972)
					p.ComponentPresenceList()
				}

			}

		}

	case ASNParserELLIPSIS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(977)
			p.Match(ASNParserELLIPSIS)
		}
		p.SetState(980)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserCOMMA {
			{
				p.SetState(978)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(979)
				p.ComponentPresenceList()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IComponentPresenceListContext is an interface to support dynamic dispatch.
type IComponentPresenceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentPresenceListContext differentiates from other interfaces.
	IsComponentPresenceListContext()
}

type ComponentPresenceListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentPresenceListContext() *ComponentPresenceListContext {
	var p = new(ComponentPresenceListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_componentPresenceList
	return p
}

func (*ComponentPresenceListContext) IsComponentPresenceListContext() {}

func NewComponentPresenceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentPresenceListContext {
	var p = new(ComponentPresenceListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_componentPresenceList

	return p
}

func (s *ComponentPresenceListContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentPresenceListContext) AllComponentPresence() []IComponentPresenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComponentPresenceContext)(nil)).Elem())
	var tst = make([]IComponentPresenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComponentPresenceContext)
		}
	}

	return tst
}

func (s *ComponentPresenceListContext) ComponentPresence(i int) IComponentPresenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentPresenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComponentPresenceContext)
}

func (s *ComponentPresenceListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ComponentPresenceListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ComponentPresenceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentPresenceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentPresenceListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterComponentPresenceList(s)
	}
}

func (s *ComponentPresenceListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitComponentPresenceList(s)
	}
}

func (p *ASNParser) ComponentPresenceList() (localctx IComponentPresenceListContext) {
	localctx = NewComponentPresenceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ASNParserRULE_componentPresenceList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(984)
		p.ComponentPresence()
	}

	p.SetState(989)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(985)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(986)
				p.ComponentPresence()
			}

		}
		p.SetState(991)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext())
	}

	return localctx
}

// IComponentPresenceContext is an interface to support dynamic dispatch.
type IComponentPresenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentPresenceContext differentiates from other interfaces.
	IsComponentPresenceContext()
}

type ComponentPresenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentPresenceContext() *ComponentPresenceContext {
	var p = new(ComponentPresenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_componentPresence
	return p
}

func (*ComponentPresenceContext) IsComponentPresenceContext() {}

func NewComponentPresenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentPresenceContext {
	var p = new(ComponentPresenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_componentPresence

	return p
}

func (s *ComponentPresenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentPresenceContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *ComponentPresenceContext) ABSENT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserABSENT_LITERAL, 0)
}

func (s *ComponentPresenceContext) PRESENT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserPRESENT_LITERAL, 0)
}

func (s *ComponentPresenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentPresenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentPresenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterComponentPresence(s)
	}
}

func (s *ComponentPresenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitComponentPresence(s)
	}
}

func (p *ASNParser) ComponentPresence() (localctx IComponentPresenceContext) {
	localctx = NewComponentPresenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ASNParserRULE_componentPresence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(992)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(993)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASNParserPRESENT_LITERAL || _la == ASNParserABSENT_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISubtypeConstraintContext is an interface to support dynamic dispatch.
type ISubtypeConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtypeConstraintContext differentiates from other interfaces.
	IsSubtypeConstraintContext()
}

type SubtypeConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtypeConstraintContext() *SubtypeConstraintContext {
	var p = new(SubtypeConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_subtypeConstraint
	return p
}

func (*SubtypeConstraintContext) IsSubtypeConstraintContext() {}

func NewSubtypeConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtypeConstraintContext {
	var p = new(SubtypeConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_subtypeConstraint

	return p
}

func (s *SubtypeConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtypeConstraintContext) ElementSetSpecs() IElementSetSpecsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementSetSpecsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementSetSpecsContext)
}

func (s *SubtypeConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtypeConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtypeConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSubtypeConstraint(s)
	}
}

func (s *SubtypeConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSubtypeConstraint(s)
	}
}

func (p *ASNParser) SubtypeConstraint() (localctx ISubtypeConstraintContext) {
	localctx = NewSubtypeConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ASNParserRULE_subtypeConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(995)
		p.ElementSetSpecs()
	}

	return localctx
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_value
	return p
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) BuiltinValue() IBuiltinValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBuiltinValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBuiltinValueContext)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterValue(s)
	}
}

func (s *ValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitValue(s)
	}
}

func (p *ASNParser) Value() (localctx IValueContext) {
	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ASNParserRULE_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(997)
		p.BuiltinValue()
	}

	return localctx
}

// IBuiltinValueContext is an interface to support dynamic dispatch.
type IBuiltinValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBuiltinValueContext differentiates from other interfaces.
	IsBuiltinValueContext()
}

type BuiltinValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuiltinValueContext() *BuiltinValueContext {
	var p = new(BuiltinValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_builtinValue
	return p
}

func (*BuiltinValueContext) IsBuiltinValueContext() {}

func NewBuiltinValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuiltinValueContext {
	var p = new(BuiltinValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_builtinValue

	return p
}

func (s *BuiltinValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BuiltinValueContext) EnumeratedValue() IEnumeratedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeratedValueContext)
}

func (s *BuiltinValueContext) IntegerValue() IIntegerValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerValueContext)
}

func (s *BuiltinValueContext) ChoiceValue() IChoiceValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoiceValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChoiceValueContext)
}

func (s *BuiltinValueContext) ObjectIdentifierValue() IObjectIdentifierValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectIdentifierValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectIdentifierValueContext)
}

func (s *BuiltinValueContext) BooleanValue() IBooleanValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BuiltinValueContext) CSTRING() antlr.TerminalNode {
	return s.GetToken(ASNParserCSTRING, 0)
}

func (s *BuiltinValueContext) BSTRING() antlr.TerminalNode {
	return s.GetToken(ASNParserBSTRING, 0)
}

func (s *BuiltinValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuiltinValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuiltinValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterBuiltinValue(s)
	}
}

func (s *BuiltinValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitBuiltinValue(s)
	}
}

func (p *ASNParser) BuiltinValue() (localctx IBuiltinValueContext) {
	localctx = NewBuiltinValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ASNParserRULE_builtinValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1006)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(999)
			p.EnumeratedValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1000)
			p.IntegerValue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1001)
			p.ChoiceValue()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1002)
			p.ObjectIdentifierValue()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1003)
			p.BooleanValue()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1004)
			p.Match(ASNParserCSTRING)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1005)
			p.Match(ASNParserBSTRING)
		}

	}

	return localctx
}

// IObjectIdentifierValueContext is an interface to support dynamic dispatch.
type IObjectIdentifierValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectIdentifierValueContext differentiates from other interfaces.
	IsObjectIdentifierValueContext()
}

type ObjectIdentifierValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectIdentifierValueContext() *ObjectIdentifierValueContext {
	var p = new(ObjectIdentifierValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectIdentifierValue
	return p
}

func (*ObjectIdentifierValueContext) IsObjectIdentifierValueContext() {}

func NewObjectIdentifierValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectIdentifierValueContext {
	var p = new(ObjectIdentifierValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectIdentifierValue

	return p
}

func (s *ObjectIdentifierValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectIdentifierValueContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ObjectIdentifierValueContext) ObjIdComponentsList() IObjIdComponentsListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjIdComponentsListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjIdComponentsListContext)
}

func (s *ObjectIdentifierValueContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ObjectIdentifierValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectIdentifierValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectIdentifierValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectIdentifierValue(s)
	}
}

func (s *ObjectIdentifierValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectIdentifierValue(s)
	}
}

func (p *ASNParser) ObjectIdentifierValue() (localctx IObjectIdentifierValueContext) {
	localctx = NewObjectIdentifierValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ASNParserRULE_objectIdentifierValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1008)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(1009)
		p.ObjIdComponentsList()
	}
	{
		p.SetState(1010)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IObjIdComponentsListContext is an interface to support dynamic dispatch.
type IObjIdComponentsListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjIdComponentsListContext differentiates from other interfaces.
	IsObjIdComponentsListContext()
}

type ObjIdComponentsListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjIdComponentsListContext() *ObjIdComponentsListContext {
	var p = new(ObjIdComponentsListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objIdComponentsList
	return p
}

func (*ObjIdComponentsListContext) IsObjIdComponentsListContext() {}

func NewObjIdComponentsListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjIdComponentsListContext {
	var p = new(ObjIdComponentsListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objIdComponentsList

	return p
}

func (s *ObjIdComponentsListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjIdComponentsListContext) AllObjIdComponents() []IObjIdComponentsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IObjIdComponentsContext)(nil)).Elem())
	var tst = make([]IObjIdComponentsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IObjIdComponentsContext)
		}
	}

	return tst
}

func (s *ObjIdComponentsListContext) ObjIdComponents(i int) IObjIdComponentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjIdComponentsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IObjIdComponentsContext)
}

func (s *ObjIdComponentsListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjIdComponentsListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjIdComponentsListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjIdComponentsList(s)
	}
}

func (s *ObjIdComponentsListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjIdComponentsList(s)
	}
}

func (p *ASNParser) ObjIdComponentsList() (localctx IObjIdComponentsListContext) {
	localctx = NewObjIdComponentsListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ASNParserRULE_objIdComponentsList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1012)
		p.ObjIdComponents()
	}

	p.SetState(1016)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserNUMBER || _la == ASNParserIDENTIFIER {
		{
			p.SetState(1013)
			p.ObjIdComponents()
		}

		p.SetState(1018)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObjIdComponentsContext is an interface to support dynamic dispatch.
type IObjIdComponentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjIdComponentsContext differentiates from other interfaces.
	IsObjIdComponentsContext()
}

type ObjIdComponentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjIdComponentsContext() *ObjIdComponentsContext {
	var p = new(ObjIdComponentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objIdComponents
	return p
}

func (*ObjIdComponentsContext) IsObjIdComponentsContext() {}

func NewObjIdComponentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjIdComponentsContext {
	var p = new(ObjIdComponentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objIdComponents

	return p
}

func (s *ObjIdComponentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjIdComponentsContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(ASNParserNUMBER, 0)
}

func (s *ObjIdComponentsContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *ObjIdComponentsContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserL_PARAN, 0)
}

func (s *ObjIdComponentsContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserR_PARAN, 0)
}

func (s *ObjIdComponentsContext) DefinedValue() IDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedValueContext)
}

func (s *ObjIdComponentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjIdComponentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjIdComponentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjIdComponents(s)
	}
}

func (s *ObjIdComponentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjIdComponents(s)
	}
}

func (p *ASNParser) ObjIdComponents() (localctx IObjIdComponentsContext) {
	localctx = NewObjIdComponentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, ASNParserRULE_objIdComponents)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1030)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1019)
			p.Match(ASNParserNUMBER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1020)
			p.Match(ASNParserIDENTIFIER)
		}
		p.SetState(1027)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserL_PARAN {
			{
				p.SetState(1021)
				p.Match(ASNParserL_PARAN)
			}
			p.SetState(1024)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ASNParserNUMBER:
				{
					p.SetState(1022)
					p.Match(ASNParserNUMBER)
				}

			case ASNParserIDENTIFIER:
				{
					p.SetState(1023)
					p.DefinedValue()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			{
				p.SetState(1026)
				p.Match(ASNParserR_PARAN)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1029)
			p.DefinedValue()
		}

	}

	return localctx
}

// IIntegerValueContext is an interface to support dynamic dispatch.
type IIntegerValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerValueContext differentiates from other interfaces.
	IsIntegerValueContext()
}

type IntegerValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerValueContext() *IntegerValueContext {
	var p = new(IntegerValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_integerValue
	return p
}

func (*IntegerValueContext) IsIntegerValueContext() {}

func NewIntegerValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerValueContext {
	var p = new(IntegerValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_integerValue

	return p
}

func (s *IntegerValueContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerValueContext) SignedNumber() ISignedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignedNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignedNumberContext)
}

func (s *IntegerValueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *IntegerValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterIntegerValue(s)
	}
}

func (s *IntegerValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitIntegerValue(s)
	}
}

func (p *ASNParser) IntegerValue() (localctx IIntegerValueContext) {
	localctx = NewIntegerValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, ASNParserRULE_integerValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1034)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserMINUS, ASNParserNUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1032)
			p.SignedNumber()
		}

	case ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1033)
			p.Match(ASNParserIDENTIFIER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IChoiceValueContext is an interface to support dynamic dispatch.
type IChoiceValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoiceValueContext differentiates from other interfaces.
	IsChoiceValueContext()
}

type ChoiceValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoiceValueContext() *ChoiceValueContext {
	var p = new(ChoiceValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_choiceValue
	return p
}

func (*ChoiceValueContext) IsChoiceValueContext() {}

func NewChoiceValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChoiceValueContext {
	var p = new(ChoiceValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_choiceValue

	return p
}

func (s *ChoiceValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ChoiceValueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *ChoiceValueContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASNParserCOLON, 0)
}

func (s *ChoiceValueContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ChoiceValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChoiceValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChoiceValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterChoiceValue(s)
	}
}

func (s *ChoiceValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitChoiceValue(s)
	}
}

func (p *ASNParser) ChoiceValue() (localctx IChoiceValueContext) {
	localctx = NewChoiceValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, ASNParserRULE_choiceValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1036)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(1037)
		p.Match(ASNParserCOLON)
	}
	{
		p.SetState(1038)
		p.Value()
	}

	return localctx
}

// IEnumeratedValueContext is an interface to support dynamic dispatch.
type IEnumeratedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratedValueContext differentiates from other interfaces.
	IsEnumeratedValueContext()
}

type EnumeratedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratedValueContext() *EnumeratedValueContext {
	var p = new(EnumeratedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_enumeratedValue
	return p
}

func (*EnumeratedValueContext) IsEnumeratedValueContext() {}

func NewEnumeratedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratedValueContext {
	var p = new(EnumeratedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_enumeratedValue

	return p
}

func (s *EnumeratedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratedValueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *EnumeratedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterEnumeratedValue(s)
	}
}

func (s *EnumeratedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitEnumeratedValue(s)
	}
}

func (p *ASNParser) EnumeratedValue() (localctx IEnumeratedValueContext) {
	localctx = NewEnumeratedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, ASNParserRULE_enumeratedValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1040)
		p.Match(ASNParserIDENTIFIER)
	}

	return localctx
}

// ISignedNumberContext is an interface to support dynamic dispatch.
type ISignedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignedNumberContext differentiates from other interfaces.
	IsSignedNumberContext()
}

type SignedNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedNumberContext() *SignedNumberContext {
	var p = new(SignedNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_signedNumber
	return p
}

func (*SignedNumberContext) IsSignedNumberContext() {}

func NewSignedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedNumberContext {
	var p = new(SignedNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_signedNumber

	return p
}

func (s *SignedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedNumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(ASNParserNUMBER, 0)
}

func (s *SignedNumberContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ASNParserMINUS, 0)
}

func (s *SignedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignedNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSignedNumber(s)
	}
}

func (s *SignedNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSignedNumber(s)
	}
}

func (p *ASNParser) SignedNumber() (localctx ISignedNumberContext) {
	localctx = NewSignedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, ASNParserRULE_signedNumber)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserMINUS {
		{
			p.SetState(1042)
			p.Match(ASNParserMINUS)
		}

	}
	{
		p.SetState(1045)
		p.Match(ASNParserNUMBER)
	}

	return localctx
}

// IChoiceTypeContext is an interface to support dynamic dispatch.
type IChoiceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoiceTypeContext differentiates from other interfaces.
	IsChoiceTypeContext()
}

type ChoiceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoiceTypeContext() *ChoiceTypeContext {
	var p = new(ChoiceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_choiceType
	return p
}

func (*ChoiceTypeContext) IsChoiceTypeContext() {}

func NewChoiceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChoiceTypeContext {
	var p = new(ChoiceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_choiceType

	return p
}

func (s *ChoiceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ChoiceTypeContext) CHOICE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserCHOICE_LITERAL, 0)
}

func (s *ChoiceTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ChoiceTypeContext) AlternativeTypeLists() IAlternativeTypeListsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternativeTypeListsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternativeTypeListsContext)
}

func (s *ChoiceTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ChoiceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChoiceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChoiceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterChoiceType(s)
	}
}

func (s *ChoiceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitChoiceType(s)
	}
}

func (p *ASNParser) ChoiceType() (localctx IChoiceTypeContext) {
	localctx = NewChoiceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, ASNParserRULE_choiceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1047)
		p.Match(ASNParserCHOICE_LITERAL)
	}
	{
		p.SetState(1048)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(1049)
		p.AlternativeTypeLists()
	}
	{
		p.SetState(1050)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IAlternativeTypeListsContext is an interface to support dynamic dispatch.
type IAlternativeTypeListsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlternativeTypeListsContext differentiates from other interfaces.
	IsAlternativeTypeListsContext()
}

type AlternativeTypeListsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlternativeTypeListsContext() *AlternativeTypeListsContext {
	var p = new(AlternativeTypeListsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_alternativeTypeLists
	return p
}

func (*AlternativeTypeListsContext) IsAlternativeTypeListsContext() {}

func NewAlternativeTypeListsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlternativeTypeListsContext {
	var p = new(AlternativeTypeListsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_alternativeTypeLists

	return p
}

func (s *AlternativeTypeListsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlternativeTypeListsContext) RootAlternativeTypeList() IRootAlternativeTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootAlternativeTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRootAlternativeTypeListContext)
}

func (s *AlternativeTypeListsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, 0)
}

func (s *AlternativeTypeListsContext) ExtensionAndException() IExtensionAndExceptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAndExceptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAndExceptionContext)
}

func (s *AlternativeTypeListsContext) ExtensionAdditionAlternatives() IExtensionAdditionAlternativesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionAlternativesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionAlternativesContext)
}

func (s *AlternativeTypeListsContext) OptionalExtensionMarker() IOptionalExtensionMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalExtensionMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalExtensionMarkerContext)
}

func (s *AlternativeTypeListsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlternativeTypeListsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlternativeTypeListsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAlternativeTypeLists(s)
	}
}

func (s *AlternativeTypeListsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAlternativeTypeLists(s)
	}
}

func (p *ASNParser) AlternativeTypeLists() (localctx IAlternativeTypeListsContext) {
	localctx = NewAlternativeTypeListsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, ASNParserRULE_alternativeTypeLists)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1052)
		p.RootAlternativeTypeList()
	}
	p.SetState(1058)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserCOMMA {
		{
			p.SetState(1053)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(1054)
			p.ExtensionAndException()
		}
		{
			p.SetState(1055)
			p.ExtensionAdditionAlternatives()
		}
		{
			p.SetState(1056)
			p.OptionalExtensionMarker()
		}

	}

	return localctx
}

// IExtensionAdditionAlternativesContext is an interface to support dynamic dispatch.
type IExtensionAdditionAlternativesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionAlternativesContext differentiates from other interfaces.
	IsExtensionAdditionAlternativesContext()
}

type ExtensionAdditionAlternativesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionAlternativesContext() *ExtensionAdditionAlternativesContext {
	var p = new(ExtensionAdditionAlternativesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternatives
	return p
}

func (*ExtensionAdditionAlternativesContext) IsExtensionAdditionAlternativesContext() {}

func NewExtensionAdditionAlternativesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionAlternativesContext {
	var p = new(ExtensionAdditionAlternativesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternatives

	return p
}

func (s *ExtensionAdditionAlternativesContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionAlternativesContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, 0)
}

func (s *ExtensionAdditionAlternativesContext) ExtensionAdditionAlternativesList() IExtensionAdditionAlternativesListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionAlternativesListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionAlternativesListContext)
}

func (s *ExtensionAdditionAlternativesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionAlternativesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionAlternativesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAdditionAlternatives(s)
	}
}

func (s *ExtensionAdditionAlternativesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAdditionAlternatives(s)
	}
}

func (p *ASNParser) ExtensionAdditionAlternatives() (localctx IExtensionAdditionAlternativesContext) {
	localctx = NewExtensionAdditionAlternativesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, ASNParserRULE_extensionAdditionAlternatives)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1062)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1060)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(1061)
			p.ExtensionAdditionAlternativesList()
		}

	}

	return localctx
}

// IExtensionAdditionAlternativesListContext is an interface to support dynamic dispatch.
type IExtensionAdditionAlternativesListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionAlternativesListContext differentiates from other interfaces.
	IsExtensionAdditionAlternativesListContext()
}

type ExtensionAdditionAlternativesListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionAlternativesListContext() *ExtensionAdditionAlternativesListContext {
	var p = new(ExtensionAdditionAlternativesListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternativesList
	return p
}

func (*ExtensionAdditionAlternativesListContext) IsExtensionAdditionAlternativesListContext() {}

func NewExtensionAdditionAlternativesListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionAlternativesListContext {
	var p = new(ExtensionAdditionAlternativesListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternativesList

	return p
}

func (s *ExtensionAdditionAlternativesListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionAlternativesListContext) AllExtensionAdditionAlternative() []IExtensionAdditionAlternativeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExtensionAdditionAlternativeContext)(nil)).Elem())
	var tst = make([]IExtensionAdditionAlternativeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExtensionAdditionAlternativeContext)
		}
	}

	return tst
}

func (s *ExtensionAdditionAlternativesListContext) ExtensionAdditionAlternative(i int) IExtensionAdditionAlternativeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionAlternativeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionAlternativeContext)
}

func (s *ExtensionAdditionAlternativesListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ExtensionAdditionAlternativesListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ExtensionAdditionAlternativesListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionAlternativesListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionAlternativesListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAdditionAlternativesList(s)
	}
}

func (s *ExtensionAdditionAlternativesListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAdditionAlternativesList(s)
	}
}

func (p *ASNParser) ExtensionAdditionAlternativesList() (localctx IExtensionAdditionAlternativesListContext) {
	localctx = NewExtensionAdditionAlternativesListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, ASNParserRULE_extensionAdditionAlternativesList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1064)
		p.ExtensionAdditionAlternative()
	}

	p.SetState(1069)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1065)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(1066)
				p.ExtensionAdditionAlternative()
			}

		}
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext())
	}

	return localctx
}

// IExtensionAdditionAlternativeContext is an interface to support dynamic dispatch.
type IExtensionAdditionAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionAlternativeContext differentiates from other interfaces.
	IsExtensionAdditionAlternativeContext()
}

type ExtensionAdditionAlternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionAlternativeContext() *ExtensionAdditionAlternativeContext {
	var p = new(ExtensionAdditionAlternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternative
	return p
}

func (*ExtensionAdditionAlternativeContext) IsExtensionAdditionAlternativeContext() {}

func NewExtensionAdditionAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionAlternativeContext {
	var p = new(ExtensionAdditionAlternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternative

	return p
}

func (s *ExtensionAdditionAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionAlternativeContext) ExtensionAdditionAlternativesGroup() IExtensionAdditionAlternativesGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionAlternativesGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionAlternativesGroupContext)
}

func (s *ExtensionAdditionAlternativeContext) NamedType() INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *ExtensionAdditionAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAdditionAlternative(s)
	}
}

func (s *ExtensionAdditionAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAdditionAlternative(s)
	}
}

func (p *ASNParser) ExtensionAdditionAlternative() (localctx IExtensionAdditionAlternativeContext) {
	localctx = NewExtensionAdditionAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, ASNParserRULE_extensionAdditionAlternative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1074)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserDOUBLE_L_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1072)
			p.ExtensionAdditionAlternativesGroup()
		}

	case ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1073)
			p.NamedType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtensionAdditionAlternativesGroupContext is an interface to support dynamic dispatch.
type IExtensionAdditionAlternativesGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionAlternativesGroupContext differentiates from other interfaces.
	IsExtensionAdditionAlternativesGroupContext()
}

type ExtensionAdditionAlternativesGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionAlternativesGroupContext() *ExtensionAdditionAlternativesGroupContext {
	var p = new(ExtensionAdditionAlternativesGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternativesGroup
	return p
}

func (*ExtensionAdditionAlternativesGroupContext) IsExtensionAdditionAlternativesGroupContext() {}

func NewExtensionAdditionAlternativesGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionAlternativesGroupContext {
	var p = new(ExtensionAdditionAlternativesGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternativesGroup

	return p
}

func (s *ExtensionAdditionAlternativesGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionAlternativesGroupContext) DOUBLE_L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASNParserDOUBLE_L_BRACKET, 0)
}

func (s *ExtensionAdditionAlternativesGroupContext) VersionNumber() IVersionNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVersionNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVersionNumberContext)
}

func (s *ExtensionAdditionAlternativesGroupContext) AlternativeTypeList() IAlternativeTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternativeTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternativeTypeListContext)
}

func (s *ExtensionAdditionAlternativesGroupContext) DOUBLE_R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASNParserDOUBLE_R_BRACKET, 0)
}

func (s *ExtensionAdditionAlternativesGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionAlternativesGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionAlternativesGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAdditionAlternativesGroup(s)
	}
}

func (s *ExtensionAdditionAlternativesGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAdditionAlternativesGroup(s)
	}
}

func (p *ASNParser) ExtensionAdditionAlternativesGroup() (localctx IExtensionAdditionAlternativesGroupContext) {
	localctx = NewExtensionAdditionAlternativesGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, ASNParserRULE_extensionAdditionAlternativesGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1076)
		p.Match(ASNParserDOUBLE_L_BRACKET)
	}
	{
		p.SetState(1077)
		p.VersionNumber()
	}
	{
		p.SetState(1078)
		p.AlternativeTypeList()
	}
	{
		p.SetState(1079)
		p.Match(ASNParserDOUBLE_R_BRACKET)
	}

	return localctx
}

// IRootAlternativeTypeListContext is an interface to support dynamic dispatch.
type IRootAlternativeTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootAlternativeTypeListContext differentiates from other interfaces.
	IsRootAlternativeTypeListContext()
}

type RootAlternativeTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootAlternativeTypeListContext() *RootAlternativeTypeListContext {
	var p = new(RootAlternativeTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_rootAlternativeTypeList
	return p
}

func (*RootAlternativeTypeListContext) IsRootAlternativeTypeListContext() {}

func NewRootAlternativeTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootAlternativeTypeListContext {
	var p = new(RootAlternativeTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_rootAlternativeTypeList

	return p
}

func (s *RootAlternativeTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *RootAlternativeTypeListContext) AlternativeTypeList() IAlternativeTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternativeTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternativeTypeListContext)
}

func (s *RootAlternativeTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootAlternativeTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootAlternativeTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterRootAlternativeTypeList(s)
	}
}

func (s *RootAlternativeTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitRootAlternativeTypeList(s)
	}
}

func (p *ASNParser) RootAlternativeTypeList() (localctx IRootAlternativeTypeListContext) {
	localctx = NewRootAlternativeTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, ASNParserRULE_rootAlternativeTypeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1081)
		p.AlternativeTypeList()
	}

	return localctx
}

// IAlternativeTypeListContext is an interface to support dynamic dispatch.
type IAlternativeTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlternativeTypeListContext differentiates from other interfaces.
	IsAlternativeTypeListContext()
}

type AlternativeTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlternativeTypeListContext() *AlternativeTypeListContext {
	var p = new(AlternativeTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_alternativeTypeList
	return p
}

func (*AlternativeTypeListContext) IsAlternativeTypeListContext() {}

func NewAlternativeTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlternativeTypeListContext {
	var p = new(AlternativeTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_alternativeTypeList

	return p
}

func (s *AlternativeTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *AlternativeTypeListContext) AllNamedType() []INamedTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedTypeContext)(nil)).Elem())
	var tst = make([]INamedTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedTypeContext)
		}
	}

	return tst
}

func (s *AlternativeTypeListContext) NamedType(i int) INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *AlternativeTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *AlternativeTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *AlternativeTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlternativeTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlternativeTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAlternativeTypeList(s)
	}
}

func (s *AlternativeTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAlternativeTypeList(s)
	}
}

func (p *ASNParser) AlternativeTypeList() (localctx IAlternativeTypeListContext) {
	localctx = NewAlternativeTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, ASNParserRULE_alternativeTypeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1083)
		p.NamedType()
	}

	p.SetState(1088)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1084)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(1085)
				p.NamedType()
			}

		}
		p.SetState(1090)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext())
	}

	return localctx
}

// INamedTypeContext is an interface to support dynamic dispatch.
type INamedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedTypeContext differentiates from other interfaces.
	IsNamedTypeContext()
}

type NamedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedTypeContext() *NamedTypeContext {
	var p = new(NamedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_namedType
	return p
}

func (*NamedTypeContext) IsNamedTypeContext() {}

func NewNamedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedTypeContext {
	var p = new(NamedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_namedType

	return p
}

func (s *NamedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedTypeContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *NamedTypeContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *NamedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterNamedType(s)
	}
}

func (s *NamedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitNamedType(s)
	}
}

func (p *ASNParser) NamedType() (localctx INamedTypeContext) {
	localctx = NewNamedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, ASNParserRULE_namedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1091)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(1092)
		p.AsnType()
	}

	return localctx
}

// IEnumeratedTypeContext is an interface to support dynamic dispatch.
type IEnumeratedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratedTypeContext differentiates from other interfaces.
	IsEnumeratedTypeContext()
}

type EnumeratedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratedTypeContext() *EnumeratedTypeContext {
	var p = new(EnumeratedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_enumeratedType
	return p
}

func (*EnumeratedTypeContext) IsEnumeratedTypeContext() {}

func NewEnumeratedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratedTypeContext {
	var p = new(EnumeratedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_enumeratedType

	return p
}

func (s *EnumeratedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratedTypeContext) ENUMERATED_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserENUMERATED_LITERAL, 0)
}

func (s *EnumeratedTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *EnumeratedTypeContext) Enumerations() IEnumerationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerationsContext)
}

func (s *EnumeratedTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *EnumeratedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterEnumeratedType(s)
	}
}

func (s *EnumeratedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitEnumeratedType(s)
	}
}

func (p *ASNParser) EnumeratedType() (localctx IEnumeratedTypeContext) {
	localctx = NewEnumeratedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, ASNParserRULE_enumeratedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1094)
		p.Match(ASNParserENUMERATED_LITERAL)
	}
	{
		p.SetState(1095)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(1096)
		p.Enumerations()
	}
	{
		p.SetState(1097)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IEnumerationsContext is an interface to support dynamic dispatch.
type IEnumerationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerationsContext differentiates from other interfaces.
	IsEnumerationsContext()
}

type EnumerationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerationsContext() *EnumerationsContext {
	var p = new(EnumerationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_enumerations
	return p
}

func (*EnumerationsContext) IsEnumerationsContext() {}

func NewEnumerationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumerationsContext {
	var p = new(EnumerationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_enumerations

	return p
}

func (s *EnumerationsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumerationsContext) RootEnumeration() IRootEnumerationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootEnumerationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRootEnumerationContext)
}

func (s *EnumerationsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *EnumerationsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *EnumerationsContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASNParserELLIPSIS, 0)
}

func (s *EnumerationsContext) ExceptionSpec() IExceptionSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExceptionSpecContext)
}

func (s *EnumerationsContext) AdditionalEnumeration() IAdditionalEnumerationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditionalEnumerationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditionalEnumerationContext)
}

func (s *EnumerationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumerationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumerationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterEnumerations(s)
	}
}

func (s *EnumerationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitEnumerations(s)
	}
}

func (p *ASNParser) Enumerations() (localctx IEnumerationsContext) {
	localctx = NewEnumerationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, ASNParserRULE_enumerations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1099)
		p.RootEnumeration()
	}
	p.SetState(1109)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserCOMMA {
		{
			p.SetState(1100)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(1101)
			p.Match(ASNParserELLIPSIS)
		}
		p.SetState(1103)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserEXCLAM {
			{
				p.SetState(1102)
				p.ExceptionSpec()
			}

		}
		p.SetState(1107)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserCOMMA {
			{
				p.SetState(1105)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(1106)
				p.AdditionalEnumeration()
			}

		}

	}

	return localctx
}

// IRootEnumerationContext is an interface to support dynamic dispatch.
type IRootEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootEnumerationContext differentiates from other interfaces.
	IsRootEnumerationContext()
}

type RootEnumerationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootEnumerationContext() *RootEnumerationContext {
	var p = new(RootEnumerationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_rootEnumeration
	return p
}

func (*RootEnumerationContext) IsRootEnumerationContext() {}

func NewRootEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootEnumerationContext {
	var p = new(RootEnumerationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_rootEnumeration

	return p
}

func (s *RootEnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *RootEnumerationContext) Enumeration() IEnumerationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerationContext)
}

func (s *RootEnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootEnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootEnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterRootEnumeration(s)
	}
}

func (s *RootEnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitRootEnumeration(s)
	}
}

func (p *ASNParser) RootEnumeration() (localctx IRootEnumerationContext) {
	localctx = NewRootEnumerationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, ASNParserRULE_rootEnumeration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1111)
		p.Enumeration()
	}

	return localctx
}

// IEnumerationContext is an interface to support dynamic dispatch.
type IEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerationContext differentiates from other interfaces.
	IsEnumerationContext()
}

type EnumerationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerationContext() *EnumerationContext {
	var p = new(EnumerationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_enumeration
	return p
}

func (*EnumerationContext) IsEnumerationContext() {}

func NewEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumerationContext {
	var p = new(EnumerationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_enumeration

	return p
}

func (s *EnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumerationContext) AllEnumerationItem() []IEnumerationItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumerationItemContext)(nil)).Elem())
	var tst = make([]IEnumerationItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumerationItemContext)
		}
	}

	return tst
}

func (s *EnumerationContext) EnumerationItem(i int) IEnumerationItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumerationItemContext)
}

func (s *EnumerationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *EnumerationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *EnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterEnumeration(s)
	}
}

func (s *EnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitEnumeration(s)
	}
}

func (p *ASNParser) Enumeration() (localctx IEnumerationContext) {
	localctx = NewEnumerationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, ASNParserRULE_enumeration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1113)
		p.EnumerationItem()
	}
	p.SetState(1118)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1114)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(1115)
				p.EnumerationItem()
			}

		}
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())
	}

	return localctx
}

// IEnumerationItemContext is an interface to support dynamic dispatch.
type IEnumerationItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerationItemContext differentiates from other interfaces.
	IsEnumerationItemContext()
}

type EnumerationItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerationItemContext() *EnumerationItemContext {
	var p = new(EnumerationItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_enumerationItem
	return p
}

func (*EnumerationItemContext) IsEnumerationItemContext() {}

func NewEnumerationItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumerationItemContext {
	var p = new(EnumerationItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_enumerationItem

	return p
}

func (s *EnumerationItemContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumerationItemContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *EnumerationItemContext) NamedNumber() INamedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedNumberContext)
}

func (s *EnumerationItemContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *EnumerationItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumerationItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumerationItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterEnumerationItem(s)
	}
}

func (s *EnumerationItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitEnumerationItem(s)
	}
}

func (p *ASNParser) EnumerationItem() (localctx IEnumerationItemContext) {
	localctx = NewEnumerationItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, ASNParserRULE_enumerationItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1124)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1121)
			p.Match(ASNParserIDENTIFIER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1122)
			p.NamedNumber()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1123)
			p.Value()
		}

	}

	return localctx
}

// INamedNumberContext is an interface to support dynamic dispatch.
type INamedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedNumberContext differentiates from other interfaces.
	IsNamedNumberContext()
}

type NamedNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedNumberContext() *NamedNumberContext {
	var p = new(NamedNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_namedNumber
	return p
}

func (*NamedNumberContext) IsNamedNumberContext() {}

func NewNamedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedNumberContext {
	var p = new(NamedNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_namedNumber

	return p
}

func (s *NamedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedNumberContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *NamedNumberContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserL_PARAN, 0)
}

func (s *NamedNumberContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserR_PARAN, 0)
}

func (s *NamedNumberContext) SignedNumber() ISignedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignedNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignedNumberContext)
}

func (s *NamedNumberContext) DefinedValue() IDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedValueContext)
}

func (s *NamedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterNamedNumber(s)
	}
}

func (s *NamedNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitNamedNumber(s)
	}
}

func (p *ASNParser) NamedNumber() (localctx INamedNumberContext) {
	localctx = NewNamedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, ASNParserRULE_namedNumber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1126)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(1127)
		p.Match(ASNParserL_PARAN)
	}
	p.SetState(1130)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserMINUS, ASNParserNUMBER:
		{
			p.SetState(1128)
			p.SignedNumber()
		}

	case ASNParserIDENTIFIER:
		{
			p.SetState(1129)
			p.DefinedValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1132)
		p.Match(ASNParserR_PARAN)
	}

	return localctx
}

// IDefinedValueContext is an interface to support dynamic dispatch.
type IDefinedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinedValueContext differentiates from other interfaces.
	IsDefinedValueContext()
}

type DefinedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinedValueContext() *DefinedValueContext {
	var p = new(DefinedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_definedValue
	return p
}

func (*DefinedValueContext) IsDefinedValueContext() {}

func NewDefinedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinedValueContext {
	var p = new(DefinedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_definedValue

	return p
}

func (s *DefinedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinedValueContext) ParameterizedValue() IParameterizedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterizedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterizedValueContext)
}

func (s *DefinedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterDefinedValue(s)
	}
}

func (s *DefinedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitDefinedValue(s)
	}
}

func (p *ASNParser) DefinedValue() (localctx IDefinedValueContext) {
	localctx = NewDefinedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, ASNParserRULE_definedValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1134)
		p.ParameterizedValue()
	}

	return localctx
}

// IParameterizedValueContext is an interface to support dynamic dispatch.
type IParameterizedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterizedValueContext differentiates from other interfaces.
	IsParameterizedValueContext()
}

type ParameterizedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterizedValueContext() *ParameterizedValueContext {
	var p = new(ParameterizedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_parameterizedValue
	return p
}

func (*ParameterizedValueContext) IsParameterizedValueContext() {}

func NewParameterizedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterizedValueContext {
	var p = new(ParameterizedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_parameterizedValue

	return p
}

func (s *ParameterizedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterizedValueContext) SimpleDefinedValue() ISimpleDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleDefinedValueContext)
}

func (s *ParameterizedValueContext) ActualParameterList() IActualParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActualParameterListContext)
}

func (s *ParameterizedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterizedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterizedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterParameterizedValue(s)
	}
}

func (s *ParameterizedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitParameterizedValue(s)
	}
}

func (p *ASNParser) ParameterizedValue() (localctx IParameterizedValueContext) {
	localctx = NewParameterizedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, ASNParserRULE_parameterizedValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1136)
		p.SimpleDefinedValue()
	}
	p.SetState(1138)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserL_BRACE {
		{
			p.SetState(1137)
			p.ActualParameterList()
		}

	}

	return localctx
}

// ISimpleDefinedValueContext is an interface to support dynamic dispatch.
type ISimpleDefinedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleDefinedValueContext differentiates from other interfaces.
	IsSimpleDefinedValueContext()
}

type SimpleDefinedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleDefinedValueContext() *SimpleDefinedValueContext {
	var p = new(SimpleDefinedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_simpleDefinedValue
	return p
}

func (*SimpleDefinedValueContext) IsSimpleDefinedValueContext() {}

func NewSimpleDefinedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleDefinedValueContext {
	var p = new(SimpleDefinedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_simpleDefinedValue

	return p
}

func (s *SimpleDefinedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleDefinedValueContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *SimpleDefinedValueContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *SimpleDefinedValueContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *SimpleDefinedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDefinedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleDefinedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSimpleDefinedValue(s)
	}
}

func (s *SimpleDefinedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSimpleDefinedValue(s)
	}
}

func (p *ASNParser) SimpleDefinedValue() (localctx ISimpleDefinedValueContext) {
	localctx = NewSimpleDefinedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, ASNParserRULE_simpleDefinedValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1140)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(1143)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserDOT {
		{
			p.SetState(1141)
			p.Match(ASNParserDOT)
		}
		{
			p.SetState(1142)
			p.Match(ASNParserIDENTIFIER)
		}

	}

	return localctx
}

// IActualParameterListContext is an interface to support dynamic dispatch.
type IActualParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActualParameterListContext differentiates from other interfaces.
	IsActualParameterListContext()
}

type ActualParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualParameterListContext() *ActualParameterListContext {
	var p = new(ActualParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_actualParameterList
	return p
}

func (*ActualParameterListContext) IsActualParameterListContext() {}

func NewActualParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualParameterListContext {
	var p = new(ActualParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_actualParameterList

	return p
}

func (s *ActualParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualParameterListContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ActualParameterListContext) AllActualParameter() []IActualParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IActualParameterContext)(nil)).Elem())
	var tst = make([]IActualParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IActualParameterContext)
		}
	}

	return tst
}

func (s *ActualParameterListContext) ActualParameter(i int) IActualParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IActualParameterContext)
}

func (s *ActualParameterListContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ActualParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ActualParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ActualParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterActualParameterList(s)
	}
}

func (s *ActualParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitActualParameterList(s)
	}
}

func (p *ASNParser) ActualParameterList() (localctx IActualParameterListContext) {
	localctx = NewActualParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, ASNParserRULE_actualParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1145)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(1146)
		p.ActualParameter()
	}
	p.SetState(1151)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserCOMMA {
		{
			p.SetState(1147)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(1148)
			p.ActualParameter()
		}

		p.SetState(1153)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1154)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IActualParameterContext is an interface to support dynamic dispatch.
type IActualParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActualParameterContext differentiates from other interfaces.
	IsActualParameterContext()
}

type ActualParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualParameterContext() *ActualParameterContext {
	var p = new(ActualParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_actualParameter
	return p
}

func (*ActualParameterContext) IsActualParameterContext() {}

func NewActualParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualParameterContext {
	var p = new(ActualParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_actualParameter

	return p
}

func (s *ActualParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualParameterContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ActualParameterContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ActualParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterActualParameter(s)
	}
}

func (s *ActualParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitActualParameter(s)
	}
}

func (p *ASNParser) ActualParameter() (localctx IActualParameterContext) {
	localctx = NewActualParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, ASNParserRULE_actualParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1158)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1156)
			p.AsnType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1157)
			p.Value()
		}

	}

	return localctx
}

// IExceptionSpecContext is an interface to support dynamic dispatch.
type IExceptionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExceptionSpecContext differentiates from other interfaces.
	IsExceptionSpecContext()
}

type ExceptionSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionSpecContext() *ExceptionSpecContext {
	var p = new(ExceptionSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_exceptionSpec
	return p
}

func (*ExceptionSpecContext) IsExceptionSpecContext() {}

func NewExceptionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionSpecContext {
	var p = new(ExceptionSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_exceptionSpec

	return p
}

func (s *ExceptionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionSpecContext) EXCLAM() antlr.TerminalNode {
	return s.GetToken(ASNParserEXCLAM, 0)
}

func (s *ExceptionSpecContext) ExceptionIdentification() IExceptionIdentificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionIdentificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExceptionIdentificationContext)
}

func (s *ExceptionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExceptionSpec(s)
	}
}

func (s *ExceptionSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExceptionSpec(s)
	}
}

func (p *ASNParser) ExceptionSpec() (localctx IExceptionSpecContext) {
	localctx = NewExceptionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, ASNParserRULE_exceptionSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1160)
		p.Match(ASNParserEXCLAM)
	}
	{
		p.SetState(1161)
		p.ExceptionIdentification()
	}

	return localctx
}

// IExceptionIdentificationContext is an interface to support dynamic dispatch.
type IExceptionIdentificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExceptionIdentificationContext differentiates from other interfaces.
	IsExceptionIdentificationContext()
}

type ExceptionIdentificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionIdentificationContext() *ExceptionIdentificationContext {
	var p = new(ExceptionIdentificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_exceptionIdentification
	return p
}

func (*ExceptionIdentificationContext) IsExceptionIdentificationContext() {}

func NewExceptionIdentificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionIdentificationContext {
	var p = new(ExceptionIdentificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_exceptionIdentification

	return p
}

func (s *ExceptionIdentificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionIdentificationContext) SignedNumber() ISignedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignedNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignedNumberContext)
}

func (s *ExceptionIdentificationContext) DefinedValue() IDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedValueContext)
}

func (s *ExceptionIdentificationContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ExceptionIdentificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASNParserCOLON, 0)
}

func (s *ExceptionIdentificationContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ExceptionIdentificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionIdentificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionIdentificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExceptionIdentification(s)
	}
}

func (s *ExceptionIdentificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExceptionIdentification(s)
	}
}

func (p *ASNParser) ExceptionIdentification() (localctx IExceptionIdentificationContext) {
	localctx = NewExceptionIdentificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, ASNParserRULE_exceptionIdentification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1169)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1163)
			p.SignedNumber()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1164)
			p.DefinedValue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1165)
			p.AsnType()
		}
		{
			p.SetState(1166)
			p.Match(ASNParserCOLON)
		}
		{
			p.SetState(1167)
			p.Value()
		}

	}

	return localctx
}

// IAdditionalEnumerationContext is an interface to support dynamic dispatch.
type IAdditionalEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditionalEnumerationContext differentiates from other interfaces.
	IsAdditionalEnumerationContext()
}

type AdditionalEnumerationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditionalEnumerationContext() *AdditionalEnumerationContext {
	var p = new(AdditionalEnumerationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_additionalEnumeration
	return p
}

func (*AdditionalEnumerationContext) IsAdditionalEnumerationContext() {}

func NewAdditionalEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditionalEnumerationContext {
	var p = new(AdditionalEnumerationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_additionalEnumeration

	return p
}

func (s *AdditionalEnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditionalEnumerationContext) Enumeration() IEnumerationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerationContext)
}

func (s *AdditionalEnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditionalEnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditionalEnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAdditionalEnumeration(s)
	}
}

func (s *AdditionalEnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAdditionalEnumeration(s)
	}
}

func (p *ASNParser) AdditionalEnumeration() (localctx IAdditionalEnumerationContext) {
	localctx = NewAdditionalEnumerationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, ASNParserRULE_additionalEnumeration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1171)
		p.Enumeration()
	}

	return localctx
}

// IIntegerTypeContext is an interface to support dynamic dispatch.
type IIntegerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerTypeContext differentiates from other interfaces.
	IsIntegerTypeContext()
}

type IntegerTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerTypeContext() *IntegerTypeContext {
	var p = new(IntegerTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_integerType
	return p
}

func (*IntegerTypeContext) IsIntegerTypeContext() {}

func NewIntegerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerTypeContext {
	var p = new(IntegerTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_integerType

	return p
}

func (s *IntegerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerTypeContext) INTEGER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserINTEGER_LITERAL, 0)
}

func (s *IntegerTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *IntegerTypeContext) NamedNumberList() INamedNumberListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedNumberListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedNumberListContext)
}

func (s *IntegerTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *IntegerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterIntegerType(s)
	}
}

func (s *IntegerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitIntegerType(s)
	}
}

func (p *ASNParser) IntegerType() (localctx IIntegerTypeContext) {
	localctx = NewIntegerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, ASNParserRULE_integerType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1173)
		p.Match(ASNParserINTEGER_LITERAL)
	}
	p.SetState(1178)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1174)
			p.Match(ASNParserL_BRACE)
		}
		{
			p.SetState(1175)
			p.NamedNumberList()
		}
		{
			p.SetState(1176)
			p.Match(ASNParserR_BRACE)
		}

	}

	return localctx
}

// INamedNumberListContext is an interface to support dynamic dispatch.
type INamedNumberListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedNumberListContext differentiates from other interfaces.
	IsNamedNumberListContext()
}

type NamedNumberListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedNumberListContext() *NamedNumberListContext {
	var p = new(NamedNumberListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_namedNumberList
	return p
}

func (*NamedNumberListContext) IsNamedNumberListContext() {}

func NewNamedNumberListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedNumberListContext {
	var p = new(NamedNumberListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_namedNumberList

	return p
}

func (s *NamedNumberListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedNumberListContext) AllNamedNumber() []INamedNumberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedNumberContext)(nil)).Elem())
	var tst = make([]INamedNumberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedNumberContext)
		}
	}

	return tst
}

func (s *NamedNumberListContext) NamedNumber(i int) INamedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedNumberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedNumberContext)
}

func (s *NamedNumberListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *NamedNumberListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *NamedNumberListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedNumberListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedNumberListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterNamedNumberList(s)
	}
}

func (s *NamedNumberListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitNamedNumberList(s)
	}
}

func (p *ASNParser) NamedNumberList() (localctx INamedNumberListContext) {
	localctx = NewNamedNumberListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, ASNParserRULE_namedNumberList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1180)
		p.NamedNumber()
	}

	p.SetState(1185)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserCOMMA {
		{
			p.SetState(1181)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(1182)
			p.NamedNumber()
		}

		p.SetState(1187)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObjectidentifiertypeContext is an interface to support dynamic dispatch.
type IObjectidentifiertypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectidentifiertypeContext differentiates from other interfaces.
	IsObjectidentifiertypeContext()
}

type ObjectidentifiertypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectidentifiertypeContext() *ObjectidentifiertypeContext {
	var p = new(ObjectidentifiertypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectidentifiertype
	return p
}

func (*ObjectidentifiertypeContext) IsObjectidentifiertypeContext() {}

func NewObjectidentifiertypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectidentifiertypeContext {
	var p = new(ObjectidentifiertypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectidentifiertype

	return p
}

func (s *ObjectidentifiertypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectidentifiertypeContext) OBJECT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOBJECT_LITERAL, 0)
}

func (s *ObjectidentifiertypeContext) IDENTIFIER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER_LITERAL, 0)
}

func (s *ObjectidentifiertypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectidentifiertypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectidentifiertypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectidentifiertype(s)
	}
}

func (s *ObjectidentifiertypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectidentifiertype(s)
	}
}

func (p *ASNParser) Objectidentifiertype() (localctx IObjectidentifiertypeContext) {
	localctx = NewObjectidentifiertypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, ASNParserRULE_objectidentifiertype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1188)
		p.Match(ASNParserOBJECT_LITERAL)
	}
	{
		p.SetState(1189)
		p.Match(ASNParserIDENTIFIER_LITERAL)
	}

	return localctx
}

// IComponentRelationConstraintContext is an interface to support dynamic dispatch.
type IComponentRelationConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentRelationConstraintContext differentiates from other interfaces.
	IsComponentRelationConstraintContext()
}

type ComponentRelationConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentRelationConstraintContext() *ComponentRelationConstraintContext {
	var p = new(ComponentRelationConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_componentRelationConstraint
	return p
}

func (*ComponentRelationConstraintContext) IsComponentRelationConstraintContext() {}

func NewComponentRelationConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentRelationConstraintContext {
	var p = new(ComponentRelationConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_componentRelationConstraint

	return p
}

func (s *ComponentRelationConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentRelationConstraintContext) AllL_BRACE() []antlr.TerminalNode {
	return s.GetTokens(ASNParserL_BRACE)
}

func (s *ComponentRelationConstraintContext) L_BRACE(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, i)
}

func (s *ComponentRelationConstraintContext) AllR_BRACE() []antlr.TerminalNode {
	return s.GetTokens(ASNParserR_BRACE)
}

func (s *ComponentRelationConstraintContext) R_BRACE(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, i)
}

func (s *ComponentRelationConstraintContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *ComponentRelationConstraintContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *ComponentRelationConstraintContext) AllAtNotation() []IAtNotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtNotationContext)(nil)).Elem())
	var tst = make([]IAtNotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtNotationContext)
		}
	}

	return tst
}

func (s *ComponentRelationConstraintContext) AtNotation(i int) IAtNotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtNotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtNotationContext)
}

func (s *ComponentRelationConstraintContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *ComponentRelationConstraintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ComponentRelationConstraintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ComponentRelationConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentRelationConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentRelationConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterComponentRelationConstraint(s)
	}
}

func (s *ComponentRelationConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitComponentRelationConstraint(s)
	}
}

func (p *ASNParser) ComponentRelationConstraint() (localctx IComponentRelationConstraintContext) {
	localctx = NewComponentRelationConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, ASNParserRULE_componentRelationConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1191)
		p.Match(ASNParserL_BRACE)
	}

	{
		p.SetState(1192)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(1195)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserDOT {
		{
			p.SetState(1193)
			p.Match(ASNParserDOT)
		}
		{
			p.SetState(1194)
			p.Match(ASNParserIDENTIFIER)
		}

	}

	{
		p.SetState(1197)
		p.Match(ASNParserR_BRACE)
	}
	p.SetState(1209)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserL_BRACE {
		{
			p.SetState(1198)
			p.Match(ASNParserL_BRACE)
		}
		{
			p.SetState(1199)
			p.AtNotation()
		}
		p.SetState(1204)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ASNParserCOMMA {
			{
				p.SetState(1200)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(1201)
				p.AtNotation()
			}

			p.SetState(1206)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1207)
			p.Match(ASNParserR_BRACE)
		}

	}

	return localctx
}

// IAtNotationContext is an interface to support dynamic dispatch.
type IAtNotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtNotationContext differentiates from other interfaces.
	IsAtNotationContext()
}

type AtNotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtNotationContext() *AtNotationContext {
	var p = new(AtNotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_atNotation
	return p
}

func (*AtNotationContext) IsAtNotationContext() {}

func NewAtNotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtNotationContext {
	var p = new(AtNotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_atNotation

	return p
}

func (s *AtNotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AtNotationContext) ComponentIdList() IComponentIdListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentIdListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentIdListContext)
}

func (s *AtNotationContext) A_ROND() antlr.TerminalNode {
	return s.GetToken(ASNParserA_ROND, 0)
}

func (s *AtNotationContext) A_ROND_DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserA_ROND_DOT, 0)
}

func (s *AtNotationContext) Level() ILevelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILevelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILevelContext)
}

func (s *AtNotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtNotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtNotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAtNotation(s)
	}
}

func (s *AtNotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAtNotation(s)
	}
}

func (p *ASNParser) AtNotation() (localctx IAtNotationContext) {
	localctx = NewAtNotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, ASNParserRULE_atNotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1214)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserA_ROND:
		{
			p.SetState(1211)
			p.Match(ASNParserA_ROND)
		}

	case ASNParserA_ROND_DOT:
		{
			p.SetState(1212)
			p.Match(ASNParserA_ROND_DOT)
		}
		{
			p.SetState(1213)
			p.Level()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1216)
		p.ComponentIdList()
	}

	return localctx
}

// ILevelContext is an interface to support dynamic dispatch.
type ILevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLevelContext differentiates from other interfaces.
	IsLevelContext()
}

type LevelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelContext() *LevelContext {
	var p = new(LevelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_level
	return p
}

func (*LevelContext) IsLevelContext() {}

func NewLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelContext {
	var p = new(LevelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_level

	return p
}

func (s *LevelContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *LevelContext) Level() ILevelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILevelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILevelContext)
}

func (s *LevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterLevel(s)
	}
}

func (s *LevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitLevel(s)
	}
}

func (p *ASNParser) Level() (localctx ILevelContext) {
	localctx = NewLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, ASNParserRULE_level)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1220)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserDOT {
		{
			p.SetState(1218)
			p.Match(ASNParserDOT)
		}
		{
			p.SetState(1219)
			p.Level()
		}

	}

	return localctx
}

// IComponentIdListContext is an interface to support dynamic dispatch.
type IComponentIdListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentIdListContext differentiates from other interfaces.
	IsComponentIdListContext()
}

type ComponentIdListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentIdListContext() *ComponentIdListContext {
	var p = new(ComponentIdListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_componentIdList
	return p
}

func (*ComponentIdListContext) IsComponentIdListContext() {}

func NewComponentIdListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentIdListContext {
	var p = new(ComponentIdListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_componentIdList

	return p
}

func (s *ComponentIdListContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentIdListContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *ComponentIdListContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *ComponentIdListContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ASNParserDOT)
}

func (s *ComponentIdListContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, i)
}

func (s *ComponentIdListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentIdListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentIdListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterComponentIdList(s)
	}
}

func (s *ComponentIdListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitComponentIdList(s)
	}
}

func (p *ASNParser) ComponentIdList() (localctx IComponentIdListContext) {
	localctx = NewComponentIdListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, ASNParserRULE_componentIdList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1222)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(1227)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserDOT {
		{
			p.SetState(1223)
			p.Match(ASNParserDOT)
		}
		{
			p.SetState(1224)
			p.Match(ASNParserIDENTIFIER)
		}

		p.SetState(1229)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOctetStringTypeContext is an interface to support dynamic dispatch.
type IOctetStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOctetStringTypeContext differentiates from other interfaces.
	IsOctetStringTypeContext()
}

type OctetStringTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOctetStringTypeContext() *OctetStringTypeContext {
	var p = new(OctetStringTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_octetStringType
	return p
}

func (*OctetStringTypeContext) IsOctetStringTypeContext() {}

func NewOctetStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OctetStringTypeContext {
	var p = new(OctetStringTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_octetStringType

	return p
}

func (s *OctetStringTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OctetStringTypeContext) OCTET_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOCTET_LITERAL, 0)
}

func (s *OctetStringTypeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSTRING_LITERAL, 0)
}

func (s *OctetStringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OctetStringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OctetStringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterOctetStringType(s)
	}
}

func (s *OctetStringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitOctetStringType(s)
	}
}

func (p *ASNParser) OctetStringType() (localctx IOctetStringTypeContext) {
	localctx = NewOctetStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, ASNParserRULE_octetStringType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1230)
		p.Match(ASNParserOCTET_LITERAL)
	}
	{
		p.SetState(1231)
		p.Match(ASNParserSTRING_LITERAL)
	}

	return localctx
}

// IBitStringTypeContext is an interface to support dynamic dispatch.
type IBitStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitStringTypeContext differentiates from other interfaces.
	IsBitStringTypeContext()
}

type BitStringTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitStringTypeContext() *BitStringTypeContext {
	var p = new(BitStringTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_bitStringType
	return p
}

func (*BitStringTypeContext) IsBitStringTypeContext() {}

func NewBitStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitStringTypeContext {
	var p = new(BitStringTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_bitStringType

	return p
}

func (s *BitStringTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BitStringTypeContext) BIT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserBIT_LITERAL, 0)
}

func (s *BitStringTypeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSTRING_LITERAL, 0)
}

func (s *BitStringTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *BitStringTypeContext) NamedBitList() INamedBitListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedBitListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedBitListContext)
}

func (s *BitStringTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *BitStringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitStringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitStringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterBitStringType(s)
	}
}

func (s *BitStringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitBitStringType(s)
	}
}

func (p *ASNParser) BitStringType() (localctx IBitStringTypeContext) {
	localctx = NewBitStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, ASNParserRULE_bitStringType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1233)
		p.Match(ASNParserBIT_LITERAL)
	}
	{
		p.SetState(1234)
		p.Match(ASNParserSTRING_LITERAL)
	}

	p.SetState(1240)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1236)
			p.Match(ASNParserL_BRACE)
		}
		{
			p.SetState(1237)
			p.NamedBitList()
		}
		{
			p.SetState(1238)
			p.Match(ASNParserR_BRACE)
		}

	}

	return localctx
}

// INamedBitListContext is an interface to support dynamic dispatch.
type INamedBitListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedBitListContext differentiates from other interfaces.
	IsNamedBitListContext()
}

type NamedBitListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedBitListContext() *NamedBitListContext {
	var p = new(NamedBitListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_namedBitList
	return p
}

func (*NamedBitListContext) IsNamedBitListContext() {}

func NewNamedBitListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedBitListContext {
	var p = new(NamedBitListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_namedBitList

	return p
}

func (s *NamedBitListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedBitListContext) AllNamedBit() []INamedBitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedBitContext)(nil)).Elem())
	var tst = make([]INamedBitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedBitContext)
		}
	}

	return tst
}

func (s *NamedBitListContext) NamedBit(i int) INamedBitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedBitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedBitContext)
}

func (s *NamedBitListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *NamedBitListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *NamedBitListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedBitListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedBitListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterNamedBitList(s)
	}
}

func (s *NamedBitListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitNamedBitList(s)
	}
}

func (p *ASNParser) NamedBitList() (localctx INamedBitListContext) {
	localctx = NewNamedBitListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, ASNParserRULE_namedBitList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1242)
		p.NamedBit()
	}

	p.SetState(1247)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserCOMMA {
		{
			p.SetState(1243)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(1244)
			p.NamedBit()
		}

		p.SetState(1249)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INamedBitContext is an interface to support dynamic dispatch.
type INamedBitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedBitContext differentiates from other interfaces.
	IsNamedBitContext()
}

type NamedBitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedBitContext() *NamedBitContext {
	var p = new(NamedBitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_namedBit
	return p
}

func (*NamedBitContext) IsNamedBitContext() {}

func NewNamedBitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedBitContext {
	var p = new(NamedBitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_namedBit

	return p
}

func (s *NamedBitContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedBitContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *NamedBitContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserL_PARAN, 0)
}

func (s *NamedBitContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserR_PARAN, 0)
}

func (s *NamedBitContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(ASNParserNUMBER, 0)
}

func (s *NamedBitContext) DefinedValue() IDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedValueContext)
}

func (s *NamedBitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedBitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedBitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterNamedBit(s)
	}
}

func (s *NamedBitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitNamedBit(s)
	}
}

func (p *ASNParser) NamedBit() (localctx INamedBitContext) {
	localctx = NewNamedBitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, ASNParserRULE_namedBit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1250)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(1251)
		p.Match(ASNParserL_PARAN)
	}
	p.SetState(1254)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserNUMBER:
		{
			p.SetState(1252)
			p.Match(ASNParserNUMBER)
		}

	case ASNParserIDENTIFIER:
		{
			p.SetState(1253)
			p.DefinedValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1256)
		p.Match(ASNParserR_PARAN)
	}

	return localctx
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_booleanValue
	return p
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserTRUE_LITERAL, 0)
}

func (s *BooleanValueContext) FALSE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserFALSE_LITERAL, 0)
}

func (s *BooleanValueContext) TRUE_SMALL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserTRUE_SMALL_LITERAL, 0)
}

func (s *BooleanValueContext) FALSE_SMALL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserFALSE_SMALL_LITERAL, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (p *ASNParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, ASNParserRULE_booleanValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1258)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASNParserTRUE_LITERAL)|(1<<ASNParserFALSE_LITERAL)|(1<<ASNParserTRUE_SMALL_LITERAL)|(1<<ASNParserFALSE_SMALL_LITERAL))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
