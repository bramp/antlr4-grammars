// Code generated from jvmBasic.g4 by ANTLR 4.9.3. DO NOT EDIT.

package jvmbasic // jvmBasic
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 124, 893,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 3, 2, 6, 2, 206, 10, 2, 13, 2, 14, 2, 207, 3, 2, 3, 2, 3, 3, 3,
	3, 3, 3, 3, 3, 5, 3, 216, 10, 3, 7, 3, 218, 10, 3, 12, 3, 14, 3, 221, 11,
	3, 3, 3, 5, 3, 224, 10, 3, 3, 4, 3, 4, 3, 5, 3, 5, 3, 6, 5, 6, 231, 10,
	6, 3, 6, 3, 6, 5, 6, 235, 10, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3,
	7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3,
	7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3,
	7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3,
	7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 286, 10, 7, 3, 8, 3, 8, 3,
	8, 3, 8, 3, 8, 7, 8, 293, 10, 8, 12, 8, 14, 8, 296, 11, 8, 3, 9, 3, 9,
	5, 9, 300, 10, 9, 3, 10, 3, 10, 3, 10, 5, 10, 305, 10, 10, 7, 10, 307,
	10, 10, 12, 10, 14, 10, 310, 11, 10, 3, 11, 3, 11, 3, 11, 3, 12, 5, 12,
	316, 10, 12, 3, 12, 3, 12, 3, 13, 3, 13, 3, 13, 3, 13, 3, 14, 3, 14, 3,
	14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14,
	3, 14, 5, 14, 338, 10, 14, 3, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3, 16, 5,
	16, 346, 10, 16, 3, 16, 3, 16, 5, 16, 350, 10, 16, 3, 17, 3, 17, 3, 17,
	3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 5, 17, 360, 10, 17, 3, 17, 3, 17, 3,
	17, 5, 17, 365, 10, 17, 5, 17, 367, 10, 17, 3, 18, 3, 18, 3, 18, 3, 18,
	3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 377, 10, 18, 3, 19, 3, 19, 3, 19, 3,
	19, 7, 19, 383, 10, 19, 12, 19, 14, 19, 386, 11, 19, 5, 19, 388, 10, 19,
	3, 20, 3, 20, 3, 20, 5, 20, 393, 10, 20, 3, 20, 3, 20, 3, 21, 3, 21, 3,
	21, 3, 22, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 3, 25,
	3, 25, 3, 25, 3, 25, 3, 25, 3, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3, 27, 3,
	27, 3, 27, 5, 27, 422, 10, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 7, 27,
	429, 10, 27, 12, 27, 14, 27, 432, 11, 27, 3, 28, 3, 28, 3, 28, 3, 28, 3,
	28, 5, 28, 439, 10, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 7, 28, 446,
	10, 28, 12, 28, 14, 28, 449, 11, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29,
	3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 462, 10, 30, 12, 30, 14,
	30, 465, 11, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 7, 31, 473,
	10, 31, 12, 31, 14, 31, 476, 11, 31, 3, 32, 3, 32, 3, 32, 3, 33, 3, 33,
	3, 33, 3, 34, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 36, 3,
	36, 3, 36, 3, 36, 5, 36, 496, 10, 36, 7, 36, 498, 10, 36, 12, 36, 14, 36,
	501, 11, 36, 3, 37, 3, 37, 5, 37, 505, 10, 37, 3, 38, 3, 38, 3, 38, 3,
	38, 3, 38, 3, 38, 5, 38, 513, 10, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 5, 39, 522, 10, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3,
	40, 3, 40, 5, 40, 531, 10, 40, 3, 41, 3, 41, 5, 41, 535, 10, 41, 3, 41,
	3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 3, 42, 3,
	42, 3, 43, 3, 43, 3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 3, 44, 3, 45, 3, 45,
	3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 3, 47, 3,
	48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 49, 3, 49, 3, 49, 3, 49,
	3, 49, 3, 49, 3, 49, 3, 50, 3, 50, 3, 50, 3, 50, 3, 51, 3, 51, 3, 51, 3,
	52, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55,
	5, 55, 601, 10, 55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 5, 56, 608, 10,
	56, 3, 57, 3, 57, 3, 57, 3, 58, 3, 58, 3, 58, 3, 59, 3, 59, 3, 60, 3, 60,
	3, 61, 3, 61, 3, 62, 5, 62, 623, 10, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3,
	63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63,
	3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3,
	63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63,
	3, 63, 5, 63, 662, 10, 63, 3, 64, 5, 64, 665, 10, 64, 3, 64, 5, 64, 668,
	10, 64, 3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 7, 65, 675, 10, 65, 12, 65,
	14, 65, 678, 11, 65, 3, 66, 3, 66, 3, 66, 7, 66, 683, 10, 66, 12, 66, 14,
	66, 686, 11, 66, 3, 67, 3, 67, 3, 67, 7, 67, 691, 10, 67, 12, 67, 14, 67,
	694, 11, 67, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68, 700, 10, 68, 3, 69, 3,
	69, 3, 69, 3, 69, 7, 69, 706, 10, 69, 12, 69, 14, 69, 709, 11, 69, 5, 69,
	711, 10, 69, 3, 70, 3, 70, 5, 70, 715, 10, 70, 3, 71, 3, 71, 7, 71, 719,
	10, 71, 12, 71, 14, 71, 722, 11, 71, 3, 72, 3, 72, 3, 73, 3, 73, 3, 73,
	7, 73, 729, 10, 73, 12, 73, 14, 73, 732, 11, 73, 3, 74, 3, 74, 3, 74, 7,
	74, 737, 10, 74, 12, 74, 14, 74, 740, 11, 74, 3, 75, 3, 75, 3, 75, 3, 75,
	3, 75, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 77, 3, 77, 3, 77, 3, 77, 3,
	77, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79,
	3, 79, 3, 79, 3, 79, 3, 79, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 81, 3,
	81, 3, 81, 3, 81, 3, 81, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 83, 3, 83,
	3, 83, 3, 83, 3, 83, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 85, 3, 85, 3,
	85, 3, 85, 3, 85, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 87, 3, 87, 3, 87,
	3, 87, 3, 87, 3, 87, 3, 87, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3,
	88, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90,
	3, 90, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 92, 3, 92, 3, 92, 3, 92, 3,
	92, 3, 92, 3, 92, 3, 93, 3, 93, 3, 93, 3, 93, 3, 93, 3, 94, 3, 94, 3, 94,
	3, 94, 3, 94, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 96, 3, 96, 3, 96, 3,
	96, 3, 96, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 98, 3, 98, 3, 98, 3, 98,
	3, 98, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 100, 3, 100, 3, 100, 3, 100,
	3, 100, 3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 3, 102, 3, 102, 3, 102,
	3, 102, 3, 102, 3, 102, 2, 2, 103, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,
	22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56,
	58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92,
	94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122,
	124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152,
	154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182,
	184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 2, 12, 4, 2, 12, 12,
	119, 119, 13, 2, 24, 24, 31, 31, 43, 45, 55, 55, 62, 62, 65, 67, 73, 74,
	96, 96, 111, 111, 114, 115, 118, 118, 4, 2, 6, 6, 116, 116, 4, 2, 29, 29,
	39, 39, 3, 2, 20, 21, 3, 2, 122, 123, 3, 2, 22, 23, 3, 2, 75, 76, 3, 2,
	121, 122, 3, 2, 3, 4, 2, 927, 2, 205, 3, 2, 2, 2, 4, 211, 3, 2, 2, 2, 6,
	225, 3, 2, 2, 2, 8, 227, 3, 2, 2, 2, 10, 234, 3, 2, 2, 2, 12, 285, 3, 2,
	2, 2, 14, 287, 3, 2, 2, 2, 16, 297, 3, 2, 2, 2, 18, 301, 3, 2, 2, 2, 20,
	311, 3, 2, 2, 2, 22, 315, 3, 2, 2, 2, 24, 319, 3, 2, 2, 2, 26, 337, 3,
	2, 2, 2, 28, 339, 3, 2, 2, 2, 30, 342, 3, 2, 2, 2, 32, 351, 3, 2, 2, 2,
	34, 368, 3, 2, 2, 2, 36, 378, 3, 2, 2, 2, 38, 389, 3, 2, 2, 2, 40, 396,
	3, 2, 2, 2, 42, 399, 3, 2, 2, 2, 44, 402, 3, 2, 2, 2, 46, 405, 3, 2, 2,
	2, 48, 408, 3, 2, 2, 2, 50, 413, 3, 2, 2, 2, 52, 416, 3, 2, 2, 2, 54, 433,
	3, 2, 2, 2, 56, 450, 3, 2, 2, 2, 58, 455, 3, 2, 2, 2, 60, 466, 3, 2, 2,
	2, 62, 477, 3, 2, 2, 2, 64, 480, 3, 2, 2, 2, 66, 483, 3, 2, 2, 2, 68, 487,
	3, 2, 2, 2, 70, 491, 3, 2, 2, 2, 72, 504, 3, 2, 2, 2, 74, 506, 3, 2, 2,
	2, 76, 514, 3, 2, 2, 2, 78, 523, 3, 2, 2, 2, 80, 532, 3, 2, 2, 2, 82, 543,
	3, 2, 2, 2, 84, 548, 3, 2, 2, 2, 86, 552, 3, 2, 2, 2, 88, 556, 3, 2, 2,
	2, 90, 560, 3, 2, 2, 2, 92, 564, 3, 2, 2, 2, 94, 568, 3, 2, 2, 2, 96, 575,
	3, 2, 2, 2, 98, 582, 3, 2, 2, 2, 100, 586, 3, 2, 2, 2, 102, 589, 3, 2,
	2, 2, 104, 592, 3, 2, 2, 2, 106, 595, 3, 2, 2, 2, 108, 598, 3, 2, 2, 2,
	110, 602, 3, 2, 2, 2, 112, 609, 3, 2, 2, 2, 114, 612, 3, 2, 2, 2, 116,
	615, 3, 2, 2, 2, 118, 617, 3, 2, 2, 2, 120, 619, 3, 2, 2, 2, 122, 622,
	3, 2, 2, 2, 124, 661, 3, 2, 2, 2, 126, 664, 3, 2, 2, 2, 128, 671, 3, 2,
	2, 2, 130, 679, 3, 2, 2, 2, 132, 687, 3, 2, 2, 2, 134, 695, 3, 2, 2, 2,
	136, 710, 3, 2, 2, 2, 138, 712, 3, 2, 2, 2, 140, 716, 3, 2, 2, 2, 142,
	723, 3, 2, 2, 2, 144, 725, 3, 2, 2, 2, 146, 733, 3, 2, 2, 2, 148, 741,
	3, 2, 2, 2, 150, 746, 3, 2, 2, 2, 152, 751, 3, 2, 2, 2, 154, 756, 3, 2,
	2, 2, 156, 761, 3, 2, 2, 2, 158, 770, 3, 2, 2, 2, 160, 775, 3, 2, 2, 2,
	162, 780, 3, 2, 2, 2, 164, 785, 3, 2, 2, 2, 166, 790, 3, 2, 2, 2, 168,
	795, 3, 2, 2, 2, 170, 800, 3, 2, 2, 2, 172, 805, 3, 2, 2, 2, 174, 812,
	3, 2, 2, 2, 176, 819, 3, 2, 2, 2, 178, 824, 3, 2, 2, 2, 180, 830, 3, 2,
	2, 2, 182, 835, 3, 2, 2, 2, 184, 842, 3, 2, 2, 2, 186, 847, 3, 2, 2, 2,
	188, 852, 3, 2, 2, 2, 190, 857, 3, 2, 2, 2, 192, 862, 3, 2, 2, 2, 194,
	867, 3, 2, 2, 2, 196, 872, 3, 2, 2, 2, 198, 877, 3, 2, 2, 2, 200, 882,
	3, 2, 2, 2, 202, 887, 3, 2, 2, 2, 204, 206, 5, 4, 3, 2, 205, 204, 3, 2,
	2, 2, 206, 207, 3, 2, 2, 2, 207, 205, 3, 2, 2, 2, 207, 208, 3, 2, 2, 2,
	208, 209, 3, 2, 2, 2, 209, 210, 7, 2, 2, 3, 210, 3, 3, 2, 2, 2, 211, 223,
	5, 8, 5, 2, 212, 219, 5, 10, 6, 2, 213, 215, 7, 42, 2, 2, 214, 216, 5,
	10, 6, 2, 215, 214, 3, 2, 2, 2, 215, 216, 3, 2, 2, 2, 216, 218, 3, 2, 2,
	2, 217, 213, 3, 2, 2, 2, 218, 221, 3, 2, 2, 2, 219, 217, 3, 2, 2, 2, 219,
	220, 3, 2, 2, 2, 220, 224, 3, 2, 2, 2, 221, 219, 3, 2, 2, 2, 222, 224,
	9, 2, 2, 2, 223, 212, 3, 2, 2, 2, 223, 222, 3, 2, 2, 2, 224, 5, 3, 2, 2,
	2, 225, 226, 7, 110, 2, 2, 226, 7, 3, 2, 2, 2, 227, 228, 7, 122, 2, 2,
	228, 9, 3, 2, 2, 2, 229, 231, 5, 6, 4, 2, 230, 229, 3, 2, 2, 2, 230, 231,
	3, 2, 2, 2, 231, 232, 3, 2, 2, 2, 232, 235, 5, 12, 7, 2, 233, 235, 9, 2,
	2, 2, 234, 230, 3, 2, 2, 2, 234, 233, 3, 2, 2, 2, 235, 11, 3, 2, 2, 2,
	236, 286, 9, 3, 2, 2, 237, 286, 5, 116, 59, 2, 238, 286, 5, 118, 60, 2,
	239, 286, 5, 120, 61, 2, 240, 286, 5, 112, 57, 2, 241, 286, 5, 110, 56,
	2, 242, 286, 5, 108, 55, 2, 243, 286, 5, 104, 53, 2, 244, 286, 5, 20, 11,
	2, 245, 286, 5, 106, 54, 2, 246, 286, 5, 36, 19, 2, 247, 286, 5, 102, 52,
	2, 248, 286, 5, 100, 51, 2, 249, 286, 5, 98, 50, 2, 250, 286, 5, 94, 48,
	2, 251, 286, 5, 96, 49, 2, 252, 286, 5, 90, 46, 2, 253, 286, 5, 84, 43,
	2, 254, 286, 5, 88, 45, 2, 255, 286, 5, 86, 44, 2, 256, 286, 5, 92, 47,
	2, 257, 286, 5, 66, 34, 2, 258, 286, 5, 68, 35, 2, 259, 286, 5, 16, 9,
	2, 260, 286, 5, 48, 25, 2, 261, 286, 5, 56, 29, 2, 262, 286, 5, 58, 30,
	2, 263, 286, 5, 60, 31, 2, 264, 286, 5, 30, 16, 2, 265, 286, 5, 32, 17,
	2, 266, 286, 5, 34, 18, 2, 267, 286, 5, 38, 20, 2, 268, 286, 5, 82, 42,
	2, 269, 286, 5, 42, 22, 2, 270, 286, 5, 44, 23, 2, 271, 286, 5, 46, 24,
	2, 272, 286, 5, 50, 26, 2, 273, 286, 5, 40, 21, 2, 274, 286, 5, 52, 27,
	2, 275, 286, 5, 54, 28, 2, 276, 286, 5, 62, 32, 2, 277, 286, 5, 64, 33,
	2, 278, 286, 5, 74, 38, 2, 279, 286, 5, 70, 36, 2, 280, 286, 5, 76, 39,
	2, 281, 286, 5, 78, 40, 2, 282, 286, 5, 80, 41, 2, 283, 286, 5, 22, 12,
	2, 284, 286, 5, 114, 58, 2, 285, 236, 3, 2, 2, 2, 285, 237, 3, 2, 2, 2,
	285, 238, 3, 2, 2, 2, 285, 239, 3, 2, 2, 2, 285, 240, 3, 2, 2, 2, 285,
	241, 3, 2, 2, 2, 285, 242, 3, 2, 2, 2, 285, 243, 3, 2, 2, 2, 285, 244,
	3, 2, 2, 2, 285, 245, 3, 2, 2, 2, 285, 246, 3, 2, 2, 2, 285, 247, 3, 2,
	2, 2, 285, 248, 3, 2, 2, 2, 285, 249, 3, 2, 2, 2, 285, 250, 3, 2, 2, 2,
	285, 251, 3, 2, 2, 2, 285, 252, 3, 2, 2, 2, 285, 253, 3, 2, 2, 2, 285,
	254, 3, 2, 2, 2, 285, 255, 3, 2, 2, 2, 285, 256, 3, 2, 2, 2, 285, 257,
	3, 2, 2, 2, 285, 258, 3, 2, 2, 2, 285, 259, 3, 2, 2, 2, 285, 260, 3, 2,
	2, 2, 285, 261, 3, 2, 2, 2, 285, 262, 3, 2, 2, 2, 285, 263, 3, 2, 2, 2,
	285, 264, 3, 2, 2, 2, 285, 265, 3, 2, 2, 2, 285, 266, 3, 2, 2, 2, 285,
	267, 3, 2, 2, 2, 285, 268, 3, 2, 2, 2, 285, 269, 3, 2, 2, 2, 285, 270,
	3, 2, 2, 2, 285, 271, 3, 2, 2, 2, 285, 272, 3, 2, 2, 2, 285, 273, 3, 2,
	2, 2, 285, 274, 3, 2, 2, 2, 285, 275, 3, 2, 2, 2, 285, 276, 3, 2, 2, 2,
	285, 277, 3, 2, 2, 2, 285, 278, 3, 2, 2, 2, 285, 279, 3, 2, 2, 2, 285,
	280, 3, 2, 2, 2, 285, 281, 3, 2, 2, 2, 285, 282, 3, 2, 2, 2, 285, 283,
	3, 2, 2, 2, 285, 284, 3, 2, 2, 2, 286, 13, 3, 2, 2, 2, 287, 294, 5, 138,
	70, 2, 288, 289, 7, 18, 2, 2, 289, 290, 5, 146, 74, 2, 290, 291, 7, 19,
	2, 2, 291, 293, 3, 2, 2, 2, 292, 288, 3, 2, 2, 2, 293, 296, 3, 2, 2, 2,
	294, 292, 3, 2, 2, 2, 294, 295, 3, 2, 2, 2, 295, 15, 3, 2, 2, 2, 296, 294,
	3, 2, 2, 2, 297, 299, 9, 4, 2, 2, 298, 300, 5, 18, 10, 2, 299, 298, 3,
	2, 2, 2, 299, 300, 3, 2, 2, 2, 300, 17, 3, 2, 2, 2, 301, 308, 5, 136, 69,
	2, 302, 304, 9, 5, 2, 2, 303, 305, 5, 136, 69, 2, 304, 303, 3, 2, 2, 2,
	304, 305, 3, 2, 2, 2, 305, 307, 3, 2, 2, 2, 306, 302, 3, 2, 2, 2, 307,
	310, 3, 2, 2, 2, 308, 306, 3, 2, 2, 2, 308, 309, 3, 2, 2, 2, 309, 19, 3,
	2, 2, 2, 310, 308, 3, 2, 2, 2, 311, 312, 7, 108, 2, 2, 312, 313, 5, 146,
	74, 2, 313, 21, 3, 2, 2, 2, 314, 316, 7, 33, 2, 2, 315, 314, 3, 2, 2, 2,
	315, 316, 3, 2, 2, 2, 316, 317, 3, 2, 2, 2, 317, 318, 5, 24, 13, 2, 318,
	23, 3, 2, 2, 2, 319, 320, 5, 14, 8, 2, 320, 321, 7, 34, 2, 2, 321, 322,
	5, 146, 74, 2, 322, 25, 3, 2, 2, 2, 323, 338, 7, 25, 2, 2, 324, 325, 7,
	27, 2, 2, 325, 338, 7, 34, 2, 2, 326, 327, 7, 34, 2, 2, 327, 338, 7, 27,
	2, 2, 328, 338, 7, 26, 2, 2, 329, 330, 7, 28, 2, 2, 330, 338, 7, 34, 2,
	2, 331, 332, 7, 34, 2, 2, 332, 338, 7, 28, 2, 2, 333, 338, 5, 28, 15, 2,
	334, 338, 7, 34, 2, 2, 335, 338, 7, 27, 2, 2, 336, 338, 7, 28, 2, 2, 337,
	323, 3, 2, 2, 2, 337, 324, 3, 2, 2, 2, 337, 326, 3, 2, 2, 2, 337, 328,
	3, 2, 2, 2, 337, 329, 3, 2, 2, 2, 337, 331, 3, 2, 2, 2, 337, 333, 3, 2,
	2, 2, 337, 334, 3, 2, 2, 2, 337, 335, 3, 2, 2, 2, 337, 336, 3, 2, 2, 2,
	338, 27, 3, 2, 2, 2, 339, 340, 7, 28, 2, 2, 340, 341, 7, 27, 2, 2, 341,
	29, 3, 2, 2, 2, 342, 343, 7, 9, 2, 2, 343, 345, 5, 136, 69, 2, 344, 346,
	7, 11, 2, 2, 345, 344, 3, 2, 2, 2, 345, 346, 3, 2, 2, 2, 346, 349, 3, 2,
	2, 2, 347, 350, 5, 12, 7, 2, 348, 350, 5, 8, 5, 2, 349, 347, 3, 2, 2, 2,
	349, 348, 3, 2, 2, 2, 350, 31, 3, 2, 2, 2, 351, 352, 7, 35, 2, 2, 352,
	353, 5, 14, 8, 2, 353, 354, 7, 34, 2, 2, 354, 355, 5, 136, 69, 2, 355,
	356, 7, 36, 2, 2, 356, 359, 5, 136, 69, 2, 357, 358, 7, 37, 2, 2, 358,
	360, 5, 136, 69, 2, 359, 357, 3, 2, 2, 2, 359, 360, 3, 2, 2, 2, 360, 366,
	3, 2, 2, 2, 361, 362, 5, 12, 7, 2, 362, 364, 7, 10, 2, 2, 363, 365, 5,
	14, 8, 2, 364, 363, 3, 2, 2, 2, 364, 365, 3, 2, 2, 2, 365, 367, 3, 2, 2,
	2, 366, 361, 3, 2, 2, 2, 366, 367, 3, 2, 2, 2, 367, 33, 3, 2, 2, 2, 368,
	369, 7, 35, 2, 2, 369, 370, 5, 14, 8, 2, 370, 371, 7, 34, 2, 2, 371, 372,
	5, 136, 69, 2, 372, 373, 7, 36, 2, 2, 373, 376, 5, 136, 69, 2, 374, 375,
	7, 37, 2, 2, 375, 377, 5, 136, 69, 2, 376, 374, 3, 2, 2, 2, 376, 377, 3,
	2, 2, 2, 377, 35, 3, 2, 2, 2, 378, 387, 7, 10, 2, 2, 379, 384, 5, 14, 8,
	2, 380, 381, 7, 29, 2, 2, 381, 383, 5, 14, 8, 2, 382, 380, 3, 2, 2, 2,
	383, 386, 3, 2, 2, 2, 384, 382, 3, 2, 2, 2, 384, 385, 3, 2, 2, 2, 385,
	388, 3, 2, 2, 2, 386, 384, 3, 2, 2, 2, 387, 379, 3, 2, 2, 2, 387, 388,
	3, 2, 2, 2, 388, 37, 3, 2, 2, 2, 389, 392, 7, 38, 2, 2, 390, 391, 7, 120,
	2, 2, 391, 393, 9, 5, 2, 2, 392, 390, 3, 2, 2, 2, 392, 393, 3, 2, 2, 2,
	393, 394, 3, 2, 2, 2, 394, 395, 5, 144, 73, 2, 395, 39, 3, 2, 2, 2, 396,
	397, 7, 79, 2, 2, 397, 398, 5, 144, 73, 2, 398, 41, 3, 2, 2, 2, 399, 400,
	7, 40, 2, 2, 400, 401, 5, 144, 73, 2, 401, 43, 3, 2, 2, 2, 402, 403, 7,
	7, 2, 2, 403, 404, 5, 8, 5, 2, 404, 45, 3, 2, 2, 2, 405, 406, 7, 8, 2,
	2, 406, 407, 5, 136, 69, 2, 407, 47, 3, 2, 2, 2, 408, 409, 7, 60, 2, 2,
	409, 410, 5, 136, 69, 2, 410, 411, 7, 29, 2, 2, 411, 412, 5, 136, 69, 2,
	412, 49, 3, 2, 2, 2, 413, 414, 7, 47, 2, 2, 414, 415, 5, 146, 74, 2, 415,
	51, 3, 2, 2, 2, 416, 421, 7, 49, 2, 2, 417, 418, 5, 136, 69, 2, 418, 419,
	7, 29, 2, 2, 419, 420, 5, 136, 69, 2, 420, 422, 3, 2, 2, 2, 421, 417, 3,
	2, 2, 2, 421, 422, 3, 2, 2, 2, 422, 430, 3, 2, 2, 2, 423, 424, 7, 36, 2,
	2, 424, 425, 5, 136, 69, 2, 425, 426, 7, 29, 2, 2, 426, 427, 5, 136, 69,
	2, 427, 429, 3, 2, 2, 2, 428, 423, 3, 2, 2, 2, 429, 432, 3, 2, 2, 2, 430,
	428, 3, 2, 2, 2, 430, 431, 3, 2, 2, 2, 431, 53, 3, 2, 2, 2, 432, 430, 3,
	2, 2, 2, 433, 438, 7, 50, 2, 2, 434, 435, 5, 136, 69, 2, 435, 436, 7, 29,
	2, 2, 436, 437, 5, 136, 69, 2, 437, 439, 3, 2, 2, 2, 438, 434, 3, 2, 2,
	2, 438, 439, 3, 2, 2, 2, 439, 447, 3, 2, 2, 2, 440, 441, 7, 36, 2, 2, 441,
	442, 5, 136, 69, 2, 442, 443, 7, 29, 2, 2, 443, 444, 5, 136, 69, 2, 444,
	446, 3, 2, 2, 2, 445, 440, 3, 2, 2, 2, 446, 449, 3, 2, 2, 2, 447, 445,
	3, 2, 2, 2, 447, 448, 3, 2, 2, 2, 448, 55, 3, 2, 2, 2, 449, 447, 3, 2,
	2, 2, 450, 451, 7, 58, 2, 2, 451, 452, 5, 136, 69, 2, 452, 453, 7, 29,
	2, 2, 453, 454, 5, 136, 69, 2, 454, 57, 3, 2, 2, 2, 455, 456, 7, 56, 2,
	2, 456, 457, 5, 136, 69, 2, 457, 458, 7, 7, 2, 2, 458, 463, 5, 8, 5, 2,
	459, 460, 7, 29, 2, 2, 460, 462, 5, 8, 5, 2, 461, 459, 3, 2, 2, 2, 462,
	465, 3, 2, 2, 2, 463, 461, 3, 2, 2, 2, 463, 464, 3, 2, 2, 2, 464, 59, 3,
	2, 2, 2, 465, 463, 3, 2, 2, 2, 466, 467, 7, 56, 2, 2, 467, 468, 5, 136,
	69, 2, 468, 469, 7, 8, 2, 2, 469, 474, 5, 8, 5, 2, 470, 471, 7, 29, 2,
	2, 471, 473, 5, 8, 5, 2, 472, 470, 3, 2, 2, 2, 473, 476, 3, 2, 2, 2, 474,
	472, 3, 2, 2, 2, 474, 475, 3, 2, 2, 2, 475, 61, 3, 2, 2, 2, 476, 474, 3,
	2, 2, 2, 477, 478, 7, 53, 2, 2, 478, 479, 5, 136, 69, 2, 479, 63, 3, 2,
	2, 2, 480, 481, 7, 54, 2, 2, 481, 482, 5, 136, 69, 2, 482, 65, 3, 2, 2,
	2, 483, 484, 7, 63, 2, 2, 484, 485, 7, 42, 2, 2, 485, 486, 5, 136, 69,
	2, 486, 67, 3, 2, 2, 2, 487, 488, 7, 64, 2, 2, 488, 489, 7, 42, 2, 2, 489,
	490, 5, 136, 69, 2, 490, 69, 3, 2, 2, 2, 491, 492, 7, 77, 2, 2, 492, 499,
	5, 72, 37, 2, 493, 495, 7, 29, 2, 2, 494, 496, 5, 72, 37, 2, 495, 494,
	3, 2, 2, 2, 495, 496, 3, 2, 2, 2, 496, 498, 3, 2, 2, 2, 497, 493, 3, 2,
	2, 2, 498, 501, 3, 2, 2, 2, 499, 497, 3, 2, 2, 2, 499, 500, 3, 2, 2, 2,
	500, 71, 3, 2, 2, 2, 501, 499, 3, 2, 2, 2, 502, 505, 5, 122, 62, 2, 503,
	505, 7, 120, 2, 2, 504, 502, 3, 2, 2, 2, 504, 503, 3, 2, 2, 2, 505, 73,
	3, 2, 2, 2, 506, 507, 7, 78, 2, 2, 507, 508, 5, 136, 69, 2, 508, 509, 7,
	29, 2, 2, 509, 512, 5, 136, 69, 2, 510, 511, 7, 29, 2, 2, 511, 513, 5,
	136, 69, 2, 512, 510, 3, 2, 2, 2, 512, 513, 3, 2, 2, 2, 513, 75, 3, 2,
	2, 2, 514, 515, 7, 80, 2, 2, 515, 521, 5, 136, 69, 2, 516, 517, 7, 82,
	2, 2, 517, 518, 5, 136, 69, 2, 518, 519, 7, 29, 2, 2, 519, 520, 5, 136,
	69, 2, 520, 522, 3, 2, 2, 2, 521, 516, 3, 2, 2, 2, 521, 522, 3, 2, 2, 2,
	522, 77, 3, 2, 2, 2, 523, 524, 7, 81, 2, 2, 524, 530, 5, 136, 69, 2, 525,
	526, 7, 82, 2, 2, 526, 527, 5, 136, 69, 2, 527, 528, 7, 29, 2, 2, 528,
	529, 5, 136, 69, 2, 529, 531, 3, 2, 2, 2, 530, 525, 3, 2, 2, 2, 530, 531,
	3, 2, 2, 2, 531, 79, 3, 2, 2, 2, 532, 534, 7, 83, 2, 2, 533, 535, 7, 84,
	2, 2, 534, 533, 3, 2, 2, 2, 534, 535, 3, 2, 2, 2, 535, 536, 3, 2, 2, 2,
	536, 537, 5, 138, 70, 2, 537, 538, 7, 18, 2, 2, 538, 539, 5, 138, 70, 2,
	539, 540, 7, 19, 2, 2, 540, 541, 7, 34, 2, 2, 541, 542, 5, 136, 69, 2,
	542, 81, 3, 2, 2, 2, 543, 544, 7, 86, 2, 2, 544, 545, 7, 18, 2, 2, 545,
	546, 5, 136, 69, 2, 546, 547, 7, 19, 2, 2, 547, 83, 3, 2, 2, 2, 548, 549,
	7, 87, 2, 2, 549, 550, 7, 34, 2, 2, 550, 551, 5, 136, 69, 2, 551, 85, 3,
	2, 2, 2, 552, 553, 7, 88, 2, 2, 553, 554, 7, 34, 2, 2, 554, 555, 5, 136,
	69, 2, 555, 87, 3, 2, 2, 2, 556, 557, 7, 89, 2, 2, 557, 558, 7, 34, 2,
	2, 558, 559, 5, 136, 69, 2, 559, 89, 3, 2, 2, 2, 560, 561, 7, 90, 2, 2,
	561, 562, 7, 34, 2, 2, 562, 563, 5, 136, 69, 2, 563, 91, 3, 2, 2, 2, 564,
	565, 7, 91, 2, 2, 565, 566, 7, 34, 2, 2, 566, 567, 5, 136, 69, 2, 567,
	93, 3, 2, 2, 2, 568, 569, 7, 92, 2, 2, 569, 570, 5, 136, 69, 2, 570, 571,
	7, 29, 2, 2, 571, 572, 5, 136, 69, 2, 572, 573, 7, 82, 2, 2, 573, 574,
	5, 136, 69, 2, 574, 95, 3, 2, 2, 2, 575, 576, 7, 93, 2, 2, 576, 577, 5,
	136, 69, 2, 577, 578, 7, 29, 2, 2, 578, 579, 5, 136, 69, 2, 579, 580, 7,
	82, 2, 2, 580, 581, 5, 136, 69, 2, 581, 97, 3, 2, 2, 2, 582, 583, 7, 68,
	2, 2, 583, 584, 7, 7, 2, 2, 584, 585, 5, 8, 5, 2, 585, 99, 3, 2, 2, 2,
	586, 587, 7, 51, 2, 2, 587, 588, 7, 122, 2, 2, 588, 101, 3, 2, 2, 2, 589,
	590, 7, 52, 2, 2, 590, 591, 7, 122, 2, 2, 591, 103, 3, 2, 2, 2, 592, 593,
	7, 106, 2, 2, 593, 594, 5, 14, 8, 2, 594, 105, 3, 2, 2, 2, 595, 596, 7,
	107, 2, 2, 596, 597, 5, 14, 8, 2, 597, 107, 3, 2, 2, 2, 598, 600, 7, 30,
	2, 2, 599, 601, 5, 136, 69, 2, 600, 599, 3, 2, 2, 2, 600, 601, 3, 2, 2,
	2, 601, 109, 3, 2, 2, 2, 602, 607, 7, 95, 2, 2, 603, 604, 5, 136, 69, 2,
	604, 605, 7, 29, 2, 2, 605, 606, 5, 136, 69, 2, 606, 608, 3, 2, 2, 2, 607,
	603, 3, 2, 2, 2, 607, 608, 3, 2, 2, 2, 608, 111, 3, 2, 2, 2, 609, 610,
	7, 110, 2, 2, 610, 611, 5, 136, 69, 2, 611, 113, 3, 2, 2, 2, 612, 613,
	7, 117, 2, 2, 613, 614, 5, 136, 69, 2, 614, 115, 3, 2, 2, 2, 615, 616,
	7, 32, 2, 2, 616, 117, 3, 2, 2, 2, 617, 618, 7, 5, 2, 2, 618, 119, 3, 2,
	2, 2, 619, 620, 7, 113, 2, 2, 620, 121, 3, 2, 2, 2, 621, 623, 9, 6, 2,
	2, 622, 621, 3, 2, 2, 2, 622, 623, 3, 2, 2, 2, 623, 624, 3, 2, 2, 2, 624,
	625, 9, 7, 2, 2, 625, 123, 3, 2, 2, 2, 626, 662, 7, 120, 2, 2, 627, 662,
	5, 122, 62, 2, 628, 662, 5, 202, 102, 2, 629, 662, 5, 14, 8, 2, 630, 662,
	5, 150, 76, 2, 631, 662, 5, 148, 75, 2, 632, 662, 5, 152, 77, 2, 633, 662,
	5, 176, 89, 2, 634, 662, 5, 154, 78, 2, 635, 662, 5, 182, 92, 2, 636, 662,
	5, 156, 79, 2, 637, 662, 5, 158, 80, 2, 638, 662, 5, 160, 81, 2, 639, 662,
	5, 162, 82, 2, 640, 662, 5, 164, 83, 2, 641, 662, 5, 166, 84, 2, 642, 662,
	5, 168, 85, 2, 643, 662, 5, 170, 86, 2, 644, 662, 5, 172, 87, 2, 645, 662,
	5, 180, 91, 2, 646, 662, 5, 174, 88, 2, 647, 662, 5, 178, 90, 2, 648, 662,
	5, 184, 93, 2, 649, 662, 5, 186, 94, 2, 650, 662, 5, 188, 95, 2, 651, 662,
	5, 190, 96, 2, 652, 662, 5, 192, 97, 2, 653, 662, 5, 194, 98, 2, 654, 662,
	5, 196, 99, 2, 655, 662, 5, 198, 100, 2, 656, 662, 5, 200, 101, 2, 657,
	658, 7, 18, 2, 2, 658, 659, 5, 136, 69, 2, 659, 660, 7, 19, 2, 2, 660,
	662, 3, 2, 2, 2, 661, 626, 3, 2, 2, 2, 661, 627, 3, 2, 2, 2, 661, 628,
	3, 2, 2, 2, 661, 629, 3, 2, 2, 2, 661, 630, 3, 2, 2, 2, 661, 631, 3, 2,
	2, 2, 661, 632, 3, 2, 2, 2, 661, 633, 3, 2, 2, 2, 661, 634, 3, 2, 2, 2,
	661, 635, 3, 2, 2, 2, 661, 636, 3, 2, 2, 2, 661, 637, 3, 2, 2, 2, 661,
	638, 3, 2, 2, 2, 661, 639, 3, 2, 2, 2, 661, 640, 3, 2, 2, 2, 661, 641,
	3, 2, 2, 2, 661, 642, 3, 2, 2, 2, 661, 643, 3, 2, 2, 2, 661, 644, 3, 2,
	2, 2, 661, 645, 3, 2, 2, 2, 661, 646, 3, 2, 2, 2, 661, 647, 3, 2, 2, 2,
	661, 648, 3, 2, 2, 2, 661, 649, 3, 2, 2, 2, 661, 650, 3, 2, 2, 2, 661,
	651, 3, 2, 2, 2, 661, 652, 3, 2, 2, 2, 661, 653, 3, 2, 2, 2, 661, 654,
	3, 2, 2, 2, 661, 655, 3, 2, 2, 2, 661, 656, 3, 2, 2, 2, 661, 657, 3, 2,
	2, 2, 662, 125, 3, 2, 2, 2, 663, 665, 7, 112, 2, 2, 664, 663, 3, 2, 2,
	2, 664, 665, 3, 2, 2, 2, 665, 667, 3, 2, 2, 2, 666, 668, 9, 6, 2, 2, 667,
	666, 3, 2, 2, 2, 667, 668, 3, 2, 2, 2, 668, 669, 3, 2, 2, 2, 669, 670,
	5, 124, 63, 2, 670, 127, 3, 2, 2, 2, 671, 676, 5, 126, 64, 2, 672, 673,
	7, 109, 2, 2, 673, 675, 5, 126, 64, 2, 674, 672, 3, 2, 2, 2, 675, 678,
	3, 2, 2, 2, 676, 674, 3, 2, 2, 2, 676, 677, 3, 2, 2, 2, 677, 129, 3, 2,
	2, 2, 678, 676, 3, 2, 2, 2, 679, 684, 5, 128, 65, 2, 680, 681, 9, 8, 2,
	2, 681, 683, 5, 128, 65, 2, 682, 680, 3, 2, 2, 2, 683, 686, 3, 2, 2, 2,
	684, 682, 3, 2, 2, 2, 684, 685, 3, 2, 2, 2, 685, 131, 3, 2, 2, 2, 686,
	684, 3, 2, 2, 2, 687, 692, 5, 130, 66, 2, 688, 689, 9, 6, 2, 2, 689, 691,
	5, 130, 66, 2, 690, 688, 3, 2, 2, 2, 691, 694, 3, 2, 2, 2, 692, 690, 3,
	2, 2, 2, 692, 693, 3, 2, 2, 2, 693, 133, 3, 2, 2, 2, 694, 692, 3, 2, 2,
	2, 695, 699, 5, 132, 67, 2, 696, 697, 5, 26, 14, 2, 697, 698, 5, 132, 67,
	2, 698, 700, 3, 2, 2, 2, 699, 696, 3, 2, 2, 2, 699, 700, 3, 2, 2, 2, 700,
	135, 3, 2, 2, 2, 701, 711, 5, 124, 63, 2, 702, 707, 5, 134, 68, 2, 703,
	704, 9, 9, 2, 2, 704, 706, 5, 134, 68, 2, 705, 703, 3, 2, 2, 2, 706, 709,
	3, 2, 2, 2, 707, 705, 3, 2, 2, 2, 707, 708, 3, 2, 2, 2, 708, 711, 3, 2,
	2, 2, 709, 707, 3, 2, 2, 2, 710, 701, 3, 2, 2, 2, 710, 702, 3, 2, 2, 2,
	711, 137, 3, 2, 2, 2, 712, 714, 5, 140, 71, 2, 713, 715, 5, 142, 72, 2,
	714, 713, 3, 2, 2, 2, 714, 715, 3, 2, 2, 2, 715, 139, 3, 2, 2, 2, 716,
	720, 7, 121, 2, 2, 717, 719, 9, 10, 2, 2, 718, 717, 3, 2, 2, 2, 719, 722,
	3, 2, 2, 2, 720, 718, 3, 2, 2, 2, 720, 721, 3, 2, 2, 2, 721, 141, 3, 2,
	2, 2, 722, 720, 3, 2, 2, 2, 723, 724, 9, 11, 2, 2, 724, 143, 3, 2, 2, 2,
	725, 730, 5, 14, 8, 2, 726, 727, 7, 29, 2, 2, 727, 729, 5, 14, 8, 2, 728,
	726, 3, 2, 2, 2, 729, 732, 3, 2, 2, 2, 730, 728, 3, 2, 2, 2, 730, 731,
	3, 2, 2, 2, 731, 145, 3, 2, 2, 2, 732, 730, 3, 2, 2, 2, 733, 738, 5, 136,
	69, 2, 734, 735, 7, 29, 2, 2, 735, 737, 5, 136, 69, 2, 736, 734, 3, 2,
	2, 2, 737, 740, 3, 2, 2, 2, 738, 736, 3, 2, 2, 2, 738, 739, 3, 2, 2, 2,
	739, 147, 3, 2, 2, 2, 740, 738, 3, 2, 2, 2, 741, 742, 7, 41, 2, 2, 742,
	743, 7, 18, 2, 2, 743, 744, 5, 136, 69, 2, 744, 745, 7, 19, 2, 2, 745,
	149, 3, 2, 2, 2, 746, 747, 7, 13, 2, 2, 747, 748, 7, 18, 2, 2, 748, 749,
	5, 136, 69, 2, 749, 750, 7, 19, 2, 2, 750, 151, 3, 2, 2, 2, 751, 752, 7,
	46, 2, 2, 752, 753, 7, 18, 2, 2, 753, 754, 5, 136, 69, 2, 754, 755, 7,
	19, 2, 2, 755, 153, 3, 2, 2, 2, 756, 757, 7, 48, 2, 2, 757, 758, 7, 18,
	2, 2, 758, 759, 5, 136, 69, 2, 759, 760, 7, 19, 2, 2, 760, 155, 3, 2, 2,
	2, 761, 762, 7, 14, 2, 2, 762, 763, 7, 18, 2, 2, 763, 764, 5, 136, 69,
	2, 764, 765, 7, 29, 2, 2, 765, 766, 5, 136, 69, 2, 766, 767, 7, 29, 2,
	2, 767, 768, 5, 136, 69, 2, 768, 769, 7, 19, 2, 2, 769, 157, 3, 2, 2, 2,
	770, 771, 7, 57, 2, 2, 771, 772, 7, 18, 2, 2, 772, 773, 5, 136, 69, 2,
	773, 774, 7, 19, 2, 2, 774, 159, 3, 2, 2, 2, 775, 776, 7, 59, 2, 2, 776,
	777, 7, 18, 2, 2, 777, 778, 5, 136, 69, 2, 778, 779, 7, 19, 2, 2, 779,
	161, 3, 2, 2, 2, 780, 781, 7, 61, 2, 2, 781, 782, 7, 18, 2, 2, 782, 783,
	5, 136, 69, 2, 783, 784, 7, 19, 2, 2, 784, 163, 3, 2, 2, 2, 785, 786, 7,
	69, 2, 2, 786, 787, 7, 18, 2, 2, 787, 788, 5, 136, 69, 2, 788, 789, 7,
	19, 2, 2, 789, 165, 3, 2, 2, 2, 790, 791, 7, 70, 2, 2, 791, 792, 7, 18,
	2, 2, 792, 793, 5, 136, 69, 2, 793, 794, 7, 19, 2, 2, 794, 167, 3, 2, 2,
	2, 795, 796, 7, 71, 2, 2, 796, 797, 7, 18, 2, 2, 797, 798, 5, 136, 69,
	2, 798, 799, 7, 19, 2, 2, 799, 169, 3, 2, 2, 2, 800, 801, 7, 72, 2, 2,
	801, 802, 7, 18, 2, 2, 802, 803, 5, 136, 69, 2, 803, 804, 7, 19, 2, 2,
	804, 171, 3, 2, 2, 2, 805, 806, 7, 15, 2, 2, 806, 807, 7, 18, 2, 2, 807,
	808, 5, 136, 69, 2, 808, 809, 7, 29, 2, 2, 809, 810, 5, 136, 69, 2, 810,
	811, 7, 19, 2, 2, 811, 173, 3, 2, 2, 2, 812, 813, 7, 16, 2, 2, 813, 814,
	7, 18, 2, 2, 814, 815, 5, 136, 69, 2, 815, 816, 7, 29, 2, 2, 816, 817,
	5, 136, 69, 2, 817, 818, 7, 19, 2, 2, 818, 175, 3, 2, 2, 2, 819, 820, 7,
	17, 2, 2, 820, 821, 7, 18, 2, 2, 821, 822, 5, 136, 69, 2, 822, 823, 7,
	19, 2, 2, 823, 177, 3, 2, 2, 2, 824, 825, 7, 84, 2, 2, 825, 826, 5, 138,
	70, 2, 826, 827, 7, 18, 2, 2, 827, 828, 5, 136, 69, 2, 828, 829, 7, 19,
	2, 2, 829, 179, 3, 2, 2, 2, 830, 831, 7, 85, 2, 2, 831, 832, 7, 18, 2,
	2, 832, 833, 5, 136, 69, 2, 833, 834, 7, 19, 2, 2, 834, 181, 3, 2, 2, 2,
	835, 836, 7, 94, 2, 2, 836, 837, 7, 18, 2, 2, 837, 838, 5, 136, 69, 2,
	838, 839, 7, 29, 2, 2, 839, 840, 5, 136, 69, 2, 840, 841, 7, 19, 2, 2,
	841, 183, 3, 2, 2, 2, 842, 843, 7, 97, 2, 2, 843, 844, 7, 18, 2, 2, 844,
	845, 5, 136, 69, 2, 845, 846, 7, 19, 2, 2, 846, 185, 3, 2, 2, 2, 847, 848,
	7, 98, 2, 2, 848, 849, 7, 18, 2, 2, 849, 850, 5, 136, 69, 2, 850, 851,
	7, 19, 2, 2, 851, 187, 3, 2, 2, 2, 852, 853, 7, 99, 2, 2, 853, 854, 7,
	18, 2, 2, 854, 855, 5, 136, 69, 2, 855, 856, 7, 19, 2, 2, 856, 189, 3,
	2, 2, 2, 857, 858, 7, 100, 2, 2, 858, 859, 7, 18, 2, 2, 859, 860, 5, 136,
	69, 2, 860, 861, 7, 19, 2, 2, 861, 191, 3, 2, 2, 2, 862, 863, 7, 101, 2,
	2, 863, 864, 7, 18, 2, 2, 864, 865, 5, 136, 69, 2, 865, 866, 7, 19, 2,
	2, 866, 193, 3, 2, 2, 2, 867, 868, 7, 102, 2, 2, 868, 869, 7, 18, 2, 2,
	869, 870, 5, 136, 69, 2, 870, 871, 7, 19, 2, 2, 871, 195, 3, 2, 2, 2, 872,
	873, 7, 103, 2, 2, 873, 874, 7, 18, 2, 2, 874, 875, 5, 136, 69, 2, 875,
	876, 7, 19, 2, 2, 876, 197, 3, 2, 2, 2, 877, 878, 7, 104, 2, 2, 878, 879,
	7, 18, 2, 2, 879, 880, 5, 136, 69, 2, 880, 881, 7, 19, 2, 2, 881, 199,
	3, 2, 2, 2, 882, 883, 7, 105, 2, 2, 883, 884, 7, 18, 2, 2, 884, 885, 5,
	136, 69, 2, 885, 886, 7, 19, 2, 2, 886, 201, 3, 2, 2, 2, 887, 888, 7, 86,
	2, 2, 888, 889, 7, 18, 2, 2, 889, 890, 5, 136, 69, 2, 890, 891, 7, 19,
	2, 2, 891, 203, 3, 2, 2, 2, 53, 207, 215, 219, 223, 230, 234, 285, 294,
	299, 304, 308, 315, 337, 345, 349, 359, 364, 366, 376, 384, 387, 392, 421,
	430, 438, 447, 463, 474, 495, 499, 504, 512, 521, 530, 534, 600, 607, 622,
	661, 664, 667, 676, 684, 692, 699, 707, 710, 714, 720, 730, 738,
}
var literalNames = []string{
	"", "'$'", "'%'", "", "", "", "", "", "", "", "", "'CHR$'", "'MID$'", "'LEFT$'",
	"'RIGHT$'", "'STR$'", "'('", "')'", "'+'", "'-'", "'*'", "'/'", "", "'>: '",
	"'<: '", "'>'", "'<'", "','", "", "", "", "", "'='", "", "", "", "", "';'",
	"", "", "':'", "", "", "", "", "", "", "", "", "'PR#'", "'IN#'", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"'^'", "'&'", "", "", "", "", "", "'?'",
}
var symbolicNames = []string{
	"", "DOLLAR", "PERCENT", "RETURN", "PRINT", "GOTO", "GOSUB", "IF", "NEXT",
	"THEN", "REM", "CHR", "MID", "LEFT", "RIGHT", "STR", "LPAREN", "RPAREN",
	"PLUS", "MINUS", "TIMES", "DIV", "CLEAR", "GTE", "LTE", "GT", "LT", "COMMA",
	"LIST", "RUN", "END", "LET", "EQ", "FOR", "TO", "STEP", "INPUT", "SEMICOLON",
	"DIM", "SQR", "COLON", "TEXT", "HGR", "HGR2", "LEN", "CALL", "ASC", "HPLOT",
	"VPLOT", "PRNUMBER", "INNUMBER", "VTAB", "HTAB", "HOME", "ON", "PDL", "PLOT",
	"PEEK", "POKE", "INTF", "STOP", "HIMEM", "LOMEM", "FLASH", "INVERSE", "NORMAL",
	"ONERR", "SPC", "FRE", "POS", "USR", "TRACE", "NOTRACE", "AND", "OR", "DATA",
	"WAIT", "READ", "XDRAW", "DRAW", "AT", "DEF", "FN", "VAL", "TAB", "SPEED",
	"ROT", "SCALE", "COLOR", "HCOLOR", "HLIN", "VLIN", "SCRN", "POP", "SHLOAD",
	"SIN", "COS", "TAN", "ATN", "RND", "SGN", "EXP", "LOG", "ABS", "STORE",
	"RECALL", "GET", "EXPONENT", "AMPERSAND", "GR", "NOT", "RESTORE", "SAVE",
	"LOAD", "QUESTION", "INCLUDE", "CLS", "COMMENT", "STRINGLITERAL", "LETTERS",
	"NUMBER", "FLOAT", "WS",
}

var ruleNames = []string{
	"prog", "line", "amperoper", "linenumber", "amprstmt", "statement", "vardecl",
	"printstmt1", "printlist", "getstmt", "letstmt", "variableassignment",
	"relop", "neq", "ifstmt", "forstmt1", "forstmt2", "nextstmt", "inputstmt",
	"readstmt", "dimstmt", "gotostmt", "gosubstmt", "pokestmt", "callstmt",
	"hplotstmt", "vplotstmt", "plotstmt", "ongotostmt", "ongosubstmt", "vtabstmnt",
	"htabstmnt", "himemstmt", "lomemstmt", "datastmt", "datum", "waitstmt",
	"xdrawstmt", "drawstmt", "defstmt", "tabstmt", "speedstmt", "rotstmt",
	"scalestmt", "colorstmt", "hcolorstmt", "hlinstmt", "vlinstmt", "onerrstmt",
	"prstmt", "instmt", "storestmt", "recallstmt", "liststmt", "popstmt", "amptstmt",
	"includestmt", "endstmt", "returnstmt", "restorestmt", "number", "func_",
	"signExpression", "exponentExpression", "multiplyingExpression", "addingExpression",
	"relationalExpression", "expression", "var_", "varname", "varsuffix", "varlist",
	"exprlist", "sqrfunc", "chrfunc", "lenfunc", "ascfunc", "midfunc", "pdlfunc",
	"peekfunc", "intfunc", "spcfunc", "frefunc", "posfunc", "usrfunc", "leftfunc",
	"rightfunc", "strfunc", "fnfunc", "valfunc", "scrnfunc", "sinfunc", "cosfunc",
	"tanfunc", "atnfunc", "rndfunc", "sgnfunc", "expfunc", "logfunc", "absfunc",
	"tabfunc",
}

type jvmBasicParser struct {
	*antlr.BaseParser
}

// NewjvmBasicParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *jvmBasicParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewjvmBasicParser(input antlr.TokenStream) *jvmBasicParser {
	this := new(jvmBasicParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "jvmBasic.g4"

	return this
}

// jvmBasicParser tokens.
const (
	jvmBasicParserEOF           = antlr.TokenEOF
	jvmBasicParserDOLLAR        = 1
	jvmBasicParserPERCENT       = 2
	jvmBasicParserRETURN        = 3
	jvmBasicParserPRINT         = 4
	jvmBasicParserGOTO          = 5
	jvmBasicParserGOSUB         = 6
	jvmBasicParserIF            = 7
	jvmBasicParserNEXT          = 8
	jvmBasicParserTHEN          = 9
	jvmBasicParserREM           = 10
	jvmBasicParserCHR           = 11
	jvmBasicParserMID           = 12
	jvmBasicParserLEFT          = 13
	jvmBasicParserRIGHT         = 14
	jvmBasicParserSTR           = 15
	jvmBasicParserLPAREN        = 16
	jvmBasicParserRPAREN        = 17
	jvmBasicParserPLUS          = 18
	jvmBasicParserMINUS         = 19
	jvmBasicParserTIMES         = 20
	jvmBasicParserDIV           = 21
	jvmBasicParserCLEAR         = 22
	jvmBasicParserGTE           = 23
	jvmBasicParserLTE           = 24
	jvmBasicParserGT            = 25
	jvmBasicParserLT            = 26
	jvmBasicParserCOMMA         = 27
	jvmBasicParserLIST          = 28
	jvmBasicParserRUN           = 29
	jvmBasicParserEND           = 30
	jvmBasicParserLET           = 31
	jvmBasicParserEQ            = 32
	jvmBasicParserFOR           = 33
	jvmBasicParserTO            = 34
	jvmBasicParserSTEP          = 35
	jvmBasicParserINPUT         = 36
	jvmBasicParserSEMICOLON     = 37
	jvmBasicParserDIM           = 38
	jvmBasicParserSQR           = 39
	jvmBasicParserCOLON         = 40
	jvmBasicParserTEXT          = 41
	jvmBasicParserHGR           = 42
	jvmBasicParserHGR2          = 43
	jvmBasicParserLEN           = 44
	jvmBasicParserCALL          = 45
	jvmBasicParserASC           = 46
	jvmBasicParserHPLOT         = 47
	jvmBasicParserVPLOT         = 48
	jvmBasicParserPRNUMBER      = 49
	jvmBasicParserINNUMBER      = 50
	jvmBasicParserVTAB          = 51
	jvmBasicParserHTAB          = 52
	jvmBasicParserHOME          = 53
	jvmBasicParserON            = 54
	jvmBasicParserPDL           = 55
	jvmBasicParserPLOT          = 56
	jvmBasicParserPEEK          = 57
	jvmBasicParserPOKE          = 58
	jvmBasicParserINTF          = 59
	jvmBasicParserSTOP          = 60
	jvmBasicParserHIMEM         = 61
	jvmBasicParserLOMEM         = 62
	jvmBasicParserFLASH         = 63
	jvmBasicParserINVERSE       = 64
	jvmBasicParserNORMAL        = 65
	jvmBasicParserONERR         = 66
	jvmBasicParserSPC           = 67
	jvmBasicParserFRE           = 68
	jvmBasicParserPOS           = 69
	jvmBasicParserUSR           = 70
	jvmBasicParserTRACE         = 71
	jvmBasicParserNOTRACE       = 72
	jvmBasicParserAND           = 73
	jvmBasicParserOR            = 74
	jvmBasicParserDATA          = 75
	jvmBasicParserWAIT          = 76
	jvmBasicParserREAD          = 77
	jvmBasicParserXDRAW         = 78
	jvmBasicParserDRAW          = 79
	jvmBasicParserAT            = 80
	jvmBasicParserDEF           = 81
	jvmBasicParserFN            = 82
	jvmBasicParserVAL           = 83
	jvmBasicParserTAB           = 84
	jvmBasicParserSPEED         = 85
	jvmBasicParserROT           = 86
	jvmBasicParserSCALE         = 87
	jvmBasicParserCOLOR         = 88
	jvmBasicParserHCOLOR        = 89
	jvmBasicParserHLIN          = 90
	jvmBasicParserVLIN          = 91
	jvmBasicParserSCRN          = 92
	jvmBasicParserPOP           = 93
	jvmBasicParserSHLOAD        = 94
	jvmBasicParserSIN           = 95
	jvmBasicParserCOS           = 96
	jvmBasicParserTAN           = 97
	jvmBasicParserATN           = 98
	jvmBasicParserRND           = 99
	jvmBasicParserSGN           = 100
	jvmBasicParserEXP           = 101
	jvmBasicParserLOG           = 102
	jvmBasicParserABS           = 103
	jvmBasicParserSTORE         = 104
	jvmBasicParserRECALL        = 105
	jvmBasicParserGET           = 106
	jvmBasicParserEXPONENT      = 107
	jvmBasicParserAMPERSAND     = 108
	jvmBasicParserGR            = 109
	jvmBasicParserNOT           = 110
	jvmBasicParserRESTORE       = 111
	jvmBasicParserSAVE          = 112
	jvmBasicParserLOAD          = 113
	jvmBasicParserQUESTION      = 114
	jvmBasicParserINCLUDE       = 115
	jvmBasicParserCLS           = 116
	jvmBasicParserCOMMENT       = 117
	jvmBasicParserSTRINGLITERAL = 118
	jvmBasicParserLETTERS       = 119
	jvmBasicParserNUMBER        = 120
	jvmBasicParserFLOAT         = 121
	jvmBasicParserWS            = 122
)

// jvmBasicParser rules.
const (
	jvmBasicParserRULE_prog                  = 0
	jvmBasicParserRULE_line                  = 1
	jvmBasicParserRULE_amperoper             = 2
	jvmBasicParserRULE_linenumber            = 3
	jvmBasicParserRULE_amprstmt              = 4
	jvmBasicParserRULE_statement             = 5
	jvmBasicParserRULE_vardecl               = 6
	jvmBasicParserRULE_printstmt1            = 7
	jvmBasicParserRULE_printlist             = 8
	jvmBasicParserRULE_getstmt               = 9
	jvmBasicParserRULE_letstmt               = 10
	jvmBasicParserRULE_variableassignment    = 11
	jvmBasicParserRULE_relop                 = 12
	jvmBasicParserRULE_neq                   = 13
	jvmBasicParserRULE_ifstmt                = 14
	jvmBasicParserRULE_forstmt1              = 15
	jvmBasicParserRULE_forstmt2              = 16
	jvmBasicParserRULE_nextstmt              = 17
	jvmBasicParserRULE_inputstmt             = 18
	jvmBasicParserRULE_readstmt              = 19
	jvmBasicParserRULE_dimstmt               = 20
	jvmBasicParserRULE_gotostmt              = 21
	jvmBasicParserRULE_gosubstmt             = 22
	jvmBasicParserRULE_pokestmt              = 23
	jvmBasicParserRULE_callstmt              = 24
	jvmBasicParserRULE_hplotstmt             = 25
	jvmBasicParserRULE_vplotstmt             = 26
	jvmBasicParserRULE_plotstmt              = 27
	jvmBasicParserRULE_ongotostmt            = 28
	jvmBasicParserRULE_ongosubstmt           = 29
	jvmBasicParserRULE_vtabstmnt             = 30
	jvmBasicParserRULE_htabstmnt             = 31
	jvmBasicParserRULE_himemstmt             = 32
	jvmBasicParserRULE_lomemstmt             = 33
	jvmBasicParserRULE_datastmt              = 34
	jvmBasicParserRULE_datum                 = 35
	jvmBasicParserRULE_waitstmt              = 36
	jvmBasicParserRULE_xdrawstmt             = 37
	jvmBasicParserRULE_drawstmt              = 38
	jvmBasicParserRULE_defstmt               = 39
	jvmBasicParserRULE_tabstmt               = 40
	jvmBasicParserRULE_speedstmt             = 41
	jvmBasicParserRULE_rotstmt               = 42
	jvmBasicParserRULE_scalestmt             = 43
	jvmBasicParserRULE_colorstmt             = 44
	jvmBasicParserRULE_hcolorstmt            = 45
	jvmBasicParserRULE_hlinstmt              = 46
	jvmBasicParserRULE_vlinstmt              = 47
	jvmBasicParserRULE_onerrstmt             = 48
	jvmBasicParserRULE_prstmt                = 49
	jvmBasicParserRULE_instmt                = 50
	jvmBasicParserRULE_storestmt             = 51
	jvmBasicParserRULE_recallstmt            = 52
	jvmBasicParserRULE_liststmt              = 53
	jvmBasicParserRULE_popstmt               = 54
	jvmBasicParserRULE_amptstmt              = 55
	jvmBasicParserRULE_includestmt           = 56
	jvmBasicParserRULE_endstmt               = 57
	jvmBasicParserRULE_returnstmt            = 58
	jvmBasicParserRULE_restorestmt           = 59
	jvmBasicParserRULE_number                = 60
	jvmBasicParserRULE_func_                 = 61
	jvmBasicParserRULE_signExpression        = 62
	jvmBasicParserRULE_exponentExpression    = 63
	jvmBasicParserRULE_multiplyingExpression = 64
	jvmBasicParserRULE_addingExpression      = 65
	jvmBasicParserRULE_relationalExpression  = 66
	jvmBasicParserRULE_expression            = 67
	jvmBasicParserRULE_var_                  = 68
	jvmBasicParserRULE_varname               = 69
	jvmBasicParserRULE_varsuffix             = 70
	jvmBasicParserRULE_varlist               = 71
	jvmBasicParserRULE_exprlist              = 72
	jvmBasicParserRULE_sqrfunc               = 73
	jvmBasicParserRULE_chrfunc               = 74
	jvmBasicParserRULE_lenfunc               = 75
	jvmBasicParserRULE_ascfunc               = 76
	jvmBasicParserRULE_midfunc               = 77
	jvmBasicParserRULE_pdlfunc               = 78
	jvmBasicParserRULE_peekfunc              = 79
	jvmBasicParserRULE_intfunc               = 80
	jvmBasicParserRULE_spcfunc               = 81
	jvmBasicParserRULE_frefunc               = 82
	jvmBasicParserRULE_posfunc               = 83
	jvmBasicParserRULE_usrfunc               = 84
	jvmBasicParserRULE_leftfunc              = 85
	jvmBasicParserRULE_rightfunc             = 86
	jvmBasicParserRULE_strfunc               = 87
	jvmBasicParserRULE_fnfunc                = 88
	jvmBasicParserRULE_valfunc               = 89
	jvmBasicParserRULE_scrnfunc              = 90
	jvmBasicParserRULE_sinfunc               = 91
	jvmBasicParserRULE_cosfunc               = 92
	jvmBasicParserRULE_tanfunc               = 93
	jvmBasicParserRULE_atnfunc               = 94
	jvmBasicParserRULE_rndfunc               = 95
	jvmBasicParserRULE_sgnfunc               = 96
	jvmBasicParserRULE_expfunc               = 97
	jvmBasicParserRULE_logfunc               = 98
	jvmBasicParserRULE_absfunc               = 99
	jvmBasicParserRULE_tabfunc               = 100
)

// IProgContext is an interface to support dynamic dispatch.
type IProgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgContext differentiates from other interfaces.
	IsProgContext()
}

type ProgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgContext() *ProgContext {
	var p = new(ProgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_prog
	return p
}

func (*ProgContext) IsProgContext() {}

func NewProgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgContext {
	var p = new(ProgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_prog

	return p
}

func (s *ProgContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgContext) EOF() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserEOF, 0)
}

func (s *ProgContext) AllLine() []ILineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILineContext)(nil)).Elem())
	var tst = make([]ILineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILineContext)
		}
	}

	return tst
}

func (s *ProgContext) Line(i int) ILineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILineContext)
}

func (s *ProgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterProg(s)
	}
}

func (s *ProgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitProg(s)
	}
}

func (p *jvmBasicParser) Prog() (localctx IProgContext) {
	this := p
	_ = this

	localctx = NewProgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, jvmBasicParserRULE_prog)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(203)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == jvmBasicParserNUMBER {
		{
			p.SetState(202)
			p.Line()
		}

		p.SetState(205)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(207)
		p.Match(jvmBasicParserEOF)
	}

	return localctx
}

// ILineContext is an interface to support dynamic dispatch.
type ILineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineContext differentiates from other interfaces.
	IsLineContext()
}

type LineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineContext() *LineContext {
	var p = new(LineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_line
	return p
}

func (*LineContext) IsLineContext() {}

func NewLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineContext {
	var p = new(LineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_line

	return p
}

func (s *LineContext) GetParser() antlr.Parser { return s.parser }

func (s *LineContext) Linenumber() ILinenumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinenumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinenumberContext)
}

func (s *LineContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMENT, 0)
}

func (s *LineContext) REM() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserREM, 0)
}

func (s *LineContext) AllAmprstmt() []IAmprstmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAmprstmtContext)(nil)).Elem())
	var tst = make([]IAmprstmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAmprstmtContext)
		}
	}

	return tst
}

func (s *LineContext) Amprstmt(i int) IAmprstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmprstmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAmprstmtContext)
}

func (s *LineContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserCOLON)
}

func (s *LineContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOLON, i)
}

func (s *LineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterLine(s)
	}
}

func (s *LineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitLine(s)
	}
}

func (p *jvmBasicParser) Line() (localctx ILineContext) {
	this := p
	_ = this

	localctx = NewLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, jvmBasicParserRULE_line)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(209)
		p.Linenumber()
	}
	p.SetState(221)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(210)
			p.Amprstmt()
		}
		p.SetState(217)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == jvmBasicParserCOLON {
			{
				p.SetState(211)
				p.Match(jvmBasicParserCOLON)
			}
			p.SetState(213)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<jvmBasicParserRETURN)|(1<<jvmBasicParserPRINT)|(1<<jvmBasicParserGOTO)|(1<<jvmBasicParserGOSUB)|(1<<jvmBasicParserIF)|(1<<jvmBasicParserNEXT)|(1<<jvmBasicParserREM)|(1<<jvmBasicParserCLEAR)|(1<<jvmBasicParserLIST)|(1<<jvmBasicParserRUN)|(1<<jvmBasicParserEND)|(1<<jvmBasicParserLET))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(jvmBasicParserFOR-33))|(1<<(jvmBasicParserINPUT-33))|(1<<(jvmBasicParserDIM-33))|(1<<(jvmBasicParserTEXT-33))|(1<<(jvmBasicParserHGR-33))|(1<<(jvmBasicParserHGR2-33))|(1<<(jvmBasicParserCALL-33))|(1<<(jvmBasicParserHPLOT-33))|(1<<(jvmBasicParserVPLOT-33))|(1<<(jvmBasicParserPRNUMBER-33))|(1<<(jvmBasicParserINNUMBER-33))|(1<<(jvmBasicParserVTAB-33))|(1<<(jvmBasicParserHTAB-33))|(1<<(jvmBasicParserHOME-33))|(1<<(jvmBasicParserON-33))|(1<<(jvmBasicParserPLOT-33))|(1<<(jvmBasicParserPOKE-33))|(1<<(jvmBasicParserSTOP-33))|(1<<(jvmBasicParserHIMEM-33))|(1<<(jvmBasicParserLOMEM-33))|(1<<(jvmBasicParserFLASH-33))|(1<<(jvmBasicParserINVERSE-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(jvmBasicParserNORMAL-65))|(1<<(jvmBasicParserONERR-65))|(1<<(jvmBasicParserTRACE-65))|(1<<(jvmBasicParserNOTRACE-65))|(1<<(jvmBasicParserDATA-65))|(1<<(jvmBasicParserWAIT-65))|(1<<(jvmBasicParserREAD-65))|(1<<(jvmBasicParserXDRAW-65))|(1<<(jvmBasicParserDRAW-65))|(1<<(jvmBasicParserDEF-65))|(1<<(jvmBasicParserTAB-65))|(1<<(jvmBasicParserSPEED-65))|(1<<(jvmBasicParserROT-65))|(1<<(jvmBasicParserSCALE-65))|(1<<(jvmBasicParserCOLOR-65))|(1<<(jvmBasicParserHCOLOR-65))|(1<<(jvmBasicParserHLIN-65))|(1<<(jvmBasicParserVLIN-65))|(1<<(jvmBasicParserPOP-65))|(1<<(jvmBasicParserSHLOAD-65)))) != 0) || (((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(jvmBasicParserSTORE-104))|(1<<(jvmBasicParserRECALL-104))|(1<<(jvmBasicParserGET-104))|(1<<(jvmBasicParserAMPERSAND-104))|(1<<(jvmBasicParserGR-104))|(1<<(jvmBasicParserRESTORE-104))|(1<<(jvmBasicParserSAVE-104))|(1<<(jvmBasicParserLOAD-104))|(1<<(jvmBasicParserQUESTION-104))|(1<<(jvmBasicParserINCLUDE-104))|(1<<(jvmBasicParserCLS-104))|(1<<(jvmBasicParserCOMMENT-104))|(1<<(jvmBasicParserLETTERS-104)))) != 0) {
				{
					p.SetState(212)
					p.Amprstmt()
				}

			}

			p.SetState(219)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(220)
			_la = p.GetTokenStream().LA(1)

			if !(_la == jvmBasicParserREM || _la == jvmBasicParserCOMMENT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IAmperoperContext is an interface to support dynamic dispatch.
type IAmperoperContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAmperoperContext differentiates from other interfaces.
	IsAmperoperContext()
}

type AmperoperContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAmperoperContext() *AmperoperContext {
	var p = new(AmperoperContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_amperoper
	return p
}

func (*AmperoperContext) IsAmperoperContext() {}

func NewAmperoperContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AmperoperContext {
	var p = new(AmperoperContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_amperoper

	return p
}

func (s *AmperoperContext) GetParser() antlr.Parser { return s.parser }

func (s *AmperoperContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserAMPERSAND, 0)
}

func (s *AmperoperContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AmperoperContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AmperoperContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterAmperoper(s)
	}
}

func (s *AmperoperContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitAmperoper(s)
	}
}

func (p *jvmBasicParser) Amperoper() (localctx IAmperoperContext) {
	this := p
	_ = this

	localctx = NewAmperoperContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, jvmBasicParserRULE_amperoper)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(223)
		p.Match(jvmBasicParserAMPERSAND)
	}

	return localctx
}

// ILinenumberContext is an interface to support dynamic dispatch.
type ILinenumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinenumberContext differentiates from other interfaces.
	IsLinenumberContext()
}

type LinenumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinenumberContext() *LinenumberContext {
	var p = new(LinenumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_linenumber
	return p
}

func (*LinenumberContext) IsLinenumberContext() {}

func NewLinenumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinenumberContext {
	var p = new(LinenumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_linenumber

	return p
}

func (s *LinenumberContext) GetParser() antlr.Parser { return s.parser }

func (s *LinenumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserNUMBER, 0)
}

func (s *LinenumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinenumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinenumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterLinenumber(s)
	}
}

func (s *LinenumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitLinenumber(s)
	}
}

func (p *jvmBasicParser) Linenumber() (localctx ILinenumberContext) {
	this := p
	_ = this

	localctx = NewLinenumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, jvmBasicParserRULE_linenumber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(225)
		p.Match(jvmBasicParserNUMBER)
	}

	return localctx
}

// IAmprstmtContext is an interface to support dynamic dispatch.
type IAmprstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAmprstmtContext differentiates from other interfaces.
	IsAmprstmtContext()
}

type AmprstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAmprstmtContext() *AmprstmtContext {
	var p = new(AmprstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_amprstmt
	return p
}

func (*AmprstmtContext) IsAmprstmtContext() {}

func NewAmprstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AmprstmtContext {
	var p = new(AmprstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_amprstmt

	return p
}

func (s *AmprstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AmprstmtContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *AmprstmtContext) Amperoper() IAmperoperContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmperoperContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmperoperContext)
}

func (s *AmprstmtContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMENT, 0)
}

func (s *AmprstmtContext) REM() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserREM, 0)
}

func (s *AmprstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AmprstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AmprstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterAmprstmt(s)
	}
}

func (s *AmprstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitAmprstmt(s)
	}
}

func (p *jvmBasicParser) Amprstmt() (localctx IAmprstmtContext) {
	this := p
	_ = this

	localctx = NewAmprstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, jvmBasicParserRULE_amprstmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(232)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jvmBasicParserRETURN, jvmBasicParserPRINT, jvmBasicParserGOTO, jvmBasicParserGOSUB, jvmBasicParserIF, jvmBasicParserNEXT, jvmBasicParserCLEAR, jvmBasicParserLIST, jvmBasicParserRUN, jvmBasicParserEND, jvmBasicParserLET, jvmBasicParserFOR, jvmBasicParserINPUT, jvmBasicParserDIM, jvmBasicParserTEXT, jvmBasicParserHGR, jvmBasicParserHGR2, jvmBasicParserCALL, jvmBasicParserHPLOT, jvmBasicParserVPLOT, jvmBasicParserPRNUMBER, jvmBasicParserINNUMBER, jvmBasicParserVTAB, jvmBasicParserHTAB, jvmBasicParserHOME, jvmBasicParserON, jvmBasicParserPLOT, jvmBasicParserPOKE, jvmBasicParserSTOP, jvmBasicParserHIMEM, jvmBasicParserLOMEM, jvmBasicParserFLASH, jvmBasicParserINVERSE, jvmBasicParserNORMAL, jvmBasicParserONERR, jvmBasicParserTRACE, jvmBasicParserNOTRACE, jvmBasicParserDATA, jvmBasicParserWAIT, jvmBasicParserREAD, jvmBasicParserXDRAW, jvmBasicParserDRAW, jvmBasicParserDEF, jvmBasicParserTAB, jvmBasicParserSPEED, jvmBasicParserROT, jvmBasicParserSCALE, jvmBasicParserCOLOR, jvmBasicParserHCOLOR, jvmBasicParserHLIN, jvmBasicParserVLIN, jvmBasicParserPOP, jvmBasicParserSHLOAD, jvmBasicParserSTORE, jvmBasicParserRECALL, jvmBasicParserGET, jvmBasicParserAMPERSAND, jvmBasicParserGR, jvmBasicParserRESTORE, jvmBasicParserSAVE, jvmBasicParserLOAD, jvmBasicParserQUESTION, jvmBasicParserINCLUDE, jvmBasicParserCLS, jvmBasicParserLETTERS:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(228)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(227)
				p.Amperoper()
			}

		}
		{
			p.SetState(230)
			p.Statement()
		}

	case jvmBasicParserREM, jvmBasicParserCOMMENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(231)
			_la = p.GetTokenStream().LA(1)

			if !(_la == jvmBasicParserREM || _la == jvmBasicParserCOMMENT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CLS() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCLS, 0)
}

func (s *StatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLOAD, 0)
}

func (s *StatementContext) SAVE() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSAVE, 0)
}

func (s *StatementContext) TRACE() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserTRACE, 0)
}

func (s *StatementContext) NOTRACE() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserNOTRACE, 0)
}

func (s *StatementContext) FLASH() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserFLASH, 0)
}

func (s *StatementContext) INVERSE() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserINVERSE, 0)
}

func (s *StatementContext) GR() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserGR, 0)
}

func (s *StatementContext) NORMAL() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserNORMAL, 0)
}

func (s *StatementContext) SHLOAD() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSHLOAD, 0)
}

func (s *StatementContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCLEAR, 0)
}

func (s *StatementContext) RUN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRUN, 0)
}

func (s *StatementContext) STOP() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSTOP, 0)
}

func (s *StatementContext) TEXT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserTEXT, 0)
}

func (s *StatementContext) HOME() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserHOME, 0)
}

func (s *StatementContext) HGR() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserHGR, 0)
}

func (s *StatementContext) HGR2() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserHGR2, 0)
}

func (s *StatementContext) Endstmt() IEndstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndstmtContext)
}

func (s *StatementContext) Returnstmt() IReturnstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnstmtContext)
}

func (s *StatementContext) Restorestmt() IRestorestmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRestorestmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRestorestmtContext)
}

func (s *StatementContext) Amptstmt() IAmptstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmptstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmptstmtContext)
}

func (s *StatementContext) Popstmt() IPopstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPopstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPopstmtContext)
}

func (s *StatementContext) Liststmt() IListstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListstmtContext)
}

func (s *StatementContext) Storestmt() IStorestmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStorestmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStorestmtContext)
}

func (s *StatementContext) Getstmt() IGetstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGetstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGetstmtContext)
}

func (s *StatementContext) Recallstmt() IRecallstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecallstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecallstmtContext)
}

func (s *StatementContext) Nextstmt() INextstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INextstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INextstmtContext)
}

func (s *StatementContext) Instmt() IInstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstmtContext)
}

func (s *StatementContext) Prstmt() IPrstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrstmtContext)
}

func (s *StatementContext) Onerrstmt() IOnerrstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnerrstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnerrstmtContext)
}

func (s *StatementContext) Hlinstmt() IHlinstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHlinstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHlinstmtContext)
}

func (s *StatementContext) Vlinstmt() IVlinstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVlinstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVlinstmtContext)
}

func (s *StatementContext) Colorstmt() IColorstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColorstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColorstmtContext)
}

func (s *StatementContext) Speedstmt() ISpeedstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpeedstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpeedstmtContext)
}

func (s *StatementContext) Scalestmt() IScalestmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScalestmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScalestmtContext)
}

func (s *StatementContext) Rotstmt() IRotstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRotstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRotstmtContext)
}

func (s *StatementContext) Hcolorstmt() IHcolorstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHcolorstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHcolorstmtContext)
}

func (s *StatementContext) Himemstmt() IHimemstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHimemstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHimemstmtContext)
}

func (s *StatementContext) Lomemstmt() ILomemstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILomemstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILomemstmtContext)
}

func (s *StatementContext) Printstmt1() IPrintstmt1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrintstmt1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrintstmt1Context)
}

func (s *StatementContext) Pokestmt() IPokestmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPokestmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPokestmtContext)
}

func (s *StatementContext) Plotstmt() IPlotstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPlotstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPlotstmtContext)
}

func (s *StatementContext) Ongotostmt() IOngotostmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOngotostmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOngotostmtContext)
}

func (s *StatementContext) Ongosubstmt() IOngosubstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOngosubstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOngosubstmtContext)
}

func (s *StatementContext) Ifstmt() IIfstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfstmtContext)
}

func (s *StatementContext) Forstmt1() IForstmt1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForstmt1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForstmt1Context)
}

func (s *StatementContext) Forstmt2() IForstmt2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForstmt2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForstmt2Context)
}

func (s *StatementContext) Inputstmt() IInputstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInputstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInputstmtContext)
}

func (s *StatementContext) Tabstmt() ITabstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITabstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITabstmtContext)
}

func (s *StatementContext) Dimstmt() IDimstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimstmtContext)
}

func (s *StatementContext) Gotostmt() IGotostmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGotostmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGotostmtContext)
}

func (s *StatementContext) Gosubstmt() IGosubstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGosubstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGosubstmtContext)
}

func (s *StatementContext) Callstmt() ICallstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallstmtContext)
}

func (s *StatementContext) Readstmt() IReadstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadstmtContext)
}

func (s *StatementContext) Hplotstmt() IHplotstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHplotstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHplotstmtContext)
}

func (s *StatementContext) Vplotstmt() IVplotstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVplotstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVplotstmtContext)
}

func (s *StatementContext) Vtabstmnt() IVtabstmntContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVtabstmntContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVtabstmntContext)
}

func (s *StatementContext) Htabstmnt() IHtabstmntContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtabstmntContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtabstmntContext)
}

func (s *StatementContext) Waitstmt() IWaitstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWaitstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWaitstmtContext)
}

func (s *StatementContext) Datastmt() IDatastmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatastmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatastmtContext)
}

func (s *StatementContext) Xdrawstmt() IXdrawstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXdrawstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IXdrawstmtContext)
}

func (s *StatementContext) Drawstmt() IDrawstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrawstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrawstmtContext)
}

func (s *StatementContext) Defstmt() IDefstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefstmtContext)
}

func (s *StatementContext) Letstmt() ILetstmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILetstmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILetstmtContext)
}

func (s *StatementContext) Includestmt() IIncludestmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIncludestmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIncludestmtContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *jvmBasicParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, jvmBasicParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(283)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(234)
			_la = p.GetTokenStream().LA(1)

			if !(_la == jvmBasicParserCLEAR || _la == jvmBasicParserRUN || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(jvmBasicParserTEXT-41))|(1<<(jvmBasicParserHGR-41))|(1<<(jvmBasicParserHGR2-41))|(1<<(jvmBasicParserHOME-41))|(1<<(jvmBasicParserSTOP-41))|(1<<(jvmBasicParserFLASH-41))|(1<<(jvmBasicParserINVERSE-41))|(1<<(jvmBasicParserNORMAL-41))|(1<<(jvmBasicParserTRACE-41))|(1<<(jvmBasicParserNOTRACE-41)))) != 0) || (((_la-94)&-(0x1f+1)) == 0 && ((1<<uint((_la-94)))&((1<<(jvmBasicParserSHLOAD-94))|(1<<(jvmBasicParserGR-94))|(1<<(jvmBasicParserSAVE-94))|(1<<(jvmBasicParserLOAD-94))|(1<<(jvmBasicParserCLS-94)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(235)
			p.Endstmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(236)
			p.Returnstmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(237)
			p.Restorestmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(238)
			p.Amptstmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(239)
			p.Popstmt()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(240)
			p.Liststmt()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(241)
			p.Storestmt()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(242)
			p.Getstmt()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(243)
			p.Recallstmt()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(244)
			p.Nextstmt()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(245)
			p.Instmt()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(246)
			p.Prstmt()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(247)
			p.Onerrstmt()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(248)
			p.Hlinstmt()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(249)
			p.Vlinstmt()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(250)
			p.Colorstmt()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(251)
			p.Speedstmt()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(252)
			p.Scalestmt()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(253)
			p.Rotstmt()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(254)
			p.Hcolorstmt()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(255)
			p.Himemstmt()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(256)
			p.Lomemstmt()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(257)
			p.Printstmt1()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(258)
			p.Pokestmt()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(259)
			p.Plotstmt()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(260)
			p.Ongotostmt()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(261)
			p.Ongosubstmt()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(262)
			p.Ifstmt()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(263)
			p.Forstmt1()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(264)
			p.Forstmt2()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(265)
			p.Inputstmt()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(266)
			p.Tabstmt()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(267)
			p.Dimstmt()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(268)
			p.Gotostmt()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(269)
			p.Gosubstmt()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(270)
			p.Callstmt()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(271)
			p.Readstmt()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(272)
			p.Hplotstmt()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(273)
			p.Vplotstmt()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(274)
			p.Vtabstmnt()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(275)
			p.Htabstmnt()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(276)
			p.Waitstmt()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(277)
			p.Datastmt()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(278)
			p.Xdrawstmt()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(279)
			p.Drawstmt()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(280)
			p.Defstmt()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(281)
			p.Letstmt()
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(282)
			p.Includestmt()
		}

	}

	return localctx
}

// IVardeclContext is an interface to support dynamic dispatch.
type IVardeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVardeclContext differentiates from other interfaces.
	IsVardeclContext()
}

type VardeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVardeclContext() *VardeclContext {
	var p = new(VardeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_vardecl
	return p
}

func (*VardeclContext) IsVardeclContext() {}

func NewVardeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VardeclContext {
	var p = new(VardeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_vardecl

	return p
}

func (s *VardeclContext) GetParser() antlr.Parser { return s.parser }

func (s *VardeclContext) Var_() IVar_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVar_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVar_Context)
}

func (s *VardeclContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserLPAREN)
}

func (s *VardeclContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, i)
}

func (s *VardeclContext) AllExprlist() []IExprlistContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprlistContext)(nil)).Elem())
	var tst = make([]IExprlistContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprlistContext)
		}
	}

	return tst
}

func (s *VardeclContext) Exprlist(i int) IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *VardeclContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserRPAREN)
}

func (s *VardeclContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, i)
}

func (s *VardeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VardeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VardeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterVardecl(s)
	}
}

func (s *VardeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitVardecl(s)
	}
}

func (p *jvmBasicParser) Vardecl() (localctx IVardeclContext) {
	this := p
	_ = this

	localctx = NewVardeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, jvmBasicParserRULE_vardecl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(285)
		p.Var_()
	}
	p.SetState(292)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jvmBasicParserLPAREN {
		{
			p.SetState(286)
			p.Match(jvmBasicParserLPAREN)
		}
		{
			p.SetState(287)
			p.Exprlist()
		}
		{
			p.SetState(288)
			p.Match(jvmBasicParserRPAREN)
		}

		p.SetState(294)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPrintstmt1Context is an interface to support dynamic dispatch.
type IPrintstmt1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrintstmt1Context differentiates from other interfaces.
	IsPrintstmt1Context()
}

type Printstmt1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrintstmt1Context() *Printstmt1Context {
	var p = new(Printstmt1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_printstmt1
	return p
}

func (*Printstmt1Context) IsPrintstmt1Context() {}

func NewPrintstmt1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Printstmt1Context {
	var p = new(Printstmt1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_printstmt1

	return p
}

func (s *Printstmt1Context) GetParser() antlr.Parser { return s.parser }

func (s *Printstmt1Context) PRINT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserPRINT, 0)
}

func (s *Printstmt1Context) QUESTION() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserQUESTION, 0)
}

func (s *Printstmt1Context) Printlist() IPrintlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrintlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrintlistContext)
}

func (s *Printstmt1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Printstmt1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Printstmt1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterPrintstmt1(s)
	}
}

func (s *Printstmt1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitPrintstmt1(s)
	}
}

func (p *jvmBasicParser) Printstmt1() (localctx IPrintstmt1Context) {
	this := p
	_ = this

	localctx = NewPrintstmt1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, jvmBasicParserRULE_printstmt1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(295)
		_la = p.GetTokenStream().LA(1)

		if !(_la == jvmBasicParserPRINT || _la == jvmBasicParserQUESTION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(297)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(296)
			p.Printlist()
		}

	}

	return localctx
}

// IPrintlistContext is an interface to support dynamic dispatch.
type IPrintlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrintlistContext differentiates from other interfaces.
	IsPrintlistContext()
}

type PrintlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrintlistContext() *PrintlistContext {
	var p = new(PrintlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_printlist
	return p
}

func (*PrintlistContext) IsPrintlistContext() {}

func NewPrintlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrintlistContext {
	var p = new(PrintlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_printlist

	return p
}

func (s *PrintlistContext) GetParser() antlr.Parser { return s.parser }

func (s *PrintlistContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *PrintlistContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrintlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserCOMMA)
}

func (s *PrintlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, i)
}

func (s *PrintlistContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserSEMICOLON)
}

func (s *PrintlistContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSEMICOLON, i)
}

func (s *PrintlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrintlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterPrintlist(s)
	}
}

func (s *PrintlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitPrintlist(s)
	}
}

func (p *jvmBasicParser) Printlist() (localctx IPrintlistContext) {
	this := p
	_ = this

	localctx = NewPrintlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, jvmBasicParserRULE_printlist)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(299)
		p.Expression()
	}
	p.SetState(306)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jvmBasicParserCOMMA || _la == jvmBasicParserSEMICOLON {
		{
			p.SetState(300)
			_la = p.GetTokenStream().LA(1)

			if !(_la == jvmBasicParserCOMMA || _la == jvmBasicParserSEMICOLON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(302)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(301)
				p.Expression()
			}

		}

		p.SetState(308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGetstmtContext is an interface to support dynamic dispatch.
type IGetstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGetstmtContext differentiates from other interfaces.
	IsGetstmtContext()
}

type GetstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetstmtContext() *GetstmtContext {
	var p = new(GetstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_getstmt
	return p
}

func (*GetstmtContext) IsGetstmtContext() {}

func NewGetstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetstmtContext {
	var p = new(GetstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_getstmt

	return p
}

func (s *GetstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GetstmtContext) GET() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserGET, 0)
}

func (s *GetstmtContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *GetstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterGetstmt(s)
	}
}

func (s *GetstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitGetstmt(s)
	}
}

func (p *jvmBasicParser) Getstmt() (localctx IGetstmtContext) {
	this := p
	_ = this

	localctx = NewGetstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, jvmBasicParserRULE_getstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(309)
		p.Match(jvmBasicParserGET)
	}
	{
		p.SetState(310)
		p.Exprlist()
	}

	return localctx
}

// ILetstmtContext is an interface to support dynamic dispatch.
type ILetstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLetstmtContext differentiates from other interfaces.
	IsLetstmtContext()
}

type LetstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetstmtContext() *LetstmtContext {
	var p = new(LetstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_letstmt
	return p
}

func (*LetstmtContext) IsLetstmtContext() {}

func NewLetstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetstmtContext {
	var p = new(LetstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_letstmt

	return p
}

func (s *LetstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *LetstmtContext) Variableassignment() IVariableassignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableassignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableassignmentContext)
}

func (s *LetstmtContext) LET() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLET, 0)
}

func (s *LetstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterLetstmt(s)
	}
}

func (s *LetstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitLetstmt(s)
	}
}

func (p *jvmBasicParser) Letstmt() (localctx ILetstmtContext) {
	this := p
	_ = this

	localctx = NewLetstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, jvmBasicParserRULE_letstmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(313)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jvmBasicParserLET {
		{
			p.SetState(312)
			p.Match(jvmBasicParserLET)
		}

	}
	{
		p.SetState(315)
		p.Variableassignment()
	}

	return localctx
}

// IVariableassignmentContext is an interface to support dynamic dispatch.
type IVariableassignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableassignmentContext differentiates from other interfaces.
	IsVariableassignmentContext()
}

type VariableassignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableassignmentContext() *VariableassignmentContext {
	var p = new(VariableassignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_variableassignment
	return p
}

func (*VariableassignmentContext) IsVariableassignmentContext() {}

func NewVariableassignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableassignmentContext {
	var p = new(VariableassignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_variableassignment

	return p
}

func (s *VariableassignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableassignmentContext) Vardecl() IVardeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVardeclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *VariableassignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserEQ, 0)
}

func (s *VariableassignmentContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *VariableassignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableassignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableassignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterVariableassignment(s)
	}
}

func (s *VariableassignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitVariableassignment(s)
	}
}

func (p *jvmBasicParser) Variableassignment() (localctx IVariableassignmentContext) {
	this := p
	_ = this

	localctx = NewVariableassignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, jvmBasicParserRULE_variableassignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(317)
		p.Vardecl()
	}
	{
		p.SetState(318)
		p.Match(jvmBasicParserEQ)
	}
	{
		p.SetState(319)
		p.Exprlist()
	}

	return localctx
}

// IRelopContext is an interface to support dynamic dispatch.
type IRelopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelopContext differentiates from other interfaces.
	IsRelopContext()
}

type RelopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelopContext() *RelopContext {
	var p = new(RelopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_relop
	return p
}

func (*RelopContext) IsRelopContext() {}

func NewRelopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelopContext {
	var p = new(RelopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_relop

	return p
}

func (s *RelopContext) GetParser() antlr.Parser { return s.parser }

func (s *RelopContext) GTE() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserGTE, 0)
}

func (s *RelopContext) GT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserGT, 0)
}

func (s *RelopContext) EQ() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserEQ, 0)
}

func (s *RelopContext) LTE() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLTE, 0)
}

func (s *RelopContext) LT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLT, 0)
}

func (s *RelopContext) Neq() INeqContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INeqContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INeqContext)
}

func (s *RelopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterRelop(s)
	}
}

func (s *RelopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitRelop(s)
	}
}

func (p *jvmBasicParser) Relop() (localctx IRelopContext) {
	this := p
	_ = this

	localctx = NewRelopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, jvmBasicParserRULE_relop)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(335)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(321)
			p.Match(jvmBasicParserGTE)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(322)
			p.Match(jvmBasicParserGT)
		}
		{
			p.SetState(323)
			p.Match(jvmBasicParserEQ)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(324)
			p.Match(jvmBasicParserEQ)
		}
		{
			p.SetState(325)
			p.Match(jvmBasicParserGT)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(326)
			p.Match(jvmBasicParserLTE)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(327)
			p.Match(jvmBasicParserLT)
		}
		{
			p.SetState(328)
			p.Match(jvmBasicParserEQ)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(329)
			p.Match(jvmBasicParserEQ)
		}
		{
			p.SetState(330)
			p.Match(jvmBasicParserLT)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(331)
			p.Neq()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(332)
			p.Match(jvmBasicParserEQ)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(333)
			p.Match(jvmBasicParserGT)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(334)
			p.Match(jvmBasicParserLT)
		}

	}

	return localctx
}

// INeqContext is an interface to support dynamic dispatch.
type INeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNeqContext differentiates from other interfaces.
	IsNeqContext()
}

type NeqContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNeqContext() *NeqContext {
	var p = new(NeqContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_neq
	return p
}

func (*NeqContext) IsNeqContext() {}

func NewNeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NeqContext {
	var p = new(NeqContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_neq

	return p
}

func (s *NeqContext) GetParser() antlr.Parser { return s.parser }

func (s *NeqContext) LT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLT, 0)
}

func (s *NeqContext) GT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserGT, 0)
}

func (s *NeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterNeq(s)
	}
}

func (s *NeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitNeq(s)
	}
}

func (p *jvmBasicParser) Neq() (localctx INeqContext) {
	this := p
	_ = this

	localctx = NewNeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, jvmBasicParserRULE_neq)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(337)
		p.Match(jvmBasicParserLT)
	}
	{
		p.SetState(338)
		p.Match(jvmBasicParserGT)
	}

	return localctx
}

// IIfstmtContext is an interface to support dynamic dispatch.
type IIfstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfstmtContext differentiates from other interfaces.
	IsIfstmtContext()
}

type IfstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfstmtContext() *IfstmtContext {
	var p = new(IfstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_ifstmt
	return p
}

func (*IfstmtContext) IsIfstmtContext() {}

func NewIfstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfstmtContext {
	var p = new(IfstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_ifstmt

	return p
}

func (s *IfstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfstmtContext) IF() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserIF, 0)
}

func (s *IfstmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfstmtContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfstmtContext) Linenumber() ILinenumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinenumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinenumberContext)
}

func (s *IfstmtContext) THEN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserTHEN, 0)
}

func (s *IfstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterIfstmt(s)
	}
}

func (s *IfstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitIfstmt(s)
	}
}

func (p *jvmBasicParser) Ifstmt() (localctx IIfstmtContext) {
	this := p
	_ = this

	localctx = NewIfstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, jvmBasicParserRULE_ifstmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(340)
		p.Match(jvmBasicParserIF)
	}
	{
		p.SetState(341)
		p.Expression()
	}
	p.SetState(343)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jvmBasicParserTHEN {
		{
			p.SetState(342)
			p.Match(jvmBasicParserTHEN)
		}

	}
	p.SetState(347)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jvmBasicParserRETURN, jvmBasicParserPRINT, jvmBasicParserGOTO, jvmBasicParserGOSUB, jvmBasicParserIF, jvmBasicParserNEXT, jvmBasicParserCLEAR, jvmBasicParserLIST, jvmBasicParserRUN, jvmBasicParserEND, jvmBasicParserLET, jvmBasicParserFOR, jvmBasicParserINPUT, jvmBasicParserDIM, jvmBasicParserTEXT, jvmBasicParserHGR, jvmBasicParserHGR2, jvmBasicParserCALL, jvmBasicParserHPLOT, jvmBasicParserVPLOT, jvmBasicParserPRNUMBER, jvmBasicParserINNUMBER, jvmBasicParserVTAB, jvmBasicParserHTAB, jvmBasicParserHOME, jvmBasicParserON, jvmBasicParserPLOT, jvmBasicParserPOKE, jvmBasicParserSTOP, jvmBasicParserHIMEM, jvmBasicParserLOMEM, jvmBasicParserFLASH, jvmBasicParserINVERSE, jvmBasicParserNORMAL, jvmBasicParserONERR, jvmBasicParserTRACE, jvmBasicParserNOTRACE, jvmBasicParserDATA, jvmBasicParserWAIT, jvmBasicParserREAD, jvmBasicParserXDRAW, jvmBasicParserDRAW, jvmBasicParserDEF, jvmBasicParserTAB, jvmBasicParserSPEED, jvmBasicParserROT, jvmBasicParserSCALE, jvmBasicParserCOLOR, jvmBasicParserHCOLOR, jvmBasicParserHLIN, jvmBasicParserVLIN, jvmBasicParserPOP, jvmBasicParserSHLOAD, jvmBasicParserSTORE, jvmBasicParserRECALL, jvmBasicParserGET, jvmBasicParserAMPERSAND, jvmBasicParserGR, jvmBasicParserRESTORE, jvmBasicParserSAVE, jvmBasicParserLOAD, jvmBasicParserQUESTION, jvmBasicParserINCLUDE, jvmBasicParserCLS, jvmBasicParserLETTERS:
		{
			p.SetState(345)
			p.Statement()
		}

	case jvmBasicParserNUMBER:
		{
			p.SetState(346)
			p.Linenumber()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForstmt1Context is an interface to support dynamic dispatch.
type IForstmt1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForstmt1Context differentiates from other interfaces.
	IsForstmt1Context()
}

type Forstmt1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForstmt1Context() *Forstmt1Context {
	var p = new(Forstmt1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_forstmt1
	return p
}

func (*Forstmt1Context) IsForstmt1Context() {}

func NewForstmt1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Forstmt1Context {
	var p = new(Forstmt1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_forstmt1

	return p
}

func (s *Forstmt1Context) GetParser() antlr.Parser { return s.parser }

func (s *Forstmt1Context) FOR() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserFOR, 0)
}

func (s *Forstmt1Context) AllVardecl() []IVardeclContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVardeclContext)(nil)).Elem())
	var tst = make([]IVardeclContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVardeclContext)
		}
	}

	return tst
}

func (s *Forstmt1Context) Vardecl(i int) IVardeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVardeclContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *Forstmt1Context) EQ() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserEQ, 0)
}

func (s *Forstmt1Context) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Forstmt1Context) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Forstmt1Context) TO() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserTO, 0)
}

func (s *Forstmt1Context) STEP() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSTEP, 0)
}

func (s *Forstmt1Context) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Forstmt1Context) NEXT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserNEXT, 0)
}

func (s *Forstmt1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Forstmt1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Forstmt1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterForstmt1(s)
	}
}

func (s *Forstmt1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitForstmt1(s)
	}
}

func (p *jvmBasicParser) Forstmt1() (localctx IForstmt1Context) {
	this := p
	_ = this

	localctx = NewForstmt1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, jvmBasicParserRULE_forstmt1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(349)
		p.Match(jvmBasicParserFOR)
	}
	{
		p.SetState(350)
		p.Vardecl()
	}
	{
		p.SetState(351)
		p.Match(jvmBasicParserEQ)
	}
	{
		p.SetState(352)
		p.Expression()
	}
	{
		p.SetState(353)
		p.Match(jvmBasicParserTO)
	}
	{
		p.SetState(354)
		p.Expression()
	}
	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jvmBasicParserSTEP {
		{
			p.SetState(355)
			p.Match(jvmBasicParserSTEP)
		}
		{
			p.SetState(356)
			p.Expression()
		}

	}
	p.SetState(364)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(359)
			p.Statement()
		}
		{
			p.SetState(360)
			p.Match(jvmBasicParserNEXT)
		}
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == jvmBasicParserLETTERS {
			{
				p.SetState(361)
				p.Vardecl()
			}

		}

	}

	return localctx
}

// IForstmt2Context is an interface to support dynamic dispatch.
type IForstmt2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForstmt2Context differentiates from other interfaces.
	IsForstmt2Context()
}

type Forstmt2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForstmt2Context() *Forstmt2Context {
	var p = new(Forstmt2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_forstmt2
	return p
}

func (*Forstmt2Context) IsForstmt2Context() {}

func NewForstmt2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Forstmt2Context {
	var p = new(Forstmt2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_forstmt2

	return p
}

func (s *Forstmt2Context) GetParser() antlr.Parser { return s.parser }

func (s *Forstmt2Context) FOR() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserFOR, 0)
}

func (s *Forstmt2Context) Vardecl() IVardeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVardeclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *Forstmt2Context) EQ() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserEQ, 0)
}

func (s *Forstmt2Context) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Forstmt2Context) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Forstmt2Context) TO() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserTO, 0)
}

func (s *Forstmt2Context) STEP() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSTEP, 0)
}

func (s *Forstmt2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Forstmt2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Forstmt2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterForstmt2(s)
	}
}

func (s *Forstmt2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitForstmt2(s)
	}
}

func (p *jvmBasicParser) Forstmt2() (localctx IForstmt2Context) {
	this := p
	_ = this

	localctx = NewForstmt2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, jvmBasicParserRULE_forstmt2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(366)
		p.Match(jvmBasicParserFOR)
	}
	{
		p.SetState(367)
		p.Vardecl()
	}
	{
		p.SetState(368)
		p.Match(jvmBasicParserEQ)
	}
	{
		p.SetState(369)
		p.Expression()
	}
	{
		p.SetState(370)
		p.Match(jvmBasicParserTO)
	}
	{
		p.SetState(371)
		p.Expression()
	}
	p.SetState(374)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jvmBasicParserSTEP {
		{
			p.SetState(372)
			p.Match(jvmBasicParserSTEP)
		}
		{
			p.SetState(373)
			p.Expression()
		}

	}

	return localctx
}

// INextstmtContext is an interface to support dynamic dispatch.
type INextstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNextstmtContext differentiates from other interfaces.
	IsNextstmtContext()
}

type NextstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNextstmtContext() *NextstmtContext {
	var p = new(NextstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_nextstmt
	return p
}

func (*NextstmtContext) IsNextstmtContext() {}

func NewNextstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NextstmtContext {
	var p = new(NextstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_nextstmt

	return p
}

func (s *NextstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *NextstmtContext) NEXT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserNEXT, 0)
}

func (s *NextstmtContext) AllVardecl() []IVardeclContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVardeclContext)(nil)).Elem())
	var tst = make([]IVardeclContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVardeclContext)
		}
	}

	return tst
}

func (s *NextstmtContext) Vardecl(i int) IVardeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVardeclContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *NextstmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserCOMMA)
}

func (s *NextstmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, i)
}

func (s *NextstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NextstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NextstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterNextstmt(s)
	}
}

func (s *NextstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitNextstmt(s)
	}
}

func (p *jvmBasicParser) Nextstmt() (localctx INextstmtContext) {
	this := p
	_ = this

	localctx = NewNextstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, jvmBasicParserRULE_nextstmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(376)
		p.Match(jvmBasicParserNEXT)
	}
	p.SetState(385)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jvmBasicParserLETTERS {
		{
			p.SetState(377)
			p.Vardecl()
		}
		p.SetState(382)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == jvmBasicParserCOMMA {
			{
				p.SetState(378)
				p.Match(jvmBasicParserCOMMA)
			}
			{
				p.SetState(379)
				p.Vardecl()
			}

			p.SetState(384)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IInputstmtContext is an interface to support dynamic dispatch.
type IInputstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInputstmtContext differentiates from other interfaces.
	IsInputstmtContext()
}

type InputstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputstmtContext() *InputstmtContext {
	var p = new(InputstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_inputstmt
	return p
}

func (*InputstmtContext) IsInputstmtContext() {}

func NewInputstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputstmtContext {
	var p = new(InputstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_inputstmt

	return p
}

func (s *InputstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *InputstmtContext) INPUT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserINPUT, 0)
}

func (s *InputstmtContext) Varlist() IVarlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarlistContext)
}

func (s *InputstmtContext) STRINGLITERAL() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSTRINGLITERAL, 0)
}

func (s *InputstmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, 0)
}

func (s *InputstmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSEMICOLON, 0)
}

func (s *InputstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterInputstmt(s)
	}
}

func (s *InputstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitInputstmt(s)
	}
}

func (p *jvmBasicParser) Inputstmt() (localctx IInputstmtContext) {
	this := p
	_ = this

	localctx = NewInputstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, jvmBasicParserRULE_inputstmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(387)
		p.Match(jvmBasicParserINPUT)
	}
	p.SetState(390)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jvmBasicParserSTRINGLITERAL {
		{
			p.SetState(388)
			p.Match(jvmBasicParserSTRINGLITERAL)
		}
		{
			p.SetState(389)
			_la = p.GetTokenStream().LA(1)

			if !(_la == jvmBasicParserCOMMA || _la == jvmBasicParserSEMICOLON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(392)
		p.Varlist()
	}

	return localctx
}

// IReadstmtContext is an interface to support dynamic dispatch.
type IReadstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadstmtContext differentiates from other interfaces.
	IsReadstmtContext()
}

type ReadstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadstmtContext() *ReadstmtContext {
	var p = new(ReadstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_readstmt
	return p
}

func (*ReadstmtContext) IsReadstmtContext() {}

func NewReadstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadstmtContext {
	var p = new(ReadstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_readstmt

	return p
}

func (s *ReadstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadstmtContext) READ() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserREAD, 0)
}

func (s *ReadstmtContext) Varlist() IVarlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarlistContext)
}

func (s *ReadstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterReadstmt(s)
	}
}

func (s *ReadstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitReadstmt(s)
	}
}

func (p *jvmBasicParser) Readstmt() (localctx IReadstmtContext) {
	this := p
	_ = this

	localctx = NewReadstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, jvmBasicParserRULE_readstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(394)
		p.Match(jvmBasicParserREAD)
	}
	{
		p.SetState(395)
		p.Varlist()
	}

	return localctx
}

// IDimstmtContext is an interface to support dynamic dispatch.
type IDimstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimstmtContext differentiates from other interfaces.
	IsDimstmtContext()
}

type DimstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimstmtContext() *DimstmtContext {
	var p = new(DimstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_dimstmt
	return p
}

func (*DimstmtContext) IsDimstmtContext() {}

func NewDimstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimstmtContext {
	var p = new(DimstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_dimstmt

	return p
}

func (s *DimstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DimstmtContext) DIM() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserDIM, 0)
}

func (s *DimstmtContext) Varlist() IVarlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarlistContext)
}

func (s *DimstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterDimstmt(s)
	}
}

func (s *DimstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitDimstmt(s)
	}
}

func (p *jvmBasicParser) Dimstmt() (localctx IDimstmtContext) {
	this := p
	_ = this

	localctx = NewDimstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, jvmBasicParserRULE_dimstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(397)
		p.Match(jvmBasicParserDIM)
	}
	{
		p.SetState(398)
		p.Varlist()
	}

	return localctx
}

// IGotostmtContext is an interface to support dynamic dispatch.
type IGotostmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGotostmtContext differentiates from other interfaces.
	IsGotostmtContext()
}

type GotostmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotostmtContext() *GotostmtContext {
	var p = new(GotostmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_gotostmt
	return p
}

func (*GotostmtContext) IsGotostmtContext() {}

func NewGotostmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotostmtContext {
	var p = new(GotostmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_gotostmt

	return p
}

func (s *GotostmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GotostmtContext) GOTO() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserGOTO, 0)
}

func (s *GotostmtContext) Linenumber() ILinenumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinenumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinenumberContext)
}

func (s *GotostmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotostmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotostmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterGotostmt(s)
	}
}

func (s *GotostmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitGotostmt(s)
	}
}

func (p *jvmBasicParser) Gotostmt() (localctx IGotostmtContext) {
	this := p
	_ = this

	localctx = NewGotostmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, jvmBasicParserRULE_gotostmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(400)
		p.Match(jvmBasicParserGOTO)
	}
	{
		p.SetState(401)
		p.Linenumber()
	}

	return localctx
}

// IGosubstmtContext is an interface to support dynamic dispatch.
type IGosubstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGosubstmtContext differentiates from other interfaces.
	IsGosubstmtContext()
}

type GosubstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGosubstmtContext() *GosubstmtContext {
	var p = new(GosubstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_gosubstmt
	return p
}

func (*GosubstmtContext) IsGosubstmtContext() {}

func NewGosubstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GosubstmtContext {
	var p = new(GosubstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_gosubstmt

	return p
}

func (s *GosubstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GosubstmtContext) GOSUB() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserGOSUB, 0)
}

func (s *GosubstmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GosubstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GosubstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GosubstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterGosubstmt(s)
	}
}

func (s *GosubstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitGosubstmt(s)
	}
}

func (p *jvmBasicParser) Gosubstmt() (localctx IGosubstmtContext) {
	this := p
	_ = this

	localctx = NewGosubstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, jvmBasicParserRULE_gosubstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(403)
		p.Match(jvmBasicParserGOSUB)
	}
	{
		p.SetState(404)
		p.Expression()
	}

	return localctx
}

// IPokestmtContext is an interface to support dynamic dispatch.
type IPokestmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPokestmtContext differentiates from other interfaces.
	IsPokestmtContext()
}

type PokestmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPokestmtContext() *PokestmtContext {
	var p = new(PokestmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_pokestmt
	return p
}

func (*PokestmtContext) IsPokestmtContext() {}

func NewPokestmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PokestmtContext {
	var p = new(PokestmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_pokestmt

	return p
}

func (s *PokestmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PokestmtContext) POKE() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserPOKE, 0)
}

func (s *PokestmtContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *PokestmtContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PokestmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, 0)
}

func (s *PokestmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PokestmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PokestmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterPokestmt(s)
	}
}

func (s *PokestmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitPokestmt(s)
	}
}

func (p *jvmBasicParser) Pokestmt() (localctx IPokestmtContext) {
	this := p
	_ = this

	localctx = NewPokestmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, jvmBasicParserRULE_pokestmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(406)
		p.Match(jvmBasicParserPOKE)
	}
	{
		p.SetState(407)
		p.Expression()
	}
	{
		p.SetState(408)
		p.Match(jvmBasicParserCOMMA)
	}
	{
		p.SetState(409)
		p.Expression()
	}

	return localctx
}

// ICallstmtContext is an interface to support dynamic dispatch.
type ICallstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallstmtContext differentiates from other interfaces.
	IsCallstmtContext()
}

type CallstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallstmtContext() *CallstmtContext {
	var p = new(CallstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_callstmt
	return p
}

func (*CallstmtContext) IsCallstmtContext() {}

func NewCallstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallstmtContext {
	var p = new(CallstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_callstmt

	return p
}

func (s *CallstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CallstmtContext) CALL() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCALL, 0)
}

func (s *CallstmtContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *CallstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterCallstmt(s)
	}
}

func (s *CallstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitCallstmt(s)
	}
}

func (p *jvmBasicParser) Callstmt() (localctx ICallstmtContext) {
	this := p
	_ = this

	localctx = NewCallstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, jvmBasicParserRULE_callstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(411)
		p.Match(jvmBasicParserCALL)
	}
	{
		p.SetState(412)
		p.Exprlist()
	}

	return localctx
}

// IHplotstmtContext is an interface to support dynamic dispatch.
type IHplotstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHplotstmtContext differentiates from other interfaces.
	IsHplotstmtContext()
}

type HplotstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHplotstmtContext() *HplotstmtContext {
	var p = new(HplotstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_hplotstmt
	return p
}

func (*HplotstmtContext) IsHplotstmtContext() {}

func NewHplotstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HplotstmtContext {
	var p = new(HplotstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_hplotstmt

	return p
}

func (s *HplotstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *HplotstmtContext) HPLOT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserHPLOT, 0)
}

func (s *HplotstmtContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *HplotstmtContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HplotstmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserCOMMA)
}

func (s *HplotstmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, i)
}

func (s *HplotstmtContext) AllTO() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserTO)
}

func (s *HplotstmtContext) TO(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserTO, i)
}

func (s *HplotstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HplotstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HplotstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterHplotstmt(s)
	}
}

func (s *HplotstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitHplotstmt(s)
	}
}

func (p *jvmBasicParser) Hplotstmt() (localctx IHplotstmtContext) {
	this := p
	_ = this

	localctx = NewHplotstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, jvmBasicParserRULE_hplotstmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.Match(jvmBasicParserHPLOT)
	}
	p.SetState(419)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(415)
			p.Expression()
		}
		{
			p.SetState(416)
			p.Match(jvmBasicParserCOMMA)
		}
		{
			p.SetState(417)
			p.Expression()
		}

	}
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jvmBasicParserTO {
		{
			p.SetState(421)
			p.Match(jvmBasicParserTO)
		}
		{
			p.SetState(422)
			p.Expression()
		}
		{
			p.SetState(423)
			p.Match(jvmBasicParserCOMMA)
		}
		{
			p.SetState(424)
			p.Expression()
		}

		p.SetState(430)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IVplotstmtContext is an interface to support dynamic dispatch.
type IVplotstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVplotstmtContext differentiates from other interfaces.
	IsVplotstmtContext()
}

type VplotstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVplotstmtContext() *VplotstmtContext {
	var p = new(VplotstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_vplotstmt
	return p
}

func (*VplotstmtContext) IsVplotstmtContext() {}

func NewVplotstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VplotstmtContext {
	var p = new(VplotstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_vplotstmt

	return p
}

func (s *VplotstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *VplotstmtContext) VPLOT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserVPLOT, 0)
}

func (s *VplotstmtContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *VplotstmtContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VplotstmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserCOMMA)
}

func (s *VplotstmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, i)
}

func (s *VplotstmtContext) AllTO() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserTO)
}

func (s *VplotstmtContext) TO(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserTO, i)
}

func (s *VplotstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VplotstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VplotstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterVplotstmt(s)
	}
}

func (s *VplotstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitVplotstmt(s)
	}
}

func (p *jvmBasicParser) Vplotstmt() (localctx IVplotstmtContext) {
	this := p
	_ = this

	localctx = NewVplotstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, jvmBasicParserRULE_vplotstmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(431)
		p.Match(jvmBasicParserVPLOT)
	}
	p.SetState(436)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(432)
			p.Expression()
		}
		{
			p.SetState(433)
			p.Match(jvmBasicParserCOMMA)
		}
		{
			p.SetState(434)
			p.Expression()
		}

	}
	p.SetState(445)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jvmBasicParserTO {
		{
			p.SetState(438)
			p.Match(jvmBasicParserTO)
		}
		{
			p.SetState(439)
			p.Expression()
		}
		{
			p.SetState(440)
			p.Match(jvmBasicParserCOMMA)
		}
		{
			p.SetState(441)
			p.Expression()
		}

		p.SetState(447)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPlotstmtContext is an interface to support dynamic dispatch.
type IPlotstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPlotstmtContext differentiates from other interfaces.
	IsPlotstmtContext()
}

type PlotstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPlotstmtContext() *PlotstmtContext {
	var p = new(PlotstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_plotstmt
	return p
}

func (*PlotstmtContext) IsPlotstmtContext() {}

func NewPlotstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlotstmtContext {
	var p = new(PlotstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_plotstmt

	return p
}

func (s *PlotstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PlotstmtContext) PLOT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserPLOT, 0)
}

func (s *PlotstmtContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *PlotstmtContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PlotstmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, 0)
}

func (s *PlotstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlotstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlotstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterPlotstmt(s)
	}
}

func (s *PlotstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitPlotstmt(s)
	}
}

func (p *jvmBasicParser) Plotstmt() (localctx IPlotstmtContext) {
	this := p
	_ = this

	localctx = NewPlotstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, jvmBasicParserRULE_plotstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(448)
		p.Match(jvmBasicParserPLOT)
	}
	{
		p.SetState(449)
		p.Expression()
	}
	{
		p.SetState(450)
		p.Match(jvmBasicParserCOMMA)
	}
	{
		p.SetState(451)
		p.Expression()
	}

	return localctx
}

// IOngotostmtContext is an interface to support dynamic dispatch.
type IOngotostmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOngotostmtContext differentiates from other interfaces.
	IsOngotostmtContext()
}

type OngotostmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOngotostmtContext() *OngotostmtContext {
	var p = new(OngotostmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_ongotostmt
	return p
}

func (*OngotostmtContext) IsOngotostmtContext() {}

func NewOngotostmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OngotostmtContext {
	var p = new(OngotostmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_ongotostmt

	return p
}

func (s *OngotostmtContext) GetParser() antlr.Parser { return s.parser }

func (s *OngotostmtContext) ON() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserON, 0)
}

func (s *OngotostmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OngotostmtContext) GOTO() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserGOTO, 0)
}

func (s *OngotostmtContext) AllLinenumber() []ILinenumberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILinenumberContext)(nil)).Elem())
	var tst = make([]ILinenumberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILinenumberContext)
		}
	}

	return tst
}

func (s *OngotostmtContext) Linenumber(i int) ILinenumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinenumberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILinenumberContext)
}

func (s *OngotostmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserCOMMA)
}

func (s *OngotostmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, i)
}

func (s *OngotostmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OngotostmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OngotostmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterOngotostmt(s)
	}
}

func (s *OngotostmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitOngotostmt(s)
	}
}

func (p *jvmBasicParser) Ongotostmt() (localctx IOngotostmtContext) {
	this := p
	_ = this

	localctx = NewOngotostmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, jvmBasicParserRULE_ongotostmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		p.Match(jvmBasicParserON)
	}
	{
		p.SetState(454)
		p.Expression()
	}
	{
		p.SetState(455)
		p.Match(jvmBasicParserGOTO)
	}
	{
		p.SetState(456)
		p.Linenumber()
	}
	p.SetState(461)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jvmBasicParserCOMMA {
		{
			p.SetState(457)
			p.Match(jvmBasicParserCOMMA)
		}
		{
			p.SetState(458)
			p.Linenumber()
		}

		p.SetState(463)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOngosubstmtContext is an interface to support dynamic dispatch.
type IOngosubstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOngosubstmtContext differentiates from other interfaces.
	IsOngosubstmtContext()
}

type OngosubstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOngosubstmtContext() *OngosubstmtContext {
	var p = new(OngosubstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_ongosubstmt
	return p
}

func (*OngosubstmtContext) IsOngosubstmtContext() {}

func NewOngosubstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OngosubstmtContext {
	var p = new(OngosubstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_ongosubstmt

	return p
}

func (s *OngosubstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *OngosubstmtContext) ON() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserON, 0)
}

func (s *OngosubstmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OngosubstmtContext) GOSUB() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserGOSUB, 0)
}

func (s *OngosubstmtContext) AllLinenumber() []ILinenumberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILinenumberContext)(nil)).Elem())
	var tst = make([]ILinenumberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILinenumberContext)
		}
	}

	return tst
}

func (s *OngosubstmtContext) Linenumber(i int) ILinenumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinenumberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILinenumberContext)
}

func (s *OngosubstmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserCOMMA)
}

func (s *OngosubstmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, i)
}

func (s *OngosubstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OngosubstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OngosubstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterOngosubstmt(s)
	}
}

func (s *OngosubstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitOngosubstmt(s)
	}
}

func (p *jvmBasicParser) Ongosubstmt() (localctx IOngosubstmtContext) {
	this := p
	_ = this

	localctx = NewOngosubstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, jvmBasicParserRULE_ongosubstmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(464)
		p.Match(jvmBasicParserON)
	}
	{
		p.SetState(465)
		p.Expression()
	}
	{
		p.SetState(466)
		p.Match(jvmBasicParserGOSUB)
	}
	{
		p.SetState(467)
		p.Linenumber()
	}
	p.SetState(472)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jvmBasicParserCOMMA {
		{
			p.SetState(468)
			p.Match(jvmBasicParserCOMMA)
		}
		{
			p.SetState(469)
			p.Linenumber()
		}

		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IVtabstmntContext is an interface to support dynamic dispatch.
type IVtabstmntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVtabstmntContext differentiates from other interfaces.
	IsVtabstmntContext()
}

type VtabstmntContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVtabstmntContext() *VtabstmntContext {
	var p = new(VtabstmntContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_vtabstmnt
	return p
}

func (*VtabstmntContext) IsVtabstmntContext() {}

func NewVtabstmntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VtabstmntContext {
	var p = new(VtabstmntContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_vtabstmnt

	return p
}

func (s *VtabstmntContext) GetParser() antlr.Parser { return s.parser }

func (s *VtabstmntContext) VTAB() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserVTAB, 0)
}

func (s *VtabstmntContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VtabstmntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VtabstmntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VtabstmntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterVtabstmnt(s)
	}
}

func (s *VtabstmntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitVtabstmnt(s)
	}
}

func (p *jvmBasicParser) Vtabstmnt() (localctx IVtabstmntContext) {
	this := p
	_ = this

	localctx = NewVtabstmntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, jvmBasicParserRULE_vtabstmnt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(475)
		p.Match(jvmBasicParserVTAB)
	}
	{
		p.SetState(476)
		p.Expression()
	}

	return localctx
}

// IHtabstmntContext is an interface to support dynamic dispatch.
type IHtabstmntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtabstmntContext differentiates from other interfaces.
	IsHtabstmntContext()
}

type HtabstmntContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtabstmntContext() *HtabstmntContext {
	var p = new(HtabstmntContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_htabstmnt
	return p
}

func (*HtabstmntContext) IsHtabstmntContext() {}

func NewHtabstmntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtabstmntContext {
	var p = new(HtabstmntContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_htabstmnt

	return p
}

func (s *HtabstmntContext) GetParser() antlr.Parser { return s.parser }

func (s *HtabstmntContext) HTAB() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserHTAB, 0)
}

func (s *HtabstmntContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HtabstmntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtabstmntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HtabstmntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterHtabstmnt(s)
	}
}

func (s *HtabstmntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitHtabstmnt(s)
	}
}

func (p *jvmBasicParser) Htabstmnt() (localctx IHtabstmntContext) {
	this := p
	_ = this

	localctx = NewHtabstmntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, jvmBasicParserRULE_htabstmnt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(478)
		p.Match(jvmBasicParserHTAB)
	}
	{
		p.SetState(479)
		p.Expression()
	}

	return localctx
}

// IHimemstmtContext is an interface to support dynamic dispatch.
type IHimemstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHimemstmtContext differentiates from other interfaces.
	IsHimemstmtContext()
}

type HimemstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHimemstmtContext() *HimemstmtContext {
	var p = new(HimemstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_himemstmt
	return p
}

func (*HimemstmtContext) IsHimemstmtContext() {}

func NewHimemstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HimemstmtContext {
	var p = new(HimemstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_himemstmt

	return p
}

func (s *HimemstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *HimemstmtContext) HIMEM() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserHIMEM, 0)
}

func (s *HimemstmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOLON, 0)
}

func (s *HimemstmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HimemstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HimemstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HimemstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterHimemstmt(s)
	}
}

func (s *HimemstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitHimemstmt(s)
	}
}

func (p *jvmBasicParser) Himemstmt() (localctx IHimemstmtContext) {
	this := p
	_ = this

	localctx = NewHimemstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, jvmBasicParserRULE_himemstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(481)
		p.Match(jvmBasicParserHIMEM)
	}
	{
		p.SetState(482)
		p.Match(jvmBasicParserCOLON)
	}
	{
		p.SetState(483)
		p.Expression()
	}

	return localctx
}

// ILomemstmtContext is an interface to support dynamic dispatch.
type ILomemstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLomemstmtContext differentiates from other interfaces.
	IsLomemstmtContext()
}

type LomemstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLomemstmtContext() *LomemstmtContext {
	var p = new(LomemstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_lomemstmt
	return p
}

func (*LomemstmtContext) IsLomemstmtContext() {}

func NewLomemstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LomemstmtContext {
	var p = new(LomemstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_lomemstmt

	return p
}

func (s *LomemstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *LomemstmtContext) LOMEM() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLOMEM, 0)
}

func (s *LomemstmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOLON, 0)
}

func (s *LomemstmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LomemstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LomemstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LomemstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterLomemstmt(s)
	}
}

func (s *LomemstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitLomemstmt(s)
	}
}

func (p *jvmBasicParser) Lomemstmt() (localctx ILomemstmtContext) {
	this := p
	_ = this

	localctx = NewLomemstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, jvmBasicParserRULE_lomemstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Match(jvmBasicParserLOMEM)
	}
	{
		p.SetState(486)
		p.Match(jvmBasicParserCOLON)
	}
	{
		p.SetState(487)
		p.Expression()
	}

	return localctx
}

// IDatastmtContext is an interface to support dynamic dispatch.
type IDatastmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatastmtContext differentiates from other interfaces.
	IsDatastmtContext()
}

type DatastmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatastmtContext() *DatastmtContext {
	var p = new(DatastmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_datastmt
	return p
}

func (*DatastmtContext) IsDatastmtContext() {}

func NewDatastmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatastmtContext {
	var p = new(DatastmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_datastmt

	return p
}

func (s *DatastmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DatastmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserDATA, 0)
}

func (s *DatastmtContext) AllDatum() []IDatumContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDatumContext)(nil)).Elem())
	var tst = make([]IDatumContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDatumContext)
		}
	}

	return tst
}

func (s *DatastmtContext) Datum(i int) IDatumContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatumContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDatumContext)
}

func (s *DatastmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserCOMMA)
}

func (s *DatastmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, i)
}

func (s *DatastmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatastmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatastmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterDatastmt(s)
	}
}

func (s *DatastmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitDatastmt(s)
	}
}

func (p *jvmBasicParser) Datastmt() (localctx IDatastmtContext) {
	this := p
	_ = this

	localctx = NewDatastmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, jvmBasicParserRULE_datastmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(489)
		p.Match(jvmBasicParserDATA)
	}
	{
		p.SetState(490)
		p.Datum()
	}
	p.SetState(497)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jvmBasicParserCOMMA {
		{
			p.SetState(491)
			p.Match(jvmBasicParserCOMMA)
		}
		p.SetState(493)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(492)
				p.Datum()
			}

		}

		p.SetState(499)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDatumContext is an interface to support dynamic dispatch.
type IDatumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatumContext differentiates from other interfaces.
	IsDatumContext()
}

type DatumContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatumContext() *DatumContext {
	var p = new(DatumContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_datum
	return p
}

func (*DatumContext) IsDatumContext() {}

func NewDatumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatumContext {
	var p = new(DatumContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_datum

	return p
}

func (s *DatumContext) GetParser() antlr.Parser { return s.parser }

func (s *DatumContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *DatumContext) STRINGLITERAL() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSTRINGLITERAL, 0)
}

func (s *DatumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterDatum(s)
	}
}

func (s *DatumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitDatum(s)
	}
}

func (p *jvmBasicParser) Datum() (localctx IDatumContext) {
	this := p
	_ = this

	localctx = NewDatumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, jvmBasicParserRULE_datum)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(502)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jvmBasicParserPLUS, jvmBasicParserMINUS, jvmBasicParserNUMBER, jvmBasicParserFLOAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(500)
			p.Number()
		}

	case jvmBasicParserSTRINGLITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(501)
			p.Match(jvmBasicParserSTRINGLITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWaitstmtContext is an interface to support dynamic dispatch.
type IWaitstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWaitstmtContext differentiates from other interfaces.
	IsWaitstmtContext()
}

type WaitstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWaitstmtContext() *WaitstmtContext {
	var p = new(WaitstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_waitstmt
	return p
}

func (*WaitstmtContext) IsWaitstmtContext() {}

func NewWaitstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WaitstmtContext {
	var p = new(WaitstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_waitstmt

	return p
}

func (s *WaitstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *WaitstmtContext) WAIT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserWAIT, 0)
}

func (s *WaitstmtContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *WaitstmtContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WaitstmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserCOMMA)
}

func (s *WaitstmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, i)
}

func (s *WaitstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WaitstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WaitstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterWaitstmt(s)
	}
}

func (s *WaitstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitWaitstmt(s)
	}
}

func (p *jvmBasicParser) Waitstmt() (localctx IWaitstmtContext) {
	this := p
	_ = this

	localctx = NewWaitstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, jvmBasicParserRULE_waitstmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(504)
		p.Match(jvmBasicParserWAIT)
	}
	{
		p.SetState(505)
		p.Expression()
	}
	{
		p.SetState(506)
		p.Match(jvmBasicParserCOMMA)
	}
	{
		p.SetState(507)
		p.Expression()
	}
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jvmBasicParserCOMMA {
		{
			p.SetState(508)
			p.Match(jvmBasicParserCOMMA)
		}
		{
			p.SetState(509)
			p.Expression()
		}

	}

	return localctx
}

// IXdrawstmtContext is an interface to support dynamic dispatch.
type IXdrawstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXdrawstmtContext differentiates from other interfaces.
	IsXdrawstmtContext()
}

type XdrawstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXdrawstmtContext() *XdrawstmtContext {
	var p = new(XdrawstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_xdrawstmt
	return p
}

func (*XdrawstmtContext) IsXdrawstmtContext() {}

func NewXdrawstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XdrawstmtContext {
	var p = new(XdrawstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_xdrawstmt

	return p
}

func (s *XdrawstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *XdrawstmtContext) XDRAW() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserXDRAW, 0)
}

func (s *XdrawstmtContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *XdrawstmtContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *XdrawstmtContext) AT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserAT, 0)
}

func (s *XdrawstmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, 0)
}

func (s *XdrawstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XdrawstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XdrawstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterXdrawstmt(s)
	}
}

func (s *XdrawstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitXdrawstmt(s)
	}
}

func (p *jvmBasicParser) Xdrawstmt() (localctx IXdrawstmtContext) {
	this := p
	_ = this

	localctx = NewXdrawstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, jvmBasicParserRULE_xdrawstmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(512)
		p.Match(jvmBasicParserXDRAW)
	}
	{
		p.SetState(513)
		p.Expression()
	}
	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jvmBasicParserAT {
		{
			p.SetState(514)
			p.Match(jvmBasicParserAT)
		}
		{
			p.SetState(515)
			p.Expression()
		}
		{
			p.SetState(516)
			p.Match(jvmBasicParserCOMMA)
		}
		{
			p.SetState(517)
			p.Expression()
		}

	}

	return localctx
}

// IDrawstmtContext is an interface to support dynamic dispatch.
type IDrawstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrawstmtContext differentiates from other interfaces.
	IsDrawstmtContext()
}

type DrawstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrawstmtContext() *DrawstmtContext {
	var p = new(DrawstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_drawstmt
	return p
}

func (*DrawstmtContext) IsDrawstmtContext() {}

func NewDrawstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DrawstmtContext {
	var p = new(DrawstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_drawstmt

	return p
}

func (s *DrawstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DrawstmtContext) DRAW() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserDRAW, 0)
}

func (s *DrawstmtContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *DrawstmtContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DrawstmtContext) AT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserAT, 0)
}

func (s *DrawstmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, 0)
}

func (s *DrawstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DrawstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DrawstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterDrawstmt(s)
	}
}

func (s *DrawstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitDrawstmt(s)
	}
}

func (p *jvmBasicParser) Drawstmt() (localctx IDrawstmtContext) {
	this := p
	_ = this

	localctx = NewDrawstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, jvmBasicParserRULE_drawstmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(521)
		p.Match(jvmBasicParserDRAW)
	}
	{
		p.SetState(522)
		p.Expression()
	}
	p.SetState(528)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jvmBasicParserAT {
		{
			p.SetState(523)
			p.Match(jvmBasicParserAT)
		}
		{
			p.SetState(524)
			p.Expression()
		}
		{
			p.SetState(525)
			p.Match(jvmBasicParserCOMMA)
		}
		{
			p.SetState(526)
			p.Expression()
		}

	}

	return localctx
}

// IDefstmtContext is an interface to support dynamic dispatch.
type IDefstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefstmtContext differentiates from other interfaces.
	IsDefstmtContext()
}

type DefstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefstmtContext() *DefstmtContext {
	var p = new(DefstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_defstmt
	return p
}

func (*DefstmtContext) IsDefstmtContext() {}

func NewDefstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefstmtContext {
	var p = new(DefstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_defstmt

	return p
}

func (s *DefstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DefstmtContext) DEF() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserDEF, 0)
}

func (s *DefstmtContext) AllVar_() []IVar_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVar_Context)(nil)).Elem())
	var tst = make([]IVar_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVar_Context)
		}
	}

	return tst
}

func (s *DefstmtContext) Var_(i int) IVar_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVar_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVar_Context)
}

func (s *DefstmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *DefstmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *DefstmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserEQ, 0)
}

func (s *DefstmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefstmtContext) FN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserFN, 0)
}

func (s *DefstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterDefstmt(s)
	}
}

func (s *DefstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitDefstmt(s)
	}
}

func (p *jvmBasicParser) Defstmt() (localctx IDefstmtContext) {
	this := p
	_ = this

	localctx = NewDefstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, jvmBasicParserRULE_defstmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(530)
		p.Match(jvmBasicParserDEF)
	}
	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jvmBasicParserFN {
		{
			p.SetState(531)
			p.Match(jvmBasicParserFN)
		}

	}
	{
		p.SetState(534)
		p.Var_()
	}
	{
		p.SetState(535)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(536)
		p.Var_()
	}
	{
		p.SetState(537)
		p.Match(jvmBasicParserRPAREN)
	}
	{
		p.SetState(538)
		p.Match(jvmBasicParserEQ)
	}
	{
		p.SetState(539)
		p.Expression()
	}

	return localctx
}

// ITabstmtContext is an interface to support dynamic dispatch.
type ITabstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTabstmtContext differentiates from other interfaces.
	IsTabstmtContext()
}

type TabstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabstmtContext() *TabstmtContext {
	var p = new(TabstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_tabstmt
	return p
}

func (*TabstmtContext) IsTabstmtContext() {}

func NewTabstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabstmtContext {
	var p = new(TabstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_tabstmt

	return p
}

func (s *TabstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *TabstmtContext) TAB() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserTAB, 0)
}

func (s *TabstmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *TabstmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TabstmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *TabstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterTabstmt(s)
	}
}

func (s *TabstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitTabstmt(s)
	}
}

func (p *jvmBasicParser) Tabstmt() (localctx ITabstmtContext) {
	this := p
	_ = this

	localctx = NewTabstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, jvmBasicParserRULE_tabstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.Match(jvmBasicParserTAB)
	}
	{
		p.SetState(542)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(543)
		p.Expression()
	}
	{
		p.SetState(544)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// ISpeedstmtContext is an interface to support dynamic dispatch.
type ISpeedstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpeedstmtContext differentiates from other interfaces.
	IsSpeedstmtContext()
}

type SpeedstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpeedstmtContext() *SpeedstmtContext {
	var p = new(SpeedstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_speedstmt
	return p
}

func (*SpeedstmtContext) IsSpeedstmtContext() {}

func NewSpeedstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpeedstmtContext {
	var p = new(SpeedstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_speedstmt

	return p
}

func (s *SpeedstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SpeedstmtContext) SPEED() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSPEED, 0)
}

func (s *SpeedstmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserEQ, 0)
}

func (s *SpeedstmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SpeedstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpeedstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpeedstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterSpeedstmt(s)
	}
}

func (s *SpeedstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitSpeedstmt(s)
	}
}

func (p *jvmBasicParser) Speedstmt() (localctx ISpeedstmtContext) {
	this := p
	_ = this

	localctx = NewSpeedstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, jvmBasicParserRULE_speedstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(546)
		p.Match(jvmBasicParserSPEED)
	}
	{
		p.SetState(547)
		p.Match(jvmBasicParserEQ)
	}
	{
		p.SetState(548)
		p.Expression()
	}

	return localctx
}

// IRotstmtContext is an interface to support dynamic dispatch.
type IRotstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRotstmtContext differentiates from other interfaces.
	IsRotstmtContext()
}

type RotstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRotstmtContext() *RotstmtContext {
	var p = new(RotstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_rotstmt
	return p
}

func (*RotstmtContext) IsRotstmtContext() {}

func NewRotstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RotstmtContext {
	var p = new(RotstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_rotstmt

	return p
}

func (s *RotstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RotstmtContext) ROT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserROT, 0)
}

func (s *RotstmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserEQ, 0)
}

func (s *RotstmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RotstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RotstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RotstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterRotstmt(s)
	}
}

func (s *RotstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitRotstmt(s)
	}
}

func (p *jvmBasicParser) Rotstmt() (localctx IRotstmtContext) {
	this := p
	_ = this

	localctx = NewRotstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, jvmBasicParserRULE_rotstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(550)
		p.Match(jvmBasicParserROT)
	}
	{
		p.SetState(551)
		p.Match(jvmBasicParserEQ)
	}
	{
		p.SetState(552)
		p.Expression()
	}

	return localctx
}

// IScalestmtContext is an interface to support dynamic dispatch.
type IScalestmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScalestmtContext differentiates from other interfaces.
	IsScalestmtContext()
}

type ScalestmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalestmtContext() *ScalestmtContext {
	var p = new(ScalestmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_scalestmt
	return p
}

func (*ScalestmtContext) IsScalestmtContext() {}

func NewScalestmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalestmtContext {
	var p = new(ScalestmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_scalestmt

	return p
}

func (s *ScalestmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalestmtContext) SCALE() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSCALE, 0)
}

func (s *ScalestmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserEQ, 0)
}

func (s *ScalestmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ScalestmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalestmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalestmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterScalestmt(s)
	}
}

func (s *ScalestmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitScalestmt(s)
	}
}

func (p *jvmBasicParser) Scalestmt() (localctx IScalestmtContext) {
	this := p
	_ = this

	localctx = NewScalestmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, jvmBasicParserRULE_scalestmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(554)
		p.Match(jvmBasicParserSCALE)
	}
	{
		p.SetState(555)
		p.Match(jvmBasicParserEQ)
	}
	{
		p.SetState(556)
		p.Expression()
	}

	return localctx
}

// IColorstmtContext is an interface to support dynamic dispatch.
type IColorstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColorstmtContext differentiates from other interfaces.
	IsColorstmtContext()
}

type ColorstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColorstmtContext() *ColorstmtContext {
	var p = new(ColorstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_colorstmt
	return p
}

func (*ColorstmtContext) IsColorstmtContext() {}

func NewColorstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColorstmtContext {
	var p = new(ColorstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_colorstmt

	return p
}

func (s *ColorstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ColorstmtContext) COLOR() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOLOR, 0)
}

func (s *ColorstmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserEQ, 0)
}

func (s *ColorstmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ColorstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColorstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColorstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterColorstmt(s)
	}
}

func (s *ColorstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitColorstmt(s)
	}
}

func (p *jvmBasicParser) Colorstmt() (localctx IColorstmtContext) {
	this := p
	_ = this

	localctx = NewColorstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, jvmBasicParserRULE_colorstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(558)
		p.Match(jvmBasicParserCOLOR)
	}
	{
		p.SetState(559)
		p.Match(jvmBasicParserEQ)
	}
	{
		p.SetState(560)
		p.Expression()
	}

	return localctx
}

// IHcolorstmtContext is an interface to support dynamic dispatch.
type IHcolorstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHcolorstmtContext differentiates from other interfaces.
	IsHcolorstmtContext()
}

type HcolorstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHcolorstmtContext() *HcolorstmtContext {
	var p = new(HcolorstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_hcolorstmt
	return p
}

func (*HcolorstmtContext) IsHcolorstmtContext() {}

func NewHcolorstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HcolorstmtContext {
	var p = new(HcolorstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_hcolorstmt

	return p
}

func (s *HcolorstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *HcolorstmtContext) HCOLOR() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserHCOLOR, 0)
}

func (s *HcolorstmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserEQ, 0)
}

func (s *HcolorstmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HcolorstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HcolorstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HcolorstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterHcolorstmt(s)
	}
}

func (s *HcolorstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitHcolorstmt(s)
	}
}

func (p *jvmBasicParser) Hcolorstmt() (localctx IHcolorstmtContext) {
	this := p
	_ = this

	localctx = NewHcolorstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, jvmBasicParserRULE_hcolorstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(562)
		p.Match(jvmBasicParserHCOLOR)
	}
	{
		p.SetState(563)
		p.Match(jvmBasicParserEQ)
	}
	{
		p.SetState(564)
		p.Expression()
	}

	return localctx
}

// IHlinstmtContext is an interface to support dynamic dispatch.
type IHlinstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHlinstmtContext differentiates from other interfaces.
	IsHlinstmtContext()
}

type HlinstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHlinstmtContext() *HlinstmtContext {
	var p = new(HlinstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_hlinstmt
	return p
}

func (*HlinstmtContext) IsHlinstmtContext() {}

func NewHlinstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HlinstmtContext {
	var p = new(HlinstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_hlinstmt

	return p
}

func (s *HlinstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *HlinstmtContext) HLIN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserHLIN, 0)
}

func (s *HlinstmtContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *HlinstmtContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HlinstmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, 0)
}

func (s *HlinstmtContext) AT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserAT, 0)
}

func (s *HlinstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HlinstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HlinstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterHlinstmt(s)
	}
}

func (s *HlinstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitHlinstmt(s)
	}
}

func (p *jvmBasicParser) Hlinstmt() (localctx IHlinstmtContext) {
	this := p
	_ = this

	localctx = NewHlinstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, jvmBasicParserRULE_hlinstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(566)
		p.Match(jvmBasicParserHLIN)
	}
	{
		p.SetState(567)
		p.Expression()
	}
	{
		p.SetState(568)
		p.Match(jvmBasicParserCOMMA)
	}
	{
		p.SetState(569)
		p.Expression()
	}
	{
		p.SetState(570)
		p.Match(jvmBasicParserAT)
	}
	{
		p.SetState(571)
		p.Expression()
	}

	return localctx
}

// IVlinstmtContext is an interface to support dynamic dispatch.
type IVlinstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVlinstmtContext differentiates from other interfaces.
	IsVlinstmtContext()
}

type VlinstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVlinstmtContext() *VlinstmtContext {
	var p = new(VlinstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_vlinstmt
	return p
}

func (*VlinstmtContext) IsVlinstmtContext() {}

func NewVlinstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VlinstmtContext {
	var p = new(VlinstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_vlinstmt

	return p
}

func (s *VlinstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *VlinstmtContext) VLIN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserVLIN, 0)
}

func (s *VlinstmtContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *VlinstmtContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VlinstmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, 0)
}

func (s *VlinstmtContext) AT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserAT, 0)
}

func (s *VlinstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VlinstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VlinstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterVlinstmt(s)
	}
}

func (s *VlinstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitVlinstmt(s)
	}
}

func (p *jvmBasicParser) Vlinstmt() (localctx IVlinstmtContext) {
	this := p
	_ = this

	localctx = NewVlinstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, jvmBasicParserRULE_vlinstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(573)
		p.Match(jvmBasicParserVLIN)
	}
	{
		p.SetState(574)
		p.Expression()
	}
	{
		p.SetState(575)
		p.Match(jvmBasicParserCOMMA)
	}
	{
		p.SetState(576)
		p.Expression()
	}
	{
		p.SetState(577)
		p.Match(jvmBasicParserAT)
	}
	{
		p.SetState(578)
		p.Expression()
	}

	return localctx
}

// IOnerrstmtContext is an interface to support dynamic dispatch.
type IOnerrstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnerrstmtContext differentiates from other interfaces.
	IsOnerrstmtContext()
}

type OnerrstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnerrstmtContext() *OnerrstmtContext {
	var p = new(OnerrstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_onerrstmt
	return p
}

func (*OnerrstmtContext) IsOnerrstmtContext() {}

func NewOnerrstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnerrstmtContext {
	var p = new(OnerrstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_onerrstmt

	return p
}

func (s *OnerrstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *OnerrstmtContext) ONERR() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserONERR, 0)
}

func (s *OnerrstmtContext) GOTO() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserGOTO, 0)
}

func (s *OnerrstmtContext) Linenumber() ILinenumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinenumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinenumberContext)
}

func (s *OnerrstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnerrstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnerrstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterOnerrstmt(s)
	}
}

func (s *OnerrstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitOnerrstmt(s)
	}
}

func (p *jvmBasicParser) Onerrstmt() (localctx IOnerrstmtContext) {
	this := p
	_ = this

	localctx = NewOnerrstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, jvmBasicParserRULE_onerrstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)
		p.Match(jvmBasicParserONERR)
	}
	{
		p.SetState(581)
		p.Match(jvmBasicParserGOTO)
	}
	{
		p.SetState(582)
		p.Linenumber()
	}

	return localctx
}

// IPrstmtContext is an interface to support dynamic dispatch.
type IPrstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrstmtContext differentiates from other interfaces.
	IsPrstmtContext()
}

type PrstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrstmtContext() *PrstmtContext {
	var p = new(PrstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_prstmt
	return p
}

func (*PrstmtContext) IsPrstmtContext() {}

func NewPrstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrstmtContext {
	var p = new(PrstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_prstmt

	return p
}

func (s *PrstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PrstmtContext) PRNUMBER() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserPRNUMBER, 0)
}

func (s *PrstmtContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserNUMBER, 0)
}

func (s *PrstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterPrstmt(s)
	}
}

func (s *PrstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitPrstmt(s)
	}
}

func (p *jvmBasicParser) Prstmt() (localctx IPrstmtContext) {
	this := p
	_ = this

	localctx = NewPrstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, jvmBasicParserRULE_prstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)
		p.Match(jvmBasicParserPRNUMBER)
	}
	{
		p.SetState(585)
		p.Match(jvmBasicParserNUMBER)
	}

	return localctx
}

// IInstmtContext is an interface to support dynamic dispatch.
type IInstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstmtContext differentiates from other interfaces.
	IsInstmtContext()
}

type InstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstmtContext() *InstmtContext {
	var p = new(InstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_instmt
	return p
}

func (*InstmtContext) IsInstmtContext() {}

func NewInstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstmtContext {
	var p = new(InstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_instmt

	return p
}

func (s *InstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *InstmtContext) INNUMBER() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserINNUMBER, 0)
}

func (s *InstmtContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserNUMBER, 0)
}

func (s *InstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterInstmt(s)
	}
}

func (s *InstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitInstmt(s)
	}
}

func (p *jvmBasicParser) Instmt() (localctx IInstmtContext) {
	this := p
	_ = this

	localctx = NewInstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, jvmBasicParserRULE_instmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(587)
		p.Match(jvmBasicParserINNUMBER)
	}
	{
		p.SetState(588)
		p.Match(jvmBasicParserNUMBER)
	}

	return localctx
}

// IStorestmtContext is an interface to support dynamic dispatch.
type IStorestmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStorestmtContext differentiates from other interfaces.
	IsStorestmtContext()
}

type StorestmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorestmtContext() *StorestmtContext {
	var p = new(StorestmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_storestmt
	return p
}

func (*StorestmtContext) IsStorestmtContext() {}

func NewStorestmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorestmtContext {
	var p = new(StorestmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_storestmt

	return p
}

func (s *StorestmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StorestmtContext) STORE() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSTORE, 0)
}

func (s *StorestmtContext) Vardecl() IVardeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVardeclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *StorestmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorestmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorestmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterStorestmt(s)
	}
}

func (s *StorestmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitStorestmt(s)
	}
}

func (p *jvmBasicParser) Storestmt() (localctx IStorestmtContext) {
	this := p
	_ = this

	localctx = NewStorestmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, jvmBasicParserRULE_storestmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(590)
		p.Match(jvmBasicParserSTORE)
	}
	{
		p.SetState(591)
		p.Vardecl()
	}

	return localctx
}

// IRecallstmtContext is an interface to support dynamic dispatch.
type IRecallstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecallstmtContext differentiates from other interfaces.
	IsRecallstmtContext()
}

type RecallstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecallstmtContext() *RecallstmtContext {
	var p = new(RecallstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_recallstmt
	return p
}

func (*RecallstmtContext) IsRecallstmtContext() {}

func NewRecallstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecallstmtContext {
	var p = new(RecallstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_recallstmt

	return p
}

func (s *RecallstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RecallstmtContext) RECALL() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRECALL, 0)
}

func (s *RecallstmtContext) Vardecl() IVardeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVardeclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *RecallstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecallstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecallstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterRecallstmt(s)
	}
}

func (s *RecallstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitRecallstmt(s)
	}
}

func (p *jvmBasicParser) Recallstmt() (localctx IRecallstmtContext) {
	this := p
	_ = this

	localctx = NewRecallstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, jvmBasicParserRULE_recallstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(593)
		p.Match(jvmBasicParserRECALL)
	}
	{
		p.SetState(594)
		p.Vardecl()
	}

	return localctx
}

// IListstmtContext is an interface to support dynamic dispatch.
type IListstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListstmtContext differentiates from other interfaces.
	IsListstmtContext()
}

type ListstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListstmtContext() *ListstmtContext {
	var p = new(ListstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_liststmt
	return p
}

func (*ListstmtContext) IsListstmtContext() {}

func NewListstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListstmtContext {
	var p = new(ListstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_liststmt

	return p
}

func (s *ListstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ListstmtContext) LIST() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLIST, 0)
}

func (s *ListstmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterListstmt(s)
	}
}

func (s *ListstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitListstmt(s)
	}
}

func (p *jvmBasicParser) Liststmt() (localctx IListstmtContext) {
	this := p
	_ = this

	localctx = NewListstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, jvmBasicParserRULE_liststmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(596)
		p.Match(jvmBasicParserLIST)
	}
	p.SetState(598)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(597)
			p.Expression()
		}

	}

	return localctx
}

// IPopstmtContext is an interface to support dynamic dispatch.
type IPopstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPopstmtContext differentiates from other interfaces.
	IsPopstmtContext()
}

type PopstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPopstmtContext() *PopstmtContext {
	var p = new(PopstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_popstmt
	return p
}

func (*PopstmtContext) IsPopstmtContext() {}

func NewPopstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PopstmtContext {
	var p = new(PopstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_popstmt

	return p
}

func (s *PopstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PopstmtContext) POP() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserPOP, 0)
}

func (s *PopstmtContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *PopstmtContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PopstmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, 0)
}

func (s *PopstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PopstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PopstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterPopstmt(s)
	}
}

func (s *PopstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitPopstmt(s)
	}
}

func (p *jvmBasicParser) Popstmt() (localctx IPopstmtContext) {
	this := p
	_ = this

	localctx = NewPopstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, jvmBasicParserRULE_popstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(600)
		p.Match(jvmBasicParserPOP)
	}
	p.SetState(605)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(601)
			p.Expression()
		}
		{
			p.SetState(602)
			p.Match(jvmBasicParserCOMMA)
		}
		{
			p.SetState(603)
			p.Expression()
		}

	}

	return localctx
}

// IAmptstmtContext is an interface to support dynamic dispatch.
type IAmptstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAmptstmtContext differentiates from other interfaces.
	IsAmptstmtContext()
}

type AmptstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAmptstmtContext() *AmptstmtContext {
	var p = new(AmptstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_amptstmt
	return p
}

func (*AmptstmtContext) IsAmptstmtContext() {}

func NewAmptstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AmptstmtContext {
	var p = new(AmptstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_amptstmt

	return p
}

func (s *AmptstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AmptstmtContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserAMPERSAND, 0)
}

func (s *AmptstmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AmptstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AmptstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AmptstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterAmptstmt(s)
	}
}

func (s *AmptstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitAmptstmt(s)
	}
}

func (p *jvmBasicParser) Amptstmt() (localctx IAmptstmtContext) {
	this := p
	_ = this

	localctx = NewAmptstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, jvmBasicParserRULE_amptstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.Match(jvmBasicParserAMPERSAND)
	}
	{
		p.SetState(608)
		p.Expression()
	}

	return localctx
}

// IIncludestmtContext is an interface to support dynamic dispatch.
type IIncludestmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIncludestmtContext differentiates from other interfaces.
	IsIncludestmtContext()
}

type IncludestmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncludestmtContext() *IncludestmtContext {
	var p = new(IncludestmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_includestmt
	return p
}

func (*IncludestmtContext) IsIncludestmtContext() {}

func NewIncludestmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncludestmtContext {
	var p = new(IncludestmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_includestmt

	return p
}

func (s *IncludestmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IncludestmtContext) INCLUDE() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserINCLUDE, 0)
}

func (s *IncludestmtContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IncludestmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludestmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IncludestmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterIncludestmt(s)
	}
}

func (s *IncludestmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitIncludestmt(s)
	}
}

func (p *jvmBasicParser) Includestmt() (localctx IIncludestmtContext) {
	this := p
	_ = this

	localctx = NewIncludestmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, jvmBasicParserRULE_includestmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(610)
		p.Match(jvmBasicParserINCLUDE)
	}
	{
		p.SetState(611)
		p.Expression()
	}

	return localctx
}

// IEndstmtContext is an interface to support dynamic dispatch.
type IEndstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndstmtContext differentiates from other interfaces.
	IsEndstmtContext()
}

type EndstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndstmtContext() *EndstmtContext {
	var p = new(EndstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_endstmt
	return p
}

func (*EndstmtContext) IsEndstmtContext() {}

func NewEndstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndstmtContext {
	var p = new(EndstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_endstmt

	return p
}

func (s *EndstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *EndstmtContext) END() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserEND, 0)
}

func (s *EndstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterEndstmt(s)
	}
}

func (s *EndstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitEndstmt(s)
	}
}

func (p *jvmBasicParser) Endstmt() (localctx IEndstmtContext) {
	this := p
	_ = this

	localctx = NewEndstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, jvmBasicParserRULE_endstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(613)
		p.Match(jvmBasicParserEND)
	}

	return localctx
}

// IReturnstmtContext is an interface to support dynamic dispatch.
type IReturnstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnstmtContext differentiates from other interfaces.
	IsReturnstmtContext()
}

type ReturnstmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnstmtContext() *ReturnstmtContext {
	var p = new(ReturnstmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_returnstmt
	return p
}

func (*ReturnstmtContext) IsReturnstmtContext() {}

func NewReturnstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnstmtContext {
	var p = new(ReturnstmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_returnstmt

	return p
}

func (s *ReturnstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnstmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRETURN, 0)
}

func (s *ReturnstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterReturnstmt(s)
	}
}

func (s *ReturnstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitReturnstmt(s)
	}
}

func (p *jvmBasicParser) Returnstmt() (localctx IReturnstmtContext) {
	this := p
	_ = this

	localctx = NewReturnstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, jvmBasicParserRULE_returnstmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(615)
		p.Match(jvmBasicParserRETURN)
	}

	return localctx
}

// IRestorestmtContext is an interface to support dynamic dispatch.
type IRestorestmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRestorestmtContext differentiates from other interfaces.
	IsRestorestmtContext()
}

type RestorestmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestorestmtContext() *RestorestmtContext {
	var p = new(RestorestmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_restorestmt
	return p
}

func (*RestorestmtContext) IsRestorestmtContext() {}

func NewRestorestmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestorestmtContext {
	var p = new(RestorestmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_restorestmt

	return p
}

func (s *RestorestmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RestorestmtContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRESTORE, 0)
}

func (s *RestorestmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestorestmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestorestmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterRestorestmt(s)
	}
}

func (s *RestorestmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitRestorestmt(s)
	}
}

func (p *jvmBasicParser) Restorestmt() (localctx IRestorestmtContext) {
	this := p
	_ = this

	localctx = NewRestorestmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, jvmBasicParserRULE_restorestmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.Match(jvmBasicParserRESTORE)
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserNUMBER, 0)
}

func (s *NumberContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserFLOAT, 0)
}

func (s *NumberContext) PLUS() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserPLUS, 0)
}

func (s *NumberContext) MINUS() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserMINUS, 0)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (p *jvmBasicParser) Number() (localctx INumberContext) {
	this := p
	_ = this

	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, jvmBasicParserRULE_number)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(620)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jvmBasicParserPLUS || _la == jvmBasicParserMINUS {
		{
			p.SetState(619)
			_la = p.GetTokenStream().LA(1)

			if !(_la == jvmBasicParserPLUS || _la == jvmBasicParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(622)
		_la = p.GetTokenStream().LA(1)

		if !(_la == jvmBasicParserNUMBER || _la == jvmBasicParserFLOAT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFunc_Context is an interface to support dynamic dispatch.
type IFunc_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunc_Context differentiates from other interfaces.
	IsFunc_Context()
}

type Func_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_Context() *Func_Context {
	var p = new(Func_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_func_
	return p
}

func (*Func_Context) IsFunc_Context() {}

func NewFunc_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_Context {
	var p = new(Func_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_func_

	return p
}

func (s *Func_Context) GetParser() antlr.Parser { return s.parser }

func (s *Func_Context) STRINGLITERAL() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSTRINGLITERAL, 0)
}

func (s *Func_Context) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Func_Context) Tabfunc() ITabfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITabfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITabfuncContext)
}

func (s *Func_Context) Vardecl() IVardeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVardeclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *Func_Context) Chrfunc() IChrfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChrfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChrfuncContext)
}

func (s *Func_Context) Sqrfunc() ISqrfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqrfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISqrfuncContext)
}

func (s *Func_Context) Lenfunc() ILenfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILenfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILenfuncContext)
}

func (s *Func_Context) Strfunc() IStrfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrfuncContext)
}

func (s *Func_Context) Ascfunc() IAscfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAscfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAscfuncContext)
}

func (s *Func_Context) Scrnfunc() IScrnfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScrnfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScrnfuncContext)
}

func (s *Func_Context) Midfunc() IMidfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMidfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMidfuncContext)
}

func (s *Func_Context) Pdlfunc() IPdlfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPdlfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPdlfuncContext)
}

func (s *Func_Context) Peekfunc() IPeekfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPeekfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPeekfuncContext)
}

func (s *Func_Context) Intfunc() IIntfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntfuncContext)
}

func (s *Func_Context) Spcfunc() ISpcfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpcfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpcfuncContext)
}

func (s *Func_Context) Frefunc() IFrefuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFrefuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFrefuncContext)
}

func (s *Func_Context) Posfunc() IPosfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPosfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPosfuncContext)
}

func (s *Func_Context) Usrfunc() IUsrfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsrfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUsrfuncContext)
}

func (s *Func_Context) Leftfunc() ILeftfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeftfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeftfuncContext)
}

func (s *Func_Context) Valfunc() IValfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValfuncContext)
}

func (s *Func_Context) Rightfunc() IRightfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRightfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRightfuncContext)
}

func (s *Func_Context) Fnfunc() IFnfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFnfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFnfuncContext)
}

func (s *Func_Context) Sinfunc() ISinfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISinfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISinfuncContext)
}

func (s *Func_Context) Cosfunc() ICosfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICosfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICosfuncContext)
}

func (s *Func_Context) Tanfunc() ITanfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITanfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITanfuncContext)
}

func (s *Func_Context) Atnfunc() IAtnfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtnfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtnfuncContext)
}

func (s *Func_Context) Rndfunc() IRndfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRndfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRndfuncContext)
}

func (s *Func_Context) Sgnfunc() ISgnfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISgnfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISgnfuncContext)
}

func (s *Func_Context) Expfunc() IExpfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpfuncContext)
}

func (s *Func_Context) Logfunc() ILogfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogfuncContext)
}

func (s *Func_Context) Absfunc() IAbsfuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbsfuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbsfuncContext)
}

func (s *Func_Context) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *Func_Context) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Func_Context) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *Func_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterFunc_(s)
	}
}

func (s *Func_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitFunc_(s)
	}
}

func (p *jvmBasicParser) Func_() (localctx IFunc_Context) {
	this := p
	_ = this

	localctx = NewFunc_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, jvmBasicParserRULE_func_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(659)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jvmBasicParserSTRINGLITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(624)
			p.Match(jvmBasicParserSTRINGLITERAL)
		}

	case jvmBasicParserPLUS, jvmBasicParserMINUS, jvmBasicParserNUMBER, jvmBasicParserFLOAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(625)
			p.Number()
		}

	case jvmBasicParserTAB:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(626)
			p.Tabfunc()
		}

	case jvmBasicParserLETTERS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(627)
			p.Vardecl()
		}

	case jvmBasicParserCHR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(628)
			p.Chrfunc()
		}

	case jvmBasicParserSQR:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(629)
			p.Sqrfunc()
		}

	case jvmBasicParserLEN:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(630)
			p.Lenfunc()
		}

	case jvmBasicParserSTR:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(631)
			p.Strfunc()
		}

	case jvmBasicParserASC:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(632)
			p.Ascfunc()
		}

	case jvmBasicParserSCRN:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(633)
			p.Scrnfunc()
		}

	case jvmBasicParserMID:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(634)
			p.Midfunc()
		}

	case jvmBasicParserPDL:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(635)
			p.Pdlfunc()
		}

	case jvmBasicParserPEEK:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(636)
			p.Peekfunc()
		}

	case jvmBasicParserINTF:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(637)
			p.Intfunc()
		}

	case jvmBasicParserSPC:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(638)
			p.Spcfunc()
		}

	case jvmBasicParserFRE:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(639)
			p.Frefunc()
		}

	case jvmBasicParserPOS:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(640)
			p.Posfunc()
		}

	case jvmBasicParserUSR:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(641)
			p.Usrfunc()
		}

	case jvmBasicParserLEFT:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(642)
			p.Leftfunc()
		}

	case jvmBasicParserVAL:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(643)
			p.Valfunc()
		}

	case jvmBasicParserRIGHT:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(644)
			p.Rightfunc()
		}

	case jvmBasicParserFN:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(645)
			p.Fnfunc()
		}

	case jvmBasicParserSIN:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(646)
			p.Sinfunc()
		}

	case jvmBasicParserCOS:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(647)
			p.Cosfunc()
		}

	case jvmBasicParserTAN:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(648)
			p.Tanfunc()
		}

	case jvmBasicParserATN:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(649)
			p.Atnfunc()
		}

	case jvmBasicParserRND:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(650)
			p.Rndfunc()
		}

	case jvmBasicParserSGN:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(651)
			p.Sgnfunc()
		}

	case jvmBasicParserEXP:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(652)
			p.Expfunc()
		}

	case jvmBasicParserLOG:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(653)
			p.Logfunc()
		}

	case jvmBasicParserABS:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(654)
			p.Absfunc()
		}

	case jvmBasicParserLPAREN:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(655)
			p.Match(jvmBasicParserLPAREN)
		}
		{
			p.SetState(656)
			p.Expression()
		}
		{
			p.SetState(657)
			p.Match(jvmBasicParserRPAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISignExpressionContext is an interface to support dynamic dispatch.
type ISignExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignExpressionContext differentiates from other interfaces.
	IsSignExpressionContext()
}

type SignExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignExpressionContext() *SignExpressionContext {
	var p = new(SignExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_signExpression
	return p
}

func (*SignExpressionContext) IsSignExpressionContext() {}

func NewSignExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignExpressionContext {
	var p = new(SignExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_signExpression

	return p
}

func (s *SignExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SignExpressionContext) Func_() IFunc_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_Context)
}

func (s *SignExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserNOT, 0)
}

func (s *SignExpressionContext) PLUS() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserPLUS, 0)
}

func (s *SignExpressionContext) MINUS() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserMINUS, 0)
}

func (s *SignExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterSignExpression(s)
	}
}

func (s *SignExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitSignExpression(s)
	}
}

func (p *jvmBasicParser) SignExpression() (localctx ISignExpressionContext) {
	this := p
	_ = this

	localctx = NewSignExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, jvmBasicParserRULE_signExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(662)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jvmBasicParserNOT {
		{
			p.SetState(661)
			p.Match(jvmBasicParserNOT)
		}

	}
	p.SetState(665)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(664)
			_la = p.GetTokenStream().LA(1)

			if !(_la == jvmBasicParserPLUS || _la == jvmBasicParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(667)
		p.Func_()
	}

	return localctx
}

// IExponentExpressionContext is an interface to support dynamic dispatch.
type IExponentExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExponentExpressionContext differentiates from other interfaces.
	IsExponentExpressionContext()
}

type ExponentExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExponentExpressionContext() *ExponentExpressionContext {
	var p = new(ExponentExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_exponentExpression
	return p
}

func (*ExponentExpressionContext) IsExponentExpressionContext() {}

func NewExponentExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExponentExpressionContext {
	var p = new(ExponentExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_exponentExpression

	return p
}

func (s *ExponentExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExponentExpressionContext) AllSignExpression() []ISignExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISignExpressionContext)(nil)).Elem())
	var tst = make([]ISignExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISignExpressionContext)
		}
	}

	return tst
}

func (s *ExponentExpressionContext) SignExpression(i int) ISignExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISignExpressionContext)
}

func (s *ExponentExpressionContext) AllEXPONENT() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserEXPONENT)
}

func (s *ExponentExpressionContext) EXPONENT(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserEXPONENT, i)
}

func (s *ExponentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExponentExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExponentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterExponentExpression(s)
	}
}

func (s *ExponentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitExponentExpression(s)
	}
}

func (p *jvmBasicParser) ExponentExpression() (localctx IExponentExpressionContext) {
	this := p
	_ = this

	localctx = NewExponentExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, jvmBasicParserRULE_exponentExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(669)
		p.SignExpression()
	}
	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jvmBasicParserEXPONENT {
		{
			p.SetState(670)
			p.Match(jvmBasicParserEXPONENT)
		}
		{
			p.SetState(671)
			p.SignExpression()
		}

		p.SetState(676)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMultiplyingExpressionContext is an interface to support dynamic dispatch.
type IMultiplyingExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyingExpressionContext differentiates from other interfaces.
	IsMultiplyingExpressionContext()
}

type MultiplyingExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyingExpressionContext() *MultiplyingExpressionContext {
	var p = new(MultiplyingExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_multiplyingExpression
	return p
}

func (*MultiplyingExpressionContext) IsMultiplyingExpressionContext() {}

func NewMultiplyingExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyingExpressionContext {
	var p = new(MultiplyingExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_multiplyingExpression

	return p
}

func (s *MultiplyingExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyingExpressionContext) AllExponentExpression() []IExponentExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExponentExpressionContext)(nil)).Elem())
	var tst = make([]IExponentExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExponentExpressionContext)
		}
	}

	return tst
}

func (s *MultiplyingExpressionContext) ExponentExpression(i int) IExponentExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExponentExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExponentExpressionContext)
}

func (s *MultiplyingExpressionContext) AllTIMES() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserTIMES)
}

func (s *MultiplyingExpressionContext) TIMES(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserTIMES, i)
}

func (s *MultiplyingExpressionContext) AllDIV() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserDIV)
}

func (s *MultiplyingExpressionContext) DIV(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserDIV, i)
}

func (s *MultiplyingExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyingExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyingExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterMultiplyingExpression(s)
	}
}

func (s *MultiplyingExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitMultiplyingExpression(s)
	}
}

func (p *jvmBasicParser) MultiplyingExpression() (localctx IMultiplyingExpressionContext) {
	this := p
	_ = this

	localctx = NewMultiplyingExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, jvmBasicParserRULE_multiplyingExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(677)
		p.ExponentExpression()
	}
	p.SetState(682)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jvmBasicParserTIMES || _la == jvmBasicParserDIV {
		{
			p.SetState(678)
			_la = p.GetTokenStream().LA(1)

			if !(_la == jvmBasicParserTIMES || _la == jvmBasicParserDIV) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(679)
			p.ExponentExpression()
		}

		p.SetState(684)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAddingExpressionContext is an interface to support dynamic dispatch.
type IAddingExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddingExpressionContext differentiates from other interfaces.
	IsAddingExpressionContext()
}

type AddingExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddingExpressionContext() *AddingExpressionContext {
	var p = new(AddingExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_addingExpression
	return p
}

func (*AddingExpressionContext) IsAddingExpressionContext() {}

func NewAddingExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddingExpressionContext {
	var p = new(AddingExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_addingExpression

	return p
}

func (s *AddingExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AddingExpressionContext) AllMultiplyingExpression() []IMultiplyingExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplyingExpressionContext)(nil)).Elem())
	var tst = make([]IMultiplyingExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplyingExpressionContext)
		}
	}

	return tst
}

func (s *AddingExpressionContext) MultiplyingExpression(i int) IMultiplyingExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyingExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplyingExpressionContext)
}

func (s *AddingExpressionContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserPLUS)
}

func (s *AddingExpressionContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserPLUS, i)
}

func (s *AddingExpressionContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserMINUS)
}

func (s *AddingExpressionContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserMINUS, i)
}

func (s *AddingExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddingExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddingExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterAddingExpression(s)
	}
}

func (s *AddingExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitAddingExpression(s)
	}
}

func (p *jvmBasicParser) AddingExpression() (localctx IAddingExpressionContext) {
	this := p
	_ = this

	localctx = NewAddingExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, jvmBasicParserRULE_addingExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.MultiplyingExpression()
	}
	p.SetState(690)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jvmBasicParserPLUS || _la == jvmBasicParserMINUS {
		{
			p.SetState(686)
			_la = p.GetTokenStream().LA(1)

			if !(_la == jvmBasicParserPLUS || _la == jvmBasicParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(687)
			p.MultiplyingExpression()
		}

		p.SetState(692)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRelationalExpressionContext is an interface to support dynamic dispatch.
type IRelationalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationalExpressionContext differentiates from other interfaces.
	IsRelationalExpressionContext()
}

type RelationalExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationalExpressionContext() *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_relationalExpression
	return p
}

func (*RelationalExpressionContext) IsRelationalExpressionContext() {}

func NewRelationalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_relationalExpression

	return p
}

func (s *RelationalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationalExpressionContext) AllAddingExpression() []IAddingExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddingExpressionContext)(nil)).Elem())
	var tst = make([]IAddingExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddingExpressionContext)
		}
	}

	return tst
}

func (s *RelationalExpressionContext) AddingExpression(i int) IAddingExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddingExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddingExpressionContext)
}

func (s *RelationalExpressionContext) Relop() IRelopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelopContext)
}

func (s *RelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitRelationalExpression(s)
	}
}

func (p *jvmBasicParser) RelationalExpression() (localctx IRelationalExpressionContext) {
	this := p
	_ = this

	localctx = NewRelationalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, jvmBasicParserRULE_relationalExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.AddingExpression()
	}
	p.SetState(697)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-23)&-(0x1f+1)) == 0 && ((1<<uint((_la-23)))&((1<<(jvmBasicParserGTE-23))|(1<<(jvmBasicParserLTE-23))|(1<<(jvmBasicParserGT-23))|(1<<(jvmBasicParserLT-23))|(1<<(jvmBasicParserEQ-23)))) != 0 {
		{
			p.SetState(694)
			p.Relop()
		}

		{
			p.SetState(695)
			p.AddingExpression()
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Func_() IFunc_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_Context)
}

func (s *ExpressionContext) AllRelationalExpression() []IRelationalExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationalExpressionContext)(nil)).Elem())
	var tst = make([]IRelationalExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationalExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) RelationalExpression(i int) IRelationalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationalExpressionContext)
}

func (s *ExpressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserAND)
}

func (s *ExpressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserAND, i)
}

func (s *ExpressionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserOR)
}

func (s *ExpressionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserOR, i)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *jvmBasicParser) Expression() (localctx IExpressionContext) {
	this := p
	_ = this

	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, jvmBasicParserRULE_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(699)
			p.Func_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(700)
			p.RelationalExpression()
		}
		p.SetState(705)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == jvmBasicParserAND || _la == jvmBasicParserOR {
			{
				p.SetState(701)
				_la = p.GetTokenStream().LA(1)

				if !(_la == jvmBasicParserAND || _la == jvmBasicParserOR) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(702)
				p.RelationalExpression()
			}

			p.SetState(707)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IVar_Context is an interface to support dynamic dispatch.
type IVar_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVar_Context differentiates from other interfaces.
	IsVar_Context()
}

type Var_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_Context() *Var_Context {
	var p = new(Var_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_var_
	return p
}

func (*Var_Context) IsVar_Context() {}

func NewVar_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_Context {
	var p = new(Var_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_var_

	return p
}

func (s *Var_Context) GetParser() antlr.Parser { return s.parser }

func (s *Var_Context) Varname() IVarnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarnameContext)
}

func (s *Var_Context) Varsuffix() IVarsuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarsuffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarsuffixContext)
}

func (s *Var_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterVar_(s)
	}
}

func (s *Var_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitVar_(s)
	}
}

func (p *jvmBasicParser) Var_() (localctx IVar_Context) {
	this := p
	_ = this

	localctx = NewVar_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, jvmBasicParserRULE_var_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(710)
		p.Varname()
	}
	p.SetState(712)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jvmBasicParserDOLLAR || _la == jvmBasicParserPERCENT {
		{
			p.SetState(711)
			p.Varsuffix()
		}

	}

	return localctx
}

// IVarnameContext is an interface to support dynamic dispatch.
type IVarnameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarnameContext differentiates from other interfaces.
	IsVarnameContext()
}

type VarnameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarnameContext() *VarnameContext {
	var p = new(VarnameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_varname
	return p
}

func (*VarnameContext) IsVarnameContext() {}

func NewVarnameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarnameContext {
	var p = new(VarnameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_varname

	return p
}

func (s *VarnameContext) GetParser() antlr.Parser { return s.parser }

func (s *VarnameContext) AllLETTERS() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserLETTERS)
}

func (s *VarnameContext) LETTERS(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLETTERS, i)
}

func (s *VarnameContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserNUMBER)
}

func (s *VarnameContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserNUMBER, i)
}

func (s *VarnameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarnameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarnameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterVarname(s)
	}
}

func (s *VarnameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitVarname(s)
	}
}

func (p *jvmBasicParser) Varname() (localctx IVarnameContext) {
	this := p
	_ = this

	localctx = NewVarnameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, jvmBasicParserRULE_varname)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(714)
		p.Match(jvmBasicParserLETTERS)
	}
	p.SetState(718)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(715)
				_la = p.GetTokenStream().LA(1)

				if !(_la == jvmBasicParserLETTERS || _la == jvmBasicParserNUMBER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(720)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())
	}

	return localctx
}

// IVarsuffixContext is an interface to support dynamic dispatch.
type IVarsuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarsuffixContext differentiates from other interfaces.
	IsVarsuffixContext()
}

type VarsuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarsuffixContext() *VarsuffixContext {
	var p = new(VarsuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_varsuffix
	return p
}

func (*VarsuffixContext) IsVarsuffixContext() {}

func NewVarsuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarsuffixContext {
	var p = new(VarsuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_varsuffix

	return p
}

func (s *VarsuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *VarsuffixContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserDOLLAR, 0)
}

func (s *VarsuffixContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserPERCENT, 0)
}

func (s *VarsuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarsuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarsuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterVarsuffix(s)
	}
}

func (s *VarsuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitVarsuffix(s)
	}
}

func (p *jvmBasicParser) Varsuffix() (localctx IVarsuffixContext) {
	this := p
	_ = this

	localctx = NewVarsuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, jvmBasicParserRULE_varsuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(721)
		_la = p.GetTokenStream().LA(1)

		if !(_la == jvmBasicParserDOLLAR || _la == jvmBasicParserPERCENT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IVarlistContext is an interface to support dynamic dispatch.
type IVarlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarlistContext differentiates from other interfaces.
	IsVarlistContext()
}

type VarlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarlistContext() *VarlistContext {
	var p = new(VarlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_varlist
	return p
}

func (*VarlistContext) IsVarlistContext() {}

func NewVarlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarlistContext {
	var p = new(VarlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_varlist

	return p
}

func (s *VarlistContext) GetParser() antlr.Parser { return s.parser }

func (s *VarlistContext) AllVardecl() []IVardeclContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVardeclContext)(nil)).Elem())
	var tst = make([]IVardeclContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVardeclContext)
		}
	}

	return tst
}

func (s *VarlistContext) Vardecl(i int) IVardeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVardeclContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *VarlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserCOMMA)
}

func (s *VarlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, i)
}

func (s *VarlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterVarlist(s)
	}
}

func (s *VarlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitVarlist(s)
	}
}

func (p *jvmBasicParser) Varlist() (localctx IVarlistContext) {
	this := p
	_ = this

	localctx = NewVarlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, jvmBasicParserRULE_varlist)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(723)
		p.Vardecl()
	}
	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jvmBasicParserCOMMA {
		{
			p.SetState(724)
			p.Match(jvmBasicParserCOMMA)
		}
		{
			p.SetState(725)
			p.Vardecl()
		}

		p.SetState(730)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExprlistContext is an interface to support dynamic dispatch.
type IExprlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprlistContext differentiates from other interfaces.
	IsExprlistContext()
}

type ExprlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprlistContext() *ExprlistContext {
	var p = new(ExprlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_exprlist
	return p
}

func (*ExprlistContext) IsExprlistContext() {}

func NewExprlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprlistContext {
	var p = new(ExprlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_exprlist

	return p
}

func (s *ExprlistContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprlistContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExprlistContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExprlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserCOMMA)
}

func (s *ExprlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, i)
}

func (s *ExprlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterExprlist(s)
	}
}

func (s *ExprlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitExprlist(s)
	}
}

func (p *jvmBasicParser) Exprlist() (localctx IExprlistContext) {
	this := p
	_ = this

	localctx = NewExprlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, jvmBasicParserRULE_exprlist)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(731)
		p.Expression()
	}
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jvmBasicParserCOMMA {
		{
			p.SetState(732)
			p.Match(jvmBasicParserCOMMA)
		}
		{
			p.SetState(733)
			p.Expression()
		}

		p.SetState(738)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISqrfuncContext is an interface to support dynamic dispatch.
type ISqrfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSqrfuncContext differentiates from other interfaces.
	IsSqrfuncContext()
}

type SqrfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqrfuncContext() *SqrfuncContext {
	var p = new(SqrfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_sqrfunc
	return p
}

func (*SqrfuncContext) IsSqrfuncContext() {}

func NewSqrfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqrfuncContext {
	var p = new(SqrfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_sqrfunc

	return p
}

func (s *SqrfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *SqrfuncContext) SQR() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSQR, 0)
}

func (s *SqrfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *SqrfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SqrfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *SqrfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqrfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqrfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterSqrfunc(s)
	}
}

func (s *SqrfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitSqrfunc(s)
	}
}

func (p *jvmBasicParser) Sqrfunc() (localctx ISqrfuncContext) {
	this := p
	_ = this

	localctx = NewSqrfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, jvmBasicParserRULE_sqrfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.Match(jvmBasicParserSQR)
	}
	{
		p.SetState(740)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(741)
		p.Expression()
	}
	{
		p.SetState(742)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IChrfuncContext is an interface to support dynamic dispatch.
type IChrfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChrfuncContext differentiates from other interfaces.
	IsChrfuncContext()
}

type ChrfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChrfuncContext() *ChrfuncContext {
	var p = new(ChrfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_chrfunc
	return p
}

func (*ChrfuncContext) IsChrfuncContext() {}

func NewChrfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChrfuncContext {
	var p = new(ChrfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_chrfunc

	return p
}

func (s *ChrfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *ChrfuncContext) CHR() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCHR, 0)
}

func (s *ChrfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *ChrfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ChrfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *ChrfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChrfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChrfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterChrfunc(s)
	}
}

func (s *ChrfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitChrfunc(s)
	}
}

func (p *jvmBasicParser) Chrfunc() (localctx IChrfuncContext) {
	this := p
	_ = this

	localctx = NewChrfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, jvmBasicParserRULE_chrfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(744)
		p.Match(jvmBasicParserCHR)
	}
	{
		p.SetState(745)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(746)
		p.Expression()
	}
	{
		p.SetState(747)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// ILenfuncContext is an interface to support dynamic dispatch.
type ILenfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLenfuncContext differentiates from other interfaces.
	IsLenfuncContext()
}

type LenfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLenfuncContext() *LenfuncContext {
	var p = new(LenfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_lenfunc
	return p
}

func (*LenfuncContext) IsLenfuncContext() {}

func NewLenfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LenfuncContext {
	var p = new(LenfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_lenfunc

	return p
}

func (s *LenfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *LenfuncContext) LEN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLEN, 0)
}

func (s *LenfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *LenfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LenfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *LenfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LenfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LenfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterLenfunc(s)
	}
}

func (s *LenfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitLenfunc(s)
	}
}

func (p *jvmBasicParser) Lenfunc() (localctx ILenfuncContext) {
	this := p
	_ = this

	localctx = NewLenfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, jvmBasicParserRULE_lenfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(749)
		p.Match(jvmBasicParserLEN)
	}
	{
		p.SetState(750)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(751)
		p.Expression()
	}
	{
		p.SetState(752)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IAscfuncContext is an interface to support dynamic dispatch.
type IAscfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAscfuncContext differentiates from other interfaces.
	IsAscfuncContext()
}

type AscfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAscfuncContext() *AscfuncContext {
	var p = new(AscfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_ascfunc
	return p
}

func (*AscfuncContext) IsAscfuncContext() {}

func NewAscfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AscfuncContext {
	var p = new(AscfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_ascfunc

	return p
}

func (s *AscfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *AscfuncContext) ASC() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserASC, 0)
}

func (s *AscfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *AscfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AscfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *AscfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AscfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AscfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterAscfunc(s)
	}
}

func (s *AscfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitAscfunc(s)
	}
}

func (p *jvmBasicParser) Ascfunc() (localctx IAscfuncContext) {
	this := p
	_ = this

	localctx = NewAscfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, jvmBasicParserRULE_ascfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(754)
		p.Match(jvmBasicParserASC)
	}
	{
		p.SetState(755)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(756)
		p.Expression()
	}
	{
		p.SetState(757)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IMidfuncContext is an interface to support dynamic dispatch.
type IMidfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMidfuncContext differentiates from other interfaces.
	IsMidfuncContext()
}

type MidfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMidfuncContext() *MidfuncContext {
	var p = new(MidfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_midfunc
	return p
}

func (*MidfuncContext) IsMidfuncContext() {}

func NewMidfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MidfuncContext {
	var p = new(MidfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_midfunc

	return p
}

func (s *MidfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *MidfuncContext) MID() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserMID, 0)
}

func (s *MidfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *MidfuncContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *MidfuncContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MidfuncContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(jvmBasicParserCOMMA)
}

func (s *MidfuncContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, i)
}

func (s *MidfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *MidfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MidfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MidfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterMidfunc(s)
	}
}

func (s *MidfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitMidfunc(s)
	}
}

func (p *jvmBasicParser) Midfunc() (localctx IMidfuncContext) {
	this := p
	_ = this

	localctx = NewMidfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, jvmBasicParserRULE_midfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.Match(jvmBasicParserMID)
	}
	{
		p.SetState(760)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(761)
		p.Expression()
	}
	{
		p.SetState(762)
		p.Match(jvmBasicParserCOMMA)
	}
	{
		p.SetState(763)
		p.Expression()
	}
	{
		p.SetState(764)
		p.Match(jvmBasicParserCOMMA)
	}
	{
		p.SetState(765)
		p.Expression()
	}
	{
		p.SetState(766)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IPdlfuncContext is an interface to support dynamic dispatch.
type IPdlfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPdlfuncContext differentiates from other interfaces.
	IsPdlfuncContext()
}

type PdlfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPdlfuncContext() *PdlfuncContext {
	var p = new(PdlfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_pdlfunc
	return p
}

func (*PdlfuncContext) IsPdlfuncContext() {}

func NewPdlfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PdlfuncContext {
	var p = new(PdlfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_pdlfunc

	return p
}

func (s *PdlfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *PdlfuncContext) PDL() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserPDL, 0)
}

func (s *PdlfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *PdlfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PdlfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *PdlfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PdlfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PdlfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterPdlfunc(s)
	}
}

func (s *PdlfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitPdlfunc(s)
	}
}

func (p *jvmBasicParser) Pdlfunc() (localctx IPdlfuncContext) {
	this := p
	_ = this

	localctx = NewPdlfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, jvmBasicParserRULE_pdlfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(768)
		p.Match(jvmBasicParserPDL)
	}
	{
		p.SetState(769)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(770)
		p.Expression()
	}
	{
		p.SetState(771)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IPeekfuncContext is an interface to support dynamic dispatch.
type IPeekfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPeekfuncContext differentiates from other interfaces.
	IsPeekfuncContext()
}

type PeekfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPeekfuncContext() *PeekfuncContext {
	var p = new(PeekfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_peekfunc
	return p
}

func (*PeekfuncContext) IsPeekfuncContext() {}

func NewPeekfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PeekfuncContext {
	var p = new(PeekfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_peekfunc

	return p
}

func (s *PeekfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *PeekfuncContext) PEEK() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserPEEK, 0)
}

func (s *PeekfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *PeekfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PeekfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *PeekfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PeekfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PeekfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterPeekfunc(s)
	}
}

func (s *PeekfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitPeekfunc(s)
	}
}

func (p *jvmBasicParser) Peekfunc() (localctx IPeekfuncContext) {
	this := p
	_ = this

	localctx = NewPeekfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, jvmBasicParserRULE_peekfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(773)
		p.Match(jvmBasicParserPEEK)
	}
	{
		p.SetState(774)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(775)
		p.Expression()
	}
	{
		p.SetState(776)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IIntfuncContext is an interface to support dynamic dispatch.
type IIntfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntfuncContext differentiates from other interfaces.
	IsIntfuncContext()
}

type IntfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntfuncContext() *IntfuncContext {
	var p = new(IntfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_intfunc
	return p
}

func (*IntfuncContext) IsIntfuncContext() {}

func NewIntfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntfuncContext {
	var p = new(IntfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_intfunc

	return p
}

func (s *IntfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *IntfuncContext) INTF() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserINTF, 0)
}

func (s *IntfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *IntfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *IntfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterIntfunc(s)
	}
}

func (s *IntfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitIntfunc(s)
	}
}

func (p *jvmBasicParser) Intfunc() (localctx IIntfuncContext) {
	this := p
	_ = this

	localctx = NewIntfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, jvmBasicParserRULE_intfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(778)
		p.Match(jvmBasicParserINTF)
	}
	{
		p.SetState(779)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(780)
		p.Expression()
	}
	{
		p.SetState(781)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// ISpcfuncContext is an interface to support dynamic dispatch.
type ISpcfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpcfuncContext differentiates from other interfaces.
	IsSpcfuncContext()
}

type SpcfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpcfuncContext() *SpcfuncContext {
	var p = new(SpcfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_spcfunc
	return p
}

func (*SpcfuncContext) IsSpcfuncContext() {}

func NewSpcfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpcfuncContext {
	var p = new(SpcfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_spcfunc

	return p
}

func (s *SpcfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *SpcfuncContext) SPC() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSPC, 0)
}

func (s *SpcfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *SpcfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SpcfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *SpcfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpcfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpcfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterSpcfunc(s)
	}
}

func (s *SpcfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitSpcfunc(s)
	}
}

func (p *jvmBasicParser) Spcfunc() (localctx ISpcfuncContext) {
	this := p
	_ = this

	localctx = NewSpcfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, jvmBasicParserRULE_spcfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(783)
		p.Match(jvmBasicParserSPC)
	}
	{
		p.SetState(784)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(785)
		p.Expression()
	}
	{
		p.SetState(786)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IFrefuncContext is an interface to support dynamic dispatch.
type IFrefuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFrefuncContext differentiates from other interfaces.
	IsFrefuncContext()
}

type FrefuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrefuncContext() *FrefuncContext {
	var p = new(FrefuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_frefunc
	return p
}

func (*FrefuncContext) IsFrefuncContext() {}

func NewFrefuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrefuncContext {
	var p = new(FrefuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_frefunc

	return p
}

func (s *FrefuncContext) GetParser() antlr.Parser { return s.parser }

func (s *FrefuncContext) FRE() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserFRE, 0)
}

func (s *FrefuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *FrefuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FrefuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *FrefuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrefuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrefuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterFrefunc(s)
	}
}

func (s *FrefuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitFrefunc(s)
	}
}

func (p *jvmBasicParser) Frefunc() (localctx IFrefuncContext) {
	this := p
	_ = this

	localctx = NewFrefuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, jvmBasicParserRULE_frefunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(788)
		p.Match(jvmBasicParserFRE)
	}
	{
		p.SetState(789)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(790)
		p.Expression()
	}
	{
		p.SetState(791)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IPosfuncContext is an interface to support dynamic dispatch.
type IPosfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPosfuncContext differentiates from other interfaces.
	IsPosfuncContext()
}

type PosfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPosfuncContext() *PosfuncContext {
	var p = new(PosfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_posfunc
	return p
}

func (*PosfuncContext) IsPosfuncContext() {}

func NewPosfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PosfuncContext {
	var p = new(PosfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_posfunc

	return p
}

func (s *PosfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *PosfuncContext) POS() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserPOS, 0)
}

func (s *PosfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *PosfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PosfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *PosfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PosfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PosfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterPosfunc(s)
	}
}

func (s *PosfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitPosfunc(s)
	}
}

func (p *jvmBasicParser) Posfunc() (localctx IPosfuncContext) {
	this := p
	_ = this

	localctx = NewPosfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, jvmBasicParserRULE_posfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(793)
		p.Match(jvmBasicParserPOS)
	}
	{
		p.SetState(794)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(795)
		p.Expression()
	}
	{
		p.SetState(796)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IUsrfuncContext is an interface to support dynamic dispatch.
type IUsrfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUsrfuncContext differentiates from other interfaces.
	IsUsrfuncContext()
}

type UsrfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsrfuncContext() *UsrfuncContext {
	var p = new(UsrfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_usrfunc
	return p
}

func (*UsrfuncContext) IsUsrfuncContext() {}

func NewUsrfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsrfuncContext {
	var p = new(UsrfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_usrfunc

	return p
}

func (s *UsrfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *UsrfuncContext) USR() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserUSR, 0)
}

func (s *UsrfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *UsrfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UsrfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *UsrfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsrfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsrfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterUsrfunc(s)
	}
}

func (s *UsrfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitUsrfunc(s)
	}
}

func (p *jvmBasicParser) Usrfunc() (localctx IUsrfuncContext) {
	this := p
	_ = this

	localctx = NewUsrfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, jvmBasicParserRULE_usrfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(798)
		p.Match(jvmBasicParserUSR)
	}
	{
		p.SetState(799)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(800)
		p.Expression()
	}
	{
		p.SetState(801)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// ILeftfuncContext is an interface to support dynamic dispatch.
type ILeftfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLeftfuncContext differentiates from other interfaces.
	IsLeftfuncContext()
}

type LeftfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeftfuncContext() *LeftfuncContext {
	var p = new(LeftfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_leftfunc
	return p
}

func (*LeftfuncContext) IsLeftfuncContext() {}

func NewLeftfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeftfuncContext {
	var p = new(LeftfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_leftfunc

	return p
}

func (s *LeftfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *LeftfuncContext) LEFT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLEFT, 0)
}

func (s *LeftfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *LeftfuncContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *LeftfuncContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LeftfuncContext) COMMA() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, 0)
}

func (s *LeftfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *LeftfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeftfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterLeftfunc(s)
	}
}

func (s *LeftfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitLeftfunc(s)
	}
}

func (p *jvmBasicParser) Leftfunc() (localctx ILeftfuncContext) {
	this := p
	_ = this

	localctx = NewLeftfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, jvmBasicParserRULE_leftfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(803)
		p.Match(jvmBasicParserLEFT)
	}
	{
		p.SetState(804)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(805)
		p.Expression()
	}
	{
		p.SetState(806)
		p.Match(jvmBasicParserCOMMA)
	}
	{
		p.SetState(807)
		p.Expression()
	}
	{
		p.SetState(808)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IRightfuncContext is an interface to support dynamic dispatch.
type IRightfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRightfuncContext differentiates from other interfaces.
	IsRightfuncContext()
}

type RightfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRightfuncContext() *RightfuncContext {
	var p = new(RightfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_rightfunc
	return p
}

func (*RightfuncContext) IsRightfuncContext() {}

func NewRightfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RightfuncContext {
	var p = new(RightfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_rightfunc

	return p
}

func (s *RightfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *RightfuncContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRIGHT, 0)
}

func (s *RightfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *RightfuncContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *RightfuncContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RightfuncContext) COMMA() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, 0)
}

func (s *RightfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *RightfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RightfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RightfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterRightfunc(s)
	}
}

func (s *RightfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitRightfunc(s)
	}
}

func (p *jvmBasicParser) Rightfunc() (localctx IRightfuncContext) {
	this := p
	_ = this

	localctx = NewRightfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, jvmBasicParserRULE_rightfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(810)
		p.Match(jvmBasicParserRIGHT)
	}
	{
		p.SetState(811)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(812)
		p.Expression()
	}
	{
		p.SetState(813)
		p.Match(jvmBasicParserCOMMA)
	}
	{
		p.SetState(814)
		p.Expression()
	}
	{
		p.SetState(815)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IStrfuncContext is an interface to support dynamic dispatch.
type IStrfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrfuncContext differentiates from other interfaces.
	IsStrfuncContext()
}

type StrfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrfuncContext() *StrfuncContext {
	var p = new(StrfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_strfunc
	return p
}

func (*StrfuncContext) IsStrfuncContext() {}

func NewStrfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrfuncContext {
	var p = new(StrfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_strfunc

	return p
}

func (s *StrfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *StrfuncContext) STR() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSTR, 0)
}

func (s *StrfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *StrfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StrfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *StrfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StrfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterStrfunc(s)
	}
}

func (s *StrfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitStrfunc(s)
	}
}

func (p *jvmBasicParser) Strfunc() (localctx IStrfuncContext) {
	this := p
	_ = this

	localctx = NewStrfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, jvmBasicParserRULE_strfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(817)
		p.Match(jvmBasicParserSTR)
	}
	{
		p.SetState(818)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(819)
		p.Expression()
	}
	{
		p.SetState(820)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IFnfuncContext is an interface to support dynamic dispatch.
type IFnfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFnfuncContext differentiates from other interfaces.
	IsFnfuncContext()
}

type FnfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnfuncContext() *FnfuncContext {
	var p = new(FnfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_fnfunc
	return p
}

func (*FnfuncContext) IsFnfuncContext() {}

func NewFnfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnfuncContext {
	var p = new(FnfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_fnfunc

	return p
}

func (s *FnfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *FnfuncContext) FN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserFN, 0)
}

func (s *FnfuncContext) Var_() IVar_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVar_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVar_Context)
}

func (s *FnfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *FnfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FnfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *FnfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterFnfunc(s)
	}
}

func (s *FnfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitFnfunc(s)
	}
}

func (p *jvmBasicParser) Fnfunc() (localctx IFnfuncContext) {
	this := p
	_ = this

	localctx = NewFnfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, jvmBasicParserRULE_fnfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(822)
		p.Match(jvmBasicParserFN)
	}
	{
		p.SetState(823)
		p.Var_()
	}
	{
		p.SetState(824)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(825)
		p.Expression()
	}
	{
		p.SetState(826)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IValfuncContext is an interface to support dynamic dispatch.
type IValfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValfuncContext differentiates from other interfaces.
	IsValfuncContext()
}

type ValfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValfuncContext() *ValfuncContext {
	var p = new(ValfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_valfunc
	return p
}

func (*ValfuncContext) IsValfuncContext() {}

func NewValfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValfuncContext {
	var p = new(ValfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_valfunc

	return p
}

func (s *ValfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *ValfuncContext) VAL() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserVAL, 0)
}

func (s *ValfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *ValfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ValfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *ValfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterValfunc(s)
	}
}

func (s *ValfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitValfunc(s)
	}
}

func (p *jvmBasicParser) Valfunc() (localctx IValfuncContext) {
	this := p
	_ = this

	localctx = NewValfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, jvmBasicParserRULE_valfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(828)
		p.Match(jvmBasicParserVAL)
	}
	{
		p.SetState(829)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(830)
		p.Expression()
	}
	{
		p.SetState(831)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IScrnfuncContext is an interface to support dynamic dispatch.
type IScrnfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScrnfuncContext differentiates from other interfaces.
	IsScrnfuncContext()
}

type ScrnfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScrnfuncContext() *ScrnfuncContext {
	var p = new(ScrnfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_scrnfunc
	return p
}

func (*ScrnfuncContext) IsScrnfuncContext() {}

func NewScrnfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScrnfuncContext {
	var p = new(ScrnfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_scrnfunc

	return p
}

func (s *ScrnfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *ScrnfuncContext) SCRN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSCRN, 0)
}

func (s *ScrnfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *ScrnfuncContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ScrnfuncContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ScrnfuncContext) COMMA() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOMMA, 0)
}

func (s *ScrnfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *ScrnfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScrnfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScrnfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterScrnfunc(s)
	}
}

func (s *ScrnfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitScrnfunc(s)
	}
}

func (p *jvmBasicParser) Scrnfunc() (localctx IScrnfuncContext) {
	this := p
	_ = this

	localctx = NewScrnfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, jvmBasicParserRULE_scrnfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(833)
		p.Match(jvmBasicParserSCRN)
	}
	{
		p.SetState(834)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(835)
		p.Expression()
	}
	{
		p.SetState(836)
		p.Match(jvmBasicParserCOMMA)
	}
	{
		p.SetState(837)
		p.Expression()
	}
	{
		p.SetState(838)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// ISinfuncContext is an interface to support dynamic dispatch.
type ISinfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSinfuncContext differentiates from other interfaces.
	IsSinfuncContext()
}

type SinfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySinfuncContext() *SinfuncContext {
	var p = new(SinfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_sinfunc
	return p
}

func (*SinfuncContext) IsSinfuncContext() {}

func NewSinfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SinfuncContext {
	var p = new(SinfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_sinfunc

	return p
}

func (s *SinfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *SinfuncContext) SIN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSIN, 0)
}

func (s *SinfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *SinfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SinfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *SinfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SinfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SinfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterSinfunc(s)
	}
}

func (s *SinfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitSinfunc(s)
	}
}

func (p *jvmBasicParser) Sinfunc() (localctx ISinfuncContext) {
	this := p
	_ = this

	localctx = NewSinfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, jvmBasicParserRULE_sinfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(840)
		p.Match(jvmBasicParserSIN)
	}
	{
		p.SetState(841)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(842)
		p.Expression()
	}
	{
		p.SetState(843)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// ICosfuncContext is an interface to support dynamic dispatch.
type ICosfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCosfuncContext differentiates from other interfaces.
	IsCosfuncContext()
}

type CosfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCosfuncContext() *CosfuncContext {
	var p = new(CosfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_cosfunc
	return p
}

func (*CosfuncContext) IsCosfuncContext() {}

func NewCosfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CosfuncContext {
	var p = new(CosfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_cosfunc

	return p
}

func (s *CosfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *CosfuncContext) COS() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserCOS, 0)
}

func (s *CosfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *CosfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CosfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *CosfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CosfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CosfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterCosfunc(s)
	}
}

func (s *CosfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitCosfunc(s)
	}
}

func (p *jvmBasicParser) Cosfunc() (localctx ICosfuncContext) {
	this := p
	_ = this

	localctx = NewCosfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, jvmBasicParserRULE_cosfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(845)
		p.Match(jvmBasicParserCOS)
	}
	{
		p.SetState(846)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(847)
		p.Expression()
	}
	{
		p.SetState(848)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// ITanfuncContext is an interface to support dynamic dispatch.
type ITanfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTanfuncContext differentiates from other interfaces.
	IsTanfuncContext()
}

type TanfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTanfuncContext() *TanfuncContext {
	var p = new(TanfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_tanfunc
	return p
}

func (*TanfuncContext) IsTanfuncContext() {}

func NewTanfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TanfuncContext {
	var p = new(TanfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_tanfunc

	return p
}

func (s *TanfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *TanfuncContext) TAN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserTAN, 0)
}

func (s *TanfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *TanfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TanfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *TanfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TanfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TanfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterTanfunc(s)
	}
}

func (s *TanfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitTanfunc(s)
	}
}

func (p *jvmBasicParser) Tanfunc() (localctx ITanfuncContext) {
	this := p
	_ = this

	localctx = NewTanfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, jvmBasicParserRULE_tanfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.Match(jvmBasicParserTAN)
	}
	{
		p.SetState(851)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(852)
		p.Expression()
	}
	{
		p.SetState(853)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IAtnfuncContext is an interface to support dynamic dispatch.
type IAtnfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtnfuncContext differentiates from other interfaces.
	IsAtnfuncContext()
}

type AtnfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtnfuncContext() *AtnfuncContext {
	var p = new(AtnfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_atnfunc
	return p
}

func (*AtnfuncContext) IsAtnfuncContext() {}

func NewAtnfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtnfuncContext {
	var p = new(AtnfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_atnfunc

	return p
}

func (s *AtnfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *AtnfuncContext) ATN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserATN, 0)
}

func (s *AtnfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *AtnfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AtnfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *AtnfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtnfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtnfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterAtnfunc(s)
	}
}

func (s *AtnfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitAtnfunc(s)
	}
}

func (p *jvmBasicParser) Atnfunc() (localctx IAtnfuncContext) {
	this := p
	_ = this

	localctx = NewAtnfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, jvmBasicParserRULE_atnfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(855)
		p.Match(jvmBasicParserATN)
	}
	{
		p.SetState(856)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(857)
		p.Expression()
	}
	{
		p.SetState(858)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IRndfuncContext is an interface to support dynamic dispatch.
type IRndfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRndfuncContext differentiates from other interfaces.
	IsRndfuncContext()
}

type RndfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRndfuncContext() *RndfuncContext {
	var p = new(RndfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_rndfunc
	return p
}

func (*RndfuncContext) IsRndfuncContext() {}

func NewRndfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RndfuncContext {
	var p = new(RndfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_rndfunc

	return p
}

func (s *RndfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *RndfuncContext) RND() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRND, 0)
}

func (s *RndfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *RndfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RndfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *RndfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RndfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RndfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterRndfunc(s)
	}
}

func (s *RndfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitRndfunc(s)
	}
}

func (p *jvmBasicParser) Rndfunc() (localctx IRndfuncContext) {
	this := p
	_ = this

	localctx = NewRndfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, jvmBasicParserRULE_rndfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(860)
		p.Match(jvmBasicParserRND)
	}
	{
		p.SetState(861)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(862)
		p.Expression()
	}
	{
		p.SetState(863)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// ISgnfuncContext is an interface to support dynamic dispatch.
type ISgnfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSgnfuncContext differentiates from other interfaces.
	IsSgnfuncContext()
}

type SgnfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySgnfuncContext() *SgnfuncContext {
	var p = new(SgnfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_sgnfunc
	return p
}

func (*SgnfuncContext) IsSgnfuncContext() {}

func NewSgnfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SgnfuncContext {
	var p = new(SgnfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_sgnfunc

	return p
}

func (s *SgnfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *SgnfuncContext) SGN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserSGN, 0)
}

func (s *SgnfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *SgnfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SgnfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *SgnfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SgnfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SgnfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterSgnfunc(s)
	}
}

func (s *SgnfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitSgnfunc(s)
	}
}

func (p *jvmBasicParser) Sgnfunc() (localctx ISgnfuncContext) {
	this := p
	_ = this

	localctx = NewSgnfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, jvmBasicParserRULE_sgnfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(865)
		p.Match(jvmBasicParserSGN)
	}
	{
		p.SetState(866)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(867)
		p.Expression()
	}
	{
		p.SetState(868)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IExpfuncContext is an interface to support dynamic dispatch.
type IExpfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpfuncContext differentiates from other interfaces.
	IsExpfuncContext()
}

type ExpfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpfuncContext() *ExpfuncContext {
	var p = new(ExpfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_expfunc
	return p
}

func (*ExpfuncContext) IsExpfuncContext() {}

func NewExpfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpfuncContext {
	var p = new(ExpfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_expfunc

	return p
}

func (s *ExpfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpfuncContext) EXP() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserEXP, 0)
}

func (s *ExpfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *ExpfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *ExpfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterExpfunc(s)
	}
}

func (s *ExpfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitExpfunc(s)
	}
}

func (p *jvmBasicParser) Expfunc() (localctx IExpfuncContext) {
	this := p
	_ = this

	localctx = NewExpfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, jvmBasicParserRULE_expfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(870)
		p.Match(jvmBasicParserEXP)
	}
	{
		p.SetState(871)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(872)
		p.Expression()
	}
	{
		p.SetState(873)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// ILogfuncContext is an interface to support dynamic dispatch.
type ILogfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogfuncContext differentiates from other interfaces.
	IsLogfuncContext()
}

type LogfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogfuncContext() *LogfuncContext {
	var p = new(LogfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_logfunc
	return p
}

func (*LogfuncContext) IsLogfuncContext() {}

func NewLogfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogfuncContext {
	var p = new(LogfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_logfunc

	return p
}

func (s *LogfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *LogfuncContext) LOG() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLOG, 0)
}

func (s *LogfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *LogfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *LogfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterLogfunc(s)
	}
}

func (s *LogfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitLogfunc(s)
	}
}

func (p *jvmBasicParser) Logfunc() (localctx ILogfuncContext) {
	this := p
	_ = this

	localctx = NewLogfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, jvmBasicParserRULE_logfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(875)
		p.Match(jvmBasicParserLOG)
	}
	{
		p.SetState(876)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(877)
		p.Expression()
	}
	{
		p.SetState(878)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// IAbsfuncContext is an interface to support dynamic dispatch.
type IAbsfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbsfuncContext differentiates from other interfaces.
	IsAbsfuncContext()
}

type AbsfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbsfuncContext() *AbsfuncContext {
	var p = new(AbsfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_absfunc
	return p
}

func (*AbsfuncContext) IsAbsfuncContext() {}

func NewAbsfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbsfuncContext {
	var p = new(AbsfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_absfunc

	return p
}

func (s *AbsfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *AbsfuncContext) ABS() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserABS, 0)
}

func (s *AbsfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *AbsfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AbsfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *AbsfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbsfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbsfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterAbsfunc(s)
	}
}

func (s *AbsfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitAbsfunc(s)
	}
}

func (p *jvmBasicParser) Absfunc() (localctx IAbsfuncContext) {
	this := p
	_ = this

	localctx = NewAbsfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, jvmBasicParserRULE_absfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(880)
		p.Match(jvmBasicParserABS)
	}
	{
		p.SetState(881)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(882)
		p.Expression()
	}
	{
		p.SetState(883)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}

// ITabfuncContext is an interface to support dynamic dispatch.
type ITabfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTabfuncContext differentiates from other interfaces.
	IsTabfuncContext()
}

type TabfuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabfuncContext() *TabfuncContext {
	var p = new(TabfuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jvmBasicParserRULE_tabfunc
	return p
}

func (*TabfuncContext) IsTabfuncContext() {}

func NewTabfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabfuncContext {
	var p = new(TabfuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jvmBasicParserRULE_tabfunc

	return p
}

func (s *TabfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *TabfuncContext) TAB() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserTAB, 0)
}

func (s *TabfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserLPAREN, 0)
}

func (s *TabfuncContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TabfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(jvmBasicParserRPAREN, 0)
}

func (s *TabfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.EnterTabfunc(s)
	}
}

func (s *TabfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jvmBasicListener); ok {
		listenerT.ExitTabfunc(s)
	}
}

func (p *jvmBasicParser) Tabfunc() (localctx ITabfuncContext) {
	this := p
	_ = this

	localctx = NewTabfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, jvmBasicParserRULE_tabfunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(885)
		p.Match(jvmBasicParserTAB)
	}
	{
		p.SetState(886)
		p.Match(jvmBasicParserLPAREN)
	}
	{
		p.SetState(887)
		p.Expression()
	}
	{
		p.SetState(888)
		p.Match(jvmBasicParserRPAREN)
	}

	return localctx
}
