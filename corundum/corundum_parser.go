// Code generated from Corundum.g4 by ANTLR 4.9.3. DO NOT EDIT.

package corundum // Corundum
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 62, 826,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 5, 3, 154, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 160, 10, 3, 12,
	3, 14, 3, 163, 11, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3,
	4, 3, 4, 5, 4, 175, 10, 4, 3, 5, 3, 5, 3, 5, 3, 5, 3, 6, 3, 6, 3, 6, 3,
	6, 3, 7, 3, 7, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 10,
	3, 10, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 13, 3, 13, 3, 14, 3,
	14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 214, 10, 14,
	3, 15, 3, 15, 5, 15, 218, 10, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
	16, 3, 16, 5, 16, 227, 10, 16, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17,
	7, 17, 235, 10, 17, 12, 17, 14, 17, 238, 11, 17, 3, 18, 3, 18, 3, 19, 3,
	19, 3, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 5, 20, 257, 10, 20, 3, 21, 3, 21, 3, 22, 3, 22, 3,
	22, 3, 22, 3, 22, 3, 22, 7, 22, 267, 10, 22, 12, 22, 14, 22, 270, 11, 22,
	3, 23, 3, 23, 5, 23, 274, 10, 23, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 280,
	10, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 5, 25, 288, 10, 25, 3,
	26, 3, 26, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 5, 27, 297, 10, 27, 3, 28,
	3, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29,
	320, 10, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3,
	30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 5, 30, 344, 10, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3,
	31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31,
	3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 5, 31, 368, 10, 31, 3,
	32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33,
	3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3,
	33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 398, 10, 33, 3, 34,
	3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 406, 10, 35, 3, 36, 3, 36, 3,
	36, 3, 36, 3, 36, 3, 36, 7, 36, 414, 10, 36, 12, 36, 14, 36, 417, 11, 36,
	3, 37, 3, 37, 3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 7,
	39, 429, 10, 39, 12, 39, 14, 39, 432, 11, 39, 3, 40, 3, 40, 3, 41, 3, 41,
	3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 445, 10, 41, 3,
	41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41,
	7, 41, 458, 10, 41, 12, 41, 14, 41, 461, 11, 41, 3, 42, 3, 42, 3, 42, 3,
	42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 471, 10, 42, 3, 43, 3, 43, 3, 43,
	3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43, 481, 10, 43, 3, 44, 3, 44, 3,
	44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 491, 10, 44, 3, 45, 3, 45,
	3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 501, 10, 45, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 511, 10, 46, 3, 47,
	3, 47, 3, 47, 3, 47, 3, 47, 3, 48, 3, 48, 3, 48, 3, 48, 3, 49, 3, 49, 3,
	49, 3, 49, 3, 50, 3, 50, 3, 50, 5, 50, 529, 10, 50, 3, 50, 3, 50, 3, 50,
	3, 50, 5, 50, 535, 10, 50, 7, 50, 537, 10, 50, 12, 50, 14, 50, 540, 11,
	50, 3, 51, 3, 51, 3, 51, 3, 51, 5, 51, 546, 10, 51, 3, 51, 3, 51, 3, 51,
	3, 51, 3, 51, 3, 51, 5, 51, 554, 10, 51, 3, 51, 3, 51, 5, 51, 558, 10,
	51, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52,
	3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3,
	52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 5, 52, 586, 10, 52, 3, 52, 3, 52,
	3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3,
	52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 7, 52, 609,
	10, 52, 12, 52, 14, 52, 612, 11, 52, 3, 53, 3, 53, 3, 53, 5, 53, 617, 10,
	53, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 5, 54, 625, 10, 54, 3, 54,
	3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 7, 54, 633, 10, 54, 12, 54, 14, 54,
	636, 11, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3,
	55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 5, 55, 652, 10, 55, 3, 55, 3, 55,
	3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 7,
	55, 666, 10, 55, 12, 55, 14, 55, 669, 11, 55, 3, 56, 3, 56, 3, 56, 3, 56,
	3, 56, 3, 56, 5, 56, 677, 10, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3,
	56, 7, 56, 685, 10, 56, 12, 56, 14, 56, 688, 11, 56, 3, 57, 3, 57, 3, 57,
	3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3,
	57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 5, 57, 711, 10, 57,
	3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 721, 10,
	58, 3, 59, 3, 59, 3, 59, 5, 59, 726, 10, 59, 3, 60, 3, 60, 3, 61, 3, 61,
	3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3,
	61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61,
	3, 61, 3, 61, 3, 61, 5, 61, 756, 10, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3,
	61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61,
	3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3,
	61, 3, 61, 7, 61, 785, 10, 61, 12, 61, 14, 61, 788, 11, 61, 3, 62, 3, 62,
	3, 63, 3, 63, 3, 64, 3, 64, 3, 65, 3, 65, 3, 66, 3, 66, 3, 67, 3, 67, 3,
	68, 3, 68, 3, 69, 3, 69, 3, 70, 3, 70, 3, 71, 3, 71, 3, 71, 5, 71, 811,
	10, 71, 3, 71, 3, 71, 3, 71, 3, 71, 7, 71, 817, 10, 71, 12, 71, 14, 71,
	820, 11, 71, 3, 72, 3, 72, 3, 73, 3, 73, 3, 73, 2, 15, 4, 32, 42, 70, 76,
	80, 98, 102, 106, 108, 110, 120, 140, 74, 2, 4, 6, 8, 10, 12, 14, 16, 18,
	20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54,
	56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90,
	92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
	122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 2, 12, 3, 2,
	35, 40, 3, 2, 24, 26, 3, 2, 22, 23, 3, 2, 30, 33, 3, 2, 28, 29, 4, 2, 44,
	44, 49, 49, 3, 2, 45, 46, 3, 2, 42, 43, 3, 2, 47, 48, 3, 2, 20, 21, 2,
	879, 2, 146, 3, 2, 2, 2, 4, 153, 3, 2, 2, 2, 6, 174, 3, 2, 2, 2, 8, 176,
	3, 2, 2, 2, 10, 180, 3, 2, 2, 2, 12, 184, 3, 2, 2, 2, 14, 186, 3, 2, 2,
	2, 16, 188, 3, 2, 2, 2, 18, 191, 3, 2, 2, 2, 20, 196, 3, 2, 2, 2, 22, 198,
	3, 2, 2, 2, 24, 202, 3, 2, 2, 2, 26, 213, 3, 2, 2, 2, 28, 217, 3, 2, 2,
	2, 30, 226, 3, 2, 2, 2, 32, 228, 3, 2, 2, 2, 34, 239, 3, 2, 2, 2, 36, 241,
	3, 2, 2, 2, 38, 256, 3, 2, 2, 2, 40, 258, 3, 2, 2, 2, 42, 260, 3, 2, 2,
	2, 44, 273, 3, 2, 2, 2, 46, 279, 3, 2, 2, 2, 48, 281, 3, 2, 2, 2, 50, 289,
	3, 2, 2, 2, 52, 296, 3, 2, 2, 2, 54, 298, 3, 2, 2, 2, 56, 319, 3, 2, 2,
	2, 58, 343, 3, 2, 2, 2, 60, 367, 3, 2, 2, 2, 62, 369, 3, 2, 2, 2, 64, 397,
	3, 2, 2, 2, 66, 399, 3, 2, 2, 2, 68, 405, 3, 2, 2, 2, 70, 407, 3, 2, 2,
	2, 72, 418, 3, 2, 2, 2, 74, 420, 3, 2, 2, 2, 76, 422, 3, 2, 2, 2, 78, 433,
	3, 2, 2, 2, 80, 444, 3, 2, 2, 2, 82, 470, 3, 2, 2, 2, 84, 480, 3, 2, 2,
	2, 86, 490, 3, 2, 2, 2, 88, 500, 3, 2, 2, 2, 90, 510, 3, 2, 2, 2, 92, 512,
	3, 2, 2, 2, 94, 517, 3, 2, 2, 2, 96, 521, 3, 2, 2, 2, 98, 525, 3, 2, 2,
	2, 100, 557, 3, 2, 2, 2, 102, 585, 3, 2, 2, 2, 104, 616, 3, 2, 2, 2, 106,
	624, 3, 2, 2, 2, 108, 651, 3, 2, 2, 2, 110, 676, 3, 2, 2, 2, 112, 710,
	3, 2, 2, 2, 114, 720, 3, 2, 2, 2, 116, 725, 3, 2, 2, 2, 118, 727, 3, 2,
	2, 2, 120, 755, 3, 2, 2, 2, 122, 789, 3, 2, 2, 2, 124, 791, 3, 2, 2, 2,
	126, 793, 3, 2, 2, 2, 128, 795, 3, 2, 2, 2, 130, 797, 3, 2, 2, 2, 132,
	799, 3, 2, 2, 2, 134, 801, 3, 2, 2, 2, 136, 803, 3, 2, 2, 2, 138, 805,
	3, 2, 2, 2, 140, 810, 3, 2, 2, 2, 142, 821, 3, 2, 2, 2, 144, 823, 3, 2,
	2, 2, 146, 147, 5, 4, 3, 2, 147, 3, 3, 2, 2, 2, 148, 149, 8, 3, 1, 2, 149,
	150, 5, 6, 4, 2, 150, 151, 5, 140, 71, 2, 151, 154, 3, 2, 2, 2, 152, 154,
	5, 140, 71, 2, 153, 148, 3, 2, 2, 2, 153, 152, 3, 2, 2, 2, 154, 161, 3,
	2, 2, 2, 155, 156, 12, 4, 2, 2, 156, 157, 5, 6, 4, 2, 157, 158, 5, 140,
	71, 2, 158, 160, 3, 2, 2, 2, 159, 155, 3, 2, 2, 2, 160, 163, 3, 2, 2, 2,
	161, 159, 3, 2, 2, 2, 161, 162, 3, 2, 2, 2, 162, 5, 3, 2, 2, 2, 163, 161,
	3, 2, 2, 2, 164, 175, 5, 22, 12, 2, 165, 175, 5, 14, 8, 2, 166, 175, 5,
	16, 9, 2, 167, 175, 5, 58, 30, 2, 168, 175, 5, 60, 31, 2, 169, 175, 5,
	120, 61, 2, 170, 175, 5, 36, 19, 2, 171, 175, 5, 62, 32, 2, 172, 175, 5,
	64, 33, 2, 173, 175, 5, 18, 10, 2, 174, 164, 3, 2, 2, 2, 174, 165, 3, 2,
	2, 2, 174, 166, 3, 2, 2, 2, 174, 167, 3, 2, 2, 2, 174, 168, 3, 2, 2, 2,
	174, 169, 3, 2, 2, 2, 174, 170, 3, 2, 2, 2, 174, 171, 3, 2, 2, 2, 174,
	172, 3, 2, 2, 2, 174, 173, 3, 2, 2, 2, 175, 7, 3, 2, 2, 2, 176, 177, 5,
	118, 60, 2, 177, 178, 7, 34, 2, 2, 178, 179, 5, 136, 69, 2, 179, 9, 3,
	2, 2, 2, 180, 181, 5, 136, 69, 2, 181, 182, 7, 34, 2, 2, 182, 183, 5, 52,
	27, 2, 183, 11, 3, 2, 2, 2, 184, 185, 5, 136, 69, 2, 185, 13, 3, 2, 2,
	2, 186, 187, 5, 38, 20, 2, 187, 15, 3, 2, 2, 2, 188, 189, 7, 7, 2, 2, 189,
	190, 5, 124, 63, 2, 190, 17, 3, 2, 2, 2, 191, 192, 7, 11, 2, 2, 192, 193,
	5, 144, 73, 2, 193, 194, 5, 20, 11, 2, 194, 195, 7, 8, 2, 2, 195, 19, 3,
	2, 2, 2, 196, 197, 5, 4, 3, 2, 197, 21, 3, 2, 2, 2, 198, 199, 5, 26, 14,
	2, 199, 200, 5, 24, 13, 2, 200, 201, 7, 8, 2, 2, 201, 23, 3, 2, 2, 2, 202,
	203, 5, 4, 3, 2, 203, 25, 3, 2, 2, 2, 204, 205, 7, 9, 2, 2, 205, 206, 5,
	28, 15, 2, 206, 207, 5, 144, 73, 2, 207, 214, 3, 2, 2, 2, 208, 209, 7,
	9, 2, 2, 209, 210, 5, 28, 15, 2, 210, 211, 5, 30, 16, 2, 211, 212, 5, 144,
	73, 2, 212, 214, 3, 2, 2, 2, 213, 204, 3, 2, 2, 2, 213, 208, 3, 2, 2, 2,
	214, 27, 3, 2, 2, 2, 215, 218, 5, 138, 70, 2, 216, 218, 5, 134, 68, 2,
	217, 215, 3, 2, 2, 2, 217, 216, 3, 2, 2, 2, 218, 29, 3, 2, 2, 2, 219, 220,
	7, 50, 2, 2, 220, 227, 7, 51, 2, 2, 221, 222, 7, 50, 2, 2, 222, 223, 5,
	32, 17, 2, 223, 224, 7, 51, 2, 2, 224, 227, 3, 2, 2, 2, 225, 227, 5, 32,
	17, 2, 226, 219, 3, 2, 2, 2, 226, 221, 3, 2, 2, 2, 226, 225, 3, 2, 2, 2,
	227, 31, 3, 2, 2, 2, 228, 229, 8, 17, 1, 2, 229, 230, 5, 34, 18, 2, 230,
	236, 3, 2, 2, 2, 231, 232, 12, 3, 2, 2, 232, 233, 7, 4, 2, 2, 233, 235,
	5, 34, 18, 2, 234, 231, 3, 2, 2, 2, 235, 238, 3, 2, 2, 2, 236, 234, 3,
	2, 2, 2, 236, 237, 3, 2, 2, 2, 237, 33, 3, 2, 2, 2, 238, 236, 3, 2, 2,
	2, 239, 240, 5, 134, 68, 2, 240, 35, 3, 2, 2, 2, 241, 242, 7, 10, 2, 2,
	242, 243, 5, 52, 27, 2, 243, 37, 3, 2, 2, 2, 244, 245, 5, 28, 15, 2, 245,
	246, 7, 50, 2, 2, 246, 247, 5, 40, 21, 2, 247, 248, 7, 51, 2, 2, 248, 257,
	3, 2, 2, 2, 249, 250, 5, 28, 15, 2, 250, 251, 5, 40, 21, 2, 251, 257, 3,
	2, 2, 2, 252, 253, 5, 28, 15, 2, 253, 254, 7, 50, 2, 2, 254, 255, 7, 51,
	2, 2, 255, 257, 3, 2, 2, 2, 256, 244, 3, 2, 2, 2, 256, 249, 3, 2, 2, 2,
	256, 252, 3, 2, 2, 2, 257, 39, 3, 2, 2, 2, 258, 259, 5, 42, 22, 2, 259,
	41, 3, 2, 2, 2, 260, 261, 8, 22, 1, 2, 261, 262, 5, 44, 23, 2, 262, 268,
	3, 2, 2, 2, 263, 264, 12, 3, 2, 2, 264, 265, 7, 4, 2, 2, 265, 267, 5, 44,
	23, 2, 266, 263, 3, 2, 2, 2, 267, 270, 3, 2, 2, 2, 268, 266, 3, 2, 2, 2,
	268, 269, 3, 2, 2, 2, 269, 43, 3, 2, 2, 2, 270, 268, 3, 2, 2, 2, 271, 274,
	5, 46, 24, 2, 272, 274, 5, 48, 25, 2, 273, 271, 3, 2, 2, 2, 273, 272, 3,
	2, 2, 2, 274, 45, 3, 2, 2, 2, 275, 280, 5, 106, 54, 2, 276, 280, 5, 108,
	55, 2, 277, 280, 5, 110, 56, 2, 278, 280, 5, 102, 52, 2, 279, 275, 3, 2,
	2, 2, 279, 276, 3, 2, 2, 2, 279, 277, 3, 2, 2, 2, 279, 278, 3, 2, 2, 2,
	280, 47, 3, 2, 2, 2, 281, 282, 5, 134, 68, 2, 282, 287, 7, 34, 2, 2, 283,
	288, 5, 106, 54, 2, 284, 288, 5, 108, 55, 2, 285, 288, 5, 110, 56, 2, 286,
	288, 5, 102, 52, 2, 287, 283, 3, 2, 2, 2, 287, 284, 3, 2, 2, 2, 287, 285,
	3, 2, 2, 2, 287, 286, 3, 2, 2, 2, 288, 49, 3, 2, 2, 2, 289, 290, 5, 38,
	20, 2, 290, 51, 3, 2, 2, 2, 291, 297, 5, 106, 54, 2, 292, 297, 5, 108,
	55, 2, 293, 297, 5, 110, 56, 2, 294, 297, 5, 102, 52, 2, 295, 297, 5, 12,
	7, 2, 296, 291, 3, 2, 2, 2, 296, 292, 3, 2, 2, 2, 296, 293, 3, 2, 2, 2,
	296, 294, 3, 2, 2, 2, 296, 295, 3, 2, 2, 2, 297, 53, 3, 2, 2, 2, 298, 299,
	5, 56, 29, 2, 299, 55, 3, 2, 2, 2, 300, 301, 7, 14, 2, 2, 301, 302, 5,
	72, 37, 2, 302, 303, 5, 144, 73, 2, 303, 304, 5, 78, 40, 2, 304, 320, 3,
	2, 2, 2, 305, 306, 7, 14, 2, 2, 306, 307, 5, 72, 37, 2, 307, 308, 5, 144,
	73, 2, 308, 309, 5, 78, 40, 2, 309, 310, 5, 142, 72, 2, 310, 311, 5, 144,
	73, 2, 311, 312, 5, 78, 40, 2, 312, 320, 3, 2, 2, 2, 313, 314, 7, 14, 2,
	2, 314, 315, 5, 72, 37, 2, 315, 316, 5, 144, 73, 2, 316, 317, 5, 78, 40,
	2, 317, 318, 5, 56, 29, 2, 318, 320, 3, 2, 2, 2, 319, 300, 3, 2, 2, 2,
	319, 305, 3, 2, 2, 2, 319, 313, 3, 2, 2, 2, 320, 57, 3, 2, 2, 2, 321, 322,
	7, 12, 2, 2, 322, 323, 5, 72, 37, 2, 323, 324, 5, 144, 73, 2, 324, 325,
	5, 78, 40, 2, 325, 326, 7, 8, 2, 2, 326, 344, 3, 2, 2, 2, 327, 328, 7,
	12, 2, 2, 328, 329, 5, 72, 37, 2, 329, 330, 5, 144, 73, 2, 330, 331, 5,
	78, 40, 2, 331, 332, 5, 142, 72, 2, 332, 333, 5, 144, 73, 2, 333, 334,
	5, 78, 40, 2, 334, 335, 7, 8, 2, 2, 335, 344, 3, 2, 2, 2, 336, 337, 7,
	12, 2, 2, 337, 338, 5, 72, 37, 2, 338, 339, 5, 144, 73, 2, 339, 340, 5,
	78, 40, 2, 340, 341, 5, 54, 28, 2, 341, 342, 7, 8, 2, 2, 342, 344, 3, 2,
	2, 2, 343, 321, 3, 2, 2, 2, 343, 327, 3, 2, 2, 2, 343, 336, 3, 2, 2, 2,
	344, 59, 3, 2, 2, 2, 345, 346, 7, 15, 2, 2, 346, 347, 5, 72, 37, 2, 347,
	348, 5, 144, 73, 2, 348, 349, 5, 78, 40, 2, 349, 350, 7, 8, 2, 2, 350,
	368, 3, 2, 2, 2, 351, 352, 7, 15, 2, 2, 352, 353, 5, 72, 37, 2, 353, 354,
	5, 144, 73, 2, 354, 355, 5, 78, 40, 2, 355, 356, 5, 142, 72, 2, 356, 357,
	5, 144, 73, 2, 357, 358, 5, 78, 40, 2, 358, 359, 7, 8, 2, 2, 359, 368,
	3, 2, 2, 2, 360, 361, 7, 15, 2, 2, 361, 362, 5, 72, 37, 2, 362, 363, 5,
	144, 73, 2, 363, 364, 5, 78, 40, 2, 364, 365, 5, 54, 28, 2, 365, 366, 7,
	8, 2, 2, 366, 368, 3, 2, 2, 2, 367, 345, 3, 2, 2, 2, 367, 351, 3, 2, 2,
	2, 367, 360, 3, 2, 2, 2, 368, 61, 3, 2, 2, 2, 369, 370, 7, 16, 2, 2, 370,
	371, 5, 72, 37, 2, 371, 372, 5, 144, 73, 2, 372, 373, 5, 78, 40, 2, 373,
	374, 7, 8, 2, 2, 374, 63, 3, 2, 2, 2, 375, 376, 7, 19, 2, 2, 376, 377,
	7, 50, 2, 2, 377, 378, 5, 66, 34, 2, 378, 379, 7, 5, 2, 2, 379, 380, 5,
	72, 37, 2, 380, 381, 7, 5, 2, 2, 381, 382, 5, 74, 38, 2, 382, 383, 7, 51,
	2, 2, 383, 384, 5, 144, 73, 2, 384, 385, 5, 78, 40, 2, 385, 386, 7, 8,
	2, 2, 386, 398, 3, 2, 2, 2, 387, 388, 7, 19, 2, 2, 388, 389, 5, 66, 34,
	2, 389, 390, 7, 5, 2, 2, 390, 391, 5, 72, 37, 2, 391, 392, 7, 5, 2, 2,
	392, 393, 5, 74, 38, 2, 393, 394, 5, 144, 73, 2, 394, 395, 5, 78, 40, 2,
	395, 396, 7, 8, 2, 2, 396, 398, 3, 2, 2, 2, 397, 375, 3, 2, 2, 2, 397,
	387, 3, 2, 2, 2, 398, 65, 3, 2, 2, 2, 399, 400, 5, 70, 36, 2, 400, 67,
	3, 2, 2, 2, 401, 406, 5, 86, 44, 2, 402, 406, 5, 88, 45, 2, 403, 406, 5,
	90, 46, 2, 404, 406, 5, 84, 43, 2, 405, 401, 3, 2, 2, 2, 405, 402, 3, 2,
	2, 2, 405, 403, 3, 2, 2, 2, 405, 404, 3, 2, 2, 2, 406, 69, 3, 2, 2, 2,
	407, 408, 8, 36, 1, 2, 408, 409, 5, 68, 35, 2, 409, 415, 3, 2, 2, 2, 410,
	411, 12, 4, 2, 2, 411, 412, 7, 4, 2, 2, 412, 414, 5, 68, 35, 2, 413, 410,
	3, 2, 2, 2, 414, 417, 3, 2, 2, 2, 415, 413, 3, 2, 2, 2, 415, 416, 3, 2,
	2, 2, 416, 71, 3, 2, 2, 2, 417, 415, 3, 2, 2, 2, 418, 419, 5, 112, 57,
	2, 419, 73, 3, 2, 2, 2, 420, 421, 5, 76, 39, 2, 421, 75, 3, 2, 2, 2, 422,
	423, 8, 39, 1, 2, 423, 424, 5, 68, 35, 2, 424, 430, 3, 2, 2, 2, 425, 426,
	12, 4, 2, 2, 426, 427, 7, 4, 2, 2, 427, 429, 5, 68, 35, 2, 428, 425, 3,
	2, 2, 2, 429, 432, 3, 2, 2, 2, 430, 428, 3, 2, 2, 2, 430, 431, 3, 2, 2,
	2, 431, 77, 3, 2, 2, 2, 432, 430, 3, 2, 2, 2, 433, 434, 5, 80, 41, 2, 434,
	79, 3, 2, 2, 2, 435, 436, 8, 41, 1, 2, 436, 437, 5, 6, 4, 2, 437, 438,
	5, 140, 71, 2, 438, 445, 3, 2, 2, 2, 439, 440, 7, 17, 2, 2, 440, 445, 5,
	140, 71, 2, 441, 442, 5, 122, 62, 2, 442, 443, 5, 140, 71, 2, 443, 445,
	3, 2, 2, 2, 444, 435, 3, 2, 2, 2, 444, 439, 3, 2, 2, 2, 444, 441, 3, 2,
	2, 2, 445, 459, 3, 2, 2, 2, 446, 447, 12, 5, 2, 2, 447, 448, 5, 6, 4, 2,
	448, 449, 5, 140, 71, 2, 449, 458, 3, 2, 2, 2, 450, 451, 12, 4, 2, 2, 451,
	452, 7, 17, 2, 2, 452, 458, 5, 140, 71, 2, 453, 454, 12, 3, 2, 2, 454,
	455, 5, 122, 62, 2, 455, 456, 5, 140, 71, 2, 456, 458, 3, 2, 2, 2, 457,
	446, 3, 2, 2, 2, 457, 450, 3, 2, 2, 2, 457, 453, 3, 2, 2, 2, 458, 461,
	3, 2, 2, 2, 459, 457, 3, 2, 2, 2, 459, 460, 3, 2, 2, 2, 460, 81, 3, 2,
	2, 2, 461, 459, 3, 2, 2, 2, 462, 463, 5, 118, 60, 2, 463, 464, 7, 34, 2,
	2, 464, 465, 5, 120, 61, 2, 465, 471, 3, 2, 2, 2, 466, 467, 5, 118, 60,
	2, 467, 468, 9, 2, 2, 2, 468, 469, 5, 120, 61, 2, 469, 471, 3, 2, 2, 2,
	470, 462, 3, 2, 2, 2, 470, 466, 3, 2, 2, 2, 471, 83, 3, 2, 2, 2, 472, 473,
	5, 118, 60, 2, 473, 474, 7, 34, 2, 2, 474, 475, 5, 102, 52, 2, 475, 481,
	3, 2, 2, 2, 476, 477, 5, 118, 60, 2, 477, 478, 9, 2, 2, 2, 478, 479, 5,
	102, 52, 2, 479, 481, 3, 2, 2, 2, 480, 472, 3, 2, 2, 2, 480, 476, 3, 2,
	2, 2, 481, 85, 3, 2, 2, 2, 482, 483, 5, 118, 60, 2, 483, 484, 7, 34, 2,
	2, 484, 485, 5, 106, 54, 2, 485, 491, 3, 2, 2, 2, 486, 487, 5, 118, 60,
	2, 487, 488, 9, 2, 2, 2, 488, 489, 5, 106, 54, 2, 489, 491, 3, 2, 2, 2,
	490, 482, 3, 2, 2, 2, 490, 486, 3, 2, 2, 2, 491, 87, 3, 2, 2, 2, 492, 493,
	5, 118, 60, 2, 493, 494, 7, 34, 2, 2, 494, 495, 5, 108, 55, 2, 495, 501,
	3, 2, 2, 2, 496, 497, 5, 118, 60, 2, 497, 498, 9, 2, 2, 2, 498, 499, 5,
	108, 55, 2, 499, 501, 3, 2, 2, 2, 500, 492, 3, 2, 2, 2, 500, 496, 3, 2,
	2, 2, 501, 89, 3, 2, 2, 2, 502, 503, 5, 118, 60, 2, 503, 504, 7, 34, 2,
	2, 504, 505, 5, 110, 56, 2, 505, 511, 3, 2, 2, 2, 506, 507, 5, 118, 60,
	2, 507, 508, 7, 35, 2, 2, 508, 509, 5, 110, 56, 2, 509, 511, 3, 2, 2, 2,
	510, 502, 3, 2, 2, 2, 510, 506, 3, 2, 2, 2, 511, 91, 3, 2, 2, 2, 512, 513,
	5, 118, 60, 2, 513, 514, 7, 34, 2, 2, 514, 515, 7, 52, 2, 2, 515, 516,
	7, 53, 2, 2, 516, 93, 3, 2, 2, 2, 517, 518, 5, 100, 51, 2, 518, 519, 7,
	34, 2, 2, 519, 520, 5, 52, 27, 2, 520, 95, 3, 2, 2, 2, 521, 522, 7, 52,
	2, 2, 522, 523, 5, 98, 50, 2, 523, 524, 7, 53, 2, 2, 524, 97, 3, 2, 2,
	2, 525, 528, 8, 50, 1, 2, 526, 529, 5, 106, 54, 2, 527, 529, 5, 102, 52,
	2, 528, 526, 3, 2, 2, 2, 528, 527, 3, 2, 2, 2, 529, 538, 3, 2, 2, 2, 530,
	531, 12, 3, 2, 2, 531, 534, 7, 4, 2, 2, 532, 535, 5, 106, 54, 2, 533, 535,
	5, 102, 52, 2, 534, 532, 3, 2, 2, 2, 534, 533, 3, 2, 2, 2, 535, 537, 3,
	2, 2, 2, 536, 530, 3, 2, 2, 2, 537, 540, 3, 2, 2, 2, 538, 536, 3, 2, 2,
	2, 538, 539, 3, 2, 2, 2, 539, 99, 3, 2, 2, 2, 540, 538, 3, 2, 2, 2, 541,
	542, 5, 134, 68, 2, 542, 545, 7, 52, 2, 2, 543, 546, 5, 106, 54, 2, 544,
	546, 5, 102, 52, 2, 545, 543, 3, 2, 2, 2, 545, 544, 3, 2, 2, 2, 546, 547,
	3, 2, 2, 2, 547, 548, 7, 53, 2, 2, 548, 558, 3, 2, 2, 2, 549, 550, 5, 136,
	69, 2, 550, 553, 7, 52, 2, 2, 551, 554, 5, 106, 54, 2, 552, 554, 5, 102,
	52, 2, 553, 551, 3, 2, 2, 2, 553, 552, 3, 2, 2, 2, 554, 555, 3, 2, 2, 2,
	555, 556, 7, 53, 2, 2, 556, 558, 3, 2, 2, 2, 557, 541, 3, 2, 2, 2, 557,
	549, 3, 2, 2, 2, 558, 101, 3, 2, 2, 2, 559, 560, 8, 52, 1, 2, 560, 561,
	5, 106, 54, 2, 561, 562, 9, 3, 2, 2, 562, 563, 5, 102, 52, 15, 563, 586,
	3, 2, 2, 2, 564, 565, 5, 108, 55, 2, 565, 566, 9, 3, 2, 2, 566, 567, 5,
	102, 52, 13, 567, 586, 3, 2, 2, 2, 568, 569, 5, 110, 56, 2, 569, 570, 7,
	24, 2, 2, 570, 571, 5, 102, 52, 10, 571, 586, 3, 2, 2, 2, 572, 573, 5,
	106, 54, 2, 573, 574, 9, 4, 2, 2, 574, 575, 5, 102, 52, 8, 575, 586, 3,
	2, 2, 2, 576, 577, 5, 108, 55, 2, 577, 578, 9, 4, 2, 2, 578, 579, 5, 102,
	52, 6, 579, 586, 3, 2, 2, 2, 580, 581, 7, 50, 2, 2, 581, 582, 5, 102, 52,
	2, 582, 583, 7, 51, 2, 2, 583, 586, 3, 2, 2, 2, 584, 586, 5, 104, 53, 2,
	585, 559, 3, 2, 2, 2, 585, 564, 3, 2, 2, 2, 585, 568, 3, 2, 2, 2, 585,
	572, 3, 2, 2, 2, 585, 576, 3, 2, 2, 2, 585, 580, 3, 2, 2, 2, 585, 584,
	3, 2, 2, 2, 586, 610, 3, 2, 2, 2, 587, 588, 12, 12, 2, 2, 588, 589, 9,
	3, 2, 2, 589, 609, 5, 102, 52, 13, 590, 591, 12, 5, 2, 2, 591, 592, 9,
	4, 2, 2, 592, 609, 5, 102, 52, 6, 593, 594, 12, 16, 2, 2, 594, 595, 9,
	3, 2, 2, 595, 609, 5, 106, 54, 2, 596, 597, 12, 14, 2, 2, 597, 598, 9,
	3, 2, 2, 598, 609, 5, 108, 55, 2, 599, 600, 12, 11, 2, 2, 600, 601, 7,
	24, 2, 2, 601, 609, 5, 110, 56, 2, 602, 603, 12, 9, 2, 2, 603, 604, 9,
	4, 2, 2, 604, 609, 5, 106, 54, 2, 605, 606, 12, 7, 2, 2, 606, 607, 9, 4,
	2, 2, 607, 609, 5, 108, 55, 2, 608, 587, 3, 2, 2, 2, 608, 590, 3, 2, 2,
	2, 608, 593, 3, 2, 2, 2, 608, 596, 3, 2, 2, 2, 608, 599, 3, 2, 2, 2, 608,
	602, 3, 2, 2, 2, 608, 605, 3, 2, 2, 2, 609, 612, 3, 2, 2, 2, 610, 608,
	3, 2, 2, 2, 610, 611, 3, 2, 2, 2, 611, 103, 3, 2, 2, 2, 612, 610, 3, 2,
	2, 2, 613, 617, 5, 134, 68, 2, 614, 617, 5, 50, 26, 2, 615, 617, 5, 100,
	51, 2, 616, 613, 3, 2, 2, 2, 616, 614, 3, 2, 2, 2, 616, 615, 3, 2, 2, 2,
	617, 105, 3, 2, 2, 2, 618, 619, 8, 54, 1, 2, 619, 620, 7, 50, 2, 2, 620,
	621, 5, 106, 54, 2, 621, 622, 7, 51, 2, 2, 622, 625, 3, 2, 2, 2, 623, 625,
	5, 128, 65, 2, 624, 618, 3, 2, 2, 2, 624, 623, 3, 2, 2, 2, 625, 634, 3,
	2, 2, 2, 626, 627, 12, 6, 2, 2, 627, 628, 9, 3, 2, 2, 628, 633, 5, 106,
	54, 7, 629, 630, 12, 5, 2, 2, 630, 631, 9, 4, 2, 2, 631, 633, 5, 106, 54,
	6, 632, 626, 3, 2, 2, 2, 632, 629, 3, 2, 2, 2, 633, 636, 3, 2, 2, 2, 634,
	632, 3, 2, 2, 2, 634, 635, 3, 2, 2, 2, 635, 107, 3, 2, 2, 2, 636, 634,
	3, 2, 2, 2, 637, 638, 8, 55, 1, 2, 638, 639, 5, 106, 54, 2, 639, 640, 9,
	3, 2, 2, 640, 641, 5, 108, 55, 9, 641, 652, 3, 2, 2, 2, 642, 643, 5, 106,
	54, 2, 643, 644, 9, 4, 2, 2, 644, 645, 5, 108, 55, 6, 645, 652, 3, 2, 2,
	2, 646, 647, 7, 50, 2, 2, 647, 648, 5, 108, 55, 2, 648, 649, 7, 51, 2,
	2, 649, 652, 3, 2, 2, 2, 650, 652, 5, 126, 64, 2, 651, 637, 3, 2, 2, 2,
	651, 642, 3, 2, 2, 2, 651, 646, 3, 2, 2, 2, 651, 650, 3, 2, 2, 2, 652,
	667, 3, 2, 2, 2, 653, 654, 12, 10, 2, 2, 654, 655, 9, 3, 2, 2, 655, 666,
	5, 108, 55, 11, 656, 657, 12, 7, 2, 2, 657, 658, 9, 4, 2, 2, 658, 666,
	5, 108, 55, 8, 659, 660, 12, 8, 2, 2, 660, 661, 9, 3, 2, 2, 661, 666, 5,
	106, 54, 2, 662, 663, 12, 5, 2, 2, 663, 664, 9, 4, 2, 2, 664, 666, 5, 106,
	54, 2, 665, 653, 3, 2, 2, 2, 665, 656, 3, 2, 2, 2, 665, 659, 3, 2, 2, 2,
	665, 662, 3, 2, 2, 2, 666, 669, 3, 2, 2, 2, 667, 665, 3, 2, 2, 2, 667,
	668, 3, 2, 2, 2, 668, 109, 3, 2, 2, 2, 669, 667, 3, 2, 2, 2, 670, 671,
	8, 56, 1, 2, 671, 672, 5, 106, 54, 2, 672, 673, 7, 24, 2, 2, 673, 674,
	5, 110, 56, 5, 674, 677, 3, 2, 2, 2, 675, 677, 5, 124, 63, 2, 676, 670,
	3, 2, 2, 2, 676, 675, 3, 2, 2, 2, 677, 686, 3, 2, 2, 2, 678, 679, 12, 4,
	2, 2, 679, 680, 7, 22, 2, 2, 680, 685, 5, 110, 56, 5, 681, 682, 12, 6,
	2, 2, 682, 683, 7, 24, 2, 2, 683, 685, 5, 106, 54, 2, 684, 678, 3, 2, 2,
	2, 684, 681, 3, 2, 2, 2, 685, 688, 3, 2, 2, 2, 686, 684, 3, 2, 2, 2, 686,
	687, 3, 2, 2, 2, 687, 111, 3, 2, 2, 2, 688, 686, 3, 2, 2, 2, 689, 690,
	5, 114, 58, 2, 690, 691, 7, 41, 2, 2, 691, 692, 5, 112, 57, 2, 692, 711,
	3, 2, 2, 2, 693, 694, 5, 114, 58, 2, 694, 695, 7, 47, 2, 2, 695, 696, 5,
	112, 57, 2, 696, 711, 3, 2, 2, 2, 697, 698, 5, 114, 58, 2, 698, 699, 7,
	42, 2, 2, 699, 700, 5, 112, 57, 2, 700, 711, 3, 2, 2, 2, 701, 702, 5, 114,
	58, 2, 702, 703, 7, 48, 2, 2, 703, 704, 5, 112, 57, 2, 704, 711, 3, 2,
	2, 2, 705, 706, 7, 50, 2, 2, 706, 707, 5, 112, 57, 2, 707, 708, 7, 51,
	2, 2, 708, 711, 3, 2, 2, 2, 709, 711, 5, 114, 58, 2, 710, 689, 3, 2, 2,
	2, 710, 693, 3, 2, 2, 2, 710, 697, 3, 2, 2, 2, 710, 701, 3, 2, 2, 2, 710,
	705, 3, 2, 2, 2, 710, 709, 3, 2, 2, 2, 711, 113, 3, 2, 2, 2, 712, 713,
	5, 116, 59, 2, 713, 714, 9, 5, 2, 2, 714, 715, 5, 116, 59, 2, 715, 721,
	3, 2, 2, 2, 716, 717, 5, 116, 59, 2, 717, 718, 9, 6, 2, 2, 718, 719, 5,
	116, 59, 2, 719, 721, 3, 2, 2, 2, 720, 712, 3, 2, 2, 2, 720, 716, 3, 2,
	2, 2, 721, 115, 3, 2, 2, 2, 722, 726, 5, 52, 27, 2, 723, 726, 5, 100, 51,
	2, 724, 726, 5, 134, 68, 2, 725, 722, 3, 2, 2, 2, 725, 723, 3, 2, 2, 2,
	725, 724, 3, 2, 2, 2, 726, 117, 3, 2, 2, 2, 727, 728, 5, 134, 68, 2, 728,
	119, 3, 2, 2, 2, 729, 730, 8, 61, 1, 2, 730, 756, 5, 118, 60, 2, 731, 756,
	5, 92, 47, 2, 732, 756, 5, 94, 48, 2, 733, 756, 5, 106, 54, 2, 734, 756,
	5, 108, 55, 2, 735, 756, 5, 110, 56, 2, 736, 756, 5, 10, 6, 2, 737, 756,
	5, 8, 5, 2, 738, 756, 5, 84, 43, 2, 739, 756, 5, 90, 46, 2, 740, 756, 5,
	88, 45, 2, 741, 756, 5, 86, 44, 2, 742, 756, 5, 82, 42, 2, 743, 756, 5,
	38, 20, 2, 744, 756, 5, 124, 63, 2, 745, 756, 5, 130, 66, 2, 746, 756,
	5, 126, 64, 2, 747, 756, 5, 128, 65, 2, 748, 756, 5, 132, 67, 2, 749, 750,
	9, 7, 2, 2, 750, 756, 5, 120, 61, 12, 751, 752, 7, 50, 2, 2, 752, 753,
	5, 120, 61, 2, 753, 754, 7, 51, 2, 2, 754, 756, 3, 2, 2, 2, 755, 729, 3,
	2, 2, 2, 755, 731, 3, 2, 2, 2, 755, 732, 3, 2, 2, 2, 755, 733, 3, 2, 2,
	2, 755, 734, 3, 2, 2, 2, 755, 735, 3, 2, 2, 2, 755, 736, 3, 2, 2, 2, 755,
	737, 3, 2, 2, 2, 755, 738, 3, 2, 2, 2, 755, 739, 3, 2, 2, 2, 755, 740,
	3, 2, 2, 2, 755, 741, 3, 2, 2, 2, 755, 742, 3, 2, 2, 2, 755, 743, 3, 2,
	2, 2, 755, 744, 3, 2, 2, 2, 755, 745, 3, 2, 2, 2, 755, 746, 3, 2, 2, 2,
	755, 747, 3, 2, 2, 2, 755, 748, 3, 2, 2, 2, 755, 749, 3, 2, 2, 2, 755,
	751, 3, 2, 2, 2, 756, 786, 3, 2, 2, 2, 757, 758, 12, 13, 2, 2, 758, 759,
	7, 27, 2, 2, 759, 785, 5, 120, 61, 14, 760, 761, 12, 11, 2, 2, 761, 762,
	9, 3, 2, 2, 762, 785, 5, 120, 61, 12, 763, 764, 12, 10, 2, 2, 764, 765,
	9, 4, 2, 2, 765, 785, 5, 120, 61, 11, 766, 767, 12, 9, 2, 2, 767, 768,
	9, 8, 2, 2, 768, 785, 5, 120, 61, 10, 769, 770, 12, 8, 2, 2, 770, 771,
	7, 41, 2, 2, 771, 785, 5, 120, 61, 9, 772, 773, 12, 7, 2, 2, 773, 774,
	9, 9, 2, 2, 774, 785, 5, 120, 61, 8, 775, 776, 12, 6, 2, 2, 776, 777, 9,
	5, 2, 2, 777, 785, 5, 120, 61, 7, 778, 779, 12, 5, 2, 2, 779, 780, 9, 6,
	2, 2, 780, 785, 5, 120, 61, 6, 781, 782, 12, 4, 2, 2, 782, 783, 9, 10,
	2, 2, 783, 785, 5, 120, 61, 5, 784, 757, 3, 2, 2, 2, 784, 760, 3, 2, 2,
	2, 784, 763, 3, 2, 2, 2, 784, 766, 3, 2, 2, 2, 784, 769, 3, 2, 2, 2, 784,
	772, 3, 2, 2, 2, 784, 775, 3, 2, 2, 2, 784, 778, 3, 2, 2, 2, 784, 781,
	3, 2, 2, 2, 785, 788, 3, 2, 2, 2, 786, 784, 3, 2, 2, 2, 786, 787, 3, 2,
	2, 2, 787, 121, 3, 2, 2, 2, 788, 786, 3, 2, 2, 2, 789, 790, 7, 18, 2, 2,
	790, 123, 3, 2, 2, 2, 791, 792, 7, 3, 2, 2, 792, 125, 3, 2, 2, 2, 793,
	794, 7, 59, 2, 2, 794, 127, 3, 2, 2, 2, 795, 796, 7, 58, 2, 2, 796, 129,
	3, 2, 2, 2, 797, 798, 9, 11, 2, 2, 798, 131, 3, 2, 2, 2, 799, 800, 7, 54,
	2, 2, 800, 133, 3, 2, 2, 2, 801, 802, 7, 60, 2, 2, 802, 135, 3, 2, 2, 2,
	803, 804, 7, 61, 2, 2, 804, 137, 3, 2, 2, 2, 805, 806, 7, 62, 2, 2, 806,
	139, 3, 2, 2, 2, 807, 808, 8, 71, 1, 2, 808, 811, 7, 5, 2, 2, 809, 811,
	5, 144, 73, 2, 810, 807, 3, 2, 2, 2, 810, 809, 3, 2, 2, 2, 811, 818, 3,
	2, 2, 2, 812, 813, 12, 6, 2, 2, 813, 817, 7, 5, 2, 2, 814, 815, 12, 5,
	2, 2, 815, 817, 5, 144, 73, 2, 816, 812, 3, 2, 2, 2, 816, 814, 3, 2, 2,
	2, 817, 820, 3, 2, 2, 2, 818, 816, 3, 2, 2, 2, 818, 819, 3, 2, 2, 2, 819,
	141, 3, 2, 2, 2, 820, 818, 3, 2, 2, 2, 821, 822, 7, 13, 2, 2, 822, 143,
	3, 2, 2, 2, 823, 824, 7, 6, 2, 2, 824, 145, 3, 2, 2, 2, 58, 153, 161, 174,
	213, 217, 226, 236, 256, 268, 273, 279, 287, 296, 319, 343, 367, 397, 405,
	415, 430, 444, 457, 459, 470, 480, 490, 500, 510, 528, 534, 538, 545, 553,
	557, 585, 608, 610, 616, 624, 632, 634, 651, 665, 667, 676, 684, 686, 710,
	720, 725, 755, 784, 786, 810, 816, 818,
}
var literalNames = []string{
	"", "", "','", "';'", "", "'require'", "'end'", "'def'", "'return'", "'pir'",
	"'if'", "'else'", "'elsif'", "'unless'", "'while'", "'retry'", "'break'",
	"'for'", "'true'", "'false'", "'+'", "'-'", "'*'", "'/'", "'%'", "'**'",
	"'=='", "'!='", "'>'", "'<'", "'<='", "'>='", "'='", "'+='", "'-='", "'*='",
	"'/='", "'%='", "'**='", "'&'", "'|'", "'^'", "'~'", "'<<'", "'>>'", "",
	"", "", "'('", "')'", "'['", "']'", "'nil'",
}
var symbolicNames = []string{
	"", "LITERAL", "COMMA", "SEMICOLON", "CRLF", "REQUIRE", "END", "DEF", "RETURN",
	"PIR", "IF", "ELSE", "ELSIF", "UNLESS", "WHILE", "RETRY", "BREAK", "FOR",
	"TRUE", "FALSE", "PLUS", "MINUS", "MUL", "DIV", "MOD", "EXP", "EQUAL",
	"NOT_EQUAL", "GREATER", "LESS", "LESS_EQUAL", "GREATER_EQUAL", "ASSIGN",
	"PLUS_ASSIGN", "MINUS_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN",
	"EXP_ASSIGN", "BIT_AND", "BIT_OR", "BIT_XOR", "BIT_NOT", "BIT_SHL", "BIT_SHR",
	"AND", "OR", "NOT", "LEFT_RBRACKET", "RIGHT_RBRACKET", "LEFT_SBRACKET",
	"RIGHT_SBRACKET", "NIL", "SL_COMMENT", "ML_COMMENT", "WS", "INT", "FLOAT",
	"ID", "ID_GLOBAL", "ID_FUNCTION",
}

var ruleNames = []string{
	"prog", "expression_list", "expression", "global_get", "global_set", "global_result",
	"function_inline_call", "require_block", "pir_inline", "pir_expression_list",
	"function_definition", "function_definition_body", "function_definition_header",
	"function_name", "function_definition_params", "function_definition_params_list",
	"function_definition_param_id", "return_statement", "function_call", "function_call_param_list",
	"function_call_params", "function_param", "function_unnamed_param", "function_named_param",
	"function_call_assignment", "all_result", "elsif_statement", "if_elsif_statement",
	"if_statement", "unless_statement", "while_statement", "for_statement",
	"init_expression", "all_assignment", "for_init_list", "cond_expression",
	"loop_expression", "for_loop_list", "statement_body", "statement_expression_list",
	"assignment", "dynamic_assignment", "int_assignment", "float_assignment",
	"string_assignment", "initial_array_assignment", "array_assignment", "array_definition",
	"array_definition_elements", "array_selector", "dynamic_result", "dynamic_",
	"int_result", "float_result", "string_result", "comparison_list", "comparison",
	"comp_var", "lvalue", "rvalue", "break_expression", "literal_t", "float_t",
	"int_t", "bool_t", "nil_t", "id_", "id_global", "id_function", "terminator",
	"else_token", "crlf",
}

type CorundumParser struct {
	*antlr.BaseParser
}

// NewCorundumParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *CorundumParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewCorundumParser(input antlr.TokenStream) *CorundumParser {
	this := new(CorundumParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Corundum.g4"

	return this
}

// CorundumParser tokens.
const (
	CorundumParserEOF            = antlr.TokenEOF
	CorundumParserLITERAL        = 1
	CorundumParserCOMMA          = 2
	CorundumParserSEMICOLON      = 3
	CorundumParserCRLF           = 4
	CorundumParserREQUIRE        = 5
	CorundumParserEND            = 6
	CorundumParserDEF            = 7
	CorundumParserRETURN         = 8
	CorundumParserPIR            = 9
	CorundumParserIF             = 10
	CorundumParserELSE           = 11
	CorundumParserELSIF          = 12
	CorundumParserUNLESS         = 13
	CorundumParserWHILE          = 14
	CorundumParserRETRY          = 15
	CorundumParserBREAK          = 16
	CorundumParserFOR            = 17
	CorundumParserTRUE           = 18
	CorundumParserFALSE          = 19
	CorundumParserPLUS           = 20
	CorundumParserMINUS          = 21
	CorundumParserMUL            = 22
	CorundumParserDIV            = 23
	CorundumParserMOD            = 24
	CorundumParserEXP            = 25
	CorundumParserEQUAL          = 26
	CorundumParserNOT_EQUAL      = 27
	CorundumParserGREATER        = 28
	CorundumParserLESS           = 29
	CorundumParserLESS_EQUAL     = 30
	CorundumParserGREATER_EQUAL  = 31
	CorundumParserASSIGN         = 32
	CorundumParserPLUS_ASSIGN    = 33
	CorundumParserMINUS_ASSIGN   = 34
	CorundumParserMUL_ASSIGN     = 35
	CorundumParserDIV_ASSIGN     = 36
	CorundumParserMOD_ASSIGN     = 37
	CorundumParserEXP_ASSIGN     = 38
	CorundumParserBIT_AND        = 39
	CorundumParserBIT_OR         = 40
	CorundumParserBIT_XOR        = 41
	CorundumParserBIT_NOT        = 42
	CorundumParserBIT_SHL        = 43
	CorundumParserBIT_SHR        = 44
	CorundumParserAND            = 45
	CorundumParserOR             = 46
	CorundumParserNOT            = 47
	CorundumParserLEFT_RBRACKET  = 48
	CorundumParserRIGHT_RBRACKET = 49
	CorundumParserLEFT_SBRACKET  = 50
	CorundumParserRIGHT_SBRACKET = 51
	CorundumParserNIL            = 52
	CorundumParserSL_COMMENT     = 53
	CorundumParserML_COMMENT     = 54
	CorundumParserWS             = 55
	CorundumParserINT            = 56
	CorundumParserFLOAT          = 57
	CorundumParserID             = 58
	CorundumParserID_GLOBAL      = 59
	CorundumParserID_FUNCTION    = 60
)

// CorundumParser rules.
const (
	CorundumParserRULE_prog                            = 0
	CorundumParserRULE_expression_list                 = 1
	CorundumParserRULE_expression                      = 2
	CorundumParserRULE_global_get                      = 3
	CorundumParserRULE_global_set                      = 4
	CorundumParserRULE_global_result                   = 5
	CorundumParserRULE_function_inline_call            = 6
	CorundumParserRULE_require_block                   = 7
	CorundumParserRULE_pir_inline                      = 8
	CorundumParserRULE_pir_expression_list             = 9
	CorundumParserRULE_function_definition             = 10
	CorundumParserRULE_function_definition_body        = 11
	CorundumParserRULE_function_definition_header      = 12
	CorundumParserRULE_function_name                   = 13
	CorundumParserRULE_function_definition_params      = 14
	CorundumParserRULE_function_definition_params_list = 15
	CorundumParserRULE_function_definition_param_id    = 16
	CorundumParserRULE_return_statement                = 17
	CorundumParserRULE_function_call                   = 18
	CorundumParserRULE_function_call_param_list        = 19
	CorundumParserRULE_function_call_params            = 20
	CorundumParserRULE_function_param                  = 21
	CorundumParserRULE_function_unnamed_param          = 22
	CorundumParserRULE_function_named_param            = 23
	CorundumParserRULE_function_call_assignment        = 24
	CorundumParserRULE_all_result                      = 25
	CorundumParserRULE_elsif_statement                 = 26
	CorundumParserRULE_if_elsif_statement              = 27
	CorundumParserRULE_if_statement                    = 28
	CorundumParserRULE_unless_statement                = 29
	CorundumParserRULE_while_statement                 = 30
	CorundumParserRULE_for_statement                   = 31
	CorundumParserRULE_init_expression                 = 32
	CorundumParserRULE_all_assignment                  = 33
	CorundumParserRULE_for_init_list                   = 34
	CorundumParserRULE_cond_expression                 = 35
	CorundumParserRULE_loop_expression                 = 36
	CorundumParserRULE_for_loop_list                   = 37
	CorundumParserRULE_statement_body                  = 38
	CorundumParserRULE_statement_expression_list       = 39
	CorundumParserRULE_assignment                      = 40
	CorundumParserRULE_dynamic_assignment              = 41
	CorundumParserRULE_int_assignment                  = 42
	CorundumParserRULE_float_assignment                = 43
	CorundumParserRULE_string_assignment               = 44
	CorundumParserRULE_initial_array_assignment        = 45
	CorundumParserRULE_array_assignment                = 46
	CorundumParserRULE_array_definition                = 47
	CorundumParserRULE_array_definition_elements       = 48
	CorundumParserRULE_array_selector                  = 49
	CorundumParserRULE_dynamic_result                  = 50
	CorundumParserRULE_dynamic_                        = 51
	CorundumParserRULE_int_result                      = 52
	CorundumParserRULE_float_result                    = 53
	CorundumParserRULE_string_result                   = 54
	CorundumParserRULE_comparison_list                 = 55
	CorundumParserRULE_comparison                      = 56
	CorundumParserRULE_comp_var                        = 57
	CorundumParserRULE_lvalue                          = 58
	CorundumParserRULE_rvalue                          = 59
	CorundumParserRULE_break_expression                = 60
	CorundumParserRULE_literal_t                       = 61
	CorundumParserRULE_float_t                         = 62
	CorundumParserRULE_int_t                           = 63
	CorundumParserRULE_bool_t                          = 64
	CorundumParserRULE_nil_t                           = 65
	CorundumParserRULE_id_                             = 66
	CorundumParserRULE_id_global                       = 67
	CorundumParserRULE_id_function                     = 68
	CorundumParserRULE_terminator                      = 69
	CorundumParserRULE_else_token                      = 70
	CorundumParserRULE_crlf                            = 71
)

// IProgContext is an interface to support dynamic dispatch.
type IProgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgContext differentiates from other interfaces.
	IsProgContext()
}

type ProgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgContext() *ProgContext {
	var p = new(ProgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_prog
	return p
}

func (*ProgContext) IsProgContext() {}

func NewProgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgContext {
	var p = new(ProgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_prog

	return p
}

func (s *ProgContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *ProgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterProg(s)
	}
}

func (s *ProgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitProg(s)
	}
}

func (p *CorundumParser) Prog() (localctx IProgContext) {
	this := p
	_ = this

	localctx = NewProgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, CorundumParserRULE_prog)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(144)
		p.expression_list(0)
	}

	return localctx
}

// IExpression_listContext is an interface to support dynamic dispatch.
type IExpression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_listContext differentiates from other interfaces.
	IsExpression_listContext()
}

type Expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_listContext() *Expression_listContext {
	var p = new(Expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_expression_list
	return p
}

func (*Expression_listContext) IsExpression_listContext() {}

func NewExpression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_listContext {
	var p = new(Expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_expression_list

	return p
}

func (s *Expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_listContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expression_listContext) Terminator() ITerminatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminatorContext)
}

func (s *Expression_listContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterExpression_list(s)
	}
}

func (s *Expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitExpression_list(s)
	}
}

func (p *CorundumParser) Expression_list() (localctx IExpression_listContext) {
	return p.expression_list(0)
}

func (p *CorundumParser) expression_list(_p int) (localctx IExpression_listContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpression_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpression_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 2
	p.EnterRecursionRule(localctx, 2, CorundumParserRULE_expression_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(151)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CorundumParserLITERAL, CorundumParserREQUIRE, CorundumParserDEF, CorundumParserRETURN, CorundumParserPIR, CorundumParserIF, CorundumParserUNLESS, CorundumParserWHILE, CorundumParserFOR, CorundumParserTRUE, CorundumParserFALSE, CorundumParserBIT_NOT, CorundumParserNOT, CorundumParserLEFT_RBRACKET, CorundumParserNIL, CorundumParserINT, CorundumParserFLOAT, CorundumParserID, CorundumParserID_GLOBAL, CorundumParserID_FUNCTION:
		{
			p.SetState(147)
			p.Expression()
		}
		{
			p.SetState(148)
			p.terminator(0)
		}

	case CorundumParserSEMICOLON, CorundumParserCRLF:
		{
			p.SetState(150)
			p.terminator(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(159)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExpression_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_expression_list)
			p.SetState(153)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(154)
				p.Expression()
			}
			{
				p.SetState(155)
				p.terminator(0)
			}

		}
		p.SetState(161)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Function_definition() IFunction_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_definitionContext)
}

func (s *ExpressionContext) Function_inline_call() IFunction_inline_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_inline_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_inline_callContext)
}

func (s *ExpressionContext) Require_block() IRequire_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRequire_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRequire_blockContext)
}

func (s *ExpressionContext) If_statement() IIf_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_statementContext)
}

func (s *ExpressionContext) Unless_statement() IUnless_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnless_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnless_statementContext)
}

func (s *ExpressionContext) Rvalue() IRvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRvalueContext)
}

func (s *ExpressionContext) Return_statement() IReturn_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_statementContext)
}

func (s *ExpressionContext) While_statement() IWhile_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhile_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhile_statementContext)
}

func (s *ExpressionContext) For_statement() IFor_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_statementContext)
}

func (s *ExpressionContext) Pir_inline() IPir_inlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPir_inlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPir_inlineContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *CorundumParser) Expression() (localctx IExpressionContext) {
	this := p
	_ = this

	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, CorundumParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(172)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(162)
			p.Function_definition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(163)
			p.Function_inline_call()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(164)
			p.Require_block()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(165)
			p.If_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(166)
			p.Unless_statement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(167)
			p.rvalue(0)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(168)
			p.Return_statement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(169)
			p.While_statement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(170)
			p.For_statement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(171)
			p.Pir_inline()
		}

	}

	return localctx
}

// IGlobal_getContext is an interface to support dynamic dispatch.
type IGlobal_getContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetVar_name returns the var_name rule contexts.
	GetVar_name() ILvalueContext

	// GetGlobal_name returns the global_name rule contexts.
	GetGlobal_name() IId_globalContext

	// SetVar_name sets the var_name rule contexts.
	SetVar_name(ILvalueContext)

	// SetGlobal_name sets the global_name rule contexts.
	SetGlobal_name(IId_globalContext)

	// IsGlobal_getContext differentiates from other interfaces.
	IsGlobal_getContext()
}

type Global_getContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	var_name    ILvalueContext
	op          antlr.Token
	global_name IId_globalContext
}

func NewEmptyGlobal_getContext() *Global_getContext {
	var p = new(Global_getContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_global_get
	return p
}

func (*Global_getContext) IsGlobal_getContext() {}

func NewGlobal_getContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_getContext {
	var p = new(Global_getContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_global_get

	return p
}

func (s *Global_getContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_getContext) GetOp() antlr.Token { return s.op }

func (s *Global_getContext) SetOp(v antlr.Token) { s.op = v }

func (s *Global_getContext) GetVar_name() ILvalueContext { return s.var_name }

func (s *Global_getContext) GetGlobal_name() IId_globalContext { return s.global_name }

func (s *Global_getContext) SetVar_name(v ILvalueContext) { s.var_name = v }

func (s *Global_getContext) SetGlobal_name(v IId_globalContext) { s.global_name = v }

func (s *Global_getContext) Lvalue() ILvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *Global_getContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserASSIGN, 0)
}

func (s *Global_getContext) Id_global() IId_globalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_globalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_globalContext)
}

func (s *Global_getContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_getContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_getContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterGlobal_get(s)
	}
}

func (s *Global_getContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitGlobal_get(s)
	}
}

func (p *CorundumParser) Global_get() (localctx IGlobal_getContext) {
	this := p
	_ = this

	localctx = NewGlobal_getContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, CorundumParserRULE_global_get)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(174)

		var _x = p.Lvalue()

		localctx.(*Global_getContext).var_name = _x
	}
	{
		p.SetState(175)

		var _m = p.Match(CorundumParserASSIGN)

		localctx.(*Global_getContext).op = _m
	}
	{
		p.SetState(176)

		var _x = p.Id_global()

		localctx.(*Global_getContext).global_name = _x
	}

	return localctx
}

// IGlobal_setContext is an interface to support dynamic dispatch.
type IGlobal_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetGlobal_name returns the global_name rule contexts.
	GetGlobal_name() IId_globalContext

	// GetResult returns the result rule contexts.
	GetResult() IAll_resultContext

	// SetGlobal_name sets the global_name rule contexts.
	SetGlobal_name(IId_globalContext)

	// SetResult sets the result rule contexts.
	SetResult(IAll_resultContext)

	// IsGlobal_setContext differentiates from other interfaces.
	IsGlobal_setContext()
}

type Global_setContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	global_name IId_globalContext
	op          antlr.Token
	result      IAll_resultContext
}

func NewEmptyGlobal_setContext() *Global_setContext {
	var p = new(Global_setContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_global_set
	return p
}

func (*Global_setContext) IsGlobal_setContext() {}

func NewGlobal_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_setContext {
	var p = new(Global_setContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_global_set

	return p
}

func (s *Global_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_setContext) GetOp() antlr.Token { return s.op }

func (s *Global_setContext) SetOp(v antlr.Token) { s.op = v }

func (s *Global_setContext) GetGlobal_name() IId_globalContext { return s.global_name }

func (s *Global_setContext) GetResult() IAll_resultContext { return s.result }

func (s *Global_setContext) SetGlobal_name(v IId_globalContext) { s.global_name = v }

func (s *Global_setContext) SetResult(v IAll_resultContext) { s.result = v }

func (s *Global_setContext) Id_global() IId_globalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_globalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_globalContext)
}

func (s *Global_setContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserASSIGN, 0)
}

func (s *Global_setContext) All_result() IAll_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAll_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAll_resultContext)
}

func (s *Global_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterGlobal_set(s)
	}
}

func (s *Global_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitGlobal_set(s)
	}
}

func (p *CorundumParser) Global_set() (localctx IGlobal_setContext) {
	this := p
	_ = this

	localctx = NewGlobal_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, CorundumParserRULE_global_set)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(178)

		var _x = p.Id_global()

		localctx.(*Global_setContext).global_name = _x
	}
	{
		p.SetState(179)

		var _m = p.Match(CorundumParserASSIGN)

		localctx.(*Global_setContext).op = _m
	}
	{
		p.SetState(180)

		var _x = p.All_result()

		localctx.(*Global_setContext).result = _x
	}

	return localctx
}

// IGlobal_resultContext is an interface to support dynamic dispatch.
type IGlobal_resultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobal_resultContext differentiates from other interfaces.
	IsGlobal_resultContext()
}

type Global_resultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_resultContext() *Global_resultContext {
	var p = new(Global_resultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_global_result
	return p
}

func (*Global_resultContext) IsGlobal_resultContext() {}

func NewGlobal_resultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_resultContext {
	var p = new(Global_resultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_global_result

	return p
}

func (s *Global_resultContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_resultContext) Id_global() IId_globalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_globalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_globalContext)
}

func (s *Global_resultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_resultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_resultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterGlobal_result(s)
	}
}

func (s *Global_resultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitGlobal_result(s)
	}
}

func (p *CorundumParser) Global_result() (localctx IGlobal_resultContext) {
	this := p
	_ = this

	localctx = NewGlobal_resultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, CorundumParserRULE_global_result)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(182)
		p.Id_global()
	}

	return localctx
}

// IFunction_inline_callContext is an interface to support dynamic dispatch.
type IFunction_inline_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_inline_callContext differentiates from other interfaces.
	IsFunction_inline_callContext()
}

type Function_inline_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_inline_callContext() *Function_inline_callContext {
	var p = new(Function_inline_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_inline_call
	return p
}

func (*Function_inline_callContext) IsFunction_inline_callContext() {}

func NewFunction_inline_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_inline_callContext {
	var p = new(Function_inline_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_inline_call

	return p
}

func (s *Function_inline_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_inline_callContext) Function_call() IFunction_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *Function_inline_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_inline_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_inline_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_inline_call(s)
	}
}

func (s *Function_inline_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_inline_call(s)
	}
}

func (p *CorundumParser) Function_inline_call() (localctx IFunction_inline_callContext) {
	this := p
	_ = this

	localctx = NewFunction_inline_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, CorundumParserRULE_function_inline_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(184)
		p.Function_call()
	}

	return localctx
}

// IRequire_blockContext is an interface to support dynamic dispatch.
type IRequire_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRequire_blockContext differentiates from other interfaces.
	IsRequire_blockContext()
}

type Require_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequire_blockContext() *Require_blockContext {
	var p = new(Require_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_require_block
	return p
}

func (*Require_blockContext) IsRequire_blockContext() {}

func NewRequire_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Require_blockContext {
	var p = new(Require_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_require_block

	return p
}

func (s *Require_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Require_blockContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(CorundumParserREQUIRE, 0)
}

func (s *Require_blockContext) Literal_t() ILiteral_tContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteral_tContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteral_tContext)
}

func (s *Require_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Require_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Require_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterRequire_block(s)
	}
}

func (s *Require_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitRequire_block(s)
	}
}

func (p *CorundumParser) Require_block() (localctx IRequire_blockContext) {
	this := p
	_ = this

	localctx = NewRequire_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, CorundumParserRULE_require_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(186)
		p.Match(CorundumParserREQUIRE)
	}
	{
		p.SetState(187)
		p.Literal_t()
	}

	return localctx
}

// IPir_inlineContext is an interface to support dynamic dispatch.
type IPir_inlineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPir_inlineContext differentiates from other interfaces.
	IsPir_inlineContext()
}

type Pir_inlineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPir_inlineContext() *Pir_inlineContext {
	var p = new(Pir_inlineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_pir_inline
	return p
}

func (*Pir_inlineContext) IsPir_inlineContext() {}

func NewPir_inlineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pir_inlineContext {
	var p = new(Pir_inlineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_pir_inline

	return p
}

func (s *Pir_inlineContext) GetParser() antlr.Parser { return s.parser }

func (s *Pir_inlineContext) PIR() antlr.TerminalNode {
	return s.GetToken(CorundumParserPIR, 0)
}

func (s *Pir_inlineContext) Crlf() ICrlfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrlfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *Pir_inlineContext) Pir_expression_list() IPir_expression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPir_expression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPir_expression_listContext)
}

func (s *Pir_inlineContext) END() antlr.TerminalNode {
	return s.GetToken(CorundumParserEND, 0)
}

func (s *Pir_inlineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pir_inlineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pir_inlineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterPir_inline(s)
	}
}

func (s *Pir_inlineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitPir_inline(s)
	}
}

func (p *CorundumParser) Pir_inline() (localctx IPir_inlineContext) {
	this := p
	_ = this

	localctx = NewPir_inlineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, CorundumParserRULE_pir_inline)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(189)
		p.Match(CorundumParserPIR)
	}
	{
		p.SetState(190)
		p.Crlf()
	}
	{
		p.SetState(191)
		p.Pir_expression_list()
	}
	{
		p.SetState(192)
		p.Match(CorundumParserEND)
	}

	return localctx
}

// IPir_expression_listContext is an interface to support dynamic dispatch.
type IPir_expression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPir_expression_listContext differentiates from other interfaces.
	IsPir_expression_listContext()
}

type Pir_expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPir_expression_listContext() *Pir_expression_listContext {
	var p = new(Pir_expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_pir_expression_list
	return p
}

func (*Pir_expression_listContext) IsPir_expression_listContext() {}

func NewPir_expression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pir_expression_listContext {
	var p = new(Pir_expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_pir_expression_list

	return p
}

func (s *Pir_expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Pir_expression_listContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Pir_expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pir_expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pir_expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterPir_expression_list(s)
	}
}

func (s *Pir_expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitPir_expression_list(s)
	}
}

func (p *CorundumParser) Pir_expression_list() (localctx IPir_expression_listContext) {
	this := p
	_ = this

	localctx = NewPir_expression_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, CorundumParserRULE_pir_expression_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(194)
		p.expression_list(0)
	}

	return localctx
}

// IFunction_definitionContext is an interface to support dynamic dispatch.
type IFunction_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definitionContext differentiates from other interfaces.
	IsFunction_definitionContext()
}

type Function_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definitionContext() *Function_definitionContext {
	var p = new(Function_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_definition
	return p
}

func (*Function_definitionContext) IsFunction_definitionContext() {}

func NewFunction_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definitionContext {
	var p = new(Function_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_definition

	return p
}

func (s *Function_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definitionContext) Function_definition_header() IFunction_definition_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definition_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_definition_headerContext)
}

func (s *Function_definitionContext) Function_definition_body() IFunction_definition_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definition_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_definition_bodyContext)
}

func (s *Function_definitionContext) END() antlr.TerminalNode {
	return s.GetToken(CorundumParserEND, 0)
}

func (s *Function_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_definition(s)
	}
}

func (s *Function_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_definition(s)
	}
}

func (p *CorundumParser) Function_definition() (localctx IFunction_definitionContext) {
	this := p
	_ = this

	localctx = NewFunction_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, CorundumParserRULE_function_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(196)
		p.Function_definition_header()
	}
	{
		p.SetState(197)
		p.Function_definition_body()
	}
	{
		p.SetState(198)
		p.Match(CorundumParserEND)
	}

	return localctx
}

// IFunction_definition_bodyContext is an interface to support dynamic dispatch.
type IFunction_definition_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definition_bodyContext differentiates from other interfaces.
	IsFunction_definition_bodyContext()
}

type Function_definition_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definition_bodyContext() *Function_definition_bodyContext {
	var p = new(Function_definition_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_definition_body
	return p
}

func (*Function_definition_bodyContext) IsFunction_definition_bodyContext() {}

func NewFunction_definition_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definition_bodyContext {
	var p = new(Function_definition_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_definition_body

	return p
}

func (s *Function_definition_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definition_bodyContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Function_definition_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definition_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definition_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_definition_body(s)
	}
}

func (s *Function_definition_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_definition_body(s)
	}
}

func (p *CorundumParser) Function_definition_body() (localctx IFunction_definition_bodyContext) {
	this := p
	_ = this

	localctx = NewFunction_definition_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, CorundumParserRULE_function_definition_body)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(200)
		p.expression_list(0)
	}

	return localctx
}

// IFunction_definition_headerContext is an interface to support dynamic dispatch.
type IFunction_definition_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definition_headerContext differentiates from other interfaces.
	IsFunction_definition_headerContext()
}

type Function_definition_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definition_headerContext() *Function_definition_headerContext {
	var p = new(Function_definition_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_definition_header
	return p
}

func (*Function_definition_headerContext) IsFunction_definition_headerContext() {}

func NewFunction_definition_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definition_headerContext {
	var p = new(Function_definition_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_definition_header

	return p
}

func (s *Function_definition_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definition_headerContext) DEF() antlr.TerminalNode {
	return s.GetToken(CorundumParserDEF, 0)
}

func (s *Function_definition_headerContext) Function_name() IFunction_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_nameContext)
}

func (s *Function_definition_headerContext) Crlf() ICrlfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrlfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *Function_definition_headerContext) Function_definition_params() IFunction_definition_paramsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definition_paramsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_definition_paramsContext)
}

func (s *Function_definition_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definition_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definition_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_definition_header(s)
	}
}

func (s *Function_definition_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_definition_header(s)
	}
}

func (p *CorundumParser) Function_definition_header() (localctx IFunction_definition_headerContext) {
	this := p
	_ = this

	localctx = NewFunction_definition_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, CorundumParserRULE_function_definition_header)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(211)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(202)
			p.Match(CorundumParserDEF)
		}
		{
			p.SetState(203)
			p.Function_name()
		}
		{
			p.SetState(204)
			p.Crlf()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(206)
			p.Match(CorundumParserDEF)
		}
		{
			p.SetState(207)
			p.Function_name()
		}
		{
			p.SetState(208)
			p.Function_definition_params()
		}
		{
			p.SetState(209)
			p.Crlf()
		}

	}

	return localctx
}

// IFunction_nameContext is an interface to support dynamic dispatch.
type IFunction_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_nameContext differentiates from other interfaces.
	IsFunction_nameContext()
}

type Function_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_nameContext() *Function_nameContext {
	var p = new(Function_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_name
	return p
}

func (*Function_nameContext) IsFunction_nameContext() {}

func NewFunction_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_nameContext {
	var p = new(Function_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_name

	return p
}

func (s *Function_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_nameContext) Id_function() IId_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_functionContext)
}

func (s *Function_nameContext) Id_() IId_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *Function_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_name(s)
	}
}

func (s *Function_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_name(s)
	}
}

func (p *CorundumParser) Function_name() (localctx IFunction_nameContext) {
	this := p
	_ = this

	localctx = NewFunction_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, CorundumParserRULE_function_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(215)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CorundumParserID_FUNCTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(213)
			p.Id_function()
		}

	case CorundumParserID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(214)
			p.Id_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunction_definition_paramsContext is an interface to support dynamic dispatch.
type IFunction_definition_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definition_paramsContext differentiates from other interfaces.
	IsFunction_definition_paramsContext()
}

type Function_definition_paramsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definition_paramsContext() *Function_definition_paramsContext {
	var p = new(Function_definition_paramsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_definition_params
	return p
}

func (*Function_definition_paramsContext) IsFunction_definition_paramsContext() {}

func NewFunction_definition_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definition_paramsContext {
	var p = new(Function_definition_paramsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_definition_params

	return p
}

func (s *Function_definition_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definition_paramsContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserLEFT_RBRACKET, 0)
}

func (s *Function_definition_paramsContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserRIGHT_RBRACKET, 0)
}

func (s *Function_definition_paramsContext) Function_definition_params_list() IFunction_definition_params_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definition_params_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_definition_params_listContext)
}

func (s *Function_definition_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definition_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definition_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_definition_params(s)
	}
}

func (s *Function_definition_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_definition_params(s)
	}
}

func (p *CorundumParser) Function_definition_params() (localctx IFunction_definition_paramsContext) {
	this := p
	_ = this

	localctx = NewFunction_definition_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, CorundumParserRULE_function_definition_params)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(224)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(217)
			p.Match(CorundumParserLEFT_RBRACKET)
		}
		{
			p.SetState(218)
			p.Match(CorundumParserRIGHT_RBRACKET)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(219)
			p.Match(CorundumParserLEFT_RBRACKET)
		}
		{
			p.SetState(220)
			p.function_definition_params_list(0)
		}
		{
			p.SetState(221)
			p.Match(CorundumParserRIGHT_RBRACKET)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(223)
			p.function_definition_params_list(0)
		}

	}

	return localctx
}

// IFunction_definition_params_listContext is an interface to support dynamic dispatch.
type IFunction_definition_params_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definition_params_listContext differentiates from other interfaces.
	IsFunction_definition_params_listContext()
}

type Function_definition_params_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definition_params_listContext() *Function_definition_params_listContext {
	var p = new(Function_definition_params_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_definition_params_list
	return p
}

func (*Function_definition_params_listContext) IsFunction_definition_params_listContext() {}

func NewFunction_definition_params_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definition_params_listContext {
	var p = new(Function_definition_params_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_definition_params_list

	return p
}

func (s *Function_definition_params_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definition_params_listContext) Function_definition_param_id() IFunction_definition_param_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definition_param_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_definition_param_idContext)
}

func (s *Function_definition_params_listContext) Function_definition_params_list() IFunction_definition_params_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definition_params_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_definition_params_listContext)
}

func (s *Function_definition_params_listContext) COMMA() antlr.TerminalNode {
	return s.GetToken(CorundumParserCOMMA, 0)
}

func (s *Function_definition_params_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definition_params_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definition_params_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_definition_params_list(s)
	}
}

func (s *Function_definition_params_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_definition_params_list(s)
	}
}

func (p *CorundumParser) Function_definition_params_list() (localctx IFunction_definition_params_listContext) {
	return p.function_definition_params_list(0)
}

func (p *CorundumParser) function_definition_params_list(_p int) (localctx IFunction_definition_params_listContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewFunction_definition_params_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFunction_definition_params_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 30
	p.EnterRecursionRule(localctx, 30, CorundumParserRULE_function_definition_params_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(227)
		p.Function_definition_param_id()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(234)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewFunction_definition_params_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_function_definition_params_list)
			p.SetState(229)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(230)
				p.Match(CorundumParserCOMMA)
			}
			{
				p.SetState(231)
				p.Function_definition_param_id()
			}

		}
		p.SetState(236)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}

	return localctx
}

// IFunction_definition_param_idContext is an interface to support dynamic dispatch.
type IFunction_definition_param_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definition_param_idContext differentiates from other interfaces.
	IsFunction_definition_param_idContext()
}

type Function_definition_param_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definition_param_idContext() *Function_definition_param_idContext {
	var p = new(Function_definition_param_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_definition_param_id
	return p
}

func (*Function_definition_param_idContext) IsFunction_definition_param_idContext() {}

func NewFunction_definition_param_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definition_param_idContext {
	var p = new(Function_definition_param_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_definition_param_id

	return p
}

func (s *Function_definition_param_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definition_param_idContext) Id_() IId_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *Function_definition_param_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definition_param_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definition_param_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_definition_param_id(s)
	}
}

func (s *Function_definition_param_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_definition_param_id(s)
	}
}

func (p *CorundumParser) Function_definition_param_id() (localctx IFunction_definition_param_idContext) {
	this := p
	_ = this

	localctx = NewFunction_definition_param_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, CorundumParserRULE_function_definition_param_id)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(237)
		p.Id_()
	}

	return localctx
}

// IReturn_statementContext is an interface to support dynamic dispatch.
type IReturn_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturn_statementContext differentiates from other interfaces.
	IsReturn_statementContext()
}

type Return_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_statementContext() *Return_statementContext {
	var p = new(Return_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_return_statement
	return p
}

func (*Return_statementContext) IsReturn_statementContext() {}

func NewReturn_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_statementContext {
	var p = new(Return_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_return_statement

	return p
}

func (s *Return_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_statementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(CorundumParserRETURN, 0)
}

func (s *Return_statementContext) All_result() IAll_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAll_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAll_resultContext)
}

func (s *Return_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterReturn_statement(s)
	}
}

func (s *Return_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitReturn_statement(s)
	}
}

func (p *CorundumParser) Return_statement() (localctx IReturn_statementContext) {
	this := p
	_ = this

	localctx = NewReturn_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, CorundumParserRULE_return_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(239)
		p.Match(CorundumParserRETURN)
	}
	{
		p.SetState(240)
		p.All_result()
	}

	return localctx
}

// IFunction_callContext is an interface to support dynamic dispatch.
type IFunction_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IFunction_nameContext

	// GetParams returns the params rule contexts.
	GetParams() IFunction_call_param_listContext

	// SetName sets the name rule contexts.
	SetName(IFunction_nameContext)

	// SetParams sets the params rule contexts.
	SetParams(IFunction_call_param_listContext)

	// IsFunction_callContext differentiates from other interfaces.
	IsFunction_callContext()
}

type Function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IFunction_nameContext
	params IFunction_call_param_listContext
}

func NewEmptyFunction_callContext() *Function_callContext {
	var p = new(Function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_call
	return p
}

func (*Function_callContext) IsFunction_callContext() {}

func NewFunction_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_callContext {
	var p = new(Function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_call

	return p
}

func (s *Function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_callContext) GetName() IFunction_nameContext { return s.name }

func (s *Function_callContext) GetParams() IFunction_call_param_listContext { return s.params }

func (s *Function_callContext) SetName(v IFunction_nameContext) { s.name = v }

func (s *Function_callContext) SetParams(v IFunction_call_param_listContext) { s.params = v }

func (s *Function_callContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserLEFT_RBRACKET, 0)
}

func (s *Function_callContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserRIGHT_RBRACKET, 0)
}

func (s *Function_callContext) Function_name() IFunction_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_nameContext)
}

func (s *Function_callContext) Function_call_param_list() IFunction_call_param_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_call_param_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_call_param_listContext)
}

func (s *Function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_call(s)
	}
}

func (s *Function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_call(s)
	}
}

func (p *CorundumParser) Function_call() (localctx IFunction_callContext) {
	this := p
	_ = this

	localctx = NewFunction_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, CorundumParserRULE_function_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(254)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(242)

			var _x = p.Function_name()

			localctx.(*Function_callContext).name = _x
		}
		{
			p.SetState(243)
			p.Match(CorundumParserLEFT_RBRACKET)
		}
		{
			p.SetState(244)

			var _x = p.Function_call_param_list()

			localctx.(*Function_callContext).params = _x
		}
		{
			p.SetState(245)
			p.Match(CorundumParserRIGHT_RBRACKET)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(247)

			var _x = p.Function_name()

			localctx.(*Function_callContext).name = _x
		}
		{
			p.SetState(248)

			var _x = p.Function_call_param_list()

			localctx.(*Function_callContext).params = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(250)

			var _x = p.Function_name()

			localctx.(*Function_callContext).name = _x
		}
		{
			p.SetState(251)
			p.Match(CorundumParserLEFT_RBRACKET)
		}
		{
			p.SetState(252)
			p.Match(CorundumParserRIGHT_RBRACKET)
		}

	}

	return localctx
}

// IFunction_call_param_listContext is an interface to support dynamic dispatch.
type IFunction_call_param_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_call_param_listContext differentiates from other interfaces.
	IsFunction_call_param_listContext()
}

type Function_call_param_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_call_param_listContext() *Function_call_param_listContext {
	var p = new(Function_call_param_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_call_param_list
	return p
}

func (*Function_call_param_listContext) IsFunction_call_param_listContext() {}

func NewFunction_call_param_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_call_param_listContext {
	var p = new(Function_call_param_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_call_param_list

	return p
}

func (s *Function_call_param_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_call_param_listContext) Function_call_params() IFunction_call_paramsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_call_paramsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_call_paramsContext)
}

func (s *Function_call_param_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_param_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_call_param_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_call_param_list(s)
	}
}

func (s *Function_call_param_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_call_param_list(s)
	}
}

func (p *CorundumParser) Function_call_param_list() (localctx IFunction_call_param_listContext) {
	this := p
	_ = this

	localctx = NewFunction_call_param_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, CorundumParserRULE_function_call_param_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(256)
		p.function_call_params(0)
	}

	return localctx
}

// IFunction_call_paramsContext is an interface to support dynamic dispatch.
type IFunction_call_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_call_paramsContext differentiates from other interfaces.
	IsFunction_call_paramsContext()
}

type Function_call_paramsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_call_paramsContext() *Function_call_paramsContext {
	var p = new(Function_call_paramsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_call_params
	return p
}

func (*Function_call_paramsContext) IsFunction_call_paramsContext() {}

func NewFunction_call_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_call_paramsContext {
	var p = new(Function_call_paramsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_call_params

	return p
}

func (s *Function_call_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_call_paramsContext) Function_param() IFunction_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_paramContext)
}

func (s *Function_call_paramsContext) Function_call_params() IFunction_call_paramsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_call_paramsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_call_paramsContext)
}

func (s *Function_call_paramsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(CorundumParserCOMMA, 0)
}

func (s *Function_call_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_call_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_call_params(s)
	}
}

func (s *Function_call_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_call_params(s)
	}
}

func (p *CorundumParser) Function_call_params() (localctx IFunction_call_paramsContext) {
	return p.function_call_params(0)
}

func (p *CorundumParser) function_call_params(_p int) (localctx IFunction_call_paramsContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewFunction_call_paramsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFunction_call_paramsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 40
	p.EnterRecursionRule(localctx, 40, CorundumParserRULE_function_call_params, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(259)
		p.Function_param()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(266)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewFunction_call_paramsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_function_call_params)
			p.SetState(261)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(262)
				p.Match(CorundumParserCOMMA)
			}
			{
				p.SetState(263)
				p.Function_param()
			}

		}
		p.SetState(268)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())
	}

	return localctx
}

// IFunction_paramContext is an interface to support dynamic dispatch.
type IFunction_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_paramContext differentiates from other interfaces.
	IsFunction_paramContext()
}

type Function_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_paramContext() *Function_paramContext {
	var p = new(Function_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_param
	return p
}

func (*Function_paramContext) IsFunction_paramContext() {}

func NewFunction_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_paramContext {
	var p = new(Function_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_param

	return p
}

func (s *Function_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_paramContext) Function_unnamed_param() IFunction_unnamed_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_unnamed_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_unnamed_paramContext)
}

func (s *Function_paramContext) Function_named_param() IFunction_named_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_named_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_named_paramContext)
}

func (s *Function_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_param(s)
	}
}

func (s *Function_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_param(s)
	}
}

func (p *CorundumParser) Function_param() (localctx IFunction_paramContext) {
	this := p
	_ = this

	localctx = NewFunction_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, CorundumParserRULE_function_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(271)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(269)
			p.Function_unnamed_param()
		}

	case 2:
		{
			p.SetState(270)
			p.Function_named_param()
		}

	}

	return localctx
}

// IFunction_unnamed_paramContext is an interface to support dynamic dispatch.
type IFunction_unnamed_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_unnamed_paramContext differentiates from other interfaces.
	IsFunction_unnamed_paramContext()
}

type Function_unnamed_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_unnamed_paramContext() *Function_unnamed_paramContext {
	var p = new(Function_unnamed_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_unnamed_param
	return p
}

func (*Function_unnamed_paramContext) IsFunction_unnamed_paramContext() {}

func NewFunction_unnamed_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_unnamed_paramContext {
	var p = new(Function_unnamed_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_unnamed_param

	return p
}

func (s *Function_unnamed_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_unnamed_paramContext) Int_result() IInt_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Function_unnamed_paramContext) Float_result() IFloat_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloat_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloat_resultContext)
}

func (s *Function_unnamed_paramContext) String_result() IString_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_resultContext)
}

func (s *Function_unnamed_paramContext) Dynamic_result() IDynamic_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamic_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDynamic_resultContext)
}

func (s *Function_unnamed_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_unnamed_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_unnamed_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_unnamed_param(s)
	}
}

func (s *Function_unnamed_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_unnamed_param(s)
	}
}

func (p *CorundumParser) Function_unnamed_param() (localctx IFunction_unnamed_paramContext) {
	this := p
	_ = this

	localctx = NewFunction_unnamed_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, CorundumParserRULE_function_unnamed_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(277)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(273)
			p.int_result(0)
		}

	case 2:
		{
			p.SetState(274)
			p.float_result(0)
		}

	case 3:
		{
			p.SetState(275)
			p.string_result(0)
		}

	case 4:
		{
			p.SetState(276)
			p.dynamic_result(0)
		}

	}

	return localctx
}

// IFunction_named_paramContext is an interface to support dynamic dispatch.
type IFunction_named_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsFunction_named_paramContext differentiates from other interfaces.
	IsFunction_named_paramContext()
}

type Function_named_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyFunction_named_paramContext() *Function_named_paramContext {
	var p = new(Function_named_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_named_param
	return p
}

func (*Function_named_paramContext) IsFunction_named_paramContext() {}

func NewFunction_named_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_named_paramContext {
	var p = new(Function_named_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_named_param

	return p
}

func (s *Function_named_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_named_paramContext) GetOp() antlr.Token { return s.op }

func (s *Function_named_paramContext) SetOp(v antlr.Token) { s.op = v }

func (s *Function_named_paramContext) Id_() IId_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *Function_named_paramContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserASSIGN, 0)
}

func (s *Function_named_paramContext) Int_result() IInt_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Function_named_paramContext) Float_result() IFloat_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloat_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloat_resultContext)
}

func (s *Function_named_paramContext) String_result() IString_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_resultContext)
}

func (s *Function_named_paramContext) Dynamic_result() IDynamic_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamic_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDynamic_resultContext)
}

func (s *Function_named_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_named_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_named_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_named_param(s)
	}
}

func (s *Function_named_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_named_param(s)
	}
}

func (p *CorundumParser) Function_named_param() (localctx IFunction_named_paramContext) {
	this := p
	_ = this

	localctx = NewFunction_named_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, CorundumParserRULE_function_named_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(279)
		p.Id_()
	}
	{
		p.SetState(280)

		var _m = p.Match(CorundumParserASSIGN)

		localctx.(*Function_named_paramContext).op = _m
	}
	p.SetState(285)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(281)
			p.int_result(0)
		}

	case 2:
		{
			p.SetState(282)
			p.float_result(0)
		}

	case 3:
		{
			p.SetState(283)
			p.string_result(0)
		}

	case 4:
		{
			p.SetState(284)
			p.dynamic_result(0)
		}

	}

	return localctx
}

// IFunction_call_assignmentContext is an interface to support dynamic dispatch.
type IFunction_call_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_call_assignmentContext differentiates from other interfaces.
	IsFunction_call_assignmentContext()
}

type Function_call_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_call_assignmentContext() *Function_call_assignmentContext {
	var p = new(Function_call_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_function_call_assignment
	return p
}

func (*Function_call_assignmentContext) IsFunction_call_assignmentContext() {}

func NewFunction_call_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_call_assignmentContext {
	var p = new(Function_call_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_function_call_assignment

	return p
}

func (s *Function_call_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_call_assignmentContext) Function_call() IFunction_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *Function_call_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_call_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFunction_call_assignment(s)
	}
}

func (s *Function_call_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFunction_call_assignment(s)
	}
}

func (p *CorundumParser) Function_call_assignment() (localctx IFunction_call_assignmentContext) {
	this := p
	_ = this

	localctx = NewFunction_call_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, CorundumParserRULE_function_call_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(287)
		p.Function_call()
	}

	return localctx
}

// IAll_resultContext is an interface to support dynamic dispatch.
type IAll_resultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAll_resultContext differentiates from other interfaces.
	IsAll_resultContext()
}

type All_resultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAll_resultContext() *All_resultContext {
	var p = new(All_resultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_all_result
	return p
}

func (*All_resultContext) IsAll_resultContext() {}

func NewAll_resultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *All_resultContext {
	var p = new(All_resultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_all_result

	return p
}

func (s *All_resultContext) GetParser() antlr.Parser { return s.parser }

func (s *All_resultContext) Int_result() IInt_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *All_resultContext) Float_result() IFloat_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloat_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloat_resultContext)
}

func (s *All_resultContext) String_result() IString_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_resultContext)
}

func (s *All_resultContext) Dynamic_result() IDynamic_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamic_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDynamic_resultContext)
}

func (s *All_resultContext) Global_result() IGlobal_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobal_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobal_resultContext)
}

func (s *All_resultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *All_resultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *All_resultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterAll_result(s)
	}
}

func (s *All_resultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitAll_result(s)
	}
}

func (p *CorundumParser) All_result() (localctx IAll_resultContext) {
	this := p
	_ = this

	localctx = NewAll_resultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, CorundumParserRULE_all_result)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(294)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(289)
			p.int_result(0)
		}

	case 2:
		{
			p.SetState(290)
			p.float_result(0)
		}

	case 3:
		{
			p.SetState(291)
			p.string_result(0)
		}

	case 4:
		{
			p.SetState(292)
			p.dynamic_result(0)
		}

	case 5:
		{
			p.SetState(293)
			p.Global_result()
		}

	}

	return localctx
}

// IElsif_statementContext is an interface to support dynamic dispatch.
type IElsif_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElsif_statementContext differentiates from other interfaces.
	IsElsif_statementContext()
}

type Elsif_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElsif_statementContext() *Elsif_statementContext {
	var p = new(Elsif_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_elsif_statement
	return p
}

func (*Elsif_statementContext) IsElsif_statementContext() {}

func NewElsif_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Elsif_statementContext {
	var p = new(Elsif_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_elsif_statement

	return p
}

func (s *Elsif_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Elsif_statementContext) If_elsif_statement() IIf_elsif_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_elsif_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_elsif_statementContext)
}

func (s *Elsif_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Elsif_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Elsif_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterElsif_statement(s)
	}
}

func (s *Elsif_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitElsif_statement(s)
	}
}

func (p *CorundumParser) Elsif_statement() (localctx IElsif_statementContext) {
	this := p
	_ = this

	localctx = NewElsif_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, CorundumParserRULE_elsif_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(296)
		p.If_elsif_statement()
	}

	return localctx
}

// IIf_elsif_statementContext is an interface to support dynamic dispatch.
type IIf_elsif_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_elsif_statementContext differentiates from other interfaces.
	IsIf_elsif_statementContext()
}

type If_elsif_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_elsif_statementContext() *If_elsif_statementContext {
	var p = new(If_elsif_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_if_elsif_statement
	return p
}

func (*If_elsif_statementContext) IsIf_elsif_statementContext() {}

func NewIf_elsif_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_elsif_statementContext {
	var p = new(If_elsif_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_if_elsif_statement

	return p
}

func (s *If_elsif_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *If_elsif_statementContext) ELSIF() antlr.TerminalNode {
	return s.GetToken(CorundumParserELSIF, 0)
}

func (s *If_elsif_statementContext) Cond_expression() ICond_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICond_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICond_expressionContext)
}

func (s *If_elsif_statementContext) AllCrlf() []ICrlfContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICrlfContext)(nil)).Elem())
	var tst = make([]ICrlfContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICrlfContext)
		}
	}

	return tst
}

func (s *If_elsif_statementContext) Crlf(i int) ICrlfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrlfContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *If_elsif_statementContext) AllStatement_body() []IStatement_bodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_bodyContext)(nil)).Elem())
	var tst = make([]IStatement_bodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_bodyContext)
		}
	}

	return tst
}

func (s *If_elsif_statementContext) Statement_body(i int) IStatement_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_bodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_bodyContext)
}

func (s *If_elsif_statementContext) Else_token() IElse_tokenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_tokenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_tokenContext)
}

func (s *If_elsif_statementContext) If_elsif_statement() IIf_elsif_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_elsif_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_elsif_statementContext)
}

func (s *If_elsif_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_elsif_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_elsif_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterIf_elsif_statement(s)
	}
}

func (s *If_elsif_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitIf_elsif_statement(s)
	}
}

func (p *CorundumParser) If_elsif_statement() (localctx IIf_elsif_statementContext) {
	this := p
	_ = this

	localctx = NewIf_elsif_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, CorundumParserRULE_if_elsif_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(317)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(298)
			p.Match(CorundumParserELSIF)
		}
		{
			p.SetState(299)
			p.Cond_expression()
		}
		{
			p.SetState(300)
			p.Crlf()
		}
		{
			p.SetState(301)
			p.Statement_body()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(303)
			p.Match(CorundumParserELSIF)
		}
		{
			p.SetState(304)
			p.Cond_expression()
		}
		{
			p.SetState(305)
			p.Crlf()
		}
		{
			p.SetState(306)
			p.Statement_body()
		}
		{
			p.SetState(307)
			p.Else_token()
		}
		{
			p.SetState(308)
			p.Crlf()
		}
		{
			p.SetState(309)
			p.Statement_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(311)
			p.Match(CorundumParserELSIF)
		}
		{
			p.SetState(312)
			p.Cond_expression()
		}
		{
			p.SetState(313)
			p.Crlf()
		}
		{
			p.SetState(314)
			p.Statement_body()
		}
		{
			p.SetState(315)
			p.If_elsif_statement()
		}

	}

	return localctx
}

// IIf_statementContext is an interface to support dynamic dispatch.
type IIf_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_statementContext differentiates from other interfaces.
	IsIf_statementContext()
}

type If_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_statementContext() *If_statementContext {
	var p = new(If_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_if_statement
	return p
}

func (*If_statementContext) IsIf_statementContext() {}

func NewIf_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_statementContext {
	var p = new(If_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_if_statement

	return p
}

func (s *If_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *If_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(CorundumParserIF, 0)
}

func (s *If_statementContext) Cond_expression() ICond_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICond_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICond_expressionContext)
}

func (s *If_statementContext) AllCrlf() []ICrlfContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICrlfContext)(nil)).Elem())
	var tst = make([]ICrlfContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICrlfContext)
		}
	}

	return tst
}

func (s *If_statementContext) Crlf(i int) ICrlfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrlfContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *If_statementContext) AllStatement_body() []IStatement_bodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_bodyContext)(nil)).Elem())
	var tst = make([]IStatement_bodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_bodyContext)
		}
	}

	return tst
}

func (s *If_statementContext) Statement_body(i int) IStatement_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_bodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_bodyContext)
}

func (s *If_statementContext) END() antlr.TerminalNode {
	return s.GetToken(CorundumParserEND, 0)
}

func (s *If_statementContext) Else_token() IElse_tokenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_tokenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_tokenContext)
}

func (s *If_statementContext) Elsif_statement() IElsif_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElsif_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElsif_statementContext)
}

func (s *If_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterIf_statement(s)
	}
}

func (s *If_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitIf_statement(s)
	}
}

func (p *CorundumParser) If_statement() (localctx IIf_statementContext) {
	this := p
	_ = this

	localctx = NewIf_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, CorundumParserRULE_if_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(341)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(319)
			p.Match(CorundumParserIF)
		}
		{
			p.SetState(320)
			p.Cond_expression()
		}
		{
			p.SetState(321)
			p.Crlf()
		}
		{
			p.SetState(322)
			p.Statement_body()
		}
		{
			p.SetState(323)
			p.Match(CorundumParserEND)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(325)
			p.Match(CorundumParserIF)
		}
		{
			p.SetState(326)
			p.Cond_expression()
		}
		{
			p.SetState(327)
			p.Crlf()
		}
		{
			p.SetState(328)
			p.Statement_body()
		}
		{
			p.SetState(329)
			p.Else_token()
		}
		{
			p.SetState(330)
			p.Crlf()
		}
		{
			p.SetState(331)
			p.Statement_body()
		}
		{
			p.SetState(332)
			p.Match(CorundumParserEND)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(334)
			p.Match(CorundumParserIF)
		}
		{
			p.SetState(335)
			p.Cond_expression()
		}
		{
			p.SetState(336)
			p.Crlf()
		}
		{
			p.SetState(337)
			p.Statement_body()
		}
		{
			p.SetState(338)
			p.Elsif_statement()
		}
		{
			p.SetState(339)
			p.Match(CorundumParserEND)
		}

	}

	return localctx
}

// IUnless_statementContext is an interface to support dynamic dispatch.
type IUnless_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnless_statementContext differentiates from other interfaces.
	IsUnless_statementContext()
}

type Unless_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnless_statementContext() *Unless_statementContext {
	var p = new(Unless_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_unless_statement
	return p
}

func (*Unless_statementContext) IsUnless_statementContext() {}

func NewUnless_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unless_statementContext {
	var p = new(Unless_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_unless_statement

	return p
}

func (s *Unless_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Unless_statementContext) UNLESS() antlr.TerminalNode {
	return s.GetToken(CorundumParserUNLESS, 0)
}

func (s *Unless_statementContext) Cond_expression() ICond_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICond_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICond_expressionContext)
}

func (s *Unless_statementContext) AllCrlf() []ICrlfContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICrlfContext)(nil)).Elem())
	var tst = make([]ICrlfContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICrlfContext)
		}
	}

	return tst
}

func (s *Unless_statementContext) Crlf(i int) ICrlfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrlfContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *Unless_statementContext) AllStatement_body() []IStatement_bodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_bodyContext)(nil)).Elem())
	var tst = make([]IStatement_bodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_bodyContext)
		}
	}

	return tst
}

func (s *Unless_statementContext) Statement_body(i int) IStatement_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_bodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_bodyContext)
}

func (s *Unless_statementContext) END() antlr.TerminalNode {
	return s.GetToken(CorundumParserEND, 0)
}

func (s *Unless_statementContext) Else_token() IElse_tokenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_tokenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_tokenContext)
}

func (s *Unless_statementContext) Elsif_statement() IElsif_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElsif_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElsif_statementContext)
}

func (s *Unless_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unless_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unless_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterUnless_statement(s)
	}
}

func (s *Unless_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitUnless_statement(s)
	}
}

func (p *CorundumParser) Unless_statement() (localctx IUnless_statementContext) {
	this := p
	_ = this

	localctx = NewUnless_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, CorundumParserRULE_unless_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(365)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(343)
			p.Match(CorundumParserUNLESS)
		}
		{
			p.SetState(344)
			p.Cond_expression()
		}
		{
			p.SetState(345)
			p.Crlf()
		}
		{
			p.SetState(346)
			p.Statement_body()
		}
		{
			p.SetState(347)
			p.Match(CorundumParserEND)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(349)
			p.Match(CorundumParserUNLESS)
		}
		{
			p.SetState(350)
			p.Cond_expression()
		}
		{
			p.SetState(351)
			p.Crlf()
		}
		{
			p.SetState(352)
			p.Statement_body()
		}
		{
			p.SetState(353)
			p.Else_token()
		}
		{
			p.SetState(354)
			p.Crlf()
		}
		{
			p.SetState(355)
			p.Statement_body()
		}
		{
			p.SetState(356)
			p.Match(CorundumParserEND)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(358)
			p.Match(CorundumParserUNLESS)
		}
		{
			p.SetState(359)
			p.Cond_expression()
		}
		{
			p.SetState(360)
			p.Crlf()
		}
		{
			p.SetState(361)
			p.Statement_body()
		}
		{
			p.SetState(362)
			p.Elsif_statement()
		}
		{
			p.SetState(363)
			p.Match(CorundumParserEND)
		}

	}

	return localctx
}

// IWhile_statementContext is an interface to support dynamic dispatch.
type IWhile_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhile_statementContext differentiates from other interfaces.
	IsWhile_statementContext()
}

type While_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_statementContext() *While_statementContext {
	var p = new(While_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_while_statement
	return p
}

func (*While_statementContext) IsWhile_statementContext() {}

func NewWhile_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_statementContext {
	var p = new(While_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_while_statement

	return p
}

func (s *While_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *While_statementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(CorundumParserWHILE, 0)
}

func (s *While_statementContext) Cond_expression() ICond_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICond_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICond_expressionContext)
}

func (s *While_statementContext) Crlf() ICrlfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrlfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *While_statementContext) Statement_body() IStatement_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_bodyContext)
}

func (s *While_statementContext) END() antlr.TerminalNode {
	return s.GetToken(CorundumParserEND, 0)
}

func (s *While_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *While_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterWhile_statement(s)
	}
}

func (s *While_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitWhile_statement(s)
	}
}

func (p *CorundumParser) While_statement() (localctx IWhile_statementContext) {
	this := p
	_ = this

	localctx = NewWhile_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, CorundumParserRULE_while_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(367)
		p.Match(CorundumParserWHILE)
	}
	{
		p.SetState(368)
		p.Cond_expression()
	}
	{
		p.SetState(369)
		p.Crlf()
	}
	{
		p.SetState(370)
		p.Statement_body()
	}
	{
		p.SetState(371)
		p.Match(CorundumParserEND)
	}

	return localctx
}

// IFor_statementContext is an interface to support dynamic dispatch.
type IFor_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_statementContext differentiates from other interfaces.
	IsFor_statementContext()
}

type For_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_statementContext() *For_statementContext {
	var p = new(For_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_for_statement
	return p
}

func (*For_statementContext) IsFor_statementContext() {}

func NewFor_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_statementContext {
	var p = new(For_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_for_statement

	return p
}

func (s *For_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *For_statementContext) FOR() antlr.TerminalNode {
	return s.GetToken(CorundumParserFOR, 0)
}

func (s *For_statementContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserLEFT_RBRACKET, 0)
}

func (s *For_statementContext) Init_expression() IInit_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_expressionContext)
}

func (s *For_statementContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(CorundumParserSEMICOLON)
}

func (s *For_statementContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(CorundumParserSEMICOLON, i)
}

func (s *For_statementContext) Cond_expression() ICond_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICond_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICond_expressionContext)
}

func (s *For_statementContext) Loop_expression() ILoop_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_expressionContext)
}

func (s *For_statementContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserRIGHT_RBRACKET, 0)
}

func (s *For_statementContext) Crlf() ICrlfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrlfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *For_statementContext) Statement_body() IStatement_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_bodyContext)
}

func (s *For_statementContext) END() antlr.TerminalNode {
	return s.GetToken(CorundumParserEND, 0)
}

func (s *For_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFor_statement(s)
	}
}

func (s *For_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFor_statement(s)
	}
}

func (p *CorundumParser) For_statement() (localctx IFor_statementContext) {
	this := p
	_ = this

	localctx = NewFor_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, CorundumParserRULE_for_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(373)
			p.Match(CorundumParserFOR)
		}
		{
			p.SetState(374)
			p.Match(CorundumParserLEFT_RBRACKET)
		}
		{
			p.SetState(375)
			p.Init_expression()
		}
		{
			p.SetState(376)
			p.Match(CorundumParserSEMICOLON)
		}
		{
			p.SetState(377)
			p.Cond_expression()
		}
		{
			p.SetState(378)
			p.Match(CorundumParserSEMICOLON)
		}
		{
			p.SetState(379)
			p.Loop_expression()
		}
		{
			p.SetState(380)
			p.Match(CorundumParserRIGHT_RBRACKET)
		}
		{
			p.SetState(381)
			p.Crlf()
		}
		{
			p.SetState(382)
			p.Statement_body()
		}
		{
			p.SetState(383)
			p.Match(CorundumParserEND)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(385)
			p.Match(CorundumParserFOR)
		}
		{
			p.SetState(386)
			p.Init_expression()
		}
		{
			p.SetState(387)
			p.Match(CorundumParserSEMICOLON)
		}
		{
			p.SetState(388)
			p.Cond_expression()
		}
		{
			p.SetState(389)
			p.Match(CorundumParserSEMICOLON)
		}
		{
			p.SetState(390)
			p.Loop_expression()
		}
		{
			p.SetState(391)
			p.Crlf()
		}
		{
			p.SetState(392)
			p.Statement_body()
		}
		{
			p.SetState(393)
			p.Match(CorundumParserEND)
		}

	}

	return localctx
}

// IInit_expressionContext is an interface to support dynamic dispatch.
type IInit_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_expressionContext differentiates from other interfaces.
	IsInit_expressionContext()
}

type Init_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_expressionContext() *Init_expressionContext {
	var p = new(Init_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_init_expression
	return p
}

func (*Init_expressionContext) IsInit_expressionContext() {}

func NewInit_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_expressionContext {
	var p = new(Init_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_init_expression

	return p
}

func (s *Init_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_expressionContext) For_init_list() IFor_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_init_listContext)
}

func (s *Init_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterInit_expression(s)
	}
}

func (s *Init_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitInit_expression(s)
	}
}

func (p *CorundumParser) Init_expression() (localctx IInit_expressionContext) {
	this := p
	_ = this

	localctx = NewInit_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, CorundumParserRULE_init_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(397)
		p.for_init_list(0)
	}

	return localctx
}

// IAll_assignmentContext is an interface to support dynamic dispatch.
type IAll_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAll_assignmentContext differentiates from other interfaces.
	IsAll_assignmentContext()
}

type All_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAll_assignmentContext() *All_assignmentContext {
	var p = new(All_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_all_assignment
	return p
}

func (*All_assignmentContext) IsAll_assignmentContext() {}

func NewAll_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *All_assignmentContext {
	var p = new(All_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_all_assignment

	return p
}

func (s *All_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *All_assignmentContext) Int_assignment() IInt_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_assignmentContext)
}

func (s *All_assignmentContext) Float_assignment() IFloat_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloat_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloat_assignmentContext)
}

func (s *All_assignmentContext) String_assignment() IString_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_assignmentContext)
}

func (s *All_assignmentContext) Dynamic_assignment() IDynamic_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamic_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDynamic_assignmentContext)
}

func (s *All_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *All_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *All_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterAll_assignment(s)
	}
}

func (s *All_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitAll_assignment(s)
	}
}

func (p *CorundumParser) All_assignment() (localctx IAll_assignmentContext) {
	this := p
	_ = this

	localctx = NewAll_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, CorundumParserRULE_all_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(403)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(399)
			p.Int_assignment()
		}

	case 2:
		{
			p.SetState(400)
			p.Float_assignment()
		}

	case 3:
		{
			p.SetState(401)
			p.String_assignment()
		}

	case 4:
		{
			p.SetState(402)
			p.Dynamic_assignment()
		}

	}

	return localctx
}

// IFor_init_listContext is an interface to support dynamic dispatch.
type IFor_init_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_init_listContext differentiates from other interfaces.
	IsFor_init_listContext()
}

type For_init_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_init_listContext() *For_init_listContext {
	var p = new(For_init_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_for_init_list
	return p
}

func (*For_init_listContext) IsFor_init_listContext() {}

func NewFor_init_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_init_listContext {
	var p = new(For_init_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_for_init_list

	return p
}

func (s *For_init_listContext) GetParser() antlr.Parser { return s.parser }

func (s *For_init_listContext) All_assignment() IAll_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAll_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAll_assignmentContext)
}

func (s *For_init_listContext) For_init_list() IFor_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_init_listContext)
}

func (s *For_init_listContext) COMMA() antlr.TerminalNode {
	return s.GetToken(CorundumParserCOMMA, 0)
}

func (s *For_init_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_init_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_init_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFor_init_list(s)
	}
}

func (s *For_init_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFor_init_list(s)
	}
}

func (p *CorundumParser) For_init_list() (localctx IFor_init_listContext) {
	return p.for_init_list(0)
}

func (p *CorundumParser) for_init_list(_p int) (localctx IFor_init_listContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewFor_init_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFor_init_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 68
	p.EnterRecursionRule(localctx, 68, CorundumParserRULE_for_init_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(406)
		p.All_assignment()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(413)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewFor_init_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_for_init_list)
			p.SetState(408)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(409)
				p.Match(CorundumParserCOMMA)
			}
			{
				p.SetState(410)
				p.All_assignment()
			}

		}
		p.SetState(415)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())
	}

	return localctx
}

// ICond_expressionContext is an interface to support dynamic dispatch.
type ICond_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCond_expressionContext differentiates from other interfaces.
	IsCond_expressionContext()
}

type Cond_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCond_expressionContext() *Cond_expressionContext {
	var p = new(Cond_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_cond_expression
	return p
}

func (*Cond_expressionContext) IsCond_expressionContext() {}

func NewCond_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cond_expressionContext {
	var p = new(Cond_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_cond_expression

	return p
}

func (s *Cond_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cond_expressionContext) Comparison_list() IComparison_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparison_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparison_listContext)
}

func (s *Cond_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cond_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cond_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterCond_expression(s)
	}
}

func (s *Cond_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitCond_expression(s)
	}
}

func (p *CorundumParser) Cond_expression() (localctx ICond_expressionContext) {
	this := p
	_ = this

	localctx = NewCond_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, CorundumParserRULE_cond_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(416)
		p.Comparison_list()
	}

	return localctx
}

// ILoop_expressionContext is an interface to support dynamic dispatch.
type ILoop_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_expressionContext differentiates from other interfaces.
	IsLoop_expressionContext()
}

type Loop_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_expressionContext() *Loop_expressionContext {
	var p = new(Loop_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_loop_expression
	return p
}

func (*Loop_expressionContext) IsLoop_expressionContext() {}

func NewLoop_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_expressionContext {
	var p = new(Loop_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_loop_expression

	return p
}

func (s *Loop_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_expressionContext) For_loop_list() IFor_loop_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_loop_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_loop_listContext)
}

func (s *Loop_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterLoop_expression(s)
	}
}

func (s *Loop_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitLoop_expression(s)
	}
}

func (p *CorundumParser) Loop_expression() (localctx ILoop_expressionContext) {
	this := p
	_ = this

	localctx = NewLoop_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, CorundumParserRULE_loop_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(418)
		p.for_loop_list(0)
	}

	return localctx
}

// IFor_loop_listContext is an interface to support dynamic dispatch.
type IFor_loop_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_loop_listContext differentiates from other interfaces.
	IsFor_loop_listContext()
}

type For_loop_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_loop_listContext() *For_loop_listContext {
	var p = new(For_loop_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_for_loop_list
	return p
}

func (*For_loop_listContext) IsFor_loop_listContext() {}

func NewFor_loop_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_loop_listContext {
	var p = new(For_loop_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_for_loop_list

	return p
}

func (s *For_loop_listContext) GetParser() antlr.Parser { return s.parser }

func (s *For_loop_listContext) All_assignment() IAll_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAll_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAll_assignmentContext)
}

func (s *For_loop_listContext) For_loop_list() IFor_loop_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_loop_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_loop_listContext)
}

func (s *For_loop_listContext) COMMA() antlr.TerminalNode {
	return s.GetToken(CorundumParserCOMMA, 0)
}

func (s *For_loop_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_loop_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_loop_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFor_loop_list(s)
	}
}

func (s *For_loop_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFor_loop_list(s)
	}
}

func (p *CorundumParser) For_loop_list() (localctx IFor_loop_listContext) {
	return p.for_loop_list(0)
}

func (p *CorundumParser) for_loop_list(_p int) (localctx IFor_loop_listContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewFor_loop_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFor_loop_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 74
	p.EnterRecursionRule(localctx, 74, CorundumParserRULE_for_loop_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(421)
		p.All_assignment()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewFor_loop_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_for_loop_list)
			p.SetState(423)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(424)
				p.Match(CorundumParserCOMMA)
			}
			{
				p.SetState(425)
				p.All_assignment()
			}

		}
		p.SetState(430)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())
	}

	return localctx
}

// IStatement_bodyContext is an interface to support dynamic dispatch.
type IStatement_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_bodyContext differentiates from other interfaces.
	IsStatement_bodyContext()
}

type Statement_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_bodyContext() *Statement_bodyContext {
	var p = new(Statement_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_statement_body
	return p
}

func (*Statement_bodyContext) IsStatement_bodyContext() {}

func NewStatement_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_bodyContext {
	var p = new(Statement_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_statement_body

	return p
}

func (s *Statement_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_bodyContext) Statement_expression_list() IStatement_expression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_expression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_expression_listContext)
}

func (s *Statement_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Statement_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterStatement_body(s)
	}
}

func (s *Statement_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitStatement_body(s)
	}
}

func (p *CorundumParser) Statement_body() (localctx IStatement_bodyContext) {
	this := p
	_ = this

	localctx = NewStatement_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, CorundumParserRULE_statement_body)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(431)
		p.statement_expression_list(0)
	}

	return localctx
}

// IStatement_expression_listContext is an interface to support dynamic dispatch.
type IStatement_expression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_expression_listContext differentiates from other interfaces.
	IsStatement_expression_listContext()
}

type Statement_expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_expression_listContext() *Statement_expression_listContext {
	var p = new(Statement_expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_statement_expression_list
	return p
}

func (*Statement_expression_listContext) IsStatement_expression_listContext() {}

func NewStatement_expression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_expression_listContext {
	var p = new(Statement_expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_statement_expression_list

	return p
}

func (s *Statement_expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_expression_listContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Statement_expression_listContext) Terminator() ITerminatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminatorContext)
}

func (s *Statement_expression_listContext) RETRY() antlr.TerminalNode {
	return s.GetToken(CorundumParserRETRY, 0)
}

func (s *Statement_expression_listContext) Break_expression() IBreak_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_expressionContext)
}

func (s *Statement_expression_listContext) Statement_expression_list() IStatement_expression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_expression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_expression_listContext)
}

func (s *Statement_expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Statement_expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterStatement_expression_list(s)
	}
}

func (s *Statement_expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitStatement_expression_list(s)
	}
}

func (p *CorundumParser) Statement_expression_list() (localctx IStatement_expression_listContext) {
	return p.statement_expression_list(0)
}

func (p *CorundumParser) statement_expression_list(_p int) (localctx IStatement_expression_listContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewStatement_expression_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IStatement_expression_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 78
	p.EnterRecursionRule(localctx, 78, CorundumParserRULE_statement_expression_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(442)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CorundumParserLITERAL, CorundumParserREQUIRE, CorundumParserDEF, CorundumParserRETURN, CorundumParserPIR, CorundumParserIF, CorundumParserUNLESS, CorundumParserWHILE, CorundumParserFOR, CorundumParserTRUE, CorundumParserFALSE, CorundumParserBIT_NOT, CorundumParserNOT, CorundumParserLEFT_RBRACKET, CorundumParserNIL, CorundumParserINT, CorundumParserFLOAT, CorundumParserID, CorundumParserID_GLOBAL, CorundumParserID_FUNCTION:
		{
			p.SetState(434)
			p.Expression()
		}
		{
			p.SetState(435)
			p.terminator(0)
		}

	case CorundumParserRETRY:
		{
			p.SetState(437)
			p.Match(CorundumParserRETRY)
		}
		{
			p.SetState(438)
			p.terminator(0)
		}

	case CorundumParserBREAK:
		{
			p.SetState(439)
			p.Break_expression()
		}
		{
			p.SetState(440)
			p.terminator(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(457)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(455)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) {
			case 1:
				localctx = NewStatement_expression_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_statement_expression_list)
				p.SetState(444)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(445)
					p.Expression()
				}
				{
					p.SetState(446)
					p.terminator(0)
				}

			case 2:
				localctx = NewStatement_expression_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_statement_expression_list)
				p.SetState(448)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(449)
					p.Match(CorundumParserRETRY)
				}
				{
					p.SetState(450)
					p.terminator(0)
				}

			case 3:
				localctx = NewStatement_expression_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_statement_expression_list)
				p.SetState(451)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(452)
					p.Break_expression()
				}
				{
					p.SetState(453)
					p.terminator(0)
				}

			}

		}
		p.SetState(459)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())
	}

	return localctx
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetVar_id returns the var_id rule contexts.
	GetVar_id() ILvalueContext

	// SetVar_id sets the var_id rule contexts.
	SetVar_id(ILvalueContext)

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	var_id ILvalueContext
	op     antlr.Token
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_assignment
	return p
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) GetOp() antlr.Token { return s.op }

func (s *AssignmentContext) SetOp(v antlr.Token) { s.op = v }

func (s *AssignmentContext) GetVar_id() ILvalueContext { return s.var_id }

func (s *AssignmentContext) SetVar_id(v ILvalueContext) { s.var_id = v }

func (s *AssignmentContext) Rvalue() IRvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRvalueContext)
}

func (s *AssignmentContext) Lvalue() ILvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *AssignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserASSIGN, 0)
}

func (s *AssignmentContext) PLUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserPLUS_ASSIGN, 0)
}

func (s *AssignmentContext) MINUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserMINUS_ASSIGN, 0)
}

func (s *AssignmentContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserMUL_ASSIGN, 0)
}

func (s *AssignmentContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserDIV_ASSIGN, 0)
}

func (s *AssignmentContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserMOD_ASSIGN, 0)
}

func (s *AssignmentContext) EXP_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserEXP_ASSIGN, 0)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (p *CorundumParser) Assignment() (localctx IAssignmentContext) {
	this := p
	_ = this

	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, CorundumParserRULE_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(468)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(460)

			var _x = p.Lvalue()

			localctx.(*AssignmentContext).var_id = _x
		}
		{
			p.SetState(461)

			var _m = p.Match(CorundumParserASSIGN)

			localctx.(*AssignmentContext).op = _m
		}
		{
			p.SetState(462)
			p.rvalue(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(464)

			var _x = p.Lvalue()

			localctx.(*AssignmentContext).var_id = _x
		}
		{
			p.SetState(465)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AssignmentContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(CorundumParserPLUS_ASSIGN-33))|(1<<(CorundumParserMINUS_ASSIGN-33))|(1<<(CorundumParserMUL_ASSIGN-33))|(1<<(CorundumParserDIV_ASSIGN-33))|(1<<(CorundumParserMOD_ASSIGN-33))|(1<<(CorundumParserEXP_ASSIGN-33)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AssignmentContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(466)
			p.rvalue(0)
		}

	}

	return localctx
}

// IDynamic_assignmentContext is an interface to support dynamic dispatch.
type IDynamic_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetVar_id returns the var_id rule contexts.
	GetVar_id() ILvalueContext

	// SetVar_id sets the var_id rule contexts.
	SetVar_id(ILvalueContext)

	// IsDynamic_assignmentContext differentiates from other interfaces.
	IsDynamic_assignmentContext()
}

type Dynamic_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	var_id ILvalueContext
	op     antlr.Token
}

func NewEmptyDynamic_assignmentContext() *Dynamic_assignmentContext {
	var p = new(Dynamic_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_dynamic_assignment
	return p
}

func (*Dynamic_assignmentContext) IsDynamic_assignmentContext() {}

func NewDynamic_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dynamic_assignmentContext {
	var p = new(Dynamic_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_dynamic_assignment

	return p
}

func (s *Dynamic_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Dynamic_assignmentContext) GetOp() antlr.Token { return s.op }

func (s *Dynamic_assignmentContext) SetOp(v antlr.Token) { s.op = v }

func (s *Dynamic_assignmentContext) GetVar_id() ILvalueContext { return s.var_id }

func (s *Dynamic_assignmentContext) SetVar_id(v ILvalueContext) { s.var_id = v }

func (s *Dynamic_assignmentContext) Dynamic_result() IDynamic_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamic_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDynamic_resultContext)
}

func (s *Dynamic_assignmentContext) Lvalue() ILvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *Dynamic_assignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserASSIGN, 0)
}

func (s *Dynamic_assignmentContext) PLUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserPLUS_ASSIGN, 0)
}

func (s *Dynamic_assignmentContext) MINUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserMINUS_ASSIGN, 0)
}

func (s *Dynamic_assignmentContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserMUL_ASSIGN, 0)
}

func (s *Dynamic_assignmentContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserDIV_ASSIGN, 0)
}

func (s *Dynamic_assignmentContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserMOD_ASSIGN, 0)
}

func (s *Dynamic_assignmentContext) EXP_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserEXP_ASSIGN, 0)
}

func (s *Dynamic_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dynamic_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dynamic_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterDynamic_assignment(s)
	}
}

func (s *Dynamic_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitDynamic_assignment(s)
	}
}

func (p *CorundumParser) Dynamic_assignment() (localctx IDynamic_assignmentContext) {
	this := p
	_ = this

	localctx = NewDynamic_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, CorundumParserRULE_dynamic_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(470)

			var _x = p.Lvalue()

			localctx.(*Dynamic_assignmentContext).var_id = _x
		}
		{
			p.SetState(471)

			var _m = p.Match(CorundumParserASSIGN)

			localctx.(*Dynamic_assignmentContext).op = _m
		}
		{
			p.SetState(472)
			p.dynamic_result(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(474)

			var _x = p.Lvalue()

			localctx.(*Dynamic_assignmentContext).var_id = _x
		}
		{
			p.SetState(475)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Dynamic_assignmentContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(CorundumParserPLUS_ASSIGN-33))|(1<<(CorundumParserMINUS_ASSIGN-33))|(1<<(CorundumParserMUL_ASSIGN-33))|(1<<(CorundumParserDIV_ASSIGN-33))|(1<<(CorundumParserMOD_ASSIGN-33))|(1<<(CorundumParserEXP_ASSIGN-33)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Dynamic_assignmentContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(476)
			p.dynamic_result(0)
		}

	}

	return localctx
}

// IInt_assignmentContext is an interface to support dynamic dispatch.
type IInt_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetVar_id returns the var_id rule contexts.
	GetVar_id() ILvalueContext

	// SetVar_id sets the var_id rule contexts.
	SetVar_id(ILvalueContext)

	// IsInt_assignmentContext differentiates from other interfaces.
	IsInt_assignmentContext()
}

type Int_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	var_id ILvalueContext
	op     antlr.Token
}

func NewEmptyInt_assignmentContext() *Int_assignmentContext {
	var p = new(Int_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_int_assignment
	return p
}

func (*Int_assignmentContext) IsInt_assignmentContext() {}

func NewInt_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_assignmentContext {
	var p = new(Int_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_int_assignment

	return p
}

func (s *Int_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_assignmentContext) GetOp() antlr.Token { return s.op }

func (s *Int_assignmentContext) SetOp(v antlr.Token) { s.op = v }

func (s *Int_assignmentContext) GetVar_id() ILvalueContext { return s.var_id }

func (s *Int_assignmentContext) SetVar_id(v ILvalueContext) { s.var_id = v }

func (s *Int_assignmentContext) Int_result() IInt_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Int_assignmentContext) Lvalue() ILvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *Int_assignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserASSIGN, 0)
}

func (s *Int_assignmentContext) PLUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserPLUS_ASSIGN, 0)
}

func (s *Int_assignmentContext) MINUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserMINUS_ASSIGN, 0)
}

func (s *Int_assignmentContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserMUL_ASSIGN, 0)
}

func (s *Int_assignmentContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserDIV_ASSIGN, 0)
}

func (s *Int_assignmentContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserMOD_ASSIGN, 0)
}

func (s *Int_assignmentContext) EXP_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserEXP_ASSIGN, 0)
}

func (s *Int_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterInt_assignment(s)
	}
}

func (s *Int_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitInt_assignment(s)
	}
}

func (p *CorundumParser) Int_assignment() (localctx IInt_assignmentContext) {
	this := p
	_ = this

	localctx = NewInt_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, CorundumParserRULE_int_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(488)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(480)

			var _x = p.Lvalue()

			localctx.(*Int_assignmentContext).var_id = _x
		}
		{
			p.SetState(481)

			var _m = p.Match(CorundumParserASSIGN)

			localctx.(*Int_assignmentContext).op = _m
		}
		{
			p.SetState(482)
			p.int_result(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(484)

			var _x = p.Lvalue()

			localctx.(*Int_assignmentContext).var_id = _x
		}
		{
			p.SetState(485)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Int_assignmentContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(CorundumParserPLUS_ASSIGN-33))|(1<<(CorundumParserMINUS_ASSIGN-33))|(1<<(CorundumParserMUL_ASSIGN-33))|(1<<(CorundumParserDIV_ASSIGN-33))|(1<<(CorundumParserMOD_ASSIGN-33))|(1<<(CorundumParserEXP_ASSIGN-33)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Int_assignmentContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(486)
			p.int_result(0)
		}

	}

	return localctx
}

// IFloat_assignmentContext is an interface to support dynamic dispatch.
type IFloat_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetVar_id returns the var_id rule contexts.
	GetVar_id() ILvalueContext

	// SetVar_id sets the var_id rule contexts.
	SetVar_id(ILvalueContext)

	// IsFloat_assignmentContext differentiates from other interfaces.
	IsFloat_assignmentContext()
}

type Float_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	var_id ILvalueContext
	op     antlr.Token
}

func NewEmptyFloat_assignmentContext() *Float_assignmentContext {
	var p = new(Float_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_float_assignment
	return p
}

func (*Float_assignmentContext) IsFloat_assignmentContext() {}

func NewFloat_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Float_assignmentContext {
	var p = new(Float_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_float_assignment

	return p
}

func (s *Float_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Float_assignmentContext) GetOp() antlr.Token { return s.op }

func (s *Float_assignmentContext) SetOp(v antlr.Token) { s.op = v }

func (s *Float_assignmentContext) GetVar_id() ILvalueContext { return s.var_id }

func (s *Float_assignmentContext) SetVar_id(v ILvalueContext) { s.var_id = v }

func (s *Float_assignmentContext) Float_result() IFloat_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloat_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloat_resultContext)
}

func (s *Float_assignmentContext) Lvalue() ILvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *Float_assignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserASSIGN, 0)
}

func (s *Float_assignmentContext) PLUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserPLUS_ASSIGN, 0)
}

func (s *Float_assignmentContext) MINUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserMINUS_ASSIGN, 0)
}

func (s *Float_assignmentContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserMUL_ASSIGN, 0)
}

func (s *Float_assignmentContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserDIV_ASSIGN, 0)
}

func (s *Float_assignmentContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserMOD_ASSIGN, 0)
}

func (s *Float_assignmentContext) EXP_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserEXP_ASSIGN, 0)
}

func (s *Float_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Float_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Float_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFloat_assignment(s)
	}
}

func (s *Float_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFloat_assignment(s)
	}
}

func (p *CorundumParser) Float_assignment() (localctx IFloat_assignmentContext) {
	this := p
	_ = this

	localctx = NewFloat_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, CorundumParserRULE_float_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(490)

			var _x = p.Lvalue()

			localctx.(*Float_assignmentContext).var_id = _x
		}
		{
			p.SetState(491)

			var _m = p.Match(CorundumParserASSIGN)

			localctx.(*Float_assignmentContext).op = _m
		}
		{
			p.SetState(492)
			p.float_result(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(494)

			var _x = p.Lvalue()

			localctx.(*Float_assignmentContext).var_id = _x
		}
		{
			p.SetState(495)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Float_assignmentContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(CorundumParserPLUS_ASSIGN-33))|(1<<(CorundumParserMINUS_ASSIGN-33))|(1<<(CorundumParserMUL_ASSIGN-33))|(1<<(CorundumParserDIV_ASSIGN-33))|(1<<(CorundumParserMOD_ASSIGN-33))|(1<<(CorundumParserEXP_ASSIGN-33)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Float_assignmentContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(496)
			p.float_result(0)
		}

	}

	return localctx
}

// IString_assignmentContext is an interface to support dynamic dispatch.
type IString_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetVar_id returns the var_id rule contexts.
	GetVar_id() ILvalueContext

	// SetVar_id sets the var_id rule contexts.
	SetVar_id(ILvalueContext)

	// IsString_assignmentContext differentiates from other interfaces.
	IsString_assignmentContext()
}

type String_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	var_id ILvalueContext
	op     antlr.Token
}

func NewEmptyString_assignmentContext() *String_assignmentContext {
	var p = new(String_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_string_assignment
	return p
}

func (*String_assignmentContext) IsString_assignmentContext() {}

func NewString_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_assignmentContext {
	var p = new(String_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_string_assignment

	return p
}

func (s *String_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *String_assignmentContext) GetOp() antlr.Token { return s.op }

func (s *String_assignmentContext) SetOp(v antlr.Token) { s.op = v }

func (s *String_assignmentContext) GetVar_id() ILvalueContext { return s.var_id }

func (s *String_assignmentContext) SetVar_id(v ILvalueContext) { s.var_id = v }

func (s *String_assignmentContext) String_result() IString_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_resultContext)
}

func (s *String_assignmentContext) Lvalue() ILvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *String_assignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserASSIGN, 0)
}

func (s *String_assignmentContext) PLUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserPLUS_ASSIGN, 0)
}

func (s *String_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterString_assignment(s)
	}
}

func (s *String_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitString_assignment(s)
	}
}

func (p *CorundumParser) String_assignment() (localctx IString_assignmentContext) {
	this := p
	_ = this

	localctx = NewString_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, CorundumParserRULE_string_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(500)

			var _x = p.Lvalue()

			localctx.(*String_assignmentContext).var_id = _x
		}
		{
			p.SetState(501)

			var _m = p.Match(CorundumParserASSIGN)

			localctx.(*String_assignmentContext).op = _m
		}
		{
			p.SetState(502)
			p.string_result(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(504)

			var _x = p.Lvalue()

			localctx.(*String_assignmentContext).var_id = _x
		}
		{
			p.SetState(505)

			var _m = p.Match(CorundumParserPLUS_ASSIGN)

			localctx.(*String_assignmentContext).op = _m
		}
		{
			p.SetState(506)
			p.string_result(0)
		}

	}

	return localctx
}

// IInitial_array_assignmentContext is an interface to support dynamic dispatch.
type IInitial_array_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetVar_id returns the var_id rule contexts.
	GetVar_id() ILvalueContext

	// SetVar_id sets the var_id rule contexts.
	SetVar_id(ILvalueContext)

	// IsInitial_array_assignmentContext differentiates from other interfaces.
	IsInitial_array_assignmentContext()
}

type Initial_array_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	var_id ILvalueContext
	op     antlr.Token
}

func NewEmptyInitial_array_assignmentContext() *Initial_array_assignmentContext {
	var p = new(Initial_array_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_initial_array_assignment
	return p
}

func (*Initial_array_assignmentContext) IsInitial_array_assignmentContext() {}

func NewInitial_array_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Initial_array_assignmentContext {
	var p = new(Initial_array_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_initial_array_assignment

	return p
}

func (s *Initial_array_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Initial_array_assignmentContext) GetOp() antlr.Token { return s.op }

func (s *Initial_array_assignmentContext) SetOp(v antlr.Token) { s.op = v }

func (s *Initial_array_assignmentContext) GetVar_id() ILvalueContext { return s.var_id }

func (s *Initial_array_assignmentContext) SetVar_id(v ILvalueContext) { s.var_id = v }

func (s *Initial_array_assignmentContext) LEFT_SBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserLEFT_SBRACKET, 0)
}

func (s *Initial_array_assignmentContext) RIGHT_SBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserRIGHT_SBRACKET, 0)
}

func (s *Initial_array_assignmentContext) Lvalue() ILvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *Initial_array_assignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserASSIGN, 0)
}

func (s *Initial_array_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Initial_array_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Initial_array_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterInitial_array_assignment(s)
	}
}

func (s *Initial_array_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitInitial_array_assignment(s)
	}
}

func (p *CorundumParser) Initial_array_assignment() (localctx IInitial_array_assignmentContext) {
	this := p
	_ = this

	localctx = NewInitial_array_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, CorundumParserRULE_initial_array_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(510)

		var _x = p.Lvalue()

		localctx.(*Initial_array_assignmentContext).var_id = _x
	}
	{
		p.SetState(511)

		var _m = p.Match(CorundumParserASSIGN)

		localctx.(*Initial_array_assignmentContext).op = _m
	}
	{
		p.SetState(512)
		p.Match(CorundumParserLEFT_SBRACKET)
	}
	{
		p.SetState(513)
		p.Match(CorundumParserRIGHT_SBRACKET)
	}

	return localctx
}

// IArray_assignmentContext is an interface to support dynamic dispatch.
type IArray_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetArr_def returns the arr_def rule contexts.
	GetArr_def() IArray_selectorContext

	// GetArr_val returns the arr_val rule contexts.
	GetArr_val() IAll_resultContext

	// SetArr_def sets the arr_def rule contexts.
	SetArr_def(IArray_selectorContext)

	// SetArr_val sets the arr_val rule contexts.
	SetArr_val(IAll_resultContext)

	// IsArray_assignmentContext differentiates from other interfaces.
	IsArray_assignmentContext()
}

type Array_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser  antlr.Parser
	arr_def IArray_selectorContext
	op      antlr.Token
	arr_val IAll_resultContext
}

func NewEmptyArray_assignmentContext() *Array_assignmentContext {
	var p = new(Array_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_array_assignment
	return p
}

func (*Array_assignmentContext) IsArray_assignmentContext() {}

func NewArray_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_assignmentContext {
	var p = new(Array_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_array_assignment

	return p
}

func (s *Array_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_assignmentContext) GetOp() antlr.Token { return s.op }

func (s *Array_assignmentContext) SetOp(v antlr.Token) { s.op = v }

func (s *Array_assignmentContext) GetArr_def() IArray_selectorContext { return s.arr_def }

func (s *Array_assignmentContext) GetArr_val() IAll_resultContext { return s.arr_val }

func (s *Array_assignmentContext) SetArr_def(v IArray_selectorContext) { s.arr_def = v }

func (s *Array_assignmentContext) SetArr_val(v IAll_resultContext) { s.arr_val = v }

func (s *Array_assignmentContext) Array_selector() IArray_selectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_selectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_selectorContext)
}

func (s *Array_assignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CorundumParserASSIGN, 0)
}

func (s *Array_assignmentContext) All_result() IAll_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAll_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAll_resultContext)
}

func (s *Array_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterArray_assignment(s)
	}
}

func (s *Array_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitArray_assignment(s)
	}
}

func (p *CorundumParser) Array_assignment() (localctx IArray_assignmentContext) {
	this := p
	_ = this

	localctx = NewArray_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, CorundumParserRULE_array_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)

		var _x = p.Array_selector()

		localctx.(*Array_assignmentContext).arr_def = _x
	}
	{
		p.SetState(516)

		var _m = p.Match(CorundumParserASSIGN)

		localctx.(*Array_assignmentContext).op = _m
	}
	{
		p.SetState(517)

		var _x = p.All_result()

		localctx.(*Array_assignmentContext).arr_val = _x
	}

	return localctx
}

// IArray_definitionContext is an interface to support dynamic dispatch.
type IArray_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_definitionContext differentiates from other interfaces.
	IsArray_definitionContext()
}

type Array_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_definitionContext() *Array_definitionContext {
	var p = new(Array_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_array_definition
	return p
}

func (*Array_definitionContext) IsArray_definitionContext() {}

func NewArray_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_definitionContext {
	var p = new(Array_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_array_definition

	return p
}

func (s *Array_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_definitionContext) LEFT_SBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserLEFT_SBRACKET, 0)
}

func (s *Array_definitionContext) Array_definition_elements() IArray_definition_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_definition_elementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_definition_elementsContext)
}

func (s *Array_definitionContext) RIGHT_SBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserRIGHT_SBRACKET, 0)
}

func (s *Array_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterArray_definition(s)
	}
}

func (s *Array_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitArray_definition(s)
	}
}

func (p *CorundumParser) Array_definition() (localctx IArray_definitionContext) {
	this := p
	_ = this

	localctx = NewArray_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, CorundumParserRULE_array_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(519)
		p.Match(CorundumParserLEFT_SBRACKET)
	}
	{
		p.SetState(520)
		p.array_definition_elements(0)
	}
	{
		p.SetState(521)
		p.Match(CorundumParserRIGHT_SBRACKET)
	}

	return localctx
}

// IArray_definition_elementsContext is an interface to support dynamic dispatch.
type IArray_definition_elementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_definition_elementsContext differentiates from other interfaces.
	IsArray_definition_elementsContext()
}

type Array_definition_elementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_definition_elementsContext() *Array_definition_elementsContext {
	var p = new(Array_definition_elementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_array_definition_elements
	return p
}

func (*Array_definition_elementsContext) IsArray_definition_elementsContext() {}

func NewArray_definition_elementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_definition_elementsContext {
	var p = new(Array_definition_elementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_array_definition_elements

	return p
}

func (s *Array_definition_elementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_definition_elementsContext) Int_result() IInt_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Array_definition_elementsContext) Dynamic_result() IDynamic_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamic_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDynamic_resultContext)
}

func (s *Array_definition_elementsContext) Array_definition_elements() IArray_definition_elementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_definition_elementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_definition_elementsContext)
}

func (s *Array_definition_elementsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(CorundumParserCOMMA, 0)
}

func (s *Array_definition_elementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_definition_elementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_definition_elementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterArray_definition_elements(s)
	}
}

func (s *Array_definition_elementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitArray_definition_elements(s)
	}
}

func (p *CorundumParser) Array_definition_elements() (localctx IArray_definition_elementsContext) {
	return p.array_definition_elements(0)
}

func (p *CorundumParser) array_definition_elements(_p int) (localctx IArray_definition_elementsContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewArray_definition_elementsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IArray_definition_elementsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 96
	p.EnterRecursionRule(localctx, 96, CorundumParserRULE_array_definition_elements, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(524)
			p.int_result(0)
		}

	case 2:
		{
			p.SetState(525)
			p.dynamic_result(0)
		}

	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(536)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewArray_definition_elementsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_array_definition_elements)
			p.SetState(528)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(529)
				p.Match(CorundumParserCOMMA)
			}
			p.SetState(532)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(530)
					p.int_result(0)
				}

			case 2:
				{
					p.SetState(531)
					p.dynamic_result(0)
				}

			}

		}
		p.SetState(538)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
	}

	return localctx
}

// IArray_selectorContext is an interface to support dynamic dispatch.
type IArray_selectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_selectorContext differentiates from other interfaces.
	IsArray_selectorContext()
}

type Array_selectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_selectorContext() *Array_selectorContext {
	var p = new(Array_selectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_array_selector
	return p
}

func (*Array_selectorContext) IsArray_selectorContext() {}

func NewArray_selectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_selectorContext {
	var p = new(Array_selectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_array_selector

	return p
}

func (s *Array_selectorContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_selectorContext) Id_() IId_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *Array_selectorContext) LEFT_SBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserLEFT_SBRACKET, 0)
}

func (s *Array_selectorContext) RIGHT_SBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserRIGHT_SBRACKET, 0)
}

func (s *Array_selectorContext) Int_result() IInt_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Array_selectorContext) Dynamic_result() IDynamic_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamic_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDynamic_resultContext)
}

func (s *Array_selectorContext) Id_global() IId_globalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_globalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_globalContext)
}

func (s *Array_selectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_selectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_selectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterArray_selector(s)
	}
}

func (s *Array_selectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitArray_selector(s)
	}
}

func (p *CorundumParser) Array_selector() (localctx IArray_selectorContext) {
	this := p
	_ = this

	localctx = NewArray_selectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, CorundumParserRULE_array_selector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(555)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CorundumParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(539)
			p.Id_()
		}
		{
			p.SetState(540)
			p.Match(CorundumParserLEFT_SBRACKET)
		}
		p.SetState(543)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(541)
				p.int_result(0)
			}

		case 2:
			{
				p.SetState(542)
				p.dynamic_result(0)
			}

		}
		{
			p.SetState(545)
			p.Match(CorundumParserRIGHT_SBRACKET)
		}

	case CorundumParserID_GLOBAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(547)
			p.Id_global()
		}
		{
			p.SetState(548)
			p.Match(CorundumParserLEFT_SBRACKET)
		}
		p.SetState(551)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(549)
				p.int_result(0)
			}

		case 2:
			{
				p.SetState(550)
				p.dynamic_result(0)
			}

		}
		{
			p.SetState(553)
			p.Match(CorundumParserRIGHT_SBRACKET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDynamic_resultContext is an interface to support dynamic dispatch.
type IDynamic_resultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsDynamic_resultContext differentiates from other interfaces.
	IsDynamic_resultContext()
}

type Dynamic_resultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyDynamic_resultContext() *Dynamic_resultContext {
	var p = new(Dynamic_resultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_dynamic_result
	return p
}

func (*Dynamic_resultContext) IsDynamic_resultContext() {}

func NewDynamic_resultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dynamic_resultContext {
	var p = new(Dynamic_resultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_dynamic_result

	return p
}

func (s *Dynamic_resultContext) GetParser() antlr.Parser { return s.parser }

func (s *Dynamic_resultContext) GetOp() antlr.Token { return s.op }

func (s *Dynamic_resultContext) SetOp(v antlr.Token) { s.op = v }

func (s *Dynamic_resultContext) Int_result() IInt_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Dynamic_resultContext) AllDynamic_result() []IDynamic_resultContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDynamic_resultContext)(nil)).Elem())
	var tst = make([]IDynamic_resultContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDynamic_resultContext)
		}
	}

	return tst
}

func (s *Dynamic_resultContext) Dynamic_result(i int) IDynamic_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamic_resultContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDynamic_resultContext)
}

func (s *Dynamic_resultContext) MUL() antlr.TerminalNode {
	return s.GetToken(CorundumParserMUL, 0)
}

func (s *Dynamic_resultContext) DIV() antlr.TerminalNode {
	return s.GetToken(CorundumParserDIV, 0)
}

func (s *Dynamic_resultContext) MOD() antlr.TerminalNode {
	return s.GetToken(CorundumParserMOD, 0)
}

func (s *Dynamic_resultContext) Float_result() IFloat_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloat_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloat_resultContext)
}

func (s *Dynamic_resultContext) String_result() IString_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_resultContext)
}

func (s *Dynamic_resultContext) PLUS() antlr.TerminalNode {
	return s.GetToken(CorundumParserPLUS, 0)
}

func (s *Dynamic_resultContext) MINUS() antlr.TerminalNode {
	return s.GetToken(CorundumParserMINUS, 0)
}

func (s *Dynamic_resultContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserLEFT_RBRACKET, 0)
}

func (s *Dynamic_resultContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserRIGHT_RBRACKET, 0)
}

func (s *Dynamic_resultContext) Dynamic_() IDynamic_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamic_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDynamic_Context)
}

func (s *Dynamic_resultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dynamic_resultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dynamic_resultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterDynamic_result(s)
	}
}

func (s *Dynamic_resultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitDynamic_result(s)
	}
}

func (p *CorundumParser) Dynamic_result() (localctx IDynamic_resultContext) {
	return p.dynamic_result(0)
}

func (p *CorundumParser) dynamic_result(_p int) (localctx IDynamic_resultContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewDynamic_resultContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDynamic_resultContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 100
	p.EnterRecursionRule(localctx, 100, CorundumParserRULE_dynamic_result, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(583)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(558)
			p.int_result(0)
		}
		{
			p.SetState(559)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Dynamic_resultContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CorundumParserMUL)|(1<<CorundumParserDIV)|(1<<CorundumParserMOD))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Dynamic_resultContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(560)
			p.dynamic_result(13)
		}

	case 2:
		{
			p.SetState(562)
			p.float_result(0)
		}
		{
			p.SetState(563)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Dynamic_resultContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CorundumParserMUL)|(1<<CorundumParserDIV)|(1<<CorundumParserMOD))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Dynamic_resultContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(564)
			p.dynamic_result(11)
		}

	case 3:
		{
			p.SetState(566)
			p.string_result(0)
		}
		{
			p.SetState(567)

			var _m = p.Match(CorundumParserMUL)

			localctx.(*Dynamic_resultContext).op = _m
		}
		{
			p.SetState(568)
			p.dynamic_result(8)
		}

	case 4:
		{
			p.SetState(570)
			p.int_result(0)
		}
		{
			p.SetState(571)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Dynamic_resultContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == CorundumParserPLUS || _la == CorundumParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Dynamic_resultContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(572)
			p.dynamic_result(6)
		}

	case 5:
		{
			p.SetState(574)
			p.float_result(0)
		}
		{
			p.SetState(575)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Dynamic_resultContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == CorundumParserPLUS || _la == CorundumParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Dynamic_resultContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(576)
			p.dynamic_result(4)
		}

	case 6:
		{
			p.SetState(578)
			p.Match(CorundumParserLEFT_RBRACKET)
		}
		{
			p.SetState(579)
			p.dynamic_result(0)
		}
		{
			p.SetState(580)
			p.Match(CorundumParserRIGHT_RBRACKET)
		}

	case 7:
		{
			p.SetState(582)
			p.Dynamic_()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(608)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(606)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
			case 1:
				localctx = NewDynamic_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_dynamic_result)
				p.SetState(585)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(586)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Dynamic_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CorundumParserMUL)|(1<<CorundumParserDIV)|(1<<CorundumParserMOD))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Dynamic_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(587)
					p.dynamic_result(11)
				}

			case 2:
				localctx = NewDynamic_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_dynamic_result)
				p.SetState(588)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(589)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Dynamic_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == CorundumParserPLUS || _la == CorundumParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Dynamic_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(590)
					p.dynamic_result(4)
				}

			case 3:
				localctx = NewDynamic_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_dynamic_result)
				p.SetState(591)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(592)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Dynamic_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CorundumParserMUL)|(1<<CorundumParserDIV)|(1<<CorundumParserMOD))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Dynamic_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(593)
					p.int_result(0)
				}

			case 4:
				localctx = NewDynamic_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_dynamic_result)
				p.SetState(594)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(595)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Dynamic_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CorundumParserMUL)|(1<<CorundumParserDIV)|(1<<CorundumParserMOD))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Dynamic_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(596)
					p.float_result(0)
				}

			case 5:
				localctx = NewDynamic_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_dynamic_result)
				p.SetState(597)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(598)

					var _m = p.Match(CorundumParserMUL)

					localctx.(*Dynamic_resultContext).op = _m
				}
				{
					p.SetState(599)
					p.string_result(0)
				}

			case 6:
				localctx = NewDynamic_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_dynamic_result)
				p.SetState(600)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(601)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Dynamic_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == CorundumParserPLUS || _la == CorundumParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Dynamic_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(602)
					p.int_result(0)
				}

			case 7:
				localctx = NewDynamic_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_dynamic_result)
				p.SetState(603)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(604)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Dynamic_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == CorundumParserPLUS || _la == CorundumParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Dynamic_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(605)
					p.float_result(0)
				}

			}

		}
		p.SetState(610)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())
	}

	return localctx
}

// IDynamic_Context is an interface to support dynamic dispatch.
type IDynamic_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDynamic_Context differentiates from other interfaces.
	IsDynamic_Context()
}

type Dynamic_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDynamic_Context() *Dynamic_Context {
	var p = new(Dynamic_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_dynamic_
	return p
}

func (*Dynamic_Context) IsDynamic_Context() {}

func NewDynamic_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dynamic_Context {
	var p = new(Dynamic_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_dynamic_

	return p
}

func (s *Dynamic_Context) GetParser() antlr.Parser { return s.parser }

func (s *Dynamic_Context) Id_() IId_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *Dynamic_Context) Function_call_assignment() IFunction_call_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_call_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_call_assignmentContext)
}

func (s *Dynamic_Context) Array_selector() IArray_selectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_selectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_selectorContext)
}

func (s *Dynamic_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dynamic_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dynamic_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterDynamic_(s)
	}
}

func (s *Dynamic_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitDynamic_(s)
	}
}

func (p *CorundumParser) Dynamic_() (localctx IDynamic_Context) {
	this := p
	_ = this

	localctx = NewDynamic_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, CorundumParserRULE_dynamic_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(611)
			p.Id_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(612)
			p.Function_call_assignment()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(613)
			p.Array_selector()
		}

	}

	return localctx
}

// IInt_resultContext is an interface to support dynamic dispatch.
type IInt_resultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsInt_resultContext differentiates from other interfaces.
	IsInt_resultContext()
}

type Int_resultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyInt_resultContext() *Int_resultContext {
	var p = new(Int_resultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_int_result
	return p
}

func (*Int_resultContext) IsInt_resultContext() {}

func NewInt_resultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_resultContext {
	var p = new(Int_resultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_int_result

	return p
}

func (s *Int_resultContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_resultContext) GetOp() antlr.Token { return s.op }

func (s *Int_resultContext) SetOp(v antlr.Token) { s.op = v }

func (s *Int_resultContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserLEFT_RBRACKET, 0)
}

func (s *Int_resultContext) AllInt_result() []IInt_resultContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInt_resultContext)(nil)).Elem())
	var tst = make([]IInt_resultContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInt_resultContext)
		}
	}

	return tst
}

func (s *Int_resultContext) Int_result(i int) IInt_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_resultContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Int_resultContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserRIGHT_RBRACKET, 0)
}

func (s *Int_resultContext) Int_t() IInt_tContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_tContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_tContext)
}

func (s *Int_resultContext) MUL() antlr.TerminalNode {
	return s.GetToken(CorundumParserMUL, 0)
}

func (s *Int_resultContext) DIV() antlr.TerminalNode {
	return s.GetToken(CorundumParserDIV, 0)
}

func (s *Int_resultContext) MOD() antlr.TerminalNode {
	return s.GetToken(CorundumParserMOD, 0)
}

func (s *Int_resultContext) PLUS() antlr.TerminalNode {
	return s.GetToken(CorundumParserPLUS, 0)
}

func (s *Int_resultContext) MINUS() antlr.TerminalNode {
	return s.GetToken(CorundumParserMINUS, 0)
}

func (s *Int_resultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_resultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int_resultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterInt_result(s)
	}
}

func (s *Int_resultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitInt_result(s)
	}
}

func (p *CorundumParser) Int_result() (localctx IInt_resultContext) {
	return p.int_result(0)
}

func (p *CorundumParser) int_result(_p int) (localctx IInt_resultContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewInt_resultContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInt_resultContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 104
	p.EnterRecursionRule(localctx, 104, CorundumParserRULE_int_result, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(622)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CorundumParserLEFT_RBRACKET:
		{
			p.SetState(617)
			p.Match(CorundumParserLEFT_RBRACKET)
		}
		{
			p.SetState(618)
			p.int_result(0)
		}
		{
			p.SetState(619)
			p.Match(CorundumParserRIGHT_RBRACKET)
		}

	case CorundumParserINT:
		{
			p.SetState(621)
			p.Int_t()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(630)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
			case 1:
				localctx = NewInt_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_int_result)
				p.SetState(624)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(625)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Int_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CorundumParserMUL)|(1<<CorundumParserDIV)|(1<<CorundumParserMOD))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Int_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(626)
					p.int_result(5)
				}

			case 2:
				localctx = NewInt_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_int_result)
				p.SetState(627)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(628)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Int_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == CorundumParserPLUS || _la == CorundumParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Int_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(629)
					p.int_result(4)
				}

			}

		}
		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())
	}

	return localctx
}

// IFloat_resultContext is an interface to support dynamic dispatch.
type IFloat_resultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsFloat_resultContext differentiates from other interfaces.
	IsFloat_resultContext()
}

type Float_resultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyFloat_resultContext() *Float_resultContext {
	var p = new(Float_resultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_float_result
	return p
}

func (*Float_resultContext) IsFloat_resultContext() {}

func NewFloat_resultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Float_resultContext {
	var p = new(Float_resultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_float_result

	return p
}

func (s *Float_resultContext) GetParser() antlr.Parser { return s.parser }

func (s *Float_resultContext) GetOp() antlr.Token { return s.op }

func (s *Float_resultContext) SetOp(v antlr.Token) { s.op = v }

func (s *Float_resultContext) Int_result() IInt_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Float_resultContext) AllFloat_result() []IFloat_resultContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFloat_resultContext)(nil)).Elem())
	var tst = make([]IFloat_resultContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFloat_resultContext)
		}
	}

	return tst
}

func (s *Float_resultContext) Float_result(i int) IFloat_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloat_resultContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFloat_resultContext)
}

func (s *Float_resultContext) MUL() antlr.TerminalNode {
	return s.GetToken(CorundumParserMUL, 0)
}

func (s *Float_resultContext) DIV() antlr.TerminalNode {
	return s.GetToken(CorundumParserDIV, 0)
}

func (s *Float_resultContext) MOD() antlr.TerminalNode {
	return s.GetToken(CorundumParserMOD, 0)
}

func (s *Float_resultContext) PLUS() antlr.TerminalNode {
	return s.GetToken(CorundumParserPLUS, 0)
}

func (s *Float_resultContext) MINUS() antlr.TerminalNode {
	return s.GetToken(CorundumParserMINUS, 0)
}

func (s *Float_resultContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserLEFT_RBRACKET, 0)
}

func (s *Float_resultContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserRIGHT_RBRACKET, 0)
}

func (s *Float_resultContext) Float_t() IFloat_tContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloat_tContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloat_tContext)
}

func (s *Float_resultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Float_resultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Float_resultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFloat_result(s)
	}
}

func (s *Float_resultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFloat_result(s)
	}
}

func (p *CorundumParser) Float_result() (localctx IFloat_resultContext) {
	return p.float_result(0)
}

func (p *CorundumParser) float_result(_p int) (localctx IFloat_resultContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewFloat_resultContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFloat_resultContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 106
	p.EnterRecursionRule(localctx, 106, CorundumParserRULE_float_result, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(636)
			p.int_result(0)
		}
		{
			p.SetState(637)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Float_resultContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CorundumParserMUL)|(1<<CorundumParserDIV)|(1<<CorundumParserMOD))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Float_resultContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(638)
			p.float_result(7)
		}

	case 2:
		{
			p.SetState(640)
			p.int_result(0)
		}
		{
			p.SetState(641)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Float_resultContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == CorundumParserPLUS || _la == CorundumParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Float_resultContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(642)
			p.float_result(4)
		}

	case 3:
		{
			p.SetState(644)
			p.Match(CorundumParserLEFT_RBRACKET)
		}
		{
			p.SetState(645)
			p.float_result(0)
		}
		{
			p.SetState(646)
			p.Match(CorundumParserRIGHT_RBRACKET)
		}

	case 4:
		{
			p.SetState(648)
			p.Float_t()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(663)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
			case 1:
				localctx = NewFloat_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_float_result)
				p.SetState(651)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(652)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Float_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CorundumParserMUL)|(1<<CorundumParserDIV)|(1<<CorundumParserMOD))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Float_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(653)
					p.float_result(9)
				}

			case 2:
				localctx = NewFloat_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_float_result)
				p.SetState(654)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(655)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Float_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == CorundumParserPLUS || _la == CorundumParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Float_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(656)
					p.float_result(6)
				}

			case 3:
				localctx = NewFloat_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_float_result)
				p.SetState(657)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(658)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Float_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CorundumParserMUL)|(1<<CorundumParserDIV)|(1<<CorundumParserMOD))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Float_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(659)
					p.int_result(0)
				}

			case 4:
				localctx = NewFloat_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_float_result)
				p.SetState(660)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(661)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Float_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == CorundumParserPLUS || _la == CorundumParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Float_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(662)
					p.int_result(0)
				}

			}

		}
		p.SetState(667)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())
	}

	return localctx
}

// IString_resultContext is an interface to support dynamic dispatch.
type IString_resultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsString_resultContext differentiates from other interfaces.
	IsString_resultContext()
}

type String_resultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyString_resultContext() *String_resultContext {
	var p = new(String_resultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_string_result
	return p
}

func (*String_resultContext) IsString_resultContext() {}

func NewString_resultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_resultContext {
	var p = new(String_resultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_string_result

	return p
}

func (s *String_resultContext) GetParser() antlr.Parser { return s.parser }

func (s *String_resultContext) GetOp() antlr.Token { return s.op }

func (s *String_resultContext) SetOp(v antlr.Token) { s.op = v }

func (s *String_resultContext) Int_result() IInt_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *String_resultContext) AllString_result() []IString_resultContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IString_resultContext)(nil)).Elem())
	var tst = make([]IString_resultContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IString_resultContext)
		}
	}

	return tst
}

func (s *String_resultContext) String_result(i int) IString_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_resultContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IString_resultContext)
}

func (s *String_resultContext) MUL() antlr.TerminalNode {
	return s.GetToken(CorundumParserMUL, 0)
}

func (s *String_resultContext) Literal_t() ILiteral_tContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteral_tContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteral_tContext)
}

func (s *String_resultContext) PLUS() antlr.TerminalNode {
	return s.GetToken(CorundumParserPLUS, 0)
}

func (s *String_resultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_resultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_resultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterString_result(s)
	}
}

func (s *String_resultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitString_result(s)
	}
}

func (p *CorundumParser) String_result() (localctx IString_resultContext) {
	return p.string_result(0)
}

func (p *CorundumParser) string_result(_p int) (localctx IString_resultContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewString_resultContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IString_resultContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 108
	p.EnterRecursionRule(localctx, 108, CorundumParserRULE_string_result, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(674)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CorundumParserLEFT_RBRACKET, CorundumParserINT:
		{
			p.SetState(669)
			p.int_result(0)
		}
		{
			p.SetState(670)

			var _m = p.Match(CorundumParserMUL)

			localctx.(*String_resultContext).op = _m
		}
		{
			p.SetState(671)
			p.string_result(3)
		}

	case CorundumParserLITERAL:
		{
			p.SetState(673)
			p.Literal_t()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(684)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(682)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
			case 1:
				localctx = NewString_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_string_result)
				p.SetState(676)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(677)

					var _m = p.Match(CorundumParserPLUS)

					localctx.(*String_resultContext).op = _m
				}
				{
					p.SetState(678)
					p.string_result(3)
				}

			case 2:
				localctx = NewString_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_string_result)
				p.SetState(679)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(680)

					var _m = p.Match(CorundumParserMUL)

					localctx.(*String_resultContext).op = _m
				}
				{
					p.SetState(681)
					p.int_result(0)
				}

			}

		}
		p.SetState(686)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())
	}

	return localctx
}

// IComparison_listContext is an interface to support dynamic dispatch.
type IComparison_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IComparisonContext

	// GetRight returns the right rule contexts.
	GetRight() IComparison_listContext

	// SetLeft sets the left rule contexts.
	SetLeft(IComparisonContext)

	// SetRight sets the right rule contexts.
	SetRight(IComparison_listContext)

	// IsComparison_listContext differentiates from other interfaces.
	IsComparison_listContext()
}

type Comparison_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IComparisonContext
	op     antlr.Token
	right  IComparison_listContext
}

func NewEmptyComparison_listContext() *Comparison_listContext {
	var p = new(Comparison_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_comparison_list
	return p
}

func (*Comparison_listContext) IsComparison_listContext() {}

func NewComparison_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comparison_listContext {
	var p = new(Comparison_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_comparison_list

	return p
}

func (s *Comparison_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Comparison_listContext) GetOp() antlr.Token { return s.op }

func (s *Comparison_listContext) SetOp(v antlr.Token) { s.op = v }

func (s *Comparison_listContext) GetLeft() IComparisonContext { return s.left }

func (s *Comparison_listContext) GetRight() IComparison_listContext { return s.right }

func (s *Comparison_listContext) SetLeft(v IComparisonContext) { s.left = v }

func (s *Comparison_listContext) SetRight(v IComparison_listContext) { s.right = v }

func (s *Comparison_listContext) Comparison() IComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *Comparison_listContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(CorundumParserBIT_AND, 0)
}

func (s *Comparison_listContext) Comparison_list() IComparison_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparison_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparison_listContext)
}

func (s *Comparison_listContext) AND() antlr.TerminalNode {
	return s.GetToken(CorundumParserAND, 0)
}

func (s *Comparison_listContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(CorundumParserBIT_OR, 0)
}

func (s *Comparison_listContext) OR() antlr.TerminalNode {
	return s.GetToken(CorundumParserOR, 0)
}

func (s *Comparison_listContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserLEFT_RBRACKET, 0)
}

func (s *Comparison_listContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserRIGHT_RBRACKET, 0)
}

func (s *Comparison_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comparison_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comparison_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterComparison_list(s)
	}
}

func (s *Comparison_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitComparison_list(s)
	}
}

func (p *CorundumParser) Comparison_list() (localctx IComparison_listContext) {
	this := p
	_ = this

	localctx = NewComparison_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, CorundumParserRULE_comparison_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(687)

			var _x = p.Comparison()

			localctx.(*Comparison_listContext).left = _x
		}
		{
			p.SetState(688)

			var _m = p.Match(CorundumParserBIT_AND)

			localctx.(*Comparison_listContext).op = _m
		}
		{
			p.SetState(689)

			var _x = p.Comparison_list()

			localctx.(*Comparison_listContext).right = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(691)

			var _x = p.Comparison()

			localctx.(*Comparison_listContext).left = _x
		}
		{
			p.SetState(692)

			var _m = p.Match(CorundumParserAND)

			localctx.(*Comparison_listContext).op = _m
		}
		{
			p.SetState(693)

			var _x = p.Comparison_list()

			localctx.(*Comparison_listContext).right = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(695)

			var _x = p.Comparison()

			localctx.(*Comparison_listContext).left = _x
		}
		{
			p.SetState(696)

			var _m = p.Match(CorundumParserBIT_OR)

			localctx.(*Comparison_listContext).op = _m
		}
		{
			p.SetState(697)

			var _x = p.Comparison_list()

			localctx.(*Comparison_listContext).right = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(699)

			var _x = p.Comparison()

			localctx.(*Comparison_listContext).left = _x
		}
		{
			p.SetState(700)

			var _m = p.Match(CorundumParserOR)

			localctx.(*Comparison_listContext).op = _m
		}
		{
			p.SetState(701)

			var _x = p.Comparison_list()

			localctx.(*Comparison_listContext).right = _x
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(703)
			p.Match(CorundumParserLEFT_RBRACKET)
		}
		{
			p.SetState(704)
			p.Comparison_list()
		}
		{
			p.SetState(705)
			p.Match(CorundumParserRIGHT_RBRACKET)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(707)
			p.Comparison()
		}

	}

	return localctx
}

// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IComp_varContext

	// GetRight returns the right rule contexts.
	GetRight() IComp_varContext

	// SetLeft sets the left rule contexts.
	SetLeft(IComp_varContext)

	// SetRight sets the right rule contexts.
	SetRight(IComp_varContext)

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IComp_varContext
	op     antlr.Token
	right  IComp_varContext
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_comparison
	return p
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) GetOp() antlr.Token { return s.op }

func (s *ComparisonContext) SetOp(v antlr.Token) { s.op = v }

func (s *ComparisonContext) GetLeft() IComp_varContext { return s.left }

func (s *ComparisonContext) GetRight() IComp_varContext { return s.right }

func (s *ComparisonContext) SetLeft(v IComp_varContext) { s.left = v }

func (s *ComparisonContext) SetRight(v IComp_varContext) { s.right = v }

func (s *ComparisonContext) AllComp_var() []IComp_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComp_varContext)(nil)).Elem())
	var tst = make([]IComp_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComp_varContext)
		}
	}

	return tst
}

func (s *ComparisonContext) Comp_var(i int) IComp_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComp_varContext)
}

func (s *ComparisonContext) LESS() antlr.TerminalNode {
	return s.GetToken(CorundumParserLESS, 0)
}

func (s *ComparisonContext) GREATER() antlr.TerminalNode {
	return s.GetToken(CorundumParserGREATER, 0)
}

func (s *ComparisonContext) LESS_EQUAL() antlr.TerminalNode {
	return s.GetToken(CorundumParserLESS_EQUAL, 0)
}

func (s *ComparisonContext) GREATER_EQUAL() antlr.TerminalNode {
	return s.GetToken(CorundumParserGREATER_EQUAL, 0)
}

func (s *ComparisonContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(CorundumParserEQUAL, 0)
}

func (s *ComparisonContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(CorundumParserNOT_EQUAL, 0)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (p *CorundumParser) Comparison() (localctx IComparisonContext) {
	this := p
	_ = this

	localctx = NewComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, CorundumParserRULE_comparison)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(718)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(710)

			var _x = p.Comp_var()

			localctx.(*ComparisonContext).left = _x
		}
		{
			p.SetState(711)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ComparisonContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CorundumParserGREATER)|(1<<CorundumParserLESS)|(1<<CorundumParserLESS_EQUAL)|(1<<CorundumParserGREATER_EQUAL))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ComparisonContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(712)

			var _x = p.Comp_var()

			localctx.(*ComparisonContext).right = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(714)

			var _x = p.Comp_var()

			localctx.(*ComparisonContext).left = _x
		}
		{
			p.SetState(715)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ComparisonContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == CorundumParserEQUAL || _la == CorundumParserNOT_EQUAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ComparisonContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(716)

			var _x = p.Comp_var()

			localctx.(*ComparisonContext).right = _x
		}

	}

	return localctx
}

// IComp_varContext is an interface to support dynamic dispatch.
type IComp_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_varContext differentiates from other interfaces.
	IsComp_varContext()
}

type Comp_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_varContext() *Comp_varContext {
	var p = new(Comp_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_comp_var
	return p
}

func (*Comp_varContext) IsComp_varContext() {}

func NewComp_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_varContext {
	var p = new(Comp_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_comp_var

	return p
}

func (s *Comp_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_varContext) All_result() IAll_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAll_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAll_resultContext)
}

func (s *Comp_varContext) Array_selector() IArray_selectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_selectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_selectorContext)
}

func (s *Comp_varContext) Id_() IId_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *Comp_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterComp_var(s)
	}
}

func (s *Comp_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitComp_var(s)
	}
}

func (p *CorundumParser) Comp_var() (localctx IComp_varContext) {
	this := p
	_ = this

	localctx = NewComp_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, CorundumParserRULE_comp_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(723)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(720)
			p.All_result()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(721)
			p.Array_selector()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(722)
			p.Id_()
		}

	}

	return localctx
}

// ILvalueContext is an interface to support dynamic dispatch.
type ILvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLvalueContext differentiates from other interfaces.
	IsLvalueContext()
}

type LvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLvalueContext() *LvalueContext {
	var p = new(LvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_lvalue
	return p
}

func (*LvalueContext) IsLvalueContext() {}

func NewLvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LvalueContext {
	var p = new(LvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_lvalue

	return p
}

func (s *LvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *LvalueContext) Id_() IId_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *LvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterLvalue(s)
	}
}

func (s *LvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitLvalue(s)
	}
}

func (p *CorundumParser) Lvalue() (localctx ILvalueContext) {
	this := p
	_ = this

	localctx = NewLvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, CorundumParserRULE_lvalue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(725)
		p.Id_()
	}

	return localctx
}

// IRvalueContext is an interface to support dynamic dispatch.
type IRvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRvalueContext differentiates from other interfaces.
	IsRvalueContext()
}

type RvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRvalueContext() *RvalueContext {
	var p = new(RvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_rvalue
	return p
}

func (*RvalueContext) IsRvalueContext() {}

func NewRvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RvalueContext {
	var p = new(RvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_rvalue

	return p
}

func (s *RvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *RvalueContext) Lvalue() ILvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *RvalueContext) Initial_array_assignment() IInitial_array_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitial_array_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitial_array_assignmentContext)
}

func (s *RvalueContext) Array_assignment() IArray_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_assignmentContext)
}

func (s *RvalueContext) Int_result() IInt_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *RvalueContext) Float_result() IFloat_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloat_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloat_resultContext)
}

func (s *RvalueContext) String_result() IString_resultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_resultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_resultContext)
}

func (s *RvalueContext) Global_set() IGlobal_setContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobal_setContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobal_setContext)
}

func (s *RvalueContext) Global_get() IGlobal_getContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobal_getContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobal_getContext)
}

func (s *RvalueContext) Dynamic_assignment() IDynamic_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamic_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDynamic_assignmentContext)
}

func (s *RvalueContext) String_assignment() IString_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_assignmentContext)
}

func (s *RvalueContext) Float_assignment() IFloat_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloat_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloat_assignmentContext)
}

func (s *RvalueContext) Int_assignment() IInt_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_assignmentContext)
}

func (s *RvalueContext) Assignment() IAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *RvalueContext) Function_call() IFunction_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *RvalueContext) Literal_t() ILiteral_tContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteral_tContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteral_tContext)
}

func (s *RvalueContext) Bool_t() IBool_tContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBool_tContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBool_tContext)
}

func (s *RvalueContext) Float_t() IFloat_tContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloat_tContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloat_tContext)
}

func (s *RvalueContext) Int_t() IInt_tContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_tContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_tContext)
}

func (s *RvalueContext) Nil_t() INil_tContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INil_tContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INil_tContext)
}

func (s *RvalueContext) AllRvalue() []IRvalueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRvalueContext)(nil)).Elem())
	var tst = make([]IRvalueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRvalueContext)
		}
	}

	return tst
}

func (s *RvalueContext) Rvalue(i int) IRvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRvalueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRvalueContext)
}

func (s *RvalueContext) NOT() antlr.TerminalNode {
	return s.GetToken(CorundumParserNOT, 0)
}

func (s *RvalueContext) BIT_NOT() antlr.TerminalNode {
	return s.GetToken(CorundumParserBIT_NOT, 0)
}

func (s *RvalueContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserLEFT_RBRACKET, 0)
}

func (s *RvalueContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(CorundumParserRIGHT_RBRACKET, 0)
}

func (s *RvalueContext) EXP() antlr.TerminalNode {
	return s.GetToken(CorundumParserEXP, 0)
}

func (s *RvalueContext) MUL() antlr.TerminalNode {
	return s.GetToken(CorundumParserMUL, 0)
}

func (s *RvalueContext) DIV() antlr.TerminalNode {
	return s.GetToken(CorundumParserDIV, 0)
}

func (s *RvalueContext) MOD() antlr.TerminalNode {
	return s.GetToken(CorundumParserMOD, 0)
}

func (s *RvalueContext) PLUS() antlr.TerminalNode {
	return s.GetToken(CorundumParserPLUS, 0)
}

func (s *RvalueContext) MINUS() antlr.TerminalNode {
	return s.GetToken(CorundumParserMINUS, 0)
}

func (s *RvalueContext) BIT_SHL() antlr.TerminalNode {
	return s.GetToken(CorundumParserBIT_SHL, 0)
}

func (s *RvalueContext) BIT_SHR() antlr.TerminalNode {
	return s.GetToken(CorundumParserBIT_SHR, 0)
}

func (s *RvalueContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(CorundumParserBIT_AND, 0)
}

func (s *RvalueContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(CorundumParserBIT_OR, 0)
}

func (s *RvalueContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(CorundumParserBIT_XOR, 0)
}

func (s *RvalueContext) LESS() antlr.TerminalNode {
	return s.GetToken(CorundumParserLESS, 0)
}

func (s *RvalueContext) GREATER() antlr.TerminalNode {
	return s.GetToken(CorundumParserGREATER, 0)
}

func (s *RvalueContext) LESS_EQUAL() antlr.TerminalNode {
	return s.GetToken(CorundumParserLESS_EQUAL, 0)
}

func (s *RvalueContext) GREATER_EQUAL() antlr.TerminalNode {
	return s.GetToken(CorundumParserGREATER_EQUAL, 0)
}

func (s *RvalueContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(CorundumParserEQUAL, 0)
}

func (s *RvalueContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(CorundumParserNOT_EQUAL, 0)
}

func (s *RvalueContext) OR() antlr.TerminalNode {
	return s.GetToken(CorundumParserOR, 0)
}

func (s *RvalueContext) AND() antlr.TerminalNode {
	return s.GetToken(CorundumParserAND, 0)
}

func (s *RvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterRvalue(s)
	}
}

func (s *RvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitRvalue(s)
	}
}

func (p *CorundumParser) Rvalue() (localctx IRvalueContext) {
	return p.rvalue(0)
}

func (p *CorundumParser) rvalue(_p int) (localctx IRvalueContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRvalueContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRvalueContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 118
	p.EnterRecursionRule(localctx, 118, CorundumParserRULE_rvalue, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(728)
			p.Lvalue()
		}

	case 2:
		{
			p.SetState(729)
			p.Initial_array_assignment()
		}

	case 3:
		{
			p.SetState(730)
			p.Array_assignment()
		}

	case 4:
		{
			p.SetState(731)
			p.int_result(0)
		}

	case 5:
		{
			p.SetState(732)
			p.float_result(0)
		}

	case 6:
		{
			p.SetState(733)
			p.string_result(0)
		}

	case 7:
		{
			p.SetState(734)
			p.Global_set()
		}

	case 8:
		{
			p.SetState(735)
			p.Global_get()
		}

	case 9:
		{
			p.SetState(736)
			p.Dynamic_assignment()
		}

	case 10:
		{
			p.SetState(737)
			p.String_assignment()
		}

	case 11:
		{
			p.SetState(738)
			p.Float_assignment()
		}

	case 12:
		{
			p.SetState(739)
			p.Int_assignment()
		}

	case 13:
		{
			p.SetState(740)
			p.Assignment()
		}

	case 14:
		{
			p.SetState(741)
			p.Function_call()
		}

	case 15:
		{
			p.SetState(742)
			p.Literal_t()
		}

	case 16:
		{
			p.SetState(743)
			p.Bool_t()
		}

	case 17:
		{
			p.SetState(744)
			p.Float_t()
		}

	case 18:
		{
			p.SetState(745)
			p.Int_t()
		}

	case 19:
		{
			p.SetState(746)
			p.Nil_t()
		}

	case 20:
		{
			p.SetState(747)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CorundumParserBIT_NOT || _la == CorundumParserNOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(748)
			p.rvalue(10)
		}

	case 21:
		{
			p.SetState(749)
			p.Match(CorundumParserLEFT_RBRACKET)
		}
		{
			p.SetState(750)
			p.rvalue(0)
		}
		{
			p.SetState(751)
			p.Match(CorundumParserRIGHT_RBRACKET)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(784)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(782)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
			case 1:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_rvalue)
				p.SetState(755)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(756)
					p.Match(CorundumParserEXP)
				}
				{
					p.SetState(757)
					p.rvalue(12)
				}

			case 2:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_rvalue)
				p.SetState(758)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(759)
					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CorundumParserMUL)|(1<<CorundumParserDIV)|(1<<CorundumParserMOD))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(760)
					p.rvalue(10)
				}

			case 3:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_rvalue)
				p.SetState(761)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(762)
					_la = p.GetTokenStream().LA(1)

					if !(_la == CorundumParserPLUS || _la == CorundumParserMINUS) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(763)
					p.rvalue(9)
				}

			case 4:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_rvalue)
				p.SetState(764)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(765)
					_la = p.GetTokenStream().LA(1)

					if !(_la == CorundumParserBIT_SHL || _la == CorundumParserBIT_SHR) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(766)
					p.rvalue(8)
				}

			case 5:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_rvalue)
				p.SetState(767)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(768)
					p.Match(CorundumParserBIT_AND)
				}
				{
					p.SetState(769)
					p.rvalue(7)
				}

			case 6:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_rvalue)
				p.SetState(770)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(771)
					_la = p.GetTokenStream().LA(1)

					if !(_la == CorundumParserBIT_OR || _la == CorundumParserBIT_XOR) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(772)
					p.rvalue(6)
				}

			case 7:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_rvalue)
				p.SetState(773)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(774)
					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CorundumParserGREATER)|(1<<CorundumParserLESS)|(1<<CorundumParserLESS_EQUAL)|(1<<CorundumParserGREATER_EQUAL))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(775)
					p.rvalue(5)
				}

			case 8:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_rvalue)
				p.SetState(776)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(777)
					_la = p.GetTokenStream().LA(1)

					if !(_la == CorundumParserEQUAL || _la == CorundumParserNOT_EQUAL) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(778)
					p.rvalue(4)
				}

			case 9:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_rvalue)
				p.SetState(779)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(780)
					_la = p.GetTokenStream().LA(1)

					if !(_la == CorundumParserAND || _la == CorundumParserOR) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(781)
					p.rvalue(3)
				}

			}

		}
		p.SetState(786)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
	}

	return localctx
}

// IBreak_expressionContext is an interface to support dynamic dispatch.
type IBreak_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_expressionContext differentiates from other interfaces.
	IsBreak_expressionContext()
}

type Break_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_expressionContext() *Break_expressionContext {
	var p = new(Break_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_break_expression
	return p
}

func (*Break_expressionContext) IsBreak_expressionContext() {}

func NewBreak_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_expressionContext {
	var p = new(Break_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_break_expression

	return p
}

func (s *Break_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_expressionContext) BREAK() antlr.TerminalNode {
	return s.GetToken(CorundumParserBREAK, 0)
}

func (s *Break_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterBreak_expression(s)
	}
}

func (s *Break_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitBreak_expression(s)
	}
}

func (p *CorundumParser) Break_expression() (localctx IBreak_expressionContext) {
	this := p
	_ = this

	localctx = NewBreak_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, CorundumParserRULE_break_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(787)
		p.Match(CorundumParserBREAK)
	}

	return localctx
}

// ILiteral_tContext is an interface to support dynamic dispatch.
type ILiteral_tContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteral_tContext differentiates from other interfaces.
	IsLiteral_tContext()
}

type Literal_tContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteral_tContext() *Literal_tContext {
	var p = new(Literal_tContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_literal_t
	return p
}

func (*Literal_tContext) IsLiteral_tContext() {}

func NewLiteral_tContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Literal_tContext {
	var p = new(Literal_tContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_literal_t

	return p
}

func (s *Literal_tContext) GetParser() antlr.Parser { return s.parser }

func (s *Literal_tContext) LITERAL() antlr.TerminalNode {
	return s.GetToken(CorundumParserLITERAL, 0)
}

func (s *Literal_tContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Literal_tContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Literal_tContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterLiteral_t(s)
	}
}

func (s *Literal_tContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitLiteral_t(s)
	}
}

func (p *CorundumParser) Literal_t() (localctx ILiteral_tContext) {
	this := p
	_ = this

	localctx = NewLiteral_tContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, CorundumParserRULE_literal_t)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(789)
		p.Match(CorundumParserLITERAL)
	}

	return localctx
}

// IFloat_tContext is an interface to support dynamic dispatch.
type IFloat_tContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFloat_tContext differentiates from other interfaces.
	IsFloat_tContext()
}

type Float_tContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloat_tContext() *Float_tContext {
	var p = new(Float_tContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_float_t
	return p
}

func (*Float_tContext) IsFloat_tContext() {}

func NewFloat_tContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Float_tContext {
	var p = new(Float_tContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_float_t

	return p
}

func (s *Float_tContext) GetParser() antlr.Parser { return s.parser }

func (s *Float_tContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(CorundumParserFLOAT, 0)
}

func (s *Float_tContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Float_tContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Float_tContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterFloat_t(s)
	}
}

func (s *Float_tContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitFloat_t(s)
	}
}

func (p *CorundumParser) Float_t() (localctx IFloat_tContext) {
	this := p
	_ = this

	localctx = NewFloat_tContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, CorundumParserRULE_float_t)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(791)
		p.Match(CorundumParserFLOAT)
	}

	return localctx
}

// IInt_tContext is an interface to support dynamic dispatch.
type IInt_tContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInt_tContext differentiates from other interfaces.
	IsInt_tContext()
}

type Int_tContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInt_tContext() *Int_tContext {
	var p = new(Int_tContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_int_t
	return p
}

func (*Int_tContext) IsInt_tContext() {}

func NewInt_tContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_tContext {
	var p = new(Int_tContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_int_t

	return p
}

func (s *Int_tContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_tContext) INT() antlr.TerminalNode {
	return s.GetToken(CorundumParserINT, 0)
}

func (s *Int_tContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_tContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int_tContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterInt_t(s)
	}
}

func (s *Int_tContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitInt_t(s)
	}
}

func (p *CorundumParser) Int_t() (localctx IInt_tContext) {
	this := p
	_ = this

	localctx = NewInt_tContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, CorundumParserRULE_int_t)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(793)
		p.Match(CorundumParserINT)
	}

	return localctx
}

// IBool_tContext is an interface to support dynamic dispatch.
type IBool_tContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBool_tContext differentiates from other interfaces.
	IsBool_tContext()
}

type Bool_tContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_tContext() *Bool_tContext {
	var p = new(Bool_tContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_bool_t
	return p
}

func (*Bool_tContext) IsBool_tContext() {}

func NewBool_tContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_tContext {
	var p = new(Bool_tContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_bool_t

	return p
}

func (s *Bool_tContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_tContext) TRUE() antlr.TerminalNode {
	return s.GetToken(CorundumParserTRUE, 0)
}

func (s *Bool_tContext) FALSE() antlr.TerminalNode {
	return s.GetToken(CorundumParserFALSE, 0)
}

func (s *Bool_tContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_tContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_tContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterBool_t(s)
	}
}

func (s *Bool_tContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitBool_t(s)
	}
}

func (p *CorundumParser) Bool_t() (localctx IBool_tContext) {
	this := p
	_ = this

	localctx = NewBool_tContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, CorundumParserRULE_bool_t)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(795)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CorundumParserTRUE || _la == CorundumParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INil_tContext is an interface to support dynamic dispatch.
type INil_tContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNil_tContext differentiates from other interfaces.
	IsNil_tContext()
}

type Nil_tContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNil_tContext() *Nil_tContext {
	var p = new(Nil_tContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_nil_t
	return p
}

func (*Nil_tContext) IsNil_tContext() {}

func NewNil_tContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nil_tContext {
	var p = new(Nil_tContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_nil_t

	return p
}

func (s *Nil_tContext) GetParser() antlr.Parser { return s.parser }

func (s *Nil_tContext) NIL() antlr.TerminalNode {
	return s.GetToken(CorundumParserNIL, 0)
}

func (s *Nil_tContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nil_tContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nil_tContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterNil_t(s)
	}
}

func (s *Nil_tContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitNil_t(s)
	}
}

func (p *CorundumParser) Nil_t() (localctx INil_tContext) {
	this := p
	_ = this

	localctx = NewNil_tContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, CorundumParserRULE_nil_t)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(797)
		p.Match(CorundumParserNIL)
	}

	return localctx
}

// IId_Context is an interface to support dynamic dispatch.
type IId_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsId_Context differentiates from other interfaces.
	IsId_Context()
}

type Id_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_Context() *Id_Context {
	var p = new(Id_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_id_
	return p
}

func (*Id_Context) IsId_Context() {}

func NewId_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_Context {
	var p = new(Id_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_id_

	return p
}

func (s *Id_Context) GetParser() antlr.Parser { return s.parser }

func (s *Id_Context) ID() antlr.TerminalNode {
	return s.GetToken(CorundumParserID, 0)
}

func (s *Id_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterId_(s)
	}
}

func (s *Id_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitId_(s)
	}
}

func (p *CorundumParser) Id_() (localctx IId_Context) {
	this := p
	_ = this

	localctx = NewId_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, CorundumParserRULE_id_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(799)
		p.Match(CorundumParserID)
	}

	return localctx
}

// IId_globalContext is an interface to support dynamic dispatch.
type IId_globalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsId_globalContext differentiates from other interfaces.
	IsId_globalContext()
}

type Id_globalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_globalContext() *Id_globalContext {
	var p = new(Id_globalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_id_global
	return p
}

func (*Id_globalContext) IsId_globalContext() {}

func NewId_globalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_globalContext {
	var p = new(Id_globalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_id_global

	return p
}

func (s *Id_globalContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_globalContext) ID_GLOBAL() antlr.TerminalNode {
	return s.GetToken(CorundumParserID_GLOBAL, 0)
}

func (s *Id_globalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_globalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_globalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterId_global(s)
	}
}

func (s *Id_globalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitId_global(s)
	}
}

func (p *CorundumParser) Id_global() (localctx IId_globalContext) {
	this := p
	_ = this

	localctx = NewId_globalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, CorundumParserRULE_id_global)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(801)
		p.Match(CorundumParserID_GLOBAL)
	}

	return localctx
}

// IId_functionContext is an interface to support dynamic dispatch.
type IId_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsId_functionContext differentiates from other interfaces.
	IsId_functionContext()
}

type Id_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_functionContext() *Id_functionContext {
	var p = new(Id_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_id_function
	return p
}

func (*Id_functionContext) IsId_functionContext() {}

func NewId_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_functionContext {
	var p = new(Id_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_id_function

	return p
}

func (s *Id_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_functionContext) ID_FUNCTION() antlr.TerminalNode {
	return s.GetToken(CorundumParserID_FUNCTION, 0)
}

func (s *Id_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterId_function(s)
	}
}

func (s *Id_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitId_function(s)
	}
}

func (p *CorundumParser) Id_function() (localctx IId_functionContext) {
	this := p
	_ = this

	localctx = NewId_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, CorundumParserRULE_id_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(803)
		p.Match(CorundumParserID_FUNCTION)
	}

	return localctx
}

// ITerminatorContext is an interface to support dynamic dispatch.
type ITerminatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTerminatorContext differentiates from other interfaces.
	IsTerminatorContext()
}

type TerminatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminatorContext() *TerminatorContext {
	var p = new(TerminatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_terminator
	return p
}

func (*TerminatorContext) IsTerminatorContext() {}

func NewTerminatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TerminatorContext {
	var p = new(TerminatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_terminator

	return p
}

func (s *TerminatorContext) GetParser() antlr.Parser { return s.parser }

func (s *TerminatorContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(CorundumParserSEMICOLON, 0)
}

func (s *TerminatorContext) Crlf() ICrlfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrlfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *TerminatorContext) Terminator() ITerminatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminatorContext)
}

func (s *TerminatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TerminatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TerminatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterTerminator(s)
	}
}

func (s *TerminatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitTerminator(s)
	}
}

func (p *CorundumParser) Terminator() (localctx ITerminatorContext) {
	return p.terminator(0)
}

func (p *CorundumParser) terminator(_p int) (localctx ITerminatorContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTerminatorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITerminatorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 138
	p.EnterRecursionRule(localctx, 138, CorundumParserRULE_terminator, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(808)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CorundumParserSEMICOLON:
		{
			p.SetState(806)
			p.Match(CorundumParserSEMICOLON)
		}

	case CorundumParserCRLF:
		{
			p.SetState(807)
			p.Crlf()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(816)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(814)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
			case 1:
				localctx = NewTerminatorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_terminator)
				p.SetState(810)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(811)
					p.Match(CorundumParserSEMICOLON)
				}

			case 2:
				localctx = NewTerminatorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CorundumParserRULE_terminator)
				p.SetState(812)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(813)
					p.Crlf()
				}

			}

		}
		p.SetState(818)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())
	}

	return localctx
}

// IElse_tokenContext is an interface to support dynamic dispatch.
type IElse_tokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElse_tokenContext differentiates from other interfaces.
	IsElse_tokenContext()
}

type Else_tokenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_tokenContext() *Else_tokenContext {
	var p = new(Else_tokenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_else_token
	return p
}

func (*Else_tokenContext) IsElse_tokenContext() {}

func NewElse_tokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_tokenContext {
	var p = new(Else_tokenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_else_token

	return p
}

func (s *Else_tokenContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_tokenContext) ELSE() antlr.TerminalNode {
	return s.GetToken(CorundumParserELSE, 0)
}

func (s *Else_tokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_tokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_tokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterElse_token(s)
	}
}

func (s *Else_tokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitElse_token(s)
	}
}

func (p *CorundumParser) Else_token() (localctx IElse_tokenContext) {
	this := p
	_ = this

	localctx = NewElse_tokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, CorundumParserRULE_else_token)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(819)
		p.Match(CorundumParserELSE)
	}

	return localctx
}

// ICrlfContext is an interface to support dynamic dispatch.
type ICrlfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCrlfContext differentiates from other interfaces.
	IsCrlfContext()
}

type CrlfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrlfContext() *CrlfContext {
	var p = new(CrlfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CorundumParserRULE_crlf
	return p
}

func (*CrlfContext) IsCrlfContext() {}

func NewCrlfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrlfContext {
	var p = new(CrlfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CorundumParserRULE_crlf

	return p
}

func (s *CrlfContext) GetParser() antlr.Parser { return s.parser }

func (s *CrlfContext) CRLF() antlr.TerminalNode {
	return s.GetToken(CorundumParserCRLF, 0)
}

func (s *CrlfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrlfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrlfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.EnterCrlf(s)
	}
}

func (s *CrlfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CorundumListener); ok {
		listenerT.ExitCrlf(s)
	}
}

func (p *CorundumParser) Crlf() (localctx ICrlfContext) {
	this := p
	_ = this

	localctx = NewCrlfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, CorundumParserRULE_crlf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(821)
		p.Match(CorundumParserCRLF)
	}

	return localctx
}

func (p *CorundumParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 1:
		var t *Expression_listContext = nil
		if localctx != nil {
			t = localctx.(*Expression_listContext)
		}
		return p.Expression_list_Sempred(t, predIndex)

	case 15:
		var t *Function_definition_params_listContext = nil
		if localctx != nil {
			t = localctx.(*Function_definition_params_listContext)
		}
		return p.Function_definition_params_list_Sempred(t, predIndex)

	case 20:
		var t *Function_call_paramsContext = nil
		if localctx != nil {
			t = localctx.(*Function_call_paramsContext)
		}
		return p.Function_call_params_Sempred(t, predIndex)

	case 34:
		var t *For_init_listContext = nil
		if localctx != nil {
			t = localctx.(*For_init_listContext)
		}
		return p.For_init_list_Sempred(t, predIndex)

	case 37:
		var t *For_loop_listContext = nil
		if localctx != nil {
			t = localctx.(*For_loop_listContext)
		}
		return p.For_loop_list_Sempred(t, predIndex)

	case 39:
		var t *Statement_expression_listContext = nil
		if localctx != nil {
			t = localctx.(*Statement_expression_listContext)
		}
		return p.Statement_expression_list_Sempred(t, predIndex)

	case 48:
		var t *Array_definition_elementsContext = nil
		if localctx != nil {
			t = localctx.(*Array_definition_elementsContext)
		}
		return p.Array_definition_elements_Sempred(t, predIndex)

	case 50:
		var t *Dynamic_resultContext = nil
		if localctx != nil {
			t = localctx.(*Dynamic_resultContext)
		}
		return p.Dynamic_result_Sempred(t, predIndex)

	case 52:
		var t *Int_resultContext = nil
		if localctx != nil {
			t = localctx.(*Int_resultContext)
		}
		return p.Int_result_Sempred(t, predIndex)

	case 53:
		var t *Float_resultContext = nil
		if localctx != nil {
			t = localctx.(*Float_resultContext)
		}
		return p.Float_result_Sempred(t, predIndex)

	case 54:
		var t *String_resultContext = nil
		if localctx != nil {
			t = localctx.(*String_resultContext)
		}
		return p.String_result_Sempred(t, predIndex)

	case 59:
		var t *RvalueContext = nil
		if localctx != nil {
			t = localctx.(*RvalueContext)
		}
		return p.Rvalue_Sempred(t, predIndex)

	case 69:
		var t *TerminatorContext = nil
		if localctx != nil {
			t = localctx.(*TerminatorContext)
		}
		return p.Terminator_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *CorundumParser) Expression_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CorundumParser) Function_definition_params_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CorundumParser) Function_call_params_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CorundumParser) For_init_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CorundumParser) For_loop_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CorundumParser) Statement_expression_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CorundumParser) Array_definition_elements_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CorundumParser) Dynamic_result_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CorundumParser) Int_result_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CorundumParser) Float_result_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 18:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CorundumParser) String_result_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 22:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CorundumParser) Rvalue_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 24:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 25:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 26:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 27:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 28:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 29:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 30:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 31:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 32:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CorundumParser) Terminator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 33:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 34:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
