// Code generated from SHARCParser.g4 by ANTLR 4.9.3. DO NOT EDIT.

package sharc // SHARCParser
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 428, 1634,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 3, 2, 3, 2, 3, 2, 6, 2, 318, 10, 2, 13, 2, 14,
	2, 319, 3, 3, 3, 3, 3, 3, 6, 3, 325, 10, 3, 13, 3, 14, 3, 326, 3, 3, 5,
	3, 330, 10, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 5, 4, 337, 10, 4, 3, 5, 3,
	5, 3, 5, 3, 5, 3, 6, 3, 6, 3, 6, 3, 6, 3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 5,
	8, 352, 10, 8, 3, 8, 3, 8, 3, 8, 5, 8, 357, 10, 8, 3, 8, 3, 8, 3, 8, 5,
	8, 362, 10, 8, 5, 8, 364, 10, 8, 3, 9, 3, 9, 3, 9, 5, 9, 369, 10, 9, 3,
	10, 3, 10, 3, 10, 3, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 13, 3, 13, 3, 14,
	3, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 390, 10,
	15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16, 398, 10, 16, 3, 17,
	3, 17, 3, 17, 7, 17, 403, 10, 17, 12, 17, 14, 17, 406, 11, 17, 3, 18, 3,
	18, 3, 18, 3, 18, 7, 18, 412, 10, 18, 12, 18, 14, 18, 415, 11, 18, 3, 19,
	3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 422, 10, 19, 3, 20, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 20, 5, 20, 430, 10, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3, 22,
	3, 22, 3, 22, 7, 22, 439, 10, 22, 12, 22, 14, 22, 442, 11, 22, 3, 22, 5,
	22, 445, 10, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 452, 10, 23,
	3, 24, 3, 24, 5, 24, 456, 10, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3,
	25, 5, 25, 464, 10, 25, 3, 26, 3, 26, 3, 27, 3, 27, 3, 27, 7, 27, 471,
	10, 27, 12, 27, 14, 27, 474, 11, 27, 3, 28, 5, 28, 477, 10, 28, 3, 28,
	3, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29, 486, 10, 29, 3, 30, 3,
	30, 3, 30, 5, 30, 491, 10, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 5, 31,
	498, 10, 31, 3, 32, 3, 32, 3, 32, 3, 32, 3, 33, 3, 33, 5, 33, 506, 10,
	33, 3, 34, 3, 34, 3, 34, 5, 34, 511, 10, 34, 3, 34, 3, 34, 3, 34, 3, 34,
	3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 524, 10, 34, 3,
	35, 3, 35, 3, 35, 3, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36,
	3, 36, 5, 36, 538, 10, 36, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3,
	37, 3, 37, 5, 37, 548, 10, 37, 3, 38, 3, 38, 5, 38, 552, 10, 38, 3, 38,
	3, 38, 3, 38, 3, 39, 3, 39, 5, 39, 559, 10, 39, 3, 39, 3, 39, 3, 39, 3,
	40, 3, 40, 3, 40, 3, 40, 5, 40, 568, 10, 40, 3, 41, 3, 41, 3, 41, 3, 41,
	5, 41, 574, 10, 41, 3, 42, 3, 42, 5, 42, 578, 10, 42, 3, 42, 3, 42, 3,
	42, 3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 589, 10, 44, 3, 45,
	3, 45, 3, 46, 3, 46, 3, 46, 3, 46, 3, 47, 3, 47, 5, 47, 599, 10, 47, 3,
	47, 3, 47, 3, 47, 3, 48, 3, 48, 3, 48, 3, 48, 5, 48, 608, 10, 48, 3, 49,
	3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3,
	49, 3, 49, 5, 49, 623, 10, 49, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50,
	3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 52, 3, 52, 3, 52, 3, 52, 3,
	52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 54, 3, 54, 3, 54,
	3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 56, 3,
	56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57,
	3, 58, 3, 58, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 5, 59, 680, 10, 59, 3,
	60, 3, 60, 3, 60, 3, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3, 62, 3, 63, 3, 63,
	3, 63, 3, 64, 3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 3, 66, 3, 66, 3, 66, 3,
	67, 3, 67, 3, 67, 3, 68, 3, 68, 3, 68, 3, 69, 3, 69, 3, 69, 3, 70, 3, 70,
	3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 5, 70, 723,
	10, 70, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71,
	3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3,
	71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71,
	3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3,
	71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71,
	3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3,
	71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71,
	3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3,
	71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 5, 71, 816,
	10, 71, 3, 71, 3, 71, 3, 71, 3, 71, 5, 71, 822, 10, 71, 5, 71, 824, 10,
	71, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72,
	3, 72, 5, 72, 837, 10, 72, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3,
	73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73,
	3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3,
	73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73,
	3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 5, 73, 886,
	10, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73,
	3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3,
	73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73,
	3, 73, 5, 73, 919, 10, 73, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3,
	74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74,
	937, 10, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 946,
	10, 74, 5, 74, 948, 10, 74, 3, 75, 3, 75, 3, 75, 3, 75, 5, 75, 954, 10,
	75, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76, 964,
	10, 76, 3, 76, 3, 76, 3, 76, 5, 76, 969, 10, 76, 3, 76, 5, 76, 972, 10,
	76, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 5, 77, 982,
	10, 77, 3, 77, 3, 77, 3, 77, 5, 77, 987, 10, 77, 5, 77, 989, 10, 77, 3,
	78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 5, 78, 999, 10, 78,
	3, 78, 3, 78, 3, 78, 5, 78, 1004, 10, 78, 5, 78, 1006, 10, 78, 3, 79, 3,
	79, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80,
	3, 80, 3, 80, 3, 80, 3, 80, 5, 80, 1024, 10, 80, 3, 81, 3, 81, 3, 81, 3,
	81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81,
	3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3,
	81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81,
	3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3,
	81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 5, 81, 1077, 10, 81, 3, 81, 3, 81,
	3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 5, 81, 1086, 10, 81, 3, 81, 3, 81, 3,
	81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 5, 81,
	1100, 10, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 5, 81, 1108, 10,
	81, 3, 82, 3, 82, 3, 82, 3, 82, 5, 82, 1114, 10, 82, 3, 83, 3, 83, 5, 83,
	1118, 10, 83, 3, 84, 3, 84, 3, 84, 3, 84, 3, 85, 3, 85, 3, 86, 3, 86, 5,
	86, 1128, 10, 86, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87,
	3, 87, 3, 87, 3, 87, 3, 87, 3, 88, 3, 88, 3, 88, 6, 88, 1145, 10, 88, 13,
	88, 14, 88, 1146, 3, 88, 3, 88, 3, 88, 6, 88, 1152, 10, 88, 13, 88, 14,
	88, 1153, 5, 88, 1156, 10, 88, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89,
	3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1169, 10, 89, 3, 90, 3, 90, 3,
	90, 3, 90, 3, 91, 3, 91, 5, 91, 1177, 10, 91, 3, 92, 3, 92, 3, 92, 3, 92,
	3, 92, 3, 92, 3, 92, 3, 93, 3, 93, 3, 93, 3, 93, 5, 93, 1190, 10, 93, 3,
	94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 5, 94, 1201,
	10, 94, 3, 94, 3, 94, 3, 95, 3, 95, 5, 95, 1207, 10, 95, 3, 96, 3, 96,
	3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 97, 3, 97, 5, 97, 1220,
	10, 97, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 3, 99, 3, 99, 3, 99, 5, 99,
	1230, 10, 99, 3, 100, 3, 100, 3, 100, 5, 100, 1235, 10, 100, 3, 101, 3,
	101, 3, 101, 5, 101, 1240, 10, 101, 3, 101, 3, 101, 5, 101, 1244, 10, 101,
	3, 102, 3, 102, 3, 102, 5, 102, 1249, 10, 102, 3, 102, 3, 102, 5, 102,
	1253, 10, 102, 3, 103, 3, 103, 5, 103, 1257, 10, 103, 3, 103, 3, 103, 5,
	103, 1261, 10, 103, 3, 104, 3, 104, 5, 104, 1265, 10, 104, 3, 104, 3, 104,
	5, 104, 1269, 10, 104, 3, 105, 3, 105, 5, 105, 1273, 10, 105, 3, 106, 3,
	106, 5, 106, 1277, 10, 106, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3,
	107, 3, 108, 3, 108, 3, 109, 3, 109, 3, 110, 3, 110, 3, 110, 3, 110, 5,
	110, 1293, 10, 110, 3, 110, 3, 110, 3, 111, 3, 111, 3, 111, 5, 111, 1300,
	10, 111, 3, 112, 3, 112, 3, 112, 3, 112, 3, 113, 3, 113, 3, 114, 3, 114,
	3, 114, 5, 114, 1311, 10, 114, 3, 114, 3, 114, 3, 115, 3, 115, 3, 115,
	5, 115, 1318, 10, 115, 3, 116, 3, 116, 3, 116, 3, 116, 5, 116, 1324, 10,
	116, 3, 117, 3, 117, 5, 117, 1328, 10, 117, 3, 117, 3, 117, 3, 117, 3,
	118, 3, 118, 5, 118, 1335, 10, 118, 3, 118, 3, 118, 3, 118, 3, 119, 3,
	119, 3, 119, 3, 119, 5, 119, 1344, 10, 119, 3, 120, 3, 120, 3, 120, 3,
	120, 5, 120, 1350, 10, 120, 3, 121, 3, 121, 5, 121, 1354, 10, 121, 3, 121,
	3, 121, 3, 121, 3, 122, 3, 122, 3, 122, 3, 122, 3, 123, 3, 123, 3, 123,
	3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123,
	3, 123, 3, 123, 3, 123, 5, 123, 1378, 10, 123, 3, 124, 3, 124, 3, 124,
	3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 5, 124, 1388, 10, 124, 3, 124,
	3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124,
	3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 7, 124, 1407, 10,
	124, 12, 124, 14, 124, 1410, 11, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3,
	124, 3, 124, 3, 124, 3, 124, 5, 124, 1420, 10, 124, 3, 124, 5, 124, 1423,
	10, 124, 3, 125, 3, 125, 3, 125, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126,
	3, 126, 3, 126, 7, 126, 1435, 10, 126, 12, 126, 14, 126, 1438, 11, 126,
	3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126,
	7, 126, 1449, 10, 126, 12, 126, 14, 126, 1452, 11, 126, 3, 126, 3, 126,
	3, 126, 3, 126, 7, 126, 1458, 10, 126, 12, 126, 14, 126, 1461, 11, 126,
	3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126,
	3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126,
	3, 126, 3, 126, 3, 126, 5, 126, 1484, 10, 126, 3, 126, 3, 126, 3, 126,
	3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 5, 126, 1494, 10, 126, 3, 127,
	3, 127, 3, 128, 3, 128, 3, 129, 3, 129, 3, 130, 3, 130, 3, 131, 3, 131,
	3, 132, 3, 132, 3, 133, 3, 133, 3, 134, 3, 134, 3, 135, 3, 135, 3, 136,
	3, 136, 5, 136, 1516, 10, 136, 3, 137, 3, 137, 5, 137, 1520, 10, 137, 3,
	138, 3, 138, 3, 138, 3, 138, 5, 138, 1526, 10, 138, 3, 139, 3, 139, 5,
	139, 1530, 10, 139, 3, 140, 3, 140, 3, 140, 3, 140, 3, 140, 3, 140, 3,
	140, 3, 140, 3, 140, 3, 140, 3, 140, 3, 140, 3, 140, 3, 140, 3, 140, 3,
	140, 5, 140, 1548, 10, 140, 3, 141, 3, 141, 3, 142, 3, 142, 3, 142, 3,
	142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3,
	142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3,
	142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3,
	142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3,
	142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 5, 142, 1598, 10,
	142, 3, 143, 3, 143, 3, 144, 3, 144, 3, 144, 3, 144, 3, 145, 3, 145, 3,
	146, 3, 146, 3, 146, 3, 146, 3, 147, 3, 147, 3, 148, 3, 148, 3, 149, 3,
	149, 3, 150, 3, 150, 3, 151, 3, 151, 3, 152, 3, 152, 3, 153, 3, 153, 3,
	154, 3, 154, 3, 155, 3, 155, 3, 156, 3, 156, 3, 157, 3, 157, 3, 157, 2,
	2, 158, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
	36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70,
	72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
	106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
	136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164,
	166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194,
	196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,
	226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254,
	256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284,
	286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 2,
	34, 4, 2, 279, 279, 400, 400, 4, 2, 103, 103, 401, 402, 3, 2, 397, 399,
	4, 2, 379, 383, 385, 386, 3, 2, 379, 380, 3, 2, 255, 256, 4, 2, 89, 89,
	208, 208, 7, 2, 92, 92, 328, 328, 354, 354, 358, 358, 378, 378, 4, 2, 284,
	284, 294, 294, 5, 2, 221, 221, 277, 277, 344, 344, 3, 2, 59, 74, 3, 2,
	192, 207, 3, 2, 299, 314, 3, 2, 128, 143, 8, 2, 57, 57, 187, 188, 190,
	190, 246, 247, 342, 342, 370, 371, 3, 2, 166, 173, 3, 2, 225, 232, 3, 2,
	174, 181, 3, 2, 233, 240, 4, 2, 329, 330, 361, 362, 6, 2, 336, 338, 345,
	347, 366, 368, 372, 374, 4, 2, 299, 299, 301, 302, 3, 2, 303, 306, 3, 2,
	307, 310, 3, 2, 311, 314, 4, 2, 128, 128, 130, 131, 3, 2, 132, 135, 3,
	2, 136, 139, 3, 2, 140, 143, 4, 2, 5, 5, 427, 427, 5, 2, 250, 250, 252,
	252, 254, 254, 5, 2, 249, 249, 251, 251, 253, 253, 2, 1793, 2, 317, 3,
	2, 2, 2, 4, 329, 3, 2, 2, 2, 6, 336, 3, 2, 2, 2, 8, 338, 3, 2, 2, 2, 10,
	342, 3, 2, 2, 2, 12, 346, 3, 2, 2, 2, 14, 363, 3, 2, 2, 2, 16, 365, 3,
	2, 2, 2, 18, 370, 3, 2, 2, 2, 20, 373, 3, 2, 2, 2, 22, 376, 3, 2, 2, 2,
	24, 378, 3, 2, 2, 2, 26, 380, 3, 2, 2, 2, 28, 389, 3, 2, 2, 2, 30, 391,
	3, 2, 2, 2, 32, 399, 3, 2, 2, 2, 34, 407, 3, 2, 2, 2, 36, 416, 3, 2, 2,
	2, 38, 423, 3, 2, 2, 2, 40, 431, 3, 2, 2, 2, 42, 444, 3, 2, 2, 2, 44, 451,
	3, 2, 2, 2, 46, 455, 3, 2, 2, 2, 48, 463, 3, 2, 2, 2, 50, 465, 3, 2, 2,
	2, 52, 467, 3, 2, 2, 2, 54, 476, 3, 2, 2, 2, 56, 485, 3, 2, 2, 2, 58, 490,
	3, 2, 2, 2, 60, 497, 3, 2, 2, 2, 62, 499, 3, 2, 2, 2, 64, 505, 3, 2, 2,
	2, 66, 510, 3, 2, 2, 2, 68, 525, 3, 2, 2, 2, 70, 537, 3, 2, 2, 2, 72, 547,
	3, 2, 2, 2, 74, 551, 3, 2, 2, 2, 76, 558, 3, 2, 2, 2, 78, 563, 3, 2, 2,
	2, 80, 569, 3, 2, 2, 2, 82, 577, 3, 2, 2, 2, 84, 582, 3, 2, 2, 2, 86, 584,
	3, 2, 2, 2, 88, 590, 3, 2, 2, 2, 90, 592, 3, 2, 2, 2, 92, 598, 3, 2, 2,
	2, 94, 603, 3, 2, 2, 2, 96, 609, 3, 2, 2, 2, 98, 624, 3, 2, 2, 2, 100,
	630, 3, 2, 2, 2, 102, 636, 3, 2, 2, 2, 104, 642, 3, 2, 2, 2, 106, 648,
	3, 2, 2, 2, 108, 654, 3, 2, 2, 2, 110, 660, 3, 2, 2, 2, 112, 666, 3, 2,
	2, 2, 114, 672, 3, 2, 2, 2, 116, 679, 3, 2, 2, 2, 118, 681, 3, 2, 2, 2,
	120, 684, 3, 2, 2, 2, 122, 687, 3, 2, 2, 2, 124, 690, 3, 2, 2, 2, 126,
	693, 3, 2, 2, 2, 128, 696, 3, 2, 2, 2, 130, 699, 3, 2, 2, 2, 132, 702,
	3, 2, 2, 2, 134, 705, 3, 2, 2, 2, 136, 708, 3, 2, 2, 2, 138, 722, 3, 2,
	2, 2, 140, 823, 3, 2, 2, 2, 142, 836, 3, 2, 2, 2, 144, 918, 3, 2, 2, 2,
	146, 947, 3, 2, 2, 2, 148, 949, 3, 2, 2, 2, 150, 971, 3, 2, 2, 2, 152,
	988, 3, 2, 2, 2, 154, 1005, 3, 2, 2, 2, 156, 1007, 3, 2, 2, 2, 158, 1023,
	3, 2, 2, 2, 160, 1107, 3, 2, 2, 2, 162, 1113, 3, 2, 2, 2, 164, 1117, 3,
	2, 2, 2, 166, 1119, 3, 2, 2, 2, 168, 1123, 3, 2, 2, 2, 170, 1127, 3, 2,
	2, 2, 172, 1129, 3, 2, 2, 2, 174, 1155, 3, 2, 2, 2, 176, 1168, 3, 2, 2,
	2, 178, 1170, 3, 2, 2, 2, 180, 1176, 3, 2, 2, 2, 182, 1178, 3, 2, 2, 2,
	184, 1189, 3, 2, 2, 2, 186, 1191, 3, 2, 2, 2, 188, 1206, 3, 2, 2, 2, 190,
	1208, 3, 2, 2, 2, 192, 1219, 3, 2, 2, 2, 194, 1221, 3, 2, 2, 2, 196, 1226,
	3, 2, 2, 2, 198, 1231, 3, 2, 2, 2, 200, 1236, 3, 2, 2, 2, 202, 1245, 3,
	2, 2, 2, 204, 1254, 3, 2, 2, 2, 206, 1262, 3, 2, 2, 2, 208, 1272, 3, 2,
	2, 2, 210, 1276, 3, 2, 2, 2, 212, 1278, 3, 2, 2, 2, 214, 1284, 3, 2, 2,
	2, 216, 1286, 3, 2, 2, 2, 218, 1288, 3, 2, 2, 2, 220, 1296, 3, 2, 2, 2,
	222, 1301, 3, 2, 2, 2, 224, 1305, 3, 2, 2, 2, 226, 1307, 3, 2, 2, 2, 228,
	1314, 3, 2, 2, 2, 230, 1323, 3, 2, 2, 2, 232, 1327, 3, 2, 2, 2, 234, 1334,
	3, 2, 2, 2, 236, 1339, 3, 2, 2, 2, 238, 1345, 3, 2, 2, 2, 240, 1353, 3,
	2, 2, 2, 242, 1358, 3, 2, 2, 2, 244, 1377, 3, 2, 2, 2, 246, 1422, 3, 2,
	2, 2, 248, 1424, 3, 2, 2, 2, 250, 1493, 3, 2, 2, 2, 252, 1495, 3, 2, 2,
	2, 254, 1497, 3, 2, 2, 2, 256, 1499, 3, 2, 2, 2, 258, 1501, 3, 2, 2, 2,
	260, 1503, 3, 2, 2, 2, 262, 1505, 3, 2, 2, 2, 264, 1507, 3, 2, 2, 2, 266,
	1509, 3, 2, 2, 2, 268, 1511, 3, 2, 2, 2, 270, 1515, 3, 2, 2, 2, 272, 1519,
	3, 2, 2, 2, 274, 1525, 3, 2, 2, 2, 276, 1529, 3, 2, 2, 2, 278, 1547, 3,
	2, 2, 2, 280, 1549, 3, 2, 2, 2, 282, 1597, 3, 2, 2, 2, 284, 1599, 3, 2,
	2, 2, 286, 1601, 3, 2, 2, 2, 288, 1605, 3, 2, 2, 2, 290, 1607, 3, 2, 2,
	2, 292, 1611, 3, 2, 2, 2, 294, 1613, 3, 2, 2, 2, 296, 1615, 3, 2, 2, 2,
	298, 1617, 3, 2, 2, 2, 300, 1619, 3, 2, 2, 2, 302, 1621, 3, 2, 2, 2, 304,
	1623, 3, 2, 2, 2, 306, 1625, 3, 2, 2, 2, 308, 1627, 3, 2, 2, 2, 310, 1629,
	3, 2, 2, 2, 312, 1631, 3, 2, 2, 2, 314, 315, 5, 4, 3, 2, 315, 316, 7, 389,
	2, 2, 316, 318, 3, 2, 2, 2, 317, 314, 3, 2, 2, 2, 318, 319, 3, 2, 2, 2,
	319, 317, 3, 2, 2, 2, 319, 320, 3, 2, 2, 2, 320, 3, 3, 2, 2, 2, 321, 330,
	5, 6, 4, 2, 322, 323, 7, 427, 2, 2, 323, 325, 7, 388, 2, 2, 324, 322, 3,
	2, 2, 2, 325, 326, 3, 2, 2, 2, 326, 324, 3, 2, 2, 2, 326, 327, 3, 2, 2,
	2, 327, 328, 3, 2, 2, 2, 328, 330, 5, 6, 4, 2, 329, 321, 3, 2, 2, 2, 329,
	324, 3, 2, 2, 2, 330, 5, 3, 2, 2, 2, 331, 337, 5, 28, 15, 2, 332, 337,
	5, 8, 5, 2, 333, 337, 5, 10, 6, 2, 334, 337, 5, 12, 7, 2, 335, 337, 5,
	250, 126, 2, 336, 331, 3, 2, 2, 2, 336, 332, 3, 2, 2, 2, 336, 333, 3, 2,
	2, 2, 336, 334, 3, 2, 2, 2, 336, 335, 3, 2, 2, 2, 337, 7, 3, 2, 2, 2, 338,
	339, 7, 43, 2, 2, 339, 340, 5, 14, 8, 2, 340, 341, 7, 427, 2, 2, 341, 9,
	3, 2, 2, 2, 342, 343, 7, 44, 2, 2, 343, 344, 5, 14, 8, 2, 344, 345, 7,
	427, 2, 2, 345, 11, 3, 2, 2, 2, 346, 347, 7, 45, 2, 2, 347, 13, 3, 2, 2,
	2, 348, 351, 5, 16, 9, 2, 349, 352, 5, 18, 10, 2, 350, 352, 5, 20, 11,
	2, 351, 349, 3, 2, 2, 2, 351, 350, 3, 2, 2, 2, 351, 352, 3, 2, 2, 2, 352,
	364, 3, 2, 2, 2, 353, 356, 5, 18, 10, 2, 354, 357, 5, 16, 9, 2, 355, 357,
	5, 20, 11, 2, 356, 354, 3, 2, 2, 2, 356, 355, 3, 2, 2, 2, 356, 357, 3,
	2, 2, 2, 357, 364, 3, 2, 2, 2, 358, 361, 5, 20, 11, 2, 359, 362, 5, 16,
	9, 2, 360, 362, 5, 18, 10, 2, 361, 359, 3, 2, 2, 2, 361, 360, 3, 2, 2,
	2, 361, 362, 3, 2, 2, 2, 362, 364, 3, 2, 2, 2, 363, 348, 3, 2, 2, 2, 363,
	353, 3, 2, 2, 2, 363, 358, 3, 2, 2, 2, 364, 15, 3, 2, 2, 2, 365, 368, 7,
	382, 2, 2, 366, 369, 5, 22, 12, 2, 367, 369, 5, 24, 13, 2, 368, 366, 3,
	2, 2, 2, 368, 367, 3, 2, 2, 2, 369, 17, 3, 2, 2, 2, 370, 371, 7, 382, 2,
	2, 371, 372, 5, 26, 14, 2, 372, 19, 3, 2, 2, 2, 373, 374, 7, 382, 2, 2,
	374, 375, 7, 403, 2, 2, 375, 21, 3, 2, 2, 2, 376, 377, 9, 2, 2, 2, 377,
	23, 3, 2, 2, 2, 378, 379, 9, 3, 2, 2, 379, 25, 3, 2, 2, 2, 380, 381, 9,
	4, 2, 2, 381, 27, 3, 2, 2, 2, 382, 390, 5, 60, 31, 2, 383, 390, 5, 176,
	89, 2, 384, 390, 5, 230, 116, 2, 385, 390, 5, 246, 124, 2, 386, 390, 5,
	30, 16, 2, 387, 390, 5, 62, 32, 2, 388, 390, 5, 66, 34, 2, 389, 382, 3,
	2, 2, 2, 389, 383, 3, 2, 2, 2, 389, 384, 3, 2, 2, 2, 389, 385, 3, 2, 2,
	2, 389, 386, 3, 2, 2, 2, 389, 387, 3, 2, 2, 2, 389, 388, 3, 2, 2, 2, 390,
	29, 3, 2, 2, 2, 391, 397, 7, 48, 2, 2, 392, 398, 5, 32, 17, 2, 393, 398,
	5, 34, 18, 2, 394, 398, 5, 36, 19, 2, 395, 398, 5, 38, 20, 2, 396, 398,
	5, 40, 21, 2, 397, 392, 3, 2, 2, 2, 397, 393, 3, 2, 2, 2, 397, 394, 3,
	2, 2, 2, 397, 395, 3, 2, 2, 2, 397, 396, 3, 2, 2, 2, 398, 31, 3, 2, 2,
	2, 399, 404, 7, 427, 2, 2, 400, 401, 7, 387, 2, 2, 401, 403, 7, 427, 2,
	2, 402, 400, 3, 2, 2, 2, 403, 406, 3, 2, 2, 2, 404, 402, 3, 2, 2, 2, 404,
	405, 3, 2, 2, 2, 405, 33, 3, 2, 2, 2, 406, 404, 3, 2, 2, 2, 407, 408, 7,
	384, 2, 2, 408, 413, 5, 46, 24, 2, 409, 410, 7, 387, 2, 2, 410, 412, 5,
	46, 24, 2, 411, 409, 3, 2, 2, 2, 412, 415, 3, 2, 2, 2, 413, 411, 3, 2,
	2, 2, 413, 414, 3, 2, 2, 2, 414, 35, 3, 2, 2, 2, 415, 413, 3, 2, 2, 2,
	416, 417, 7, 427, 2, 2, 417, 418, 7, 392, 2, 2, 418, 421, 7, 393, 2, 2,
	419, 420, 7, 384, 2, 2, 420, 422, 5, 44, 23, 2, 421, 419, 3, 2, 2, 2, 421,
	422, 3, 2, 2, 2, 422, 37, 3, 2, 2, 2, 423, 424, 7, 427, 2, 2, 424, 425,
	7, 392, 2, 2, 425, 426, 5, 50, 26, 2, 426, 429, 7, 393, 2, 2, 427, 428,
	7, 384, 2, 2, 428, 430, 5, 44, 23, 2, 429, 427, 3, 2, 2, 2, 429, 430, 3,
	2, 2, 2, 430, 39, 3, 2, 2, 2, 431, 432, 7, 427, 2, 2, 432, 433, 7, 384,
	2, 2, 433, 434, 5, 50, 26, 2, 434, 41, 3, 2, 2, 2, 435, 440, 5, 46, 24,
	2, 436, 437, 7, 387, 2, 2, 437, 439, 5, 46, 24, 2, 438, 436, 3, 2, 2, 2,
	439, 442, 3, 2, 2, 2, 440, 438, 3, 2, 2, 2, 440, 441, 3, 2, 2, 2, 441,
	445, 3, 2, 2, 2, 442, 440, 3, 2, 2, 2, 443, 445, 7, 3, 2, 2, 444, 435,
	3, 2, 2, 2, 444, 443, 3, 2, 2, 2, 445, 43, 3, 2, 2, 2, 446, 447, 7, 394,
	2, 2, 447, 448, 5, 42, 22, 2, 448, 449, 7, 395, 2, 2, 449, 452, 3, 2, 2,
	2, 450, 452, 5, 42, 22, 2, 451, 446, 3, 2, 2, 2, 451, 450, 3, 2, 2, 2,
	452, 45, 3, 2, 2, 2, 453, 456, 5, 50, 26, 2, 454, 456, 7, 4, 2, 2, 455,
	453, 3, 2, 2, 2, 455, 454, 3, 2, 2, 2, 456, 47, 3, 2, 2, 2, 457, 458, 7,
	396, 2, 2, 458, 464, 7, 427, 2, 2, 459, 460, 7, 215, 2, 2, 460, 461, 7,
	390, 2, 2, 461, 462, 7, 427, 2, 2, 462, 464, 7, 391, 2, 2, 463, 457, 3,
	2, 2, 2, 463, 459, 3, 2, 2, 2, 464, 49, 3, 2, 2, 2, 465, 466, 5, 52, 27,
	2, 466, 51, 3, 2, 2, 2, 467, 472, 5, 54, 28, 2, 468, 469, 9, 5, 2, 2, 469,
	471, 5, 54, 28, 2, 470, 468, 3, 2, 2, 2, 471, 474, 3, 2, 2, 2, 472, 470,
	3, 2, 2, 2, 472, 473, 3, 2, 2, 2, 473, 53, 3, 2, 2, 2, 474, 472, 3, 2,
	2, 2, 475, 477, 7, 380, 2, 2, 476, 475, 3, 2, 2, 2, 476, 477, 3, 2, 2,
	2, 477, 478, 3, 2, 2, 2, 478, 479, 5, 56, 29, 2, 479, 55, 3, 2, 2, 2, 480,
	486, 5, 58, 30, 2, 481, 482, 7, 390, 2, 2, 482, 483, 5, 52, 27, 2, 483,
	484, 7, 391, 2, 2, 484, 486, 3, 2, 2, 2, 485, 480, 3, 2, 2, 2, 485, 481,
	3, 2, 2, 2, 486, 57, 3, 2, 2, 2, 487, 491, 7, 5, 2, 2, 488, 491, 5, 48,
	25, 2, 489, 491, 7, 427, 2, 2, 490, 487, 3, 2, 2, 2, 490, 488, 3, 2, 2,
	2, 490, 489, 3, 2, 2, 2, 491, 59, 3, 2, 2, 2, 492, 498, 5, 170, 86, 2,
	493, 498, 5, 138, 70, 2, 494, 498, 5, 142, 72, 2, 495, 498, 5, 146, 74,
	2, 496, 498, 5, 158, 80, 2, 497, 492, 3, 2, 2, 2, 497, 493, 3, 2, 2, 2,
	497, 494, 3, 2, 2, 2, 497, 495, 3, 2, 2, 2, 497, 496, 3, 2, 2, 2, 498,
	61, 3, 2, 2, 2, 499, 500, 7, 186, 2, 2, 500, 501, 5, 280, 141, 2, 501,
	502, 5, 64, 33, 2, 502, 63, 3, 2, 2, 2, 503, 506, 5, 66, 34, 2, 504, 506,
	5, 60, 31, 2, 505, 503, 3, 2, 2, 2, 505, 504, 3, 2, 2, 2, 506, 65, 3, 2,
	2, 2, 507, 508, 5, 60, 31, 2, 508, 509, 7, 387, 2, 2, 509, 511, 3, 2, 2,
	2, 510, 507, 3, 2, 2, 2, 510, 511, 3, 2, 2, 2, 511, 523, 3, 2, 2, 2, 512,
	524, 5, 68, 35, 2, 513, 524, 5, 74, 38, 2, 514, 524, 5, 76, 39, 2, 515,
	524, 5, 78, 40, 2, 516, 524, 5, 80, 41, 2, 517, 524, 5, 82, 42, 2, 518,
	524, 5, 84, 43, 2, 519, 524, 5, 86, 44, 2, 520, 524, 5, 88, 45, 2, 521,
	524, 5, 90, 46, 2, 522, 524, 5, 96, 49, 2, 523, 512, 3, 2, 2, 2, 523, 513,
	3, 2, 2, 2, 523, 514, 3, 2, 2, 2, 523, 515, 3, 2, 2, 2, 523, 516, 3, 2,
	2, 2, 523, 517, 3, 2, 2, 2, 523, 518, 3, 2, 2, 2, 523, 519, 3, 2, 2, 2,
	523, 520, 3, 2, 2, 2, 523, 521, 3, 2, 2, 2, 523, 522, 3, 2, 2, 2, 524,
	67, 3, 2, 2, 2, 525, 526, 5, 70, 36, 2, 526, 527, 7, 387, 2, 2, 527, 528,
	5, 72, 37, 2, 528, 69, 3, 2, 2, 2, 529, 530, 5, 118, 60, 2, 530, 531, 7,
	384, 2, 2, 531, 532, 5, 276, 139, 2, 532, 538, 3, 2, 2, 2, 533, 534, 5,
	276, 139, 2, 534, 535, 7, 384, 2, 2, 535, 536, 5, 118, 60, 2, 536, 538,
	3, 2, 2, 2, 537, 529, 3, 2, 2, 2, 537, 533, 3, 2, 2, 2, 538, 71, 3, 2,
	2, 2, 539, 540, 5, 120, 61, 2, 540, 541, 7, 384, 2, 2, 541, 542, 5, 276,
	139, 2, 542, 548, 3, 2, 2, 2, 543, 544, 5, 276, 139, 2, 544, 545, 7, 384,
	2, 2, 545, 546, 5, 120, 61, 2, 546, 548, 3, 2, 2, 2, 547, 539, 3, 2, 2,
	2, 547, 543, 3, 2, 2, 2, 548, 73, 3, 2, 2, 2, 549, 552, 5, 118, 60, 2,
	550, 552, 5, 120, 61, 2, 551, 549, 3, 2, 2, 2, 551, 550, 3, 2, 2, 2, 552,
	553, 3, 2, 2, 2, 553, 554, 7, 384, 2, 2, 554, 555, 5, 278, 140, 2, 555,
	75, 3, 2, 2, 2, 556, 559, 5, 122, 62, 2, 557, 559, 5, 124, 63, 2, 558,
	556, 3, 2, 2, 2, 558, 557, 3, 2, 2, 2, 559, 560, 3, 2, 2, 2, 560, 561,
	7, 384, 2, 2, 561, 562, 5, 278, 140, 2, 562, 77, 3, 2, 2, 2, 563, 564,
	5, 278, 140, 2, 564, 567, 7, 384, 2, 2, 565, 568, 5, 118, 60, 2, 566, 568,
	5, 120, 61, 2, 567, 565, 3, 2, 2, 2, 567, 566, 3, 2, 2, 2, 568, 79, 3,
	2, 2, 2, 569, 570, 5, 278, 140, 2, 570, 573, 7, 384, 2, 2, 571, 574, 5,
	122, 62, 2, 572, 574, 5, 124, 63, 2, 573, 571, 3, 2, 2, 2, 573, 572, 3,
	2, 2, 2, 574, 81, 3, 2, 2, 2, 575, 578, 5, 126, 64, 2, 576, 578, 5, 128,
	65, 2, 577, 575, 3, 2, 2, 2, 577, 576, 3, 2, 2, 2, 578, 579, 3, 2, 2, 2,
	579, 580, 7, 384, 2, 2, 580, 581, 5, 276, 139, 2, 581, 83, 3, 2, 2, 2,
	582, 583, 5, 234, 118, 2, 583, 85, 3, 2, 2, 2, 584, 585, 5, 276, 139, 2,
	585, 588, 7, 384, 2, 2, 586, 589, 5, 126, 64, 2, 587, 589, 5, 128, 65,
	2, 588, 586, 3, 2, 2, 2, 588, 587, 3, 2, 2, 2, 589, 87, 3, 2, 2, 2, 590,
	591, 5, 238, 120, 2, 591, 89, 3, 2, 2, 2, 592, 593, 5, 244, 123, 2, 593,
	594, 7, 384, 2, 2, 594, 595, 5, 278, 140, 2, 595, 91, 3, 2, 2, 2, 596,
	599, 5, 118, 60, 2, 597, 599, 5, 120, 61, 2, 598, 596, 3, 2, 2, 2, 598,
	597, 3, 2, 2, 2, 599, 600, 3, 2, 2, 2, 600, 601, 7, 384, 2, 2, 601, 602,
	5, 276, 139, 2, 602, 93, 3, 2, 2, 2, 603, 604, 5, 276, 139, 2, 604, 607,
	7, 384, 2, 2, 605, 608, 5, 118, 60, 2, 606, 608, 5, 120, 61, 2, 607, 605,
	3, 2, 2, 2, 607, 606, 3, 2, 2, 2, 608, 95, 3, 2, 2, 2, 609, 622, 7, 248,
	2, 2, 610, 611, 7, 390, 2, 2, 611, 612, 5, 262, 132, 2, 612, 613, 7, 387,
	2, 2, 613, 614, 5, 264, 133, 2, 614, 615, 7, 391, 2, 2, 615, 623, 3, 2,
	2, 2, 616, 617, 7, 390, 2, 2, 617, 618, 5, 266, 134, 2, 618, 619, 7, 387,
	2, 2, 619, 620, 5, 268, 135, 2, 620, 621, 7, 391, 2, 2, 621, 623, 3, 2,
	2, 2, 622, 610, 3, 2, 2, 2, 622, 616, 3, 2, 2, 2, 623, 97, 3, 2, 2, 2,
	624, 625, 7, 390, 2, 2, 625, 626, 5, 262, 132, 2, 626, 627, 7, 387, 2,
	2, 627, 628, 5, 264, 133, 2, 628, 629, 7, 391, 2, 2, 629, 99, 3, 2, 2,
	2, 630, 631, 7, 390, 2, 2, 631, 632, 5, 266, 134, 2, 632, 633, 7, 387,
	2, 2, 633, 634, 5, 268, 135, 2, 634, 635, 7, 391, 2, 2, 635, 101, 3, 2,
	2, 2, 636, 637, 7, 390, 2, 2, 637, 638, 5, 268, 135, 2, 638, 639, 7, 387,
	2, 2, 639, 640, 5, 266, 134, 2, 640, 641, 7, 391, 2, 2, 641, 103, 3, 2,
	2, 2, 642, 643, 7, 390, 2, 2, 643, 644, 5, 264, 133, 2, 644, 645, 7, 387,
	2, 2, 645, 646, 5, 262, 132, 2, 646, 647, 7, 391, 2, 2, 647, 105, 3, 2,
	2, 2, 648, 649, 7, 390, 2, 2, 649, 650, 5, 262, 132, 2, 650, 651, 7, 387,
	2, 2, 651, 652, 5, 50, 26, 2, 652, 653, 7, 391, 2, 2, 653, 107, 3, 2, 2,
	2, 654, 655, 7, 390, 2, 2, 655, 656, 5, 266, 134, 2, 656, 657, 7, 387,
	2, 2, 657, 658, 5, 50, 26, 2, 658, 659, 7, 391, 2, 2, 659, 109, 3, 2, 2,
	2, 660, 661, 7, 390, 2, 2, 661, 662, 5, 50, 26, 2, 662, 663, 7, 387, 2,
	2, 663, 664, 5, 262, 132, 2, 664, 665, 7, 391, 2, 2, 665, 111, 3, 2, 2,
	2, 666, 667, 7, 390, 2, 2, 667, 668, 5, 50, 26, 2, 668, 669, 7, 387, 2,
	2, 669, 670, 5, 266, 134, 2, 670, 671, 7, 391, 2, 2, 671, 113, 3, 2, 2,
	2, 672, 673, 3, 2, 2, 2, 673, 115, 3, 2, 2, 2, 674, 680, 5, 58, 30, 2,
	675, 676, 5, 58, 30, 2, 676, 677, 9, 6, 2, 2, 677, 678, 5, 58, 30, 2, 678,
	680, 3, 2, 2, 2, 679, 674, 3, 2, 2, 2, 679, 675, 3, 2, 2, 2, 680, 117,
	3, 2, 2, 2, 681, 682, 7, 103, 2, 2, 682, 683, 5, 98, 50, 2, 683, 119, 3,
	2, 2, 2, 684, 685, 7, 279, 2, 2, 685, 686, 5, 100, 51, 2, 686, 121, 3,
	2, 2, 2, 687, 688, 7, 103, 2, 2, 688, 689, 5, 104, 53, 2, 689, 123, 3,
	2, 2, 2, 690, 691, 7, 279, 2, 2, 691, 692, 5, 102, 52, 2, 692, 125, 3,
	2, 2, 2, 693, 694, 7, 103, 2, 2, 694, 695, 5, 106, 54, 2, 695, 127, 3,
	2, 2, 2, 696, 697, 7, 279, 2, 2, 697, 698, 5, 108, 55, 2, 698, 129, 3,
	2, 2, 2, 699, 700, 7, 103, 2, 2, 700, 701, 5, 110, 56, 2, 701, 131, 3,
	2, 2, 2, 702, 703, 7, 279, 2, 2, 703, 704, 5, 112, 57, 2, 704, 133, 3,
	2, 2, 2, 705, 706, 7, 103, 2, 2, 706, 707, 5, 114, 58, 2, 707, 135, 3,
	2, 2, 2, 708, 709, 7, 279, 2, 2, 709, 710, 5, 114, 58, 2, 710, 137, 3,
	2, 2, 2, 711, 712, 5, 256, 129, 2, 712, 713, 7, 384, 2, 2, 713, 714, 5,
	140, 71, 2, 714, 723, 3, 2, 2, 2, 715, 716, 7, 94, 2, 2, 716, 717, 7, 390,
	2, 2, 717, 718, 5, 256, 129, 2, 718, 719, 7, 387, 2, 2, 719, 720, 5, 256,
	129, 2, 720, 721, 7, 391, 2, 2, 721, 723, 3, 2, 2, 2, 722, 711, 3, 2, 2,
	2, 722, 715, 3, 2, 2, 2, 723, 139, 3, 2, 2, 2, 724, 725, 5, 256, 129, 2,
	725, 726, 5, 168, 85, 2, 726, 727, 5, 256, 129, 2, 727, 824, 3, 2, 2, 2,
	728, 729, 5, 256, 129, 2, 729, 730, 7, 379, 2, 2, 730, 731, 5, 256, 129,
	2, 731, 732, 7, 379, 2, 2, 732, 733, 7, 89, 2, 2, 733, 824, 3, 2, 2, 2,
	734, 735, 5, 256, 129, 2, 735, 736, 7, 379, 2, 2, 736, 737, 5, 256, 129,
	2, 737, 738, 7, 379, 2, 2, 738, 739, 7, 89, 2, 2, 739, 740, 7, 380, 2,
	2, 740, 741, 7, 5, 2, 2, 741, 824, 3, 2, 2, 2, 742, 743, 7, 390, 2, 2,
	743, 744, 5, 256, 129, 2, 744, 745, 7, 379, 2, 2, 745, 746, 5, 256, 129,
	2, 746, 747, 7, 391, 2, 2, 747, 748, 7, 382, 2, 2, 748, 749, 7, 5, 2, 2,
	749, 824, 3, 2, 2, 2, 750, 751, 5, 256, 129, 2, 751, 752, 7, 379, 2, 2,
	752, 753, 7, 89, 2, 2, 753, 824, 3, 2, 2, 2, 754, 755, 5, 256, 129, 2,
	755, 756, 7, 379, 2, 2, 756, 757, 7, 89, 2, 2, 757, 758, 7, 380, 2, 2,
	758, 759, 7, 5, 2, 2, 759, 824, 3, 2, 2, 2, 760, 761, 5, 256, 129, 2, 761,
	762, 7, 379, 2, 2, 762, 763, 7, 5, 2, 2, 763, 824, 3, 2, 2, 2, 764, 765,
	5, 256, 129, 2, 765, 766, 7, 380, 2, 2, 766, 767, 7, 5, 2, 2, 767, 824,
	3, 2, 2, 2, 768, 769, 7, 380, 2, 2, 769, 824, 5, 256, 129, 2, 770, 771,
	7, 50, 2, 2, 771, 824, 5, 256, 129, 2, 772, 773, 7, 275, 2, 2, 773, 824,
	5, 256, 129, 2, 774, 775, 5, 256, 129, 2, 775, 776, 7, 55, 2, 2, 776, 777,
	5, 256, 129, 2, 777, 824, 3, 2, 2, 2, 778, 779, 5, 256, 129, 2, 779, 780,
	7, 269, 2, 2, 780, 781, 5, 256, 129, 2, 781, 824, 3, 2, 2, 2, 782, 783,
	5, 256, 129, 2, 783, 784, 7, 378, 2, 2, 784, 785, 5, 256, 129, 2, 785,
	824, 3, 2, 2, 2, 786, 787, 7, 265, 2, 2, 787, 824, 5, 256, 129, 2, 788,
	789, 7, 244, 2, 2, 789, 790, 7, 390, 2, 2, 790, 791, 5, 256, 129, 2, 791,
	792, 7, 387, 2, 2, 792, 793, 5, 256, 129, 2, 793, 794, 7, 391, 2, 2, 794,
	824, 3, 2, 2, 2, 795, 796, 7, 242, 2, 2, 796, 797, 7, 390, 2, 2, 797, 798,
	5, 256, 129, 2, 798, 799, 7, 387, 2, 2, 799, 800, 5, 256, 129, 2, 800,
	801, 7, 391, 2, 2, 801, 824, 3, 2, 2, 2, 802, 803, 7, 93, 2, 2, 803, 804,
	5, 256, 129, 2, 804, 805, 7, 84, 2, 2, 805, 806, 5, 256, 129, 2, 806, 824,
	3, 2, 2, 2, 807, 808, 7, 241, 2, 2, 808, 824, 5, 258, 130, 2, 809, 810,
	7, 220, 2, 2, 810, 824, 5, 258, 130, 2, 811, 812, 7, 148, 2, 2, 812, 815,
	5, 258, 130, 2, 813, 814, 7, 84, 2, 2, 814, 816, 5, 256, 129, 2, 815, 813,
	3, 2, 2, 2, 815, 816, 3, 2, 2, 2, 816, 824, 3, 2, 2, 2, 817, 818, 7, 357,
	2, 2, 818, 821, 5, 258, 130, 2, 819, 820, 7, 84, 2, 2, 820, 822, 5, 256,
	129, 2, 821, 819, 3, 2, 2, 2, 821, 822, 3, 2, 2, 2, 822, 824, 3, 2, 2,
	2, 823, 724, 3, 2, 2, 2, 823, 728, 3, 2, 2, 2, 823, 734, 3, 2, 2, 2, 823,
	742, 3, 2, 2, 2, 823, 750, 3, 2, 2, 2, 823, 754, 3, 2, 2, 2, 823, 760,
	3, 2, 2, 2, 823, 764, 3, 2, 2, 2, 823, 768, 3, 2, 2, 2, 823, 770, 3, 2,
	2, 2, 823, 772, 3, 2, 2, 2, 823, 774, 3, 2, 2, 2, 823, 778, 3, 2, 2, 2,
	823, 782, 3, 2, 2, 2, 823, 786, 3, 2, 2, 2, 823, 788, 3, 2, 2, 2, 823,
	795, 3, 2, 2, 2, 823, 802, 3, 2, 2, 2, 823, 807, 3, 2, 2, 2, 823, 809,
	3, 2, 2, 2, 823, 811, 3, 2, 2, 2, 823, 817, 3, 2, 2, 2, 824, 141, 3, 2,
	2, 2, 825, 826, 5, 258, 130, 2, 826, 827, 7, 384, 2, 2, 827, 828, 5, 144,
	73, 2, 828, 837, 3, 2, 2, 2, 829, 830, 7, 94, 2, 2, 830, 831, 7, 390, 2,
	2, 831, 832, 5, 258, 130, 2, 832, 833, 7, 387, 2, 2, 833, 834, 5, 258,
	130, 2, 834, 835, 7, 391, 2, 2, 835, 837, 3, 2, 2, 2, 836, 825, 3, 2, 2,
	2, 836, 829, 3, 2, 2, 2, 837, 143, 3, 2, 2, 2, 838, 839, 5, 258, 130, 2,
	839, 840, 7, 379, 2, 2, 840, 841, 5, 258, 130, 2, 841, 919, 3, 2, 2, 2,
	842, 843, 5, 258, 130, 2, 843, 844, 7, 380, 2, 2, 844, 845, 5, 258, 130,
	2, 845, 919, 3, 2, 2, 2, 846, 847, 7, 50, 2, 2, 847, 848, 7, 390, 2, 2,
	848, 849, 5, 258, 130, 2, 849, 850, 7, 379, 2, 2, 850, 851, 5, 258, 130,
	2, 851, 852, 7, 391, 2, 2, 852, 919, 3, 2, 2, 2, 853, 854, 7, 50, 2, 2,
	854, 855, 7, 390, 2, 2, 855, 856, 5, 258, 130, 2, 856, 857, 7, 380, 2,
	2, 857, 858, 5, 258, 130, 2, 858, 859, 7, 391, 2, 2, 859, 919, 3, 2, 2,
	2, 860, 861, 7, 390, 2, 2, 861, 862, 5, 258, 130, 2, 862, 863, 7, 379,
	2, 2, 863, 864, 5, 258, 130, 2, 864, 865, 7, 391, 2, 2, 865, 866, 7, 382,
	2, 2, 866, 867, 7, 5, 2, 2, 867, 919, 3, 2, 2, 2, 868, 869, 7, 380, 2,
	2, 869, 919, 5, 258, 130, 2, 870, 871, 7, 50, 2, 2, 871, 919, 5, 258, 130,
	2, 872, 873, 7, 275, 2, 2, 873, 919, 5, 258, 130, 2, 874, 875, 7, 318,
	2, 2, 875, 919, 5, 258, 130, 2, 876, 877, 7, 325, 2, 2, 877, 878, 5, 258,
	130, 2, 878, 879, 7, 84, 2, 2, 879, 880, 5, 256, 129, 2, 880, 919, 3, 2,
	2, 2, 881, 882, 7, 153, 2, 2, 882, 885, 5, 256, 129, 2, 883, 884, 7, 84,
	2, 2, 884, 886, 5, 256, 129, 2, 885, 883, 3, 2, 2, 2, 885, 886, 3, 2, 2,
	2, 886, 919, 3, 2, 2, 2, 887, 888, 7, 316, 2, 2, 888, 919, 5, 258, 130,
	2, 889, 890, 7, 321, 2, 2, 890, 919, 5, 258, 130, 2, 891, 892, 5, 258,
	130, 2, 892, 893, 7, 95, 2, 2, 893, 894, 5, 258, 130, 2, 894, 919, 3, 2,
	2, 2, 895, 896, 7, 244, 2, 2, 896, 897, 7, 390, 2, 2, 897, 898, 5, 258,
	130, 2, 898, 899, 7, 387, 2, 2, 899, 900, 5, 258, 130, 2, 900, 901, 7,
	391, 2, 2, 901, 919, 3, 2, 2, 2, 902, 903, 7, 242, 2, 2, 903, 904, 7, 390,
	2, 2, 904, 905, 5, 258, 130, 2, 905, 906, 7, 387, 2, 2, 906, 907, 5, 258,
	130, 2, 907, 908, 7, 391, 2, 2, 908, 919, 3, 2, 2, 2, 909, 910, 7, 93,
	2, 2, 910, 911, 5, 258, 130, 2, 911, 912, 7, 84, 2, 2, 912, 913, 5, 258,
	130, 2, 913, 919, 3, 2, 2, 2, 914, 915, 5, 258, 130, 2, 915, 916, 7, 381,
	2, 2, 916, 917, 5, 258, 130, 2, 917, 919, 3, 2, 2, 2, 918, 838, 3, 2, 2,
	2, 918, 842, 3, 2, 2, 2, 918, 846, 3, 2, 2, 2, 918, 853, 3, 2, 2, 2, 918,
	860, 3, 2, 2, 2, 918, 868, 3, 2, 2, 2, 918, 870, 3, 2, 2, 2, 918, 872,
	3, 2, 2, 2, 918, 874, 3, 2, 2, 2, 918, 876, 3, 2, 2, 2, 918, 881, 3, 2,
	2, 2, 918, 887, 3, 2, 2, 2, 918, 889, 3, 2, 2, 2, 918, 891, 3, 2, 2, 2,
	918, 895, 3, 2, 2, 2, 918, 902, 3, 2, 2, 2, 918, 909, 3, 2, 2, 2, 918,
	914, 3, 2, 2, 2, 919, 145, 3, 2, 2, 2, 920, 921, 5, 256, 129, 2, 921, 922,
	7, 384, 2, 2, 922, 923, 5, 150, 76, 2, 923, 948, 3, 2, 2, 2, 924, 925,
	7, 256, 2, 2, 925, 926, 7, 384, 2, 2, 926, 948, 5, 152, 77, 2, 927, 928,
	7, 255, 2, 2, 928, 929, 7, 384, 2, 2, 929, 948, 5, 154, 78, 2, 930, 931,
	5, 156, 79, 2, 931, 932, 7, 384, 2, 2, 932, 933, 7, 5, 2, 2, 933, 948,
	3, 2, 2, 2, 934, 937, 5, 310, 156, 2, 935, 937, 5, 312, 157, 2, 936, 934,
	3, 2, 2, 2, 936, 935, 3, 2, 2, 2, 937, 938, 3, 2, 2, 2, 938, 939, 7, 384,
	2, 2, 939, 940, 5, 256, 129, 2, 940, 948, 3, 2, 2, 2, 941, 942, 5, 256,
	129, 2, 942, 945, 7, 384, 2, 2, 943, 946, 5, 310, 156, 2, 944, 946, 5,
	312, 157, 2, 945, 943, 3, 2, 2, 2, 945, 944, 3, 2, 2, 2, 946, 948, 3, 2,
	2, 2, 947, 920, 3, 2, 2, 2, 947, 924, 3, 2, 2, 2, 947, 927, 3, 2, 2, 2,
	947, 930, 3, 2, 2, 2, 947, 936, 3, 2, 2, 2, 947, 941, 3, 2, 2, 2, 948,
	147, 3, 2, 2, 2, 949, 950, 5, 256, 129, 2, 950, 951, 7, 381, 2, 2, 951,
	953, 5, 256, 129, 2, 952, 954, 5, 288, 145, 2, 953, 952, 3, 2, 2, 2, 953,
	954, 3, 2, 2, 2, 954, 149, 3, 2, 2, 2, 955, 972, 5, 148, 75, 2, 956, 957,
	5, 156, 79, 2, 957, 958, 5, 168, 85, 2, 958, 959, 5, 148, 75, 2, 959, 972,
	3, 2, 2, 2, 960, 961, 7, 324, 2, 2, 961, 963, 5, 156, 79, 2, 962, 964,
	5, 284, 143, 2, 963, 962, 3, 2, 2, 2, 963, 964, 3, 2, 2, 2, 964, 972, 3,
	2, 2, 2, 965, 966, 7, 318, 2, 2, 966, 968, 5, 156, 79, 2, 967, 969, 5,
	284, 143, 2, 968, 967, 3, 2, 2, 2, 968, 969, 3, 2, 2, 2, 969, 972, 3, 2,
	2, 2, 970, 972, 5, 156, 79, 2, 971, 955, 3, 2, 2, 2, 971, 956, 3, 2, 2,
	2, 971, 960, 3, 2, 2, 2, 971, 965, 3, 2, 2, 2, 971, 970, 3, 2, 2, 2, 972,
	151, 3, 2, 2, 2, 973, 989, 5, 148, 75, 2, 974, 975, 7, 256, 2, 2, 975,
	976, 5, 168, 85, 2, 976, 977, 5, 148, 75, 2, 977, 989, 3, 2, 2, 2, 978,
	979, 7, 324, 2, 2, 979, 981, 7, 256, 2, 2, 980, 982, 5, 284, 143, 2, 981,
	980, 3, 2, 2, 2, 981, 982, 3, 2, 2, 2, 982, 989, 3, 2, 2, 2, 983, 984,
	7, 318, 2, 2, 984, 986, 7, 256, 2, 2, 985, 987, 5, 284, 143, 2, 986, 985,
	3, 2, 2, 2, 986, 987, 3, 2, 2, 2, 987, 989, 3, 2, 2, 2, 988, 973, 3, 2,
	2, 2, 988, 974, 3, 2, 2, 2, 988, 978, 3, 2, 2, 2, 988, 983, 3, 2, 2, 2,
	989, 153, 3, 2, 2, 2, 990, 1006, 5, 148, 75, 2, 991, 992, 7, 255, 2, 2,
	992, 993, 5, 168, 85, 2, 993, 994, 5, 148, 75, 2, 994, 1006, 3, 2, 2, 2,
	995, 996, 7, 324, 2, 2, 996, 998, 7, 255, 2, 2, 997, 999, 5, 284, 143,
	2, 998, 997, 3, 2, 2, 2, 998, 999, 3, 2, 2, 2, 999, 1006, 3, 2, 2, 2, 1000,
	1001, 7, 318, 2, 2, 1001, 1003, 7, 255, 2, 2, 1002, 1004, 5, 284, 143,
	2, 1003, 1002, 3, 2, 2, 2, 1003, 1004, 3, 2, 2, 2, 1004, 1006, 3, 2, 2,
	2, 1005, 990, 3, 2, 2, 2, 1005, 991, 3, 2, 2, 2, 1005, 995, 3, 2, 2, 2,
	1005, 1000, 3, 2, 2, 2, 1006, 155, 3, 2, 2, 2, 1007, 1008, 9, 7, 2, 2,
	1008, 157, 3, 2, 2, 2, 1009, 1010, 5, 256, 129, 2, 1010, 1011, 7, 384,
	2, 2, 1011, 1012, 5, 160, 81, 2, 1012, 1024, 3, 2, 2, 2, 1013, 1014, 7,
	83, 2, 2, 1014, 1015, 5, 256, 129, 2, 1015, 1016, 7, 84, 2, 2, 1016, 1017,
	5, 162, 82, 2, 1017, 1024, 3, 2, 2, 2, 1018, 1019, 5, 258, 130, 2, 1019,
	1020, 7, 384, 2, 2, 1020, 1021, 7, 162, 2, 2, 1021, 1022, 5, 256, 129,
	2, 1022, 1024, 3, 2, 2, 2, 1023, 1009, 3, 2, 2, 2, 1023, 1013, 3, 2, 2,
	2, 1023, 1018, 3, 2, 2, 2, 1024, 159, 3, 2, 2, 2, 1025, 1026, 7, 223, 2,
	2, 1026, 1027, 5, 256, 129, 2, 1027, 1028, 7, 84, 2, 2, 1028, 1029, 5,
	162, 82, 2, 1029, 1108, 3, 2, 2, 2, 1030, 1031, 5, 256, 129, 2, 1031, 1032,
	7, 269, 2, 2, 1032, 1033, 7, 223, 2, 2, 1033, 1034, 5, 256, 129, 2, 1034,
	1035, 7, 84, 2, 2, 1035, 1036, 5, 162, 82, 2, 1036, 1108, 3, 2, 2, 2, 1037,
	1038, 7, 56, 2, 2, 1038, 1039, 5, 256, 129, 2, 1039, 1040, 7, 84, 2, 2,
	1040, 1041, 5, 162, 82, 2, 1041, 1108, 3, 2, 2, 2, 1042, 1043, 5, 256,
	129, 2, 1043, 1044, 7, 269, 2, 2, 1044, 1045, 7, 56, 2, 2, 1045, 1046,
	5, 256, 129, 2, 1046, 1047, 7, 84, 2, 2, 1047, 1048, 5, 162, 82, 2, 1048,
	1108, 3, 2, 2, 2, 1049, 1050, 7, 319, 2, 2, 1050, 1051, 5, 256, 129, 2,
	1051, 1052, 7, 84, 2, 2, 1052, 1053, 5, 162, 82, 2, 1053, 1108, 3, 2, 2,
	2, 1054, 1055, 7, 76, 2, 2, 1055, 1056, 5, 256, 129, 2, 1056, 1057, 7,
	84, 2, 2, 1057, 1058, 5, 162, 82, 2, 1058, 1108, 3, 2, 2, 2, 1059, 1060,
	7, 81, 2, 2, 1060, 1061, 5, 256, 129, 2, 1061, 1062, 7, 84, 2, 2, 1062,
	1063, 5, 162, 82, 2, 1063, 1108, 3, 2, 2, 2, 1064, 1065, 7, 82, 2, 2, 1065,
	1066, 5, 256, 129, 2, 1066, 1067, 7, 84, 2, 2, 1067, 1068, 5, 162, 82,
	2, 1068, 1108, 3, 2, 2, 2, 1069, 1070, 7, 145, 2, 2, 1070, 1071, 5, 256,
	129, 2, 1071, 1072, 7, 84, 2, 2, 1072, 1076, 5, 164, 83, 2, 1073, 1074,
	7, 390, 2, 2, 1074, 1075, 7, 327, 2, 2, 1075, 1077, 7, 391, 2, 2, 1076,
	1073, 3, 2, 2, 2, 1076, 1077, 3, 2, 2, 2, 1077, 1108, 3, 2, 2, 2, 1078,
	1079, 7, 146, 2, 2, 1079, 1080, 5, 256, 129, 2, 1080, 1081, 7, 84, 2, 2,
	1081, 1085, 5, 164, 83, 2, 1082, 1083, 7, 390, 2, 2, 1083, 1084, 7, 327,
	2, 2, 1084, 1086, 7, 391, 2, 2, 1085, 1082, 3, 2, 2, 2, 1085, 1086, 3,
	2, 2, 2, 1086, 1108, 3, 2, 2, 2, 1087, 1088, 5, 256, 129, 2, 1088, 1089,
	7, 269, 2, 2, 1089, 1090, 7, 145, 2, 2, 1090, 1091, 5, 256, 129, 2, 1091,
	1092, 7, 84, 2, 2, 1092, 1093, 5, 164, 83, 2, 1093, 1108, 3, 2, 2, 2, 1094,
	1095, 7, 126, 2, 2, 1095, 1099, 5, 256, 129, 2, 1096, 1097, 7, 390, 2,
	2, 1097, 1098, 7, 125, 2, 2, 1098, 1100, 7, 391, 2, 2, 1099, 1096, 3, 2,
	2, 2, 1099, 1100, 3, 2, 2, 2, 1100, 1108, 3, 2, 2, 2, 1101, 1102, 7, 214,
	2, 2, 1102, 1108, 5, 256, 129, 2, 1103, 1104, 7, 213, 2, 2, 1104, 1108,
	5, 256, 129, 2, 1105, 1106, 7, 157, 2, 2, 1106, 1108, 5, 258, 130, 2, 1107,
	1025, 3, 2, 2, 2, 1107, 1030, 3, 2, 2, 2, 1107, 1037, 3, 2, 2, 2, 1107,
	1042, 3, 2, 2, 2, 1107, 1049, 3, 2, 2, 2, 1107, 1054, 3, 2, 2, 2, 1107,
	1059, 3, 2, 2, 2, 1107, 1064, 3, 2, 2, 2, 1107, 1069, 3, 2, 2, 2, 1107,
	1078, 3, 2, 2, 2, 1107, 1087, 3, 2, 2, 2, 1107, 1094, 3, 2, 2, 2, 1107,
	1101, 3, 2, 2, 2, 1107, 1103, 3, 2, 2, 2, 1107, 1105, 3, 2, 2, 2, 1108,
	161, 3, 2, 2, 2, 1109, 1114, 5, 256, 129, 2, 1110, 1114, 5, 58, 30, 2,
	1111, 1112, 7, 380, 2, 2, 1112, 1114, 5, 58, 30, 2, 1113, 1109, 3, 2, 2,
	2, 1113, 1110, 3, 2, 2, 2, 1113, 1111, 3, 2, 2, 2, 1114, 163, 3, 2, 2,
	2, 1115, 1118, 5, 256, 129, 2, 1116, 1118, 5, 166, 84, 2, 1117, 1115, 3,
	2, 2, 2, 1117, 1116, 3, 2, 2, 2, 1118, 165, 3, 2, 2, 2, 1119, 1120, 7,
	5, 2, 2, 1120, 1121, 7, 388, 2, 2, 1121, 1122, 7, 5, 2, 2, 1122, 167, 3,
	2, 2, 2, 1123, 1124, 9, 6, 2, 2, 1124, 169, 3, 2, 2, 2, 1125, 1128, 5,
	172, 87, 2, 1126, 1128, 5, 174, 88, 2, 1127, 1125, 3, 2, 2, 2, 1127, 1126,
	3, 2, 2, 2, 1128, 171, 3, 2, 2, 2, 1129, 1130, 5, 256, 129, 2, 1130, 1131,
	7, 384, 2, 2, 1131, 1132, 5, 256, 129, 2, 1132, 1133, 7, 379, 2, 2, 1133,
	1134, 5, 256, 129, 2, 1134, 1135, 7, 387, 2, 2, 1135, 1136, 5, 256, 129,
	2, 1136, 1137, 7, 384, 2, 2, 1137, 1138, 5, 256, 129, 2, 1138, 1139, 7,
	380, 2, 2, 1139, 1140, 5, 256, 129, 2, 1140, 173, 3, 2, 2, 2, 1141, 1144,
	5, 146, 74, 2, 1142, 1143, 7, 387, 2, 2, 1143, 1145, 5, 138, 70, 2, 1144,
	1142, 3, 2, 2, 2, 1145, 1146, 3, 2, 2, 2, 1146, 1144, 3, 2, 2, 2, 1146,
	1147, 3, 2, 2, 2, 1147, 1156, 3, 2, 2, 2, 1148, 1151, 5, 142, 72, 2, 1149,
	1150, 7, 387, 2, 2, 1150, 1152, 5, 142, 72, 2, 1151, 1149, 3, 2, 2, 2,
	1152, 1153, 3, 2, 2, 2, 1153, 1151, 3, 2, 2, 2, 1153, 1154, 3, 2, 2, 2,
	1154, 1156, 3, 2, 2, 2, 1155, 1141, 3, 2, 2, 2, 1155, 1148, 3, 2, 2, 2,
	1156, 175, 3, 2, 2, 2, 1157, 1169, 5, 178, 90, 2, 1158, 1169, 5, 182, 92,
	2, 1159, 1169, 5, 186, 94, 2, 1160, 1169, 5, 196, 99, 2, 1161, 1169, 5,
	198, 100, 2, 1162, 1169, 5, 200, 101, 2, 1163, 1169, 5, 202, 102, 2, 1164,
	1169, 5, 204, 103, 2, 1165, 1169, 5, 206, 104, 2, 1166, 1169, 5, 190, 96,
	2, 1167, 1169, 5, 194, 98, 2, 1168, 1157, 3, 2, 2, 2, 1168, 1158, 3, 2,
	2, 2, 1168, 1159, 3, 2, 2, 2, 1168, 1160, 3, 2, 2, 2, 1168, 1161, 3, 2,
	2, 2, 1168, 1162, 3, 2, 2, 2, 1168, 1163, 3, 2, 2, 2, 1168, 1164, 3, 2,
	2, 2, 1168, 1165, 3, 2, 2, 2, 1168, 1166, 3, 2, 2, 2, 1168, 1167, 3, 2,
	2, 2, 1169, 177, 3, 2, 2, 2, 1170, 1171, 7, 186, 2, 2, 1171, 1172, 5, 280,
	141, 2, 1172, 1173, 5, 180, 91, 2, 1173, 179, 3, 2, 2, 2, 1174, 1177, 5,
	196, 99, 2, 1175, 1177, 5, 198, 100, 2, 1176, 1174, 3, 2, 2, 2, 1176, 1175,
	3, 2, 2, 2, 1177, 181, 3, 2, 2, 2, 1178, 1179, 7, 186, 2, 2, 1179, 1180,
	5, 280, 141, 2, 1180, 1181, 5, 184, 93, 2, 1181, 1182, 7, 387, 2, 2, 1182,
	1183, 7, 118, 2, 2, 1183, 1184, 5, 60, 31, 2, 1184, 183, 3, 2, 2, 2, 1185,
	1190, 5, 200, 101, 2, 1186, 1190, 5, 202, 102, 2, 1187, 1190, 5, 204, 103,
	2, 1188, 1190, 5, 206, 104, 2, 1189, 1185, 3, 2, 2, 2, 1189, 1186, 3, 2,
	2, 2, 1189, 1187, 3, 2, 2, 2, 1189, 1188, 3, 2, 2, 2, 1190, 185, 3, 2,
	2, 2, 1191, 1192, 7, 186, 2, 2, 1192, 1193, 5, 280, 141, 2, 1193, 1194,
	7, 191, 2, 2, 1194, 1195, 5, 188, 95, 2, 1195, 1196, 7, 387, 2, 2, 1196,
	1200, 7, 118, 2, 2, 1197, 1198, 5, 60, 31, 2, 1198, 1199, 7, 387, 2, 2,
	1199, 1201, 3, 2, 2, 2, 1200, 1197, 3, 2, 2, 2, 1200, 1201, 3, 2, 2, 2,
	1201, 1202, 3, 2, 2, 2, 1202, 1203, 5, 70, 36, 2, 1203, 187, 3, 2, 2, 2,
	1204, 1207, 5, 102, 52, 2, 1205, 1207, 5, 212, 107, 2, 1206, 1204, 3, 2,
	2, 2, 1206, 1205, 3, 2, 2, 2, 1207, 189, 3, 2, 2, 2, 1208, 1209, 7, 211,
	2, 2, 1209, 1210, 7, 384, 2, 2, 1210, 1211, 5, 192, 97, 2, 1211, 1212,
	7, 387, 2, 2, 1212, 1213, 7, 113, 2, 2, 1213, 1214, 5, 208, 105, 2, 1214,
	1215, 7, 364, 2, 2, 1215, 1216, 7, 210, 2, 2, 1216, 191, 3, 2, 2, 2, 1217,
	1220, 5, 50, 26, 2, 1218, 1220, 5, 278, 140, 2, 1219, 1217, 3, 2, 2, 2,
	1219, 1218, 3, 2, 2, 2, 1220, 193, 3, 2, 2, 2, 1221, 1222, 7, 113, 2, 2,
	1222, 1223, 5, 208, 105, 2, 1223, 1224, 7, 364, 2, 2, 1224, 1225, 5, 280,
	141, 2, 1225, 195, 3, 2, 2, 2, 1226, 1227, 7, 191, 2, 2, 1227, 1229, 5,
	214, 108, 2, 1228, 1230, 5, 216, 109, 2, 1229, 1228, 3, 2, 2, 2, 1229,
	1230, 3, 2, 2, 2, 1230, 197, 3, 2, 2, 2, 1231, 1232, 7, 87, 2, 2, 1232,
	1234, 5, 214, 108, 2, 1233, 1235, 5, 222, 112, 2, 1234, 1233, 3, 2, 2,
	2, 1234, 1235, 3, 2, 2, 2, 1235, 199, 3, 2, 2, 2, 1236, 1237, 7, 191, 2,
	2, 1237, 1239, 5, 188, 95, 2, 1238, 1240, 5, 216, 109, 2, 1239, 1238, 3,
	2, 2, 2, 1239, 1240, 3, 2, 2, 2, 1240, 1243, 3, 2, 2, 2, 1241, 1242, 7,
	387, 2, 2, 1242, 1244, 5, 60, 31, 2, 1243, 1241, 3, 2, 2, 2, 1243, 1244,
	3, 2, 2, 2, 1244, 201, 3, 2, 2, 2, 1245, 1246, 7, 87, 2, 2, 1246, 1248,
	5, 188, 95, 2, 1247, 1249, 5, 222, 112, 2, 1248, 1247, 3, 2, 2, 2, 1248,
	1249, 3, 2, 2, 2, 1249, 1252, 3, 2, 2, 2, 1250, 1251, 7, 387, 2, 2, 1251,
	1253, 5, 60, 31, 2, 1252, 1250, 3, 2, 2, 2, 1252, 1253, 3, 2, 2, 2, 1253,
	203, 3, 2, 2, 2, 1254, 1256, 7, 323, 2, 2, 1255, 1257, 5, 224, 113, 2,
	1256, 1255, 3, 2, 2, 2, 1256, 1257, 3, 2, 2, 2, 1257, 1260, 3, 2, 2, 2,
	1258, 1259, 7, 387, 2, 2, 1259, 1261, 5, 60, 31, 2, 1260, 1258, 3, 2, 2,
	2, 1260, 1261, 3, 2, 2, 2, 1261, 205, 3, 2, 2, 2, 1262, 1264, 7, 322, 2,
	2, 1263, 1265, 5, 222, 112, 2, 1264, 1263, 3, 2, 2, 2, 1264, 1265, 3, 2,
	2, 2, 1265, 1268, 3, 2, 2, 2, 1266, 1267, 7, 387, 2, 2, 1267, 1269, 5,
	60, 31, 2, 1268, 1266, 3, 2, 2, 2, 1268, 1269, 3, 2, 2, 2, 1269, 207, 3,
	2, 2, 2, 1270, 1273, 5, 214, 108, 2, 1271, 1273, 5, 212, 107, 2, 1272,
	1270, 3, 2, 2, 2, 1272, 1271, 3, 2, 2, 2, 1273, 209, 3, 2, 2, 2, 1274,
	1277, 5, 102, 52, 2, 1275, 1277, 5, 212, 107, 2, 1276, 1274, 3, 2, 2, 2,
	1276, 1275, 3, 2, 2, 2, 1277, 211, 3, 2, 2, 2, 1278, 1279, 7, 390, 2, 2,
	1279, 1280, 7, 276, 2, 2, 1280, 1281, 7, 387, 2, 2, 1281, 1282, 5, 50,
	26, 2, 1282, 1283, 7, 391, 2, 2, 1283, 213, 3, 2, 2, 2, 1284, 1285, 5,
	50, 26, 2, 1285, 215, 3, 2, 2, 2, 1286, 1287, 5, 218, 110, 2, 1287, 217,
	3, 2, 2, 2, 1288, 1292, 7, 390, 2, 2, 1289, 1293, 5, 220, 111, 2, 1290,
	1293, 7, 208, 2, 2, 1291, 1293, 7, 89, 2, 2, 1292, 1289, 3, 2, 2, 2, 1292,
	1290, 3, 2, 2, 2, 1292, 1291, 3, 2, 2, 2, 1293, 1294, 3, 2, 2, 2, 1294,
	1295, 7, 391, 2, 2, 1295, 219, 3, 2, 2, 2, 1296, 1299, 7, 99, 2, 2, 1297,
	1298, 7, 387, 2, 2, 1298, 1300, 9, 8, 2, 2, 1299, 1297, 3, 2, 2, 2, 1299,
	1300, 3, 2, 2, 2, 1300, 221, 3, 2, 2, 2, 1301, 1302, 7, 390, 2, 2, 1302,
	1303, 7, 99, 2, 2, 1303, 1304, 7, 391, 2, 2, 1304, 223, 3, 2, 2, 2, 1305,
	1306, 5, 226, 114, 2, 1306, 225, 3, 2, 2, 2, 1307, 1310, 7, 390, 2, 2,
	1308, 1311, 5, 228, 115, 2, 1309, 1311, 7, 222, 2, 2, 1310, 1308, 3, 2,
	2, 2, 1310, 1309, 3, 2, 2, 2, 1311, 1312, 3, 2, 2, 2, 1312, 1313, 7, 391,
	2, 2, 1313, 227, 3, 2, 2, 2, 1314, 1317, 7, 99, 2, 2, 1315, 1316, 7, 387,
	2, 2, 1316, 1318, 7, 222, 2, 2, 1317, 1315, 3, 2, 2, 2, 1317, 1318, 3,
	2, 2, 2, 1318, 229, 3, 2, 2, 2, 1319, 1324, 5, 232, 117, 2, 1320, 1324,
	5, 236, 119, 2, 1321, 1324, 5, 240, 121, 2, 1322, 1324, 5, 242, 122, 2,
	1323, 1319, 3, 2, 2, 2, 1323, 1320, 3, 2, 2, 2, 1323, 1321, 3, 2, 2, 2,
	1323, 1322, 3, 2, 2, 2, 1324, 231, 3, 2, 2, 2, 1325, 1328, 5, 134, 68,
	2, 1326, 1328, 5, 136, 69, 2, 1327, 1325, 3, 2, 2, 2, 1327, 1326, 3, 2,
	2, 2, 1328, 1329, 3, 2, 2, 2, 1329, 1330, 7, 384, 2, 2, 1330, 1331, 5,
	278, 140, 2, 1331, 233, 3, 2, 2, 2, 1332, 1335, 5, 130, 66, 2, 1333, 1335,
	5, 132, 67, 2, 1334, 1332, 3, 2, 2, 2, 1334, 1333, 3, 2, 2, 2, 1335, 1336,
	3, 2, 2, 2, 1336, 1337, 7, 384, 2, 2, 1337, 1338, 5, 278, 140, 2, 1338,
	235, 3, 2, 2, 2, 1339, 1340, 5, 278, 140, 2, 1340, 1343, 7, 384, 2, 2,
	1341, 1344, 5, 134, 68, 2, 1342, 1344, 5, 136, 69, 2, 1343, 1341, 3, 2,
	2, 2, 1343, 1342, 3, 2, 2, 2, 1344, 237, 3, 2, 2, 2, 1345, 1346, 5, 278,
	140, 2, 1346, 1349, 7, 384, 2, 2, 1347, 1350, 5, 130, 66, 2, 1348, 1350,
	5, 132, 67, 2, 1349, 1347, 3, 2, 2, 2, 1349, 1348, 3, 2, 2, 2, 1350, 239,
	3, 2, 2, 2, 1351, 1354, 5, 118, 60, 2, 1352, 1354, 5, 120, 61, 2, 1353,
	1351, 3, 2, 2, 2, 1353, 1352, 3, 2, 2, 2, 1354, 1355, 3, 2, 2, 2, 1355,
	1356, 7, 384, 2, 2, 1356, 1357, 5, 50, 26, 2, 1357, 241, 3, 2, 2, 2, 1358,
	1359, 5, 244, 123, 2, 1359, 1360, 7, 384, 2, 2, 1360, 1361, 5, 50, 26,
	2, 1361, 243, 3, 2, 2, 2, 1362, 1378, 5, 276, 139, 2, 1363, 1378, 7, 276,
	2, 2, 1364, 1378, 7, 277, 2, 2, 1365, 1378, 7, 278, 2, 2, 1366, 1378, 7,
	144, 2, 2, 1367, 1378, 7, 98, 2, 2, 1368, 1378, 7, 209, 2, 2, 1369, 1378,
	7, 97, 2, 2, 1370, 1378, 5, 274, 138, 2, 1371, 1378, 7, 296, 2, 2, 1372,
	1378, 7, 297, 2, 2, 1373, 1378, 7, 295, 2, 2, 1374, 1378, 7, 355, 2, 2,
	1375, 1378, 7, 352, 2, 2, 1376, 1378, 5, 260, 131, 2, 1377, 1362, 3, 2,
	2, 2, 1377, 1363, 3, 2, 2, 2, 1377, 1364, 3, 2, 2, 2, 1377, 1365, 3, 2,
	2, 2, 1377, 1366, 3, 2, 2, 2, 1377, 1367, 3, 2, 2, 2, 1377, 1368, 3, 2,
	2, 2, 1377, 1369, 3, 2, 2, 2, 1377, 1370, 3, 2, 2, 2, 1377, 1371, 3, 2,
	2, 2, 1377, 1372, 3, 2, 2, 2, 1377, 1373, 3, 2, 2, 2, 1377, 1374, 3, 2,
	2, 2, 1377, 1375, 3, 2, 2, 2, 1377, 1376, 3, 2, 2, 2, 1378, 245, 3, 2,
	2, 2, 1379, 1380, 7, 78, 2, 2, 1380, 1381, 9, 9, 2, 2, 1381, 1382, 5, 260,
	131, 2, 1382, 1383, 5, 50, 26, 2, 1383, 1423, 3, 2, 2, 2, 1384, 1387, 7,
	79, 2, 2, 1385, 1388, 5, 106, 54, 2, 1386, 1388, 5, 108, 55, 2, 1387, 1385,
	3, 2, 2, 2, 1387, 1386, 3, 2, 2, 2, 1388, 1423, 3, 2, 2, 2, 1389, 1390,
	7, 248, 2, 2, 1390, 1391, 7, 390, 2, 2, 1391, 1392, 5, 262, 132, 2, 1392,
	1393, 7, 387, 2, 2, 1393, 1394, 5, 50, 26, 2, 1394, 1395, 7, 391, 2, 2,
	1395, 1423, 3, 2, 2, 2, 1396, 1397, 7, 248, 2, 2, 1397, 1398, 7, 390, 2,
	2, 1398, 1399, 5, 266, 134, 2, 1399, 1400, 7, 387, 2, 2, 1400, 1401, 5,
	50, 26, 2, 1401, 1402, 7, 391, 2, 2, 1402, 1423, 3, 2, 2, 2, 1403, 1408,
	5, 248, 125, 2, 1404, 1405, 7, 387, 2, 2, 1405, 1407, 5, 248, 125, 2, 1406,
	1404, 3, 2, 2, 2, 1407, 1410, 3, 2, 2, 2, 1408, 1406, 3, 2, 2, 2, 1408,
	1409, 3, 2, 2, 2, 1409, 1423, 3, 2, 2, 2, 1410, 1408, 3, 2, 2, 2, 1411,
	1412, 7, 154, 2, 2, 1412, 1423, 7, 86, 2, 2, 1413, 1423, 7, 263, 2, 2,
	1414, 1423, 7, 182, 2, 2, 1415, 1423, 7, 183, 2, 2, 1416, 1417, 7, 90,
	2, 2, 1417, 1419, 5, 208, 105, 2, 1418, 1420, 5, 222, 112, 2, 1419, 1418,
	3, 2, 2, 2, 1419, 1420, 3, 2, 2, 2, 1420, 1423, 3, 2, 2, 2, 1421, 1423,
	7, 317, 2, 2, 1422, 1379, 3, 2, 2, 2, 1422, 1384, 3, 2, 2, 2, 1422, 1389,
	3, 2, 2, 2, 1422, 1396, 3, 2, 2, 2, 1422, 1403, 3, 2, 2, 2, 1422, 1411,
	3, 2, 2, 2, 1422, 1413, 3, 2, 2, 2, 1422, 1414, 3, 2, 2, 2, 1422, 1415,
	3, 2, 2, 2, 1422, 1416, 3, 2, 2, 2, 1422, 1421, 3, 2, 2, 2, 1423, 247,
	3, 2, 2, 2, 1424, 1425, 9, 10, 2, 2, 1425, 1426, 9, 11, 2, 2, 1426, 249,
	3, 2, 2, 2, 1427, 1428, 7, 10, 2, 2, 1428, 1494, 7, 5, 2, 2, 1429, 1494,
	7, 11, 2, 2, 1430, 1431, 7, 15, 2, 2, 1431, 1436, 7, 427, 2, 2, 1432, 1433,
	7, 387, 2, 2, 1433, 1435, 7, 427, 2, 2, 1434, 1432, 3, 2, 2, 2, 1435, 1438,
	3, 2, 2, 2, 1436, 1434, 3, 2, 2, 2, 1436, 1437, 3, 2, 2, 2, 1437, 1494,
	3, 2, 2, 2, 1438, 1436, 3, 2, 2, 2, 1439, 1440, 7, 16, 2, 2, 1440, 1494,
	7, 3, 2, 2, 1441, 1442, 7, 17, 2, 2, 1442, 1494, 11, 2, 2, 2, 1443, 1494,
	7, 18, 2, 2, 1444, 1445, 7, 19, 2, 2, 1445, 1450, 7, 427, 2, 2, 1446, 1447,
	7, 387, 2, 2, 1447, 1449, 7, 427, 2, 2, 1448, 1446, 3, 2, 2, 2, 1449, 1452,
	3, 2, 2, 2, 1450, 1448, 3, 2, 2, 2, 1450, 1451, 3, 2, 2, 2, 1451, 1494,
	3, 2, 2, 2, 1452, 1450, 3, 2, 2, 2, 1453, 1454, 7, 21, 2, 2, 1454, 1459,
	7, 3, 2, 2, 1455, 1456, 7, 387, 2, 2, 1456, 1458, 7, 3, 2, 2, 1457, 1455,
	3, 2, 2, 2, 1458, 1461, 3, 2, 2, 2, 1459, 1457, 3, 2, 2, 2, 1459, 1460,
	3, 2, 2, 2, 1460, 1494, 3, 2, 2, 2, 1461, 1459, 3, 2, 2, 2, 1462, 1463,
	7, 23, 2, 2, 1463, 1494, 5, 50, 26, 2, 1464, 1494, 7, 24, 2, 2, 1465, 1494,
	7, 25, 2, 2, 1466, 1494, 7, 26, 2, 2, 1467, 1468, 7, 27, 2, 2, 1468, 1494,
	5, 50, 26, 2, 1469, 1470, 7, 28, 2, 2, 1470, 1494, 5, 50, 26, 2, 1471,
	1494, 7, 29, 2, 2, 1472, 1494, 7, 30, 2, 2, 1473, 1494, 7, 31, 2, 2, 1474,
	1494, 7, 32, 2, 2, 1475, 1494, 7, 33, 2, 2, 1476, 1494, 7, 34, 2, 2, 1477,
	1478, 7, 35, 2, 2, 1478, 1494, 5, 50, 26, 2, 1479, 1480, 7, 36, 2, 2, 1480,
	1494, 5, 50, 26, 2, 1481, 1483, 7, 37, 2, 2, 1482, 1484, 7, 384, 2, 2,
	1483, 1482, 3, 2, 2, 2, 1483, 1484, 3, 2, 2, 2, 1484, 1485, 3, 2, 2, 2,
	1485, 1494, 7, 5, 2, 2, 1486, 1494, 7, 38, 2, 2, 1487, 1494, 7, 39, 2,
	2, 1488, 1494, 7, 40, 2, 2, 1489, 1494, 7, 41, 2, 2, 1490, 1494, 7, 42,
	2, 2, 1491, 1492, 7, 49, 2, 2, 1492, 1494, 7, 427, 2, 2, 1493, 1427, 3,
	2, 2, 2, 1493, 1429, 3, 2, 2, 2, 1493, 1430, 3, 2, 2, 2, 1493, 1439, 3,
	2, 2, 2, 1493, 1441, 3, 2, 2, 2, 1493, 1443, 3, 2, 2, 2, 1493, 1444, 3,
	2, 2, 2, 1493, 1453, 3, 2, 2, 2, 1493, 1462, 3, 2, 2, 2, 1493, 1464, 3,
	2, 2, 2, 1493, 1465, 3, 2, 2, 2, 1493, 1466, 3, 2, 2, 2, 1493, 1467, 3,
	2, 2, 2, 1493, 1469, 3, 2, 2, 2, 1493, 1471, 3, 2, 2, 2, 1493, 1472, 3,
	2, 2, 2, 1493, 1473, 3, 2, 2, 2, 1493, 1474, 3, 2, 2, 2, 1493, 1475, 3,
	2, 2, 2, 1493, 1476, 3, 2, 2, 2, 1493, 1477, 3, 2, 2, 2, 1493, 1479, 3,
	2, 2, 2, 1493, 1481, 3, 2, 2, 2, 1493, 1486, 3, 2, 2, 2, 1493, 1487, 3,
	2, 2, 2, 1493, 1488, 3, 2, 2, 2, 1493, 1489, 3, 2, 2, 2, 1493, 1490, 3,
	2, 2, 2, 1493, 1491, 3, 2, 2, 2, 1494, 251, 3, 2, 2, 2, 1495, 1496, 9,
	12, 2, 2, 1496, 253, 3, 2, 2, 2, 1497, 1498, 9, 13, 2, 2, 1498, 255, 3,
	2, 2, 2, 1499, 1500, 9, 14, 2, 2, 1500, 257, 3, 2, 2, 2, 1501, 1502, 9,
	15, 2, 2, 1502, 259, 3, 2, 2, 2, 1503, 1504, 9, 16, 2, 2, 1504, 261, 3,
	2, 2, 2, 1505, 1506, 9, 17, 2, 2, 1506, 263, 3, 2, 2, 2, 1507, 1508, 9,
	18, 2, 2, 1508, 265, 3, 2, 2, 2, 1509, 1510, 9, 19, 2, 2, 1510, 267, 3,
	2, 2, 2, 1511, 1512, 9, 20, 2, 2, 1512, 269, 3, 2, 2, 2, 1513, 1516, 5,
	262, 132, 2, 1514, 1516, 5, 266, 134, 2, 1515, 1513, 3, 2, 2, 2, 1515,
	1514, 3, 2, 2, 2, 1516, 271, 3, 2, 2, 2, 1517, 1520, 5, 264, 133, 2, 1518,
	1520, 5, 268, 135, 2, 1519, 1517, 3, 2, 2, 2, 1519, 1518, 3, 2, 2, 2, 1520,
	273, 3, 2, 2, 2, 1521, 1526, 5, 270, 136, 2, 1522, 1526, 5, 272, 137, 2,
	1523, 1526, 5, 252, 127, 2, 1524, 1526, 5, 254, 128, 2, 1525, 1521, 3,
	2, 2, 2, 1525, 1522, 3, 2, 2, 2, 1525, 1523, 3, 2, 2, 2, 1525, 1524, 3,
	2, 2, 2, 1526, 275, 3, 2, 2, 2, 1527, 1530, 5, 256, 129, 2, 1528, 1530,
	5, 258, 130, 2, 1529, 1527, 3, 2, 2, 2, 1529, 1528, 3, 2, 2, 2, 1530, 277,
	3, 2, 2, 2, 1531, 1548, 5, 276, 139, 2, 1532, 1548, 7, 276, 2, 2, 1533,
	1548, 7, 277, 2, 2, 1534, 1548, 7, 278, 2, 2, 1535, 1548, 7, 144, 2, 2,
	1536, 1548, 7, 98, 2, 2, 1537, 1548, 7, 209, 2, 2, 1538, 1548, 7, 97, 2,
	2, 1539, 1548, 7, 211, 2, 2, 1540, 1548, 5, 274, 138, 2, 1541, 1548, 7,
	296, 2, 2, 1542, 1548, 7, 297, 2, 2, 1543, 1548, 7, 295, 2, 2, 1544, 1548,
	7, 355, 2, 2, 1545, 1548, 7, 352, 2, 2, 1546, 1548, 5, 260, 131, 2, 1547,
	1531, 3, 2, 2, 2, 1547, 1532, 3, 2, 2, 2, 1547, 1533, 3, 2, 2, 2, 1547,
	1534, 3, 2, 2, 2, 1547, 1535, 3, 2, 2, 2, 1547, 1536, 3, 2, 2, 2, 1547,
	1537, 3, 2, 2, 2, 1547, 1538, 3, 2, 2, 2, 1547, 1539, 3, 2, 2, 2, 1547,
	1540, 3, 2, 2, 2, 1547, 1541, 3, 2, 2, 2, 1547, 1542, 3, 2, 2, 2, 1547,
	1543, 3, 2, 2, 2, 1547, 1544, 3, 2, 2, 2, 1547, 1545, 3, 2, 2, 2, 1547,
	1546, 3, 2, 2, 2, 1548, 279, 3, 2, 2, 2, 1549, 1550, 5, 282, 142, 2, 1550,
	281, 3, 2, 2, 2, 1551, 1598, 7, 124, 2, 2, 1552, 1598, 7, 224, 2, 2, 1553,
	1598, 7, 212, 2, 2, 1554, 1598, 7, 51, 2, 2, 1555, 1598, 7, 58, 2, 2, 1556,
	1598, 7, 258, 2, 2, 1557, 1598, 7, 257, 2, 2, 1558, 1598, 7, 348, 2, 2,
	1559, 1598, 7, 350, 2, 2, 1560, 1598, 7, 149, 2, 2, 1561, 1598, 7, 150,
	2, 2, 1562, 1598, 7, 151, 2, 2, 1563, 1598, 7, 152, 2, 2, 1564, 1598, 7,
	353, 2, 2, 1565, 1598, 7, 80, 2, 2, 1566, 1598, 7, 210, 2, 2, 1567, 1568,
	7, 265, 2, 2, 1568, 1598, 7, 210, 2, 2, 1569, 1598, 7, 260, 2, 2, 1570,
	1598, 7, 164, 2, 2, 1571, 1598, 7, 165, 2, 2, 1572, 1573, 7, 265, 2, 2,
	1573, 1598, 7, 51, 2, 2, 1574, 1575, 7, 265, 2, 2, 1575, 1598, 7, 58, 2,
	2, 1576, 1577, 7, 265, 2, 2, 1577, 1598, 7, 258, 2, 2, 1578, 1579, 7, 265,
	2, 2, 1579, 1598, 7, 257, 2, 2, 1580, 1581, 7, 265, 2, 2, 1581, 1598, 7,
	348, 2, 2, 1582, 1583, 7, 265, 2, 2, 1583, 1598, 7, 350, 2, 2, 1584, 1585,
	7, 265, 2, 2, 1585, 1598, 7, 149, 2, 2, 1586, 1587, 7, 265, 2, 2, 1587,
	1598, 7, 150, 2, 2, 1588, 1589, 7, 265, 2, 2, 1589, 1598, 7, 151, 2, 2,
	1590, 1591, 7, 265, 2, 2, 1591, 1598, 7, 152, 2, 2, 1592, 1593, 7, 265,
	2, 2, 1593, 1598, 7, 353, 2, 2, 1594, 1598, 7, 259, 2, 2, 1595, 1598, 7,
	156, 2, 2, 1596, 1598, 7, 356, 2, 2, 1597, 1551, 3, 2, 2, 2, 1597, 1552,
	3, 2, 2, 2, 1597, 1553, 3, 2, 2, 2, 1597, 1554, 3, 2, 2, 2, 1597, 1555,
	3, 2, 2, 2, 1597, 1556, 3, 2, 2, 2, 1597, 1557, 3, 2, 2, 2, 1597, 1558,
	3, 2, 2, 2, 1597, 1559, 3, 2, 2, 2, 1597, 1560, 3, 2, 2, 2, 1597, 1561,
	3, 2, 2, 2, 1597, 1562, 3, 2, 2, 2, 1597, 1563, 3, 2, 2, 2, 1597, 1564,
	3, 2, 2, 2, 1597, 1565, 3, 2, 2, 2, 1597, 1566, 3, 2, 2, 2, 1597, 1567,
	3, 2, 2, 2, 1597, 1569, 3, 2, 2, 2, 1597, 1570, 3, 2, 2, 2, 1597, 1571,
	3, 2, 2, 2, 1597, 1572, 3, 2, 2, 2, 1597, 1574, 3, 2, 2, 2, 1597, 1576,
	3, 2, 2, 2, 1597, 1578, 3, 2, 2, 2, 1597, 1580, 3, 2, 2, 2, 1597, 1582,
	3, 2, 2, 2, 1597, 1584, 3, 2, 2, 2, 1597, 1586, 3, 2, 2, 2, 1597, 1588,
	3, 2, 2, 2, 1597, 1590, 3, 2, 2, 2, 1597, 1592, 3, 2, 2, 2, 1597, 1594,
	3, 2, 2, 2, 1597, 1595, 3, 2, 2, 2, 1597, 1596, 3, 2, 2, 2, 1598, 283,
	3, 2, 2, 2, 1599, 1600, 5, 286, 144, 2, 1600, 285, 3, 2, 2, 2, 1601, 1602,
	7, 390, 2, 2, 1602, 1603, 9, 21, 2, 2, 1603, 1604, 7, 391, 2, 2, 1604,
	287, 3, 2, 2, 2, 1605, 1606, 5, 290, 146, 2, 1606, 289, 3, 2, 2, 2, 1607,
	1608, 7, 390, 2, 2, 1608, 1609, 9, 22, 2, 2, 1609, 1610, 7, 391, 2, 2,
	1610, 291, 3, 2, 2, 2, 1611, 1612, 9, 23, 2, 2, 1612, 293, 3, 2, 2, 2,
	1613, 1614, 9, 24, 2, 2, 1614, 295, 3, 2, 2, 2, 1615, 1616, 9, 25, 2, 2,
	1616, 297, 3, 2, 2, 2, 1617, 1618, 9, 26, 2, 2, 1618, 299, 3, 2, 2, 2,
	1619, 1620, 9, 27, 2, 2, 1620, 301, 3, 2, 2, 2, 1621, 1622, 9, 28, 2, 2,
	1622, 303, 3, 2, 2, 2, 1623, 1624, 9, 29, 2, 2, 1624, 305, 3, 2, 2, 2,
	1625, 1626, 9, 30, 2, 2, 1626, 307, 3, 2, 2, 2, 1627, 1628, 9, 31, 2, 2,
	1628, 309, 3, 2, 2, 2, 1629, 1630, 9, 32, 2, 2, 1630, 311, 3, 2, 2, 2,
	1631, 1632, 9, 33, 2, 2, 1632, 313, 3, 2, 2, 2, 117, 319, 326, 329, 336,
	351, 356, 361, 363, 368, 389, 397, 404, 413, 421, 429, 440, 444, 451, 455,
	463, 472, 476, 485, 490, 497, 505, 510, 523, 537, 547, 551, 558, 567, 573,
	577, 588, 598, 607, 622, 679, 722, 815, 821, 823, 836, 885, 918, 936, 945,
	947, 953, 963, 968, 971, 981, 986, 988, 998, 1003, 1005, 1023, 1076, 1085,
	1099, 1107, 1113, 1117, 1127, 1146, 1153, 1155, 1168, 1176, 1189, 1200,
	1206, 1219, 1229, 1234, 1239, 1243, 1248, 1252, 1256, 1260, 1264, 1268,
	1272, 1276, 1292, 1299, 1310, 1317, 1323, 1327, 1334, 1343, 1349, 1353,
	1377, 1387, 1408, 1419, 1422, 1436, 1450, 1459, 1483, 1493, 1515, 1519,
	1525, 1529, 1547, 1597,
}
var literalNames = []string{
	"", "", "", "", "", "'_ADI_'", "'_DATE_'", "'_FILE'", "'.align'", "'.compress'",
	"'.elif'", "'.else'", "'.endif'", "'.extern'", "'.file'", "'.file_attr'",
	"'.forcecompress'", "'.global'", "'.if'", "'.import'", "'.inc/binary'",
	"'.leftmargin'", "'.list'", "'.list_data'", "'.list_datfile'", "'.list_deftab'",
	"'.list_loctab'", "'.list_wrapdata'", "'.newpage'", "'.nocompress'", "'.nolist_data'",
	"'.nolist_datfile'", "'.nolist_wrapdata'", "'.pagelength'", "'.pagewidth'",
	"'.precision'", "'.round_minus'", "'.round_nearest'", "'.round_plus'",
	"'.round_zero'", "'.previous'", "'.section'", "'.segment'", "'.endseg'",
	"'.struct'", "'.type'", "'.var'", "'.weak'", "'abs'", "'ac'", "'acs'",
	"'act'", "'address'", "'and'", "'ashift'", "'astat'", "'av'", "'b0'", "'b1'",
	"'b2'", "'b3'", "'b4'", "'b5'", "'b6'", "'b7'", "'b8'", "'b9'", "'b10'",
	"'b11'", "'b12'", "'b13'", "'b14'", "'b15'", "'bb'", "'bclr'", "'bf'",
	"'bit'", "'bitrev'", "'bm'", "'bset'", "'btgl'", "'btst'", "'by'", "'ca'",
	"'cache'", "'call'", "'ch'", "'ci'", "'cjump'", "'cl'", "'clr'", "'clip'",
	"'comp'", "'copysign'", "'cos'", "'curlcntr'", "'daddr'", "'db'", "'dec'",
	"'def'", "'dim'", "'dm'", "'dm1e'", "'dm1s'", "'dm2e'", "'dm2s'", "'dmadr'",
	"'dmabank1'", "'dmabank2'", "'dmabank3'", "'dmawait'", "'do'", "'dovl'",
	"'eb'", "'ece'", "'ef'", "'else'", "'emuclk'", "'emuclk2'", "'emuidle'",
	"'emun'", "'eos'", "'eq'", "'ex'", "'exp'", "'exp2'", "'f0'", "'f1'", "'f2'",
	"'f3'", "'f4'", "'f5'", "'f6'", "'f7'", "'f8'", "'f9'", "'f10'", "'f11'",
	"'f12'", "'f13'", "'f14'", "'f15'", "'faddr'", "'fdep'", "'fext'", "'file'",
	"'fix'", "'flag0_in'", "'flag1_in'", "'flag2_in'", "'flag3_in'", "'float'",
	"'flush'", "'fmerg'", "'forever'", "'fpack'", "'fractional'", "'fta'",
	"'ftb'", "'ftc'", "'funpack'", "'gcc_compiled'", "'ge'", "'gt'", "'i0'",
	"'i1'", "'i2'", "'i3'", "'i4'", "'i5'", "'i6'", "'i7'", "'i8'", "'i9'",
	"'i10'", "'i11'", "'i12'", "'i13'", "'i14'", "'i15'", "'idle'", "'idle16'",
	"'idlei15'", "'idlei16'", "'if'", "'imask'", "'imaskp'", "'inc'", "'irptl'",
	"'jump'", "'l0'", "'l1'", "'l2'", "'l3'", "'l4'", "'l5'", "'l6'", "'l7'",
	"'l8'", "'l9'", "'l10'", "'l11'", "'l12'", "'l13'", "'l14'", "'l15'", "'la'",
	"'laddr'", "'lce'", "'lcntr'", "'le'", "'lefto'", "'leftz'", "'length'",
	"'line'", "'ln'", "'load'", "'log2'", "'logb'", "'loop'", "'lr'", "'lshift'",
	"'lt'", "'m0'", "'m1'", "'m2'", "'m3'", "'m4'", "'m5'", "'m6'", "'m7'",
	"'m8'", "'m9'", "'m10'", "'m11'", "'m12'", "'m13'", "'m14'", "'m15'", "'mant'",
	"'max'", "'mbm'", "'min'", "'mod'", "'mode1'", "'mode2'", "'modify'", "'mr0b'",
	"'mr0f'", "'mr1b'", "'mr1f'", "'mr2b'", "'mr2f'", "'mrb'", "'mrf'", "'ms'",
	"'mv'", "'nbm'", "'ne'", "'nofo'", "'nofz'", "'nop'", "'nopspecial'", "'not'",
	"'nu'", "'nw'", "'offsetof'", "'or'", "'p20'", "'p32'", "'p40'", "'pack'",
	"'page'", "'pass'", "'pc'", "'pcstk'", "'pcstkp'", "'pm'", "'pmadr'", "'pmbank1'",
	"'pmdae'", "'pmdas'", "'pop'", "'povl0'", "'povl1'", "'psa1e'", "'psa1s'",
	"'psa2e'", "'psa3e'", "'psa3s'", "'psa4e'", "'psa4s'", "'push'", "'px'",
	"'px1'", "'px2'", "'retain_name'", "'r0'", "'r1'", "'r2'", "'r3'", "'r4'",
	"'r5'", "'r6'", "'r7'", "'r8'", "'r9'", "'r10'", "'r11'", "'r12'", "'r13'",
	"'r14'", "'r15'", "'read'", "'recips'", "'rframe'", "'rnd'", "'rot'", "'rs'",
	"'rsqrts'", "'rti'", "'rts'", "'sat'", "'scalb'", "'scl'", "'se'", "'set'",
	"'sf'", "'si'", "'sin'", "'size'", "'sizeof'", "'sqr'", "'sr'", "'ssf'",
	"'ssfr'", "'ssi'", "'ssir'", "'st'", "'step'", "'stky'", "'struct'", "'sts'",
	"'suf'", "'sufr'", "'sui'", "'sv'", "'sw'", "'sz'", "'tag'", "'tcount'",
	"'tf'", "'tgl'", "'tperiod'", "'true'", "'trunc'", "'tst'", "'type'", "'trap'",
	"'uf'", "'ui'", "'unpack'", "'until'", "'ur'", "'usf'", "'usfr'", "'usi'",
	"'usir'", "'ustat1'", "'ustat2'", "'uuf'", "'uufr'", "'uui'", "'uuir'",
	"'val'", "'with'", "'xor'", "'+'", "'-'", "'*'", "'/'", "'%'", "'='", "'|'",
	"'^'", "','", "':'", "';'", "'('", "')'", "'['", "']'", "'{'", "'}'", "'@'",
	"'no_init'", "'zero_init'", "'runtime_init'", "'code'", "'data'", "'data64'",
	"'dmaonly'", "'SECTION'", "'SECTION_INFO'", "'STMT'", "'ADDR'", "'BIT_DATA'",
	"'JUMP_INT'", "'JUMP_PC'", "'JUMP_MD'", "'MODIFIER'", "'MULTI_MOD'", "'LABLE'",
	"'VARDEF'", "'ARRDEF'", "'DM_ACCESS'", "'PM_ACCESS'", "'CONDITION'", "'IF_STMT'",
	"'VALUE_EXP'", "'NULL'", "'CHAR_LITERAL'", "'STR_LITERAL'", "'DIRECTIVE'",
	"'NEGATE'",
}
var symbolicNames = []string{
	"", "StringLiteral", "CharLiteral", "INT", "WS", "DOT_ADI_", "DOT_DATE_",
	"DOT_FILE_", "DOT_ALGIGN", "DOT_COMPRESS", "DOT_ELIF", "DOT_ELSE", "DOT_ENDIF",
	"DOT_EXTERN", "DOT_FILE", "DOT_FILE_ATTR", "DOT_FORCECOMPRESS", "DOT_GLOBAL",
	"DOT_IF", "DOT_IMPORT", "DOT_INCBINARY", "DOT_LEFTMARGIN", "DOT_LIST",
	"DOT_LIST_DATA", "DOT_LIST_DATFILE", "DOT_LIST_DEFTAB", "DOT_LIST_LOCTAB",
	"DOT_LIST_WRAPDATA", "DOT_NEWPAGE", "DOT_NOCOMPRESS", "DOT_NOLIST_DATA",
	"DOT_NOLIST_DATFILE", "DOT_NOLIST_WRAPDATA", "DOT_PAGELENGTH", "DOT_PAGEWIDTH",
	"DOT_PRECISION", "DOT_ROUND_MINUS", "DOT_ROUND_NEAREST", "DOT_ROUND_PLUS",
	"DOT_ROUND_ZERO", "DOT_PREVIOUS", "DOT_SECTION", "DOT_SEGMENT", "DOT_ENDSEG",
	"DOT_STRUCT", "DOT_TYPE", "DOT_VAR", "DOT_WEAK", "ABS", "AC", "ACS", "ACT",
	"ADDRESS", "AND", "ASHIFT", "ASTAT", "AV", "B0", "B1", "B2", "B3", "B4",
	"B5", "B6", "B7", "B8", "B9", "B10", "B11", "B12", "B13", "B14", "B15",
	"BB", "BCLR", "BF", "BIT", "BITREV", "BM", "BSET", "BTGL", "BTST", "BY",
	"CA", "CACHE", "CALL", "CH", "CI", "CJUMP", "CL", "CLR", "CLIP", "COMP",
	"COPYSIGN", "COS", "CURLCNTR", "DADDR", "DB", "DEC", "DEF", "DIM", "DM",
	"DMA1E", "DMA1s", "DMA2E", "DMA2s", "DMADR", "DMABANK1", "DMABANK2", "DMABANK3",
	"DMAWAIT", "DO", "DOVL", "EB", "ECE", "EF", "ELSE", "EMUCLK", "EMUCLK2",
	"EMUIDLE", "EMUN", "EOS", "EQ", "EX", "EXP", "EXP2", "F0", "F1", "F2",
	"F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14",
	"F15", "FADDR", "FDEP", "FEXT", "FILE", "FIX", "FLAG0_IN", "FLAG1_IN",
	"FLAG2_IN", "FLAG3_IN", "FLOAT", "FLUSH", "FMERG", "FOREVER", "FPACK",
	"FRACTIONAL", "FTA", "FTB", "FTC", "FUNPACK", "GCC_COMPILED", "GE", "GT",
	"I0", "I1", "I2", "I3", "I4", "I5", "I6", "I7", "I8", "I9", "I10", "I11",
	"I12", "I13", "I14", "I15", "IDLE", "IDLE16", "IDLEI15", "IDLEI16", "IF",
	"IMASK", "IMASKP", "INC", "IRPTL", "JUMP", "L0", "L1", "L2", "L3", "L4",
	"L5", "L6", "L7", "L8", "L9", "L10", "L11", "L12", "L13", "L14", "L15",
	"LA", "LADDR", "LCE", "LCNTR", "LE", "LEFTO", "LEFTZ", "LENGTH", "LINE",
	"LN", "LOAD", "LOG2", "LOGB", "LOOP", "LR", "LSHIFT", "LT", "M0", "M1",
	"M2", "M3", "M4", "M5", "M6", "M7", "M8", "M9", "M10", "M11", "M12", "M13",
	"M14", "M15", "MANT", "MAX", "MBM", "MIN", "MOD", "MODE1", "MODE2", "MODIFY",
	"MR0B", "MR0F", "MR1B", "MR1F", "MR2B", "MR2F", "MRB", "MRF", "MS", "MV",
	"NBM", "NE", "NOFO", "NOFZ", "NOP", "NOPSPECIAL", "NOT", "NU", "NW", "OFFSETOF",
	"OR", "P20", "P32", "P40", "PACK", "PAGE", "PASS", "PC", "PCSTK", "PCSTKP",
	"PM", "PMADR", "PMBANK1", "PMDAE", "PMDAS", "POP", "POVL0", "POVL1", "PSA1E",
	"PSA1S", "PSA2E", "PSA3E", "PSA3S", "PSA4E", "PSA4S", "PUSH", "PX", "PX1",
	"PX2", "RETAIN_NAME", "R0", "R1", "R2", "R3", "R4", "R5", "R6", "R7", "R8",
	"R9", "R10", "R11", "R12", "R13", "R14", "R15", "READ", "RECIPS", "RFRAME",
	"RND", "ROT", "RS", "RSQRTS", "RTI", "RTS", "SAT", "SCALB", "SCL", "SE",
	"SET", "SF", "SI", "SIN", "SIZE", "SIZEOF", "SQR", "SR", "SSF", "SSFR",
	"SSI", "SSIR", "ST", "STEP", "STKY", "STRUCT", "STS", "SUF", "SUFR", "SUI",
	"SV", "SW", "SZ", "TAG", "TCOUNT", "TF", "TGL", "TPERIOD", "TRUE", "TRUNC",
	"TST", "TYPE", "TRAP", "UF", "UI", "UNPACK", "UNTIL", "UR", "USF", "USFR",
	"USI", "USIR", "USTAT1", "USTAT2", "UUF", "UUFR", "UUI", "UUIR", "VAL",
	"WITH", "XOR", "PLUS", "MINUS", "MULT", "DIV", "DIV_MOD", "EQU", "I_OR",
	"I_XOR", "COMMA", "COLON", "SEMICOLON", "LPARENTHESE", "RPARENTHESE", "LBRACKET",
	"RBRACKET", "LBRACE", "RBRACE", "AT", "NO_INIT", "ZERO_INIT", "RUNTIME_INIT",
	"CODE", "DATA", "DATA64", "DMAONLY", "SECTION", "SECTION_INFO", "STMT",
	"ADDR", "BIT_DATA", "JUMP_INT", "JUMP_PC", "JUMP_MD", "MODIFIER", "MULTI_MOD",
	"LABLE", "VARDEF", "ARRDEF", "DM_ACCESS", "PM_ACCESS", "CONDITION", "IF_STMT",
	"VALUE_EXP", "NULL_", "CHAR_LITERAL", "STR_LITERAL", "DIRECTIVE", "NEGATE",
	"ID", "COMMENT",
}

var ruleNames = []string{
	"prog", "statement", "stmt_atom", "sec", "seg", "end_seg", "seg_qualifier",
	"seg_qualifier1", "seg_qualifier2", "seg_qualifier3", "seg_qualifier_1",
	"seg_qualifier_2", "seg_qualifier_3", "stmt", "declaration", "declaration_exp1",
	"declaration_exp2", "declaration_exp3", "declaration_exp4", "declaration_exp5",
	"declaration_exp_f1", "declaration_exp_f2", "initExpression", "var_addr",
	"value_exp", "value_exp2", "term", "factor", "atom", "compute", "if_compute_mov",
	"if_compute_mov_exp", "compute_mov_exp", "mov_exp_1", "mov_exp_1_1", "mov_exp_1_2",
	"mov_exp_3a", "mov_exp_3b", "mov_exp_3c", "mov_exp_3d", "mov_exp_4a", "mov_exp_4b",
	"mov_exp_4c", "mov_exp_4d", "mov_exp_5", "mov_exp_6a", "mov_exp_6b", "mov_exp_7",
	"mem_addr_ia_mb", "mem_addr_ic_md", "mem_addr_md_ic", "mem_addr_mb_ia",
	"mem_addr_ia_int", "mem_addr_ic_int", "mem_addr_int_ia", "mem_addr_int_ic",
	"mem_addr_int", "mem_addr_int_", "mem_addr_dm_ia_mb", "mem_addr_pm_ic_md",
	"mem_addr_dm_mb_ia", "mem_addr_pm_md_ic", "mem_addr_dm_ia_int", "mem_addr_pm_ic_int",
	"mem_addr_dm_int_ia", "mem_addr_pm_int_ic", "mem_addr_dm_int", "mem_addr_pm_int",
	"fixpoint_alu_op", "r_exp", "floating_point_alu_op", "f_exp", "multi_op",
	"multi_r", "multi_exp_r", "multi_exp_mrf", "multi_exp_mrb", "mr", "shifter_op",
	"shifter_exp", "sec_op", "sec_op2", "bit_data", "add_or_sub", "dual_op",
	"dual_add_r", "parallel_multi", "flow_control_exp", "flow_contorl_8", "flow_contorl_8_exp",
	"flow_control_9_and_11", "flow_control_9_and_11_exp", "flow_control_10",
	"flow_control_10_frag", "flow_control_12", "lcntr_v", "flow_control_13",
	"flow_control_8a", "flow_control_8b", "flow_control_9a", "flow_control_9b",
	"flow_control_11a", "flow_control_11b", "jump_addr_int_or_pc", "jump_addr_md_or_pc",
	"jump_addr_pc", "jump_addr_int", "jump_modifier", "jump_modifier_", "jump_modifier_1",
	"jump_modifier2", "jump_modifier3", "jump_modifier3_", "jump_modifier3_1",
	"imm_mov_exp", "imm_mov_14a", "imm_mov_15a", "imm_mov_14b", "imm_mov_15b",
	"imm_mov_16", "imm_mov_17", "u_reg2", "misc_exp", "misc_20", "directive_exp",
	"b_reg", "l_reg", "r_reg", "f_reg", "s_reg", "ia", "mb", "ic", "md", "i_reg",
	"m_reg", "dag_reg", "d_reg", "u_reg", "condition", "ccondition", "multi_mod1",
	"multi_mod1_", "multi_mod2", "multi_mod2_", "r3_0", "r7_4", "r11_8", "r15_12",
	"f3_0", "f7_4", "f11_8", "f15_12", "addr", "mrf", "mrb",
}

type SHARCParser struct {
	*antlr.BaseParser
}

// NewSHARCParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *SHARCParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewSHARCParser(input antlr.TokenStream) *SHARCParser {
	this := new(SHARCParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SHARCParser.g4"

	return this
}

// SHARCParser tokens.
const (
	SHARCParserEOF                 = antlr.TokenEOF
	SHARCParserStringLiteral       = 1
	SHARCParserCharLiteral         = 2
	SHARCParserINT                 = 3
	SHARCParserWS                  = 4
	SHARCParserDOT_ADI_            = 5
	SHARCParserDOT_DATE_           = 6
	SHARCParserDOT_FILE_           = 7
	SHARCParserDOT_ALGIGN          = 8
	SHARCParserDOT_COMPRESS        = 9
	SHARCParserDOT_ELIF            = 10
	SHARCParserDOT_ELSE            = 11
	SHARCParserDOT_ENDIF           = 12
	SHARCParserDOT_EXTERN          = 13
	SHARCParserDOT_FILE            = 14
	SHARCParserDOT_FILE_ATTR       = 15
	SHARCParserDOT_FORCECOMPRESS   = 16
	SHARCParserDOT_GLOBAL          = 17
	SHARCParserDOT_IF              = 18
	SHARCParserDOT_IMPORT          = 19
	SHARCParserDOT_INCBINARY       = 20
	SHARCParserDOT_LEFTMARGIN      = 21
	SHARCParserDOT_LIST            = 22
	SHARCParserDOT_LIST_DATA       = 23
	SHARCParserDOT_LIST_DATFILE    = 24
	SHARCParserDOT_LIST_DEFTAB     = 25
	SHARCParserDOT_LIST_LOCTAB     = 26
	SHARCParserDOT_LIST_WRAPDATA   = 27
	SHARCParserDOT_NEWPAGE         = 28
	SHARCParserDOT_NOCOMPRESS      = 29
	SHARCParserDOT_NOLIST_DATA     = 30
	SHARCParserDOT_NOLIST_DATFILE  = 31
	SHARCParserDOT_NOLIST_WRAPDATA = 32
	SHARCParserDOT_PAGELENGTH      = 33
	SHARCParserDOT_PAGEWIDTH       = 34
	SHARCParserDOT_PRECISION       = 35
	SHARCParserDOT_ROUND_MINUS     = 36
	SHARCParserDOT_ROUND_NEAREST   = 37
	SHARCParserDOT_ROUND_PLUS      = 38
	SHARCParserDOT_ROUND_ZERO      = 39
	SHARCParserDOT_PREVIOUS        = 40
	SHARCParserDOT_SECTION         = 41
	SHARCParserDOT_SEGMENT         = 42
	SHARCParserDOT_ENDSEG          = 43
	SHARCParserDOT_STRUCT          = 44
	SHARCParserDOT_TYPE            = 45
	SHARCParserDOT_VAR             = 46
	SHARCParserDOT_WEAK            = 47
	SHARCParserABS                 = 48
	SHARCParserAC                  = 49
	SHARCParserACS                 = 50
	SHARCParserACT                 = 51
	SHARCParserADDRESS             = 52
	SHARCParserAND                 = 53
	SHARCParserASHIFT              = 54
	SHARCParserASTAT               = 55
	SHARCParserAV                  = 56
	SHARCParserB0                  = 57
	SHARCParserB1                  = 58
	SHARCParserB2                  = 59
	SHARCParserB3                  = 60
	SHARCParserB4                  = 61
	SHARCParserB5                  = 62
	SHARCParserB6                  = 63
	SHARCParserB7                  = 64
	SHARCParserB8                  = 65
	SHARCParserB9                  = 66
	SHARCParserB10                 = 67
	SHARCParserB11                 = 68
	SHARCParserB12                 = 69
	SHARCParserB13                 = 70
	SHARCParserB14                 = 71
	SHARCParserB15                 = 72
	SHARCParserBB                  = 73
	SHARCParserBCLR                = 74
	SHARCParserBF                  = 75
	SHARCParserBIT                 = 76
	SHARCParserBITREV              = 77
	SHARCParserBM                  = 78
	SHARCParserBSET                = 79
	SHARCParserBTGL                = 80
	SHARCParserBTST                = 81
	SHARCParserBY                  = 82
	SHARCParserCA                  = 83
	SHARCParserCACHE               = 84
	SHARCParserCALL                = 85
	SHARCParserCH                  = 86
	SHARCParserCI                  = 87
	SHARCParserCJUMP               = 88
	SHARCParserCL                  = 89
	SHARCParserCLR                 = 90
	SHARCParserCLIP                = 91
	SHARCParserCOMP                = 92
	SHARCParserCOPYSIGN            = 93
	SHARCParserCOS                 = 94
	SHARCParserCURLCNTR            = 95
	SHARCParserDADDR               = 96
	SHARCParserDB                  = 97
	SHARCParserDEC                 = 98
	SHARCParserDEF                 = 99
	SHARCParserDIM                 = 100
	SHARCParserDM                  = 101
	SHARCParserDMA1E               = 102
	SHARCParserDMA1s               = 103
	SHARCParserDMA2E               = 104
	SHARCParserDMA2s               = 105
	SHARCParserDMADR               = 106
	SHARCParserDMABANK1            = 107
	SHARCParserDMABANK2            = 108
	SHARCParserDMABANK3            = 109
	SHARCParserDMAWAIT             = 110
	SHARCParserDO                  = 111
	SHARCParserDOVL                = 112
	SHARCParserEB                  = 113
	SHARCParserECE                 = 114
	SHARCParserEF                  = 115
	SHARCParserELSE                = 116
	SHARCParserEMUCLK              = 117
	SHARCParserEMUCLK2             = 118
	SHARCParserEMUIDLE             = 119
	SHARCParserEMUN                = 120
	SHARCParserEOS                 = 121
	SHARCParserEQ                  = 122
	SHARCParserEX                  = 123
	SHARCParserEXP                 = 124
	SHARCParserEXP2                = 125
	SHARCParserF0                  = 126
	SHARCParserF1                  = 127
	SHARCParserF2                  = 128
	SHARCParserF3                  = 129
	SHARCParserF4                  = 130
	SHARCParserF5                  = 131
	SHARCParserF6                  = 132
	SHARCParserF7                  = 133
	SHARCParserF8                  = 134
	SHARCParserF9                  = 135
	SHARCParserF10                 = 136
	SHARCParserF11                 = 137
	SHARCParserF12                 = 138
	SHARCParserF13                 = 139
	SHARCParserF14                 = 140
	SHARCParserF15                 = 141
	SHARCParserFADDR               = 142
	SHARCParserFDEP                = 143
	SHARCParserFEXT                = 144
	SHARCParserFILE                = 145
	SHARCParserFIX                 = 146
	SHARCParserFLAG0_IN            = 147
	SHARCParserFLAG1_IN            = 148
	SHARCParserFLAG2_IN            = 149
	SHARCParserFLAG3_IN            = 150
	SHARCParserFLOAT               = 151
	SHARCParserFLUSH               = 152
	SHARCParserFMERG               = 153
	SHARCParserFOREVER             = 154
	SHARCParserFPACK               = 155
	SHARCParserFRACTIONAL          = 156
	SHARCParserFTA                 = 157
	SHARCParserFTB                 = 158
	SHARCParserFTC                 = 159
	SHARCParserFUNPACK             = 160
	SHARCParserGCC_COMPILED        = 161
	SHARCParserGE                  = 162
	SHARCParserGT                  = 163
	SHARCParserI0                  = 164
	SHARCParserI1                  = 165
	SHARCParserI2                  = 166
	SHARCParserI3                  = 167
	SHARCParserI4                  = 168
	SHARCParserI5                  = 169
	SHARCParserI6                  = 170
	SHARCParserI7                  = 171
	SHARCParserI8                  = 172
	SHARCParserI9                  = 173
	SHARCParserI10                 = 174
	SHARCParserI11                 = 175
	SHARCParserI12                 = 176
	SHARCParserI13                 = 177
	SHARCParserI14                 = 178
	SHARCParserI15                 = 179
	SHARCParserIDLE                = 180
	SHARCParserIDLE16              = 181
	SHARCParserIDLEI15             = 182
	SHARCParserIDLEI16             = 183
	SHARCParserIF                  = 184
	SHARCParserIMASK               = 185
	SHARCParserIMASKP              = 186
	SHARCParserINC                 = 187
	SHARCParserIRPTL               = 188
	SHARCParserJUMP                = 189
	SHARCParserL0                  = 190
	SHARCParserL1                  = 191
	SHARCParserL2                  = 192
	SHARCParserL3                  = 193
	SHARCParserL4                  = 194
	SHARCParserL5                  = 195
	SHARCParserL6                  = 196
	SHARCParserL7                  = 197
	SHARCParserL8                  = 198
	SHARCParserL9                  = 199
	SHARCParserL10                 = 200
	SHARCParserL11                 = 201
	SHARCParserL12                 = 202
	SHARCParserL13                 = 203
	SHARCParserL14                 = 204
	SHARCParserL15                 = 205
	SHARCParserLA                  = 206
	SHARCParserLADDR               = 207
	SHARCParserLCE                 = 208
	SHARCParserLCNTR               = 209
	SHARCParserLE                  = 210
	SHARCParserLEFTO               = 211
	SHARCParserLEFTZ               = 212
	SHARCParserLENGTH              = 213
	SHARCParserLINE                = 214
	SHARCParserLN                  = 215
	SHARCParserLOAD                = 216
	SHARCParserLOG2                = 217
	SHARCParserLOGB                = 218
	SHARCParserLOOP                = 219
	SHARCParserLR                  = 220
	SHARCParserLSHIFT              = 221
	SHARCParserLT                  = 222
	SHARCParserM0                  = 223
	SHARCParserM1                  = 224
	SHARCParserM2                  = 225
	SHARCParserM3                  = 226
	SHARCParserM4                  = 227
	SHARCParserM5                  = 228
	SHARCParserM6                  = 229
	SHARCParserM7                  = 230
	SHARCParserM8                  = 231
	SHARCParserM9                  = 232
	SHARCParserM10                 = 233
	SHARCParserM11                 = 234
	SHARCParserM12                 = 235
	SHARCParserM13                 = 236
	SHARCParserM14                 = 237
	SHARCParserM15                 = 238
	SHARCParserMANT                = 239
	SHARCParserMAX                 = 240
	SHARCParserMBM                 = 241
	SHARCParserMIN                 = 242
	SHARCParserMOD                 = 243
	SHARCParserMODE1               = 244
	SHARCParserMODE2               = 245
	SHARCParserMODIFY              = 246
	SHARCParserMR0B                = 247
	SHARCParserMR0F                = 248
	SHARCParserMR1B                = 249
	SHARCParserMR1F                = 250
	SHARCParserMR2B                = 251
	SHARCParserMR2F                = 252
	SHARCParserMRB                 = 253
	SHARCParserMRF                 = 254
	SHARCParserMS                  = 255
	SHARCParserMV                  = 256
	SHARCParserNBM                 = 257
	SHARCParserNE                  = 258
	SHARCParserNOFO                = 259
	SHARCParserNOFZ                = 260
	SHARCParserNOP                 = 261
	SHARCParserNOPSPECIAL          = 262
	SHARCParserNOT                 = 263
	SHARCParserNU                  = 264
	SHARCParserNW                  = 265
	SHARCParserOFFSETOF            = 266
	SHARCParserOR                  = 267
	SHARCParserP20                 = 268
	SHARCParserP32                 = 269
	SHARCParserP40                 = 270
	SHARCParserPACK                = 271
	SHARCParserPAGE                = 272
	SHARCParserPASS                = 273
	SHARCParserPC                  = 274
	SHARCParserPCSTK               = 275
	SHARCParserPCSTKP              = 276
	SHARCParserPM                  = 277
	SHARCParserPMADR               = 278
	SHARCParserPMBANK1             = 279
	SHARCParserPMDAE               = 280
	SHARCParserPMDAS               = 281
	SHARCParserPOP                 = 282
	SHARCParserPOVL0               = 283
	SHARCParserPOVL1               = 284
	SHARCParserPSA1E               = 285
	SHARCParserPSA1S               = 286
	SHARCParserPSA2E               = 287
	SHARCParserPSA3E               = 288
	SHARCParserPSA3S               = 289
	SHARCParserPSA4E               = 290
	SHARCParserPSA4S               = 291
	SHARCParserPUSH                = 292
	SHARCParserPX                  = 293
	SHARCParserPX1                 = 294
	SHARCParserPX2                 = 295
	SHARCParserRETAIN_NAME         = 296
	SHARCParserR0                  = 297
	SHARCParserR1                  = 298
	SHARCParserR2                  = 299
	SHARCParserR3                  = 300
	SHARCParserR4                  = 301
	SHARCParserR5                  = 302
	SHARCParserR6                  = 303
	SHARCParserR7                  = 304
	SHARCParserR8                  = 305
	SHARCParserR9                  = 306
	SHARCParserR10                 = 307
	SHARCParserR11                 = 308
	SHARCParserR12                 = 309
	SHARCParserR13                 = 310
	SHARCParserR14                 = 311
	SHARCParserR15                 = 312
	SHARCParserREAD                = 313
	SHARCParserRECIPS              = 314
	SHARCParserRFRAME              = 315
	SHARCParserRND                 = 316
	SHARCParserROT                 = 317
	SHARCParserRS                  = 318
	SHARCParserRSQRTS              = 319
	SHARCParserRTI                 = 320
	SHARCParserRTS                 = 321
	SHARCParserSAT                 = 322
	SHARCParserSCALB               = 323
	SHARCParserSCL                 = 324
	SHARCParserSE                  = 325
	SHARCParserSET                 = 326
	SHARCParserSF                  = 327
	SHARCParserSI                  = 328
	SHARCParserSIN                 = 329
	SHARCParserSIZE                = 330
	SHARCParserSIZEOF              = 331
	SHARCParserSQR                 = 332
	SHARCParserSR                  = 333
	SHARCParserSSF                 = 334
	SHARCParserSSFR                = 335
	SHARCParserSSI                 = 336
	SHARCParserSSIR                = 337
	SHARCParserST                  = 338
	SHARCParserSTEP                = 339
	SHARCParserSTKY                = 340
	SHARCParserSTRUCT              = 341
	SHARCParserSTS                 = 342
	SHARCParserSUF                 = 343
	SHARCParserSUFR                = 344
	SHARCParserSUI                 = 345
	SHARCParserSV                  = 346
	SHARCParserSW                  = 347
	SHARCParserSZ                  = 348
	SHARCParserTAG                 = 349
	SHARCParserTCOUNT              = 350
	SHARCParserTF                  = 351
	SHARCParserTGL                 = 352
	SHARCParserTPERIOD             = 353
	SHARCParserTRUE                = 354
	SHARCParserTRUNC               = 355
	SHARCParserTST                 = 356
	SHARCParserTYPE                = 357
	SHARCParserTRAP                = 358
	SHARCParserUF                  = 359
	SHARCParserUI                  = 360
	SHARCParserUNPACK              = 361
	SHARCParserUNTIL               = 362
	SHARCParserUR                  = 363
	SHARCParserUSF                 = 364
	SHARCParserUSFR                = 365
	SHARCParserUSI                 = 366
	SHARCParserUSIR                = 367
	SHARCParserUSTAT1              = 368
	SHARCParserUSTAT2              = 369
	SHARCParserUUF                 = 370
	SHARCParserUUFR                = 371
	SHARCParserUUI                 = 372
	SHARCParserUUIR                = 373
	SHARCParserVAL                 = 374
	SHARCParserWITH                = 375
	SHARCParserXOR                 = 376
	SHARCParserPLUS                = 377
	SHARCParserMINUS               = 378
	SHARCParserMULT                = 379
	SHARCParserDIV                 = 380
	SHARCParserDIV_MOD             = 381
	SHARCParserEQU                 = 382
	SHARCParserI_OR                = 383
	SHARCParserI_XOR               = 384
	SHARCParserCOMMA               = 385
	SHARCParserCOLON               = 386
	SHARCParserSEMICOLON           = 387
	SHARCParserLPARENTHESE         = 388
	SHARCParserRPARENTHESE         = 389
	SHARCParserLBRACKET            = 390
	SHARCParserRBRACKET            = 391
	SHARCParserLBRACE              = 392
	SHARCParserRBRACE              = 393
	SHARCParserAT                  = 394
	SHARCParserNO_INIT             = 395
	SHARCParserZERO_INIT           = 396
	SHARCParserRUNTIME_INIT        = 397
	SHARCParserCODE                = 398
	SHARCParserDATA                = 399
	SHARCParserDATA64              = 400
	SHARCParserDMAONLY             = 401
	SHARCParserSECTION             = 402
	SHARCParserSECTION_INFO        = 403
	SHARCParserSTMT                = 404
	SHARCParserADDR                = 405
	SHARCParserBIT_DATA            = 406
	SHARCParserJUMP_INT            = 407
	SHARCParserJUMP_PC             = 408
	SHARCParserJUMP_MD             = 409
	SHARCParserMODIFIER            = 410
	SHARCParserMULTI_MOD           = 411
	SHARCParserLABLE               = 412
	SHARCParserVARDEF              = 413
	SHARCParserARRDEF              = 414
	SHARCParserDM_ACCESS           = 415
	SHARCParserPM_ACCESS           = 416
	SHARCParserCONDITION           = 417
	SHARCParserIF_STMT             = 418
	SHARCParserVALUE_EXP           = 419
	SHARCParserNULL_               = 420
	SHARCParserCHAR_LITERAL        = 421
	SHARCParserSTR_LITERAL         = 422
	SHARCParserDIRECTIVE           = 423
	SHARCParserNEGATE              = 424
	SHARCParserID                  = 425
	SHARCParserCOMMENT             = 426
)

// SHARCParser rules.
const (
	SHARCParserRULE_prog                      = 0
	SHARCParserRULE_statement                 = 1
	SHARCParserRULE_stmt_atom                 = 2
	SHARCParserRULE_sec                       = 3
	SHARCParserRULE_seg                       = 4
	SHARCParserRULE_end_seg                   = 5
	SHARCParserRULE_seg_qualifier             = 6
	SHARCParserRULE_seg_qualifier1            = 7
	SHARCParserRULE_seg_qualifier2            = 8
	SHARCParserRULE_seg_qualifier3            = 9
	SHARCParserRULE_seg_qualifier_1           = 10
	SHARCParserRULE_seg_qualifier_2           = 11
	SHARCParserRULE_seg_qualifier_3           = 12
	SHARCParserRULE_stmt                      = 13
	SHARCParserRULE_declaration               = 14
	SHARCParserRULE_declaration_exp1          = 15
	SHARCParserRULE_declaration_exp2          = 16
	SHARCParserRULE_declaration_exp3          = 17
	SHARCParserRULE_declaration_exp4          = 18
	SHARCParserRULE_declaration_exp5          = 19
	SHARCParserRULE_declaration_exp_f1        = 20
	SHARCParserRULE_declaration_exp_f2        = 21
	SHARCParserRULE_initExpression            = 22
	SHARCParserRULE_var_addr                  = 23
	SHARCParserRULE_value_exp                 = 24
	SHARCParserRULE_value_exp2                = 25
	SHARCParserRULE_term                      = 26
	SHARCParserRULE_factor                    = 27
	SHARCParserRULE_atom                      = 28
	SHARCParserRULE_compute                   = 29
	SHARCParserRULE_if_compute_mov            = 30
	SHARCParserRULE_if_compute_mov_exp        = 31
	SHARCParserRULE_compute_mov_exp           = 32
	SHARCParserRULE_mov_exp_1                 = 33
	SHARCParserRULE_mov_exp_1_1               = 34
	SHARCParserRULE_mov_exp_1_2               = 35
	SHARCParserRULE_mov_exp_3a                = 36
	SHARCParserRULE_mov_exp_3b                = 37
	SHARCParserRULE_mov_exp_3c                = 38
	SHARCParserRULE_mov_exp_3d                = 39
	SHARCParserRULE_mov_exp_4a                = 40
	SHARCParserRULE_mov_exp_4b                = 41
	SHARCParserRULE_mov_exp_4c                = 42
	SHARCParserRULE_mov_exp_4d                = 43
	SHARCParserRULE_mov_exp_5                 = 44
	SHARCParserRULE_mov_exp_6a                = 45
	SHARCParserRULE_mov_exp_6b                = 46
	SHARCParserRULE_mov_exp_7                 = 47
	SHARCParserRULE_mem_addr_ia_mb            = 48
	SHARCParserRULE_mem_addr_ic_md            = 49
	SHARCParserRULE_mem_addr_md_ic            = 50
	SHARCParserRULE_mem_addr_mb_ia            = 51
	SHARCParserRULE_mem_addr_ia_int           = 52
	SHARCParserRULE_mem_addr_ic_int           = 53
	SHARCParserRULE_mem_addr_int_ia           = 54
	SHARCParserRULE_mem_addr_int_ic           = 55
	SHARCParserRULE_mem_addr_int              = 56
	SHARCParserRULE_mem_addr_int_             = 57
	SHARCParserRULE_mem_addr_dm_ia_mb         = 58
	SHARCParserRULE_mem_addr_pm_ic_md         = 59
	SHARCParserRULE_mem_addr_dm_mb_ia         = 60
	SHARCParserRULE_mem_addr_pm_md_ic         = 61
	SHARCParserRULE_mem_addr_dm_ia_int        = 62
	SHARCParserRULE_mem_addr_pm_ic_int        = 63
	SHARCParserRULE_mem_addr_dm_int_ia        = 64
	SHARCParserRULE_mem_addr_pm_int_ic        = 65
	SHARCParserRULE_mem_addr_dm_int           = 66
	SHARCParserRULE_mem_addr_pm_int           = 67
	SHARCParserRULE_fixpoint_alu_op           = 68
	SHARCParserRULE_r_exp                     = 69
	SHARCParserRULE_floating_point_alu_op     = 70
	SHARCParserRULE_f_exp                     = 71
	SHARCParserRULE_multi_op                  = 72
	SHARCParserRULE_multi_r                   = 73
	SHARCParserRULE_multi_exp_r               = 74
	SHARCParserRULE_multi_exp_mrf             = 75
	SHARCParserRULE_multi_exp_mrb             = 76
	SHARCParserRULE_mr                        = 77
	SHARCParserRULE_shifter_op                = 78
	SHARCParserRULE_shifter_exp               = 79
	SHARCParserRULE_sec_op                    = 80
	SHARCParserRULE_sec_op2                   = 81
	SHARCParserRULE_bit_data                  = 82
	SHARCParserRULE_add_or_sub                = 83
	SHARCParserRULE_dual_op                   = 84
	SHARCParserRULE_dual_add_r                = 85
	SHARCParserRULE_parallel_multi            = 86
	SHARCParserRULE_flow_control_exp          = 87
	SHARCParserRULE_flow_contorl_8            = 88
	SHARCParserRULE_flow_contorl_8_exp        = 89
	SHARCParserRULE_flow_control_9_and_11     = 90
	SHARCParserRULE_flow_control_9_and_11_exp = 91
	SHARCParserRULE_flow_control_10           = 92
	SHARCParserRULE_flow_control_10_frag      = 93
	SHARCParserRULE_flow_control_12           = 94
	SHARCParserRULE_lcntr_v                   = 95
	SHARCParserRULE_flow_control_13           = 96
	SHARCParserRULE_flow_control_8a           = 97
	SHARCParserRULE_flow_control_8b           = 98
	SHARCParserRULE_flow_control_9a           = 99
	SHARCParserRULE_flow_control_9b           = 100
	SHARCParserRULE_flow_control_11a          = 101
	SHARCParserRULE_flow_control_11b          = 102
	SHARCParserRULE_jump_addr_int_or_pc       = 103
	SHARCParserRULE_jump_addr_md_or_pc        = 104
	SHARCParserRULE_jump_addr_pc              = 105
	SHARCParserRULE_jump_addr_int             = 106
	SHARCParserRULE_jump_modifier             = 107
	SHARCParserRULE_jump_modifier_            = 108
	SHARCParserRULE_jump_modifier_1           = 109
	SHARCParserRULE_jump_modifier2            = 110
	SHARCParserRULE_jump_modifier3            = 111
	SHARCParserRULE_jump_modifier3_           = 112
	SHARCParserRULE_jump_modifier3_1          = 113
	SHARCParserRULE_imm_mov_exp               = 114
	SHARCParserRULE_imm_mov_14a               = 115
	SHARCParserRULE_imm_mov_15a               = 116
	SHARCParserRULE_imm_mov_14b               = 117
	SHARCParserRULE_imm_mov_15b               = 118
	SHARCParserRULE_imm_mov_16                = 119
	SHARCParserRULE_imm_mov_17                = 120
	SHARCParserRULE_u_reg2                    = 121
	SHARCParserRULE_misc_exp                  = 122
	SHARCParserRULE_misc_20                   = 123
	SHARCParserRULE_directive_exp             = 124
	SHARCParserRULE_b_reg                     = 125
	SHARCParserRULE_l_reg                     = 126
	SHARCParserRULE_r_reg                     = 127
	SHARCParserRULE_f_reg                     = 128
	SHARCParserRULE_s_reg                     = 129
	SHARCParserRULE_ia                        = 130
	SHARCParserRULE_mb                        = 131
	SHARCParserRULE_ic                        = 132
	SHARCParserRULE_md                        = 133
	SHARCParserRULE_i_reg                     = 134
	SHARCParserRULE_m_reg                     = 135
	SHARCParserRULE_dag_reg                   = 136
	SHARCParserRULE_d_reg                     = 137
	SHARCParserRULE_u_reg                     = 138
	SHARCParserRULE_condition                 = 139
	SHARCParserRULE_ccondition                = 140
	SHARCParserRULE_multi_mod1                = 141
	SHARCParserRULE_multi_mod1_               = 142
	SHARCParserRULE_multi_mod2                = 143
	SHARCParserRULE_multi_mod2_               = 144
	SHARCParserRULE_r3_0                      = 145
	SHARCParserRULE_r7_4                      = 146
	SHARCParserRULE_r11_8                     = 147
	SHARCParserRULE_r15_12                    = 148
	SHARCParserRULE_f3_0                      = 149
	SHARCParserRULE_f7_4                      = 150
	SHARCParserRULE_f11_8                     = 151
	SHARCParserRULE_f15_12                    = 152
	SHARCParserRULE_addr                      = 153
	SHARCParserRULE_mrf                       = 154
	SHARCParserRULE_mrb                       = 155
)

// IProgContext is an interface to support dynamic dispatch.
type IProgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgContext differentiates from other interfaces.
	IsProgContext()
}

type ProgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgContext() *ProgContext {
	var p = new(ProgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_prog
	return p
}

func (*ProgContext) IsProgContext() {}

func NewProgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgContext {
	var p = new(ProgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_prog

	return p
}

func (s *ProgContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *ProgContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ProgContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserSEMICOLON)
}

func (s *ProgContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserSEMICOLON, i)
}

func (s *ProgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterProg(s)
	}
}

func (s *ProgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitProg(s)
	}
}

func (p *SHARCParser) Prog() (localctx IProgContext) {
	this := p
	_ = this

	localctx = NewProgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SHARCParserRULE_prog)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(315)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-8)&-(0x1f+1)) == 0 && ((1<<uint((_la-8)))&((1<<(SHARCParserDOT_ALGIGN-8))|(1<<(SHARCParserDOT_COMPRESS-8))|(1<<(SHARCParserDOT_EXTERN-8))|(1<<(SHARCParserDOT_FILE-8))|(1<<(SHARCParserDOT_FILE_ATTR-8))|(1<<(SHARCParserDOT_FORCECOMPRESS-8))|(1<<(SHARCParserDOT_GLOBAL-8))|(1<<(SHARCParserDOT_IMPORT-8))|(1<<(SHARCParserDOT_LEFTMARGIN-8))|(1<<(SHARCParserDOT_LIST-8))|(1<<(SHARCParserDOT_LIST_DATA-8))|(1<<(SHARCParserDOT_LIST_DATFILE-8))|(1<<(SHARCParserDOT_LIST_DEFTAB-8))|(1<<(SHARCParserDOT_LIST_LOCTAB-8))|(1<<(SHARCParserDOT_LIST_WRAPDATA-8))|(1<<(SHARCParserDOT_NEWPAGE-8))|(1<<(SHARCParserDOT_NOCOMPRESS-8))|(1<<(SHARCParserDOT_NOLIST_DATA-8))|(1<<(SHARCParserDOT_NOLIST_DATFILE-8))|(1<<(SHARCParserDOT_NOLIST_WRAPDATA-8))|(1<<(SHARCParserDOT_PAGELENGTH-8))|(1<<(SHARCParserDOT_PAGEWIDTH-8))|(1<<(SHARCParserDOT_PRECISION-8))|(1<<(SHARCParserDOT_ROUND_MINUS-8))|(1<<(SHARCParserDOT_ROUND_NEAREST-8))|(1<<(SHARCParserDOT_ROUND_PLUS-8))|(1<<(SHARCParserDOT_ROUND_ZERO-8)))) != 0) || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(SHARCParserDOT_PREVIOUS-40))|(1<<(SHARCParserDOT_SECTION-40))|(1<<(SHARCParserDOT_SEGMENT-40))|(1<<(SHARCParserDOT_ENDSEG-40))|(1<<(SHARCParserDOT_VAR-40))|(1<<(SHARCParserDOT_WEAK-40))|(1<<(SHARCParserASTAT-40))|(1<<(SHARCParserB0-40))|(1<<(SHARCParserB1-40))|(1<<(SHARCParserB2-40))|(1<<(SHARCParserB3-40))|(1<<(SHARCParserB4-40))|(1<<(SHARCParserB5-40))|(1<<(SHARCParserB6-40))|(1<<(SHARCParserB7-40))|(1<<(SHARCParserB8-40))|(1<<(SHARCParserB9-40))|(1<<(SHARCParserB10-40))|(1<<(SHARCParserB11-40))|(1<<(SHARCParserB12-40))|(1<<(SHARCParserB13-40))|(1<<(SHARCParserB14-40)))) != 0) || (((_la-72)&-(0x1f+1)) == 0 && ((1<<uint((_la-72)))&((1<<(SHARCParserB15-72))|(1<<(SHARCParserBIT-72))|(1<<(SHARCParserBITREV-72))|(1<<(SHARCParserBTST-72))|(1<<(SHARCParserCALL-72))|(1<<(SHARCParserCJUMP-72))|(1<<(SHARCParserCOMP-72))|(1<<(SHARCParserCURLCNTR-72))|(1<<(SHARCParserDADDR-72))|(1<<(SHARCParserDM-72)))) != 0) || (((_la-111)&-(0x1f+1)) == 0 && ((1<<uint((_la-111)))&((1<<(SHARCParserDO-111))|(1<<(SHARCParserF0-111))|(1<<(SHARCParserF1-111))|(1<<(SHARCParserF2-111))|(1<<(SHARCParserF3-111))|(1<<(SHARCParserF4-111))|(1<<(SHARCParserF5-111))|(1<<(SHARCParserF6-111))|(1<<(SHARCParserF7-111))|(1<<(SHARCParserF8-111))|(1<<(SHARCParserF9-111))|(1<<(SHARCParserF10-111))|(1<<(SHARCParserF11-111))|(1<<(SHARCParserF12-111))|(1<<(SHARCParserF13-111))|(1<<(SHARCParserF14-111))|(1<<(SHARCParserF15-111))|(1<<(SHARCParserFADDR-111)))) != 0) || (((_la-152)&-(0x1f+1)) == 0 && ((1<<uint((_la-152)))&((1<<(SHARCParserFLUSH-152))|(1<<(SHARCParserI0-152))|(1<<(SHARCParserI1-152))|(1<<(SHARCParserI2-152))|(1<<(SHARCParserI3-152))|(1<<(SHARCParserI4-152))|(1<<(SHARCParserI5-152))|(1<<(SHARCParserI6-152))|(1<<(SHARCParserI7-152))|(1<<(SHARCParserI8-152))|(1<<(SHARCParserI9-152))|(1<<(SHARCParserI10-152))|(1<<(SHARCParserI11-152))|(1<<(SHARCParserI12-152))|(1<<(SHARCParserI13-152))|(1<<(SHARCParserI14-152))|(1<<(SHARCParserI15-152))|(1<<(SHARCParserIDLE-152))|(1<<(SHARCParserIDLE16-152)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(SHARCParserIF-184))|(1<<(SHARCParserIMASK-184))|(1<<(SHARCParserIMASKP-184))|(1<<(SHARCParserIRPTL-184))|(1<<(SHARCParserJUMP-184))|(1<<(SHARCParserL0-184))|(1<<(SHARCParserL1-184))|(1<<(SHARCParserL2-184))|(1<<(SHARCParserL3-184))|(1<<(SHARCParserL4-184))|(1<<(SHARCParserL5-184))|(1<<(SHARCParserL6-184))|(1<<(SHARCParserL7-184))|(1<<(SHARCParserL8-184))|(1<<(SHARCParserL9-184))|(1<<(SHARCParserL10-184))|(1<<(SHARCParserL11-184))|(1<<(SHARCParserL12-184))|(1<<(SHARCParserL13-184))|(1<<(SHARCParserL14-184))|(1<<(SHARCParserL15-184))|(1<<(SHARCParserLADDR-184))|(1<<(SHARCParserLCNTR-184)))) != 0) || (((_la-223)&-(0x1f+1)) == 0 && ((1<<uint((_la-223)))&((1<<(SHARCParserM0-223))|(1<<(SHARCParserM1-223))|(1<<(SHARCParserM2-223))|(1<<(SHARCParserM3-223))|(1<<(SHARCParserM4-223))|(1<<(SHARCParserM5-223))|(1<<(SHARCParserM6-223))|(1<<(SHARCParserM7-223))|(1<<(SHARCParserM8-223))|(1<<(SHARCParserM9-223))|(1<<(SHARCParserM10-223))|(1<<(SHARCParserM11-223))|(1<<(SHARCParserM12-223))|(1<<(SHARCParserM13-223))|(1<<(SHARCParserM14-223))|(1<<(SHARCParserM15-223))|(1<<(SHARCParserMODE1-223))|(1<<(SHARCParserMODE2-223))|(1<<(SHARCParserMODIFY-223))|(1<<(SHARCParserMR0B-223))|(1<<(SHARCParserMR0F-223))|(1<<(SHARCParserMR1B-223))|(1<<(SHARCParserMR1F-223))|(1<<(SHARCParserMR2B-223))|(1<<(SHARCParserMR2F-223))|(1<<(SHARCParserMRB-223))|(1<<(SHARCParserMRF-223)))) != 0) || (((_la-261)&-(0x1f+1)) == 0 && ((1<<uint((_la-261)))&((1<<(SHARCParserNOP-261))|(1<<(SHARCParserPC-261))|(1<<(SHARCParserPCSTK-261))|(1<<(SHARCParserPCSTKP-261))|(1<<(SHARCParserPM-261))|(1<<(SHARCParserPOP-261))|(1<<(SHARCParserPUSH-261)))) != 0) || (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(SHARCParserPX-293))|(1<<(SHARCParserPX1-293))|(1<<(SHARCParserPX2-293))|(1<<(SHARCParserR0-293))|(1<<(SHARCParserR1-293))|(1<<(SHARCParserR2-293))|(1<<(SHARCParserR3-293))|(1<<(SHARCParserR4-293))|(1<<(SHARCParserR5-293))|(1<<(SHARCParserR6-293))|(1<<(SHARCParserR7-293))|(1<<(SHARCParserR8-293))|(1<<(SHARCParserR9-293))|(1<<(SHARCParserR10-293))|(1<<(SHARCParserR11-293))|(1<<(SHARCParserR12-293))|(1<<(SHARCParserR13-293))|(1<<(SHARCParserR14-293))|(1<<(SHARCParserR15-293))|(1<<(SHARCParserRFRAME-293))|(1<<(SHARCParserRTI-293))|(1<<(SHARCParserRTS-293)))) != 0) || (((_la-340)&-(0x1f+1)) == 0 && ((1<<uint((_la-340)))&((1<<(SHARCParserSTKY-340))|(1<<(SHARCParserTCOUNT-340))|(1<<(SHARCParserTPERIOD-340))|(1<<(SHARCParserUSTAT1-340))|(1<<(SHARCParserUSTAT2-340)))) != 0) || _la == SHARCParserID {
		{
			p.SetState(312)
			p.Statement()
		}
		{
			p.SetState(313)
			p.Match(SHARCParserSEMICOLON)
		}

		p.SetState(317)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Stmt_atom() IStmt_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmt_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStmt_atomContext)
}

func (s *StatementContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserID)
}

func (s *StatementContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserID, i)
}

func (s *StatementContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserCOLON)
}

func (s *StatementContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserCOLON, i)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *SHARCParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SHARCParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(327)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDOT_ALGIGN, SHARCParserDOT_COMPRESS, SHARCParserDOT_EXTERN, SHARCParserDOT_FILE, SHARCParserDOT_FILE_ATTR, SHARCParserDOT_FORCECOMPRESS, SHARCParserDOT_GLOBAL, SHARCParserDOT_IMPORT, SHARCParserDOT_LEFTMARGIN, SHARCParserDOT_LIST, SHARCParserDOT_LIST_DATA, SHARCParserDOT_LIST_DATFILE, SHARCParserDOT_LIST_DEFTAB, SHARCParserDOT_LIST_LOCTAB, SHARCParserDOT_LIST_WRAPDATA, SHARCParserDOT_NEWPAGE, SHARCParserDOT_NOCOMPRESS, SHARCParserDOT_NOLIST_DATA, SHARCParserDOT_NOLIST_DATFILE, SHARCParserDOT_NOLIST_WRAPDATA, SHARCParserDOT_PAGELENGTH, SHARCParserDOT_PAGEWIDTH, SHARCParserDOT_PRECISION, SHARCParserDOT_ROUND_MINUS, SHARCParserDOT_ROUND_NEAREST, SHARCParserDOT_ROUND_PLUS, SHARCParserDOT_ROUND_ZERO, SHARCParserDOT_PREVIOUS, SHARCParserDOT_SECTION, SHARCParserDOT_SEGMENT, SHARCParserDOT_ENDSEG, SHARCParserDOT_VAR, SHARCParserDOT_WEAK, SHARCParserASTAT, SHARCParserB0, SHARCParserB1, SHARCParserB2, SHARCParserB3, SHARCParserB4, SHARCParserB5, SHARCParserB6, SHARCParserB7, SHARCParserB8, SHARCParserB9, SHARCParserB10, SHARCParserB11, SHARCParserB12, SHARCParserB13, SHARCParserB14, SHARCParserB15, SHARCParserBIT, SHARCParserBITREV, SHARCParserBTST, SHARCParserCALL, SHARCParserCJUMP, SHARCParserCOMP, SHARCParserCURLCNTR, SHARCParserDADDR, SHARCParserDM, SHARCParserDO, SHARCParserF0, SHARCParserF1, SHARCParserF2, SHARCParserF3, SHARCParserF4, SHARCParserF5, SHARCParserF6, SHARCParserF7, SHARCParserF8, SHARCParserF9, SHARCParserF10, SHARCParserF11, SHARCParserF12, SHARCParserF13, SHARCParserF14, SHARCParserF15, SHARCParserFADDR, SHARCParserFLUSH, SHARCParserI0, SHARCParserI1, SHARCParserI2, SHARCParserI3, SHARCParserI4, SHARCParserI5, SHARCParserI6, SHARCParserI7, SHARCParserI8, SHARCParserI9, SHARCParserI10, SHARCParserI11, SHARCParserI12, SHARCParserI13, SHARCParserI14, SHARCParserI15, SHARCParserIDLE, SHARCParserIDLE16, SHARCParserIF, SHARCParserIMASK, SHARCParserIMASKP, SHARCParserIRPTL, SHARCParserJUMP, SHARCParserL0, SHARCParserL1, SHARCParserL2, SHARCParserL3, SHARCParserL4, SHARCParserL5, SHARCParserL6, SHARCParserL7, SHARCParserL8, SHARCParserL9, SHARCParserL10, SHARCParserL11, SHARCParserL12, SHARCParserL13, SHARCParserL14, SHARCParserL15, SHARCParserLADDR, SHARCParserLCNTR, SHARCParserM0, SHARCParserM1, SHARCParserM2, SHARCParserM3, SHARCParserM4, SHARCParserM5, SHARCParserM6, SHARCParserM7, SHARCParserM8, SHARCParserM9, SHARCParserM10, SHARCParserM11, SHARCParserM12, SHARCParserM13, SHARCParserM14, SHARCParserM15, SHARCParserMODE1, SHARCParserMODE2, SHARCParserMODIFY, SHARCParserMR0B, SHARCParserMR0F, SHARCParserMR1B, SHARCParserMR1F, SHARCParserMR2B, SHARCParserMR2F, SHARCParserMRB, SHARCParserMRF, SHARCParserNOP, SHARCParserPC, SHARCParserPCSTK, SHARCParserPCSTKP, SHARCParserPM, SHARCParserPOP, SHARCParserPUSH, SHARCParserPX, SHARCParserPX1, SHARCParserPX2, SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15, SHARCParserRFRAME, SHARCParserRTI, SHARCParserRTS, SHARCParserSTKY, SHARCParserTCOUNT, SHARCParserTPERIOD, SHARCParserUSTAT1, SHARCParserUSTAT2:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(319)
			p.Stmt_atom()
		}

	case SHARCParserID:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(322)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SHARCParserID {
			{
				p.SetState(320)
				p.Match(SHARCParserID)
			}
			{
				p.SetState(321)
				p.Match(SHARCParserCOLON)
			}

			p.SetState(324)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(326)
			p.Stmt_atom()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStmt_atomContext is an interface to support dynamic dispatch.
type IStmt_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStmt_atomContext differentiates from other interfaces.
	IsStmt_atomContext()
}

type Stmt_atomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmt_atomContext() *Stmt_atomContext {
	var p = new(Stmt_atomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_stmt_atom
	return p
}

func (*Stmt_atomContext) IsStmt_atomContext() {}

func NewStmt_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Stmt_atomContext {
	var p = new(Stmt_atomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_stmt_atom

	return p
}

func (s *Stmt_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Stmt_atomContext) Stmt() IStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *Stmt_atomContext) Sec() ISecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISecContext)
}

func (s *Stmt_atomContext) Seg() ISegContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISegContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISegContext)
}

func (s *Stmt_atomContext) End_seg() IEnd_segContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnd_segContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnd_segContext)
}

func (s *Stmt_atomContext) Directive_exp() IDirective_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDirective_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDirective_expContext)
}

func (s *Stmt_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Stmt_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterStmt_atom(s)
	}
}

func (s *Stmt_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitStmt_atom(s)
	}
}

func (p *SHARCParser) Stmt_atom() (localctx IStmt_atomContext) {
	this := p
	_ = this

	localctx = NewStmt_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SHARCParserRULE_stmt_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(334)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDOT_VAR, SHARCParserASTAT, SHARCParserB0, SHARCParserB1, SHARCParserB2, SHARCParserB3, SHARCParserB4, SHARCParserB5, SHARCParserB6, SHARCParserB7, SHARCParserB8, SHARCParserB9, SHARCParserB10, SHARCParserB11, SHARCParserB12, SHARCParserB13, SHARCParserB14, SHARCParserB15, SHARCParserBIT, SHARCParserBITREV, SHARCParserBTST, SHARCParserCALL, SHARCParserCJUMP, SHARCParserCOMP, SHARCParserCURLCNTR, SHARCParserDADDR, SHARCParserDM, SHARCParserDO, SHARCParserF0, SHARCParserF1, SHARCParserF2, SHARCParserF3, SHARCParserF4, SHARCParserF5, SHARCParserF6, SHARCParserF7, SHARCParserF8, SHARCParserF9, SHARCParserF10, SHARCParserF11, SHARCParserF12, SHARCParserF13, SHARCParserF14, SHARCParserF15, SHARCParserFADDR, SHARCParserFLUSH, SHARCParserI0, SHARCParserI1, SHARCParserI2, SHARCParserI3, SHARCParserI4, SHARCParserI5, SHARCParserI6, SHARCParserI7, SHARCParserI8, SHARCParserI9, SHARCParserI10, SHARCParserI11, SHARCParserI12, SHARCParserI13, SHARCParserI14, SHARCParserI15, SHARCParserIDLE, SHARCParserIDLE16, SHARCParserIF, SHARCParserIMASK, SHARCParserIMASKP, SHARCParserIRPTL, SHARCParserJUMP, SHARCParserL0, SHARCParserL1, SHARCParserL2, SHARCParserL3, SHARCParserL4, SHARCParserL5, SHARCParserL6, SHARCParserL7, SHARCParserL8, SHARCParserL9, SHARCParserL10, SHARCParserL11, SHARCParserL12, SHARCParserL13, SHARCParserL14, SHARCParserL15, SHARCParserLADDR, SHARCParserLCNTR, SHARCParserM0, SHARCParserM1, SHARCParserM2, SHARCParserM3, SHARCParserM4, SHARCParserM5, SHARCParserM6, SHARCParserM7, SHARCParserM8, SHARCParserM9, SHARCParserM10, SHARCParserM11, SHARCParserM12, SHARCParserM13, SHARCParserM14, SHARCParserM15, SHARCParserMODE1, SHARCParserMODE2, SHARCParserMODIFY, SHARCParserMR0B, SHARCParserMR0F, SHARCParserMR1B, SHARCParserMR1F, SHARCParserMR2B, SHARCParserMR2F, SHARCParserMRB, SHARCParserMRF, SHARCParserNOP, SHARCParserPC, SHARCParserPCSTK, SHARCParserPCSTKP, SHARCParserPM, SHARCParserPOP, SHARCParserPUSH, SHARCParserPX, SHARCParserPX1, SHARCParserPX2, SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15, SHARCParserRFRAME, SHARCParserRTI, SHARCParserRTS, SHARCParserSTKY, SHARCParserTCOUNT, SHARCParserTPERIOD, SHARCParserUSTAT1, SHARCParserUSTAT2:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(329)
			p.Stmt()
		}

	case SHARCParserDOT_SECTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(330)
			p.Sec()
		}

	case SHARCParserDOT_SEGMENT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(331)
			p.Seg()
		}

	case SHARCParserDOT_ENDSEG:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(332)
			p.End_seg()
		}

	case SHARCParserDOT_ALGIGN, SHARCParserDOT_COMPRESS, SHARCParserDOT_EXTERN, SHARCParserDOT_FILE, SHARCParserDOT_FILE_ATTR, SHARCParserDOT_FORCECOMPRESS, SHARCParserDOT_GLOBAL, SHARCParserDOT_IMPORT, SHARCParserDOT_LEFTMARGIN, SHARCParserDOT_LIST, SHARCParserDOT_LIST_DATA, SHARCParserDOT_LIST_DATFILE, SHARCParserDOT_LIST_DEFTAB, SHARCParserDOT_LIST_LOCTAB, SHARCParserDOT_LIST_WRAPDATA, SHARCParserDOT_NEWPAGE, SHARCParserDOT_NOCOMPRESS, SHARCParserDOT_NOLIST_DATA, SHARCParserDOT_NOLIST_DATFILE, SHARCParserDOT_NOLIST_WRAPDATA, SHARCParserDOT_PAGELENGTH, SHARCParserDOT_PAGEWIDTH, SHARCParserDOT_PRECISION, SHARCParserDOT_ROUND_MINUS, SHARCParserDOT_ROUND_NEAREST, SHARCParserDOT_ROUND_PLUS, SHARCParserDOT_ROUND_ZERO, SHARCParserDOT_PREVIOUS, SHARCParserDOT_WEAK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(333)
			p.Directive_exp()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISecContext is an interface to support dynamic dispatch.
type ISecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSecContext differentiates from other interfaces.
	IsSecContext()
}

type SecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySecContext() *SecContext {
	var p = new(SecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_sec
	return p
}

func (*SecContext) IsSecContext() {}

func NewSecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SecContext {
	var p = new(SecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_sec

	return p
}

func (s *SecContext) GetParser() antlr.Parser { return s.parser }

func (s *SecContext) DOT_SECTION() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_SECTION, 0)
}

func (s *SecContext) Seg_qualifier() ISeg_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeg_qualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeg_qualifierContext)
}

func (s *SecContext) ID() antlr.TerminalNode {
	return s.GetToken(SHARCParserID, 0)
}

func (s *SecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterSec(s)
	}
}

func (s *SecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitSec(s)
	}
}

func (p *SHARCParser) Sec() (localctx ISecContext) {
	this := p
	_ = this

	localctx = NewSecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SHARCParserRULE_sec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(336)
		p.Match(SHARCParserDOT_SECTION)
	}
	{
		p.SetState(337)
		p.Seg_qualifier()
	}
	{
		p.SetState(338)
		p.Match(SHARCParserID)
	}

	return localctx
}

// ISegContext is an interface to support dynamic dispatch.
type ISegContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSegContext differentiates from other interfaces.
	IsSegContext()
}

type SegContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySegContext() *SegContext {
	var p = new(SegContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_seg
	return p
}

func (*SegContext) IsSegContext() {}

func NewSegContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SegContext {
	var p = new(SegContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_seg

	return p
}

func (s *SegContext) GetParser() antlr.Parser { return s.parser }

func (s *SegContext) DOT_SEGMENT() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_SEGMENT, 0)
}

func (s *SegContext) Seg_qualifier() ISeg_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeg_qualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeg_qualifierContext)
}

func (s *SegContext) ID() antlr.TerminalNode {
	return s.GetToken(SHARCParserID, 0)
}

func (s *SegContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SegContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SegContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterSeg(s)
	}
}

func (s *SegContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitSeg(s)
	}
}

func (p *SHARCParser) Seg() (localctx ISegContext) {
	this := p
	_ = this

	localctx = NewSegContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SHARCParserRULE_seg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(340)
		p.Match(SHARCParserDOT_SEGMENT)
	}
	{
		p.SetState(341)
		p.Seg_qualifier()
	}
	{
		p.SetState(342)
		p.Match(SHARCParserID)
	}

	return localctx
}

// IEnd_segContext is an interface to support dynamic dispatch.
type IEnd_segContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnd_segContext differentiates from other interfaces.
	IsEnd_segContext()
}

type End_segContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnd_segContext() *End_segContext {
	var p = new(End_segContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_end_seg
	return p
}

func (*End_segContext) IsEnd_segContext() {}

func NewEnd_segContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *End_segContext {
	var p = new(End_segContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_end_seg

	return p
}

func (s *End_segContext) GetParser() antlr.Parser { return s.parser }

func (s *End_segContext) DOT_ENDSEG() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_ENDSEG, 0)
}

func (s *End_segContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *End_segContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *End_segContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterEnd_seg(s)
	}
}

func (s *End_segContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitEnd_seg(s)
	}
}

func (p *SHARCParser) End_seg() (localctx IEnd_segContext) {
	this := p
	_ = this

	localctx = NewEnd_segContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SHARCParserRULE_end_seg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(344)
		p.Match(SHARCParserDOT_ENDSEG)
	}

	return localctx
}

// ISeg_qualifierContext is an interface to support dynamic dispatch.
type ISeg_qualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeg_qualifierContext differentiates from other interfaces.
	IsSeg_qualifierContext()
}

type Seg_qualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeg_qualifierContext() *Seg_qualifierContext {
	var p = new(Seg_qualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_seg_qualifier
	return p
}

func (*Seg_qualifierContext) IsSeg_qualifierContext() {}

func NewSeg_qualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Seg_qualifierContext {
	var p = new(Seg_qualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_seg_qualifier

	return p
}

func (s *Seg_qualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Seg_qualifierContext) Seg_qualifier1() ISeg_qualifier1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeg_qualifier1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeg_qualifier1Context)
}

func (s *Seg_qualifierContext) Seg_qualifier2() ISeg_qualifier2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeg_qualifier2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeg_qualifier2Context)
}

func (s *Seg_qualifierContext) Seg_qualifier3() ISeg_qualifier3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeg_qualifier3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeg_qualifier3Context)
}

func (s *Seg_qualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Seg_qualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Seg_qualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterSeg_qualifier(s)
	}
}

func (s *Seg_qualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitSeg_qualifier(s)
	}
}

func (p *SHARCParser) Seg_qualifier() (localctx ISeg_qualifierContext) {
	this := p
	_ = this

	localctx = NewSeg_qualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SHARCParserRULE_seg_qualifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(346)
			p.Seg_qualifier1()
		}
		p.SetState(349)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(347)
				p.Seg_qualifier2()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(348)
				p.Seg_qualifier3()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(351)
			p.Seg_qualifier2()
		}
		p.SetState(354)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(352)
				p.Seg_qualifier1()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(353)
				p.Seg_qualifier3()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(356)
			p.Seg_qualifier3()
		}
		p.SetState(359)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(357)
				p.Seg_qualifier1()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(358)
				p.Seg_qualifier2()
			}

		}

	}

	return localctx
}

// ISeg_qualifier1Context is an interface to support dynamic dispatch.
type ISeg_qualifier1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeg_qualifier1Context differentiates from other interfaces.
	IsSeg_qualifier1Context()
}

type Seg_qualifier1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeg_qualifier1Context() *Seg_qualifier1Context {
	var p = new(Seg_qualifier1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_seg_qualifier1
	return p
}

func (*Seg_qualifier1Context) IsSeg_qualifier1Context() {}

func NewSeg_qualifier1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Seg_qualifier1Context {
	var p = new(Seg_qualifier1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_seg_qualifier1

	return p
}

func (s *Seg_qualifier1Context) GetParser() antlr.Parser { return s.parser }

func (s *Seg_qualifier1Context) DIV() antlr.TerminalNode {
	return s.GetToken(SHARCParserDIV, 0)
}

func (s *Seg_qualifier1Context) Seg_qualifier_1() ISeg_qualifier_1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeg_qualifier_1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeg_qualifier_1Context)
}

func (s *Seg_qualifier1Context) Seg_qualifier_2() ISeg_qualifier_2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeg_qualifier_2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeg_qualifier_2Context)
}

func (s *Seg_qualifier1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Seg_qualifier1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Seg_qualifier1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterSeg_qualifier1(s)
	}
}

func (s *Seg_qualifier1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitSeg_qualifier1(s)
	}
}

func (p *SHARCParser) Seg_qualifier1() (localctx ISeg_qualifier1Context) {
	this := p
	_ = this

	localctx = NewSeg_qualifier1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SHARCParserRULE_seg_qualifier1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(363)
		p.Match(SHARCParserDIV)
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserPM, SHARCParserCODE:
		{
			p.SetState(364)
			p.Seg_qualifier_1()
		}

	case SHARCParserDM, SHARCParserDATA, SHARCParserDATA64:
		{
			p.SetState(365)
			p.Seg_qualifier_2()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISeg_qualifier2Context is an interface to support dynamic dispatch.
type ISeg_qualifier2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeg_qualifier2Context differentiates from other interfaces.
	IsSeg_qualifier2Context()
}

type Seg_qualifier2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeg_qualifier2Context() *Seg_qualifier2Context {
	var p = new(Seg_qualifier2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_seg_qualifier2
	return p
}

func (*Seg_qualifier2Context) IsSeg_qualifier2Context() {}

func NewSeg_qualifier2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Seg_qualifier2Context {
	var p = new(Seg_qualifier2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_seg_qualifier2

	return p
}

func (s *Seg_qualifier2Context) GetParser() antlr.Parser { return s.parser }

func (s *Seg_qualifier2Context) DIV() antlr.TerminalNode {
	return s.GetToken(SHARCParserDIV, 0)
}

func (s *Seg_qualifier2Context) Seg_qualifier_3() ISeg_qualifier_3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeg_qualifier_3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeg_qualifier_3Context)
}

func (s *Seg_qualifier2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Seg_qualifier2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Seg_qualifier2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterSeg_qualifier2(s)
	}
}

func (s *Seg_qualifier2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitSeg_qualifier2(s)
	}
}

func (p *SHARCParser) Seg_qualifier2() (localctx ISeg_qualifier2Context) {
	this := p
	_ = this

	localctx = NewSeg_qualifier2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SHARCParserRULE_seg_qualifier2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(368)
		p.Match(SHARCParserDIV)
	}
	{
		p.SetState(369)
		p.Seg_qualifier_3()
	}

	return localctx
}

// ISeg_qualifier3Context is an interface to support dynamic dispatch.
type ISeg_qualifier3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeg_qualifier3Context differentiates from other interfaces.
	IsSeg_qualifier3Context()
}

type Seg_qualifier3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeg_qualifier3Context() *Seg_qualifier3Context {
	var p = new(Seg_qualifier3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_seg_qualifier3
	return p
}

func (*Seg_qualifier3Context) IsSeg_qualifier3Context() {}

func NewSeg_qualifier3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Seg_qualifier3Context {
	var p = new(Seg_qualifier3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_seg_qualifier3

	return p
}

func (s *Seg_qualifier3Context) GetParser() antlr.Parser { return s.parser }

func (s *Seg_qualifier3Context) DIV() antlr.TerminalNode {
	return s.GetToken(SHARCParserDIV, 0)
}

func (s *Seg_qualifier3Context) DMAONLY() antlr.TerminalNode {
	return s.GetToken(SHARCParserDMAONLY, 0)
}

func (s *Seg_qualifier3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Seg_qualifier3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Seg_qualifier3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterSeg_qualifier3(s)
	}
}

func (s *Seg_qualifier3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitSeg_qualifier3(s)
	}
}

func (p *SHARCParser) Seg_qualifier3() (localctx ISeg_qualifier3Context) {
	this := p
	_ = this

	localctx = NewSeg_qualifier3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SHARCParserRULE_seg_qualifier3)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(371)
		p.Match(SHARCParserDIV)
	}
	{
		p.SetState(372)
		p.Match(SHARCParserDMAONLY)
	}

	return localctx
}

// ISeg_qualifier_1Context is an interface to support dynamic dispatch.
type ISeg_qualifier_1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeg_qualifier_1Context differentiates from other interfaces.
	IsSeg_qualifier_1Context()
}

type Seg_qualifier_1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeg_qualifier_1Context() *Seg_qualifier_1Context {
	var p = new(Seg_qualifier_1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_seg_qualifier_1
	return p
}

func (*Seg_qualifier_1Context) IsSeg_qualifier_1Context() {}

func NewSeg_qualifier_1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Seg_qualifier_1Context {
	var p = new(Seg_qualifier_1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_seg_qualifier_1

	return p
}

func (s *Seg_qualifier_1Context) GetParser() antlr.Parser { return s.parser }

func (s *Seg_qualifier_1Context) PM() antlr.TerminalNode {
	return s.GetToken(SHARCParserPM, 0)
}

func (s *Seg_qualifier_1Context) CODE() antlr.TerminalNode {
	return s.GetToken(SHARCParserCODE, 0)
}

func (s *Seg_qualifier_1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Seg_qualifier_1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Seg_qualifier_1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterSeg_qualifier_1(s)
	}
}

func (s *Seg_qualifier_1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitSeg_qualifier_1(s)
	}
}

func (p *SHARCParser) Seg_qualifier_1() (localctx ISeg_qualifier_1Context) {
	this := p
	_ = this

	localctx = NewSeg_qualifier_1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SHARCParserRULE_seg_qualifier_1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(374)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SHARCParserPM || _la == SHARCParserCODE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISeg_qualifier_2Context is an interface to support dynamic dispatch.
type ISeg_qualifier_2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeg_qualifier_2Context differentiates from other interfaces.
	IsSeg_qualifier_2Context()
}

type Seg_qualifier_2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeg_qualifier_2Context() *Seg_qualifier_2Context {
	var p = new(Seg_qualifier_2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_seg_qualifier_2
	return p
}

func (*Seg_qualifier_2Context) IsSeg_qualifier_2Context() {}

func NewSeg_qualifier_2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Seg_qualifier_2Context {
	var p = new(Seg_qualifier_2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_seg_qualifier_2

	return p
}

func (s *Seg_qualifier_2Context) GetParser() antlr.Parser { return s.parser }

func (s *Seg_qualifier_2Context) DM() antlr.TerminalNode {
	return s.GetToken(SHARCParserDM, 0)
}

func (s *Seg_qualifier_2Context) DATA() antlr.TerminalNode {
	return s.GetToken(SHARCParserDATA, 0)
}

func (s *Seg_qualifier_2Context) DATA64() antlr.TerminalNode {
	return s.GetToken(SHARCParserDATA64, 0)
}

func (s *Seg_qualifier_2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Seg_qualifier_2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Seg_qualifier_2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterSeg_qualifier_2(s)
	}
}

func (s *Seg_qualifier_2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitSeg_qualifier_2(s)
	}
}

func (p *SHARCParser) Seg_qualifier_2() (localctx ISeg_qualifier_2Context) {
	this := p
	_ = this

	localctx = NewSeg_qualifier_2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SHARCParserRULE_seg_qualifier_2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(376)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SHARCParserDM || _la == SHARCParserDATA || _la == SHARCParserDATA64) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISeg_qualifier_3Context is an interface to support dynamic dispatch.
type ISeg_qualifier_3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeg_qualifier_3Context differentiates from other interfaces.
	IsSeg_qualifier_3Context()
}

type Seg_qualifier_3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeg_qualifier_3Context() *Seg_qualifier_3Context {
	var p = new(Seg_qualifier_3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_seg_qualifier_3
	return p
}

func (*Seg_qualifier_3Context) IsSeg_qualifier_3Context() {}

func NewSeg_qualifier_3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Seg_qualifier_3Context {
	var p = new(Seg_qualifier_3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_seg_qualifier_3

	return p
}

func (s *Seg_qualifier_3Context) GetParser() antlr.Parser { return s.parser }

func (s *Seg_qualifier_3Context) NO_INIT() antlr.TerminalNode {
	return s.GetToken(SHARCParserNO_INIT, 0)
}

func (s *Seg_qualifier_3Context) ZERO_INIT() antlr.TerminalNode {
	return s.GetToken(SHARCParserZERO_INIT, 0)
}

func (s *Seg_qualifier_3Context) RUNTIME_INIT() antlr.TerminalNode {
	return s.GetToken(SHARCParserRUNTIME_INIT, 0)
}

func (s *Seg_qualifier_3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Seg_qualifier_3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Seg_qualifier_3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterSeg_qualifier_3(s)
	}
}

func (s *Seg_qualifier_3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitSeg_qualifier_3(s)
	}
}

func (p *SHARCParser) Seg_qualifier_3() (localctx ISeg_qualifier_3Context) {
	this := p
	_ = this

	localctx = NewSeg_qualifier_3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SHARCParserRULE_seg_qualifier_3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(378)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(SHARCParserNO_INIT-395))|(1<<(SHARCParserZERO_INIT-395))|(1<<(SHARCParserRUNTIME_INIT-395)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_stmt
	return p
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Compute() IComputeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputeContext)
}

func (s *StmtContext) Flow_control_exp() IFlow_control_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_expContext)
}

func (s *StmtContext) Imm_mov_exp() IImm_mov_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImm_mov_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImm_mov_expContext)
}

func (s *StmtContext) Misc_exp() IMisc_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMisc_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMisc_expContext)
}

func (s *StmtContext) Declaration() IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *StmtContext) If_compute_mov() IIf_compute_movContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_compute_movContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_compute_movContext)
}

func (s *StmtContext) Compute_mov_exp() ICompute_mov_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompute_mov_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompute_mov_expContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitStmt(s)
	}
}

func (p *SHARCParser) Stmt() (localctx IStmtContext) {
	this := p
	_ = this

	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SHARCParserRULE_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(387)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(380)
			p.Compute()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(381)
			p.Flow_control_exp()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(382)
			p.Imm_mov_exp()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(383)
			p.Misc_exp()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(384)
			p.Declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(385)
			p.If_compute_mov()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(386)
			p.Compute_mov_exp()
		}

	}

	return localctx
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) DOT_VAR() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_VAR, 0)
}

func (s *DeclarationContext) Declaration_exp1() IDeclaration_exp1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_exp1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_exp1Context)
}

func (s *DeclarationContext) Declaration_exp2() IDeclaration_exp2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_exp2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_exp2Context)
}

func (s *DeclarationContext) Declaration_exp3() IDeclaration_exp3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_exp3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_exp3Context)
}

func (s *DeclarationContext) Declaration_exp4() IDeclaration_exp4Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_exp4Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_exp4Context)
}

func (s *DeclarationContext) Declaration_exp5() IDeclaration_exp5Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_exp5Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_exp5Context)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (p *SHARCParser) Declaration() (localctx IDeclarationContext) {
	this := p
	_ = this

	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SHARCParserRULE_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.Match(SHARCParserDOT_VAR)
	}
	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(390)
			p.Declaration_exp1()
		}

	case 2:
		{
			p.SetState(391)
			p.Declaration_exp2()
		}

	case 3:
		{
			p.SetState(392)
			p.Declaration_exp3()
		}

	case 4:
		{
			p.SetState(393)
			p.Declaration_exp4()
		}

	case 5:
		{
			p.SetState(394)
			p.Declaration_exp5()
		}

	}

	return localctx
}

// IDeclaration_exp1Context is an interface to support dynamic dispatch.
type IDeclaration_exp1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaration_exp1Context differentiates from other interfaces.
	IsDeclaration_exp1Context()
}

type Declaration_exp1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaration_exp1Context() *Declaration_exp1Context {
	var p = new(Declaration_exp1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_declaration_exp1
	return p
}

func (*Declaration_exp1Context) IsDeclaration_exp1Context() {}

func NewDeclaration_exp1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_exp1Context {
	var p = new(Declaration_exp1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_declaration_exp1

	return p
}

func (s *Declaration_exp1Context) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_exp1Context) AllID() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserID)
}

func (s *Declaration_exp1Context) ID(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserID, i)
}

func (s *Declaration_exp1Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserCOMMA)
}

func (s *Declaration_exp1Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, i)
}

func (s *Declaration_exp1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_exp1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declaration_exp1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterDeclaration_exp1(s)
	}
}

func (s *Declaration_exp1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitDeclaration_exp1(s)
	}
}

func (p *SHARCParser) Declaration_exp1() (localctx IDeclaration_exp1Context) {
	this := p
	_ = this

	localctx = NewDeclaration_exp1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SHARCParserRULE_declaration_exp1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(397)
		p.Match(SHARCParserID)
	}
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SHARCParserCOMMA {
		{
			p.SetState(398)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(399)
			p.Match(SHARCParserID)
		}

		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDeclaration_exp2Context is an interface to support dynamic dispatch.
type IDeclaration_exp2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaration_exp2Context differentiates from other interfaces.
	IsDeclaration_exp2Context()
}

type Declaration_exp2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaration_exp2Context() *Declaration_exp2Context {
	var p = new(Declaration_exp2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_declaration_exp2
	return p
}

func (*Declaration_exp2Context) IsDeclaration_exp2Context() {}

func NewDeclaration_exp2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_exp2Context {
	var p = new(Declaration_exp2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_declaration_exp2

	return p
}

func (s *Declaration_exp2Context) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_exp2Context) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Declaration_exp2Context) AllInitExpression() []IInitExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInitExpressionContext)(nil)).Elem())
	var tst = make([]IInitExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInitExpressionContext)
		}
	}

	return tst
}

func (s *Declaration_exp2Context) InitExpression(i int) IInitExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInitExpressionContext)
}

func (s *Declaration_exp2Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserCOMMA)
}

func (s *Declaration_exp2Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, i)
}

func (s *Declaration_exp2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_exp2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declaration_exp2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterDeclaration_exp2(s)
	}
}

func (s *Declaration_exp2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitDeclaration_exp2(s)
	}
}

func (p *SHARCParser) Declaration_exp2() (localctx IDeclaration_exp2Context) {
	this := p
	_ = this

	localctx = NewDeclaration_exp2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SHARCParserRULE_declaration_exp2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(405)
		p.Match(SHARCParserEQU)
	}
	{
		p.SetState(406)
		p.InitExpression()
	}
	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SHARCParserCOMMA {
		{
			p.SetState(407)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(408)
			p.InitExpression()
		}

		p.SetState(413)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDeclaration_exp3Context is an interface to support dynamic dispatch.
type IDeclaration_exp3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaration_exp3Context differentiates from other interfaces.
	IsDeclaration_exp3Context()
}

type Declaration_exp3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaration_exp3Context() *Declaration_exp3Context {
	var p = new(Declaration_exp3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_declaration_exp3
	return p
}

func (*Declaration_exp3Context) IsDeclaration_exp3Context() {}

func NewDeclaration_exp3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_exp3Context {
	var p = new(Declaration_exp3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_declaration_exp3

	return p
}

func (s *Declaration_exp3Context) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_exp3Context) ID() antlr.TerminalNode {
	return s.GetToken(SHARCParserID, 0)
}

func (s *Declaration_exp3Context) LBRACKET() antlr.TerminalNode {
	return s.GetToken(SHARCParserLBRACKET, 0)
}

func (s *Declaration_exp3Context) RBRACKET() antlr.TerminalNode {
	return s.GetToken(SHARCParserRBRACKET, 0)
}

func (s *Declaration_exp3Context) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Declaration_exp3Context) Declaration_exp_f2() IDeclaration_exp_f2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_exp_f2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_exp_f2Context)
}

func (s *Declaration_exp3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_exp3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declaration_exp3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterDeclaration_exp3(s)
	}
}

func (s *Declaration_exp3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitDeclaration_exp3(s)
	}
}

func (p *SHARCParser) Declaration_exp3() (localctx IDeclaration_exp3Context) {
	this := p
	_ = this

	localctx = NewDeclaration_exp3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SHARCParserRULE_declaration_exp3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.Match(SHARCParserID)
	}
	{
		p.SetState(415)
		p.Match(SHARCParserLBRACKET)
	}
	{
		p.SetState(416)
		p.Match(SHARCParserRBRACKET)
	}
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SHARCParserEQU {
		{
			p.SetState(417)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(418)
			p.Declaration_exp_f2()
		}

	}

	return localctx
}

// IDeclaration_exp4Context is an interface to support dynamic dispatch.
type IDeclaration_exp4Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaration_exp4Context differentiates from other interfaces.
	IsDeclaration_exp4Context()
}

type Declaration_exp4Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaration_exp4Context() *Declaration_exp4Context {
	var p = new(Declaration_exp4Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_declaration_exp4
	return p
}

func (*Declaration_exp4Context) IsDeclaration_exp4Context() {}

func NewDeclaration_exp4Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_exp4Context {
	var p = new(Declaration_exp4Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_declaration_exp4

	return p
}

func (s *Declaration_exp4Context) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_exp4Context) ID() antlr.TerminalNode {
	return s.GetToken(SHARCParserID, 0)
}

func (s *Declaration_exp4Context) LBRACKET() antlr.TerminalNode {
	return s.GetToken(SHARCParserLBRACKET, 0)
}

func (s *Declaration_exp4Context) Value_exp() IValue_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_expContext)
}

func (s *Declaration_exp4Context) RBRACKET() antlr.TerminalNode {
	return s.GetToken(SHARCParserRBRACKET, 0)
}

func (s *Declaration_exp4Context) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Declaration_exp4Context) Declaration_exp_f2() IDeclaration_exp_f2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_exp_f2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_exp_f2Context)
}

func (s *Declaration_exp4Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_exp4Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declaration_exp4Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterDeclaration_exp4(s)
	}
}

func (s *Declaration_exp4Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitDeclaration_exp4(s)
	}
}

func (p *SHARCParser) Declaration_exp4() (localctx IDeclaration_exp4Context) {
	this := p
	_ = this

	localctx = NewDeclaration_exp4Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SHARCParserRULE_declaration_exp4)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(421)
		p.Match(SHARCParserID)
	}
	{
		p.SetState(422)
		p.Match(SHARCParserLBRACKET)
	}
	{
		p.SetState(423)
		p.Value_exp()
	}
	{
		p.SetState(424)
		p.Match(SHARCParserRBRACKET)
	}
	p.SetState(427)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SHARCParserEQU {
		{
			p.SetState(425)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(426)
			p.Declaration_exp_f2()
		}

	}

	return localctx
}

// IDeclaration_exp5Context is an interface to support dynamic dispatch.
type IDeclaration_exp5Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaration_exp5Context differentiates from other interfaces.
	IsDeclaration_exp5Context()
}

type Declaration_exp5Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaration_exp5Context() *Declaration_exp5Context {
	var p = new(Declaration_exp5Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_declaration_exp5
	return p
}

func (*Declaration_exp5Context) IsDeclaration_exp5Context() {}

func NewDeclaration_exp5Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_exp5Context {
	var p = new(Declaration_exp5Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_declaration_exp5

	return p
}

func (s *Declaration_exp5Context) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_exp5Context) ID() antlr.TerminalNode {
	return s.GetToken(SHARCParserID, 0)
}

func (s *Declaration_exp5Context) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Declaration_exp5Context) Value_exp() IValue_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_expContext)
}

func (s *Declaration_exp5Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_exp5Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declaration_exp5Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterDeclaration_exp5(s)
	}
}

func (s *Declaration_exp5Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitDeclaration_exp5(s)
	}
}

func (p *SHARCParser) Declaration_exp5() (localctx IDeclaration_exp5Context) {
	this := p
	_ = this

	localctx = NewDeclaration_exp5Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SHARCParserRULE_declaration_exp5)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(429)
		p.Match(SHARCParserID)
	}
	{
		p.SetState(430)
		p.Match(SHARCParserEQU)
	}
	{
		p.SetState(431)
		p.Value_exp()
	}

	return localctx
}

// IDeclaration_exp_f1Context is an interface to support dynamic dispatch.
type IDeclaration_exp_f1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaration_exp_f1Context differentiates from other interfaces.
	IsDeclaration_exp_f1Context()
}

type Declaration_exp_f1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaration_exp_f1Context() *Declaration_exp_f1Context {
	var p = new(Declaration_exp_f1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_declaration_exp_f1
	return p
}

func (*Declaration_exp_f1Context) IsDeclaration_exp_f1Context() {}

func NewDeclaration_exp_f1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_exp_f1Context {
	var p = new(Declaration_exp_f1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_declaration_exp_f1

	return p
}

func (s *Declaration_exp_f1Context) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_exp_f1Context) AllInitExpression() []IInitExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInitExpressionContext)(nil)).Elem())
	var tst = make([]IInitExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInitExpressionContext)
		}
	}

	return tst
}

func (s *Declaration_exp_f1Context) InitExpression(i int) IInitExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInitExpressionContext)
}

func (s *Declaration_exp_f1Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserCOMMA)
}

func (s *Declaration_exp_f1Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, i)
}

func (s *Declaration_exp_f1Context) StringLiteral() antlr.TerminalNode {
	return s.GetToken(SHARCParserStringLiteral, 0)
}

func (s *Declaration_exp_f1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_exp_f1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declaration_exp_f1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterDeclaration_exp_f1(s)
	}
}

func (s *Declaration_exp_f1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitDeclaration_exp_f1(s)
	}
}

func (p *SHARCParser) Declaration_exp_f1() (localctx IDeclaration_exp_f1Context) {
	this := p
	_ = this

	localctx = NewDeclaration_exp_f1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SHARCParserRULE_declaration_exp_f1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(442)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserCharLiteral, SHARCParserINT, SHARCParserLENGTH, SHARCParserMINUS, SHARCParserLPARENTHESE, SHARCParserAT, SHARCParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(433)
			p.InitExpression()
		}
		p.SetState(438)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SHARCParserCOMMA {
			{
				p.SetState(434)
				p.Match(SHARCParserCOMMA)
			}
			{
				p.SetState(435)
				p.InitExpression()
			}

			p.SetState(440)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case SHARCParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(441)
			p.Match(SHARCParserStringLiteral)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDeclaration_exp_f2Context is an interface to support dynamic dispatch.
type IDeclaration_exp_f2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaration_exp_f2Context differentiates from other interfaces.
	IsDeclaration_exp_f2Context()
}

type Declaration_exp_f2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaration_exp_f2Context() *Declaration_exp_f2Context {
	var p = new(Declaration_exp_f2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_declaration_exp_f2
	return p
}

func (*Declaration_exp_f2Context) IsDeclaration_exp_f2Context() {}

func NewDeclaration_exp_f2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_exp_f2Context {
	var p = new(Declaration_exp_f2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_declaration_exp_f2

	return p
}

func (s *Declaration_exp_f2Context) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_exp_f2Context) LBRACE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLBRACE, 0)
}

func (s *Declaration_exp_f2Context) Declaration_exp_f1() IDeclaration_exp_f1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_exp_f1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_exp_f1Context)
}

func (s *Declaration_exp_f2Context) RBRACE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRBRACE, 0)
}

func (s *Declaration_exp_f2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_exp_f2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declaration_exp_f2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterDeclaration_exp_f2(s)
	}
}

func (s *Declaration_exp_f2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitDeclaration_exp_f2(s)
	}
}

func (p *SHARCParser) Declaration_exp_f2() (localctx IDeclaration_exp_f2Context) {
	this := p
	_ = this

	localctx = NewDeclaration_exp_f2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SHARCParserRULE_declaration_exp_f2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(449)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(444)
			p.Match(SHARCParserLBRACE)
		}
		{
			p.SetState(445)
			p.Declaration_exp_f1()
		}
		{
			p.SetState(446)
			p.Match(SHARCParserRBRACE)
		}

	case SHARCParserStringLiteral, SHARCParserCharLiteral, SHARCParserINT, SHARCParserLENGTH, SHARCParserMINUS, SHARCParserLPARENTHESE, SHARCParserAT, SHARCParserID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(448)
			p.Declaration_exp_f1()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInitExpressionContext is an interface to support dynamic dispatch.
type IInitExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitExpressionContext differentiates from other interfaces.
	IsInitExpressionContext()
}

type InitExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitExpressionContext() *InitExpressionContext {
	var p = new(InitExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_initExpression
	return p
}

func (*InitExpressionContext) IsInitExpressionContext() {}

func NewInitExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitExpressionContext {
	var p = new(InitExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_initExpression

	return p
}

func (s *InitExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *InitExpressionContext) Value_exp() IValue_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_expContext)
}

func (s *InitExpressionContext) CharLiteral() antlr.TerminalNode {
	return s.GetToken(SHARCParserCharLiteral, 0)
}

func (s *InitExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterInitExpression(s)
	}
}

func (s *InitExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitInitExpression(s)
	}
}

func (p *SHARCParser) InitExpression() (localctx IInitExpressionContext) {
	this := p
	_ = this

	localctx = NewInitExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SHARCParserRULE_initExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(453)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserINT, SHARCParserLENGTH, SHARCParserMINUS, SHARCParserLPARENTHESE, SHARCParserAT, SHARCParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(451)
			p.Value_exp()
		}

	case SHARCParserCharLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(452)
			p.Match(SHARCParserCharLiteral)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVar_addrContext is an interface to support dynamic dispatch.
type IVar_addrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVar_addrContext differentiates from other interfaces.
	IsVar_addrContext()
}

type Var_addrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_addrContext() *Var_addrContext {
	var p = new(Var_addrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_var_addr
	return p
}

func (*Var_addrContext) IsVar_addrContext() {}

func NewVar_addrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_addrContext {
	var p = new(Var_addrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_var_addr

	return p
}

func (s *Var_addrContext) GetParser() antlr.Parser { return s.parser }

func (s *Var_addrContext) AT() antlr.TerminalNode {
	return s.GetToken(SHARCParserAT, 0)
}

func (s *Var_addrContext) ID() antlr.TerminalNode {
	return s.GetToken(SHARCParserID, 0)
}

func (s *Var_addrContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(SHARCParserLENGTH, 0)
}

func (s *Var_addrContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Var_addrContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Var_addrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_addrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_addrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterVar_addr(s)
	}
}

func (s *Var_addrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitVar_addr(s)
	}
}

func (p *SHARCParser) Var_addr() (localctx IVar_addrContext) {
	this := p
	_ = this

	localctx = NewVar_addrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SHARCParserRULE_var_addr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(461)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(455)
			p.Match(SHARCParserAT)
		}
		{
			p.SetState(456)
			p.Match(SHARCParserID)
		}

	case SHARCParserLENGTH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(457)
			p.Match(SHARCParserLENGTH)
		}
		{
			p.SetState(458)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(459)
			p.Match(SHARCParserID)
		}
		{
			p.SetState(460)
			p.Match(SHARCParserRPARENTHESE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IValue_expContext is an interface to support dynamic dispatch.
type IValue_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_expContext differentiates from other interfaces.
	IsValue_expContext()
}

type Value_expContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_expContext() *Value_expContext {
	var p = new(Value_expContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_value_exp
	return p
}

func (*Value_expContext) IsValue_expContext() {}

func NewValue_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_expContext {
	var p = new(Value_expContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_value_exp

	return p
}

func (s *Value_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_expContext) Value_exp2() IValue_exp2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_exp2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_exp2Context)
}

func (s *Value_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterValue_exp(s)
	}
}

func (s *Value_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitValue_exp(s)
	}
}

func (p *SHARCParser) Value_exp() (localctx IValue_expContext) {
	this := p
	_ = this

	localctx = NewValue_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SHARCParserRULE_value_exp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(463)
		p.Value_exp2()
	}

	return localctx
}

// IValue_exp2Context is an interface to support dynamic dispatch.
type IValue_exp2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_exp2Context differentiates from other interfaces.
	IsValue_exp2Context()
}

type Value_exp2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_exp2Context() *Value_exp2Context {
	var p = new(Value_exp2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_value_exp2
	return p
}

func (*Value_exp2Context) IsValue_exp2Context() {}

func NewValue_exp2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_exp2Context {
	var p = new(Value_exp2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_value_exp2

	return p
}

func (s *Value_exp2Context) GetParser() antlr.Parser { return s.parser }

func (s *Value_exp2Context) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Value_exp2Context) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Value_exp2Context) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserPLUS)
}

func (s *Value_exp2Context) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserPLUS, i)
}

func (s *Value_exp2Context) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserMINUS)
}

func (s *Value_exp2Context) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserMINUS, i)
}

func (s *Value_exp2Context) AllMULT() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserMULT)
}

func (s *Value_exp2Context) MULT(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserMULT, i)
}

func (s *Value_exp2Context) AllDIV() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserDIV)
}

func (s *Value_exp2Context) DIV(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserDIV, i)
}

func (s *Value_exp2Context) AllDIV_MOD() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserDIV_MOD)
}

func (s *Value_exp2Context) DIV_MOD(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserDIV_MOD, i)
}

func (s *Value_exp2Context) AllI_OR() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserI_OR)
}

func (s *Value_exp2Context) I_OR(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserI_OR, i)
}

func (s *Value_exp2Context) AllI_XOR() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserI_XOR)
}

func (s *Value_exp2Context) I_XOR(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserI_XOR, i)
}

func (s *Value_exp2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_exp2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_exp2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterValue_exp2(s)
	}
}

func (s *Value_exp2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitValue_exp2(s)
	}
}

func (p *SHARCParser) Value_exp2() (localctx IValue_exp2Context) {
	this := p
	_ = this

	localctx = NewValue_exp2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SHARCParserRULE_value_exp2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(465)
		p.Term()
	}
	p.SetState(470)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-377)&-(0x1f+1)) == 0 && ((1<<uint((_la-377)))&((1<<(SHARCParserPLUS-377))|(1<<(SHARCParserMINUS-377))|(1<<(SHARCParserMULT-377))|(1<<(SHARCParserDIV-377))|(1<<(SHARCParserDIV_MOD-377))|(1<<(SHARCParserI_OR-377))|(1<<(SHARCParserI_XOR-377)))) != 0 {
		{
			p.SetState(466)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-377)&-(0x1f+1)) == 0 && ((1<<uint((_la-377)))&((1<<(SHARCParserPLUS-377))|(1<<(SHARCParserMINUS-377))|(1<<(SHARCParserMULT-377))|(1<<(SHARCParserDIV-377))|(1<<(SHARCParserDIV_MOD-377))|(1<<(SHARCParserI_OR-377))|(1<<(SHARCParserI_XOR-377)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(467)
			p.Term()
		}

		p.SetState(472)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) GetOp() antlr.Token { return s.op }

func (s *TermContext) SetOp(v antlr.Token) { s.op = v }

func (s *TermContext) Factor() IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *TermContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SHARCParserMINUS, 0)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (p *SHARCParser) Term() (localctx ITermContext) {
	this := p
	_ = this

	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SHARCParserRULE_term)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(474)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SHARCParserMINUS {
		{
			p.SetState(473)

			var _m = p.Match(SHARCParserMINUS)

			localctx.(*TermContext).op = _m
		}

	}
	{
		p.SetState(476)
		p.Factor()
	}

	return localctx
}

// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_factor
	return p
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *FactorContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *FactorContext) Value_exp2() IValue_exp2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_exp2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_exp2Context)
}

func (s *FactorContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFactor(s)
	}
}

func (p *SHARCParser) Factor() (localctx IFactorContext) {
	this := p
	_ = this

	localctx = NewFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SHARCParserRULE_factor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(483)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserINT, SHARCParserLENGTH, SHARCParserAT, SHARCParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(478)
			p.Atom()
		}

	case SHARCParserLPARENTHESE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(479)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(480)
			p.Value_exp2()
		}
		{
			p.SetState(481)
			p.Match(SHARCParserRPARENTHESE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) INT() antlr.TerminalNode {
	return s.GetToken(SHARCParserINT, 0)
}

func (s *AtomContext) Var_addr() IVar_addrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVar_addrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVar_addrContext)
}

func (s *AtomContext) ID() antlr.TerminalNode {
	return s.GetToken(SHARCParserID, 0)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *SHARCParser) Atom() (localctx IAtomContext) {
	this := p
	_ = this

	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SHARCParserRULE_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(488)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserINT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(485)
			p.Match(SHARCParserINT)
		}

	case SHARCParserLENGTH, SHARCParserAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(486)
			p.Var_addr()
		}

	case SHARCParserID:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(487)
			p.Match(SHARCParserID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IComputeContext is an interface to support dynamic dispatch.
type IComputeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComputeContext differentiates from other interfaces.
	IsComputeContext()
}

type ComputeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputeContext() *ComputeContext {
	var p = new(ComputeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_compute
	return p
}

func (*ComputeContext) IsComputeContext() {}

func NewComputeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputeContext {
	var p = new(ComputeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_compute

	return p
}

func (s *ComputeContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputeContext) Dual_op() IDual_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDual_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDual_opContext)
}

func (s *ComputeContext) Fixpoint_alu_op() IFixpoint_alu_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFixpoint_alu_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFixpoint_alu_opContext)
}

func (s *ComputeContext) Floating_point_alu_op() IFloating_point_alu_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloating_point_alu_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloating_point_alu_opContext)
}

func (s *ComputeContext) Multi_op() IMulti_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_opContext)
}

func (s *ComputeContext) Shifter_op() IShifter_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShifter_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShifter_opContext)
}

func (s *ComputeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterCompute(s)
	}
}

func (s *ComputeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitCompute(s)
	}
}

func (p *SHARCParser) Compute() (localctx IComputeContext) {
	this := p
	_ = this

	localctx = NewComputeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SHARCParserRULE_compute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(490)
			p.Dual_op()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(491)
			p.Fixpoint_alu_op()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(492)
			p.Floating_point_alu_op()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(493)
			p.Multi_op()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(494)
			p.Shifter_op()
		}

	}

	return localctx
}

// IIf_compute_movContext is an interface to support dynamic dispatch.
type IIf_compute_movContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_compute_movContext differentiates from other interfaces.
	IsIf_compute_movContext()
}

type If_compute_movContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_compute_movContext() *If_compute_movContext {
	var p = new(If_compute_movContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_if_compute_mov
	return p
}

func (*If_compute_movContext) IsIf_compute_movContext() {}

func NewIf_compute_movContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_compute_movContext {
	var p = new(If_compute_movContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_if_compute_mov

	return p
}

func (s *If_compute_movContext) GetParser() antlr.Parser { return s.parser }

func (s *If_compute_movContext) IF() antlr.TerminalNode {
	return s.GetToken(SHARCParserIF, 0)
}

func (s *If_compute_movContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *If_compute_movContext) If_compute_mov_exp() IIf_compute_mov_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_compute_mov_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_compute_mov_expContext)
}

func (s *If_compute_movContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_compute_movContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_compute_movContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterIf_compute_mov(s)
	}
}

func (s *If_compute_movContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitIf_compute_mov(s)
	}
}

func (p *SHARCParser) If_compute_mov() (localctx IIf_compute_movContext) {
	this := p
	_ = this

	localctx = NewIf_compute_movContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SHARCParserRULE_if_compute_mov)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(497)
		p.Match(SHARCParserIF)
	}
	{
		p.SetState(498)
		p.Condition()
	}
	{
		p.SetState(499)
		p.If_compute_mov_exp()
	}

	return localctx
}

// IIf_compute_mov_expContext is an interface to support dynamic dispatch.
type IIf_compute_mov_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_compute_mov_expContext differentiates from other interfaces.
	IsIf_compute_mov_expContext()
}

type If_compute_mov_expContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_compute_mov_expContext() *If_compute_mov_expContext {
	var p = new(If_compute_mov_expContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_if_compute_mov_exp
	return p
}

func (*If_compute_mov_expContext) IsIf_compute_mov_expContext() {}

func NewIf_compute_mov_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_compute_mov_expContext {
	var p = new(If_compute_mov_expContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_if_compute_mov_exp

	return p
}

func (s *If_compute_mov_expContext) GetParser() antlr.Parser { return s.parser }

func (s *If_compute_mov_expContext) Compute_mov_exp() ICompute_mov_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompute_mov_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompute_mov_expContext)
}

func (s *If_compute_mov_expContext) Compute() IComputeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputeContext)
}

func (s *If_compute_mov_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_compute_mov_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_compute_mov_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterIf_compute_mov_exp(s)
	}
}

func (s *If_compute_mov_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitIf_compute_mov_exp(s)
	}
}

func (p *SHARCParser) If_compute_mov_exp() (localctx IIf_compute_mov_expContext) {
	this := p
	_ = this

	localctx = NewIf_compute_mov_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SHARCParserRULE_if_compute_mov_exp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(501)
			p.Compute_mov_exp()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(502)
			p.Compute()
		}

	}

	return localctx
}

// ICompute_mov_expContext is an interface to support dynamic dispatch.
type ICompute_mov_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompute_mov_expContext differentiates from other interfaces.
	IsCompute_mov_expContext()
}

type Compute_mov_expContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompute_mov_expContext() *Compute_mov_expContext {
	var p = new(Compute_mov_expContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_compute_mov_exp
	return p
}

func (*Compute_mov_expContext) IsCompute_mov_expContext() {}

func NewCompute_mov_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compute_mov_expContext {
	var p = new(Compute_mov_expContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_compute_mov_exp

	return p
}

func (s *Compute_mov_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Compute_mov_expContext) Mov_exp_1() IMov_exp_1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMov_exp_1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMov_exp_1Context)
}

func (s *Compute_mov_expContext) Mov_exp_3a() IMov_exp_3aContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMov_exp_3aContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMov_exp_3aContext)
}

func (s *Compute_mov_expContext) Mov_exp_3b() IMov_exp_3bContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMov_exp_3bContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMov_exp_3bContext)
}

func (s *Compute_mov_expContext) Mov_exp_3c() IMov_exp_3cContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMov_exp_3cContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMov_exp_3cContext)
}

func (s *Compute_mov_expContext) Mov_exp_3d() IMov_exp_3dContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMov_exp_3dContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMov_exp_3dContext)
}

func (s *Compute_mov_expContext) Mov_exp_4a() IMov_exp_4aContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMov_exp_4aContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMov_exp_4aContext)
}

func (s *Compute_mov_expContext) Mov_exp_4b() IMov_exp_4bContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMov_exp_4bContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMov_exp_4bContext)
}

func (s *Compute_mov_expContext) Mov_exp_4c() IMov_exp_4cContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMov_exp_4cContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMov_exp_4cContext)
}

func (s *Compute_mov_expContext) Mov_exp_4d() IMov_exp_4dContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMov_exp_4dContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMov_exp_4dContext)
}

func (s *Compute_mov_expContext) Mov_exp_5() IMov_exp_5Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMov_exp_5Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMov_exp_5Context)
}

func (s *Compute_mov_expContext) Mov_exp_7() IMov_exp_7Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMov_exp_7Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMov_exp_7Context)
}

func (s *Compute_mov_expContext) Compute() IComputeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputeContext)
}

func (s *Compute_mov_expContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Compute_mov_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compute_mov_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compute_mov_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterCompute_mov_exp(s)
	}
}

func (s *Compute_mov_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitCompute_mov_exp(s)
	}
}

func (p *SHARCParser) Compute_mov_exp() (localctx ICompute_mov_expContext) {
	this := p
	_ = this

	localctx = NewCompute_mov_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SHARCParserRULE_compute_mov_exp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(508)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(505)
			p.Compute()
		}
		{
			p.SetState(506)
			p.Match(SHARCParserCOMMA)
		}

	}
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(510)
			p.Mov_exp_1()
		}

	case 2:
		{
			p.SetState(511)
			p.Mov_exp_3a()
		}

	case 3:
		{
			p.SetState(512)
			p.Mov_exp_3b()
		}

	case 4:
		{
			p.SetState(513)
			p.Mov_exp_3c()
		}

	case 5:
		{
			p.SetState(514)
			p.Mov_exp_3d()
		}

	case 6:
		{
			p.SetState(515)
			p.Mov_exp_4a()
		}

	case 7:
		{
			p.SetState(516)
			p.Mov_exp_4b()
		}

	case 8:
		{
			p.SetState(517)
			p.Mov_exp_4c()
		}

	case 9:
		{
			p.SetState(518)
			p.Mov_exp_4d()
		}

	case 10:
		{
			p.SetState(519)
			p.Mov_exp_5()
		}

	case 11:
		{
			p.SetState(520)
			p.Mov_exp_7()
		}

	}

	return localctx
}

// IMov_exp_1Context is an interface to support dynamic dispatch.
type IMov_exp_1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_1Context differentiates from other interfaces.
	IsMov_exp_1Context()
}

type Mov_exp_1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_1Context() *Mov_exp_1Context {
	var p = new(Mov_exp_1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_1
	return p
}

func (*Mov_exp_1Context) IsMov_exp_1Context() {}

func NewMov_exp_1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_1Context {
	var p = new(Mov_exp_1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_1

	return p
}

func (s *Mov_exp_1Context) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_1Context) Mov_exp_1_1() IMov_exp_1_1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMov_exp_1_1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMov_exp_1_1Context)
}

func (s *Mov_exp_1Context) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Mov_exp_1Context) Mov_exp_1_2() IMov_exp_1_2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMov_exp_1_2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMov_exp_1_2Context)
}

func (s *Mov_exp_1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_1(s)
	}
}

func (s *Mov_exp_1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_1(s)
	}
}

func (p *SHARCParser) Mov_exp_1() (localctx IMov_exp_1Context) {
	this := p
	_ = this

	localctx = NewMov_exp_1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SHARCParserRULE_mov_exp_1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(523)
		p.Mov_exp_1_1()
	}
	{
		p.SetState(524)
		p.Match(SHARCParserCOMMA)
	}
	{
		p.SetState(525)
		p.Mov_exp_1_2()
	}

	return localctx
}

// IMov_exp_1_1Context is an interface to support dynamic dispatch.
type IMov_exp_1_1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_1_1Context differentiates from other interfaces.
	IsMov_exp_1_1Context()
}

type Mov_exp_1_1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_1_1Context() *Mov_exp_1_1Context {
	var p = new(Mov_exp_1_1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_1_1
	return p
}

func (*Mov_exp_1_1Context) IsMov_exp_1_1Context() {}

func NewMov_exp_1_1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_1_1Context {
	var p = new(Mov_exp_1_1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_1_1

	return p
}

func (s *Mov_exp_1_1Context) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_1_1Context) Mem_addr_dm_ia_mb() IMem_addr_dm_ia_mbContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_dm_ia_mbContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_dm_ia_mbContext)
}

func (s *Mov_exp_1_1Context) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Mov_exp_1_1Context) D_reg() ID_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ID_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ID_regContext)
}

func (s *Mov_exp_1_1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_1_1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_1_1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_1_1(s)
	}
}

func (s *Mov_exp_1_1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_1_1(s)
	}
}

func (p *SHARCParser) Mov_exp_1_1() (localctx IMov_exp_1_1Context) {
	this := p
	_ = this

	localctx = NewMov_exp_1_1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SHARCParserRULE_mov_exp_1_1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(535)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(527)
			p.Mem_addr_dm_ia_mb()
		}
		{
			p.SetState(528)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(529)
			p.D_reg()
		}

	case SHARCParserF0, SHARCParserF1, SHARCParserF2, SHARCParserF3, SHARCParserF4, SHARCParserF5, SHARCParserF6, SHARCParserF7, SHARCParserF8, SHARCParserF9, SHARCParserF10, SHARCParserF11, SHARCParserF12, SHARCParserF13, SHARCParserF14, SHARCParserF15, SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(531)
			p.D_reg()
		}
		{
			p.SetState(532)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(533)
			p.Mem_addr_dm_ia_mb()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMov_exp_1_2Context is an interface to support dynamic dispatch.
type IMov_exp_1_2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_1_2Context differentiates from other interfaces.
	IsMov_exp_1_2Context()
}

type Mov_exp_1_2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_1_2Context() *Mov_exp_1_2Context {
	var p = new(Mov_exp_1_2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_1_2
	return p
}

func (*Mov_exp_1_2Context) IsMov_exp_1_2Context() {}

func NewMov_exp_1_2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_1_2Context {
	var p = new(Mov_exp_1_2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_1_2

	return p
}

func (s *Mov_exp_1_2Context) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_1_2Context) Mem_addr_pm_ic_md() IMem_addr_pm_ic_mdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_pm_ic_mdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_pm_ic_mdContext)
}

func (s *Mov_exp_1_2Context) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Mov_exp_1_2Context) D_reg() ID_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ID_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ID_regContext)
}

func (s *Mov_exp_1_2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_1_2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_1_2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_1_2(s)
	}
}

func (s *Mov_exp_1_2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_1_2(s)
	}
}

func (p *SHARCParser) Mov_exp_1_2() (localctx IMov_exp_1_2Context) {
	this := p
	_ = this

	localctx = NewMov_exp_1_2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SHARCParserRULE_mov_exp_1_2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(545)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserPM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(537)
			p.Mem_addr_pm_ic_md()
		}
		{
			p.SetState(538)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(539)
			p.D_reg()
		}

	case SHARCParserF0, SHARCParserF1, SHARCParserF2, SHARCParserF3, SHARCParserF4, SHARCParserF5, SHARCParserF6, SHARCParserF7, SHARCParserF8, SHARCParserF9, SHARCParserF10, SHARCParserF11, SHARCParserF12, SHARCParserF13, SHARCParserF14, SHARCParserF15, SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(541)
			p.D_reg()
		}
		{
			p.SetState(542)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(543)
			p.Mem_addr_pm_ic_md()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMov_exp_3aContext is an interface to support dynamic dispatch.
type IMov_exp_3aContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_3aContext differentiates from other interfaces.
	IsMov_exp_3aContext()
}

type Mov_exp_3aContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_3aContext() *Mov_exp_3aContext {
	var p = new(Mov_exp_3aContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_3a
	return p
}

func (*Mov_exp_3aContext) IsMov_exp_3aContext() {}

func NewMov_exp_3aContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_3aContext {
	var p = new(Mov_exp_3aContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_3a

	return p
}

func (s *Mov_exp_3aContext) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_3aContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Mov_exp_3aContext) U_reg() IU_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IU_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IU_regContext)
}

func (s *Mov_exp_3aContext) Mem_addr_dm_ia_mb() IMem_addr_dm_ia_mbContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_dm_ia_mbContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_dm_ia_mbContext)
}

func (s *Mov_exp_3aContext) Mem_addr_pm_ic_md() IMem_addr_pm_ic_mdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_pm_ic_mdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_pm_ic_mdContext)
}

func (s *Mov_exp_3aContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_3aContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_3aContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_3a(s)
	}
}

func (s *Mov_exp_3aContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_3a(s)
	}
}

func (p *SHARCParser) Mov_exp_3a() (localctx IMov_exp_3aContext) {
	this := p
	_ = this

	localctx = NewMov_exp_3aContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SHARCParserRULE_mov_exp_3a)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(549)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDM:
		{
			p.SetState(547)
			p.Mem_addr_dm_ia_mb()
		}

	case SHARCParserPM:
		{
			p.SetState(548)
			p.Mem_addr_pm_ic_md()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(551)
		p.Match(SHARCParserEQU)
	}
	{
		p.SetState(552)
		p.U_reg()
	}

	return localctx
}

// IMov_exp_3bContext is an interface to support dynamic dispatch.
type IMov_exp_3bContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_3bContext differentiates from other interfaces.
	IsMov_exp_3bContext()
}

type Mov_exp_3bContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_3bContext() *Mov_exp_3bContext {
	var p = new(Mov_exp_3bContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_3b
	return p
}

func (*Mov_exp_3bContext) IsMov_exp_3bContext() {}

func NewMov_exp_3bContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_3bContext {
	var p = new(Mov_exp_3bContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_3b

	return p
}

func (s *Mov_exp_3bContext) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_3bContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Mov_exp_3bContext) U_reg() IU_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IU_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IU_regContext)
}

func (s *Mov_exp_3bContext) Mem_addr_dm_mb_ia() IMem_addr_dm_mb_iaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_dm_mb_iaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_dm_mb_iaContext)
}

func (s *Mov_exp_3bContext) Mem_addr_pm_md_ic() IMem_addr_pm_md_icContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_pm_md_icContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_pm_md_icContext)
}

func (s *Mov_exp_3bContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_3bContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_3bContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_3b(s)
	}
}

func (s *Mov_exp_3bContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_3b(s)
	}
}

func (p *SHARCParser) Mov_exp_3b() (localctx IMov_exp_3bContext) {
	this := p
	_ = this

	localctx = NewMov_exp_3bContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SHARCParserRULE_mov_exp_3b)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(556)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDM:
		{
			p.SetState(554)
			p.Mem_addr_dm_mb_ia()
		}

	case SHARCParserPM:
		{
			p.SetState(555)
			p.Mem_addr_pm_md_ic()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(558)
		p.Match(SHARCParserEQU)
	}
	{
		p.SetState(559)
		p.U_reg()
	}

	return localctx
}

// IMov_exp_3cContext is an interface to support dynamic dispatch.
type IMov_exp_3cContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_3cContext differentiates from other interfaces.
	IsMov_exp_3cContext()
}

type Mov_exp_3cContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_3cContext() *Mov_exp_3cContext {
	var p = new(Mov_exp_3cContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_3c
	return p
}

func (*Mov_exp_3cContext) IsMov_exp_3cContext() {}

func NewMov_exp_3cContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_3cContext {
	var p = new(Mov_exp_3cContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_3c

	return p
}

func (s *Mov_exp_3cContext) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_3cContext) U_reg() IU_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IU_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IU_regContext)
}

func (s *Mov_exp_3cContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Mov_exp_3cContext) Mem_addr_dm_ia_mb() IMem_addr_dm_ia_mbContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_dm_ia_mbContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_dm_ia_mbContext)
}

func (s *Mov_exp_3cContext) Mem_addr_pm_ic_md() IMem_addr_pm_ic_mdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_pm_ic_mdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_pm_ic_mdContext)
}

func (s *Mov_exp_3cContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_3cContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_3cContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_3c(s)
	}
}

func (s *Mov_exp_3cContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_3c(s)
	}
}

func (p *SHARCParser) Mov_exp_3c() (localctx IMov_exp_3cContext) {
	this := p
	_ = this

	localctx = NewMov_exp_3cContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SHARCParserRULE_mov_exp_3c)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(561)
		p.U_reg()
	}
	{
		p.SetState(562)
		p.Match(SHARCParserEQU)
	}
	p.SetState(565)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDM:
		{
			p.SetState(563)
			p.Mem_addr_dm_ia_mb()
		}

	case SHARCParserPM:
		{
			p.SetState(564)
			p.Mem_addr_pm_ic_md()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMov_exp_3dContext is an interface to support dynamic dispatch.
type IMov_exp_3dContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_3dContext differentiates from other interfaces.
	IsMov_exp_3dContext()
}

type Mov_exp_3dContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_3dContext() *Mov_exp_3dContext {
	var p = new(Mov_exp_3dContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_3d
	return p
}

func (*Mov_exp_3dContext) IsMov_exp_3dContext() {}

func NewMov_exp_3dContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_3dContext {
	var p = new(Mov_exp_3dContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_3d

	return p
}

func (s *Mov_exp_3dContext) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_3dContext) U_reg() IU_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IU_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IU_regContext)
}

func (s *Mov_exp_3dContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Mov_exp_3dContext) Mem_addr_dm_mb_ia() IMem_addr_dm_mb_iaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_dm_mb_iaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_dm_mb_iaContext)
}

func (s *Mov_exp_3dContext) Mem_addr_pm_md_ic() IMem_addr_pm_md_icContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_pm_md_icContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_pm_md_icContext)
}

func (s *Mov_exp_3dContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_3dContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_3dContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_3d(s)
	}
}

func (s *Mov_exp_3dContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_3d(s)
	}
}

func (p *SHARCParser) Mov_exp_3d() (localctx IMov_exp_3dContext) {
	this := p
	_ = this

	localctx = NewMov_exp_3dContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SHARCParserRULE_mov_exp_3d)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(567)
		p.U_reg()
	}
	{
		p.SetState(568)
		p.Match(SHARCParserEQU)
	}
	p.SetState(571)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDM:
		{
			p.SetState(569)
			p.Mem_addr_dm_mb_ia()
		}

	case SHARCParserPM:
		{
			p.SetState(570)
			p.Mem_addr_pm_md_ic()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMov_exp_4aContext is an interface to support dynamic dispatch.
type IMov_exp_4aContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_4aContext differentiates from other interfaces.
	IsMov_exp_4aContext()
}

type Mov_exp_4aContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_4aContext() *Mov_exp_4aContext {
	var p = new(Mov_exp_4aContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_4a
	return p
}

func (*Mov_exp_4aContext) IsMov_exp_4aContext() {}

func NewMov_exp_4aContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_4aContext {
	var p = new(Mov_exp_4aContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_4a

	return p
}

func (s *Mov_exp_4aContext) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_4aContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Mov_exp_4aContext) D_reg() ID_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ID_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ID_regContext)
}

func (s *Mov_exp_4aContext) Mem_addr_dm_ia_int() IMem_addr_dm_ia_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_dm_ia_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_dm_ia_intContext)
}

func (s *Mov_exp_4aContext) Mem_addr_pm_ic_int() IMem_addr_pm_ic_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_pm_ic_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_pm_ic_intContext)
}

func (s *Mov_exp_4aContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_4aContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_4aContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_4a(s)
	}
}

func (s *Mov_exp_4aContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_4a(s)
	}
}

func (p *SHARCParser) Mov_exp_4a() (localctx IMov_exp_4aContext) {
	this := p
	_ = this

	localctx = NewMov_exp_4aContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SHARCParserRULE_mov_exp_4a)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(575)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDM:
		{
			p.SetState(573)
			p.Mem_addr_dm_ia_int()
		}

	case SHARCParserPM:
		{
			p.SetState(574)
			p.Mem_addr_pm_ic_int()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(577)
		p.Match(SHARCParserEQU)
	}
	{
		p.SetState(578)
		p.D_reg()
	}

	return localctx
}

// IMov_exp_4bContext is an interface to support dynamic dispatch.
type IMov_exp_4bContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_4bContext differentiates from other interfaces.
	IsMov_exp_4bContext()
}

type Mov_exp_4bContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_4bContext() *Mov_exp_4bContext {
	var p = new(Mov_exp_4bContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_4b
	return p
}

func (*Mov_exp_4bContext) IsMov_exp_4bContext() {}

func NewMov_exp_4bContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_4bContext {
	var p = new(Mov_exp_4bContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_4b

	return p
}

func (s *Mov_exp_4bContext) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_4bContext) Imm_mov_15a() IImm_mov_15aContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImm_mov_15aContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImm_mov_15aContext)
}

func (s *Mov_exp_4bContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_4bContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_4bContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_4b(s)
	}
}

func (s *Mov_exp_4bContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_4b(s)
	}
}

func (p *SHARCParser) Mov_exp_4b() (localctx IMov_exp_4bContext) {
	this := p
	_ = this

	localctx = NewMov_exp_4bContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SHARCParserRULE_mov_exp_4b)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)
		p.Imm_mov_15a()
	}

	return localctx
}

// IMov_exp_4cContext is an interface to support dynamic dispatch.
type IMov_exp_4cContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_4cContext differentiates from other interfaces.
	IsMov_exp_4cContext()
}

type Mov_exp_4cContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_4cContext() *Mov_exp_4cContext {
	var p = new(Mov_exp_4cContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_4c
	return p
}

func (*Mov_exp_4cContext) IsMov_exp_4cContext() {}

func NewMov_exp_4cContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_4cContext {
	var p = new(Mov_exp_4cContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_4c

	return p
}

func (s *Mov_exp_4cContext) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_4cContext) D_reg() ID_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ID_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ID_regContext)
}

func (s *Mov_exp_4cContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Mov_exp_4cContext) Mem_addr_dm_ia_int() IMem_addr_dm_ia_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_dm_ia_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_dm_ia_intContext)
}

func (s *Mov_exp_4cContext) Mem_addr_pm_ic_int() IMem_addr_pm_ic_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_pm_ic_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_pm_ic_intContext)
}

func (s *Mov_exp_4cContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_4cContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_4cContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_4c(s)
	}
}

func (s *Mov_exp_4cContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_4c(s)
	}
}

func (p *SHARCParser) Mov_exp_4c() (localctx IMov_exp_4cContext) {
	this := p
	_ = this

	localctx = NewMov_exp_4cContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SHARCParserRULE_mov_exp_4c)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(582)
		p.D_reg()
	}
	{
		p.SetState(583)
		p.Match(SHARCParserEQU)
	}
	p.SetState(586)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDM:
		{
			p.SetState(584)
			p.Mem_addr_dm_ia_int()
		}

	case SHARCParserPM:
		{
			p.SetState(585)
			p.Mem_addr_pm_ic_int()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMov_exp_4dContext is an interface to support dynamic dispatch.
type IMov_exp_4dContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_4dContext differentiates from other interfaces.
	IsMov_exp_4dContext()
}

type Mov_exp_4dContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_4dContext() *Mov_exp_4dContext {
	var p = new(Mov_exp_4dContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_4d
	return p
}

func (*Mov_exp_4dContext) IsMov_exp_4dContext() {}

func NewMov_exp_4dContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_4dContext {
	var p = new(Mov_exp_4dContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_4d

	return p
}

func (s *Mov_exp_4dContext) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_4dContext) Imm_mov_15b() IImm_mov_15bContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImm_mov_15bContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImm_mov_15bContext)
}

func (s *Mov_exp_4dContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_4dContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_4dContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_4d(s)
	}
}

func (s *Mov_exp_4dContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_4d(s)
	}
}

func (p *SHARCParser) Mov_exp_4d() (localctx IMov_exp_4dContext) {
	this := p
	_ = this

	localctx = NewMov_exp_4dContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SHARCParserRULE_mov_exp_4d)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(588)
		p.Imm_mov_15b()
	}

	return localctx
}

// IMov_exp_5Context is an interface to support dynamic dispatch.
type IMov_exp_5Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_5Context differentiates from other interfaces.
	IsMov_exp_5Context()
}

type Mov_exp_5Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_5Context() *Mov_exp_5Context {
	var p = new(Mov_exp_5Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_5
	return p
}

func (*Mov_exp_5Context) IsMov_exp_5Context() {}

func NewMov_exp_5Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_5Context {
	var p = new(Mov_exp_5Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_5

	return p
}

func (s *Mov_exp_5Context) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_5Context) U_reg2() IU_reg2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IU_reg2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IU_reg2Context)
}

func (s *Mov_exp_5Context) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Mov_exp_5Context) U_reg() IU_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IU_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IU_regContext)
}

func (s *Mov_exp_5Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_5Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_5Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_5(s)
	}
}

func (s *Mov_exp_5Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_5(s)
	}
}

func (p *SHARCParser) Mov_exp_5() (localctx IMov_exp_5Context) {
	this := p
	_ = this

	localctx = NewMov_exp_5Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SHARCParserRULE_mov_exp_5)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(590)
		p.U_reg2()
	}
	{
		p.SetState(591)
		p.Match(SHARCParserEQU)
	}
	{
		p.SetState(592)
		p.U_reg()
	}

	return localctx
}

// IMov_exp_6aContext is an interface to support dynamic dispatch.
type IMov_exp_6aContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_6aContext differentiates from other interfaces.
	IsMov_exp_6aContext()
}

type Mov_exp_6aContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_6aContext() *Mov_exp_6aContext {
	var p = new(Mov_exp_6aContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_6a
	return p
}

func (*Mov_exp_6aContext) IsMov_exp_6aContext() {}

func NewMov_exp_6aContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_6aContext {
	var p = new(Mov_exp_6aContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_6a

	return p
}

func (s *Mov_exp_6aContext) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_6aContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Mov_exp_6aContext) D_reg() ID_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ID_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ID_regContext)
}

func (s *Mov_exp_6aContext) Mem_addr_dm_ia_mb() IMem_addr_dm_ia_mbContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_dm_ia_mbContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_dm_ia_mbContext)
}

func (s *Mov_exp_6aContext) Mem_addr_pm_ic_md() IMem_addr_pm_ic_mdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_pm_ic_mdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_pm_ic_mdContext)
}

func (s *Mov_exp_6aContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_6aContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_6aContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_6a(s)
	}
}

func (s *Mov_exp_6aContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_6a(s)
	}
}

func (p *SHARCParser) Mov_exp_6a() (localctx IMov_exp_6aContext) {
	this := p
	_ = this

	localctx = NewMov_exp_6aContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SHARCParserRULE_mov_exp_6a)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(596)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDM:
		{
			p.SetState(594)
			p.Mem_addr_dm_ia_mb()
		}

	case SHARCParserPM:
		{
			p.SetState(595)
			p.Mem_addr_pm_ic_md()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(598)
		p.Match(SHARCParserEQU)
	}
	{
		p.SetState(599)
		p.D_reg()
	}

	return localctx
}

// IMov_exp_6bContext is an interface to support dynamic dispatch.
type IMov_exp_6bContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_6bContext differentiates from other interfaces.
	IsMov_exp_6bContext()
}

type Mov_exp_6bContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_6bContext() *Mov_exp_6bContext {
	var p = new(Mov_exp_6bContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_6b
	return p
}

func (*Mov_exp_6bContext) IsMov_exp_6bContext() {}

func NewMov_exp_6bContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_6bContext {
	var p = new(Mov_exp_6bContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_6b

	return p
}

func (s *Mov_exp_6bContext) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_6bContext) D_reg() ID_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ID_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ID_regContext)
}

func (s *Mov_exp_6bContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Mov_exp_6bContext) Mem_addr_dm_ia_mb() IMem_addr_dm_ia_mbContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_dm_ia_mbContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_dm_ia_mbContext)
}

func (s *Mov_exp_6bContext) Mem_addr_pm_ic_md() IMem_addr_pm_ic_mdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_pm_ic_mdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_pm_ic_mdContext)
}

func (s *Mov_exp_6bContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_6bContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_6bContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_6b(s)
	}
}

func (s *Mov_exp_6bContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_6b(s)
	}
}

func (p *SHARCParser) Mov_exp_6b() (localctx IMov_exp_6bContext) {
	this := p
	_ = this

	localctx = NewMov_exp_6bContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SHARCParserRULE_mov_exp_6b)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(601)
		p.D_reg()
	}
	{
		p.SetState(602)
		p.Match(SHARCParserEQU)
	}
	p.SetState(605)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDM:
		{
			p.SetState(603)
			p.Mem_addr_dm_ia_mb()
		}

	case SHARCParserPM:
		{
			p.SetState(604)
			p.Mem_addr_pm_ic_md()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMov_exp_7Context is an interface to support dynamic dispatch.
type IMov_exp_7Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMov_exp_7Context differentiates from other interfaces.
	IsMov_exp_7Context()
}

type Mov_exp_7Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMov_exp_7Context() *Mov_exp_7Context {
	var p = new(Mov_exp_7Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mov_exp_7
	return p
}

func (*Mov_exp_7Context) IsMov_exp_7Context() {}

func NewMov_exp_7Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mov_exp_7Context {
	var p = new(Mov_exp_7Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mov_exp_7

	return p
}

func (s *Mov_exp_7Context) GetParser() antlr.Parser { return s.parser }

func (s *Mov_exp_7Context) MODIFY() antlr.TerminalNode {
	return s.GetToken(SHARCParserMODIFY, 0)
}

func (s *Mov_exp_7Context) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Mov_exp_7Context) Ia() IIaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIaContext)
}

func (s *Mov_exp_7Context) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Mov_exp_7Context) Mb() IMbContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMbContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMbContext)
}

func (s *Mov_exp_7Context) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Mov_exp_7Context) Ic() IIcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIcContext)
}

func (s *Mov_exp_7Context) Md() IMdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMdContext)
}

func (s *Mov_exp_7Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mov_exp_7Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mov_exp_7Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMov_exp_7(s)
	}
}

func (s *Mov_exp_7Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMov_exp_7(s)
	}
}

func (p *SHARCParser) Mov_exp_7() (localctx IMov_exp_7Context) {
	this := p
	_ = this

	localctx = NewMov_exp_7Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SHARCParserRULE_mov_exp_7)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.Match(SHARCParserMODIFY)
	}
	p.SetState(620)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(608)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(609)
			p.Ia()
		}
		{
			p.SetState(610)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(611)
			p.Mb()
		}
		{
			p.SetState(612)
			p.Match(SHARCParserRPARENTHESE)
		}

	case 2:
		{
			p.SetState(614)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(615)
			p.Ic()
		}
		{
			p.SetState(616)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(617)
			p.Md()
		}
		{
			p.SetState(618)
			p.Match(SHARCParserRPARENTHESE)
		}

	}

	return localctx
}

// IMem_addr_ia_mbContext is an interface to support dynamic dispatch.
type IMem_addr_ia_mbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_ia_mbContext differentiates from other interfaces.
	IsMem_addr_ia_mbContext()
}

type Mem_addr_ia_mbContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_ia_mbContext() *Mem_addr_ia_mbContext {
	var p = new(Mem_addr_ia_mbContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_ia_mb
	return p
}

func (*Mem_addr_ia_mbContext) IsMem_addr_ia_mbContext() {}

func NewMem_addr_ia_mbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_ia_mbContext {
	var p = new(Mem_addr_ia_mbContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_ia_mb

	return p
}

func (s *Mem_addr_ia_mbContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_ia_mbContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Mem_addr_ia_mbContext) Ia() IIaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIaContext)
}

func (s *Mem_addr_ia_mbContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Mem_addr_ia_mbContext) Mb() IMbContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMbContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMbContext)
}

func (s *Mem_addr_ia_mbContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Mem_addr_ia_mbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_ia_mbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_ia_mbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_ia_mb(s)
	}
}

func (s *Mem_addr_ia_mbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_ia_mb(s)
	}
}

func (p *SHARCParser) Mem_addr_ia_mb() (localctx IMem_addr_ia_mbContext) {
	this := p
	_ = this

	localctx = NewMem_addr_ia_mbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SHARCParserRULE_mem_addr_ia_mb)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(622)
		p.Match(SHARCParserLPARENTHESE)
	}
	{
		p.SetState(623)
		p.Ia()
	}
	{
		p.SetState(624)
		p.Match(SHARCParserCOMMA)
	}
	{
		p.SetState(625)
		p.Mb()
	}
	{
		p.SetState(626)
		p.Match(SHARCParserRPARENTHESE)
	}

	return localctx
}

// IMem_addr_ic_mdContext is an interface to support dynamic dispatch.
type IMem_addr_ic_mdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_ic_mdContext differentiates from other interfaces.
	IsMem_addr_ic_mdContext()
}

type Mem_addr_ic_mdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_ic_mdContext() *Mem_addr_ic_mdContext {
	var p = new(Mem_addr_ic_mdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_ic_md
	return p
}

func (*Mem_addr_ic_mdContext) IsMem_addr_ic_mdContext() {}

func NewMem_addr_ic_mdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_ic_mdContext {
	var p = new(Mem_addr_ic_mdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_ic_md

	return p
}

func (s *Mem_addr_ic_mdContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_ic_mdContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Mem_addr_ic_mdContext) Ic() IIcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIcContext)
}

func (s *Mem_addr_ic_mdContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Mem_addr_ic_mdContext) Md() IMdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMdContext)
}

func (s *Mem_addr_ic_mdContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Mem_addr_ic_mdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_ic_mdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_ic_mdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_ic_md(s)
	}
}

func (s *Mem_addr_ic_mdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_ic_md(s)
	}
}

func (p *SHARCParser) Mem_addr_ic_md() (localctx IMem_addr_ic_mdContext) {
	this := p
	_ = this

	localctx = NewMem_addr_ic_mdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SHARCParserRULE_mem_addr_ic_md)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(628)
		p.Match(SHARCParserLPARENTHESE)
	}
	{
		p.SetState(629)
		p.Ic()
	}
	{
		p.SetState(630)
		p.Match(SHARCParserCOMMA)
	}
	{
		p.SetState(631)
		p.Md()
	}
	{
		p.SetState(632)
		p.Match(SHARCParserRPARENTHESE)
	}

	return localctx
}

// IMem_addr_md_icContext is an interface to support dynamic dispatch.
type IMem_addr_md_icContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_md_icContext differentiates from other interfaces.
	IsMem_addr_md_icContext()
}

type Mem_addr_md_icContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_md_icContext() *Mem_addr_md_icContext {
	var p = new(Mem_addr_md_icContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_md_ic
	return p
}

func (*Mem_addr_md_icContext) IsMem_addr_md_icContext() {}

func NewMem_addr_md_icContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_md_icContext {
	var p = new(Mem_addr_md_icContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_md_ic

	return p
}

func (s *Mem_addr_md_icContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_md_icContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Mem_addr_md_icContext) Md() IMdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMdContext)
}

func (s *Mem_addr_md_icContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Mem_addr_md_icContext) Ic() IIcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIcContext)
}

func (s *Mem_addr_md_icContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Mem_addr_md_icContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_md_icContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_md_icContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_md_ic(s)
	}
}

func (s *Mem_addr_md_icContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_md_ic(s)
	}
}

func (p *SHARCParser) Mem_addr_md_ic() (localctx IMem_addr_md_icContext) {
	this := p
	_ = this

	localctx = NewMem_addr_md_icContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SHARCParserRULE_mem_addr_md_ic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(634)
		p.Match(SHARCParserLPARENTHESE)
	}
	{
		p.SetState(635)
		p.Md()
	}
	{
		p.SetState(636)
		p.Match(SHARCParserCOMMA)
	}
	{
		p.SetState(637)
		p.Ic()
	}
	{
		p.SetState(638)
		p.Match(SHARCParserRPARENTHESE)
	}

	return localctx
}

// IMem_addr_mb_iaContext is an interface to support dynamic dispatch.
type IMem_addr_mb_iaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_mb_iaContext differentiates from other interfaces.
	IsMem_addr_mb_iaContext()
}

type Mem_addr_mb_iaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_mb_iaContext() *Mem_addr_mb_iaContext {
	var p = new(Mem_addr_mb_iaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_mb_ia
	return p
}

func (*Mem_addr_mb_iaContext) IsMem_addr_mb_iaContext() {}

func NewMem_addr_mb_iaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_mb_iaContext {
	var p = new(Mem_addr_mb_iaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_mb_ia

	return p
}

func (s *Mem_addr_mb_iaContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_mb_iaContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Mem_addr_mb_iaContext) Mb() IMbContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMbContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMbContext)
}

func (s *Mem_addr_mb_iaContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Mem_addr_mb_iaContext) Ia() IIaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIaContext)
}

func (s *Mem_addr_mb_iaContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Mem_addr_mb_iaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_mb_iaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_mb_iaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_mb_ia(s)
	}
}

func (s *Mem_addr_mb_iaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_mb_ia(s)
	}
}

func (p *SHARCParser) Mem_addr_mb_ia() (localctx IMem_addr_mb_iaContext) {
	this := p
	_ = this

	localctx = NewMem_addr_mb_iaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SHARCParserRULE_mem_addr_mb_ia)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.Match(SHARCParserLPARENTHESE)
	}
	{
		p.SetState(641)
		p.Mb()
	}
	{
		p.SetState(642)
		p.Match(SHARCParserCOMMA)
	}
	{
		p.SetState(643)
		p.Ia()
	}
	{
		p.SetState(644)
		p.Match(SHARCParserRPARENTHESE)
	}

	return localctx
}

// IMem_addr_ia_intContext is an interface to support dynamic dispatch.
type IMem_addr_ia_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_ia_intContext differentiates from other interfaces.
	IsMem_addr_ia_intContext()
}

type Mem_addr_ia_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_ia_intContext() *Mem_addr_ia_intContext {
	var p = new(Mem_addr_ia_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_ia_int
	return p
}

func (*Mem_addr_ia_intContext) IsMem_addr_ia_intContext() {}

func NewMem_addr_ia_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_ia_intContext {
	var p = new(Mem_addr_ia_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_ia_int

	return p
}

func (s *Mem_addr_ia_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_ia_intContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Mem_addr_ia_intContext) Ia() IIaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIaContext)
}

func (s *Mem_addr_ia_intContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Mem_addr_ia_intContext) Value_exp() IValue_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_expContext)
}

func (s *Mem_addr_ia_intContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Mem_addr_ia_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_ia_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_ia_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_ia_int(s)
	}
}

func (s *Mem_addr_ia_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_ia_int(s)
	}
}

func (p *SHARCParser) Mem_addr_ia_int() (localctx IMem_addr_ia_intContext) {
	this := p
	_ = this

	localctx = NewMem_addr_ia_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SHARCParserRULE_mem_addr_ia_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(646)
		p.Match(SHARCParserLPARENTHESE)
	}
	{
		p.SetState(647)
		p.Ia()
	}
	{
		p.SetState(648)
		p.Match(SHARCParserCOMMA)
	}
	{
		p.SetState(649)
		p.Value_exp()
	}
	{
		p.SetState(650)
		p.Match(SHARCParserRPARENTHESE)
	}

	return localctx
}

// IMem_addr_ic_intContext is an interface to support dynamic dispatch.
type IMem_addr_ic_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_ic_intContext differentiates from other interfaces.
	IsMem_addr_ic_intContext()
}

type Mem_addr_ic_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_ic_intContext() *Mem_addr_ic_intContext {
	var p = new(Mem_addr_ic_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_ic_int
	return p
}

func (*Mem_addr_ic_intContext) IsMem_addr_ic_intContext() {}

func NewMem_addr_ic_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_ic_intContext {
	var p = new(Mem_addr_ic_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_ic_int

	return p
}

func (s *Mem_addr_ic_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_ic_intContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Mem_addr_ic_intContext) Ic() IIcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIcContext)
}

func (s *Mem_addr_ic_intContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Mem_addr_ic_intContext) Value_exp() IValue_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_expContext)
}

func (s *Mem_addr_ic_intContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Mem_addr_ic_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_ic_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_ic_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_ic_int(s)
	}
}

func (s *Mem_addr_ic_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_ic_int(s)
	}
}

func (p *SHARCParser) Mem_addr_ic_int() (localctx IMem_addr_ic_intContext) {
	this := p
	_ = this

	localctx = NewMem_addr_ic_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SHARCParserRULE_mem_addr_ic_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(652)
		p.Match(SHARCParserLPARENTHESE)
	}
	{
		p.SetState(653)
		p.Ic()
	}
	{
		p.SetState(654)
		p.Match(SHARCParserCOMMA)
	}
	{
		p.SetState(655)
		p.Value_exp()
	}
	{
		p.SetState(656)
		p.Match(SHARCParserRPARENTHESE)
	}

	return localctx
}

// IMem_addr_int_iaContext is an interface to support dynamic dispatch.
type IMem_addr_int_iaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_int_iaContext differentiates from other interfaces.
	IsMem_addr_int_iaContext()
}

type Mem_addr_int_iaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_int_iaContext() *Mem_addr_int_iaContext {
	var p = new(Mem_addr_int_iaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_int_ia
	return p
}

func (*Mem_addr_int_iaContext) IsMem_addr_int_iaContext() {}

func NewMem_addr_int_iaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_int_iaContext {
	var p = new(Mem_addr_int_iaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_int_ia

	return p
}

func (s *Mem_addr_int_iaContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_int_iaContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Mem_addr_int_iaContext) Value_exp() IValue_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_expContext)
}

func (s *Mem_addr_int_iaContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Mem_addr_int_iaContext) Ia() IIaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIaContext)
}

func (s *Mem_addr_int_iaContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Mem_addr_int_iaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_int_iaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_int_iaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_int_ia(s)
	}
}

func (s *Mem_addr_int_iaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_int_ia(s)
	}
}

func (p *SHARCParser) Mem_addr_int_ia() (localctx IMem_addr_int_iaContext) {
	this := p
	_ = this

	localctx = NewMem_addr_int_iaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SHARCParserRULE_mem_addr_int_ia)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(658)
		p.Match(SHARCParserLPARENTHESE)
	}
	{
		p.SetState(659)
		p.Value_exp()
	}
	{
		p.SetState(660)
		p.Match(SHARCParserCOMMA)
	}
	{
		p.SetState(661)
		p.Ia()
	}
	{
		p.SetState(662)
		p.Match(SHARCParserRPARENTHESE)
	}

	return localctx
}

// IMem_addr_int_icContext is an interface to support dynamic dispatch.
type IMem_addr_int_icContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_int_icContext differentiates from other interfaces.
	IsMem_addr_int_icContext()
}

type Mem_addr_int_icContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_int_icContext() *Mem_addr_int_icContext {
	var p = new(Mem_addr_int_icContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_int_ic
	return p
}

func (*Mem_addr_int_icContext) IsMem_addr_int_icContext() {}

func NewMem_addr_int_icContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_int_icContext {
	var p = new(Mem_addr_int_icContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_int_ic

	return p
}

func (s *Mem_addr_int_icContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_int_icContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Mem_addr_int_icContext) Value_exp() IValue_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_expContext)
}

func (s *Mem_addr_int_icContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Mem_addr_int_icContext) Ic() IIcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIcContext)
}

func (s *Mem_addr_int_icContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Mem_addr_int_icContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_int_icContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_int_icContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_int_ic(s)
	}
}

func (s *Mem_addr_int_icContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_int_ic(s)
	}
}

func (p *SHARCParser) Mem_addr_int_ic() (localctx IMem_addr_int_icContext) {
	this := p
	_ = this

	localctx = NewMem_addr_int_icContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SHARCParserRULE_mem_addr_int_ic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(664)
		p.Match(SHARCParserLPARENTHESE)
	}
	{
		p.SetState(665)
		p.Value_exp()
	}
	{
		p.SetState(666)
		p.Match(SHARCParserCOMMA)
	}
	{
		p.SetState(667)
		p.Ic()
	}
	{
		p.SetState(668)
		p.Match(SHARCParserRPARENTHESE)
	}

	return localctx
}

// IMem_addr_intContext is an interface to support dynamic dispatch.
type IMem_addr_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_intContext differentiates from other interfaces.
	IsMem_addr_intContext()
}

type Mem_addr_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_intContext() *Mem_addr_intContext {
	var p = new(Mem_addr_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_int
	return p
}

func (*Mem_addr_intContext) IsMem_addr_intContext() {}

func NewMem_addr_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_intContext {
	var p = new(Mem_addr_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_int

	return p
}

func (s *Mem_addr_intContext) GetParser() antlr.Parser { return s.parser }
func (s *Mem_addr_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_int(s)
	}
}

func (s *Mem_addr_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_int(s)
	}
}

func (p *SHARCParser) Mem_addr_int() (localctx IMem_addr_intContext) {
	this := p
	_ = this

	localctx = NewMem_addr_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SHARCParserRULE_mem_addr_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IMem_addr_int_Context is an interface to support dynamic dispatch.
type IMem_addr_int_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_int_Context differentiates from other interfaces.
	IsMem_addr_int_Context()
}

type Mem_addr_int_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_int_Context() *Mem_addr_int_Context {
	var p = new(Mem_addr_int_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_int_
	return p
}

func (*Mem_addr_int_Context) IsMem_addr_int_Context() {}

func NewMem_addr_int_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_int_Context {
	var p = new(Mem_addr_int_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_int_

	return p
}

func (s *Mem_addr_int_Context) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_int_Context) AllAtom() []IAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtomContext)(nil)).Elem())
	var tst = make([]IAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtomContext)
		}
	}

	return tst
}

func (s *Mem_addr_int_Context) Atom(i int) IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *Mem_addr_int_Context) PLUS() antlr.TerminalNode {
	return s.GetToken(SHARCParserPLUS, 0)
}

func (s *Mem_addr_int_Context) MINUS() antlr.TerminalNode {
	return s.GetToken(SHARCParserMINUS, 0)
}

func (s *Mem_addr_int_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_int_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_int_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_int_(s)
	}
}

func (s *Mem_addr_int_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_int_(s)
	}
}

func (p *SHARCParser) Mem_addr_int_() (localctx IMem_addr_int_Context) {
	this := p
	_ = this

	localctx = NewMem_addr_int_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SHARCParserRULE_mem_addr_int_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(672)
			p.Atom()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(673)
			p.Atom()
		}
		{
			p.SetState(674)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SHARCParserPLUS || _la == SHARCParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(675)
			p.Atom()
		}

	}

	return localctx
}

// IMem_addr_dm_ia_mbContext is an interface to support dynamic dispatch.
type IMem_addr_dm_ia_mbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_dm_ia_mbContext differentiates from other interfaces.
	IsMem_addr_dm_ia_mbContext()
}

type Mem_addr_dm_ia_mbContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_dm_ia_mbContext() *Mem_addr_dm_ia_mbContext {
	var p = new(Mem_addr_dm_ia_mbContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_dm_ia_mb
	return p
}

func (*Mem_addr_dm_ia_mbContext) IsMem_addr_dm_ia_mbContext() {}

func NewMem_addr_dm_ia_mbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_dm_ia_mbContext {
	var p = new(Mem_addr_dm_ia_mbContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_dm_ia_mb

	return p
}

func (s *Mem_addr_dm_ia_mbContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_dm_ia_mbContext) DM() antlr.TerminalNode {
	return s.GetToken(SHARCParserDM, 0)
}

func (s *Mem_addr_dm_ia_mbContext) Mem_addr_ia_mb() IMem_addr_ia_mbContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_ia_mbContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_ia_mbContext)
}

func (s *Mem_addr_dm_ia_mbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_dm_ia_mbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_dm_ia_mbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_dm_ia_mb(s)
	}
}

func (s *Mem_addr_dm_ia_mbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_dm_ia_mb(s)
	}
}

func (p *SHARCParser) Mem_addr_dm_ia_mb() (localctx IMem_addr_dm_ia_mbContext) {
	this := p
	_ = this

	localctx = NewMem_addr_dm_ia_mbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SHARCParserRULE_mem_addr_dm_ia_mb)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(679)
		p.Match(SHARCParserDM)
	}
	{
		p.SetState(680)
		p.Mem_addr_ia_mb()
	}

	return localctx
}

// IMem_addr_pm_ic_mdContext is an interface to support dynamic dispatch.
type IMem_addr_pm_ic_mdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_pm_ic_mdContext differentiates from other interfaces.
	IsMem_addr_pm_ic_mdContext()
}

type Mem_addr_pm_ic_mdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_pm_ic_mdContext() *Mem_addr_pm_ic_mdContext {
	var p = new(Mem_addr_pm_ic_mdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_pm_ic_md
	return p
}

func (*Mem_addr_pm_ic_mdContext) IsMem_addr_pm_ic_mdContext() {}

func NewMem_addr_pm_ic_mdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_pm_ic_mdContext {
	var p = new(Mem_addr_pm_ic_mdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_pm_ic_md

	return p
}

func (s *Mem_addr_pm_ic_mdContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_pm_ic_mdContext) PM() antlr.TerminalNode {
	return s.GetToken(SHARCParserPM, 0)
}

func (s *Mem_addr_pm_ic_mdContext) Mem_addr_ic_md() IMem_addr_ic_mdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_ic_mdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_ic_mdContext)
}

func (s *Mem_addr_pm_ic_mdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_pm_ic_mdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_pm_ic_mdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_pm_ic_md(s)
	}
}

func (s *Mem_addr_pm_ic_mdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_pm_ic_md(s)
	}
}

func (p *SHARCParser) Mem_addr_pm_ic_md() (localctx IMem_addr_pm_ic_mdContext) {
	this := p
	_ = this

	localctx = NewMem_addr_pm_ic_mdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SHARCParserRULE_mem_addr_pm_ic_md)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(682)
		p.Match(SHARCParserPM)
	}
	{
		p.SetState(683)
		p.Mem_addr_ic_md()
	}

	return localctx
}

// IMem_addr_dm_mb_iaContext is an interface to support dynamic dispatch.
type IMem_addr_dm_mb_iaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_dm_mb_iaContext differentiates from other interfaces.
	IsMem_addr_dm_mb_iaContext()
}

type Mem_addr_dm_mb_iaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_dm_mb_iaContext() *Mem_addr_dm_mb_iaContext {
	var p = new(Mem_addr_dm_mb_iaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_dm_mb_ia
	return p
}

func (*Mem_addr_dm_mb_iaContext) IsMem_addr_dm_mb_iaContext() {}

func NewMem_addr_dm_mb_iaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_dm_mb_iaContext {
	var p = new(Mem_addr_dm_mb_iaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_dm_mb_ia

	return p
}

func (s *Mem_addr_dm_mb_iaContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_dm_mb_iaContext) DM() antlr.TerminalNode {
	return s.GetToken(SHARCParserDM, 0)
}

func (s *Mem_addr_dm_mb_iaContext) Mem_addr_mb_ia() IMem_addr_mb_iaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_mb_iaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_mb_iaContext)
}

func (s *Mem_addr_dm_mb_iaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_dm_mb_iaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_dm_mb_iaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_dm_mb_ia(s)
	}
}

func (s *Mem_addr_dm_mb_iaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_dm_mb_ia(s)
	}
}

func (p *SHARCParser) Mem_addr_dm_mb_ia() (localctx IMem_addr_dm_mb_iaContext) {
	this := p
	_ = this

	localctx = NewMem_addr_dm_mb_iaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SHARCParserRULE_mem_addr_dm_mb_ia)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.Match(SHARCParserDM)
	}
	{
		p.SetState(686)
		p.Mem_addr_mb_ia()
	}

	return localctx
}

// IMem_addr_pm_md_icContext is an interface to support dynamic dispatch.
type IMem_addr_pm_md_icContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_pm_md_icContext differentiates from other interfaces.
	IsMem_addr_pm_md_icContext()
}

type Mem_addr_pm_md_icContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_pm_md_icContext() *Mem_addr_pm_md_icContext {
	var p = new(Mem_addr_pm_md_icContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_pm_md_ic
	return p
}

func (*Mem_addr_pm_md_icContext) IsMem_addr_pm_md_icContext() {}

func NewMem_addr_pm_md_icContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_pm_md_icContext {
	var p = new(Mem_addr_pm_md_icContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_pm_md_ic

	return p
}

func (s *Mem_addr_pm_md_icContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_pm_md_icContext) PM() antlr.TerminalNode {
	return s.GetToken(SHARCParserPM, 0)
}

func (s *Mem_addr_pm_md_icContext) Mem_addr_md_ic() IMem_addr_md_icContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_md_icContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_md_icContext)
}

func (s *Mem_addr_pm_md_icContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_pm_md_icContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_pm_md_icContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_pm_md_ic(s)
	}
}

func (s *Mem_addr_pm_md_icContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_pm_md_ic(s)
	}
}

func (p *SHARCParser) Mem_addr_pm_md_ic() (localctx IMem_addr_pm_md_icContext) {
	this := p
	_ = this

	localctx = NewMem_addr_pm_md_icContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SHARCParserRULE_mem_addr_pm_md_ic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(688)
		p.Match(SHARCParserPM)
	}
	{
		p.SetState(689)
		p.Mem_addr_md_ic()
	}

	return localctx
}

// IMem_addr_dm_ia_intContext is an interface to support dynamic dispatch.
type IMem_addr_dm_ia_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_dm_ia_intContext differentiates from other interfaces.
	IsMem_addr_dm_ia_intContext()
}

type Mem_addr_dm_ia_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_dm_ia_intContext() *Mem_addr_dm_ia_intContext {
	var p = new(Mem_addr_dm_ia_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_dm_ia_int
	return p
}

func (*Mem_addr_dm_ia_intContext) IsMem_addr_dm_ia_intContext() {}

func NewMem_addr_dm_ia_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_dm_ia_intContext {
	var p = new(Mem_addr_dm_ia_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_dm_ia_int

	return p
}

func (s *Mem_addr_dm_ia_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_dm_ia_intContext) DM() antlr.TerminalNode {
	return s.GetToken(SHARCParserDM, 0)
}

func (s *Mem_addr_dm_ia_intContext) Mem_addr_ia_int() IMem_addr_ia_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_ia_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_ia_intContext)
}

func (s *Mem_addr_dm_ia_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_dm_ia_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_dm_ia_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_dm_ia_int(s)
	}
}

func (s *Mem_addr_dm_ia_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_dm_ia_int(s)
	}
}

func (p *SHARCParser) Mem_addr_dm_ia_int() (localctx IMem_addr_dm_ia_intContext) {
	this := p
	_ = this

	localctx = NewMem_addr_dm_ia_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SHARCParserRULE_mem_addr_dm_ia_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(691)
		p.Match(SHARCParserDM)
	}
	{
		p.SetState(692)
		p.Mem_addr_ia_int()
	}

	return localctx
}

// IMem_addr_pm_ic_intContext is an interface to support dynamic dispatch.
type IMem_addr_pm_ic_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_pm_ic_intContext differentiates from other interfaces.
	IsMem_addr_pm_ic_intContext()
}

type Mem_addr_pm_ic_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_pm_ic_intContext() *Mem_addr_pm_ic_intContext {
	var p = new(Mem_addr_pm_ic_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_pm_ic_int
	return p
}

func (*Mem_addr_pm_ic_intContext) IsMem_addr_pm_ic_intContext() {}

func NewMem_addr_pm_ic_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_pm_ic_intContext {
	var p = new(Mem_addr_pm_ic_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_pm_ic_int

	return p
}

func (s *Mem_addr_pm_ic_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_pm_ic_intContext) PM() antlr.TerminalNode {
	return s.GetToken(SHARCParserPM, 0)
}

func (s *Mem_addr_pm_ic_intContext) Mem_addr_ic_int() IMem_addr_ic_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_ic_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_ic_intContext)
}

func (s *Mem_addr_pm_ic_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_pm_ic_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_pm_ic_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_pm_ic_int(s)
	}
}

func (s *Mem_addr_pm_ic_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_pm_ic_int(s)
	}
}

func (p *SHARCParser) Mem_addr_pm_ic_int() (localctx IMem_addr_pm_ic_intContext) {
	this := p
	_ = this

	localctx = NewMem_addr_pm_ic_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SHARCParserRULE_mem_addr_pm_ic_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(694)
		p.Match(SHARCParserPM)
	}
	{
		p.SetState(695)
		p.Mem_addr_ic_int()
	}

	return localctx
}

// IMem_addr_dm_int_iaContext is an interface to support dynamic dispatch.
type IMem_addr_dm_int_iaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_dm_int_iaContext differentiates from other interfaces.
	IsMem_addr_dm_int_iaContext()
}

type Mem_addr_dm_int_iaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_dm_int_iaContext() *Mem_addr_dm_int_iaContext {
	var p = new(Mem_addr_dm_int_iaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_dm_int_ia
	return p
}

func (*Mem_addr_dm_int_iaContext) IsMem_addr_dm_int_iaContext() {}

func NewMem_addr_dm_int_iaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_dm_int_iaContext {
	var p = new(Mem_addr_dm_int_iaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_dm_int_ia

	return p
}

func (s *Mem_addr_dm_int_iaContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_dm_int_iaContext) DM() antlr.TerminalNode {
	return s.GetToken(SHARCParserDM, 0)
}

func (s *Mem_addr_dm_int_iaContext) Mem_addr_int_ia() IMem_addr_int_iaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_int_iaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_int_iaContext)
}

func (s *Mem_addr_dm_int_iaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_dm_int_iaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_dm_int_iaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_dm_int_ia(s)
	}
}

func (s *Mem_addr_dm_int_iaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_dm_int_ia(s)
	}
}

func (p *SHARCParser) Mem_addr_dm_int_ia() (localctx IMem_addr_dm_int_iaContext) {
	this := p
	_ = this

	localctx = NewMem_addr_dm_int_iaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SHARCParserRULE_mem_addr_dm_int_ia)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(697)
		p.Match(SHARCParserDM)
	}
	{
		p.SetState(698)
		p.Mem_addr_int_ia()
	}

	return localctx
}

// IMem_addr_pm_int_icContext is an interface to support dynamic dispatch.
type IMem_addr_pm_int_icContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_pm_int_icContext differentiates from other interfaces.
	IsMem_addr_pm_int_icContext()
}

type Mem_addr_pm_int_icContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_pm_int_icContext() *Mem_addr_pm_int_icContext {
	var p = new(Mem_addr_pm_int_icContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_pm_int_ic
	return p
}

func (*Mem_addr_pm_int_icContext) IsMem_addr_pm_int_icContext() {}

func NewMem_addr_pm_int_icContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_pm_int_icContext {
	var p = new(Mem_addr_pm_int_icContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_pm_int_ic

	return p
}

func (s *Mem_addr_pm_int_icContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_pm_int_icContext) PM() antlr.TerminalNode {
	return s.GetToken(SHARCParserPM, 0)
}

func (s *Mem_addr_pm_int_icContext) Mem_addr_int_ic() IMem_addr_int_icContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_int_icContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_int_icContext)
}

func (s *Mem_addr_pm_int_icContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_pm_int_icContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_pm_int_icContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_pm_int_ic(s)
	}
}

func (s *Mem_addr_pm_int_icContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_pm_int_ic(s)
	}
}

func (p *SHARCParser) Mem_addr_pm_int_ic() (localctx IMem_addr_pm_int_icContext) {
	this := p
	_ = this

	localctx = NewMem_addr_pm_int_icContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SHARCParserRULE_mem_addr_pm_int_ic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(700)
		p.Match(SHARCParserPM)
	}
	{
		p.SetState(701)
		p.Mem_addr_int_ic()
	}

	return localctx
}

// IMem_addr_dm_intContext is an interface to support dynamic dispatch.
type IMem_addr_dm_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_dm_intContext differentiates from other interfaces.
	IsMem_addr_dm_intContext()
}

type Mem_addr_dm_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_dm_intContext() *Mem_addr_dm_intContext {
	var p = new(Mem_addr_dm_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_dm_int
	return p
}

func (*Mem_addr_dm_intContext) IsMem_addr_dm_intContext() {}

func NewMem_addr_dm_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_dm_intContext {
	var p = new(Mem_addr_dm_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_dm_int

	return p
}

func (s *Mem_addr_dm_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_dm_intContext) DM() antlr.TerminalNode {
	return s.GetToken(SHARCParserDM, 0)
}

func (s *Mem_addr_dm_intContext) Mem_addr_int() IMem_addr_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_intContext)
}

func (s *Mem_addr_dm_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_dm_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_dm_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_dm_int(s)
	}
}

func (s *Mem_addr_dm_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_dm_int(s)
	}
}

func (p *SHARCParser) Mem_addr_dm_int() (localctx IMem_addr_dm_intContext) {
	this := p
	_ = this

	localctx = NewMem_addr_dm_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SHARCParserRULE_mem_addr_dm_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(703)
		p.Match(SHARCParserDM)
	}
	{
		p.SetState(704)
		p.Mem_addr_int()
	}

	return localctx
}

// IMem_addr_pm_intContext is an interface to support dynamic dispatch.
type IMem_addr_pm_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_addr_pm_intContext differentiates from other interfaces.
	IsMem_addr_pm_intContext()
}

type Mem_addr_pm_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_addr_pm_intContext() *Mem_addr_pm_intContext {
	var p = new(Mem_addr_pm_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mem_addr_pm_int
	return p
}

func (*Mem_addr_pm_intContext) IsMem_addr_pm_intContext() {}

func NewMem_addr_pm_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_addr_pm_intContext {
	var p = new(Mem_addr_pm_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mem_addr_pm_int

	return p
}

func (s *Mem_addr_pm_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_addr_pm_intContext) PM() antlr.TerminalNode {
	return s.GetToken(SHARCParserPM, 0)
}

func (s *Mem_addr_pm_intContext) Mem_addr_int() IMem_addr_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_intContext)
}

func (s *Mem_addr_pm_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_addr_pm_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_addr_pm_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMem_addr_pm_int(s)
	}
}

func (s *Mem_addr_pm_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMem_addr_pm_int(s)
	}
}

func (p *SHARCParser) Mem_addr_pm_int() (localctx IMem_addr_pm_intContext) {
	this := p
	_ = this

	localctx = NewMem_addr_pm_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SHARCParserRULE_mem_addr_pm_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.Match(SHARCParserPM)
	}
	{
		p.SetState(707)
		p.Mem_addr_int()
	}

	return localctx
}

// IFixpoint_alu_opContext is an interface to support dynamic dispatch.
type IFixpoint_alu_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFixpoint_alu_opContext differentiates from other interfaces.
	IsFixpoint_alu_opContext()
}

type Fixpoint_alu_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixpoint_alu_opContext() *Fixpoint_alu_opContext {
	var p = new(Fixpoint_alu_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_fixpoint_alu_op
	return p
}

func (*Fixpoint_alu_opContext) IsFixpoint_alu_opContext() {}

func NewFixpoint_alu_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fixpoint_alu_opContext {
	var p = new(Fixpoint_alu_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_fixpoint_alu_op

	return p
}

func (s *Fixpoint_alu_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Fixpoint_alu_opContext) AllR_reg() []IR_regContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IR_regContext)(nil)).Elem())
	var tst = make([]IR_regContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IR_regContext)
		}
	}

	return tst
}

func (s *Fixpoint_alu_opContext) R_reg(i int) IR_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IR_regContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IR_regContext)
}

func (s *Fixpoint_alu_opContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Fixpoint_alu_opContext) R_exp() IR_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IR_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IR_expContext)
}

func (s *Fixpoint_alu_opContext) COMP() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMP, 0)
}

func (s *Fixpoint_alu_opContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Fixpoint_alu_opContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Fixpoint_alu_opContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Fixpoint_alu_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fixpoint_alu_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fixpoint_alu_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFixpoint_alu_op(s)
	}
}

func (s *Fixpoint_alu_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFixpoint_alu_op(s)
	}
}

func (p *SHARCParser) Fixpoint_alu_op() (localctx IFixpoint_alu_opContext) {
	this := p
	_ = this

	localctx = NewFixpoint_alu_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SHARCParserRULE_fixpoint_alu_op)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(720)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(709)
			p.R_reg()
		}
		{
			p.SetState(710)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(711)
			p.R_exp()
		}

	case SHARCParserCOMP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(713)
			p.Match(SHARCParserCOMP)
		}
		{
			p.SetState(714)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(715)
			p.R_reg()
		}
		{
			p.SetState(716)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(717)
			p.R_reg()
		}
		{
			p.SetState(718)
			p.Match(SHARCParserRPARENTHESE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IR_expContext is an interface to support dynamic dispatch.
type IR_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsR_expContext differentiates from other interfaces.
	IsR_expContext()
}

type R_expContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyR_expContext() *R_expContext {
	var p = new(R_expContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_r_exp
	return p
}

func (*R_expContext) IsR_expContext() {}

func NewR_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *R_expContext {
	var p = new(R_expContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_r_exp

	return p
}

func (s *R_expContext) GetParser() antlr.Parser { return s.parser }

func (s *R_expContext) AllR_reg() []IR_regContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IR_regContext)(nil)).Elem())
	var tst = make([]IR_regContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IR_regContext)
		}
	}

	return tst
}

func (s *R_expContext) R_reg(i int) IR_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IR_regContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IR_regContext)
}

func (s *R_expContext) Add_or_sub() IAdd_or_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdd_or_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdd_or_subContext)
}

func (s *R_expContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserPLUS)
}

func (s *R_expContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserPLUS, i)
}

func (s *R_expContext) CI() antlr.TerminalNode {
	return s.GetToken(SHARCParserCI, 0)
}

func (s *R_expContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SHARCParserMINUS, 0)
}

func (s *R_expContext) INT() antlr.TerminalNode {
	return s.GetToken(SHARCParserINT, 0)
}

func (s *R_expContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *R_expContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *R_expContext) DIV() antlr.TerminalNode {
	return s.GetToken(SHARCParserDIV, 0)
}

func (s *R_expContext) ABS() antlr.TerminalNode {
	return s.GetToken(SHARCParserABS, 0)
}

func (s *R_expContext) PASS() antlr.TerminalNode {
	return s.GetToken(SHARCParserPASS, 0)
}

func (s *R_expContext) AND() antlr.TerminalNode {
	return s.GetToken(SHARCParserAND, 0)
}

func (s *R_expContext) OR() antlr.TerminalNode {
	return s.GetToken(SHARCParserOR, 0)
}

func (s *R_expContext) XOR() antlr.TerminalNode {
	return s.GetToken(SHARCParserXOR, 0)
}

func (s *R_expContext) NOT() antlr.TerminalNode {
	return s.GetToken(SHARCParserNOT, 0)
}

func (s *R_expContext) MIN() antlr.TerminalNode {
	return s.GetToken(SHARCParserMIN, 0)
}

func (s *R_expContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *R_expContext) MAX() antlr.TerminalNode {
	return s.GetToken(SHARCParserMAX, 0)
}

func (s *R_expContext) CLIP() antlr.TerminalNode {
	return s.GetToken(SHARCParserCLIP, 0)
}

func (s *R_expContext) BY() antlr.TerminalNode {
	return s.GetToken(SHARCParserBY, 0)
}

func (s *R_expContext) MANT() antlr.TerminalNode {
	return s.GetToken(SHARCParserMANT, 0)
}

func (s *R_expContext) F_reg() IF_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IF_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IF_regContext)
}

func (s *R_expContext) LOGB() antlr.TerminalNode {
	return s.GetToken(SHARCParserLOGB, 0)
}

func (s *R_expContext) FIX() antlr.TerminalNode {
	return s.GetToken(SHARCParserFIX, 0)
}

func (s *R_expContext) TRUNC() antlr.TerminalNode {
	return s.GetToken(SHARCParserTRUNC, 0)
}

func (s *R_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *R_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *R_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterR_exp(s)
	}
}

func (s *R_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitR_exp(s)
	}
}

func (p *SHARCParser) R_exp() (localctx IR_expContext) {
	this := p
	_ = this

	localctx = NewR_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SHARCParserRULE_r_exp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(722)
			p.R_reg()
		}
		{
			p.SetState(723)
			p.Add_or_sub()
		}
		{
			p.SetState(724)
			p.R_reg()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(726)
			p.R_reg()
		}
		{
			p.SetState(727)
			p.Match(SHARCParserPLUS)
		}
		{
			p.SetState(728)
			p.R_reg()
		}
		{
			p.SetState(729)
			p.Match(SHARCParserPLUS)
		}
		{
			p.SetState(730)
			p.Match(SHARCParserCI)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(732)
			p.R_reg()
		}
		{
			p.SetState(733)
			p.Match(SHARCParserPLUS)
		}
		{
			p.SetState(734)
			p.R_reg()
		}
		{
			p.SetState(735)
			p.Match(SHARCParserPLUS)
		}
		{
			p.SetState(736)
			p.Match(SHARCParserCI)
		}
		{
			p.SetState(737)
			p.Match(SHARCParserMINUS)
		}
		{
			p.SetState(738)
			p.Match(SHARCParserINT)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(740)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(741)
			p.R_reg()
		}
		{
			p.SetState(742)
			p.Match(SHARCParserPLUS)
		}
		{
			p.SetState(743)
			p.R_reg()
		}
		{
			p.SetState(744)
			p.Match(SHARCParserRPARENTHESE)
		}
		{
			p.SetState(745)
			p.Match(SHARCParserDIV)
		}
		{
			p.SetState(746)
			p.Match(SHARCParserINT)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(748)
			p.R_reg()
		}
		{
			p.SetState(749)
			p.Match(SHARCParserPLUS)
		}
		{
			p.SetState(750)
			p.Match(SHARCParserCI)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(752)
			p.R_reg()
		}
		{
			p.SetState(753)
			p.Match(SHARCParserPLUS)
		}
		{
			p.SetState(754)
			p.Match(SHARCParserCI)
		}
		{
			p.SetState(755)
			p.Match(SHARCParserMINUS)
		}
		{
			p.SetState(756)
			p.Match(SHARCParserINT)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(758)
			p.R_reg()
		}
		{
			p.SetState(759)
			p.Match(SHARCParserPLUS)
		}
		{
			p.SetState(760)
			p.Match(SHARCParserINT)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(762)
			p.R_reg()
		}
		{
			p.SetState(763)
			p.Match(SHARCParserMINUS)
		}
		{
			p.SetState(764)
			p.Match(SHARCParserINT)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(766)
			p.Match(SHARCParserMINUS)
		}
		{
			p.SetState(767)
			p.R_reg()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(768)
			p.Match(SHARCParserABS)
		}
		{
			p.SetState(769)
			p.R_reg()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(770)
			p.Match(SHARCParserPASS)
		}
		{
			p.SetState(771)
			p.R_reg()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(772)
			p.R_reg()
		}
		{
			p.SetState(773)
			p.Match(SHARCParserAND)
		}
		{
			p.SetState(774)
			p.R_reg()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(776)
			p.R_reg()
		}
		{
			p.SetState(777)
			p.Match(SHARCParserOR)
		}
		{
			p.SetState(778)
			p.R_reg()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(780)
			p.R_reg()
		}
		{
			p.SetState(781)
			p.Match(SHARCParserXOR)
		}
		{
			p.SetState(782)
			p.R_reg()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(784)
			p.Match(SHARCParserNOT)
		}
		{
			p.SetState(785)
			p.R_reg()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(786)
			p.Match(SHARCParserMIN)
		}
		{
			p.SetState(787)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(788)
			p.R_reg()
		}
		{
			p.SetState(789)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(790)
			p.R_reg()
		}
		{
			p.SetState(791)
			p.Match(SHARCParserRPARENTHESE)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(793)
			p.Match(SHARCParserMAX)
		}
		{
			p.SetState(794)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(795)
			p.R_reg()
		}
		{
			p.SetState(796)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(797)
			p.R_reg()
		}
		{
			p.SetState(798)
			p.Match(SHARCParserRPARENTHESE)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(800)
			p.Match(SHARCParserCLIP)
		}
		{
			p.SetState(801)
			p.R_reg()
		}
		{
			p.SetState(802)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(803)
			p.R_reg()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(805)
			p.Match(SHARCParserMANT)
		}
		{
			p.SetState(806)
			p.F_reg()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(807)
			p.Match(SHARCParserLOGB)
		}
		{
			p.SetState(808)
			p.F_reg()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(809)
			p.Match(SHARCParserFIX)
		}
		{
			p.SetState(810)
			p.F_reg()
		}
		p.SetState(813)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SHARCParserBY {
			{
				p.SetState(811)
				p.Match(SHARCParserBY)
			}
			{
				p.SetState(812)
				p.R_reg()
			}

		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(815)
			p.Match(SHARCParserTRUNC)
		}
		{
			p.SetState(816)
			p.F_reg()
		}
		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SHARCParserBY {
			{
				p.SetState(817)
				p.Match(SHARCParserBY)
			}
			{
				p.SetState(818)
				p.R_reg()
			}

		}

	}

	return localctx
}

// IFloating_point_alu_opContext is an interface to support dynamic dispatch.
type IFloating_point_alu_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFloating_point_alu_opContext differentiates from other interfaces.
	IsFloating_point_alu_opContext()
}

type Floating_point_alu_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloating_point_alu_opContext() *Floating_point_alu_opContext {
	var p = new(Floating_point_alu_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_floating_point_alu_op
	return p
}

func (*Floating_point_alu_opContext) IsFloating_point_alu_opContext() {}

func NewFloating_point_alu_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Floating_point_alu_opContext {
	var p = new(Floating_point_alu_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_floating_point_alu_op

	return p
}

func (s *Floating_point_alu_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Floating_point_alu_opContext) AllF_reg() []IF_regContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IF_regContext)(nil)).Elem())
	var tst = make([]IF_regContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IF_regContext)
		}
	}

	return tst
}

func (s *Floating_point_alu_opContext) F_reg(i int) IF_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IF_regContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IF_regContext)
}

func (s *Floating_point_alu_opContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Floating_point_alu_opContext) F_exp() IF_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IF_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IF_expContext)
}

func (s *Floating_point_alu_opContext) COMP() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMP, 0)
}

func (s *Floating_point_alu_opContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Floating_point_alu_opContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Floating_point_alu_opContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Floating_point_alu_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Floating_point_alu_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Floating_point_alu_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFloating_point_alu_op(s)
	}
}

func (s *Floating_point_alu_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFloating_point_alu_op(s)
	}
}

func (p *SHARCParser) Floating_point_alu_op() (localctx IFloating_point_alu_opContext) {
	this := p
	_ = this

	localctx = NewFloating_point_alu_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SHARCParserRULE_floating_point_alu_op)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(834)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserF0, SHARCParserF1, SHARCParserF2, SHARCParserF3, SHARCParserF4, SHARCParserF5, SHARCParserF6, SHARCParserF7, SHARCParserF8, SHARCParserF9, SHARCParserF10, SHARCParserF11, SHARCParserF12, SHARCParserF13, SHARCParserF14, SHARCParserF15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(823)
			p.F_reg()
		}
		{
			p.SetState(824)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(825)
			p.F_exp()
		}

	case SHARCParserCOMP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(827)
			p.Match(SHARCParserCOMP)
		}
		{
			p.SetState(828)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(829)
			p.F_reg()
		}
		{
			p.SetState(830)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(831)
			p.F_reg()
		}
		{
			p.SetState(832)
			p.Match(SHARCParserRPARENTHESE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IF_expContext is an interface to support dynamic dispatch.
type IF_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsF_expContext differentiates from other interfaces.
	IsF_expContext()
}

type F_expContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyF_expContext() *F_expContext {
	var p = new(F_expContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_f_exp
	return p
}

func (*F_expContext) IsF_expContext() {}

func NewF_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *F_expContext {
	var p = new(F_expContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_f_exp

	return p
}

func (s *F_expContext) GetParser() antlr.Parser { return s.parser }

func (s *F_expContext) AllF_reg() []IF_regContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IF_regContext)(nil)).Elem())
	var tst = make([]IF_regContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IF_regContext)
		}
	}

	return tst
}

func (s *F_expContext) F_reg(i int) IF_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IF_regContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IF_regContext)
}

func (s *F_expContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SHARCParserPLUS, 0)
}

func (s *F_expContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SHARCParserMINUS, 0)
}

func (s *F_expContext) ABS() antlr.TerminalNode {
	return s.GetToken(SHARCParserABS, 0)
}

func (s *F_expContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *F_expContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *F_expContext) DIV() antlr.TerminalNode {
	return s.GetToken(SHARCParserDIV, 0)
}

func (s *F_expContext) INT() antlr.TerminalNode {
	return s.GetToken(SHARCParserINT, 0)
}

func (s *F_expContext) PASS() antlr.TerminalNode {
	return s.GetToken(SHARCParserPASS, 0)
}

func (s *F_expContext) RND() antlr.TerminalNode {
	return s.GetToken(SHARCParserRND, 0)
}

func (s *F_expContext) SCALB() antlr.TerminalNode {
	return s.GetToken(SHARCParserSCALB, 0)
}

func (s *F_expContext) BY() antlr.TerminalNode {
	return s.GetToken(SHARCParserBY, 0)
}

func (s *F_expContext) AllR_reg() []IR_regContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IR_regContext)(nil)).Elem())
	var tst = make([]IR_regContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IR_regContext)
		}
	}

	return tst
}

func (s *F_expContext) R_reg(i int) IR_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IR_regContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IR_regContext)
}

func (s *F_expContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(SHARCParserFLOAT, 0)
}

func (s *F_expContext) RECIPS() antlr.TerminalNode {
	return s.GetToken(SHARCParserRECIPS, 0)
}

func (s *F_expContext) RSQRTS() antlr.TerminalNode {
	return s.GetToken(SHARCParserRSQRTS, 0)
}

func (s *F_expContext) COPYSIGN() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOPYSIGN, 0)
}

func (s *F_expContext) MIN() antlr.TerminalNode {
	return s.GetToken(SHARCParserMIN, 0)
}

func (s *F_expContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *F_expContext) MAX() antlr.TerminalNode {
	return s.GetToken(SHARCParserMAX, 0)
}

func (s *F_expContext) CLIP() antlr.TerminalNode {
	return s.GetToken(SHARCParserCLIP, 0)
}

func (s *F_expContext) MULT() antlr.TerminalNode {
	return s.GetToken(SHARCParserMULT, 0)
}

func (s *F_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *F_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *F_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterF_exp(s)
	}
}

func (s *F_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitF_exp(s)
	}
}

func (p *SHARCParser) F_exp() (localctx IF_expContext) {
	this := p
	_ = this

	localctx = NewF_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SHARCParserRULE_f_exp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(916)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(836)
			p.F_reg()
		}
		{
			p.SetState(837)
			p.Match(SHARCParserPLUS)
		}
		{
			p.SetState(838)
			p.F_reg()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(840)
			p.F_reg()
		}
		{
			p.SetState(841)
			p.Match(SHARCParserMINUS)
		}
		{
			p.SetState(842)
			p.F_reg()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(844)
			p.Match(SHARCParserABS)
		}
		{
			p.SetState(845)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(846)
			p.F_reg()
		}
		{
			p.SetState(847)
			p.Match(SHARCParserPLUS)
		}
		{
			p.SetState(848)
			p.F_reg()
		}
		{
			p.SetState(849)
			p.Match(SHARCParserRPARENTHESE)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(851)
			p.Match(SHARCParserABS)
		}
		{
			p.SetState(852)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(853)
			p.F_reg()
		}
		{
			p.SetState(854)
			p.Match(SHARCParserMINUS)
		}
		{
			p.SetState(855)
			p.F_reg()
		}
		{
			p.SetState(856)
			p.Match(SHARCParserRPARENTHESE)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(858)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(859)
			p.F_reg()
		}
		{
			p.SetState(860)
			p.Match(SHARCParserPLUS)
		}
		{
			p.SetState(861)
			p.F_reg()
		}
		{
			p.SetState(862)
			p.Match(SHARCParserRPARENTHESE)
		}
		{
			p.SetState(863)
			p.Match(SHARCParserDIV)
		}
		{
			p.SetState(864)
			p.Match(SHARCParserINT)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(866)
			p.Match(SHARCParserMINUS)
		}
		{
			p.SetState(867)
			p.F_reg()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(868)
			p.Match(SHARCParserABS)
		}
		{
			p.SetState(869)
			p.F_reg()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(870)
			p.Match(SHARCParserPASS)
		}
		{
			p.SetState(871)
			p.F_reg()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(872)
			p.Match(SHARCParserRND)
		}
		{
			p.SetState(873)
			p.F_reg()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(874)
			p.Match(SHARCParserSCALB)
		}
		{
			p.SetState(875)
			p.F_reg()
		}
		{
			p.SetState(876)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(877)
			p.R_reg()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(879)
			p.Match(SHARCParserFLOAT)
		}
		{
			p.SetState(880)
			p.R_reg()
		}
		p.SetState(883)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SHARCParserBY {
			{
				p.SetState(881)
				p.Match(SHARCParserBY)
			}
			{
				p.SetState(882)
				p.R_reg()
			}

		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(885)
			p.Match(SHARCParserRECIPS)
		}
		{
			p.SetState(886)
			p.F_reg()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(887)
			p.Match(SHARCParserRSQRTS)
		}
		{
			p.SetState(888)
			p.F_reg()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(889)
			p.F_reg()
		}
		{
			p.SetState(890)
			p.Match(SHARCParserCOPYSIGN)
		}
		{
			p.SetState(891)
			p.F_reg()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(893)
			p.Match(SHARCParserMIN)
		}
		{
			p.SetState(894)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(895)
			p.F_reg()
		}
		{
			p.SetState(896)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(897)
			p.F_reg()
		}
		{
			p.SetState(898)
			p.Match(SHARCParserRPARENTHESE)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(900)
			p.Match(SHARCParserMAX)
		}
		{
			p.SetState(901)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(902)
			p.F_reg()
		}
		{
			p.SetState(903)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(904)
			p.F_reg()
		}
		{
			p.SetState(905)
			p.Match(SHARCParserRPARENTHESE)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(907)
			p.Match(SHARCParserCLIP)
		}
		{
			p.SetState(908)
			p.F_reg()
		}
		{
			p.SetState(909)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(910)
			p.F_reg()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(912)
			p.F_reg()
		}
		{
			p.SetState(913)
			p.Match(SHARCParserMULT)
		}
		{
			p.SetState(914)
			p.F_reg()
		}

	}

	return localctx
}

// IMulti_opContext is an interface to support dynamic dispatch.
type IMulti_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_opContext differentiates from other interfaces.
	IsMulti_opContext()
}

type Multi_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_opContext() *Multi_opContext {
	var p = new(Multi_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_multi_op
	return p
}

func (*Multi_opContext) IsMulti_opContext() {}

func NewMulti_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_opContext {
	var p = new(Multi_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_multi_op

	return p
}

func (s *Multi_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_opContext) R_reg() IR_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IR_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IR_regContext)
}

func (s *Multi_opContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Multi_opContext) Multi_exp_r() IMulti_exp_rContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_exp_rContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_exp_rContext)
}

func (s *Multi_opContext) MRF() antlr.TerminalNode {
	return s.GetToken(SHARCParserMRF, 0)
}

func (s *Multi_opContext) Multi_exp_mrf() IMulti_exp_mrfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_exp_mrfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_exp_mrfContext)
}

func (s *Multi_opContext) MRB() antlr.TerminalNode {
	return s.GetToken(SHARCParserMRB, 0)
}

func (s *Multi_opContext) Multi_exp_mrb() IMulti_exp_mrbContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_exp_mrbContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_exp_mrbContext)
}

func (s *Multi_opContext) Mr() IMrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMrContext)
}

func (s *Multi_opContext) INT() antlr.TerminalNode {
	return s.GetToken(SHARCParserINT, 0)
}

func (s *Multi_opContext) Mrf() IMrfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMrfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMrfContext)
}

func (s *Multi_opContext) Mrb() IMrbContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMrbContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMrbContext)
}

func (s *Multi_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMulti_op(s)
	}
}

func (s *Multi_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMulti_op(s)
	}
}

func (p *SHARCParser) Multi_op() (localctx IMulti_opContext) {
	this := p
	_ = this

	localctx = NewMulti_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SHARCParserRULE_multi_op)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(945)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(918)
			p.R_reg()
		}
		{
			p.SetState(919)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(920)
			p.Multi_exp_r()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(922)
			p.Match(SHARCParserMRF)
		}
		{
			p.SetState(923)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(924)
			p.Multi_exp_mrf()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(925)
			p.Match(SHARCParserMRB)
		}
		{
			p.SetState(926)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(927)
			p.Multi_exp_mrb()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(928)
			p.Mr()
		}
		{
			p.SetState(929)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(930)
			p.Match(SHARCParserINT)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(934)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SHARCParserMR0F, SHARCParserMR1F, SHARCParserMR2F:
			{
				p.SetState(932)
				p.Mrf()
			}

		case SHARCParserMR0B, SHARCParserMR1B, SHARCParserMR2B:
			{
				p.SetState(933)
				p.Mrb()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(936)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(937)
			p.R_reg()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(939)
			p.R_reg()
		}
		{
			p.SetState(940)
			p.Match(SHARCParserEQU)
		}
		p.SetState(943)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SHARCParserMR0F, SHARCParserMR1F, SHARCParserMR2F:
			{
				p.SetState(941)
				p.Mrf()
			}

		case SHARCParserMR0B, SHARCParserMR1B, SHARCParserMR2B:
			{
				p.SetState(942)
				p.Mrb()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IMulti_rContext is an interface to support dynamic dispatch.
type IMulti_rContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_rContext differentiates from other interfaces.
	IsMulti_rContext()
}

type Multi_rContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_rContext() *Multi_rContext {
	var p = new(Multi_rContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_multi_r
	return p
}

func (*Multi_rContext) IsMulti_rContext() {}

func NewMulti_rContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_rContext {
	var p = new(Multi_rContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_multi_r

	return p
}

func (s *Multi_rContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_rContext) AllR_reg() []IR_regContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IR_regContext)(nil)).Elem())
	var tst = make([]IR_regContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IR_regContext)
		}
	}

	return tst
}

func (s *Multi_rContext) R_reg(i int) IR_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IR_regContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IR_regContext)
}

func (s *Multi_rContext) MULT() antlr.TerminalNode {
	return s.GetToken(SHARCParserMULT, 0)
}

func (s *Multi_rContext) Multi_mod2() IMulti_mod2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_mod2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_mod2Context)
}

func (s *Multi_rContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_rContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_rContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMulti_r(s)
	}
}

func (s *Multi_rContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMulti_r(s)
	}
}

func (p *SHARCParser) Multi_r() (localctx IMulti_rContext) {
	this := p
	_ = this

	localctx = NewMulti_rContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SHARCParserRULE_multi_r)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(947)
		p.R_reg()
	}
	{
		p.SetState(948)
		p.Match(SHARCParserMULT)
	}
	{
		p.SetState(949)
		p.R_reg()
	}
	p.SetState(951)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SHARCParserLPARENTHESE {
		{
			p.SetState(950)
			p.Multi_mod2()
		}

	}

	return localctx
}

// IMulti_exp_rContext is an interface to support dynamic dispatch.
type IMulti_exp_rContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_exp_rContext differentiates from other interfaces.
	IsMulti_exp_rContext()
}

type Multi_exp_rContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_exp_rContext() *Multi_exp_rContext {
	var p = new(Multi_exp_rContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_multi_exp_r
	return p
}

func (*Multi_exp_rContext) IsMulti_exp_rContext() {}

func NewMulti_exp_rContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_exp_rContext {
	var p = new(Multi_exp_rContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_multi_exp_r

	return p
}

func (s *Multi_exp_rContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_exp_rContext) Multi_r() IMulti_rContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_rContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_rContext)
}

func (s *Multi_exp_rContext) Mr() IMrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMrContext)
}

func (s *Multi_exp_rContext) Add_or_sub() IAdd_or_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdd_or_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdd_or_subContext)
}

func (s *Multi_exp_rContext) SAT() antlr.TerminalNode {
	return s.GetToken(SHARCParserSAT, 0)
}

func (s *Multi_exp_rContext) Multi_mod1() IMulti_mod1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_mod1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_mod1Context)
}

func (s *Multi_exp_rContext) RND() antlr.TerminalNode {
	return s.GetToken(SHARCParserRND, 0)
}

func (s *Multi_exp_rContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_exp_rContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_exp_rContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMulti_exp_r(s)
	}
}

func (s *Multi_exp_rContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMulti_exp_r(s)
	}
}

func (p *SHARCParser) Multi_exp_r() (localctx IMulti_exp_rContext) {
	this := p
	_ = this

	localctx = NewMulti_exp_rContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SHARCParserRULE_multi_exp_r)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(953)
			p.Multi_r()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(954)
			p.Mr()
		}
		{
			p.SetState(955)
			p.Add_or_sub()
		}
		{
			p.SetState(956)
			p.Multi_r()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(958)
			p.Match(SHARCParserSAT)
		}
		{
			p.SetState(959)
			p.Mr()
		}
		p.SetState(961)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SHARCParserLPARENTHESE {
			{
				p.SetState(960)
				p.Multi_mod1()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(963)
			p.Match(SHARCParserRND)
		}
		{
			p.SetState(964)
			p.Mr()
		}
		p.SetState(966)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SHARCParserLPARENTHESE {
			{
				p.SetState(965)
				p.Multi_mod1()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(968)
			p.Mr()
		}

	}

	return localctx
}

// IMulti_exp_mrfContext is an interface to support dynamic dispatch.
type IMulti_exp_mrfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_exp_mrfContext differentiates from other interfaces.
	IsMulti_exp_mrfContext()
}

type Multi_exp_mrfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_exp_mrfContext() *Multi_exp_mrfContext {
	var p = new(Multi_exp_mrfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_multi_exp_mrf
	return p
}

func (*Multi_exp_mrfContext) IsMulti_exp_mrfContext() {}

func NewMulti_exp_mrfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_exp_mrfContext {
	var p = new(Multi_exp_mrfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_multi_exp_mrf

	return p
}

func (s *Multi_exp_mrfContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_exp_mrfContext) Multi_r() IMulti_rContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_rContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_rContext)
}

func (s *Multi_exp_mrfContext) MRF() antlr.TerminalNode {
	return s.GetToken(SHARCParserMRF, 0)
}

func (s *Multi_exp_mrfContext) Add_or_sub() IAdd_or_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdd_or_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdd_or_subContext)
}

func (s *Multi_exp_mrfContext) SAT() antlr.TerminalNode {
	return s.GetToken(SHARCParserSAT, 0)
}

func (s *Multi_exp_mrfContext) Multi_mod1() IMulti_mod1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_mod1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_mod1Context)
}

func (s *Multi_exp_mrfContext) RND() antlr.TerminalNode {
	return s.GetToken(SHARCParserRND, 0)
}

func (s *Multi_exp_mrfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_exp_mrfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_exp_mrfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMulti_exp_mrf(s)
	}
}

func (s *Multi_exp_mrfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMulti_exp_mrf(s)
	}
}

func (p *SHARCParser) Multi_exp_mrf() (localctx IMulti_exp_mrfContext) {
	this := p
	_ = this

	localctx = NewMulti_exp_mrfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SHARCParserRULE_multi_exp_mrf)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(986)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(971)
			p.Multi_r()
		}

	case SHARCParserMRF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(972)
			p.Match(SHARCParserMRF)
		}
		{
			p.SetState(973)
			p.Add_or_sub()
		}
		{
			p.SetState(974)
			p.Multi_r()
		}

	case SHARCParserSAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(976)
			p.Match(SHARCParserSAT)
		}
		{
			p.SetState(977)
			p.Match(SHARCParserMRF)
		}
		p.SetState(979)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SHARCParserLPARENTHESE {
			{
				p.SetState(978)
				p.Multi_mod1()
			}

		}

	case SHARCParserRND:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(981)
			p.Match(SHARCParserRND)
		}
		{
			p.SetState(982)
			p.Match(SHARCParserMRF)
		}
		p.SetState(984)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SHARCParserLPARENTHESE {
			{
				p.SetState(983)
				p.Multi_mod1()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMulti_exp_mrbContext is an interface to support dynamic dispatch.
type IMulti_exp_mrbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_exp_mrbContext differentiates from other interfaces.
	IsMulti_exp_mrbContext()
}

type Multi_exp_mrbContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_exp_mrbContext() *Multi_exp_mrbContext {
	var p = new(Multi_exp_mrbContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_multi_exp_mrb
	return p
}

func (*Multi_exp_mrbContext) IsMulti_exp_mrbContext() {}

func NewMulti_exp_mrbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_exp_mrbContext {
	var p = new(Multi_exp_mrbContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_multi_exp_mrb

	return p
}

func (s *Multi_exp_mrbContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_exp_mrbContext) Multi_r() IMulti_rContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_rContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_rContext)
}

func (s *Multi_exp_mrbContext) MRB() antlr.TerminalNode {
	return s.GetToken(SHARCParserMRB, 0)
}

func (s *Multi_exp_mrbContext) Add_or_sub() IAdd_or_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdd_or_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdd_or_subContext)
}

func (s *Multi_exp_mrbContext) SAT() antlr.TerminalNode {
	return s.GetToken(SHARCParserSAT, 0)
}

func (s *Multi_exp_mrbContext) Multi_mod1() IMulti_mod1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_mod1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_mod1Context)
}

func (s *Multi_exp_mrbContext) RND() antlr.TerminalNode {
	return s.GetToken(SHARCParserRND, 0)
}

func (s *Multi_exp_mrbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_exp_mrbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_exp_mrbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMulti_exp_mrb(s)
	}
}

func (s *Multi_exp_mrbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMulti_exp_mrb(s)
	}
}

func (p *SHARCParser) Multi_exp_mrb() (localctx IMulti_exp_mrbContext) {
	this := p
	_ = this

	localctx = NewMulti_exp_mrbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SHARCParserRULE_multi_exp_mrb)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1003)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(988)
			p.Multi_r()
		}

	case SHARCParserMRB:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(989)
			p.Match(SHARCParserMRB)
		}
		{
			p.SetState(990)
			p.Add_or_sub()
		}
		{
			p.SetState(991)
			p.Multi_r()
		}

	case SHARCParserSAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(993)
			p.Match(SHARCParserSAT)
		}
		{
			p.SetState(994)
			p.Match(SHARCParserMRB)
		}
		p.SetState(996)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SHARCParserLPARENTHESE {
			{
				p.SetState(995)
				p.Multi_mod1()
			}

		}

	case SHARCParserRND:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(998)
			p.Match(SHARCParserRND)
		}
		{
			p.SetState(999)
			p.Match(SHARCParserMRB)
		}
		p.SetState(1001)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SHARCParserLPARENTHESE {
			{
				p.SetState(1000)
				p.Multi_mod1()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMrContext is an interface to support dynamic dispatch.
type IMrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMrContext differentiates from other interfaces.
	IsMrContext()
}

type MrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMrContext() *MrContext {
	var p = new(MrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mr
	return p
}

func (*MrContext) IsMrContext() {}

func NewMrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MrContext {
	var p = new(MrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mr

	return p
}

func (s *MrContext) GetParser() antlr.Parser { return s.parser }

func (s *MrContext) MRB() antlr.TerminalNode {
	return s.GetToken(SHARCParserMRB, 0)
}

func (s *MrContext) MRF() antlr.TerminalNode {
	return s.GetToken(SHARCParserMRF, 0)
}

func (s *MrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMr(s)
	}
}

func (s *MrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMr(s)
	}
}

func (p *SHARCParser) Mr() (localctx IMrContext) {
	this := p
	_ = this

	localctx = NewMrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SHARCParserRULE_mr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1005)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SHARCParserMRB || _la == SHARCParserMRF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IShifter_opContext is an interface to support dynamic dispatch.
type IShifter_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShifter_opContext differentiates from other interfaces.
	IsShifter_opContext()
}

type Shifter_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShifter_opContext() *Shifter_opContext {
	var p = new(Shifter_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_shifter_op
	return p
}

func (*Shifter_opContext) IsShifter_opContext() {}

func NewShifter_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shifter_opContext {
	var p = new(Shifter_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_shifter_op

	return p
}

func (s *Shifter_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Shifter_opContext) R_reg() IR_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IR_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IR_regContext)
}

func (s *Shifter_opContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Shifter_opContext) Shifter_exp() IShifter_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShifter_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShifter_expContext)
}

func (s *Shifter_opContext) BTST() antlr.TerminalNode {
	return s.GetToken(SHARCParserBTST, 0)
}

func (s *Shifter_opContext) BY() antlr.TerminalNode {
	return s.GetToken(SHARCParserBY, 0)
}

func (s *Shifter_opContext) Sec_op() ISec_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISec_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISec_opContext)
}

func (s *Shifter_opContext) F_reg() IF_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IF_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IF_regContext)
}

func (s *Shifter_opContext) FUNPACK() antlr.TerminalNode {
	return s.GetToken(SHARCParserFUNPACK, 0)
}

func (s *Shifter_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shifter_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shifter_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterShifter_op(s)
	}
}

func (s *Shifter_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitShifter_op(s)
	}
}

func (p *SHARCParser) Shifter_op() (localctx IShifter_opContext) {
	this := p
	_ = this

	localctx = NewShifter_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SHARCParserRULE_shifter_op)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1021)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1007)
			p.R_reg()
		}
		{
			p.SetState(1008)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(1009)
			p.Shifter_exp()
		}

	case SHARCParserBTST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1011)
			p.Match(SHARCParserBTST)
		}
		{
			p.SetState(1012)
			p.R_reg()
		}
		{
			p.SetState(1013)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(1014)
			p.Sec_op()
		}

	case SHARCParserF0, SHARCParserF1, SHARCParserF2, SHARCParserF3, SHARCParserF4, SHARCParserF5, SHARCParserF6, SHARCParserF7, SHARCParserF8, SHARCParserF9, SHARCParserF10, SHARCParserF11, SHARCParserF12, SHARCParserF13, SHARCParserF14, SHARCParserF15:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1016)
			p.F_reg()
		}
		{
			p.SetState(1017)
			p.Match(SHARCParserEQU)
		}
		{
			p.SetState(1018)
			p.Match(SHARCParserFUNPACK)
		}
		{
			p.SetState(1019)
			p.R_reg()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IShifter_expContext is an interface to support dynamic dispatch.
type IShifter_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShifter_expContext differentiates from other interfaces.
	IsShifter_expContext()
}

type Shifter_expContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShifter_expContext() *Shifter_expContext {
	var p = new(Shifter_expContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_shifter_exp
	return p
}

func (*Shifter_expContext) IsShifter_expContext() {}

func NewShifter_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shifter_expContext {
	var p = new(Shifter_expContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_shifter_exp

	return p
}

func (s *Shifter_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Shifter_expContext) LSHIFT() antlr.TerminalNode {
	return s.GetToken(SHARCParserLSHIFT, 0)
}

func (s *Shifter_expContext) AllR_reg() []IR_regContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IR_regContext)(nil)).Elem())
	var tst = make([]IR_regContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IR_regContext)
		}
	}

	return tst
}

func (s *Shifter_expContext) R_reg(i int) IR_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IR_regContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IR_regContext)
}

func (s *Shifter_expContext) BY() antlr.TerminalNode {
	return s.GetToken(SHARCParserBY, 0)
}

func (s *Shifter_expContext) Sec_op() ISec_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISec_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISec_opContext)
}

func (s *Shifter_expContext) OR() antlr.TerminalNode {
	return s.GetToken(SHARCParserOR, 0)
}

func (s *Shifter_expContext) ASHIFT() antlr.TerminalNode {
	return s.GetToken(SHARCParserASHIFT, 0)
}

func (s *Shifter_expContext) ROT() antlr.TerminalNode {
	return s.GetToken(SHARCParserROT, 0)
}

func (s *Shifter_expContext) BCLR() antlr.TerminalNode {
	return s.GetToken(SHARCParserBCLR, 0)
}

func (s *Shifter_expContext) BSET() antlr.TerminalNode {
	return s.GetToken(SHARCParserBSET, 0)
}

func (s *Shifter_expContext) BTGL() antlr.TerminalNode {
	return s.GetToken(SHARCParserBTGL, 0)
}

func (s *Shifter_expContext) FDEP() antlr.TerminalNode {
	return s.GetToken(SHARCParserFDEP, 0)
}

func (s *Shifter_expContext) Sec_op2() ISec_op2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISec_op2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISec_op2Context)
}

func (s *Shifter_expContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Shifter_expContext) SE() antlr.TerminalNode {
	return s.GetToken(SHARCParserSE, 0)
}

func (s *Shifter_expContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Shifter_expContext) FEXT() antlr.TerminalNode {
	return s.GetToken(SHARCParserFEXT, 0)
}

func (s *Shifter_expContext) EXP() antlr.TerminalNode {
	return s.GetToken(SHARCParserEXP, 0)
}

func (s *Shifter_expContext) EX() antlr.TerminalNode {
	return s.GetToken(SHARCParserEX, 0)
}

func (s *Shifter_expContext) LEFTZ() antlr.TerminalNode {
	return s.GetToken(SHARCParserLEFTZ, 0)
}

func (s *Shifter_expContext) LEFTO() antlr.TerminalNode {
	return s.GetToken(SHARCParserLEFTO, 0)
}

func (s *Shifter_expContext) FPACK() antlr.TerminalNode {
	return s.GetToken(SHARCParserFPACK, 0)
}

func (s *Shifter_expContext) F_reg() IF_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IF_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IF_regContext)
}

func (s *Shifter_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shifter_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shifter_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterShifter_exp(s)
	}
}

func (s *Shifter_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitShifter_exp(s)
	}
}

func (p *SHARCParser) Shifter_exp() (localctx IShifter_expContext) {
	this := p
	_ = this

	localctx = NewShifter_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SHARCParserRULE_shifter_exp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1105)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1023)
			p.Match(SHARCParserLSHIFT)
		}
		{
			p.SetState(1024)
			p.R_reg()
		}
		{
			p.SetState(1025)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(1026)
			p.Sec_op()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1028)
			p.R_reg()
		}
		{
			p.SetState(1029)
			p.Match(SHARCParserOR)
		}
		{
			p.SetState(1030)
			p.Match(SHARCParserLSHIFT)
		}
		{
			p.SetState(1031)
			p.R_reg()
		}
		{
			p.SetState(1032)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(1033)
			p.Sec_op()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1035)
			p.Match(SHARCParserASHIFT)
		}
		{
			p.SetState(1036)
			p.R_reg()
		}
		{
			p.SetState(1037)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(1038)
			p.Sec_op()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1040)
			p.R_reg()
		}
		{
			p.SetState(1041)
			p.Match(SHARCParserOR)
		}
		{
			p.SetState(1042)
			p.Match(SHARCParserASHIFT)
		}
		{
			p.SetState(1043)
			p.R_reg()
		}
		{
			p.SetState(1044)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(1045)
			p.Sec_op()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1047)
			p.Match(SHARCParserROT)
		}
		{
			p.SetState(1048)
			p.R_reg()
		}
		{
			p.SetState(1049)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(1050)
			p.Sec_op()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1052)
			p.Match(SHARCParserBCLR)
		}
		{
			p.SetState(1053)
			p.R_reg()
		}
		{
			p.SetState(1054)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(1055)
			p.Sec_op()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1057)
			p.Match(SHARCParserBSET)
		}
		{
			p.SetState(1058)
			p.R_reg()
		}
		{
			p.SetState(1059)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(1060)
			p.Sec_op()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1062)
			p.Match(SHARCParserBTGL)
		}
		{
			p.SetState(1063)
			p.R_reg()
		}
		{
			p.SetState(1064)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(1065)
			p.Sec_op()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1067)
			p.Match(SHARCParserFDEP)
		}
		{
			p.SetState(1068)
			p.R_reg()
		}
		{
			p.SetState(1069)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(1070)
			p.Sec_op2()
		}
		p.SetState(1074)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SHARCParserLPARENTHESE {
			{
				p.SetState(1071)
				p.Match(SHARCParserLPARENTHESE)
			}
			{
				p.SetState(1072)
				p.Match(SHARCParserSE)
			}
			{
				p.SetState(1073)
				p.Match(SHARCParserRPARENTHESE)
			}

		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1076)
			p.Match(SHARCParserFEXT)
		}
		{
			p.SetState(1077)
			p.R_reg()
		}
		{
			p.SetState(1078)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(1079)
			p.Sec_op2()
		}
		p.SetState(1083)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SHARCParserLPARENTHESE {
			{
				p.SetState(1080)
				p.Match(SHARCParserLPARENTHESE)
			}
			{
				p.SetState(1081)
				p.Match(SHARCParserSE)
			}
			{
				p.SetState(1082)
				p.Match(SHARCParserRPARENTHESE)
			}

		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1085)
			p.R_reg()
		}
		{
			p.SetState(1086)
			p.Match(SHARCParserOR)
		}
		{
			p.SetState(1087)
			p.Match(SHARCParserFDEP)
		}
		{
			p.SetState(1088)
			p.R_reg()
		}
		{
			p.SetState(1089)
			p.Match(SHARCParserBY)
		}
		{
			p.SetState(1090)
			p.Sec_op2()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1092)
			p.Match(SHARCParserEXP)
		}
		{
			p.SetState(1093)
			p.R_reg()
		}
		p.SetState(1097)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SHARCParserLPARENTHESE {
			{
				p.SetState(1094)
				p.Match(SHARCParserLPARENTHESE)
			}
			{
				p.SetState(1095)
				p.Match(SHARCParserEX)
			}
			{
				p.SetState(1096)
				p.Match(SHARCParserRPARENTHESE)
			}

		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1099)
			p.Match(SHARCParserLEFTZ)
		}
		{
			p.SetState(1100)
			p.R_reg()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1101)
			p.Match(SHARCParserLEFTO)
		}
		{
			p.SetState(1102)
			p.R_reg()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1103)
			p.Match(SHARCParserFPACK)
		}
		{
			p.SetState(1104)
			p.F_reg()
		}

	}

	return localctx
}

// ISec_opContext is an interface to support dynamic dispatch.
type ISec_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSec_opContext differentiates from other interfaces.
	IsSec_opContext()
}

type Sec_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySec_opContext() *Sec_opContext {
	var p = new(Sec_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_sec_op
	return p
}

func (*Sec_opContext) IsSec_opContext() {}

func NewSec_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sec_opContext {
	var p = new(Sec_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_sec_op

	return p
}

func (s *Sec_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Sec_opContext) R_reg() IR_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IR_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IR_regContext)
}

func (s *Sec_opContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *Sec_opContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SHARCParserMINUS, 0)
}

func (s *Sec_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sec_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sec_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterSec_op(s)
	}
}

func (s *Sec_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitSec_op(s)
	}
}

func (p *SHARCParser) Sec_op() (localctx ISec_opContext) {
	this := p
	_ = this

	localctx = NewSec_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SHARCParserRULE_sec_op)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1111)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1107)
			p.R_reg()
		}

	case SHARCParserINT, SHARCParserLENGTH, SHARCParserAT, SHARCParserID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1108)
			p.Atom()
		}

	case SHARCParserMINUS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1109)
			p.Match(SHARCParserMINUS)
		}
		{
			p.SetState(1110)
			p.Atom()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISec_op2Context is an interface to support dynamic dispatch.
type ISec_op2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSec_op2Context differentiates from other interfaces.
	IsSec_op2Context()
}

type Sec_op2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySec_op2Context() *Sec_op2Context {
	var p = new(Sec_op2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_sec_op2
	return p
}

func (*Sec_op2Context) IsSec_op2Context() {}

func NewSec_op2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sec_op2Context {
	var p = new(Sec_op2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_sec_op2

	return p
}

func (s *Sec_op2Context) GetParser() antlr.Parser { return s.parser }

func (s *Sec_op2Context) R_reg() IR_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IR_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IR_regContext)
}

func (s *Sec_op2Context) Bit_data() IBit_dataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBit_dataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBit_dataContext)
}

func (s *Sec_op2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sec_op2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sec_op2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterSec_op2(s)
	}
}

func (s *Sec_op2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitSec_op2(s)
	}
}

func (p *SHARCParser) Sec_op2() (localctx ISec_op2Context) {
	this := p
	_ = this

	localctx = NewSec_op2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SHARCParserRULE_sec_op2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1115)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1113)
			p.R_reg()
		}

	case SHARCParserINT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1114)
			p.Bit_data()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBit_dataContext is an interface to support dynamic dispatch.
type IBit_dataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBit_dataContext differentiates from other interfaces.
	IsBit_dataContext()
}

type Bit_dataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBit_dataContext() *Bit_dataContext {
	var p = new(Bit_dataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_bit_data
	return p
}

func (*Bit_dataContext) IsBit_dataContext() {}

func NewBit_dataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bit_dataContext {
	var p = new(Bit_dataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_bit_data

	return p
}

func (s *Bit_dataContext) GetParser() antlr.Parser { return s.parser }

func (s *Bit_dataContext) AllINT() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserINT)
}

func (s *Bit_dataContext) INT(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserINT, i)
}

func (s *Bit_dataContext) COLON() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOLON, 0)
}

func (s *Bit_dataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bit_dataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bit_dataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterBit_data(s)
	}
}

func (s *Bit_dataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitBit_data(s)
	}
}

func (p *SHARCParser) Bit_data() (localctx IBit_dataContext) {
	this := p
	_ = this

	localctx = NewBit_dataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SHARCParserRULE_bit_data)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1117)
		p.Match(SHARCParserINT)
	}
	{
		p.SetState(1118)
		p.Match(SHARCParserCOLON)
	}
	{
		p.SetState(1119)
		p.Match(SHARCParserINT)
	}

	return localctx
}

// IAdd_or_subContext is an interface to support dynamic dispatch.
type IAdd_or_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdd_or_subContext differentiates from other interfaces.
	IsAdd_or_subContext()
}

type Add_or_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdd_or_subContext() *Add_or_subContext {
	var p = new(Add_or_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_add_or_sub
	return p
}

func (*Add_or_subContext) IsAdd_or_subContext() {}

func NewAdd_or_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Add_or_subContext {
	var p = new(Add_or_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_add_or_sub

	return p
}

func (s *Add_or_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Add_or_subContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SHARCParserPLUS, 0)
}

func (s *Add_or_subContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SHARCParserMINUS, 0)
}

func (s *Add_or_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_or_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Add_or_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterAdd_or_sub(s)
	}
}

func (s *Add_or_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitAdd_or_sub(s)
	}
}

func (p *SHARCParser) Add_or_sub() (localctx IAdd_or_subContext) {
	this := p
	_ = this

	localctx = NewAdd_or_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SHARCParserRULE_add_or_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1121)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SHARCParserPLUS || _la == SHARCParserMINUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDual_opContext is an interface to support dynamic dispatch.
type IDual_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDual_opContext differentiates from other interfaces.
	IsDual_opContext()
}

type Dual_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDual_opContext() *Dual_opContext {
	var p = new(Dual_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_dual_op
	return p
}

func (*Dual_opContext) IsDual_opContext() {}

func NewDual_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dual_opContext {
	var p = new(Dual_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_dual_op

	return p
}

func (s *Dual_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Dual_opContext) Dual_add_r() IDual_add_rContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDual_add_rContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDual_add_rContext)
}

func (s *Dual_opContext) Parallel_multi() IParallel_multiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParallel_multiContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParallel_multiContext)
}

func (s *Dual_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dual_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dual_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterDual_op(s)
	}
}

func (s *Dual_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitDual_op(s)
	}
}

func (p *SHARCParser) Dual_op() (localctx IDual_opContext) {
	this := p
	_ = this

	localctx = NewDual_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SHARCParserRULE_dual_op)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1125)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1123)
			p.Dual_add_r()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1124)
			p.Parallel_multi()
		}

	}

	return localctx
}

// IDual_add_rContext is an interface to support dynamic dispatch.
type IDual_add_rContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDual_add_rContext differentiates from other interfaces.
	IsDual_add_rContext()
}

type Dual_add_rContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDual_add_rContext() *Dual_add_rContext {
	var p = new(Dual_add_rContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_dual_add_r
	return p
}

func (*Dual_add_rContext) IsDual_add_rContext() {}

func NewDual_add_rContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dual_add_rContext {
	var p = new(Dual_add_rContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_dual_add_r

	return p
}

func (s *Dual_add_rContext) GetParser() antlr.Parser { return s.parser }

func (s *Dual_add_rContext) AllR_reg() []IR_regContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IR_regContext)(nil)).Elem())
	var tst = make([]IR_regContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IR_regContext)
		}
	}

	return tst
}

func (s *Dual_add_rContext) R_reg(i int) IR_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IR_regContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IR_regContext)
}

func (s *Dual_add_rContext) AllEQU() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserEQU)
}

func (s *Dual_add_rContext) EQU(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, i)
}

func (s *Dual_add_rContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SHARCParserPLUS, 0)
}

func (s *Dual_add_rContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Dual_add_rContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SHARCParserMINUS, 0)
}

func (s *Dual_add_rContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dual_add_rContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dual_add_rContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterDual_add_r(s)
	}
}

func (s *Dual_add_rContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitDual_add_r(s)
	}
}

func (p *SHARCParser) Dual_add_r() (localctx IDual_add_rContext) {
	this := p
	_ = this

	localctx = NewDual_add_rContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SHARCParserRULE_dual_add_r)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1127)
		p.R_reg()
	}
	{
		p.SetState(1128)
		p.Match(SHARCParserEQU)
	}
	{
		p.SetState(1129)
		p.R_reg()
	}
	{
		p.SetState(1130)
		p.Match(SHARCParserPLUS)
	}
	{
		p.SetState(1131)
		p.R_reg()
	}
	{
		p.SetState(1132)
		p.Match(SHARCParserCOMMA)
	}
	{
		p.SetState(1133)
		p.R_reg()
	}
	{
		p.SetState(1134)
		p.Match(SHARCParserEQU)
	}
	{
		p.SetState(1135)
		p.R_reg()
	}
	{
		p.SetState(1136)
		p.Match(SHARCParserMINUS)
	}
	{
		p.SetState(1137)
		p.R_reg()
	}

	return localctx
}

// IParallel_multiContext is an interface to support dynamic dispatch.
type IParallel_multiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParallel_multiContext differentiates from other interfaces.
	IsParallel_multiContext()
}

type Parallel_multiContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParallel_multiContext() *Parallel_multiContext {
	var p = new(Parallel_multiContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_parallel_multi
	return p
}

func (*Parallel_multiContext) IsParallel_multiContext() {}

func NewParallel_multiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parallel_multiContext {
	var p = new(Parallel_multiContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_parallel_multi

	return p
}

func (s *Parallel_multiContext) GetParser() antlr.Parser { return s.parser }

func (s *Parallel_multiContext) Multi_op() IMulti_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_opContext)
}

func (s *Parallel_multiContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserCOMMA)
}

func (s *Parallel_multiContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, i)
}

func (s *Parallel_multiContext) AllFixpoint_alu_op() []IFixpoint_alu_opContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFixpoint_alu_opContext)(nil)).Elem())
	var tst = make([]IFixpoint_alu_opContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFixpoint_alu_opContext)
		}
	}

	return tst
}

func (s *Parallel_multiContext) Fixpoint_alu_op(i int) IFixpoint_alu_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFixpoint_alu_opContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFixpoint_alu_opContext)
}

func (s *Parallel_multiContext) AllFloating_point_alu_op() []IFloating_point_alu_opContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFloating_point_alu_opContext)(nil)).Elem())
	var tst = make([]IFloating_point_alu_opContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFloating_point_alu_opContext)
		}
	}

	return tst
}

func (s *Parallel_multiContext) Floating_point_alu_op(i int) IFloating_point_alu_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloating_point_alu_opContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFloating_point_alu_opContext)
}

func (s *Parallel_multiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parallel_multiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parallel_multiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterParallel_multi(s)
	}
}

func (s *Parallel_multiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitParallel_multi(s)
	}
}

func (p *SHARCParser) Parallel_multi() (localctx IParallel_multiContext) {
	this := p
	_ = this

	localctx = NewParallel_multiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SHARCParserRULE_parallel_multi)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1153)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserMR0B, SHARCParserMR0F, SHARCParserMR1B, SHARCParserMR1F, SHARCParserMR2B, SHARCParserMR2F, SHARCParserMRB, SHARCParserMRF, SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1139)
			p.Multi_op()
		}
		p.SetState(1142)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1140)
					p.Match(SHARCParserCOMMA)
				}
				{
					p.SetState(1141)
					p.Fixpoint_alu_op()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1144)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())
		}

	case SHARCParserCOMP, SHARCParserF0, SHARCParserF1, SHARCParserF2, SHARCParserF3, SHARCParserF4, SHARCParserF5, SHARCParserF6, SHARCParserF7, SHARCParserF8, SHARCParserF9, SHARCParserF10, SHARCParserF11, SHARCParserF12, SHARCParserF13, SHARCParserF14, SHARCParserF15:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1146)
			p.Floating_point_alu_op()
		}
		p.SetState(1149)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1147)
					p.Match(SHARCParserCOMMA)
				}
				{
					p.SetState(1148)
					p.Floating_point_alu_op()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1151)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFlow_control_expContext is an interface to support dynamic dispatch.
type IFlow_control_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_control_expContext differentiates from other interfaces.
	IsFlow_control_expContext()
}

type Flow_control_expContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_control_expContext() *Flow_control_expContext {
	var p = new(Flow_control_expContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_control_exp
	return p
}

func (*Flow_control_expContext) IsFlow_control_expContext() {}

func NewFlow_control_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_control_expContext {
	var p = new(Flow_control_expContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_control_exp

	return p
}

func (s *Flow_control_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_control_expContext) Flow_contorl_8() IFlow_contorl_8Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_contorl_8Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_contorl_8Context)
}

func (s *Flow_control_expContext) Flow_control_9_and_11() IFlow_control_9_and_11Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_9_and_11Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_9_and_11Context)
}

func (s *Flow_control_expContext) Flow_control_10() IFlow_control_10Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_10Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_10Context)
}

func (s *Flow_control_expContext) Flow_control_8a() IFlow_control_8aContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_8aContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_8aContext)
}

func (s *Flow_control_expContext) Flow_control_8b() IFlow_control_8bContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_8bContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_8bContext)
}

func (s *Flow_control_expContext) Flow_control_9a() IFlow_control_9aContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_9aContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_9aContext)
}

func (s *Flow_control_expContext) Flow_control_9b() IFlow_control_9bContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_9bContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_9bContext)
}

func (s *Flow_control_expContext) Flow_control_11a() IFlow_control_11aContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_11aContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_11aContext)
}

func (s *Flow_control_expContext) Flow_control_11b() IFlow_control_11bContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_11bContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_11bContext)
}

func (s *Flow_control_expContext) Flow_control_12() IFlow_control_12Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_12Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_12Context)
}

func (s *Flow_control_expContext) Flow_control_13() IFlow_control_13Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_13Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_13Context)
}

func (s *Flow_control_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_control_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_control_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_control_exp(s)
	}
}

func (s *Flow_control_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_control_exp(s)
	}
}

func (p *SHARCParser) Flow_control_exp() (localctx IFlow_control_expContext) {
	this := p
	_ = this

	localctx = NewFlow_control_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SHARCParserRULE_flow_control_exp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1166)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1155)
			p.Flow_contorl_8()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1156)
			p.Flow_control_9_and_11()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1157)
			p.Flow_control_10()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1158)
			p.Flow_control_8a()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1159)
			p.Flow_control_8b()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1160)
			p.Flow_control_9a()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1161)
			p.Flow_control_9b()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1162)
			p.Flow_control_11a()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1163)
			p.Flow_control_11b()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1164)
			p.Flow_control_12()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1165)
			p.Flow_control_13()
		}

	}

	return localctx
}

// IFlow_contorl_8Context is an interface to support dynamic dispatch.
type IFlow_contorl_8Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_contorl_8Context differentiates from other interfaces.
	IsFlow_contorl_8Context()
}

type Flow_contorl_8Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_contorl_8Context() *Flow_contorl_8Context {
	var p = new(Flow_contorl_8Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_contorl_8
	return p
}

func (*Flow_contorl_8Context) IsFlow_contorl_8Context() {}

func NewFlow_contorl_8Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_contorl_8Context {
	var p = new(Flow_contorl_8Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_contorl_8

	return p
}

func (s *Flow_contorl_8Context) GetParser() antlr.Parser { return s.parser }

func (s *Flow_contorl_8Context) IF() antlr.TerminalNode {
	return s.GetToken(SHARCParserIF, 0)
}

func (s *Flow_contorl_8Context) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Flow_contorl_8Context) Flow_contorl_8_exp() IFlow_contorl_8_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_contorl_8_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_contorl_8_expContext)
}

func (s *Flow_contorl_8Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_contorl_8Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_contorl_8Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_contorl_8(s)
	}
}

func (s *Flow_contorl_8Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_contorl_8(s)
	}
}

func (p *SHARCParser) Flow_contorl_8() (localctx IFlow_contorl_8Context) {
	this := p
	_ = this

	localctx = NewFlow_contorl_8Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SHARCParserRULE_flow_contorl_8)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1168)
		p.Match(SHARCParserIF)
	}
	{
		p.SetState(1169)
		p.Condition()
	}
	{
		p.SetState(1170)
		p.Flow_contorl_8_exp()
	}

	return localctx
}

// IFlow_contorl_8_expContext is an interface to support dynamic dispatch.
type IFlow_contorl_8_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_contorl_8_expContext differentiates from other interfaces.
	IsFlow_contorl_8_expContext()
}

type Flow_contorl_8_expContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_contorl_8_expContext() *Flow_contorl_8_expContext {
	var p = new(Flow_contorl_8_expContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_contorl_8_exp
	return p
}

func (*Flow_contorl_8_expContext) IsFlow_contorl_8_expContext() {}

func NewFlow_contorl_8_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_contorl_8_expContext {
	var p = new(Flow_contorl_8_expContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_contorl_8_exp

	return p
}

func (s *Flow_contorl_8_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_contorl_8_expContext) Flow_control_8a() IFlow_control_8aContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_8aContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_8aContext)
}

func (s *Flow_contorl_8_expContext) Flow_control_8b() IFlow_control_8bContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_8bContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_8bContext)
}

func (s *Flow_contorl_8_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_contorl_8_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_contorl_8_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_contorl_8_exp(s)
	}
}

func (s *Flow_contorl_8_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_contorl_8_exp(s)
	}
}

func (p *SHARCParser) Flow_contorl_8_exp() (localctx IFlow_contorl_8_expContext) {
	this := p
	_ = this

	localctx = NewFlow_contorl_8_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SHARCParserRULE_flow_contorl_8_exp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1174)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserJUMP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1172)
			p.Flow_control_8a()
		}

	case SHARCParserCALL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1173)
			p.Flow_control_8b()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFlow_control_9_and_11Context is an interface to support dynamic dispatch.
type IFlow_control_9_and_11Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_control_9_and_11Context differentiates from other interfaces.
	IsFlow_control_9_and_11Context()
}

type Flow_control_9_and_11Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_control_9_and_11Context() *Flow_control_9_and_11Context {
	var p = new(Flow_control_9_and_11Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_control_9_and_11
	return p
}

func (*Flow_control_9_and_11Context) IsFlow_control_9_and_11Context() {}

func NewFlow_control_9_and_11Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_control_9_and_11Context {
	var p = new(Flow_control_9_and_11Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_control_9_and_11

	return p
}

func (s *Flow_control_9_and_11Context) GetParser() antlr.Parser { return s.parser }

func (s *Flow_control_9_and_11Context) IF() antlr.TerminalNode {
	return s.GetToken(SHARCParserIF, 0)
}

func (s *Flow_control_9_and_11Context) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Flow_control_9_and_11Context) Flow_control_9_and_11_exp() IFlow_control_9_and_11_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_9_and_11_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_9_and_11_expContext)
}

func (s *Flow_control_9_and_11Context) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Flow_control_9_and_11Context) ELSE() antlr.TerminalNode {
	return s.GetToken(SHARCParserELSE, 0)
}

func (s *Flow_control_9_and_11Context) Compute() IComputeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputeContext)
}

func (s *Flow_control_9_and_11Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_control_9_and_11Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_control_9_and_11Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_control_9_and_11(s)
	}
}

func (s *Flow_control_9_and_11Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_control_9_and_11(s)
	}
}

func (p *SHARCParser) Flow_control_9_and_11() (localctx IFlow_control_9_and_11Context) {
	this := p
	_ = this

	localctx = NewFlow_control_9_and_11Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SHARCParserRULE_flow_control_9_and_11)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1176)
		p.Match(SHARCParserIF)
	}
	{
		p.SetState(1177)
		p.Condition()
	}
	{
		p.SetState(1178)
		p.Flow_control_9_and_11_exp()
	}
	{
		p.SetState(1179)
		p.Match(SHARCParserCOMMA)
	}
	{
		p.SetState(1180)
		p.Match(SHARCParserELSE)
	}
	{
		p.SetState(1181)
		p.Compute()
	}

	return localctx
}

// IFlow_control_9_and_11_expContext is an interface to support dynamic dispatch.
type IFlow_control_9_and_11_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_control_9_and_11_expContext differentiates from other interfaces.
	IsFlow_control_9_and_11_expContext()
}

type Flow_control_9_and_11_expContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_control_9_and_11_expContext() *Flow_control_9_and_11_expContext {
	var p = new(Flow_control_9_and_11_expContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_control_9_and_11_exp
	return p
}

func (*Flow_control_9_and_11_expContext) IsFlow_control_9_and_11_expContext() {}

func NewFlow_control_9_and_11_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_control_9_and_11_expContext {
	var p = new(Flow_control_9_and_11_expContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_control_9_and_11_exp

	return p
}

func (s *Flow_control_9_and_11_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_control_9_and_11_expContext) Flow_control_9a() IFlow_control_9aContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_9aContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_9aContext)
}

func (s *Flow_control_9_and_11_expContext) Flow_control_9b() IFlow_control_9bContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_9bContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_9bContext)
}

func (s *Flow_control_9_and_11_expContext) Flow_control_11a() IFlow_control_11aContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_11aContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_11aContext)
}

func (s *Flow_control_9_and_11_expContext) Flow_control_11b() IFlow_control_11bContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_11bContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_11bContext)
}

func (s *Flow_control_9_and_11_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_control_9_and_11_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_control_9_and_11_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_control_9_and_11_exp(s)
	}
}

func (s *Flow_control_9_and_11_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_control_9_and_11_exp(s)
	}
}

func (p *SHARCParser) Flow_control_9_and_11_exp() (localctx IFlow_control_9_and_11_expContext) {
	this := p
	_ = this

	localctx = NewFlow_control_9_and_11_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SHARCParserRULE_flow_control_9_and_11_exp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1187)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserJUMP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1183)
			p.Flow_control_9a()
		}

	case SHARCParserCALL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1184)
			p.Flow_control_9b()
		}

	case SHARCParserRTS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1185)
			p.Flow_control_11a()
		}

	case SHARCParserRTI:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1186)
			p.Flow_control_11b()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFlow_control_10Context is an interface to support dynamic dispatch.
type IFlow_control_10Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_control_10Context differentiates from other interfaces.
	IsFlow_control_10Context()
}

type Flow_control_10Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_control_10Context() *Flow_control_10Context {
	var p = new(Flow_control_10Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_control_10
	return p
}

func (*Flow_control_10Context) IsFlow_control_10Context() {}

func NewFlow_control_10Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_control_10Context {
	var p = new(Flow_control_10Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_control_10

	return p
}

func (s *Flow_control_10Context) GetParser() antlr.Parser { return s.parser }

func (s *Flow_control_10Context) IF() antlr.TerminalNode {
	return s.GetToken(SHARCParserIF, 0)
}

func (s *Flow_control_10Context) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Flow_control_10Context) JUMP() antlr.TerminalNode {
	return s.GetToken(SHARCParserJUMP, 0)
}

func (s *Flow_control_10Context) Flow_control_10_frag() IFlow_control_10_fragContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_10_fragContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_10_fragContext)
}

func (s *Flow_control_10Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserCOMMA)
}

func (s *Flow_control_10Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, i)
}

func (s *Flow_control_10Context) ELSE() antlr.TerminalNode {
	return s.GetToken(SHARCParserELSE, 0)
}

func (s *Flow_control_10Context) Mov_exp_1_1() IMov_exp_1_1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMov_exp_1_1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMov_exp_1_1Context)
}

func (s *Flow_control_10Context) Compute() IComputeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputeContext)
}

func (s *Flow_control_10Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_control_10Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_control_10Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_control_10(s)
	}
}

func (s *Flow_control_10Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_control_10(s)
	}
}

func (p *SHARCParser) Flow_control_10() (localctx IFlow_control_10Context) {
	this := p
	_ = this

	localctx = NewFlow_control_10Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SHARCParserRULE_flow_control_10)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1189)
		p.Match(SHARCParserIF)
	}
	{
		p.SetState(1190)
		p.Condition()
	}
	{
		p.SetState(1191)
		p.Match(SHARCParserJUMP)
	}
	{
		p.SetState(1192)
		p.Flow_control_10_frag()
	}
	{
		p.SetState(1193)
		p.Match(SHARCParserCOMMA)
	}
	{
		p.SetState(1194)
		p.Match(SHARCParserELSE)
	}
	p.SetState(1198)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1195)
			p.Compute()
		}
		{
			p.SetState(1196)
			p.Match(SHARCParserCOMMA)
		}

	}
	{
		p.SetState(1200)
		p.Mov_exp_1_1()
	}

	return localctx
}

// IFlow_control_10_fragContext is an interface to support dynamic dispatch.
type IFlow_control_10_fragContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_control_10_fragContext differentiates from other interfaces.
	IsFlow_control_10_fragContext()
}

type Flow_control_10_fragContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_control_10_fragContext() *Flow_control_10_fragContext {
	var p = new(Flow_control_10_fragContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_control_10_frag
	return p
}

func (*Flow_control_10_fragContext) IsFlow_control_10_fragContext() {}

func NewFlow_control_10_fragContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_control_10_fragContext {
	var p = new(Flow_control_10_fragContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_control_10_frag

	return p
}

func (s *Flow_control_10_fragContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_control_10_fragContext) Mem_addr_md_ic() IMem_addr_md_icContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_md_icContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_md_icContext)
}

func (s *Flow_control_10_fragContext) Jump_addr_pc() IJump_addr_pcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_addr_pcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_addr_pcContext)
}

func (s *Flow_control_10_fragContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_control_10_fragContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_control_10_fragContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_control_10_frag(s)
	}
}

func (s *Flow_control_10_fragContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_control_10_frag(s)
	}
}

func (p *SHARCParser) Flow_control_10_frag() (localctx IFlow_control_10_fragContext) {
	this := p
	_ = this

	localctx = NewFlow_control_10_fragContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SHARCParserRULE_flow_control_10_frag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1204)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1202)
			p.Mem_addr_md_ic()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1203)
			p.Jump_addr_pc()
		}

	}

	return localctx
}

// IFlow_control_12Context is an interface to support dynamic dispatch.
type IFlow_control_12Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_control_12Context differentiates from other interfaces.
	IsFlow_control_12Context()
}

type Flow_control_12Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_control_12Context() *Flow_control_12Context {
	var p = new(Flow_control_12Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_control_12
	return p
}

func (*Flow_control_12Context) IsFlow_control_12Context() {}

func NewFlow_control_12Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_control_12Context {
	var p = new(Flow_control_12Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_control_12

	return p
}

func (s *Flow_control_12Context) GetParser() antlr.Parser { return s.parser }

func (s *Flow_control_12Context) LCNTR() antlr.TerminalNode {
	return s.GetToken(SHARCParserLCNTR, 0)
}

func (s *Flow_control_12Context) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Flow_control_12Context) Lcntr_v() ILcntr_vContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILcntr_vContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILcntr_vContext)
}

func (s *Flow_control_12Context) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Flow_control_12Context) DO() antlr.TerminalNode {
	return s.GetToken(SHARCParserDO, 0)
}

func (s *Flow_control_12Context) Jump_addr_int_or_pc() IJump_addr_int_or_pcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_addr_int_or_pcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_addr_int_or_pcContext)
}

func (s *Flow_control_12Context) UNTIL() antlr.TerminalNode {
	return s.GetToken(SHARCParserUNTIL, 0)
}

func (s *Flow_control_12Context) LCE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLCE, 0)
}

func (s *Flow_control_12Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_control_12Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_control_12Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_control_12(s)
	}
}

func (s *Flow_control_12Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_control_12(s)
	}
}

func (p *SHARCParser) Flow_control_12() (localctx IFlow_control_12Context) {
	this := p
	_ = this

	localctx = NewFlow_control_12Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SHARCParserRULE_flow_control_12)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1206)
		p.Match(SHARCParserLCNTR)
	}
	{
		p.SetState(1207)
		p.Match(SHARCParserEQU)
	}
	{
		p.SetState(1208)
		p.Lcntr_v()
	}

	{
		p.SetState(1209)
		p.Match(SHARCParserCOMMA)
	}
	{
		p.SetState(1210)
		p.Match(SHARCParserDO)
	}
	{
		p.SetState(1211)
		p.Jump_addr_int_or_pc()
	}
	{
		p.SetState(1212)
		p.Match(SHARCParserUNTIL)
	}
	{
		p.SetState(1213)
		p.Match(SHARCParserLCE)
	}

	return localctx
}

// ILcntr_vContext is an interface to support dynamic dispatch.
type ILcntr_vContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLcntr_vContext differentiates from other interfaces.
	IsLcntr_vContext()
}

type Lcntr_vContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLcntr_vContext() *Lcntr_vContext {
	var p = new(Lcntr_vContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_lcntr_v
	return p
}

func (*Lcntr_vContext) IsLcntr_vContext() {}

func NewLcntr_vContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lcntr_vContext {
	var p = new(Lcntr_vContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_lcntr_v

	return p
}

func (s *Lcntr_vContext) GetParser() antlr.Parser { return s.parser }

func (s *Lcntr_vContext) Value_exp() IValue_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_expContext)
}

func (s *Lcntr_vContext) U_reg() IU_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IU_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IU_regContext)
}

func (s *Lcntr_vContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lcntr_vContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lcntr_vContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterLcntr_v(s)
	}
}

func (s *Lcntr_vContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitLcntr_v(s)
	}
}

func (p *SHARCParser) Lcntr_v() (localctx ILcntr_vContext) {
	this := p
	_ = this

	localctx = NewLcntr_vContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SHARCParserRULE_lcntr_v)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1217)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserINT, SHARCParserLENGTH, SHARCParserMINUS, SHARCParserLPARENTHESE, SHARCParserAT, SHARCParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1215)
			p.Value_exp()
		}

	case SHARCParserASTAT, SHARCParserB0, SHARCParserB1, SHARCParserB2, SHARCParserB3, SHARCParserB4, SHARCParserB5, SHARCParserB6, SHARCParserB7, SHARCParserB8, SHARCParserB9, SHARCParserB10, SHARCParserB11, SHARCParserB12, SHARCParserB13, SHARCParserB14, SHARCParserB15, SHARCParserCURLCNTR, SHARCParserDADDR, SHARCParserF0, SHARCParserF1, SHARCParserF2, SHARCParserF3, SHARCParserF4, SHARCParserF5, SHARCParserF6, SHARCParserF7, SHARCParserF8, SHARCParserF9, SHARCParserF10, SHARCParserF11, SHARCParserF12, SHARCParserF13, SHARCParserF14, SHARCParserF15, SHARCParserFADDR, SHARCParserI0, SHARCParserI1, SHARCParserI2, SHARCParserI3, SHARCParserI4, SHARCParserI5, SHARCParserI6, SHARCParserI7, SHARCParserI8, SHARCParserI9, SHARCParserI10, SHARCParserI11, SHARCParserI12, SHARCParserI13, SHARCParserI14, SHARCParserI15, SHARCParserIMASK, SHARCParserIMASKP, SHARCParserIRPTL, SHARCParserL0, SHARCParserL1, SHARCParserL2, SHARCParserL3, SHARCParserL4, SHARCParserL5, SHARCParserL6, SHARCParserL7, SHARCParserL8, SHARCParserL9, SHARCParserL10, SHARCParserL11, SHARCParserL12, SHARCParserL13, SHARCParserL14, SHARCParserL15, SHARCParserLADDR, SHARCParserLCNTR, SHARCParserM0, SHARCParserM1, SHARCParserM2, SHARCParserM3, SHARCParserM4, SHARCParserM5, SHARCParserM6, SHARCParserM7, SHARCParserM8, SHARCParserM9, SHARCParserM10, SHARCParserM11, SHARCParserM12, SHARCParserM13, SHARCParserM14, SHARCParserM15, SHARCParserMODE1, SHARCParserMODE2, SHARCParserPC, SHARCParserPCSTK, SHARCParserPCSTKP, SHARCParserPX, SHARCParserPX1, SHARCParserPX2, SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15, SHARCParserSTKY, SHARCParserTCOUNT, SHARCParserTPERIOD, SHARCParserUSTAT1, SHARCParserUSTAT2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1216)
			p.U_reg()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFlow_control_13Context is an interface to support dynamic dispatch.
type IFlow_control_13Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_control_13Context differentiates from other interfaces.
	IsFlow_control_13Context()
}

type Flow_control_13Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_control_13Context() *Flow_control_13Context {
	var p = new(Flow_control_13Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_control_13
	return p
}

func (*Flow_control_13Context) IsFlow_control_13Context() {}

func NewFlow_control_13Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_control_13Context {
	var p = new(Flow_control_13Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_control_13

	return p
}

func (s *Flow_control_13Context) GetParser() antlr.Parser { return s.parser }

func (s *Flow_control_13Context) DO() antlr.TerminalNode {
	return s.GetToken(SHARCParserDO, 0)
}

func (s *Flow_control_13Context) Jump_addr_int_or_pc() IJump_addr_int_or_pcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_addr_int_or_pcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_addr_int_or_pcContext)
}

func (s *Flow_control_13Context) UNTIL() antlr.TerminalNode {
	return s.GetToken(SHARCParserUNTIL, 0)
}

func (s *Flow_control_13Context) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Flow_control_13Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_control_13Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_control_13Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_control_13(s)
	}
}

func (s *Flow_control_13Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_control_13(s)
	}
}

func (p *SHARCParser) Flow_control_13() (localctx IFlow_control_13Context) {
	this := p
	_ = this

	localctx = NewFlow_control_13Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, SHARCParserRULE_flow_control_13)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1219)
		p.Match(SHARCParserDO)
	}
	{
		p.SetState(1220)
		p.Jump_addr_int_or_pc()
	}
	{
		p.SetState(1221)
		p.Match(SHARCParserUNTIL)
	}
	{
		p.SetState(1222)
		p.Condition()
	}

	return localctx
}

// IFlow_control_8aContext is an interface to support dynamic dispatch.
type IFlow_control_8aContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_control_8aContext differentiates from other interfaces.
	IsFlow_control_8aContext()
}

type Flow_control_8aContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_control_8aContext() *Flow_control_8aContext {
	var p = new(Flow_control_8aContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_control_8a
	return p
}

func (*Flow_control_8aContext) IsFlow_control_8aContext() {}

func NewFlow_control_8aContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_control_8aContext {
	var p = new(Flow_control_8aContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_control_8a

	return p
}

func (s *Flow_control_8aContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_control_8aContext) JUMP() antlr.TerminalNode {
	return s.GetToken(SHARCParserJUMP, 0)
}

func (s *Flow_control_8aContext) Jump_addr_int() IJump_addr_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_addr_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_addr_intContext)
}

func (s *Flow_control_8aContext) Jump_modifier() IJump_modifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_modifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_modifierContext)
}

func (s *Flow_control_8aContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_control_8aContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_control_8aContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_control_8a(s)
	}
}

func (s *Flow_control_8aContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_control_8a(s)
	}
}

func (p *SHARCParser) Flow_control_8a() (localctx IFlow_control_8aContext) {
	this := p
	_ = this

	localctx = NewFlow_control_8aContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, SHARCParserRULE_flow_control_8a)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1224)
		p.Match(SHARCParserJUMP)
	}
	{
		p.SetState(1225)
		p.Jump_addr_int()
	}
	p.SetState(1227)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SHARCParserLPARENTHESE {
		{
			p.SetState(1226)
			p.Jump_modifier()
		}

	}

	return localctx
}

// IFlow_control_8bContext is an interface to support dynamic dispatch.
type IFlow_control_8bContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_control_8bContext differentiates from other interfaces.
	IsFlow_control_8bContext()
}

type Flow_control_8bContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_control_8bContext() *Flow_control_8bContext {
	var p = new(Flow_control_8bContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_control_8b
	return p
}

func (*Flow_control_8bContext) IsFlow_control_8bContext() {}

func NewFlow_control_8bContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_control_8bContext {
	var p = new(Flow_control_8bContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_control_8b

	return p
}

func (s *Flow_control_8bContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_control_8bContext) CALL() antlr.TerminalNode {
	return s.GetToken(SHARCParserCALL, 0)
}

func (s *Flow_control_8bContext) Jump_addr_int() IJump_addr_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_addr_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_addr_intContext)
}

func (s *Flow_control_8bContext) Jump_modifier2() IJump_modifier2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_modifier2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_modifier2Context)
}

func (s *Flow_control_8bContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_control_8bContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_control_8bContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_control_8b(s)
	}
}

func (s *Flow_control_8bContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_control_8b(s)
	}
}

func (p *SHARCParser) Flow_control_8b() (localctx IFlow_control_8bContext) {
	this := p
	_ = this

	localctx = NewFlow_control_8bContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, SHARCParserRULE_flow_control_8b)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1229)
		p.Match(SHARCParserCALL)
	}
	{
		p.SetState(1230)
		p.Jump_addr_int()
	}
	p.SetState(1232)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SHARCParserLPARENTHESE {
		{
			p.SetState(1231)
			p.Jump_modifier2()
		}

	}

	return localctx
}

// IFlow_control_9aContext is an interface to support dynamic dispatch.
type IFlow_control_9aContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_control_9aContext differentiates from other interfaces.
	IsFlow_control_9aContext()
}

type Flow_control_9aContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_control_9aContext() *Flow_control_9aContext {
	var p = new(Flow_control_9aContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_control_9a
	return p
}

func (*Flow_control_9aContext) IsFlow_control_9aContext() {}

func NewFlow_control_9aContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_control_9aContext {
	var p = new(Flow_control_9aContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_control_9a

	return p
}

func (s *Flow_control_9aContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_control_9aContext) JUMP() antlr.TerminalNode {
	return s.GetToken(SHARCParserJUMP, 0)
}

func (s *Flow_control_9aContext) Flow_control_10_frag() IFlow_control_10_fragContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_10_fragContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_10_fragContext)
}

func (s *Flow_control_9aContext) Jump_modifier() IJump_modifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_modifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_modifierContext)
}

func (s *Flow_control_9aContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Flow_control_9aContext) Compute() IComputeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputeContext)
}

func (s *Flow_control_9aContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_control_9aContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_control_9aContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_control_9a(s)
	}
}

func (s *Flow_control_9aContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_control_9a(s)
	}
}

func (p *SHARCParser) Flow_control_9a() (localctx IFlow_control_9aContext) {
	this := p
	_ = this

	localctx = NewFlow_control_9aContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, SHARCParserRULE_flow_control_9a)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1234)
		p.Match(SHARCParserJUMP)
	}
	{
		p.SetState(1235)
		p.Flow_control_10_frag()
	}
	p.SetState(1237)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SHARCParserLPARENTHESE {
		{
			p.SetState(1236)
			p.Jump_modifier()
		}

	}
	p.SetState(1241)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1239)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(1240)
			p.Compute()
		}

	}

	return localctx
}

// IFlow_control_9bContext is an interface to support dynamic dispatch.
type IFlow_control_9bContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_control_9bContext differentiates from other interfaces.
	IsFlow_control_9bContext()
}

type Flow_control_9bContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_control_9bContext() *Flow_control_9bContext {
	var p = new(Flow_control_9bContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_control_9b
	return p
}

func (*Flow_control_9bContext) IsFlow_control_9bContext() {}

func NewFlow_control_9bContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_control_9bContext {
	var p = new(Flow_control_9bContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_control_9b

	return p
}

func (s *Flow_control_9bContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_control_9bContext) CALL() antlr.TerminalNode {
	return s.GetToken(SHARCParserCALL, 0)
}

func (s *Flow_control_9bContext) Flow_control_10_frag() IFlow_control_10_fragContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_10_fragContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_10_fragContext)
}

func (s *Flow_control_9bContext) Jump_modifier2() IJump_modifier2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_modifier2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_modifier2Context)
}

func (s *Flow_control_9bContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Flow_control_9bContext) Compute() IComputeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputeContext)
}

func (s *Flow_control_9bContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_control_9bContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_control_9bContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_control_9b(s)
	}
}

func (s *Flow_control_9bContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_control_9b(s)
	}
}

func (p *SHARCParser) Flow_control_9b() (localctx IFlow_control_9bContext) {
	this := p
	_ = this

	localctx = NewFlow_control_9bContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, SHARCParserRULE_flow_control_9b)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1243)
		p.Match(SHARCParserCALL)
	}
	{
		p.SetState(1244)
		p.Flow_control_10_frag()
	}
	p.SetState(1246)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SHARCParserLPARENTHESE {
		{
			p.SetState(1245)
			p.Jump_modifier2()
		}

	}
	p.SetState(1250)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1248)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(1249)
			p.Compute()
		}

	}

	return localctx
}

// IFlow_control_11aContext is an interface to support dynamic dispatch.
type IFlow_control_11aContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_control_11aContext differentiates from other interfaces.
	IsFlow_control_11aContext()
}

type Flow_control_11aContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_control_11aContext() *Flow_control_11aContext {
	var p = new(Flow_control_11aContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_control_11a
	return p
}

func (*Flow_control_11aContext) IsFlow_control_11aContext() {}

func NewFlow_control_11aContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_control_11aContext {
	var p = new(Flow_control_11aContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_control_11a

	return p
}

func (s *Flow_control_11aContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_control_11aContext) RTS() antlr.TerminalNode {
	return s.GetToken(SHARCParserRTS, 0)
}

func (s *Flow_control_11aContext) Jump_modifier3() IJump_modifier3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_modifier3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_modifier3Context)
}

func (s *Flow_control_11aContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Flow_control_11aContext) Compute() IComputeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputeContext)
}

func (s *Flow_control_11aContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_control_11aContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_control_11aContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_control_11a(s)
	}
}

func (s *Flow_control_11aContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_control_11a(s)
	}
}

func (p *SHARCParser) Flow_control_11a() (localctx IFlow_control_11aContext) {
	this := p
	_ = this

	localctx = NewFlow_control_11aContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, SHARCParserRULE_flow_control_11a)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1252)
		p.Match(SHARCParserRTS)
	}
	p.SetState(1254)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SHARCParserLPARENTHESE {
		{
			p.SetState(1253)
			p.Jump_modifier3()
		}

	}
	p.SetState(1258)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1256)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(1257)
			p.Compute()
		}

	}

	return localctx
}

// IFlow_control_11bContext is an interface to support dynamic dispatch.
type IFlow_control_11bContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_control_11bContext differentiates from other interfaces.
	IsFlow_control_11bContext()
}

type Flow_control_11bContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_control_11bContext() *Flow_control_11bContext {
	var p = new(Flow_control_11bContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_flow_control_11b
	return p
}

func (*Flow_control_11bContext) IsFlow_control_11bContext() {}

func NewFlow_control_11bContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_control_11bContext {
	var p = new(Flow_control_11bContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_flow_control_11b

	return p
}

func (s *Flow_control_11bContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_control_11bContext) RTI() antlr.TerminalNode {
	return s.GetToken(SHARCParserRTI, 0)
}

func (s *Flow_control_11bContext) Jump_modifier2() IJump_modifier2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_modifier2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_modifier2Context)
}

func (s *Flow_control_11bContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Flow_control_11bContext) Compute() IComputeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputeContext)
}

func (s *Flow_control_11bContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_control_11bContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_control_11bContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterFlow_control_11b(s)
	}
}

func (s *Flow_control_11bContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitFlow_control_11b(s)
	}
}

func (p *SHARCParser) Flow_control_11b() (localctx IFlow_control_11bContext) {
	this := p
	_ = this

	localctx = NewFlow_control_11bContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, SHARCParserRULE_flow_control_11b)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1260)
		p.Match(SHARCParserRTI)
	}
	p.SetState(1262)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SHARCParserLPARENTHESE {
		{
			p.SetState(1261)
			p.Jump_modifier2()
		}

	}
	p.SetState(1266)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1264)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(1265)
			p.Compute()
		}

	}

	return localctx
}

// IJump_addr_int_or_pcContext is an interface to support dynamic dispatch.
type IJump_addr_int_or_pcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_addr_int_or_pcContext differentiates from other interfaces.
	IsJump_addr_int_or_pcContext()
}

type Jump_addr_int_or_pcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_addr_int_or_pcContext() *Jump_addr_int_or_pcContext {
	var p = new(Jump_addr_int_or_pcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_jump_addr_int_or_pc
	return p
}

func (*Jump_addr_int_or_pcContext) IsJump_addr_int_or_pcContext() {}

func NewJump_addr_int_or_pcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_addr_int_or_pcContext {
	var p = new(Jump_addr_int_or_pcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_jump_addr_int_or_pc

	return p
}

func (s *Jump_addr_int_or_pcContext) GetParser() antlr.Parser { return s.parser }

func (s *Jump_addr_int_or_pcContext) Jump_addr_int() IJump_addr_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_addr_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_addr_intContext)
}

func (s *Jump_addr_int_or_pcContext) Jump_addr_pc() IJump_addr_pcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_addr_pcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_addr_pcContext)
}

func (s *Jump_addr_int_or_pcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_addr_int_or_pcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jump_addr_int_or_pcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterJump_addr_int_or_pc(s)
	}
}

func (s *Jump_addr_int_or_pcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitJump_addr_int_or_pc(s)
	}
}

func (p *SHARCParser) Jump_addr_int_or_pc() (localctx IJump_addr_int_or_pcContext) {
	this := p
	_ = this

	localctx = NewJump_addr_int_or_pcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, SHARCParserRULE_jump_addr_int_or_pc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1270)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1268)
			p.Jump_addr_int()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1269)
			p.Jump_addr_pc()
		}

	}

	return localctx
}

// IJump_addr_md_or_pcContext is an interface to support dynamic dispatch.
type IJump_addr_md_or_pcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_addr_md_or_pcContext differentiates from other interfaces.
	IsJump_addr_md_or_pcContext()
}

type Jump_addr_md_or_pcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_addr_md_or_pcContext() *Jump_addr_md_or_pcContext {
	var p = new(Jump_addr_md_or_pcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_jump_addr_md_or_pc
	return p
}

func (*Jump_addr_md_or_pcContext) IsJump_addr_md_or_pcContext() {}

func NewJump_addr_md_or_pcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_addr_md_or_pcContext {
	var p = new(Jump_addr_md_or_pcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_jump_addr_md_or_pc

	return p
}

func (s *Jump_addr_md_or_pcContext) GetParser() antlr.Parser { return s.parser }

func (s *Jump_addr_md_or_pcContext) Mem_addr_md_ic() IMem_addr_md_icContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_md_icContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_md_icContext)
}

func (s *Jump_addr_md_or_pcContext) Jump_addr_pc() IJump_addr_pcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_addr_pcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_addr_pcContext)
}

func (s *Jump_addr_md_or_pcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_addr_md_or_pcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jump_addr_md_or_pcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterJump_addr_md_or_pc(s)
	}
}

func (s *Jump_addr_md_or_pcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitJump_addr_md_or_pc(s)
	}
}

func (p *SHARCParser) Jump_addr_md_or_pc() (localctx IJump_addr_md_or_pcContext) {
	this := p
	_ = this

	localctx = NewJump_addr_md_or_pcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, SHARCParserRULE_jump_addr_md_or_pc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1274)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1272)
			p.Mem_addr_md_ic()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1273)
			p.Jump_addr_pc()
		}

	}

	return localctx
}

// IJump_addr_pcContext is an interface to support dynamic dispatch.
type IJump_addr_pcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_addr_pcContext differentiates from other interfaces.
	IsJump_addr_pcContext()
}

type Jump_addr_pcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_addr_pcContext() *Jump_addr_pcContext {
	var p = new(Jump_addr_pcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_jump_addr_pc
	return p
}

func (*Jump_addr_pcContext) IsJump_addr_pcContext() {}

func NewJump_addr_pcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_addr_pcContext {
	var p = new(Jump_addr_pcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_jump_addr_pc

	return p
}

func (s *Jump_addr_pcContext) GetParser() antlr.Parser { return s.parser }

func (s *Jump_addr_pcContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Jump_addr_pcContext) PC() antlr.TerminalNode {
	return s.GetToken(SHARCParserPC, 0)
}

func (s *Jump_addr_pcContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Jump_addr_pcContext) Value_exp() IValue_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_expContext)
}

func (s *Jump_addr_pcContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Jump_addr_pcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_addr_pcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jump_addr_pcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterJump_addr_pc(s)
	}
}

func (s *Jump_addr_pcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitJump_addr_pc(s)
	}
}

func (p *SHARCParser) Jump_addr_pc() (localctx IJump_addr_pcContext) {
	this := p
	_ = this

	localctx = NewJump_addr_pcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, SHARCParserRULE_jump_addr_pc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1276)
		p.Match(SHARCParserLPARENTHESE)
	}
	{
		p.SetState(1277)
		p.Match(SHARCParserPC)
	}
	{
		p.SetState(1278)
		p.Match(SHARCParserCOMMA)
	}
	{
		p.SetState(1279)
		p.Value_exp()
	}
	{
		p.SetState(1280)
		p.Match(SHARCParserRPARENTHESE)
	}

	return localctx
}

// IJump_addr_intContext is an interface to support dynamic dispatch.
type IJump_addr_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_addr_intContext differentiates from other interfaces.
	IsJump_addr_intContext()
}

type Jump_addr_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_addr_intContext() *Jump_addr_intContext {
	var p = new(Jump_addr_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_jump_addr_int
	return p
}

func (*Jump_addr_intContext) IsJump_addr_intContext() {}

func NewJump_addr_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_addr_intContext {
	var p = new(Jump_addr_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_jump_addr_int

	return p
}

func (s *Jump_addr_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Jump_addr_intContext) Value_exp() IValue_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_expContext)
}

func (s *Jump_addr_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_addr_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jump_addr_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterJump_addr_int(s)
	}
}

func (s *Jump_addr_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitJump_addr_int(s)
	}
}

func (p *SHARCParser) Jump_addr_int() (localctx IJump_addr_intContext) {
	this := p
	_ = this

	localctx = NewJump_addr_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, SHARCParserRULE_jump_addr_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1282)
		p.Value_exp()
	}

	return localctx
}

// IJump_modifierContext is an interface to support dynamic dispatch.
type IJump_modifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_modifierContext differentiates from other interfaces.
	IsJump_modifierContext()
}

type Jump_modifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_modifierContext() *Jump_modifierContext {
	var p = new(Jump_modifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_jump_modifier
	return p
}

func (*Jump_modifierContext) IsJump_modifierContext() {}

func NewJump_modifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_modifierContext {
	var p = new(Jump_modifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_jump_modifier

	return p
}

func (s *Jump_modifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Jump_modifierContext) Jump_modifier_() IJump_modifier_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_modifier_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_modifier_Context)
}

func (s *Jump_modifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_modifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jump_modifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterJump_modifier(s)
	}
}

func (s *Jump_modifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitJump_modifier(s)
	}
}

func (p *SHARCParser) Jump_modifier() (localctx IJump_modifierContext) {
	this := p
	_ = this

	localctx = NewJump_modifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, SHARCParserRULE_jump_modifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1284)
		p.Jump_modifier_()
	}

	return localctx
}

// IJump_modifier_Context is an interface to support dynamic dispatch.
type IJump_modifier_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_modifier_Context differentiates from other interfaces.
	IsJump_modifier_Context()
}

type Jump_modifier_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_modifier_Context() *Jump_modifier_Context {
	var p = new(Jump_modifier_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_jump_modifier_
	return p
}

func (*Jump_modifier_Context) IsJump_modifier_Context() {}

func NewJump_modifier_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_modifier_Context {
	var p = new(Jump_modifier_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_jump_modifier_

	return p
}

func (s *Jump_modifier_Context) GetParser() antlr.Parser { return s.parser }

func (s *Jump_modifier_Context) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Jump_modifier_Context) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Jump_modifier_Context) Jump_modifier_1() IJump_modifier_1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_modifier_1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_modifier_1Context)
}

func (s *Jump_modifier_Context) LA() antlr.TerminalNode {
	return s.GetToken(SHARCParserLA, 0)
}

func (s *Jump_modifier_Context) CI() antlr.TerminalNode {
	return s.GetToken(SHARCParserCI, 0)
}

func (s *Jump_modifier_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_modifier_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jump_modifier_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterJump_modifier_(s)
	}
}

func (s *Jump_modifier_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitJump_modifier_(s)
	}
}

func (p *SHARCParser) Jump_modifier_() (localctx IJump_modifier_Context) {
	this := p
	_ = this

	localctx = NewJump_modifier_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, SHARCParserRULE_jump_modifier_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1286)
		p.Match(SHARCParserLPARENTHESE)
	}
	p.SetState(1290)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDB:
		{
			p.SetState(1287)
			p.Jump_modifier_1()
		}

	case SHARCParserLA:
		{
			p.SetState(1288)
			p.Match(SHARCParserLA)
		}

	case SHARCParserCI:
		{
			p.SetState(1289)
			p.Match(SHARCParserCI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1292)
		p.Match(SHARCParserRPARENTHESE)
	}

	return localctx
}

// IJump_modifier_1Context is an interface to support dynamic dispatch.
type IJump_modifier_1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_modifier_1Context differentiates from other interfaces.
	IsJump_modifier_1Context()
}

type Jump_modifier_1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_modifier_1Context() *Jump_modifier_1Context {
	var p = new(Jump_modifier_1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_jump_modifier_1
	return p
}

func (*Jump_modifier_1Context) IsJump_modifier_1Context() {}

func NewJump_modifier_1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_modifier_1Context {
	var p = new(Jump_modifier_1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_jump_modifier_1

	return p
}

func (s *Jump_modifier_1Context) GetParser() antlr.Parser { return s.parser }

func (s *Jump_modifier_1Context) DB() antlr.TerminalNode {
	return s.GetToken(SHARCParserDB, 0)
}

func (s *Jump_modifier_1Context) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Jump_modifier_1Context) LA() antlr.TerminalNode {
	return s.GetToken(SHARCParserLA, 0)
}

func (s *Jump_modifier_1Context) CI() antlr.TerminalNode {
	return s.GetToken(SHARCParserCI, 0)
}

func (s *Jump_modifier_1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_modifier_1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jump_modifier_1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterJump_modifier_1(s)
	}
}

func (s *Jump_modifier_1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitJump_modifier_1(s)
	}
}

func (p *SHARCParser) Jump_modifier_1() (localctx IJump_modifier_1Context) {
	this := p
	_ = this

	localctx = NewJump_modifier_1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, SHARCParserRULE_jump_modifier_1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1294)
		p.Match(SHARCParserDB)
	}
	p.SetState(1297)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SHARCParserCOMMA {
		{
			p.SetState(1295)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(1296)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SHARCParserCI || _la == SHARCParserLA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IJump_modifier2Context is an interface to support dynamic dispatch.
type IJump_modifier2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_modifier2Context differentiates from other interfaces.
	IsJump_modifier2Context()
}

type Jump_modifier2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_modifier2Context() *Jump_modifier2Context {
	var p = new(Jump_modifier2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_jump_modifier2
	return p
}

func (*Jump_modifier2Context) IsJump_modifier2Context() {}

func NewJump_modifier2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_modifier2Context {
	var p = new(Jump_modifier2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_jump_modifier2

	return p
}

func (s *Jump_modifier2Context) GetParser() antlr.Parser { return s.parser }

func (s *Jump_modifier2Context) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Jump_modifier2Context) DB() antlr.TerminalNode {
	return s.GetToken(SHARCParserDB, 0)
}

func (s *Jump_modifier2Context) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Jump_modifier2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_modifier2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jump_modifier2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterJump_modifier2(s)
	}
}

func (s *Jump_modifier2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitJump_modifier2(s)
	}
}

func (p *SHARCParser) Jump_modifier2() (localctx IJump_modifier2Context) {
	this := p
	_ = this

	localctx = NewJump_modifier2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, SHARCParserRULE_jump_modifier2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1299)
		p.Match(SHARCParserLPARENTHESE)
	}
	{
		p.SetState(1300)
		p.Match(SHARCParserDB)
	}
	{
		p.SetState(1301)
		p.Match(SHARCParserRPARENTHESE)
	}

	return localctx
}

// IJump_modifier3Context is an interface to support dynamic dispatch.
type IJump_modifier3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_modifier3Context differentiates from other interfaces.
	IsJump_modifier3Context()
}

type Jump_modifier3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_modifier3Context() *Jump_modifier3Context {
	var p = new(Jump_modifier3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_jump_modifier3
	return p
}

func (*Jump_modifier3Context) IsJump_modifier3Context() {}

func NewJump_modifier3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_modifier3Context {
	var p = new(Jump_modifier3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_jump_modifier3

	return p
}

func (s *Jump_modifier3Context) GetParser() antlr.Parser { return s.parser }

func (s *Jump_modifier3Context) Jump_modifier3_() IJump_modifier3_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_modifier3_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_modifier3_Context)
}

func (s *Jump_modifier3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_modifier3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jump_modifier3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterJump_modifier3(s)
	}
}

func (s *Jump_modifier3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitJump_modifier3(s)
	}
}

func (p *SHARCParser) Jump_modifier3() (localctx IJump_modifier3Context) {
	this := p
	_ = this

	localctx = NewJump_modifier3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, SHARCParserRULE_jump_modifier3)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1303)
		p.Jump_modifier3_()
	}

	return localctx
}

// IJump_modifier3_Context is an interface to support dynamic dispatch.
type IJump_modifier3_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_modifier3_Context differentiates from other interfaces.
	IsJump_modifier3_Context()
}

type Jump_modifier3_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_modifier3_Context() *Jump_modifier3_Context {
	var p = new(Jump_modifier3_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_jump_modifier3_
	return p
}

func (*Jump_modifier3_Context) IsJump_modifier3_Context() {}

func NewJump_modifier3_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_modifier3_Context {
	var p = new(Jump_modifier3_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_jump_modifier3_

	return p
}

func (s *Jump_modifier3_Context) GetParser() antlr.Parser { return s.parser }

func (s *Jump_modifier3_Context) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Jump_modifier3_Context) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Jump_modifier3_Context) Jump_modifier3_1() IJump_modifier3_1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_modifier3_1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_modifier3_1Context)
}

func (s *Jump_modifier3_Context) LR() antlr.TerminalNode {
	return s.GetToken(SHARCParserLR, 0)
}

func (s *Jump_modifier3_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_modifier3_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jump_modifier3_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterJump_modifier3_(s)
	}
}

func (s *Jump_modifier3_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitJump_modifier3_(s)
	}
}

func (p *SHARCParser) Jump_modifier3_() (localctx IJump_modifier3_Context) {
	this := p
	_ = this

	localctx = NewJump_modifier3_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, SHARCParserRULE_jump_modifier3_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1305)
		p.Match(SHARCParserLPARENTHESE)
	}
	p.SetState(1308)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDB:
		{
			p.SetState(1306)
			p.Jump_modifier3_1()
		}

	case SHARCParserLR:
		{
			p.SetState(1307)
			p.Match(SHARCParserLR)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1310)
		p.Match(SHARCParserRPARENTHESE)
	}

	return localctx
}

// IJump_modifier3_1Context is an interface to support dynamic dispatch.
type IJump_modifier3_1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_modifier3_1Context differentiates from other interfaces.
	IsJump_modifier3_1Context()
}

type Jump_modifier3_1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_modifier3_1Context() *Jump_modifier3_1Context {
	var p = new(Jump_modifier3_1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_jump_modifier3_1
	return p
}

func (*Jump_modifier3_1Context) IsJump_modifier3_1Context() {}

func NewJump_modifier3_1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_modifier3_1Context {
	var p = new(Jump_modifier3_1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_jump_modifier3_1

	return p
}

func (s *Jump_modifier3_1Context) GetParser() antlr.Parser { return s.parser }

func (s *Jump_modifier3_1Context) DB() antlr.TerminalNode {
	return s.GetToken(SHARCParserDB, 0)
}

func (s *Jump_modifier3_1Context) COMMA() antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, 0)
}

func (s *Jump_modifier3_1Context) LR() antlr.TerminalNode {
	return s.GetToken(SHARCParserLR, 0)
}

func (s *Jump_modifier3_1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_modifier3_1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jump_modifier3_1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterJump_modifier3_1(s)
	}
}

func (s *Jump_modifier3_1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitJump_modifier3_1(s)
	}
}

func (p *SHARCParser) Jump_modifier3_1() (localctx IJump_modifier3_1Context) {
	this := p
	_ = this

	localctx = NewJump_modifier3_1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, SHARCParserRULE_jump_modifier3_1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1312)
		p.Match(SHARCParserDB)
	}
	p.SetState(1315)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SHARCParserCOMMA {
		{
			p.SetState(1313)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(1314)
			p.Match(SHARCParserLR)
		}

	}

	return localctx
}

// IImm_mov_expContext is an interface to support dynamic dispatch.
type IImm_mov_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImm_mov_expContext differentiates from other interfaces.
	IsImm_mov_expContext()
}

type Imm_mov_expContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImm_mov_expContext() *Imm_mov_expContext {
	var p = new(Imm_mov_expContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_imm_mov_exp
	return p
}

func (*Imm_mov_expContext) IsImm_mov_expContext() {}

func NewImm_mov_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imm_mov_expContext {
	var p = new(Imm_mov_expContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_imm_mov_exp

	return p
}

func (s *Imm_mov_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Imm_mov_expContext) Imm_mov_14a() IImm_mov_14aContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImm_mov_14aContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImm_mov_14aContext)
}

func (s *Imm_mov_expContext) Imm_mov_14b() IImm_mov_14bContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImm_mov_14bContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImm_mov_14bContext)
}

func (s *Imm_mov_expContext) Imm_mov_16() IImm_mov_16Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImm_mov_16Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImm_mov_16Context)
}

func (s *Imm_mov_expContext) Imm_mov_17() IImm_mov_17Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImm_mov_17Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImm_mov_17Context)
}

func (s *Imm_mov_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imm_mov_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imm_mov_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterImm_mov_exp(s)
	}
}

func (s *Imm_mov_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitImm_mov_exp(s)
	}
}

func (p *SHARCParser) Imm_mov_exp() (localctx IImm_mov_expContext) {
	this := p
	_ = this

	localctx = NewImm_mov_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, SHARCParserRULE_imm_mov_exp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1321)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1317)
			p.Imm_mov_14a()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1318)
			p.Imm_mov_14b()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1319)
			p.Imm_mov_16()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1320)
			p.Imm_mov_17()
		}

	}

	return localctx
}

// IImm_mov_14aContext is an interface to support dynamic dispatch.
type IImm_mov_14aContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImm_mov_14aContext differentiates from other interfaces.
	IsImm_mov_14aContext()
}

type Imm_mov_14aContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImm_mov_14aContext() *Imm_mov_14aContext {
	var p = new(Imm_mov_14aContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_imm_mov_14a
	return p
}

func (*Imm_mov_14aContext) IsImm_mov_14aContext() {}

func NewImm_mov_14aContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imm_mov_14aContext {
	var p = new(Imm_mov_14aContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_imm_mov_14a

	return p
}

func (s *Imm_mov_14aContext) GetParser() antlr.Parser { return s.parser }

func (s *Imm_mov_14aContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Imm_mov_14aContext) U_reg() IU_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IU_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IU_regContext)
}

func (s *Imm_mov_14aContext) Mem_addr_dm_int() IMem_addr_dm_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_dm_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_dm_intContext)
}

func (s *Imm_mov_14aContext) Mem_addr_pm_int() IMem_addr_pm_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_pm_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_pm_intContext)
}

func (s *Imm_mov_14aContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imm_mov_14aContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imm_mov_14aContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterImm_mov_14a(s)
	}
}

func (s *Imm_mov_14aContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitImm_mov_14a(s)
	}
}

func (p *SHARCParser) Imm_mov_14a() (localctx IImm_mov_14aContext) {
	this := p
	_ = this

	localctx = NewImm_mov_14aContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, SHARCParserRULE_imm_mov_14a)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1325)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDM:
		{
			p.SetState(1323)
			p.Mem_addr_dm_int()
		}

	case SHARCParserPM:
		{
			p.SetState(1324)
			p.Mem_addr_pm_int()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1327)
		p.Match(SHARCParserEQU)
	}
	{
		p.SetState(1328)
		p.U_reg()
	}

	return localctx
}

// IImm_mov_15aContext is an interface to support dynamic dispatch.
type IImm_mov_15aContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImm_mov_15aContext differentiates from other interfaces.
	IsImm_mov_15aContext()
}

type Imm_mov_15aContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImm_mov_15aContext() *Imm_mov_15aContext {
	var p = new(Imm_mov_15aContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_imm_mov_15a
	return p
}

func (*Imm_mov_15aContext) IsImm_mov_15aContext() {}

func NewImm_mov_15aContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imm_mov_15aContext {
	var p = new(Imm_mov_15aContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_imm_mov_15a

	return p
}

func (s *Imm_mov_15aContext) GetParser() antlr.Parser { return s.parser }

func (s *Imm_mov_15aContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Imm_mov_15aContext) U_reg() IU_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IU_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IU_regContext)
}

func (s *Imm_mov_15aContext) Mem_addr_dm_int_ia() IMem_addr_dm_int_iaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_dm_int_iaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_dm_int_iaContext)
}

func (s *Imm_mov_15aContext) Mem_addr_pm_int_ic() IMem_addr_pm_int_icContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_pm_int_icContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_pm_int_icContext)
}

func (s *Imm_mov_15aContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imm_mov_15aContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imm_mov_15aContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterImm_mov_15a(s)
	}
}

func (s *Imm_mov_15aContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitImm_mov_15a(s)
	}
}

func (p *SHARCParser) Imm_mov_15a() (localctx IImm_mov_15aContext) {
	this := p
	_ = this

	localctx = NewImm_mov_15aContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, SHARCParserRULE_imm_mov_15a)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1332)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDM:
		{
			p.SetState(1330)
			p.Mem_addr_dm_int_ia()
		}

	case SHARCParserPM:
		{
			p.SetState(1331)
			p.Mem_addr_pm_int_ic()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1334)
		p.Match(SHARCParserEQU)
	}
	{
		p.SetState(1335)
		p.U_reg()
	}

	return localctx
}

// IImm_mov_14bContext is an interface to support dynamic dispatch.
type IImm_mov_14bContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImm_mov_14bContext differentiates from other interfaces.
	IsImm_mov_14bContext()
}

type Imm_mov_14bContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImm_mov_14bContext() *Imm_mov_14bContext {
	var p = new(Imm_mov_14bContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_imm_mov_14b
	return p
}

func (*Imm_mov_14bContext) IsImm_mov_14bContext() {}

func NewImm_mov_14bContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imm_mov_14bContext {
	var p = new(Imm_mov_14bContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_imm_mov_14b

	return p
}

func (s *Imm_mov_14bContext) GetParser() antlr.Parser { return s.parser }

func (s *Imm_mov_14bContext) U_reg() IU_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IU_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IU_regContext)
}

func (s *Imm_mov_14bContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Imm_mov_14bContext) Mem_addr_dm_int() IMem_addr_dm_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_dm_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_dm_intContext)
}

func (s *Imm_mov_14bContext) Mem_addr_pm_int() IMem_addr_pm_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_pm_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_pm_intContext)
}

func (s *Imm_mov_14bContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imm_mov_14bContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imm_mov_14bContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterImm_mov_14b(s)
	}
}

func (s *Imm_mov_14bContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitImm_mov_14b(s)
	}
}

func (p *SHARCParser) Imm_mov_14b() (localctx IImm_mov_14bContext) {
	this := p
	_ = this

	localctx = NewImm_mov_14bContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, SHARCParserRULE_imm_mov_14b)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1337)
		p.U_reg()
	}
	{
		p.SetState(1338)
		p.Match(SHARCParserEQU)
	}
	p.SetState(1341)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDM:
		{
			p.SetState(1339)
			p.Mem_addr_dm_int()
		}

	case SHARCParserPM:
		{
			p.SetState(1340)
			p.Mem_addr_pm_int()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImm_mov_15bContext is an interface to support dynamic dispatch.
type IImm_mov_15bContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImm_mov_15bContext differentiates from other interfaces.
	IsImm_mov_15bContext()
}

type Imm_mov_15bContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImm_mov_15bContext() *Imm_mov_15bContext {
	var p = new(Imm_mov_15bContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_imm_mov_15b
	return p
}

func (*Imm_mov_15bContext) IsImm_mov_15bContext() {}

func NewImm_mov_15bContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imm_mov_15bContext {
	var p = new(Imm_mov_15bContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_imm_mov_15b

	return p
}

func (s *Imm_mov_15bContext) GetParser() antlr.Parser { return s.parser }

func (s *Imm_mov_15bContext) U_reg() IU_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IU_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IU_regContext)
}

func (s *Imm_mov_15bContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Imm_mov_15bContext) Mem_addr_dm_int_ia() IMem_addr_dm_int_iaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_dm_int_iaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_dm_int_iaContext)
}

func (s *Imm_mov_15bContext) Mem_addr_pm_int_ic() IMem_addr_pm_int_icContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_pm_int_icContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_pm_int_icContext)
}

func (s *Imm_mov_15bContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imm_mov_15bContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imm_mov_15bContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterImm_mov_15b(s)
	}
}

func (s *Imm_mov_15bContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitImm_mov_15b(s)
	}
}

func (p *SHARCParser) Imm_mov_15b() (localctx IImm_mov_15bContext) {
	this := p
	_ = this

	localctx = NewImm_mov_15bContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, SHARCParserRULE_imm_mov_15b)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1343)
		p.U_reg()
	}
	{
		p.SetState(1344)
		p.Match(SHARCParserEQU)
	}
	p.SetState(1347)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDM:
		{
			p.SetState(1345)
			p.Mem_addr_dm_int_ia()
		}

	case SHARCParserPM:
		{
			p.SetState(1346)
			p.Mem_addr_pm_int_ic()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImm_mov_16Context is an interface to support dynamic dispatch.
type IImm_mov_16Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImm_mov_16Context differentiates from other interfaces.
	IsImm_mov_16Context()
}

type Imm_mov_16Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImm_mov_16Context() *Imm_mov_16Context {
	var p = new(Imm_mov_16Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_imm_mov_16
	return p
}

func (*Imm_mov_16Context) IsImm_mov_16Context() {}

func NewImm_mov_16Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imm_mov_16Context {
	var p = new(Imm_mov_16Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_imm_mov_16

	return p
}

func (s *Imm_mov_16Context) GetParser() antlr.Parser { return s.parser }

func (s *Imm_mov_16Context) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Imm_mov_16Context) Value_exp() IValue_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_expContext)
}

func (s *Imm_mov_16Context) Mem_addr_dm_ia_mb() IMem_addr_dm_ia_mbContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_dm_ia_mbContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_dm_ia_mbContext)
}

func (s *Imm_mov_16Context) Mem_addr_pm_ic_md() IMem_addr_pm_ic_mdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_pm_ic_mdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_pm_ic_mdContext)
}

func (s *Imm_mov_16Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imm_mov_16Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imm_mov_16Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterImm_mov_16(s)
	}
}

func (s *Imm_mov_16Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitImm_mov_16(s)
	}
}

func (p *SHARCParser) Imm_mov_16() (localctx IImm_mov_16Context) {
	this := p
	_ = this

	localctx = NewImm_mov_16Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, SHARCParserRULE_imm_mov_16)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1351)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDM:
		{
			p.SetState(1349)
			p.Mem_addr_dm_ia_mb()
		}

	case SHARCParserPM:
		{
			p.SetState(1350)
			p.Mem_addr_pm_ic_md()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1353)
		p.Match(SHARCParserEQU)
	}
	{
		p.SetState(1354)
		p.Value_exp()
	}

	return localctx
}

// IImm_mov_17Context is an interface to support dynamic dispatch.
type IImm_mov_17Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImm_mov_17Context differentiates from other interfaces.
	IsImm_mov_17Context()
}

type Imm_mov_17Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImm_mov_17Context() *Imm_mov_17Context {
	var p = new(Imm_mov_17Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_imm_mov_17
	return p
}

func (*Imm_mov_17Context) IsImm_mov_17Context() {}

func NewImm_mov_17Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imm_mov_17Context {
	var p = new(Imm_mov_17Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_imm_mov_17

	return p
}

func (s *Imm_mov_17Context) GetParser() antlr.Parser { return s.parser }

func (s *Imm_mov_17Context) U_reg2() IU_reg2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IU_reg2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IU_reg2Context)
}

func (s *Imm_mov_17Context) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Imm_mov_17Context) Value_exp() IValue_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_expContext)
}

func (s *Imm_mov_17Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imm_mov_17Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imm_mov_17Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterImm_mov_17(s)
	}
}

func (s *Imm_mov_17Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitImm_mov_17(s)
	}
}

func (p *SHARCParser) Imm_mov_17() (localctx IImm_mov_17Context) {
	this := p
	_ = this

	localctx = NewImm_mov_17Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, SHARCParserRULE_imm_mov_17)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1356)
		p.U_reg2()
	}
	{
		p.SetState(1357)
		p.Match(SHARCParserEQU)
	}
	{
		p.SetState(1358)
		p.Value_exp()
	}

	return localctx
}

// IU_reg2Context is an interface to support dynamic dispatch.
type IU_reg2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsU_reg2Context differentiates from other interfaces.
	IsU_reg2Context()
}

type U_reg2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyU_reg2Context() *U_reg2Context {
	var p = new(U_reg2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_u_reg2
	return p
}

func (*U_reg2Context) IsU_reg2Context() {}

func NewU_reg2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *U_reg2Context {
	var p = new(U_reg2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_u_reg2

	return p
}

func (s *U_reg2Context) GetParser() antlr.Parser { return s.parser }

func (s *U_reg2Context) D_reg() ID_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ID_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ID_regContext)
}

func (s *U_reg2Context) PC() antlr.TerminalNode {
	return s.GetToken(SHARCParserPC, 0)
}

func (s *U_reg2Context) PCSTK() antlr.TerminalNode {
	return s.GetToken(SHARCParserPCSTK, 0)
}

func (s *U_reg2Context) PCSTKP() antlr.TerminalNode {
	return s.GetToken(SHARCParserPCSTKP, 0)
}

func (s *U_reg2Context) FADDR() antlr.TerminalNode {
	return s.GetToken(SHARCParserFADDR, 0)
}

func (s *U_reg2Context) DADDR() antlr.TerminalNode {
	return s.GetToken(SHARCParserDADDR, 0)
}

func (s *U_reg2Context) LADDR() antlr.TerminalNode {
	return s.GetToken(SHARCParserLADDR, 0)
}

func (s *U_reg2Context) CURLCNTR() antlr.TerminalNode {
	return s.GetToken(SHARCParserCURLCNTR, 0)
}

func (s *U_reg2Context) Dag_reg() IDag_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDag_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDag_regContext)
}

func (s *U_reg2Context) PX1() antlr.TerminalNode {
	return s.GetToken(SHARCParserPX1, 0)
}

func (s *U_reg2Context) PX2() antlr.TerminalNode {
	return s.GetToken(SHARCParserPX2, 0)
}

func (s *U_reg2Context) PX() antlr.TerminalNode {
	return s.GetToken(SHARCParserPX, 0)
}

func (s *U_reg2Context) TPERIOD() antlr.TerminalNode {
	return s.GetToken(SHARCParserTPERIOD, 0)
}

func (s *U_reg2Context) TCOUNT() antlr.TerminalNode {
	return s.GetToken(SHARCParserTCOUNT, 0)
}

func (s *U_reg2Context) S_reg() IS_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IS_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IS_regContext)
}

func (s *U_reg2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *U_reg2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *U_reg2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterU_reg2(s)
	}
}

func (s *U_reg2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitU_reg2(s)
	}
}

func (p *SHARCParser) U_reg2() (localctx IU_reg2Context) {
	this := p
	_ = this

	localctx = NewU_reg2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, SHARCParserRULE_u_reg2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1375)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserF0, SHARCParserF1, SHARCParserF2, SHARCParserF3, SHARCParserF4, SHARCParserF5, SHARCParserF6, SHARCParserF7, SHARCParserF8, SHARCParserF9, SHARCParserF10, SHARCParserF11, SHARCParserF12, SHARCParserF13, SHARCParserF14, SHARCParserF15, SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1360)
			p.D_reg()
		}

	case SHARCParserPC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1361)
			p.Match(SHARCParserPC)
		}

	case SHARCParserPCSTK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1362)
			p.Match(SHARCParserPCSTK)
		}

	case SHARCParserPCSTKP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1363)
			p.Match(SHARCParserPCSTKP)
		}

	case SHARCParserFADDR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1364)
			p.Match(SHARCParserFADDR)
		}

	case SHARCParserDADDR:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1365)
			p.Match(SHARCParserDADDR)
		}

	case SHARCParserLADDR:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1366)
			p.Match(SHARCParserLADDR)
		}

	case SHARCParserCURLCNTR:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1367)
			p.Match(SHARCParserCURLCNTR)
		}

	case SHARCParserB0, SHARCParserB1, SHARCParserB2, SHARCParserB3, SHARCParserB4, SHARCParserB5, SHARCParserB6, SHARCParserB7, SHARCParserB8, SHARCParserB9, SHARCParserB10, SHARCParserB11, SHARCParserB12, SHARCParserB13, SHARCParserB14, SHARCParserB15, SHARCParserI0, SHARCParserI1, SHARCParserI2, SHARCParserI3, SHARCParserI4, SHARCParserI5, SHARCParserI6, SHARCParserI7, SHARCParserI8, SHARCParserI9, SHARCParserI10, SHARCParserI11, SHARCParserI12, SHARCParserI13, SHARCParserI14, SHARCParserI15, SHARCParserL0, SHARCParserL1, SHARCParserL2, SHARCParserL3, SHARCParserL4, SHARCParserL5, SHARCParserL6, SHARCParserL7, SHARCParserL8, SHARCParserL9, SHARCParserL10, SHARCParserL11, SHARCParserL12, SHARCParserL13, SHARCParserL14, SHARCParserL15, SHARCParserM0, SHARCParserM1, SHARCParserM2, SHARCParserM3, SHARCParserM4, SHARCParserM5, SHARCParserM6, SHARCParserM7, SHARCParserM8, SHARCParserM9, SHARCParserM10, SHARCParserM11, SHARCParserM12, SHARCParserM13, SHARCParserM14, SHARCParserM15:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1368)
			p.Dag_reg()
		}

	case SHARCParserPX1:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1369)
			p.Match(SHARCParserPX1)
		}

	case SHARCParserPX2:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1370)
			p.Match(SHARCParserPX2)
		}

	case SHARCParserPX:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1371)
			p.Match(SHARCParserPX)
		}

	case SHARCParserTPERIOD:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1372)
			p.Match(SHARCParserTPERIOD)
		}

	case SHARCParserTCOUNT:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1373)
			p.Match(SHARCParserTCOUNT)
		}

	case SHARCParserASTAT, SHARCParserIMASK, SHARCParserIMASKP, SHARCParserIRPTL, SHARCParserMODE1, SHARCParserMODE2, SHARCParserSTKY, SHARCParserUSTAT1, SHARCParserUSTAT2:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1374)
			p.S_reg()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMisc_expContext is an interface to support dynamic dispatch.
type IMisc_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMisc_expContext differentiates from other interfaces.
	IsMisc_expContext()
}

type Misc_expContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMisc_expContext() *Misc_expContext {
	var p = new(Misc_expContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_misc_exp
	return p
}

func (*Misc_expContext) IsMisc_expContext() {}

func NewMisc_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Misc_expContext {
	var p = new(Misc_expContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_misc_exp

	return p
}

func (s *Misc_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Misc_expContext) BIT() antlr.TerminalNode {
	return s.GetToken(SHARCParserBIT, 0)
}

func (s *Misc_expContext) S_reg() IS_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IS_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IS_regContext)
}

func (s *Misc_expContext) Value_exp() IValue_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_expContext)
}

func (s *Misc_expContext) SET() antlr.TerminalNode {
	return s.GetToken(SHARCParserSET, 0)
}

func (s *Misc_expContext) CLR() antlr.TerminalNode {
	return s.GetToken(SHARCParserCLR, 0)
}

func (s *Misc_expContext) TGL() antlr.TerminalNode {
	return s.GetToken(SHARCParserTGL, 0)
}

func (s *Misc_expContext) TST() antlr.TerminalNode {
	return s.GetToken(SHARCParserTST, 0)
}

func (s *Misc_expContext) XOR() antlr.TerminalNode {
	return s.GetToken(SHARCParserXOR, 0)
}

func (s *Misc_expContext) BITREV() antlr.TerminalNode {
	return s.GetToken(SHARCParserBITREV, 0)
}

func (s *Misc_expContext) Mem_addr_ia_int() IMem_addr_ia_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_ia_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_ia_intContext)
}

func (s *Misc_expContext) Mem_addr_ic_int() IMem_addr_ic_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_addr_ic_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_addr_ic_intContext)
}

func (s *Misc_expContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(SHARCParserMODIFY, 0)
}

func (s *Misc_expContext) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Misc_expContext) Ia() IIaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIaContext)
}

func (s *Misc_expContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserCOMMA)
}

func (s *Misc_expContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, i)
}

func (s *Misc_expContext) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Misc_expContext) Ic() IIcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIcContext)
}

func (s *Misc_expContext) AllMisc_20() []IMisc_20Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMisc_20Context)(nil)).Elem())
	var tst = make([]IMisc_20Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMisc_20Context)
		}
	}

	return tst
}

func (s *Misc_expContext) Misc_20(i int) IMisc_20Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMisc_20Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMisc_20Context)
}

func (s *Misc_expContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(SHARCParserFLUSH, 0)
}

func (s *Misc_expContext) CACHE() antlr.TerminalNode {
	return s.GetToken(SHARCParserCACHE, 0)
}

func (s *Misc_expContext) NOP() antlr.TerminalNode {
	return s.GetToken(SHARCParserNOP, 0)
}

func (s *Misc_expContext) IDLE() antlr.TerminalNode {
	return s.GetToken(SHARCParserIDLE, 0)
}

func (s *Misc_expContext) IDLE16() antlr.TerminalNode {
	return s.GetToken(SHARCParserIDLE16, 0)
}

func (s *Misc_expContext) CJUMP() antlr.TerminalNode {
	return s.GetToken(SHARCParserCJUMP, 0)
}

func (s *Misc_expContext) Jump_addr_int_or_pc() IJump_addr_int_or_pcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_addr_int_or_pcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_addr_int_or_pcContext)
}

func (s *Misc_expContext) Jump_modifier2() IJump_modifier2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_modifier2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_modifier2Context)
}

func (s *Misc_expContext) RFRAME() antlr.TerminalNode {
	return s.GetToken(SHARCParserRFRAME, 0)
}

func (s *Misc_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Misc_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Misc_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMisc_exp(s)
	}
}

func (s *Misc_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMisc_exp(s)
	}
}

func (p *SHARCParser) Misc_exp() (localctx IMisc_expContext) {
	this := p
	_ = this

	localctx = NewMisc_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, SHARCParserRULE_misc_exp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1420)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1377)
			p.Match(SHARCParserBIT)
		}
		{
			p.SetState(1378)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SHARCParserCLR || (((_la-326)&-(0x1f+1)) == 0 && ((1<<uint((_la-326)))&((1<<(SHARCParserSET-326))|(1<<(SHARCParserTGL-326))|(1<<(SHARCParserTST-326)))) != 0) || _la == SHARCParserXOR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1379)
			p.S_reg()
		}
		{
			p.SetState(1380)
			p.Value_exp()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1382)
			p.Match(SHARCParserBITREV)
		}
		p.SetState(1385)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1383)
				p.Mem_addr_ia_int()
			}

		case 2:
			{
				p.SetState(1384)
				p.Mem_addr_ic_int()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1387)
			p.Match(SHARCParserMODIFY)
		}
		{
			p.SetState(1388)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(1389)
			p.Ia()
		}
		{
			p.SetState(1390)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(1391)
			p.Value_exp()
		}
		{
			p.SetState(1392)
			p.Match(SHARCParserRPARENTHESE)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1394)
			p.Match(SHARCParserMODIFY)
		}
		{
			p.SetState(1395)
			p.Match(SHARCParserLPARENTHESE)
		}
		{
			p.SetState(1396)
			p.Ic()
		}
		{
			p.SetState(1397)
			p.Match(SHARCParserCOMMA)
		}
		{
			p.SetState(1398)
			p.Value_exp()
		}
		{
			p.SetState(1399)
			p.Match(SHARCParserRPARENTHESE)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1401)
			p.Misc_20()
		}
		p.SetState(1406)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SHARCParserCOMMA {
			{
				p.SetState(1402)
				p.Match(SHARCParserCOMMA)
			}
			{
				p.SetState(1403)
				p.Misc_20()
			}

			p.SetState(1408)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1409)
			p.Match(SHARCParserFLUSH)
		}
		{
			p.SetState(1410)
			p.Match(SHARCParserCACHE)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1411)
			p.Match(SHARCParserNOP)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1412)
			p.Match(SHARCParserIDLE)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1413)
			p.Match(SHARCParserIDLE16)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1414)
			p.Match(SHARCParserCJUMP)
		}
		{
			p.SetState(1415)
			p.Jump_addr_int_or_pc()
		}
		p.SetState(1417)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SHARCParserLPARENTHESE {
			{
				p.SetState(1416)
				p.Jump_modifier2()
			}

		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1419)
			p.Match(SHARCParserRFRAME)
		}

	}

	return localctx
}

// IMisc_20Context is an interface to support dynamic dispatch.
type IMisc_20Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMisc_20Context differentiates from other interfaces.
	IsMisc_20Context()
}

type Misc_20Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMisc_20Context() *Misc_20Context {
	var p = new(Misc_20Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_misc_20
	return p
}

func (*Misc_20Context) IsMisc_20Context() {}

func NewMisc_20Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Misc_20Context {
	var p = new(Misc_20Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_misc_20

	return p
}

func (s *Misc_20Context) GetParser() antlr.Parser { return s.parser }

func (s *Misc_20Context) PUSH() antlr.TerminalNode {
	return s.GetToken(SHARCParserPUSH, 0)
}

func (s *Misc_20Context) POP() antlr.TerminalNode {
	return s.GetToken(SHARCParserPOP, 0)
}

func (s *Misc_20Context) LOOP() antlr.TerminalNode {
	return s.GetToken(SHARCParserLOOP, 0)
}

func (s *Misc_20Context) STS() antlr.TerminalNode {
	return s.GetToken(SHARCParserSTS, 0)
}

func (s *Misc_20Context) PCSTK() antlr.TerminalNode {
	return s.GetToken(SHARCParserPCSTK, 0)
}

func (s *Misc_20Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Misc_20Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Misc_20Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMisc_20(s)
	}
}

func (s *Misc_20Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMisc_20(s)
	}
}

func (p *SHARCParser) Misc_20() (localctx IMisc_20Context) {
	this := p
	_ = this

	localctx = NewMisc_20Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, SHARCParserRULE_misc_20)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1422)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SHARCParserPOP || _la == SHARCParserPUSH) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1423)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SHARCParserLOOP || _la == SHARCParserPCSTK || _la == SHARCParserSTS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDirective_expContext is an interface to support dynamic dispatch.
type IDirective_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirective_expContext differentiates from other interfaces.
	IsDirective_expContext()
}

type Directive_expContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirective_expContext() *Directive_expContext {
	var p = new(Directive_expContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_directive_exp
	return p
}

func (*Directive_expContext) IsDirective_expContext() {}

func NewDirective_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Directive_expContext {
	var p = new(Directive_expContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_directive_exp

	return p
}

func (s *Directive_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Directive_expContext) DOT_ALGIGN() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_ALGIGN, 0)
}

func (s *Directive_expContext) INT() antlr.TerminalNode {
	return s.GetToken(SHARCParserINT, 0)
}

func (s *Directive_expContext) DOT_COMPRESS() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_COMPRESS, 0)
}

func (s *Directive_expContext) DOT_EXTERN() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_EXTERN, 0)
}

func (s *Directive_expContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserID)
}

func (s *Directive_expContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserID, i)
}

func (s *Directive_expContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserCOMMA)
}

func (s *Directive_expContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserCOMMA, i)
}

func (s *Directive_expContext) DOT_FILE() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_FILE, 0)
}

func (s *Directive_expContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(SHARCParserStringLiteral)
}

func (s *Directive_expContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(SHARCParserStringLiteral, i)
}

func (s *Directive_expContext) DOT_FILE_ATTR() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_FILE_ATTR, 0)
}

func (s *Directive_expContext) DOT_FORCECOMPRESS() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_FORCECOMPRESS, 0)
}

func (s *Directive_expContext) DOT_GLOBAL() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_GLOBAL, 0)
}

func (s *Directive_expContext) DOT_IMPORT() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_IMPORT, 0)
}

func (s *Directive_expContext) DOT_LEFTMARGIN() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_LEFTMARGIN, 0)
}

func (s *Directive_expContext) Value_exp() IValue_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_expContext)
}

func (s *Directive_expContext) DOT_LIST() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_LIST, 0)
}

func (s *Directive_expContext) DOT_LIST_DATA() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_LIST_DATA, 0)
}

func (s *Directive_expContext) DOT_LIST_DATFILE() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_LIST_DATFILE, 0)
}

func (s *Directive_expContext) DOT_LIST_DEFTAB() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_LIST_DEFTAB, 0)
}

func (s *Directive_expContext) DOT_LIST_LOCTAB() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_LIST_LOCTAB, 0)
}

func (s *Directive_expContext) DOT_LIST_WRAPDATA() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_LIST_WRAPDATA, 0)
}

func (s *Directive_expContext) DOT_NEWPAGE() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_NEWPAGE, 0)
}

func (s *Directive_expContext) DOT_NOCOMPRESS() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_NOCOMPRESS, 0)
}

func (s *Directive_expContext) DOT_NOLIST_DATA() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_NOLIST_DATA, 0)
}

func (s *Directive_expContext) DOT_NOLIST_DATFILE() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_NOLIST_DATFILE, 0)
}

func (s *Directive_expContext) DOT_NOLIST_WRAPDATA() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_NOLIST_WRAPDATA, 0)
}

func (s *Directive_expContext) DOT_PAGELENGTH() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_PAGELENGTH, 0)
}

func (s *Directive_expContext) DOT_PAGEWIDTH() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_PAGEWIDTH, 0)
}

func (s *Directive_expContext) DOT_PRECISION() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_PRECISION, 0)
}

func (s *Directive_expContext) EQU() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQU, 0)
}

func (s *Directive_expContext) DOT_ROUND_MINUS() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_ROUND_MINUS, 0)
}

func (s *Directive_expContext) DOT_ROUND_NEAREST() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_ROUND_NEAREST, 0)
}

func (s *Directive_expContext) DOT_ROUND_PLUS() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_ROUND_PLUS, 0)
}

func (s *Directive_expContext) DOT_ROUND_ZERO() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_ROUND_ZERO, 0)
}

func (s *Directive_expContext) DOT_PREVIOUS() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_PREVIOUS, 0)
}

func (s *Directive_expContext) DOT_WEAK() antlr.TerminalNode {
	return s.GetToken(SHARCParserDOT_WEAK, 0)
}

func (s *Directive_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Directive_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Directive_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterDirective_exp(s)
	}
}

func (s *Directive_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitDirective_exp(s)
	}
}

func (p *SHARCParser) Directive_exp() (localctx IDirective_expContext) {
	this := p
	_ = this

	localctx = NewDirective_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, SHARCParserRULE_directive_exp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1491)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserDOT_ALGIGN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1425)
			p.Match(SHARCParserDOT_ALGIGN)
		}
		{
			p.SetState(1426)
			p.Match(SHARCParserINT)
		}

	case SHARCParserDOT_COMPRESS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1427)
			p.Match(SHARCParserDOT_COMPRESS)
		}

	case SHARCParserDOT_EXTERN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1428)
			p.Match(SHARCParserDOT_EXTERN)
		}
		{
			p.SetState(1429)
			p.Match(SHARCParserID)
		}
		p.SetState(1434)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SHARCParserCOMMA {
			{
				p.SetState(1430)
				p.Match(SHARCParserCOMMA)
			}
			{
				p.SetState(1431)
				p.Match(SHARCParserID)
			}

			p.SetState(1436)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case SHARCParserDOT_FILE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1437)
			p.Match(SHARCParserDOT_FILE)
		}
		{
			p.SetState(1438)
			p.Match(SHARCParserStringLiteral)
		}

	case SHARCParserDOT_FILE_ATTR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1439)
			p.Match(SHARCParserDOT_FILE_ATTR)
		}
		p.SetState(1440)
		p.MatchWildcard()

	case SHARCParserDOT_FORCECOMPRESS:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1441)
			p.Match(SHARCParserDOT_FORCECOMPRESS)
		}

	case SHARCParserDOT_GLOBAL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1442)
			p.Match(SHARCParserDOT_GLOBAL)
		}
		{
			p.SetState(1443)
			p.Match(SHARCParserID)
		}
		p.SetState(1448)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SHARCParserCOMMA {
			{
				p.SetState(1444)
				p.Match(SHARCParserCOMMA)
			}
			{
				p.SetState(1445)
				p.Match(SHARCParserID)
			}

			p.SetState(1450)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case SHARCParserDOT_IMPORT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1451)
			p.Match(SHARCParserDOT_IMPORT)
		}
		{
			p.SetState(1452)
			p.Match(SHARCParserStringLiteral)
		}
		p.SetState(1457)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SHARCParserCOMMA {
			{
				p.SetState(1453)
				p.Match(SHARCParserCOMMA)
			}
			{
				p.SetState(1454)
				p.Match(SHARCParserStringLiteral)
			}

			p.SetState(1459)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case SHARCParserDOT_LEFTMARGIN:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1460)
			p.Match(SHARCParserDOT_LEFTMARGIN)
		}
		{
			p.SetState(1461)
			p.Value_exp()
		}

	case SHARCParserDOT_LIST:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1462)
			p.Match(SHARCParserDOT_LIST)
		}

	case SHARCParserDOT_LIST_DATA:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1463)
			p.Match(SHARCParserDOT_LIST_DATA)
		}

	case SHARCParserDOT_LIST_DATFILE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1464)
			p.Match(SHARCParserDOT_LIST_DATFILE)
		}

	case SHARCParserDOT_LIST_DEFTAB:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1465)
			p.Match(SHARCParserDOT_LIST_DEFTAB)
		}
		{
			p.SetState(1466)
			p.Value_exp()
		}

	case SHARCParserDOT_LIST_LOCTAB:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1467)
			p.Match(SHARCParserDOT_LIST_LOCTAB)
		}
		{
			p.SetState(1468)
			p.Value_exp()
		}

	case SHARCParserDOT_LIST_WRAPDATA:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1469)
			p.Match(SHARCParserDOT_LIST_WRAPDATA)
		}

	case SHARCParserDOT_NEWPAGE:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1470)
			p.Match(SHARCParserDOT_NEWPAGE)
		}

	case SHARCParserDOT_NOCOMPRESS:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1471)
			p.Match(SHARCParserDOT_NOCOMPRESS)
		}

	case SHARCParserDOT_NOLIST_DATA:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1472)
			p.Match(SHARCParserDOT_NOLIST_DATA)
		}

	case SHARCParserDOT_NOLIST_DATFILE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1473)
			p.Match(SHARCParserDOT_NOLIST_DATFILE)
		}

	case SHARCParserDOT_NOLIST_WRAPDATA:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1474)
			p.Match(SHARCParserDOT_NOLIST_WRAPDATA)
		}

	case SHARCParserDOT_PAGELENGTH:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1475)
			p.Match(SHARCParserDOT_PAGELENGTH)
		}
		{
			p.SetState(1476)
			p.Value_exp()
		}

	case SHARCParserDOT_PAGEWIDTH:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1477)
			p.Match(SHARCParserDOT_PAGEWIDTH)
		}
		{
			p.SetState(1478)
			p.Value_exp()
		}

	case SHARCParserDOT_PRECISION:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1479)
			p.Match(SHARCParserDOT_PRECISION)
		}

		p.SetState(1481)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SHARCParserEQU {
			{
				p.SetState(1480)
				p.Match(SHARCParserEQU)
			}

		}

		{
			p.SetState(1483)
			p.Match(SHARCParserINT)
		}

	case SHARCParserDOT_ROUND_MINUS:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1484)
			p.Match(SHARCParserDOT_ROUND_MINUS)
		}

	case SHARCParserDOT_ROUND_NEAREST:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1485)
			p.Match(SHARCParserDOT_ROUND_NEAREST)
		}

	case SHARCParserDOT_ROUND_PLUS:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1486)
			p.Match(SHARCParserDOT_ROUND_PLUS)
		}

	case SHARCParserDOT_ROUND_ZERO:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1487)
			p.Match(SHARCParserDOT_ROUND_ZERO)
		}

	case SHARCParserDOT_PREVIOUS:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1488)
			p.Match(SHARCParserDOT_PREVIOUS)
		}

	case SHARCParserDOT_WEAK:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1489)
			p.Match(SHARCParserDOT_WEAK)
		}
		{
			p.SetState(1490)
			p.Match(SHARCParserID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IB_regContext is an interface to support dynamic dispatch.
type IB_regContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsB_regContext differentiates from other interfaces.
	IsB_regContext()
}

type B_regContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyB_regContext() *B_regContext {
	var p = new(B_regContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_b_reg
	return p
}

func (*B_regContext) IsB_regContext() {}

func NewB_regContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *B_regContext {
	var p = new(B_regContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_b_reg

	return p
}

func (s *B_regContext) GetParser() antlr.Parser { return s.parser }

func (s *B_regContext) B0() antlr.TerminalNode {
	return s.GetToken(SHARCParserB0, 0)
}

func (s *B_regContext) B1() antlr.TerminalNode {
	return s.GetToken(SHARCParserB1, 0)
}

func (s *B_regContext) B2() antlr.TerminalNode {
	return s.GetToken(SHARCParserB2, 0)
}

func (s *B_regContext) B3() antlr.TerminalNode {
	return s.GetToken(SHARCParserB3, 0)
}

func (s *B_regContext) B4() antlr.TerminalNode {
	return s.GetToken(SHARCParserB4, 0)
}

func (s *B_regContext) B5() antlr.TerminalNode {
	return s.GetToken(SHARCParserB5, 0)
}

func (s *B_regContext) B6() antlr.TerminalNode {
	return s.GetToken(SHARCParserB6, 0)
}

func (s *B_regContext) B7() antlr.TerminalNode {
	return s.GetToken(SHARCParserB7, 0)
}

func (s *B_regContext) B8() antlr.TerminalNode {
	return s.GetToken(SHARCParserB8, 0)
}

func (s *B_regContext) B9() antlr.TerminalNode {
	return s.GetToken(SHARCParserB9, 0)
}

func (s *B_regContext) B10() antlr.TerminalNode {
	return s.GetToken(SHARCParserB10, 0)
}

func (s *B_regContext) B11() antlr.TerminalNode {
	return s.GetToken(SHARCParserB11, 0)
}

func (s *B_regContext) B12() antlr.TerminalNode {
	return s.GetToken(SHARCParserB12, 0)
}

func (s *B_regContext) B13() antlr.TerminalNode {
	return s.GetToken(SHARCParserB13, 0)
}

func (s *B_regContext) B14() antlr.TerminalNode {
	return s.GetToken(SHARCParserB14, 0)
}

func (s *B_regContext) B15() antlr.TerminalNode {
	return s.GetToken(SHARCParserB15, 0)
}

func (s *B_regContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *B_regContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *B_regContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterB_reg(s)
	}
}

func (s *B_regContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitB_reg(s)
	}
}

func (p *SHARCParser) B_reg() (localctx IB_regContext) {
	this := p
	_ = this

	localctx = NewB_regContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, SHARCParserRULE_b_reg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1493)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(SHARCParserB0-57))|(1<<(SHARCParserB1-57))|(1<<(SHARCParserB2-57))|(1<<(SHARCParserB3-57))|(1<<(SHARCParserB4-57))|(1<<(SHARCParserB5-57))|(1<<(SHARCParserB6-57))|(1<<(SHARCParserB7-57))|(1<<(SHARCParserB8-57))|(1<<(SHARCParserB9-57))|(1<<(SHARCParserB10-57))|(1<<(SHARCParserB11-57))|(1<<(SHARCParserB12-57))|(1<<(SHARCParserB13-57))|(1<<(SHARCParserB14-57))|(1<<(SHARCParserB15-57)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IL_regContext is an interface to support dynamic dispatch.
type IL_regContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsL_regContext differentiates from other interfaces.
	IsL_regContext()
}

type L_regContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyL_regContext() *L_regContext {
	var p = new(L_regContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_l_reg
	return p
}

func (*L_regContext) IsL_regContext() {}

func NewL_regContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *L_regContext {
	var p = new(L_regContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_l_reg

	return p
}

func (s *L_regContext) GetParser() antlr.Parser { return s.parser }

func (s *L_regContext) L0() antlr.TerminalNode {
	return s.GetToken(SHARCParserL0, 0)
}

func (s *L_regContext) L1() antlr.TerminalNode {
	return s.GetToken(SHARCParserL1, 0)
}

func (s *L_regContext) L2() antlr.TerminalNode {
	return s.GetToken(SHARCParserL2, 0)
}

func (s *L_regContext) L3() antlr.TerminalNode {
	return s.GetToken(SHARCParserL3, 0)
}

func (s *L_regContext) L4() antlr.TerminalNode {
	return s.GetToken(SHARCParserL4, 0)
}

func (s *L_regContext) L5() antlr.TerminalNode {
	return s.GetToken(SHARCParserL5, 0)
}

func (s *L_regContext) L6() antlr.TerminalNode {
	return s.GetToken(SHARCParserL6, 0)
}

func (s *L_regContext) L7() antlr.TerminalNode {
	return s.GetToken(SHARCParserL7, 0)
}

func (s *L_regContext) L8() antlr.TerminalNode {
	return s.GetToken(SHARCParserL8, 0)
}

func (s *L_regContext) L9() antlr.TerminalNode {
	return s.GetToken(SHARCParserL9, 0)
}

func (s *L_regContext) L10() antlr.TerminalNode {
	return s.GetToken(SHARCParserL10, 0)
}

func (s *L_regContext) L11() antlr.TerminalNode {
	return s.GetToken(SHARCParserL11, 0)
}

func (s *L_regContext) L12() antlr.TerminalNode {
	return s.GetToken(SHARCParserL12, 0)
}

func (s *L_regContext) L13() antlr.TerminalNode {
	return s.GetToken(SHARCParserL13, 0)
}

func (s *L_regContext) L14() antlr.TerminalNode {
	return s.GetToken(SHARCParserL14, 0)
}

func (s *L_regContext) L15() antlr.TerminalNode {
	return s.GetToken(SHARCParserL15, 0)
}

func (s *L_regContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *L_regContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *L_regContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterL_reg(s)
	}
}

func (s *L_regContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitL_reg(s)
	}
}

func (p *SHARCParser) L_reg() (localctx IL_regContext) {
	this := p
	_ = this

	localctx = NewL_regContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, SHARCParserRULE_l_reg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1495)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-190)&-(0x1f+1)) == 0 && ((1<<uint((_la-190)))&((1<<(SHARCParserL0-190))|(1<<(SHARCParserL1-190))|(1<<(SHARCParserL2-190))|(1<<(SHARCParserL3-190))|(1<<(SHARCParserL4-190))|(1<<(SHARCParserL5-190))|(1<<(SHARCParserL6-190))|(1<<(SHARCParserL7-190))|(1<<(SHARCParserL8-190))|(1<<(SHARCParserL9-190))|(1<<(SHARCParserL10-190))|(1<<(SHARCParserL11-190))|(1<<(SHARCParserL12-190))|(1<<(SHARCParserL13-190))|(1<<(SHARCParserL14-190))|(1<<(SHARCParserL15-190)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IR_regContext is an interface to support dynamic dispatch.
type IR_regContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsR_regContext differentiates from other interfaces.
	IsR_regContext()
}

type R_regContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyR_regContext() *R_regContext {
	var p = new(R_regContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_r_reg
	return p
}

func (*R_regContext) IsR_regContext() {}

func NewR_regContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *R_regContext {
	var p = new(R_regContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_r_reg

	return p
}

func (s *R_regContext) GetParser() antlr.Parser { return s.parser }

func (s *R_regContext) R0() antlr.TerminalNode {
	return s.GetToken(SHARCParserR0, 0)
}

func (s *R_regContext) R1() antlr.TerminalNode {
	return s.GetToken(SHARCParserR1, 0)
}

func (s *R_regContext) R2() antlr.TerminalNode {
	return s.GetToken(SHARCParserR2, 0)
}

func (s *R_regContext) R3() antlr.TerminalNode {
	return s.GetToken(SHARCParserR3, 0)
}

func (s *R_regContext) R4() antlr.TerminalNode {
	return s.GetToken(SHARCParserR4, 0)
}

func (s *R_regContext) R5() antlr.TerminalNode {
	return s.GetToken(SHARCParserR5, 0)
}

func (s *R_regContext) R6() antlr.TerminalNode {
	return s.GetToken(SHARCParserR6, 0)
}

func (s *R_regContext) R7() antlr.TerminalNode {
	return s.GetToken(SHARCParserR7, 0)
}

func (s *R_regContext) R8() antlr.TerminalNode {
	return s.GetToken(SHARCParserR8, 0)
}

func (s *R_regContext) R9() antlr.TerminalNode {
	return s.GetToken(SHARCParserR9, 0)
}

func (s *R_regContext) R10() antlr.TerminalNode {
	return s.GetToken(SHARCParserR10, 0)
}

func (s *R_regContext) R11() antlr.TerminalNode {
	return s.GetToken(SHARCParserR11, 0)
}

func (s *R_regContext) R12() antlr.TerminalNode {
	return s.GetToken(SHARCParserR12, 0)
}

func (s *R_regContext) R13() antlr.TerminalNode {
	return s.GetToken(SHARCParserR13, 0)
}

func (s *R_regContext) R14() antlr.TerminalNode {
	return s.GetToken(SHARCParserR14, 0)
}

func (s *R_regContext) R15() antlr.TerminalNode {
	return s.GetToken(SHARCParserR15, 0)
}

func (s *R_regContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *R_regContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *R_regContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterR_reg(s)
	}
}

func (s *R_regContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitR_reg(s)
	}
}

func (p *SHARCParser) R_reg() (localctx IR_regContext) {
	this := p
	_ = this

	localctx = NewR_regContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, SHARCParserRULE_r_reg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1497)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-297)&-(0x1f+1)) == 0 && ((1<<uint((_la-297)))&((1<<(SHARCParserR0-297))|(1<<(SHARCParserR1-297))|(1<<(SHARCParserR2-297))|(1<<(SHARCParserR3-297))|(1<<(SHARCParserR4-297))|(1<<(SHARCParserR5-297))|(1<<(SHARCParserR6-297))|(1<<(SHARCParserR7-297))|(1<<(SHARCParserR8-297))|(1<<(SHARCParserR9-297))|(1<<(SHARCParserR10-297))|(1<<(SHARCParserR11-297))|(1<<(SHARCParserR12-297))|(1<<(SHARCParserR13-297))|(1<<(SHARCParserR14-297))|(1<<(SHARCParserR15-297)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IF_regContext is an interface to support dynamic dispatch.
type IF_regContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsF_regContext differentiates from other interfaces.
	IsF_regContext()
}

type F_regContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyF_regContext() *F_regContext {
	var p = new(F_regContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_f_reg
	return p
}

func (*F_regContext) IsF_regContext() {}

func NewF_regContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *F_regContext {
	var p = new(F_regContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_f_reg

	return p
}

func (s *F_regContext) GetParser() antlr.Parser { return s.parser }

func (s *F_regContext) F0() antlr.TerminalNode {
	return s.GetToken(SHARCParserF0, 0)
}

func (s *F_regContext) F1() antlr.TerminalNode {
	return s.GetToken(SHARCParserF1, 0)
}

func (s *F_regContext) F2() antlr.TerminalNode {
	return s.GetToken(SHARCParserF2, 0)
}

func (s *F_regContext) F3() antlr.TerminalNode {
	return s.GetToken(SHARCParserF3, 0)
}

func (s *F_regContext) F4() antlr.TerminalNode {
	return s.GetToken(SHARCParserF4, 0)
}

func (s *F_regContext) F5() antlr.TerminalNode {
	return s.GetToken(SHARCParserF5, 0)
}

func (s *F_regContext) F6() antlr.TerminalNode {
	return s.GetToken(SHARCParserF6, 0)
}

func (s *F_regContext) F7() antlr.TerminalNode {
	return s.GetToken(SHARCParserF7, 0)
}

func (s *F_regContext) F8() antlr.TerminalNode {
	return s.GetToken(SHARCParserF8, 0)
}

func (s *F_regContext) F9() antlr.TerminalNode {
	return s.GetToken(SHARCParserF9, 0)
}

func (s *F_regContext) F10() antlr.TerminalNode {
	return s.GetToken(SHARCParserF10, 0)
}

func (s *F_regContext) F11() antlr.TerminalNode {
	return s.GetToken(SHARCParserF11, 0)
}

func (s *F_regContext) F12() antlr.TerminalNode {
	return s.GetToken(SHARCParserF12, 0)
}

func (s *F_regContext) F13() antlr.TerminalNode {
	return s.GetToken(SHARCParserF13, 0)
}

func (s *F_regContext) F14() antlr.TerminalNode {
	return s.GetToken(SHARCParserF14, 0)
}

func (s *F_regContext) F15() antlr.TerminalNode {
	return s.GetToken(SHARCParserF15, 0)
}

func (s *F_regContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *F_regContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *F_regContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterF_reg(s)
	}
}

func (s *F_regContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitF_reg(s)
	}
}

func (p *SHARCParser) F_reg() (localctx IF_regContext) {
	this := p
	_ = this

	localctx = NewF_regContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, SHARCParserRULE_f_reg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1499)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-126)&-(0x1f+1)) == 0 && ((1<<uint((_la-126)))&((1<<(SHARCParserF0-126))|(1<<(SHARCParserF1-126))|(1<<(SHARCParserF2-126))|(1<<(SHARCParserF3-126))|(1<<(SHARCParserF4-126))|(1<<(SHARCParserF5-126))|(1<<(SHARCParserF6-126))|(1<<(SHARCParserF7-126))|(1<<(SHARCParserF8-126))|(1<<(SHARCParserF9-126))|(1<<(SHARCParserF10-126))|(1<<(SHARCParserF11-126))|(1<<(SHARCParserF12-126))|(1<<(SHARCParserF13-126))|(1<<(SHARCParserF14-126))|(1<<(SHARCParserF15-126)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IS_regContext is an interface to support dynamic dispatch.
type IS_regContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsS_regContext differentiates from other interfaces.
	IsS_regContext()
}

type S_regContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyS_regContext() *S_regContext {
	var p = new(S_regContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_s_reg
	return p
}

func (*S_regContext) IsS_regContext() {}

func NewS_regContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *S_regContext {
	var p = new(S_regContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_s_reg

	return p
}

func (s *S_regContext) GetParser() antlr.Parser { return s.parser }

func (s *S_regContext) MODE1() antlr.TerminalNode {
	return s.GetToken(SHARCParserMODE1, 0)
}

func (s *S_regContext) MODE2() antlr.TerminalNode {
	return s.GetToken(SHARCParserMODE2, 0)
}

func (s *S_regContext) IRPTL() antlr.TerminalNode {
	return s.GetToken(SHARCParserIRPTL, 0)
}

func (s *S_regContext) IMASK() antlr.TerminalNode {
	return s.GetToken(SHARCParserIMASK, 0)
}

func (s *S_regContext) IMASKP() antlr.TerminalNode {
	return s.GetToken(SHARCParserIMASKP, 0)
}

func (s *S_regContext) ASTAT() antlr.TerminalNode {
	return s.GetToken(SHARCParserASTAT, 0)
}

func (s *S_regContext) STKY() antlr.TerminalNode {
	return s.GetToken(SHARCParserSTKY, 0)
}

func (s *S_regContext) USTAT1() antlr.TerminalNode {
	return s.GetToken(SHARCParserUSTAT1, 0)
}

func (s *S_regContext) USTAT2() antlr.TerminalNode {
	return s.GetToken(SHARCParserUSTAT2, 0)
}

func (s *S_regContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *S_regContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *S_regContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterS_reg(s)
	}
}

func (s *S_regContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitS_reg(s)
	}
}

func (p *SHARCParser) S_reg() (localctx IS_regContext) {
	this := p
	_ = this

	localctx = NewS_regContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, SHARCParserRULE_s_reg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1501)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SHARCParserASTAT || (((_la-185)&-(0x1f+1)) == 0 && ((1<<uint((_la-185)))&((1<<(SHARCParserIMASK-185))|(1<<(SHARCParserIMASKP-185))|(1<<(SHARCParserIRPTL-185)))) != 0) || _la == SHARCParserMODE1 || _la == SHARCParserMODE2 || (((_la-340)&-(0x1f+1)) == 0 && ((1<<uint((_la-340)))&((1<<(SHARCParserSTKY-340))|(1<<(SHARCParserUSTAT1-340))|(1<<(SHARCParserUSTAT2-340)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIaContext is an interface to support dynamic dispatch.
type IIaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIaContext differentiates from other interfaces.
	IsIaContext()
}

type IaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIaContext() *IaContext {
	var p = new(IaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_ia
	return p
}

func (*IaContext) IsIaContext() {}

func NewIaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IaContext {
	var p = new(IaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_ia

	return p
}

func (s *IaContext) GetParser() antlr.Parser { return s.parser }

func (s *IaContext) I0() antlr.TerminalNode {
	return s.GetToken(SHARCParserI0, 0)
}

func (s *IaContext) I1() antlr.TerminalNode {
	return s.GetToken(SHARCParserI1, 0)
}

func (s *IaContext) I2() antlr.TerminalNode {
	return s.GetToken(SHARCParserI2, 0)
}

func (s *IaContext) I3() antlr.TerminalNode {
	return s.GetToken(SHARCParserI3, 0)
}

func (s *IaContext) I4() antlr.TerminalNode {
	return s.GetToken(SHARCParserI4, 0)
}

func (s *IaContext) I5() antlr.TerminalNode {
	return s.GetToken(SHARCParserI5, 0)
}

func (s *IaContext) I6() antlr.TerminalNode {
	return s.GetToken(SHARCParserI6, 0)
}

func (s *IaContext) I7() antlr.TerminalNode {
	return s.GetToken(SHARCParserI7, 0)
}

func (s *IaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterIa(s)
	}
}

func (s *IaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitIa(s)
	}
}

func (p *SHARCParser) Ia() (localctx IIaContext) {
	this := p
	_ = this

	localctx = NewIaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, SHARCParserRULE_ia)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1503)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(SHARCParserI0-164))|(1<<(SHARCParserI1-164))|(1<<(SHARCParserI2-164))|(1<<(SHARCParserI3-164))|(1<<(SHARCParserI4-164))|(1<<(SHARCParserI5-164))|(1<<(SHARCParserI6-164))|(1<<(SHARCParserI7-164)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMbContext is an interface to support dynamic dispatch.
type IMbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMbContext differentiates from other interfaces.
	IsMbContext()
}

type MbContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMbContext() *MbContext {
	var p = new(MbContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mb
	return p
}

func (*MbContext) IsMbContext() {}

func NewMbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MbContext {
	var p = new(MbContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mb

	return p
}

func (s *MbContext) GetParser() antlr.Parser { return s.parser }

func (s *MbContext) M0() antlr.TerminalNode {
	return s.GetToken(SHARCParserM0, 0)
}

func (s *MbContext) M1() antlr.TerminalNode {
	return s.GetToken(SHARCParserM1, 0)
}

func (s *MbContext) M2() antlr.TerminalNode {
	return s.GetToken(SHARCParserM2, 0)
}

func (s *MbContext) M3() antlr.TerminalNode {
	return s.GetToken(SHARCParserM3, 0)
}

func (s *MbContext) M4() antlr.TerminalNode {
	return s.GetToken(SHARCParserM4, 0)
}

func (s *MbContext) M5() antlr.TerminalNode {
	return s.GetToken(SHARCParserM5, 0)
}

func (s *MbContext) M6() antlr.TerminalNode {
	return s.GetToken(SHARCParserM6, 0)
}

func (s *MbContext) M7() antlr.TerminalNode {
	return s.GetToken(SHARCParserM7, 0)
}

func (s *MbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMb(s)
	}
}

func (s *MbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMb(s)
	}
}

func (p *SHARCParser) Mb() (localctx IMbContext) {
	this := p
	_ = this

	localctx = NewMbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, SHARCParserRULE_mb)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1505)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-223)&-(0x1f+1)) == 0 && ((1<<uint((_la-223)))&((1<<(SHARCParserM0-223))|(1<<(SHARCParserM1-223))|(1<<(SHARCParserM2-223))|(1<<(SHARCParserM3-223))|(1<<(SHARCParserM4-223))|(1<<(SHARCParserM5-223))|(1<<(SHARCParserM6-223))|(1<<(SHARCParserM7-223)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIcContext is an interface to support dynamic dispatch.
type IIcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIcContext differentiates from other interfaces.
	IsIcContext()
}

type IcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIcContext() *IcContext {
	var p = new(IcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_ic
	return p
}

func (*IcContext) IsIcContext() {}

func NewIcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IcContext {
	var p = new(IcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_ic

	return p
}

func (s *IcContext) GetParser() antlr.Parser { return s.parser }

func (s *IcContext) I8() antlr.TerminalNode {
	return s.GetToken(SHARCParserI8, 0)
}

func (s *IcContext) I9() antlr.TerminalNode {
	return s.GetToken(SHARCParserI9, 0)
}

func (s *IcContext) I10() antlr.TerminalNode {
	return s.GetToken(SHARCParserI10, 0)
}

func (s *IcContext) I11() antlr.TerminalNode {
	return s.GetToken(SHARCParserI11, 0)
}

func (s *IcContext) I12() antlr.TerminalNode {
	return s.GetToken(SHARCParserI12, 0)
}

func (s *IcContext) I13() antlr.TerminalNode {
	return s.GetToken(SHARCParserI13, 0)
}

func (s *IcContext) I14() antlr.TerminalNode {
	return s.GetToken(SHARCParserI14, 0)
}

func (s *IcContext) I15() antlr.TerminalNode {
	return s.GetToken(SHARCParserI15, 0)
}

func (s *IcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterIc(s)
	}
}

func (s *IcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitIc(s)
	}
}

func (p *SHARCParser) Ic() (localctx IIcContext) {
	this := p
	_ = this

	localctx = NewIcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, SHARCParserRULE_ic)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1507)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-172)&-(0x1f+1)) == 0 && ((1<<uint((_la-172)))&((1<<(SHARCParserI8-172))|(1<<(SHARCParserI9-172))|(1<<(SHARCParserI10-172))|(1<<(SHARCParserI11-172))|(1<<(SHARCParserI12-172))|(1<<(SHARCParserI13-172))|(1<<(SHARCParserI14-172))|(1<<(SHARCParserI15-172)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMdContext is an interface to support dynamic dispatch.
type IMdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMdContext differentiates from other interfaces.
	IsMdContext()
}

type MdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMdContext() *MdContext {
	var p = new(MdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_md
	return p
}

func (*MdContext) IsMdContext() {}

func NewMdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MdContext {
	var p = new(MdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_md

	return p
}

func (s *MdContext) GetParser() antlr.Parser { return s.parser }

func (s *MdContext) M8() antlr.TerminalNode {
	return s.GetToken(SHARCParserM8, 0)
}

func (s *MdContext) M9() antlr.TerminalNode {
	return s.GetToken(SHARCParserM9, 0)
}

func (s *MdContext) M10() antlr.TerminalNode {
	return s.GetToken(SHARCParserM10, 0)
}

func (s *MdContext) M11() antlr.TerminalNode {
	return s.GetToken(SHARCParserM11, 0)
}

func (s *MdContext) M12() antlr.TerminalNode {
	return s.GetToken(SHARCParserM12, 0)
}

func (s *MdContext) M13() antlr.TerminalNode {
	return s.GetToken(SHARCParserM13, 0)
}

func (s *MdContext) M14() antlr.TerminalNode {
	return s.GetToken(SHARCParserM14, 0)
}

func (s *MdContext) M15() antlr.TerminalNode {
	return s.GetToken(SHARCParserM15, 0)
}

func (s *MdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMd(s)
	}
}

func (s *MdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMd(s)
	}
}

func (p *SHARCParser) Md() (localctx IMdContext) {
	this := p
	_ = this

	localctx = NewMdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, SHARCParserRULE_md)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1509)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-231)&-(0x1f+1)) == 0 && ((1<<uint((_la-231)))&((1<<(SHARCParserM8-231))|(1<<(SHARCParserM9-231))|(1<<(SHARCParserM10-231))|(1<<(SHARCParserM11-231))|(1<<(SHARCParserM12-231))|(1<<(SHARCParserM13-231))|(1<<(SHARCParserM14-231))|(1<<(SHARCParserM15-231)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// II_regContext is an interface to support dynamic dispatch.
type II_regContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsI_regContext differentiates from other interfaces.
	IsI_regContext()
}

type I_regContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyI_regContext() *I_regContext {
	var p = new(I_regContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_i_reg
	return p
}

func (*I_regContext) IsI_regContext() {}

func NewI_regContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *I_regContext {
	var p = new(I_regContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_i_reg

	return p
}

func (s *I_regContext) GetParser() antlr.Parser { return s.parser }

func (s *I_regContext) Ia() IIaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIaContext)
}

func (s *I_regContext) Ic() IIcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIcContext)
}

func (s *I_regContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *I_regContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *I_regContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterI_reg(s)
	}
}

func (s *I_regContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitI_reg(s)
	}
}

func (p *SHARCParser) I_reg() (localctx II_regContext) {
	this := p
	_ = this

	localctx = NewI_regContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, SHARCParserRULE_i_reg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1513)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserI0, SHARCParserI1, SHARCParserI2, SHARCParserI3, SHARCParserI4, SHARCParserI5, SHARCParserI6, SHARCParserI7:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1511)
			p.Ia()
		}

	case SHARCParserI8, SHARCParserI9, SHARCParserI10, SHARCParserI11, SHARCParserI12, SHARCParserI13, SHARCParserI14, SHARCParserI15:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1512)
			p.Ic()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IM_regContext is an interface to support dynamic dispatch.
type IM_regContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsM_regContext differentiates from other interfaces.
	IsM_regContext()
}

type M_regContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyM_regContext() *M_regContext {
	var p = new(M_regContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_m_reg
	return p
}

func (*M_regContext) IsM_regContext() {}

func NewM_regContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *M_regContext {
	var p = new(M_regContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_m_reg

	return p
}

func (s *M_regContext) GetParser() antlr.Parser { return s.parser }

func (s *M_regContext) Mb() IMbContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMbContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMbContext)
}

func (s *M_regContext) Md() IMdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMdContext)
}

func (s *M_regContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *M_regContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *M_regContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterM_reg(s)
	}
}

func (s *M_regContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitM_reg(s)
	}
}

func (p *SHARCParser) M_reg() (localctx IM_regContext) {
	this := p
	_ = this

	localctx = NewM_regContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, SHARCParserRULE_m_reg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1517)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserM0, SHARCParserM1, SHARCParserM2, SHARCParserM3, SHARCParserM4, SHARCParserM5, SHARCParserM6, SHARCParserM7:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1515)
			p.Mb()
		}

	case SHARCParserM8, SHARCParserM9, SHARCParserM10, SHARCParserM11, SHARCParserM12, SHARCParserM13, SHARCParserM14, SHARCParserM15:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1516)
			p.Md()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDag_regContext is an interface to support dynamic dispatch.
type IDag_regContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDag_regContext differentiates from other interfaces.
	IsDag_regContext()
}

type Dag_regContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDag_regContext() *Dag_regContext {
	var p = new(Dag_regContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_dag_reg
	return p
}

func (*Dag_regContext) IsDag_regContext() {}

func NewDag_regContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dag_regContext {
	var p = new(Dag_regContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_dag_reg

	return p
}

func (s *Dag_regContext) GetParser() antlr.Parser { return s.parser }

func (s *Dag_regContext) I_reg() II_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*II_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(II_regContext)
}

func (s *Dag_regContext) M_reg() IM_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IM_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IM_regContext)
}

func (s *Dag_regContext) B_reg() IB_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IB_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IB_regContext)
}

func (s *Dag_regContext) L_reg() IL_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IL_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IL_regContext)
}

func (s *Dag_regContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dag_regContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dag_regContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterDag_reg(s)
	}
}

func (s *Dag_regContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitDag_reg(s)
	}
}

func (p *SHARCParser) Dag_reg() (localctx IDag_regContext) {
	this := p
	_ = this

	localctx = NewDag_regContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, SHARCParserRULE_dag_reg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1523)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserI0, SHARCParserI1, SHARCParserI2, SHARCParserI3, SHARCParserI4, SHARCParserI5, SHARCParserI6, SHARCParserI7, SHARCParserI8, SHARCParserI9, SHARCParserI10, SHARCParserI11, SHARCParserI12, SHARCParserI13, SHARCParserI14, SHARCParserI15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1519)
			p.I_reg()
		}

	case SHARCParserM0, SHARCParserM1, SHARCParserM2, SHARCParserM3, SHARCParserM4, SHARCParserM5, SHARCParserM6, SHARCParserM7, SHARCParserM8, SHARCParserM9, SHARCParserM10, SHARCParserM11, SHARCParserM12, SHARCParserM13, SHARCParserM14, SHARCParserM15:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1520)
			p.M_reg()
		}

	case SHARCParserB0, SHARCParserB1, SHARCParserB2, SHARCParserB3, SHARCParserB4, SHARCParserB5, SHARCParserB6, SHARCParserB7, SHARCParserB8, SHARCParserB9, SHARCParserB10, SHARCParserB11, SHARCParserB12, SHARCParserB13, SHARCParserB14, SHARCParserB15:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1521)
			p.B_reg()
		}

	case SHARCParserL0, SHARCParserL1, SHARCParserL2, SHARCParserL3, SHARCParserL4, SHARCParserL5, SHARCParserL6, SHARCParserL7, SHARCParserL8, SHARCParserL9, SHARCParserL10, SHARCParserL11, SHARCParserL12, SHARCParserL13, SHARCParserL14, SHARCParserL15:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1522)
			p.L_reg()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ID_regContext is an interface to support dynamic dispatch.
type ID_regContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsD_regContext differentiates from other interfaces.
	IsD_regContext()
}

type D_regContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyD_regContext() *D_regContext {
	var p = new(D_regContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_d_reg
	return p
}

func (*D_regContext) IsD_regContext() {}

func NewD_regContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *D_regContext {
	var p = new(D_regContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_d_reg

	return p
}

func (s *D_regContext) GetParser() antlr.Parser { return s.parser }

func (s *D_regContext) R_reg() IR_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IR_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IR_regContext)
}

func (s *D_regContext) F_reg() IF_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IF_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IF_regContext)
}

func (s *D_regContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *D_regContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *D_regContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterD_reg(s)
	}
}

func (s *D_regContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitD_reg(s)
	}
}

func (p *SHARCParser) D_reg() (localctx ID_regContext) {
	this := p
	_ = this

	localctx = NewD_regContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, SHARCParserRULE_d_reg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1527)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1525)
			p.R_reg()
		}

	case SHARCParserF0, SHARCParserF1, SHARCParserF2, SHARCParserF3, SHARCParserF4, SHARCParserF5, SHARCParserF6, SHARCParserF7, SHARCParserF8, SHARCParserF9, SHARCParserF10, SHARCParserF11, SHARCParserF12, SHARCParserF13, SHARCParserF14, SHARCParserF15:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1526)
			p.F_reg()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IU_regContext is an interface to support dynamic dispatch.
type IU_regContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsU_regContext differentiates from other interfaces.
	IsU_regContext()
}

type U_regContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyU_regContext() *U_regContext {
	var p = new(U_regContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_u_reg
	return p
}

func (*U_regContext) IsU_regContext() {}

func NewU_regContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *U_regContext {
	var p = new(U_regContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_u_reg

	return p
}

func (s *U_regContext) GetParser() antlr.Parser { return s.parser }

func (s *U_regContext) D_reg() ID_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ID_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ID_regContext)
}

func (s *U_regContext) PC() antlr.TerminalNode {
	return s.GetToken(SHARCParserPC, 0)
}

func (s *U_regContext) PCSTK() antlr.TerminalNode {
	return s.GetToken(SHARCParserPCSTK, 0)
}

func (s *U_regContext) PCSTKP() antlr.TerminalNode {
	return s.GetToken(SHARCParserPCSTKP, 0)
}

func (s *U_regContext) FADDR() antlr.TerminalNode {
	return s.GetToken(SHARCParserFADDR, 0)
}

func (s *U_regContext) DADDR() antlr.TerminalNode {
	return s.GetToken(SHARCParserDADDR, 0)
}

func (s *U_regContext) LADDR() antlr.TerminalNode {
	return s.GetToken(SHARCParserLADDR, 0)
}

func (s *U_regContext) CURLCNTR() antlr.TerminalNode {
	return s.GetToken(SHARCParserCURLCNTR, 0)
}

func (s *U_regContext) LCNTR() antlr.TerminalNode {
	return s.GetToken(SHARCParserLCNTR, 0)
}

func (s *U_regContext) Dag_reg() IDag_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDag_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDag_regContext)
}

func (s *U_regContext) PX1() antlr.TerminalNode {
	return s.GetToken(SHARCParserPX1, 0)
}

func (s *U_regContext) PX2() antlr.TerminalNode {
	return s.GetToken(SHARCParserPX2, 0)
}

func (s *U_regContext) PX() antlr.TerminalNode {
	return s.GetToken(SHARCParserPX, 0)
}

func (s *U_regContext) TPERIOD() antlr.TerminalNode {
	return s.GetToken(SHARCParserTPERIOD, 0)
}

func (s *U_regContext) TCOUNT() antlr.TerminalNode {
	return s.GetToken(SHARCParserTCOUNT, 0)
}

func (s *U_regContext) S_reg() IS_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IS_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IS_regContext)
}

func (s *U_regContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *U_regContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *U_regContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterU_reg(s)
	}
}

func (s *U_regContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitU_reg(s)
	}
}

func (p *SHARCParser) U_reg() (localctx IU_regContext) {
	this := p
	_ = this

	localctx = NewU_regContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, SHARCParserRULE_u_reg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1545)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SHARCParserF0, SHARCParserF1, SHARCParserF2, SHARCParserF3, SHARCParserF4, SHARCParserF5, SHARCParserF6, SHARCParserF7, SHARCParserF8, SHARCParserF9, SHARCParserF10, SHARCParserF11, SHARCParserF12, SHARCParserF13, SHARCParserF14, SHARCParserF15, SHARCParserR0, SHARCParserR1, SHARCParserR2, SHARCParserR3, SHARCParserR4, SHARCParserR5, SHARCParserR6, SHARCParserR7, SHARCParserR8, SHARCParserR9, SHARCParserR10, SHARCParserR11, SHARCParserR12, SHARCParserR13, SHARCParserR14, SHARCParserR15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1529)
			p.D_reg()
		}

	case SHARCParserPC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1530)
			p.Match(SHARCParserPC)
		}

	case SHARCParserPCSTK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1531)
			p.Match(SHARCParserPCSTK)
		}

	case SHARCParserPCSTKP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1532)
			p.Match(SHARCParserPCSTKP)
		}

	case SHARCParserFADDR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1533)
			p.Match(SHARCParserFADDR)
		}

	case SHARCParserDADDR:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1534)
			p.Match(SHARCParserDADDR)
		}

	case SHARCParserLADDR:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1535)
			p.Match(SHARCParserLADDR)
		}

	case SHARCParserCURLCNTR:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1536)
			p.Match(SHARCParserCURLCNTR)
		}

	case SHARCParserLCNTR:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1537)
			p.Match(SHARCParserLCNTR)
		}

	case SHARCParserB0, SHARCParserB1, SHARCParserB2, SHARCParserB3, SHARCParserB4, SHARCParserB5, SHARCParserB6, SHARCParserB7, SHARCParserB8, SHARCParserB9, SHARCParserB10, SHARCParserB11, SHARCParserB12, SHARCParserB13, SHARCParserB14, SHARCParserB15, SHARCParserI0, SHARCParserI1, SHARCParserI2, SHARCParserI3, SHARCParserI4, SHARCParserI5, SHARCParserI6, SHARCParserI7, SHARCParserI8, SHARCParserI9, SHARCParserI10, SHARCParserI11, SHARCParserI12, SHARCParserI13, SHARCParserI14, SHARCParserI15, SHARCParserL0, SHARCParserL1, SHARCParserL2, SHARCParserL3, SHARCParserL4, SHARCParserL5, SHARCParserL6, SHARCParserL7, SHARCParserL8, SHARCParserL9, SHARCParserL10, SHARCParserL11, SHARCParserL12, SHARCParserL13, SHARCParserL14, SHARCParserL15, SHARCParserM0, SHARCParserM1, SHARCParserM2, SHARCParserM3, SHARCParserM4, SHARCParserM5, SHARCParserM6, SHARCParserM7, SHARCParserM8, SHARCParserM9, SHARCParserM10, SHARCParserM11, SHARCParserM12, SHARCParserM13, SHARCParserM14, SHARCParserM15:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1538)
			p.Dag_reg()
		}

	case SHARCParserPX1:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1539)
			p.Match(SHARCParserPX1)
		}

	case SHARCParserPX2:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1540)
			p.Match(SHARCParserPX2)
		}

	case SHARCParserPX:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1541)
			p.Match(SHARCParserPX)
		}

	case SHARCParserTPERIOD:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1542)
			p.Match(SHARCParserTPERIOD)
		}

	case SHARCParserTCOUNT:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1543)
			p.Match(SHARCParserTCOUNT)
		}

	case SHARCParserASTAT, SHARCParserIMASK, SHARCParserIMASKP, SHARCParserIRPTL, SHARCParserMODE1, SHARCParserMODE2, SHARCParserSTKY, SHARCParserUSTAT1, SHARCParserUSTAT2:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1544)
			p.S_reg()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_condition
	return p
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) Ccondition() ICconditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICconditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICconditionContext)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterCondition(s)
	}
}

func (s *ConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitCondition(s)
	}
}

func (p *SHARCParser) Condition() (localctx IConditionContext) {
	this := p
	_ = this

	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, SHARCParserRULE_condition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1547)
		p.Ccondition()
	}

	return localctx
}

// ICconditionContext is an interface to support dynamic dispatch.
type ICconditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCconditionContext differentiates from other interfaces.
	IsCconditionContext()
}

type CconditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCconditionContext() *CconditionContext {
	var p = new(CconditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_ccondition
	return p
}

func (*CconditionContext) IsCconditionContext() {}

func NewCconditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CconditionContext {
	var p = new(CconditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_ccondition

	return p
}

func (s *CconditionContext) GetParser() antlr.Parser { return s.parser }

func (s *CconditionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SHARCParserEQ, 0)
}

func (s *CconditionContext) LT() antlr.TerminalNode {
	return s.GetToken(SHARCParserLT, 0)
}

func (s *CconditionContext) LE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLE, 0)
}

func (s *CconditionContext) AC() antlr.TerminalNode {
	return s.GetToken(SHARCParserAC, 0)
}

func (s *CconditionContext) AV() antlr.TerminalNode {
	return s.GetToken(SHARCParserAV, 0)
}

func (s *CconditionContext) MV() antlr.TerminalNode {
	return s.GetToken(SHARCParserMV, 0)
}

func (s *CconditionContext) MS() antlr.TerminalNode {
	return s.GetToken(SHARCParserMS, 0)
}

func (s *CconditionContext) SV() antlr.TerminalNode {
	return s.GetToken(SHARCParserSV, 0)
}

func (s *CconditionContext) SZ() antlr.TerminalNode {
	return s.GetToken(SHARCParserSZ, 0)
}

func (s *CconditionContext) FLAG0_IN() antlr.TerminalNode {
	return s.GetToken(SHARCParserFLAG0_IN, 0)
}

func (s *CconditionContext) FLAG1_IN() antlr.TerminalNode {
	return s.GetToken(SHARCParserFLAG1_IN, 0)
}

func (s *CconditionContext) FLAG2_IN() antlr.TerminalNode {
	return s.GetToken(SHARCParserFLAG2_IN, 0)
}

func (s *CconditionContext) FLAG3_IN() antlr.TerminalNode {
	return s.GetToken(SHARCParserFLAG3_IN, 0)
}

func (s *CconditionContext) TF() antlr.TerminalNode {
	return s.GetToken(SHARCParserTF, 0)
}

func (s *CconditionContext) BM() antlr.TerminalNode {
	return s.GetToken(SHARCParserBM, 0)
}

func (s *CconditionContext) LCE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLCE, 0)
}

func (s *CconditionContext) NOT() antlr.TerminalNode {
	return s.GetToken(SHARCParserNOT, 0)
}

func (s *CconditionContext) NE() antlr.TerminalNode {
	return s.GetToken(SHARCParserNE, 0)
}

func (s *CconditionContext) GE() antlr.TerminalNode {
	return s.GetToken(SHARCParserGE, 0)
}

func (s *CconditionContext) GT() antlr.TerminalNode {
	return s.GetToken(SHARCParserGT, 0)
}

func (s *CconditionContext) NBM() antlr.TerminalNode {
	return s.GetToken(SHARCParserNBM, 0)
}

func (s *CconditionContext) FOREVER() antlr.TerminalNode {
	return s.GetToken(SHARCParserFOREVER, 0)
}

func (s *CconditionContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SHARCParserTRUE, 0)
}

func (s *CconditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CconditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CconditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterCcondition(s)
	}
}

func (s *CconditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitCcondition(s)
	}
}

func (p *SHARCParser) Ccondition() (localctx ICconditionContext) {
	this := p
	_ = this

	localctx = NewCconditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, SHARCParserRULE_ccondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1595)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1549)
			p.Match(SHARCParserEQ)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1550)
			p.Match(SHARCParserLT)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1551)
			p.Match(SHARCParserLE)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1552)
			p.Match(SHARCParserAC)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1553)
			p.Match(SHARCParserAV)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1554)
			p.Match(SHARCParserMV)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1555)
			p.Match(SHARCParserMS)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1556)
			p.Match(SHARCParserSV)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1557)
			p.Match(SHARCParserSZ)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1558)
			p.Match(SHARCParserFLAG0_IN)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1559)
			p.Match(SHARCParserFLAG1_IN)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1560)
			p.Match(SHARCParserFLAG2_IN)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1561)
			p.Match(SHARCParserFLAG3_IN)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1562)
			p.Match(SHARCParserTF)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1563)
			p.Match(SHARCParserBM)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1564)
			p.Match(SHARCParserLCE)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1565)
			p.Match(SHARCParserNOT)
		}
		{
			p.SetState(1566)
			p.Match(SHARCParserLCE)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1567)
			p.Match(SHARCParserNE)
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1568)
			p.Match(SHARCParserGE)
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1569)
			p.Match(SHARCParserGT)
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1570)
			p.Match(SHARCParserNOT)
		}
		{
			p.SetState(1571)
			p.Match(SHARCParserAC)
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1572)
			p.Match(SHARCParserNOT)
		}
		{
			p.SetState(1573)
			p.Match(SHARCParserAV)
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1574)
			p.Match(SHARCParserNOT)
		}
		{
			p.SetState(1575)
			p.Match(SHARCParserMV)
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1576)
			p.Match(SHARCParserNOT)
		}
		{
			p.SetState(1577)
			p.Match(SHARCParserMS)
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1578)
			p.Match(SHARCParserNOT)
		}
		{
			p.SetState(1579)
			p.Match(SHARCParserSV)
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1580)
			p.Match(SHARCParserNOT)
		}
		{
			p.SetState(1581)
			p.Match(SHARCParserSZ)
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1582)
			p.Match(SHARCParserNOT)
		}
		{
			p.SetState(1583)
			p.Match(SHARCParserFLAG0_IN)
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1584)
			p.Match(SHARCParserNOT)
		}
		{
			p.SetState(1585)
			p.Match(SHARCParserFLAG1_IN)
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1586)
			p.Match(SHARCParserNOT)
		}
		{
			p.SetState(1587)
			p.Match(SHARCParserFLAG2_IN)
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1588)
			p.Match(SHARCParserNOT)
		}
		{
			p.SetState(1589)
			p.Match(SHARCParserFLAG3_IN)
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1590)
			p.Match(SHARCParserNOT)
		}
		{
			p.SetState(1591)
			p.Match(SHARCParserTF)
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1592)
			p.Match(SHARCParserNBM)
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1593)
			p.Match(SHARCParserFOREVER)
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1594)
			p.Match(SHARCParserTRUE)
		}

	}

	return localctx
}

// IMulti_mod1Context is an interface to support dynamic dispatch.
type IMulti_mod1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_mod1Context differentiates from other interfaces.
	IsMulti_mod1Context()
}

type Multi_mod1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_mod1Context() *Multi_mod1Context {
	var p = new(Multi_mod1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_multi_mod1
	return p
}

func (*Multi_mod1Context) IsMulti_mod1Context() {}

func NewMulti_mod1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_mod1Context {
	var p = new(Multi_mod1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_multi_mod1

	return p
}

func (s *Multi_mod1Context) GetParser() antlr.Parser { return s.parser }

func (s *Multi_mod1Context) Multi_mod1_() IMulti_mod1_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_mod1_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_mod1_Context)
}

func (s *Multi_mod1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_mod1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_mod1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMulti_mod1(s)
	}
}

func (s *Multi_mod1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMulti_mod1(s)
	}
}

func (p *SHARCParser) Multi_mod1() (localctx IMulti_mod1Context) {
	this := p
	_ = this

	localctx = NewMulti_mod1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, SHARCParserRULE_multi_mod1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1597)
		p.Multi_mod1_()
	}

	return localctx
}

// IMulti_mod1_Context is an interface to support dynamic dispatch.
type IMulti_mod1_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_mod1_Context differentiates from other interfaces.
	IsMulti_mod1_Context()
}

type Multi_mod1_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_mod1_Context() *Multi_mod1_Context {
	var p = new(Multi_mod1_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_multi_mod1_
	return p
}

func (*Multi_mod1_Context) IsMulti_mod1_Context() {}

func NewMulti_mod1_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_mod1_Context {
	var p = new(Multi_mod1_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_multi_mod1_

	return p
}

func (s *Multi_mod1_Context) GetParser() antlr.Parser { return s.parser }

func (s *Multi_mod1_Context) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Multi_mod1_Context) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Multi_mod1_Context) SI() antlr.TerminalNode {
	return s.GetToken(SHARCParserSI, 0)
}

func (s *Multi_mod1_Context) UI() antlr.TerminalNode {
	return s.GetToken(SHARCParserUI, 0)
}

func (s *Multi_mod1_Context) SF() antlr.TerminalNode {
	return s.GetToken(SHARCParserSF, 0)
}

func (s *Multi_mod1_Context) UF() antlr.TerminalNode {
	return s.GetToken(SHARCParserUF, 0)
}

func (s *Multi_mod1_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_mod1_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_mod1_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMulti_mod1_(s)
	}
}

func (s *Multi_mod1_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMulti_mod1_(s)
	}
}

func (p *SHARCParser) Multi_mod1_() (localctx IMulti_mod1_Context) {
	this := p
	_ = this

	localctx = NewMulti_mod1_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, SHARCParserRULE_multi_mod1_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1599)
		p.Match(SHARCParserLPARENTHESE)
	}
	{
		p.SetState(1600)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SHARCParserSF || _la == SHARCParserSI || _la == SHARCParserUF || _la == SHARCParserUI) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1601)
		p.Match(SHARCParserRPARENTHESE)
	}

	return localctx
}

// IMulti_mod2Context is an interface to support dynamic dispatch.
type IMulti_mod2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_mod2Context differentiates from other interfaces.
	IsMulti_mod2Context()
}

type Multi_mod2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_mod2Context() *Multi_mod2Context {
	var p = new(Multi_mod2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_multi_mod2
	return p
}

func (*Multi_mod2Context) IsMulti_mod2Context() {}

func NewMulti_mod2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_mod2Context {
	var p = new(Multi_mod2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_multi_mod2

	return p
}

func (s *Multi_mod2Context) GetParser() antlr.Parser { return s.parser }

func (s *Multi_mod2Context) Multi_mod2_() IMulti_mod2_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_mod2_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_mod2_Context)
}

func (s *Multi_mod2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_mod2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_mod2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMulti_mod2(s)
	}
}

func (s *Multi_mod2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMulti_mod2(s)
	}
}

func (p *SHARCParser) Multi_mod2() (localctx IMulti_mod2Context) {
	this := p
	_ = this

	localctx = NewMulti_mod2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, SHARCParserRULE_multi_mod2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1603)
		p.Multi_mod2_()
	}

	return localctx
}

// IMulti_mod2_Context is an interface to support dynamic dispatch.
type IMulti_mod2_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_mod2_Context differentiates from other interfaces.
	IsMulti_mod2_Context()
}

type Multi_mod2_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_mod2_Context() *Multi_mod2_Context {
	var p = new(Multi_mod2_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_multi_mod2_
	return p
}

func (*Multi_mod2_Context) IsMulti_mod2_Context() {}

func NewMulti_mod2_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_mod2_Context {
	var p = new(Multi_mod2_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_multi_mod2_

	return p
}

func (s *Multi_mod2_Context) GetParser() antlr.Parser { return s.parser }

func (s *Multi_mod2_Context) LPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserLPARENTHESE, 0)
}

func (s *Multi_mod2_Context) RPARENTHESE() antlr.TerminalNode {
	return s.GetToken(SHARCParserRPARENTHESE, 0)
}

func (s *Multi_mod2_Context) SSI() antlr.TerminalNode {
	return s.GetToken(SHARCParserSSI, 0)
}

func (s *Multi_mod2_Context) SUI() antlr.TerminalNode {
	return s.GetToken(SHARCParserSUI, 0)
}

func (s *Multi_mod2_Context) USI() antlr.TerminalNode {
	return s.GetToken(SHARCParserUSI, 0)
}

func (s *Multi_mod2_Context) UUI() antlr.TerminalNode {
	return s.GetToken(SHARCParserUUI, 0)
}

func (s *Multi_mod2_Context) SSF() antlr.TerminalNode {
	return s.GetToken(SHARCParserSSF, 0)
}

func (s *Multi_mod2_Context) SUF() antlr.TerminalNode {
	return s.GetToken(SHARCParserSUF, 0)
}

func (s *Multi_mod2_Context) USF() antlr.TerminalNode {
	return s.GetToken(SHARCParserUSF, 0)
}

func (s *Multi_mod2_Context) UUF() antlr.TerminalNode {
	return s.GetToken(SHARCParserUUF, 0)
}

func (s *Multi_mod2_Context) SSFR() antlr.TerminalNode {
	return s.GetToken(SHARCParserSSFR, 0)
}

func (s *Multi_mod2_Context) SUFR() antlr.TerminalNode {
	return s.GetToken(SHARCParserSUFR, 0)
}

func (s *Multi_mod2_Context) USFR() antlr.TerminalNode {
	return s.GetToken(SHARCParserUSFR, 0)
}

func (s *Multi_mod2_Context) UUFR() antlr.TerminalNode {
	return s.GetToken(SHARCParserUUFR, 0)
}

func (s *Multi_mod2_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_mod2_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_mod2_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMulti_mod2_(s)
	}
}

func (s *Multi_mod2_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMulti_mod2_(s)
	}
}

func (p *SHARCParser) Multi_mod2_() (localctx IMulti_mod2_Context) {
	this := p
	_ = this

	localctx = NewMulti_mod2_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, SHARCParserRULE_multi_mod2_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1605)
		p.Match(SHARCParserLPARENTHESE)
	}
	{
		p.SetState(1606)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-334)&-(0x1f+1)) == 0 && ((1<<uint((_la-334)))&((1<<(SHARCParserSSF-334))|(1<<(SHARCParserSSFR-334))|(1<<(SHARCParserSSI-334))|(1<<(SHARCParserSUF-334))|(1<<(SHARCParserSUFR-334))|(1<<(SHARCParserSUI-334))|(1<<(SHARCParserUSF-334))|(1<<(SHARCParserUSFR-334)))) != 0) || (((_la-366)&-(0x1f+1)) == 0 && ((1<<uint((_la-366)))&((1<<(SHARCParserUSI-366))|(1<<(SHARCParserUUF-366))|(1<<(SHARCParserUUFR-366))|(1<<(SHARCParserUUI-366)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1607)
		p.Match(SHARCParserRPARENTHESE)
	}

	return localctx
}

// IR3_0Context is an interface to support dynamic dispatch.
type IR3_0Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsR3_0Context differentiates from other interfaces.
	IsR3_0Context()
}

type R3_0Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyR3_0Context() *R3_0Context {
	var p = new(R3_0Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_r3_0
	return p
}

func (*R3_0Context) IsR3_0Context() {}

func NewR3_0Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *R3_0Context {
	var p = new(R3_0Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_r3_0

	return p
}

func (s *R3_0Context) GetParser() antlr.Parser { return s.parser }

func (s *R3_0Context) R0() antlr.TerminalNode {
	return s.GetToken(SHARCParserR0, 0)
}

func (s *R3_0Context) R2() antlr.TerminalNode {
	return s.GetToken(SHARCParserR2, 0)
}

func (s *R3_0Context) R3() antlr.TerminalNode {
	return s.GetToken(SHARCParserR3, 0)
}

func (s *R3_0Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *R3_0Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *R3_0Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterR3_0(s)
	}
}

func (s *R3_0Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitR3_0(s)
	}
}

func (p *SHARCParser) R3_0() (localctx IR3_0Context) {
	this := p
	_ = this

	localctx = NewR3_0Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, SHARCParserRULE_r3_0)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1609)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-297)&-(0x1f+1)) == 0 && ((1<<uint((_la-297)))&((1<<(SHARCParserR0-297))|(1<<(SHARCParserR2-297))|(1<<(SHARCParserR3-297)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IR7_4Context is an interface to support dynamic dispatch.
type IR7_4Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsR7_4Context differentiates from other interfaces.
	IsR7_4Context()
}

type R7_4Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyR7_4Context() *R7_4Context {
	var p = new(R7_4Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_r7_4
	return p
}

func (*R7_4Context) IsR7_4Context() {}

func NewR7_4Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *R7_4Context {
	var p = new(R7_4Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_r7_4

	return p
}

func (s *R7_4Context) GetParser() antlr.Parser { return s.parser }

func (s *R7_4Context) R4() antlr.TerminalNode {
	return s.GetToken(SHARCParserR4, 0)
}

func (s *R7_4Context) R5() antlr.TerminalNode {
	return s.GetToken(SHARCParserR5, 0)
}

func (s *R7_4Context) R6() antlr.TerminalNode {
	return s.GetToken(SHARCParserR6, 0)
}

func (s *R7_4Context) R7() antlr.TerminalNode {
	return s.GetToken(SHARCParserR7, 0)
}

func (s *R7_4Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *R7_4Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *R7_4Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterR7_4(s)
	}
}

func (s *R7_4Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitR7_4(s)
	}
}

func (p *SHARCParser) R7_4() (localctx IR7_4Context) {
	this := p
	_ = this

	localctx = NewR7_4Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, SHARCParserRULE_r7_4)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1611)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-301)&-(0x1f+1)) == 0 && ((1<<uint((_la-301)))&((1<<(SHARCParserR4-301))|(1<<(SHARCParserR5-301))|(1<<(SHARCParserR6-301))|(1<<(SHARCParserR7-301)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IR11_8Context is an interface to support dynamic dispatch.
type IR11_8Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsR11_8Context differentiates from other interfaces.
	IsR11_8Context()
}

type R11_8Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyR11_8Context() *R11_8Context {
	var p = new(R11_8Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_r11_8
	return p
}

func (*R11_8Context) IsR11_8Context() {}

func NewR11_8Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *R11_8Context {
	var p = new(R11_8Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_r11_8

	return p
}

func (s *R11_8Context) GetParser() antlr.Parser { return s.parser }

func (s *R11_8Context) R8() antlr.TerminalNode {
	return s.GetToken(SHARCParserR8, 0)
}

func (s *R11_8Context) R9() antlr.TerminalNode {
	return s.GetToken(SHARCParserR9, 0)
}

func (s *R11_8Context) R10() antlr.TerminalNode {
	return s.GetToken(SHARCParserR10, 0)
}

func (s *R11_8Context) R11() antlr.TerminalNode {
	return s.GetToken(SHARCParserR11, 0)
}

func (s *R11_8Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *R11_8Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *R11_8Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterR11_8(s)
	}
}

func (s *R11_8Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitR11_8(s)
	}
}

func (p *SHARCParser) R11_8() (localctx IR11_8Context) {
	this := p
	_ = this

	localctx = NewR11_8Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, SHARCParserRULE_r11_8)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1613)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-305)&-(0x1f+1)) == 0 && ((1<<uint((_la-305)))&((1<<(SHARCParserR8-305))|(1<<(SHARCParserR9-305))|(1<<(SHARCParserR10-305))|(1<<(SHARCParserR11-305)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IR15_12Context is an interface to support dynamic dispatch.
type IR15_12Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsR15_12Context differentiates from other interfaces.
	IsR15_12Context()
}

type R15_12Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyR15_12Context() *R15_12Context {
	var p = new(R15_12Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_r15_12
	return p
}

func (*R15_12Context) IsR15_12Context() {}

func NewR15_12Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *R15_12Context {
	var p = new(R15_12Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_r15_12

	return p
}

func (s *R15_12Context) GetParser() antlr.Parser { return s.parser }

func (s *R15_12Context) R12() antlr.TerminalNode {
	return s.GetToken(SHARCParserR12, 0)
}

func (s *R15_12Context) R13() antlr.TerminalNode {
	return s.GetToken(SHARCParserR13, 0)
}

func (s *R15_12Context) R14() antlr.TerminalNode {
	return s.GetToken(SHARCParserR14, 0)
}

func (s *R15_12Context) R15() antlr.TerminalNode {
	return s.GetToken(SHARCParserR15, 0)
}

func (s *R15_12Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *R15_12Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *R15_12Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterR15_12(s)
	}
}

func (s *R15_12Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitR15_12(s)
	}
}

func (p *SHARCParser) R15_12() (localctx IR15_12Context) {
	this := p
	_ = this

	localctx = NewR15_12Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, SHARCParserRULE_r15_12)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1615)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-309)&-(0x1f+1)) == 0 && ((1<<uint((_la-309)))&((1<<(SHARCParserR12-309))|(1<<(SHARCParserR13-309))|(1<<(SHARCParserR14-309))|(1<<(SHARCParserR15-309)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IF3_0Context is an interface to support dynamic dispatch.
type IF3_0Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsF3_0Context differentiates from other interfaces.
	IsF3_0Context()
}

type F3_0Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyF3_0Context() *F3_0Context {
	var p = new(F3_0Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_f3_0
	return p
}

func (*F3_0Context) IsF3_0Context() {}

func NewF3_0Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *F3_0Context {
	var p = new(F3_0Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_f3_0

	return p
}

func (s *F3_0Context) GetParser() antlr.Parser { return s.parser }

func (s *F3_0Context) F0() antlr.TerminalNode {
	return s.GetToken(SHARCParserF0, 0)
}

func (s *F3_0Context) F2() antlr.TerminalNode {
	return s.GetToken(SHARCParserF2, 0)
}

func (s *F3_0Context) F3() antlr.TerminalNode {
	return s.GetToken(SHARCParserF3, 0)
}

func (s *F3_0Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *F3_0Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *F3_0Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterF3_0(s)
	}
}

func (s *F3_0Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitF3_0(s)
	}
}

func (p *SHARCParser) F3_0() (localctx IF3_0Context) {
	this := p
	_ = this

	localctx = NewF3_0Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, SHARCParserRULE_f3_0)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1617)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-126)&-(0x1f+1)) == 0 && ((1<<uint((_la-126)))&((1<<(SHARCParserF0-126))|(1<<(SHARCParserF2-126))|(1<<(SHARCParserF3-126)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IF7_4Context is an interface to support dynamic dispatch.
type IF7_4Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsF7_4Context differentiates from other interfaces.
	IsF7_4Context()
}

type F7_4Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyF7_4Context() *F7_4Context {
	var p = new(F7_4Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_f7_4
	return p
}

func (*F7_4Context) IsF7_4Context() {}

func NewF7_4Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *F7_4Context {
	var p = new(F7_4Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_f7_4

	return p
}

func (s *F7_4Context) GetParser() antlr.Parser { return s.parser }

func (s *F7_4Context) F4() antlr.TerminalNode {
	return s.GetToken(SHARCParserF4, 0)
}

func (s *F7_4Context) F5() antlr.TerminalNode {
	return s.GetToken(SHARCParserF5, 0)
}

func (s *F7_4Context) F6() antlr.TerminalNode {
	return s.GetToken(SHARCParserF6, 0)
}

func (s *F7_4Context) F7() antlr.TerminalNode {
	return s.GetToken(SHARCParserF7, 0)
}

func (s *F7_4Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *F7_4Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *F7_4Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterF7_4(s)
	}
}

func (s *F7_4Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitF7_4(s)
	}
}

func (p *SHARCParser) F7_4() (localctx IF7_4Context) {
	this := p
	_ = this

	localctx = NewF7_4Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, SHARCParserRULE_f7_4)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1619)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(SHARCParserF4-130))|(1<<(SHARCParserF5-130))|(1<<(SHARCParserF6-130))|(1<<(SHARCParserF7-130)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IF11_8Context is an interface to support dynamic dispatch.
type IF11_8Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsF11_8Context differentiates from other interfaces.
	IsF11_8Context()
}

type F11_8Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyF11_8Context() *F11_8Context {
	var p = new(F11_8Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_f11_8
	return p
}

func (*F11_8Context) IsF11_8Context() {}

func NewF11_8Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *F11_8Context {
	var p = new(F11_8Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_f11_8

	return p
}

func (s *F11_8Context) GetParser() antlr.Parser { return s.parser }

func (s *F11_8Context) F8() antlr.TerminalNode {
	return s.GetToken(SHARCParserF8, 0)
}

func (s *F11_8Context) F9() antlr.TerminalNode {
	return s.GetToken(SHARCParserF9, 0)
}

func (s *F11_8Context) F10() antlr.TerminalNode {
	return s.GetToken(SHARCParserF10, 0)
}

func (s *F11_8Context) F11() antlr.TerminalNode {
	return s.GetToken(SHARCParserF11, 0)
}

func (s *F11_8Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *F11_8Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *F11_8Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterF11_8(s)
	}
}

func (s *F11_8Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitF11_8(s)
	}
}

func (p *SHARCParser) F11_8() (localctx IF11_8Context) {
	this := p
	_ = this

	localctx = NewF11_8Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, SHARCParserRULE_f11_8)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1621)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-134)&-(0x1f+1)) == 0 && ((1<<uint((_la-134)))&((1<<(SHARCParserF8-134))|(1<<(SHARCParserF9-134))|(1<<(SHARCParserF10-134))|(1<<(SHARCParserF11-134)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IF15_12Context is an interface to support dynamic dispatch.
type IF15_12Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsF15_12Context differentiates from other interfaces.
	IsF15_12Context()
}

type F15_12Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyF15_12Context() *F15_12Context {
	var p = new(F15_12Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_f15_12
	return p
}

func (*F15_12Context) IsF15_12Context() {}

func NewF15_12Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *F15_12Context {
	var p = new(F15_12Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_f15_12

	return p
}

func (s *F15_12Context) GetParser() antlr.Parser { return s.parser }

func (s *F15_12Context) F12() antlr.TerminalNode {
	return s.GetToken(SHARCParserF12, 0)
}

func (s *F15_12Context) F13() antlr.TerminalNode {
	return s.GetToken(SHARCParserF13, 0)
}

func (s *F15_12Context) F14() antlr.TerminalNode {
	return s.GetToken(SHARCParserF14, 0)
}

func (s *F15_12Context) F15() antlr.TerminalNode {
	return s.GetToken(SHARCParserF15, 0)
}

func (s *F15_12Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *F15_12Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *F15_12Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterF15_12(s)
	}
}

func (s *F15_12Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitF15_12(s)
	}
}

func (p *SHARCParser) F15_12() (localctx IF15_12Context) {
	this := p
	_ = this

	localctx = NewF15_12Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, SHARCParserRULE_f15_12)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1623)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(SHARCParserF12-138))|(1<<(SHARCParserF13-138))|(1<<(SHARCParserF14-138))|(1<<(SHARCParserF15-138)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAddrContext is an interface to support dynamic dispatch.
type IAddrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddrContext differentiates from other interfaces.
	IsAddrContext()
}

type AddrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddrContext() *AddrContext {
	var p = new(AddrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_addr
	return p
}

func (*AddrContext) IsAddrContext() {}

func NewAddrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddrContext {
	var p = new(AddrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_addr

	return p
}

func (s *AddrContext) GetParser() antlr.Parser { return s.parser }

func (s *AddrContext) ID() antlr.TerminalNode {
	return s.GetToken(SHARCParserID, 0)
}

func (s *AddrContext) INT() antlr.TerminalNode {
	return s.GetToken(SHARCParserINT, 0)
}

func (s *AddrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterAddr(s)
	}
}

func (s *AddrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitAddr(s)
	}
}

func (p *SHARCParser) Addr() (localctx IAddrContext) {
	this := p
	_ = this

	localctx = NewAddrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, SHARCParserRULE_addr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1625)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SHARCParserINT || _la == SHARCParserID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMrfContext is an interface to support dynamic dispatch.
type IMrfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMrfContext differentiates from other interfaces.
	IsMrfContext()
}

type MrfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMrfContext() *MrfContext {
	var p = new(MrfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mrf
	return p
}

func (*MrfContext) IsMrfContext() {}

func NewMrfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MrfContext {
	var p = new(MrfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mrf

	return p
}

func (s *MrfContext) GetParser() antlr.Parser { return s.parser }

func (s *MrfContext) MR0F() antlr.TerminalNode {
	return s.GetToken(SHARCParserMR0F, 0)
}

func (s *MrfContext) MR1F() antlr.TerminalNode {
	return s.GetToken(SHARCParserMR1F, 0)
}

func (s *MrfContext) MR2F() antlr.TerminalNode {
	return s.GetToken(SHARCParserMR2F, 0)
}

func (s *MrfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MrfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MrfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMrf(s)
	}
}

func (s *MrfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMrf(s)
	}
}

func (p *SHARCParser) Mrf() (localctx IMrfContext) {
	this := p
	_ = this

	localctx = NewMrfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, SHARCParserRULE_mrf)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1627)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-248)&-(0x1f+1)) == 0 && ((1<<uint((_la-248)))&((1<<(SHARCParserMR0F-248))|(1<<(SHARCParserMR1F-248))|(1<<(SHARCParserMR2F-248)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMrbContext is an interface to support dynamic dispatch.
type IMrbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMrbContext differentiates from other interfaces.
	IsMrbContext()
}

type MrbContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMrbContext() *MrbContext {
	var p = new(MrbContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SHARCParserRULE_mrb
	return p
}

func (*MrbContext) IsMrbContext() {}

func NewMrbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MrbContext {
	var p = new(MrbContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SHARCParserRULE_mrb

	return p
}

func (s *MrbContext) GetParser() antlr.Parser { return s.parser }

func (s *MrbContext) MR0B() antlr.TerminalNode {
	return s.GetToken(SHARCParserMR0B, 0)
}

func (s *MrbContext) MR1B() antlr.TerminalNode {
	return s.GetToken(SHARCParserMR1B, 0)
}

func (s *MrbContext) MR2B() antlr.TerminalNode {
	return s.GetToken(SHARCParserMR2B, 0)
}

func (s *MrbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MrbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MrbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.EnterMrb(s)
	}
}

func (s *MrbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SHARCParserListener); ok {
		listenerT.ExitMrb(s)
	}
}

func (p *SHARCParser) Mrb() (localctx IMrbContext) {
	this := p
	_ = this

	localctx = NewMrbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, SHARCParserRULE_mrb)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1629)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-247)&-(0x1f+1)) == 0 && ((1<<uint((_la-247)))&((1<<(SHARCParserMR0B-247))|(1<<(SHARCParserMR1B-247))|(1<<(SHARCParserMR2B-247)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
