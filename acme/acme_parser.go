// Code generated from acme.g4 by ANTLR 4.9.3. DO NOT EDIT.

package acme // acme
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 108, 1720,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 3, 2, 7, 2, 226, 10, 2, 12, 2, 14, 2, 229, 11,
	2, 3, 2, 3, 2, 3, 2, 6, 2, 234, 10, 2, 13, 2, 14, 2, 235, 3, 3, 3, 3, 3,
	3, 5, 3, 241, 10, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 5, 5, 5, 248, 10, 5, 3,
	5, 3, 5, 6, 5, 252, 10, 5, 13, 5, 14, 5, 253, 3, 5, 7, 5, 257, 10, 5, 12,
	5, 14, 5, 260, 11, 5, 3, 6, 3, 6, 3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3,
	8, 3, 8, 5, 8, 272, 10, 8, 3, 8, 3, 8, 3, 8, 3, 8, 7, 8, 278, 10, 8, 12,
	8, 14, 8, 281, 11, 8, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 287, 10, 8, 5, 8, 289,
	10, 8, 5, 8, 291, 10, 8, 3, 9, 3, 9, 5, 9, 295, 10, 9, 3, 9, 5, 9, 298,
	10, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 5, 9, 307, 10, 9, 3, 9,
	3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 5, 9, 318, 10, 9, 7, 9,
	320, 10, 9, 12, 9, 14, 9, 323, 11, 9, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10,
	3, 10, 3, 10, 3, 10, 7, 10, 333, 10, 10, 12, 10, 14, 10, 336, 11, 10, 5,
	10, 338, 10, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 344, 10, 10, 3, 10,
	3, 10, 3, 10, 3, 10, 7, 10, 350, 10, 10, 12, 10, 14, 10, 353, 11, 10, 3,
	10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 360, 10, 10, 5, 10, 362, 10, 10,
	5, 10, 364, 10, 10, 5, 10, 366, 10, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3,
	11, 3, 11, 3, 11, 7, 11, 375, 10, 11, 12, 11, 14, 11, 378, 11, 11, 3, 11,
	3, 11, 3, 12, 3, 12, 3, 13, 3, 13, 3, 13, 5, 13, 387, 10, 13, 3, 14, 3,
	14, 3, 14, 5, 14, 392, 10, 14, 3, 15, 3, 15, 3, 15, 5, 15, 397, 10, 15,
	3, 16, 3, 16, 3, 16, 5, 16, 402, 10, 16, 3, 17, 3, 17, 3, 17, 5, 17, 407,
	10, 17, 3, 18, 3, 18, 3, 18, 5, 18, 412, 10, 18, 3, 19, 3, 19, 3, 19, 5,
	19, 417, 10, 19, 3, 20, 3, 20, 3, 20, 5, 20, 422, 10, 20, 3, 21, 3, 21,
	3, 21, 5, 21, 427, 10, 21, 3, 22, 3, 22, 3, 22, 5, 22, 432, 10, 22, 3,
	23, 3, 23, 3, 23, 5, 23, 437, 10, 23, 3, 24, 3, 24, 3, 24, 5, 24, 442,
	10, 24, 3, 25, 3, 25, 3, 25, 5, 25, 447, 10, 25, 3, 26, 3, 26, 3, 27, 3,
	27, 3, 27, 5, 27, 454, 10, 27, 3, 28, 3, 28, 3, 28, 5, 28, 459, 10, 28,
	3, 29, 3, 29, 3, 29, 7, 29, 464, 10, 29, 12, 29, 14, 29, 467, 11, 29, 3,
	30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 476, 10, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 7, 30, 482, 10, 30, 12, 30, 14, 30, 485, 11, 30, 3,
	30, 3, 30, 3, 30, 3, 30, 5, 30, 491, 10, 30, 5, 30, 493, 10, 30, 5, 30,
	495, 10, 30, 5, 30, 497, 10, 30, 3, 31, 3, 31, 3, 31, 7, 31, 502, 10, 31,
	12, 31, 14, 31, 505, 11, 31, 3, 31, 3, 31, 3, 32, 3, 32, 3, 32, 3, 32,
	3, 32, 3, 32, 3, 32, 5, 32, 516, 10, 32, 3, 32, 3, 32, 3, 32, 3, 32, 7,
	32, 522, 10, 32, 12, 32, 14, 32, 525, 11, 32, 3, 32, 3, 32, 3, 32, 3, 32,
	5, 32, 531, 10, 32, 5, 32, 533, 10, 32, 5, 32, 535, 10, 32, 5, 32, 537,
	10, 32, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 7, 33, 545, 10, 33, 12,
	33, 14, 33, 548, 11, 33, 5, 33, 550, 10, 33, 3, 33, 3, 33, 3, 33, 3, 33,
	5, 33, 556, 10, 33, 3, 33, 3, 33, 3, 33, 3, 33, 7, 33, 562, 10, 33, 12,
	33, 14, 33, 565, 11, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 572,
	10, 33, 5, 33, 574, 10, 33, 5, 33, 576, 10, 33, 5, 33, 578, 10, 33, 3,
	34, 3, 34, 3, 34, 3, 34, 7, 34, 584, 10, 34, 12, 34, 14, 34, 587, 11, 34,
	3, 34, 3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 7, 35, 596, 10, 35, 12,
	35, 14, 35, 599, 11, 35, 5, 35, 601, 10, 35, 3, 35, 3, 35, 5, 35, 605,
	10, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 5, 36, 614, 10,
	36, 3, 36, 3, 36, 3, 36, 3, 36, 7, 36, 620, 10, 36, 12, 36, 14, 36, 623,
	11, 36, 3, 36, 3, 36, 3, 36, 3, 36, 5, 36, 629, 10, 36, 5, 36, 631, 10,
	36, 5, 36, 633, 10, 36, 5, 36, 635, 10, 36, 3, 37, 3, 37, 3, 37, 3, 37,
	3, 37, 3, 37, 7, 37, 643, 10, 37, 12, 37, 14, 37, 646, 11, 37, 5, 37, 648,
	10, 37, 3, 37, 5, 37, 651, 10, 37, 3, 37, 3, 37, 3, 37, 5, 37, 656, 10,
	37, 3, 37, 3, 37, 3, 37, 3, 37, 7, 37, 662, 10, 37, 12, 37, 14, 37, 665,
	11, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 672, 10, 37, 5, 37, 674,
	10, 37, 5, 37, 676, 10, 37, 5, 37, 678, 10, 37, 3, 38, 3, 38, 3, 38, 3,
	38, 7, 38, 684, 10, 38, 12, 38, 14, 38, 687, 11, 38, 3, 38, 3, 38, 3, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 698, 10, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 7, 39, 704, 10, 39, 12, 39, 14, 39, 707, 11, 39, 3, 39,
	3, 39, 3, 39, 3, 39, 5, 39, 713, 10, 39, 5, 39, 715, 10, 39, 5, 39, 717,
	10, 39, 5, 39, 719, 10, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 7,
	40, 727, 10, 40, 12, 40, 14, 40, 730, 11, 40, 5, 40, 732, 10, 40, 3, 40,
	3, 40, 3, 40, 3, 40, 5, 40, 738, 10, 40, 3, 40, 3, 40, 3, 40, 3, 40, 7,
	40, 744, 10, 40, 12, 40, 14, 40, 747, 11, 40, 3, 40, 3, 40, 3, 40, 3, 40,
	3, 40, 5, 40, 754, 10, 40, 5, 40, 756, 10, 40, 5, 40, 758, 10, 40, 5, 40,
	760, 10, 40, 3, 41, 3, 41, 3, 41, 3, 41, 7, 41, 766, 10, 41, 12, 41, 14,
	41, 769, 11, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42,
	3, 42, 5, 42, 780, 10, 42, 3, 42, 3, 42, 3, 42, 3, 42, 7, 42, 786, 10,
	42, 12, 42, 14, 42, 789, 11, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 795,
	10, 42, 5, 42, 797, 10, 42, 5, 42, 799, 10, 42, 5, 42, 801, 10, 42, 3,
	43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 7, 43, 809, 10, 43, 12, 43, 14,
	43, 812, 11, 43, 5, 43, 814, 10, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43,
	820, 10, 43, 3, 43, 3, 43, 3, 43, 3, 43, 7, 43, 826, 10, 43, 12, 43, 14,
	43, 829, 11, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43, 836, 10, 43,
	5, 43, 838, 10, 43, 5, 43, 840, 10, 43, 5, 43, 842, 10, 43, 3, 44, 3, 44,
	3, 44, 3, 44, 3, 44, 7, 44, 849, 10, 44, 12, 44, 14, 44, 852, 11, 44, 3,
	44, 3, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 863,
	10, 45, 3, 45, 3, 45, 3, 45, 3, 45, 7, 45, 869, 10, 45, 12, 45, 14, 45,
	872, 11, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 878, 10, 45, 5, 45, 880,
	10, 45, 5, 45, 882, 10, 45, 5, 45, 884, 10, 45, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 7, 46, 892, 10, 46, 12, 46, 14, 46, 895, 11, 46, 5, 46,
	897, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 903, 10, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 7, 46, 909, 10, 46, 12, 46, 14, 46, 912, 11, 46, 3, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 919, 10, 46, 5, 46, 921, 10, 46, 5,
	46, 923, 10, 46, 5, 46, 925, 10, 46, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47,
	7, 47, 932, 10, 47, 12, 47, 14, 47, 935, 11, 47, 3, 47, 3, 47, 3, 48, 3,
	48, 3, 48, 5, 48, 942, 10, 48, 3, 48, 3, 48, 3, 48, 5, 48, 947, 10, 48,
	3, 48, 3, 48, 5, 48, 951, 10, 48, 3, 49, 3, 49, 3, 49, 7, 49, 956, 10,
	49, 12, 49, 14, 49, 959, 11, 49, 3, 49, 3, 49, 5, 49, 963, 10, 49, 3, 50,
	3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 973, 10, 50, 3,
	50, 3, 50, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 52, 3, 52, 3, 52,
	3, 52, 5, 52, 987, 10, 52, 3, 52, 3, 52, 3, 52, 3, 52, 5, 52, 993, 10,
	52, 3, 52, 5, 52, 996, 10, 52, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 53,
	3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 5, 53, 1009, 10, 53, 3, 54, 3, 54, 3,
	55, 3, 55, 3, 55, 7, 55, 1016, 10, 55, 12, 55, 14, 55, 1019, 11, 55, 3,
	55, 5, 55, 1022, 10, 55, 3, 56, 3, 56, 3, 56, 5, 56, 1027, 10, 56, 3, 57,
	3, 57, 3, 57, 3, 57, 7, 57, 1033, 10, 57, 12, 57, 14, 57, 1036, 11, 57,
	5, 57, 1038, 10, 57, 3, 57, 3, 57, 3, 58, 3, 58, 3, 58, 5, 58, 1045, 10,
	58, 3, 58, 3, 58, 3, 58, 3, 59, 3, 59, 3, 59, 3, 59, 7, 59, 1054, 10, 59,
	12, 59, 14, 59, 1057, 11, 59, 3, 59, 5, 59, 1060, 10, 59, 5, 59, 1062,
	10, 59, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 3, 60, 7, 60, 1070, 10, 60,
	12, 60, 14, 60, 1073, 11, 60, 5, 60, 1075, 10, 60, 3, 60, 3, 60, 3, 61,
	3, 61, 3, 61, 7, 61, 1082, 10, 61, 12, 61, 14, 61, 1085, 11, 61, 3, 61,
	3, 61, 3, 62, 3, 62, 3, 62, 5, 62, 1092, 10, 62, 3, 62, 3, 62, 3, 63, 3,
	63, 3, 63, 5, 63, 1099, 10, 63, 3, 63, 3, 63, 3, 64, 3, 64, 3, 64, 3, 64,
	3, 64, 7, 64, 1108, 10, 64, 12, 64, 14, 64, 1111, 11, 64, 3, 64, 3, 64,
	3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 66, 3, 66, 5, 66, 1122, 10, 66, 3,
	67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67,
	1134, 10, 67, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3,
	68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68, 1151, 10, 68, 3, 68,
	3, 68, 5, 68, 1155, 10, 68, 3, 69, 3, 69, 3, 69, 5, 69, 1160, 10, 69, 3,
	69, 3, 69, 3, 69, 3, 69, 5, 69, 1166, 10, 69, 3, 69, 3, 69, 3, 70, 3, 70,
	6, 70, 1172, 10, 70, 13, 70, 14, 70, 1173, 3, 70, 3, 70, 3, 71, 3, 71,
	3, 72, 3, 72, 3, 73, 3, 73, 3, 74, 3, 74, 3, 75, 3, 75, 3, 76, 3, 76, 3,
	77, 3, 77, 3, 77, 3, 77, 5, 77, 1194, 10, 77, 3, 77, 3, 77, 3, 77, 3, 77,
	5, 77, 1200, 10, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 5,
	77, 1209, 10, 77, 5, 77, 1211, 10, 77, 5, 77, 1213, 10, 77, 5, 77, 1215,
	10, 77, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 5, 78, 1224, 10,
	78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 5, 78, 1232, 10, 78, 5, 78,
	1234, 10, 78, 5, 78, 1236, 10, 78, 5, 78, 1238, 10, 78, 3, 79, 3, 79, 3,
	79, 3, 80, 5, 80, 1244, 10, 80, 3, 80, 3, 80, 3, 80, 5, 80, 1249, 10, 80,
	5, 80, 1251, 10, 80, 3, 80, 3, 80, 3, 80, 3, 80, 5, 80, 1257, 10, 80, 5,
	80, 1259, 10, 80, 3, 80, 5, 80, 1262, 10, 80, 3, 80, 3, 80, 3, 81, 5, 81,
	1267, 10, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 7, 81, 1275, 10,
	81, 12, 81, 14, 81, 1278, 11, 81, 5, 81, 1280, 10, 81, 3, 81, 3, 81, 3,
	81, 3, 81, 3, 81, 3, 81, 5, 81, 1288, 10, 81, 3, 81, 3, 81, 3, 81, 3, 81,
	5, 81, 1294, 10, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 7, 81, 1302,
	10, 81, 12, 81, 14, 81, 1305, 11, 81, 5, 81, 1307, 10, 81, 3, 81, 3, 81,
	3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 7, 81, 1317, 10, 81, 12, 81,
	14, 81, 1320, 11, 81, 5, 81, 1322, 10, 81, 3, 81, 3, 81, 5, 81, 1326, 10,
	81, 3, 82, 3, 82, 3, 82, 3, 82, 3, 83, 3, 83, 3, 83, 3, 84, 3, 84, 3, 84,
	7, 84, 1338, 10, 84, 12, 84, 14, 84, 1341, 11, 84, 3, 85, 3, 85, 3, 85,
	7, 85, 1346, 10, 85, 12, 85, 14, 85, 1349, 11, 85, 3, 86, 3, 86, 3, 86,
	7, 86, 1354, 10, 86, 12, 86, 14, 86, 1357, 11, 86, 3, 87, 3, 87, 3, 87,
	7, 87, 1362, 10, 87, 12, 87, 14, 87, 1365, 11, 87, 3, 88, 3, 88, 3, 88,
	5, 88, 1370, 10, 88, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 7, 89, 1377, 10,
	89, 12, 89, 14, 89, 1380, 11, 89, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3,
	90, 3, 90, 3, 90, 3, 90, 7, 90, 1391, 10, 90, 12, 90, 14, 90, 1394, 11,
	90, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 7, 91, 1401, 10, 91, 12, 91, 14,
	91, 1404, 11, 91, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92,
	3, 92, 7, 92, 1415, 10, 92, 12, 92, 14, 92, 1418, 11, 92, 3, 93, 3, 93,
	3, 93, 5, 93, 1423, 10, 93, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3,
	94, 3, 94, 5, 94, 1433, 10, 94, 3, 95, 3, 95, 3, 95, 3, 95, 3, 96, 3, 96,
	3, 96, 3, 96, 5, 96, 1443, 10, 96, 7, 96, 1445, 10, 96, 12, 96, 14, 96,
	1448, 11, 96, 3, 96, 5, 96, 1451, 10, 96, 3, 97, 3, 97, 3, 97, 3, 97, 3,
	97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 5, 97, 1464, 10, 97, 3, 98,
	3, 98, 3, 98, 3, 98, 7, 98, 1470, 10, 98, 12, 98, 14, 98, 1473, 11, 98,
	5, 98, 1475, 10, 98, 3, 98, 3, 98, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3,
	99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99,
	3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 5, 99, 1501, 10, 99, 3, 100,
	3, 100, 3, 100, 5, 100, 1506, 10, 100, 5, 100, 1508, 10, 100, 3, 100, 3,
	100, 3, 100, 7, 100, 1513, 10, 100, 12, 100, 14, 100, 1516, 11, 100, 3,
	100, 3, 100, 3, 100, 3, 101, 3, 101, 3, 101, 3, 101, 7, 101, 1525, 10,
	101, 12, 101, 14, 101, 1528, 11, 101, 3, 101, 3, 101, 5, 101, 1532, 10,
	101, 3, 101, 3, 101, 3, 101, 5, 101, 1537, 10, 101, 3, 102, 3, 102, 3,
	102, 3, 102, 7, 102, 1543, 10, 102, 12, 102, 14, 102, 1546, 11, 102, 3,
	102, 3, 102, 5, 102, 1550, 10, 102, 3, 102, 3, 102, 3, 102, 5, 102, 1555,
	10, 102, 5, 102, 1557, 10, 102, 3, 103, 3, 103, 3, 103, 3, 103, 3, 104,
	3, 104, 3, 104, 5, 104, 1566, 10, 104, 3, 105, 3, 105, 3, 105, 3, 105,
	5, 105, 1572, 10, 105, 3, 105, 3, 105, 3, 105, 3, 105, 5, 105, 1578, 10,
	105, 3, 105, 3, 105, 7, 105, 1582, 10, 105, 12, 105, 14, 105, 1585, 11,
	105, 3, 106, 3, 106, 3, 106, 5, 106, 1590, 10, 106, 3, 106, 3, 106, 3,
	106, 3, 106, 5, 106, 1596, 10, 106, 3, 106, 3, 106, 7, 106, 1600, 10, 106,
	12, 106, 14, 106, 1603, 11, 106, 3, 106, 5, 106, 1606, 10, 106, 3, 106,
	5, 106, 1609, 10, 106, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 5, 107,
	1616, 10, 107, 3, 107, 3, 107, 3, 107, 5, 107, 1621, 10, 107, 7, 107, 1623,
	10, 107, 12, 107, 14, 107, 1626, 11, 107, 3, 107, 3, 107, 5, 107, 1630,
	10, 107, 3, 108, 3, 108, 3, 108, 3, 108, 3, 108, 5, 108, 1637, 10, 108,
	3, 108, 3, 108, 3, 108, 5, 108, 1642, 10, 108, 7, 108, 1644, 10, 108, 12,
	108, 14, 108, 1647, 11, 108, 3, 108, 3, 108, 5, 108, 1651, 10, 108, 3,
	109, 3, 109, 3, 109, 5, 109, 1656, 10, 109, 3, 109, 3, 109, 3, 109, 3,
	110, 3, 110, 3, 110, 3, 110, 7, 110, 1665, 10, 110, 12, 110, 14, 110, 1668,
	11, 110, 3, 110, 5, 110, 1671, 10, 110, 5, 110, 1673, 10, 110, 3, 110,
	3, 110, 3, 111, 5, 111, 1678, 10, 111, 3, 111, 3, 111, 3, 111, 3, 111,
	3, 111, 5, 111, 1685, 10, 111, 3, 111, 5, 111, 1688, 10, 111, 3, 111, 3,
	111, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111, 5, 111, 1697, 10, 111, 3,
	111, 3, 111, 3, 111, 5, 111, 1702, 10, 111, 5, 111, 1704, 10, 111, 3, 112,
	3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112,
	3, 112, 3, 112, 5, 112, 1718, 10, 112, 3, 112, 2, 2, 113, 2, 4, 6, 8, 10,
	12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
	48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
	84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
	116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144,
	146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174,
	176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204,
	206, 208, 210, 212, 214, 216, 218, 220, 222, 2, 8, 4, 2, 3, 3, 78, 78,
	9, 2, 3, 5, 17, 17, 27, 27, 63, 63, 69, 69, 78, 78, 88, 88, 4, 2, 37, 37,
	91, 91, 3, 2, 66, 67, 4, 2, 6, 6, 38, 38, 4, 2, 17, 17, 87, 87, 2, 1964,
	2, 227, 3, 2, 2, 2, 4, 237, 3, 2, 2, 2, 6, 244, 3, 2, 2, 2, 8, 247, 3,
	2, 2, 2, 10, 261, 3, 2, 2, 2, 12, 263, 3, 2, 2, 2, 14, 265, 3, 2, 2, 2,
	16, 292, 3, 2, 2, 2, 18, 326, 3, 2, 2, 2, 20, 367, 3, 2, 2, 2, 22, 381,
	3, 2, 2, 2, 24, 383, 3, 2, 2, 2, 26, 388, 3, 2, 2, 2, 28, 393, 3, 2, 2,
	2, 30, 398, 3, 2, 2, 2, 32, 403, 3, 2, 2, 2, 34, 408, 3, 2, 2, 2, 36, 413,
	3, 2, 2, 2, 38, 418, 3, 2, 2, 2, 40, 423, 3, 2, 2, 2, 42, 428, 3, 2, 2,
	2, 44, 433, 3, 2, 2, 2, 46, 438, 3, 2, 2, 2, 48, 443, 3, 2, 2, 2, 50, 448,
	3, 2, 2, 2, 52, 450, 3, 2, 2, 2, 54, 455, 3, 2, 2, 2, 56, 460, 3, 2, 2,
	2, 58, 468, 3, 2, 2, 2, 60, 498, 3, 2, 2, 2, 62, 508, 3, 2, 2, 2, 64, 538,
	3, 2, 2, 2, 66, 579, 3, 2, 2, 2, 68, 590, 3, 2, 2, 2, 70, 606, 3, 2, 2,
	2, 72, 636, 3, 2, 2, 2, 74, 679, 3, 2, 2, 2, 76, 690, 3, 2, 2, 2, 78, 720,
	3, 2, 2, 2, 80, 761, 3, 2, 2, 2, 82, 772, 3, 2, 2, 2, 84, 802, 3, 2, 2,
	2, 86, 843, 3, 2, 2, 2, 88, 855, 3, 2, 2, 2, 90, 885, 3, 2, 2, 2, 92, 926,
	3, 2, 2, 2, 94, 938, 3, 2, 2, 2, 96, 952, 3, 2, 2, 2, 98, 964, 3, 2, 2,
	2, 100, 976, 3, 2, 2, 2, 102, 982, 3, 2, 2, 2, 104, 1008, 3, 2, 2, 2, 106,
	1010, 3, 2, 2, 2, 108, 1021, 3, 2, 2, 2, 110, 1026, 3, 2, 2, 2, 112, 1028,
	3, 2, 2, 2, 114, 1041, 3, 2, 2, 2, 116, 1049, 3, 2, 2, 2, 118, 1065, 3,
	2, 2, 2, 120, 1078, 3, 2, 2, 2, 122, 1088, 3, 2, 2, 2, 124, 1095, 3, 2,
	2, 2, 126, 1102, 3, 2, 2, 2, 128, 1114, 3, 2, 2, 2, 130, 1121, 3, 2, 2,
	2, 132, 1133, 3, 2, 2, 2, 134, 1135, 3, 2, 2, 2, 136, 1156, 3, 2, 2, 2,
	138, 1169, 3, 2, 2, 2, 140, 1177, 3, 2, 2, 2, 142, 1179, 3, 2, 2, 2, 144,
	1181, 3, 2, 2, 2, 146, 1183, 3, 2, 2, 2, 148, 1185, 3, 2, 2, 2, 150, 1187,
	3, 2, 2, 2, 152, 1189, 3, 2, 2, 2, 154, 1216, 3, 2, 2, 2, 156, 1239, 3,
	2, 2, 2, 158, 1243, 3, 2, 2, 2, 160, 1325, 3, 2, 2, 2, 162, 1327, 3, 2,
	2, 2, 164, 1331, 3, 2, 2, 2, 166, 1334, 3, 2, 2, 2, 168, 1342, 3, 2, 2,
	2, 170, 1350, 3, 2, 2, 2, 172, 1358, 3, 2, 2, 2, 174, 1369, 3, 2, 2, 2,
	176, 1371, 3, 2, 2, 2, 178, 1381, 3, 2, 2, 2, 180, 1395, 3, 2, 2, 2, 182,
	1405, 3, 2, 2, 2, 184, 1422, 3, 2, 2, 2, 186, 1432, 3, 2, 2, 2, 188, 1434,
	3, 2, 2, 2, 190, 1438, 3, 2, 2, 2, 192, 1463, 3, 2, 2, 2, 194, 1465, 3,
	2, 2, 2, 196, 1500, 3, 2, 2, 2, 198, 1507, 3, 2, 2, 2, 200, 1520, 3, 2,
	2, 2, 202, 1556, 3, 2, 2, 2, 204, 1558, 3, 2, 2, 2, 206, 1565, 3, 2, 2,
	2, 208, 1567, 3, 2, 2, 2, 210, 1608, 3, 2, 2, 2, 212, 1629, 3, 2, 2, 2,
	214, 1650, 3, 2, 2, 2, 216, 1652, 3, 2, 2, 2, 218, 1660, 3, 2, 2, 2, 220,
	1703, 3, 2, 2, 2, 222, 1717, 3, 2, 2, 2, 224, 226, 5, 4, 3, 2, 225, 224,
	3, 2, 2, 2, 226, 229, 3, 2, 2, 2, 227, 225, 3, 2, 2, 2, 227, 228, 3, 2,
	2, 2, 228, 233, 3, 2, 2, 2, 229, 227, 3, 2, 2, 2, 230, 234, 5, 18, 10,
	2, 231, 234, 5, 14, 8, 2, 232, 234, 5, 22, 12, 2, 233, 230, 3, 2, 2, 2,
	233, 231, 3, 2, 2, 2, 233, 232, 3, 2, 2, 2, 234, 235, 3, 2, 2, 2, 235,
	233, 3, 2, 2, 2, 235, 236, 3, 2, 2, 2, 236, 3, 3, 2, 2, 2, 237, 240, 7,
	46, 2, 2, 238, 241, 5, 8, 5, 2, 239, 241, 5, 6, 4, 2, 240, 238, 3, 2, 2,
	2, 240, 239, 3, 2, 2, 2, 241, 242, 3, 2, 2, 2, 242, 243, 7, 85, 2, 2, 243,
	5, 3, 2, 2, 2, 244, 245, 7, 104, 2, 2, 245, 7, 3, 2, 2, 2, 246, 248, 9,
	2, 2, 2, 247, 246, 3, 2, 2, 2, 247, 248, 3, 2, 2, 2, 248, 249, 3, 2, 2,
	2, 249, 258, 7, 105, 2, 2, 250, 252, 9, 3, 2, 2, 251, 250, 3, 2, 2, 2,
	252, 253, 3, 2, 2, 2, 253, 251, 3, 2, 2, 2, 253, 254, 3, 2, 2, 2, 254,
	255, 3, 2, 2, 2, 255, 257, 7, 105, 2, 2, 256, 251, 3, 2, 2, 2, 257, 260,
	3, 2, 2, 2, 258, 256, 3, 2, 2, 2, 258, 259, 3, 2, 2, 2, 259, 9, 3, 2, 2,
	2, 260, 258, 3, 2, 2, 2, 261, 262, 7, 105, 2, 2, 262, 11, 3, 2, 2, 2, 263,
	264, 7, 104, 2, 2, 264, 13, 3, 2, 2, 2, 265, 266, 9, 4, 2, 2, 266, 290,
	5, 10, 6, 2, 267, 291, 7, 85, 2, 2, 268, 269, 7, 10, 2, 2, 269, 271, 5,
	16, 9, 2, 270, 272, 7, 85, 2, 2, 271, 270, 3, 2, 2, 2, 271, 272, 3, 2,
	2, 2, 272, 291, 3, 2, 2, 2, 273, 274, 7, 32, 2, 2, 274, 279, 5, 48, 25,
	2, 275, 276, 7, 18, 2, 2, 276, 278, 5, 48, 25, 2, 277, 275, 3, 2, 2, 2,
	278, 281, 3, 2, 2, 2, 279, 277, 3, 2, 2, 2, 279, 280, 3, 2, 2, 2, 280,
	288, 3, 2, 2, 2, 281, 279, 3, 2, 2, 2, 282, 289, 7, 85, 2, 2, 283, 284,
	7, 96, 2, 2, 284, 286, 5, 16, 9, 2, 285, 287, 7, 85, 2, 2, 286, 285, 3,
	2, 2, 2, 286, 287, 3, 2, 2, 2, 287, 289, 3, 2, 2, 2, 288, 282, 3, 2, 2,
	2, 288, 283, 3, 2, 2, 2, 289, 291, 3, 2, 2, 2, 290, 267, 3, 2, 2, 2, 290,
	268, 3, 2, 2, 2, 290, 273, 3, 2, 2, 2, 291, 15, 3, 2, 2, 2, 292, 321, 7,
	51, 2, 2, 293, 295, 9, 5, 2, 2, 294, 293, 3, 2, 2, 2, 294, 295, 3, 2, 2,
	2, 295, 297, 3, 2, 2, 2, 296, 298, 9, 6, 2, 2, 297, 296, 3, 2, 2, 2, 297,
	298, 3, 2, 2, 2, 298, 306, 3, 2, 2, 2, 299, 307, 5, 70, 36, 2, 300, 307,
	5, 76, 39, 2, 301, 307, 5, 82, 42, 2, 302, 307, 5, 88, 45, 2, 303, 307,
	5, 58, 30, 2, 304, 307, 5, 134, 68, 2, 305, 307, 5, 62, 32, 2, 306, 299,
	3, 2, 2, 2, 306, 300, 3, 2, 2, 2, 306, 301, 3, 2, 2, 2, 306, 302, 3, 2,
	2, 2, 306, 303, 3, 2, 2, 2, 306, 304, 3, 2, 2, 2, 306, 305, 3, 2, 2, 2,
	307, 320, 3, 2, 2, 2, 308, 318, 5, 160, 81, 2, 309, 318, 5, 158, 80, 2,
	310, 318, 5, 72, 37, 2, 311, 318, 5, 78, 40, 2, 312, 318, 5, 84, 43, 2,
	313, 318, 5, 90, 46, 2, 314, 318, 5, 102, 52, 2, 315, 318, 5, 64, 33, 2,
	316, 318, 5, 100, 51, 2, 317, 308, 3, 2, 2, 2, 317, 309, 3, 2, 2, 2, 317,
	310, 3, 2, 2, 2, 317, 311, 3, 2, 2, 2, 317, 312, 3, 2, 2, 2, 317, 313,
	3, 2, 2, 2, 317, 314, 3, 2, 2, 2, 317, 315, 3, 2, 2, 2, 317, 316, 3, 2,
	2, 2, 318, 320, 3, 2, 2, 2, 319, 294, 3, 2, 2, 2, 319, 317, 3, 2, 2, 2,
	320, 323, 3, 2, 2, 2, 321, 319, 3, 2, 2, 2, 321, 322, 3, 2, 2, 2, 322,
	324, 3, 2, 2, 2, 323, 321, 3, 2, 2, 2, 324, 325, 7, 52, 2, 2, 325, 17,
	3, 2, 2, 2, 326, 327, 7, 92, 2, 2, 327, 337, 5, 10, 6, 2, 328, 329, 7,
	17, 2, 2, 329, 334, 5, 48, 25, 2, 330, 331, 7, 18, 2, 2, 331, 333, 5, 48,
	25, 2, 332, 330, 3, 2, 2, 2, 333, 336, 3, 2, 2, 2, 334, 332, 3, 2, 2, 2,
	334, 335, 3, 2, 2, 2, 335, 338, 3, 2, 2, 2, 336, 334, 3, 2, 2, 2, 337,
	328, 3, 2, 2, 2, 337, 338, 3, 2, 2, 2, 338, 365, 3, 2, 2, 2, 339, 366,
	7, 85, 2, 2, 340, 363, 7, 10, 2, 2, 341, 343, 5, 20, 11, 2, 342, 344, 7,
	85, 2, 2, 343, 342, 3, 2, 2, 2, 343, 344, 3, 2, 2, 2, 344, 364, 3, 2, 2,
	2, 345, 346, 7, 61, 2, 2, 346, 351, 5, 50, 26, 2, 347, 348, 7, 18, 2, 2,
	348, 350, 5, 50, 26, 2, 349, 347, 3, 2, 2, 2, 350, 353, 3, 2, 2, 2, 351,
	349, 3, 2, 2, 2, 351, 352, 3, 2, 2, 2, 352, 361, 3, 2, 2, 2, 353, 351,
	3, 2, 2, 2, 354, 362, 7, 85, 2, 2, 355, 356, 7, 31, 2, 2, 356, 357, 7,
	96, 2, 2, 357, 359, 5, 20, 11, 2, 358, 360, 7, 85, 2, 2, 359, 358, 3, 2,
	2, 2, 359, 360, 3, 2, 2, 2, 360, 362, 3, 2, 2, 2, 361, 354, 3, 2, 2, 2,
	361, 355, 3, 2, 2, 2, 362, 364, 3, 2, 2, 2, 363, 341, 3, 2, 2, 2, 363,
	345, 3, 2, 2, 2, 364, 366, 3, 2, 2, 2, 365, 339, 3, 2, 2, 2, 365, 340,
	3, 2, 2, 2, 366, 19, 3, 2, 2, 2, 367, 376, 7, 51, 2, 2, 368, 375, 5, 102,
	52, 2, 369, 375, 5, 84, 43, 2, 370, 375, 5, 90, 46, 2, 371, 375, 5, 100,
	51, 2, 372, 375, 5, 64, 33, 2, 373, 375, 5, 158, 80, 2, 374, 368, 3, 2,
	2, 2, 374, 369, 3, 2, 2, 2, 374, 370, 3, 2, 2, 2, 374, 371, 3, 2, 2, 2,
	374, 372, 3, 2, 2, 2, 374, 373, 3, 2, 2, 2, 375, 378, 3, 2, 2, 2, 376,
	374, 3, 2, 2, 2, 376, 377, 3, 2, 2, 2, 377, 379, 3, 2, 2, 2, 378, 376,
	3, 2, 2, 2, 379, 380, 7, 52, 2, 2, 380, 21, 3, 2, 2, 2, 381, 382, 7, 25,
	2, 2, 382, 23, 3, 2, 2, 2, 383, 386, 5, 10, 6, 2, 384, 385, 7, 27, 2, 2,
	385, 387, 5, 10, 6, 2, 386, 384, 3, 2, 2, 2, 386, 387, 3, 2, 2, 2, 387,
	25, 3, 2, 2, 2, 388, 391, 5, 10, 6, 2, 389, 390, 7, 27, 2, 2, 390, 392,
	5, 10, 6, 2, 391, 389, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 27, 3, 2,
	2, 2, 393, 396, 5, 10, 6, 2, 394, 395, 7, 27, 2, 2, 395, 397, 5, 10, 6,
	2, 396, 394, 3, 2, 2, 2, 396, 397, 3, 2, 2, 2, 397, 29, 3, 2, 2, 2, 398,
	401, 5, 10, 6, 2, 399, 400, 7, 27, 2, 2, 400, 402, 5, 10, 6, 2, 401, 399,
	3, 2, 2, 2, 401, 402, 3, 2, 2, 2, 402, 31, 3, 2, 2, 2, 403, 406, 5, 10,
	6, 2, 404, 405, 7, 27, 2, 2, 405, 407, 5, 10, 6, 2, 406, 404, 3, 2, 2,
	2, 406, 407, 3, 2, 2, 2, 407, 33, 3, 2, 2, 2, 408, 411, 5, 10, 6, 2, 409,
	410, 7, 27, 2, 2, 410, 412, 5, 10, 6, 2, 411, 409, 3, 2, 2, 2, 411, 412,
	3, 2, 2, 2, 412, 35, 3, 2, 2, 2, 413, 416, 5, 10, 6, 2, 414, 415, 7, 27,
	2, 2, 415, 417, 5, 10, 6, 2, 416, 414, 3, 2, 2, 2, 416, 417, 3, 2, 2, 2,
	417, 37, 3, 2, 2, 2, 418, 421, 5, 10, 6, 2, 419, 420, 7, 27, 2, 2, 420,
	422, 5, 10, 6, 2, 421, 419, 3, 2, 2, 2, 421, 422, 3, 2, 2, 2, 422, 39,
	3, 2, 2, 2, 423, 426, 5, 10, 6, 2, 424, 425, 7, 27, 2, 2, 425, 427, 5,
	10, 6, 2, 426, 424, 3, 2, 2, 2, 426, 427, 3, 2, 2, 2, 427, 41, 3, 2, 2,
	2, 428, 431, 5, 10, 6, 2, 429, 430, 7, 27, 2, 2, 430, 432, 5, 10, 6, 2,
	431, 429, 3, 2, 2, 2, 431, 432, 3, 2, 2, 2, 432, 43, 3, 2, 2, 2, 433, 436,
	5, 10, 6, 2, 434, 435, 7, 27, 2, 2, 435, 437, 5, 10, 6, 2, 436, 434, 3,
	2, 2, 2, 436, 437, 3, 2, 2, 2, 437, 45, 3, 2, 2, 2, 438, 441, 5, 10, 6,
	2, 439, 440, 7, 27, 2, 2, 440, 442, 5, 10, 6, 2, 441, 439, 3, 2, 2, 2,
	441, 442, 3, 2, 2, 2, 442, 47, 3, 2, 2, 2, 443, 446, 5, 10, 6, 2, 444,
	445, 7, 27, 2, 2, 445, 447, 5, 10, 6, 2, 446, 444, 3, 2, 2, 2, 446, 447,
	3, 2, 2, 2, 447, 49, 3, 2, 2, 2, 448, 449, 5, 10, 6, 2, 449, 51, 3, 2,
	2, 2, 450, 453, 5, 10, 6, 2, 451, 452, 7, 27, 2, 2, 452, 454, 5, 10, 6,
	2, 453, 451, 3, 2, 2, 2, 453, 454, 3, 2, 2, 2, 454, 53, 3, 2, 2, 2, 455,
	458, 5, 10, 6, 2, 456, 457, 7, 27, 2, 2, 457, 459, 5, 10, 6, 2, 458, 456,
	3, 2, 2, 2, 458, 459, 3, 2, 2, 2, 459, 55, 3, 2, 2, 2, 460, 465, 7, 105,
	2, 2, 461, 462, 7, 27, 2, 2, 462, 464, 7, 105, 2, 2, 463, 461, 3, 2, 2,
	2, 464, 467, 3, 2, 2, 2, 465, 463, 3, 2, 2, 2, 465, 466, 3, 2, 2, 2, 466,
	57, 3, 2, 2, 2, 467, 465, 3, 2, 2, 2, 468, 469, 7, 29, 2, 2, 469, 470,
	7, 94, 2, 2, 470, 496, 5, 10, 6, 2, 471, 497, 7, 85, 2, 2, 472, 473, 7,
	10, 2, 2, 473, 475, 5, 60, 31, 2, 474, 476, 7, 85, 2, 2, 475, 474, 3, 2,
	2, 2, 475, 476, 3, 2, 2, 2, 476, 495, 3, 2, 2, 2, 477, 478, 7, 32, 2, 2,
	478, 483, 5, 52, 27, 2, 479, 480, 7, 18, 2, 2, 480, 482, 5, 52, 27, 2,
	481, 479, 3, 2, 2, 2, 482, 485, 3, 2, 2, 2, 483, 481, 3, 2, 2, 2, 483,
	484, 3, 2, 2, 2, 484, 492, 3, 2, 2, 2, 485, 483, 3, 2, 2, 2, 486, 493,
	7, 85, 2, 2, 487, 488, 7, 96, 2, 2, 488, 490, 5, 60, 31, 2, 489, 491, 7,
	85, 2, 2, 490, 489, 3, 2, 2, 2, 490, 491, 3, 2, 2, 2, 491, 493, 3, 2, 2,
	2, 492, 486, 3, 2, 2, 2, 492, 487, 3, 2, 2, 2, 493, 495, 3, 2, 2, 2, 494,
	472, 3, 2, 2, 2, 494, 477, 3, 2, 2, 2, 495, 497, 3, 2, 2, 2, 496, 471,
	3, 2, 2, 2, 496, 494, 3, 2, 2, 2, 497, 59, 3, 2, 2, 2, 498, 503, 7, 51,
	2, 2, 499, 502, 5, 102, 52, 2, 500, 502, 5, 158, 80, 2, 501, 499, 3, 2,
	2, 2, 501, 500, 3, 2, 2, 2, 502, 505, 3, 2, 2, 2, 503, 501, 3, 2, 2, 2,
	503, 504, 3, 2, 2, 2, 504, 506, 3, 2, 2, 2, 505, 503, 3, 2, 2, 2, 506,
	507, 7, 52, 2, 2, 507, 61, 3, 2, 2, 2, 508, 509, 7, 41, 2, 2, 509, 510,
	7, 94, 2, 2, 510, 536, 5, 10, 6, 2, 511, 537, 7, 85, 2, 2, 512, 513, 7,
	10, 2, 2, 513, 515, 5, 66, 34, 2, 514, 516, 7, 85, 2, 2, 515, 514, 3, 2,
	2, 2, 515, 516, 3, 2, 2, 2, 516, 535, 3, 2, 2, 2, 517, 518, 7, 32, 2, 2,
	518, 523, 5, 36, 19, 2, 519, 520, 7, 18, 2, 2, 520, 522, 5, 36, 19, 2,
	521, 519, 3, 2, 2, 2, 522, 525, 3, 2, 2, 2, 523, 521, 3, 2, 2, 2, 523,
	524, 3, 2, 2, 2, 524, 532, 3, 2, 2, 2, 525, 523, 3, 2, 2, 2, 526, 533,
	7, 85, 2, 2, 527, 528, 7, 96, 2, 2, 528, 530, 5, 66, 34, 2, 529, 531, 7,
	85, 2, 2, 530, 529, 3, 2, 2, 2, 530, 531, 3, 2, 2, 2, 531, 533, 3, 2, 2,
	2, 532, 526, 3, 2, 2, 2, 532, 527, 3, 2, 2, 2, 533, 535, 3, 2, 2, 2, 534,
	512, 3, 2, 2, 2, 534, 517, 3, 2, 2, 2, 535, 537, 3, 2, 2, 2, 536, 511,
	3, 2, 2, 2, 536, 534, 3, 2, 2, 2, 537, 63, 3, 2, 2, 2, 538, 539, 7, 41,
	2, 2, 539, 549, 5, 10, 6, 2, 540, 541, 7, 17, 2, 2, 541, 546, 5, 36, 19,
	2, 542, 543, 7, 18, 2, 2, 543, 545, 5, 36, 19, 2, 544, 542, 3, 2, 2, 2,
	545, 548, 3, 2, 2, 2, 546, 544, 3, 2, 2, 2, 546, 547, 3, 2, 2, 2, 547,
	550, 3, 2, 2, 2, 548, 546, 3, 2, 2, 2, 549, 540, 3, 2, 2, 2, 549, 550,
	3, 2, 2, 2, 550, 577, 3, 2, 2, 2, 551, 578, 7, 85, 2, 2, 552, 575, 7, 10,
	2, 2, 553, 555, 5, 66, 34, 2, 554, 556, 7, 85, 2, 2, 555, 554, 3, 2, 2,
	2, 555, 556, 3, 2, 2, 2, 556, 576, 3, 2, 2, 2, 557, 558, 7, 61, 2, 2, 558,
	563, 5, 38, 20, 2, 559, 560, 7, 18, 2, 2, 560, 562, 5, 38, 20, 2, 561,
	559, 3, 2, 2, 2, 562, 565, 3, 2, 2, 2, 563, 561, 3, 2, 2, 2, 563, 564,
	3, 2, 2, 2, 564, 573, 3, 2, 2, 2, 565, 563, 3, 2, 2, 2, 566, 574, 7, 85,
	2, 2, 567, 568, 7, 31, 2, 2, 568, 569, 7, 96, 2, 2, 569, 571, 5, 66, 34,
	2, 570, 572, 7, 85, 2, 2, 571, 570, 3, 2, 2, 2, 571, 572, 3, 2, 2, 2, 572,
	574, 3, 2, 2, 2, 573, 566, 3, 2, 2, 2, 573, 567, 3, 2, 2, 2, 574, 576,
	3, 2, 2, 2, 575, 553, 3, 2, 2, 2, 575, 557, 3, 2, 2, 2, 576, 578, 3, 2,
	2, 2, 577, 551, 3, 2, 2, 2, 577, 552, 3, 2, 2, 2, 578, 65, 3, 2, 2, 2,
	579, 585, 7, 51, 2, 2, 580, 584, 5, 68, 35, 2, 581, 584, 5, 102, 52, 2,
	582, 584, 5, 158, 80, 2, 583, 580, 3, 2, 2, 2, 583, 581, 3, 2, 2, 2, 583,
	582, 3, 2, 2, 2, 584, 587, 3, 2, 2, 2, 585, 583, 3, 2, 2, 2, 585, 586,
	3, 2, 2, 2, 586, 588, 3, 2, 2, 2, 587, 585, 3, 2, 2, 2, 588, 589, 7, 52,
	2, 2, 589, 67, 3, 2, 2, 2, 590, 591, 7, 62, 2, 2, 591, 600, 7, 51, 2, 2,
	592, 597, 5, 56, 29, 2, 593, 594, 7, 18, 2, 2, 594, 596, 5, 56, 29, 2,
	595, 593, 3, 2, 2, 2, 596, 599, 3, 2, 2, 2, 597, 595, 3, 2, 2, 2, 597,
	598, 3, 2, 2, 2, 598, 601, 3, 2, 2, 2, 599, 597, 3, 2, 2, 2, 600, 592,
	3, 2, 2, 2, 600, 601, 3, 2, 2, 2, 601, 602, 3, 2, 2, 2, 602, 604, 7, 52,
	2, 2, 603, 605, 7, 85, 2, 2, 604, 603, 3, 2, 2, 2, 604, 605, 3, 2, 2, 2,
	605, 69, 3, 2, 2, 2, 606, 607, 7, 70, 2, 2, 607, 608, 7, 94, 2, 2, 608,
	634, 5, 10, 6, 2, 609, 635, 7, 85, 2, 2, 610, 611, 7, 10, 2, 2, 611, 613,
	5, 74, 38, 2, 612, 614, 7, 85, 2, 2, 613, 612, 3, 2, 2, 2, 613, 614, 3,
	2, 2, 2, 614, 633, 3, 2, 2, 2, 615, 616, 7, 32, 2, 2, 616, 621, 5, 32,
	17, 2, 617, 618, 7, 18, 2, 2, 618, 620, 5, 32, 17, 2, 619, 617, 3, 2, 2,
	2, 620, 623, 3, 2, 2, 2, 621, 619, 3, 2, 2, 2, 621, 622, 3, 2, 2, 2, 622,
	630, 3, 2, 2, 2, 623, 621, 3, 2, 2, 2, 624, 631, 7, 85, 2, 2, 625, 626,
	7, 96, 2, 2, 626, 628, 5, 74, 38, 2, 627, 629, 7, 85, 2, 2, 628, 627, 3,
	2, 2, 2, 628, 629, 3, 2, 2, 2, 629, 631, 3, 2, 2, 2, 630, 624, 3, 2, 2,
	2, 630, 625, 3, 2, 2, 2, 631, 633, 3, 2, 2, 2, 632, 610, 3, 2, 2, 2, 632,
	615, 3, 2, 2, 2, 633, 635, 3, 2, 2, 2, 634, 609, 3, 2, 2, 2, 634, 632,
	3, 2, 2, 2, 635, 71, 3, 2, 2, 2, 636, 637, 7, 70, 2, 2, 637, 647, 5, 10,
	6, 2, 638, 639, 7, 17, 2, 2, 639, 644, 5, 32, 17, 2, 640, 641, 7, 18, 2,
	2, 641, 643, 5, 32, 17, 2, 642, 640, 3, 2, 2, 2, 643, 646, 3, 2, 2, 2,
	644, 642, 3, 2, 2, 2, 644, 645, 3, 2, 2, 2, 645, 648, 3, 2, 2, 2, 646,
	644, 3, 2, 2, 2, 647, 638, 3, 2, 2, 2, 647, 648, 3, 2, 2, 2, 648, 677,
	3, 2, 2, 2, 649, 651, 7, 85, 2, 2, 650, 649, 3, 2, 2, 2, 650, 651, 3, 2,
	2, 2, 651, 678, 3, 2, 2, 2, 652, 675, 7, 10, 2, 2, 653, 655, 5, 74, 38,
	2, 654, 656, 7, 85, 2, 2, 655, 654, 3, 2, 2, 2, 655, 656, 3, 2, 2, 2, 656,
	676, 3, 2, 2, 2, 657, 658, 7, 61, 2, 2, 658, 663, 5, 34, 18, 2, 659, 660,
	7, 18, 2, 2, 660, 662, 5, 34, 18, 2, 661, 659, 3, 2, 2, 2, 662, 665, 3,
	2, 2, 2, 663, 661, 3, 2, 2, 2, 663, 664, 3, 2, 2, 2, 664, 673, 3, 2, 2,
	2, 665, 663, 3, 2, 2, 2, 666, 674, 7, 85, 2, 2, 667, 668, 7, 31, 2, 2,
	668, 669, 7, 96, 2, 2, 669, 671, 5, 74, 38, 2, 670, 672, 7, 85, 2, 2, 671,
	670, 3, 2, 2, 2, 671, 672, 3, 2, 2, 2, 672, 674, 3, 2, 2, 2, 673, 666,
	3, 2, 2, 2, 673, 667, 3, 2, 2, 2, 674, 676, 3, 2, 2, 2, 675, 653, 3, 2,
	2, 2, 675, 657, 3, 2, 2, 2, 676, 678, 3, 2, 2, 2, 677, 650, 3, 2, 2, 2,
	677, 652, 3, 2, 2, 2, 678, 73, 3, 2, 2, 2, 679, 685, 7, 51, 2, 2, 680,
	684, 5, 102, 52, 2, 681, 684, 5, 158, 80, 2, 682, 684, 5, 94, 48, 2, 683,
	680, 3, 2, 2, 2, 683, 681, 3, 2, 2, 2, 683, 682, 3, 2, 2, 2, 684, 687,
	3, 2, 2, 2, 685, 683, 3, 2, 2, 2, 685, 686, 3, 2, 2, 2, 686, 688, 3, 2,
	2, 2, 687, 685, 3, 2, 2, 2, 688, 689, 7, 52, 2, 2, 689, 75, 3, 2, 2, 2,
	690, 691, 7, 80, 2, 2, 691, 692, 7, 94, 2, 2, 692, 718, 5, 10, 6, 2, 693,
	719, 7, 85, 2, 2, 694, 695, 7, 10, 2, 2, 695, 697, 5, 80, 41, 2, 696, 698,
	7, 85, 2, 2, 697, 696, 3, 2, 2, 2, 697, 698, 3, 2, 2, 2, 698, 717, 3, 2,
	2, 2, 699, 700, 7, 32, 2, 2, 700, 705, 5, 40, 21, 2, 701, 702, 7, 18, 2,
	2, 702, 704, 5, 40, 21, 2, 703, 701, 3, 2, 2, 2, 704, 707, 3, 2, 2, 2,
	705, 703, 3, 2, 2, 2, 705, 706, 3, 2, 2, 2, 706, 714, 3, 2, 2, 2, 707,
	705, 3, 2, 2, 2, 708, 715, 7, 85, 2, 2, 709, 710, 7, 96, 2, 2, 710, 712,
	5, 80, 41, 2, 711, 713, 7, 85, 2, 2, 712, 711, 3, 2, 2, 2, 712, 713, 3,
	2, 2, 2, 713, 715, 3, 2, 2, 2, 714, 708, 3, 2, 2, 2, 714, 709, 3, 2, 2,
	2, 715, 717, 3, 2, 2, 2, 716, 694, 3, 2, 2, 2, 716, 699, 3, 2, 2, 2, 717,
	719, 3, 2, 2, 2, 718, 693, 3, 2, 2, 2, 718, 716, 3, 2, 2, 2, 719, 77, 3,
	2, 2, 2, 720, 721, 7, 80, 2, 2, 721, 731, 5, 10, 6, 2, 722, 723, 7, 17,
	2, 2, 723, 728, 5, 40, 21, 2, 724, 725, 7, 18, 2, 2, 725, 727, 5, 40, 21,
	2, 726, 724, 3, 2, 2, 2, 727, 730, 3, 2, 2, 2, 728, 726, 3, 2, 2, 2, 728,
	729, 3, 2, 2, 2, 729, 732, 3, 2, 2, 2, 730, 728, 3, 2, 2, 2, 731, 722,
	3, 2, 2, 2, 731, 732, 3, 2, 2, 2, 732, 759, 3, 2, 2, 2, 733, 760, 7, 85,
	2, 2, 734, 757, 7, 10, 2, 2, 735, 737, 5, 80, 41, 2, 736, 738, 7, 85, 2,
	2, 737, 736, 3, 2, 2, 2, 737, 738, 3, 2, 2, 2, 738, 758, 3, 2, 2, 2, 739,
	740, 7, 61, 2, 2, 740, 745, 5, 42, 22, 2, 741, 742, 7, 18, 2, 2, 742, 744,
	5, 42, 22, 2, 743, 741, 3, 2, 2, 2, 744, 747, 3, 2, 2, 2, 745, 743, 3,
	2, 2, 2, 745, 746, 3, 2, 2, 2, 746, 755, 3, 2, 2, 2, 747, 745, 3, 2, 2,
	2, 748, 756, 7, 85, 2, 2, 749, 750, 7, 31, 2, 2, 750, 751, 7, 96, 2, 2,
	751, 753, 5, 80, 41, 2, 752, 754, 7, 85, 2, 2, 753, 752, 3, 2, 2, 2, 753,
	754, 3, 2, 2, 2, 754, 756, 3, 2, 2, 2, 755, 748, 3, 2, 2, 2, 755, 749,
	3, 2, 2, 2, 756, 758, 3, 2, 2, 2, 757, 735, 3, 2, 2, 2, 757, 739, 3, 2,
	2, 2, 758, 760, 3, 2, 2, 2, 759, 733, 3, 2, 2, 2, 759, 734, 3, 2, 2, 2,
	760, 79, 3, 2, 2, 2, 761, 767, 7, 51, 2, 2, 762, 766, 5, 102, 52, 2, 763,
	766, 5, 158, 80, 2, 764, 766, 5, 94, 48, 2, 765, 762, 3, 2, 2, 2, 765,
	763, 3, 2, 2, 2, 765, 764, 3, 2, 2, 2, 766, 769, 3, 2, 2, 2, 767, 765,
	3, 2, 2, 2, 767, 768, 3, 2, 2, 2, 768, 770, 3, 2, 2, 2, 769, 767, 3, 2,
	2, 2, 770, 771, 7, 52, 2, 2, 771, 81, 3, 2, 2, 2, 772, 773, 7, 20, 2, 2,
	773, 774, 7, 94, 2, 2, 774, 800, 5, 10, 6, 2, 775, 801, 7, 85, 2, 2, 776,
	777, 7, 10, 2, 2, 777, 779, 5, 86, 44, 2, 778, 780, 7, 85, 2, 2, 779, 778,
	3, 2, 2, 2, 779, 780, 3, 2, 2, 2, 780, 799, 3, 2, 2, 2, 781, 782, 7, 32,
	2, 2, 782, 787, 5, 24, 13, 2, 783, 784, 7, 18, 2, 2, 784, 786, 5, 24, 13,
	2, 785, 783, 3, 2, 2, 2, 786, 789, 3, 2, 2, 2, 787, 785, 3, 2, 2, 2, 787,
	788, 3, 2, 2, 2, 788, 796, 3, 2, 2, 2, 789, 787, 3, 2, 2, 2, 790, 797,
	7, 85, 2, 2, 791, 792, 7, 96, 2, 2, 792, 794, 5, 86, 44, 2, 793, 795, 7,
	85, 2, 2, 794, 793, 3, 2, 2, 2, 794, 795, 3, 2, 2, 2, 795, 797, 3, 2, 2,
	2, 796, 790, 3, 2, 2, 2, 796, 791, 3, 2, 2, 2, 797, 799, 3, 2, 2, 2, 798,
	776, 3, 2, 2, 2, 798, 781, 3, 2, 2, 2, 799, 801, 3, 2, 2, 2, 800, 775,
	3, 2, 2, 2, 800, 798, 3, 2, 2, 2, 801, 83, 3, 2, 2, 2, 802, 803, 7, 20,
	2, 2, 803, 813, 5, 10, 6, 2, 804, 805, 7, 17, 2, 2, 805, 810, 5, 24, 13,
	2, 806, 807, 7, 18, 2, 2, 807, 809, 5, 24, 13, 2, 808, 806, 3, 2, 2, 2,
	809, 812, 3, 2, 2, 2, 810, 808, 3, 2, 2, 2, 810, 811, 3, 2, 2, 2, 811,
	814, 3, 2, 2, 2, 812, 810, 3, 2, 2, 2, 813, 804, 3, 2, 2, 2, 813, 814,
	3, 2, 2, 2, 814, 841, 3, 2, 2, 2, 815, 842, 7, 85, 2, 2, 816, 839, 7, 10,
	2, 2, 817, 819, 5, 86, 44, 2, 818, 820, 7, 85, 2, 2, 819, 818, 3, 2, 2,
	2, 819, 820, 3, 2, 2, 2, 820, 840, 3, 2, 2, 2, 821, 822, 7, 61, 2, 2, 822,
	827, 5, 26, 14, 2, 823, 824, 7, 18, 2, 2, 824, 826, 5, 26, 14, 2, 825,
	823, 3, 2, 2, 2, 826, 829, 3, 2, 2, 2, 827, 825, 3, 2, 2, 2, 827, 828,
	3, 2, 2, 2, 828, 837, 3, 2, 2, 2, 829, 827, 3, 2, 2, 2, 830, 838, 7, 85,
	2, 2, 831, 832, 7, 31, 2, 2, 832, 833, 7, 96, 2, 2, 833, 835, 5, 86, 44,
	2, 834, 836, 7, 85, 2, 2, 835, 834, 3, 2, 2, 2, 835, 836, 3, 2, 2, 2, 836,
	838, 3, 2, 2, 2, 837, 830, 3, 2, 2, 2, 837, 831, 3, 2, 2, 2, 838, 840,
	3, 2, 2, 2, 839, 817, 3, 2, 2, 2, 839, 821, 3, 2, 2, 2, 840, 842, 3, 2,
	2, 2, 841, 815, 3, 2, 2, 2, 841, 816, 3, 2, 2, 2, 842, 85, 3, 2, 2, 2,
	843, 850, 7, 51, 2, 2, 844, 849, 5, 102, 52, 2, 845, 849, 5, 72, 37, 2,
	846, 849, 5, 158, 80, 2, 847, 849, 5, 94, 48, 2, 848, 844, 3, 2, 2, 2,
	848, 845, 3, 2, 2, 2, 848, 846, 3, 2, 2, 2, 848, 847, 3, 2, 2, 2, 849,
	852, 3, 2, 2, 2, 850, 848, 3, 2, 2, 2, 850, 851, 3, 2, 2, 2, 851, 853,
	3, 2, 2, 2, 852, 850, 3, 2, 2, 2, 853, 854, 7, 52, 2, 2, 854, 87, 3, 2,
	2, 2, 855, 856, 7, 22, 2, 2, 856, 857, 7, 94, 2, 2, 857, 883, 5, 10, 6,
	2, 858, 884, 7, 85, 2, 2, 859, 860, 7, 10, 2, 2, 860, 862, 5, 92, 47, 2,
	861, 863, 7, 85, 2, 2, 862, 861, 3, 2, 2, 2, 862, 863, 3, 2, 2, 2, 863,
	882, 3, 2, 2, 2, 864, 865, 7, 32, 2, 2, 865, 870, 5, 28, 15, 2, 866, 867,
	7, 18, 2, 2, 867, 869, 5, 28, 15, 2, 868, 866, 3, 2, 2, 2, 869, 872, 3,
	2, 2, 2, 870, 868, 3, 2, 2, 2, 870, 871, 3, 2, 2, 2, 871, 879, 3, 2, 2,
	2, 872, 870, 3, 2, 2, 2, 873, 880, 7, 85, 2, 2, 874, 875, 7, 96, 2, 2,
	875, 877, 5, 92, 47, 2, 876, 878, 7, 85, 2, 2, 877, 876, 3, 2, 2, 2, 877,
	878, 3, 2, 2, 2, 878, 880, 3, 2, 2, 2, 879, 873, 3, 2, 2, 2, 879, 874,
	3, 2, 2, 2, 880, 882, 3, 2, 2, 2, 881, 859, 3, 2, 2, 2, 881, 864, 3, 2,
	2, 2, 882, 884, 3, 2, 2, 2, 883, 858, 3, 2, 2, 2, 883, 881, 3, 2, 2, 2,
	884, 89, 3, 2, 2, 2, 885, 886, 7, 22, 2, 2, 886, 896, 5, 10, 6, 2, 887,
	888, 7, 17, 2, 2, 888, 893, 5, 28, 15, 2, 889, 890, 7, 18, 2, 2, 890, 892,
	5, 28, 15, 2, 891, 889, 3, 2, 2, 2, 892, 895, 3, 2, 2, 2, 893, 891, 3,
	2, 2, 2, 893, 894, 3, 2, 2, 2, 894, 897, 3, 2, 2, 2, 895, 893, 3, 2, 2,
	2, 896, 887, 3, 2, 2, 2, 896, 897, 3, 2, 2, 2, 897, 924, 3, 2, 2, 2, 898,
	925, 7, 85, 2, 2, 899, 922, 7, 10, 2, 2, 900, 902, 5, 92, 47, 2, 901, 903,
	7, 85, 2, 2, 902, 901, 3, 2, 2, 2, 902, 903, 3, 2, 2, 2, 903, 923, 3, 2,
	2, 2, 904, 905, 7, 61, 2, 2, 905, 910, 5, 30, 16, 2, 906, 907, 7, 18, 2,
	2, 907, 909, 5, 30, 16, 2, 908, 906, 3, 2, 2, 2, 909, 912, 3, 2, 2, 2,
	910, 908, 3, 2, 2, 2, 910, 911, 3, 2, 2, 2, 911, 920, 3, 2, 2, 2, 912,
	910, 3, 2, 2, 2, 913, 921, 7, 85, 2, 2, 914, 915, 7, 31, 2, 2, 915, 916,
	7, 96, 2, 2, 916, 918, 5, 92, 47, 2, 917, 919, 7, 85, 2, 2, 918, 917, 3,
	2, 2, 2, 918, 919, 3, 2, 2, 2, 919, 921, 3, 2, 2, 2, 920, 913, 3, 2, 2,
	2, 920, 914, 3, 2, 2, 2, 921, 923, 3, 2, 2, 2, 922, 900, 3, 2, 2, 2, 922,
	904, 3, 2, 2, 2, 923, 925, 3, 2, 2, 2, 924, 898, 3, 2, 2, 2, 924, 899,
	3, 2, 2, 2, 925, 91, 3, 2, 2, 2, 926, 933, 7, 51, 2, 2, 927, 932, 5, 102,
	52, 2, 928, 932, 5, 78, 40, 2, 929, 932, 5, 158, 80, 2, 930, 932, 5, 94,
	48, 2, 931, 927, 3, 2, 2, 2, 931, 928, 3, 2, 2, 2, 931, 929, 3, 2, 2, 2,
	931, 930, 3, 2, 2, 2, 932, 935, 3, 2, 2, 2, 933, 931, 3, 2, 2, 2, 933,
	934, 3, 2, 2, 2, 934, 936, 3, 2, 2, 2, 935, 933, 3, 2, 2, 2, 936, 937,
	7, 52, 2, 2, 937, 93, 3, 2, 2, 2, 938, 941, 7, 77, 2, 2, 939, 940, 7, 105,
	2, 2, 940, 942, 7, 10, 2, 2, 941, 939, 3, 2, 2, 2, 941, 942, 3, 2, 2, 2,
	942, 943, 3, 2, 2, 2, 943, 944, 7, 51, 2, 2, 944, 946, 5, 18, 10, 2, 945,
	947, 5, 96, 49, 2, 946, 945, 3, 2, 2, 2, 946, 947, 3, 2, 2, 2, 947, 948,
	3, 2, 2, 2, 948, 950, 7, 52, 2, 2, 949, 951, 7, 85, 2, 2, 950, 949, 3,
	2, 2, 2, 950, 951, 3, 2, 2, 2, 951, 95, 3, 2, 2, 2, 952, 953, 7, 16, 2,
	2, 953, 957, 7, 51, 2, 2, 954, 956, 5, 98, 50, 2, 955, 954, 3, 2, 2, 2,
	956, 959, 3, 2, 2, 2, 957, 955, 3, 2, 2, 2, 957, 958, 3, 2, 2, 2, 958,
	960, 3, 2, 2, 2, 959, 957, 3, 2, 2, 2, 960, 962, 7, 52, 2, 2, 961, 963,
	7, 85, 2, 2, 962, 961, 3, 2, 2, 2, 962, 963, 3, 2, 2, 2, 963, 97, 3, 2,
	2, 2, 964, 965, 5, 56, 29, 2, 965, 966, 7, 93, 2, 2, 966, 972, 5, 56, 29,
	2, 967, 968, 7, 51, 2, 2, 968, 969, 5, 102, 52, 2, 969, 970, 5, 138, 70,
	2, 970, 971, 7, 52, 2, 2, 971, 973, 3, 2, 2, 2, 972, 967, 3, 2, 2, 2, 972,
	973, 3, 2, 2, 2, 973, 974, 3, 2, 2, 2, 974, 975, 7, 85, 2, 2, 975, 99,
	3, 2, 2, 2, 976, 977, 7, 11, 2, 2, 977, 978, 5, 56, 29, 2, 978, 979, 7,
	93, 2, 2, 979, 980, 5, 56, 29, 2, 980, 981, 7, 85, 2, 2, 981, 101, 3, 2,
	2, 2, 982, 983, 7, 72, 2, 2, 983, 986, 5, 10, 6, 2, 984, 985, 7, 17, 2,
	2, 985, 987, 5, 130, 66, 2, 986, 984, 3, 2, 2, 2, 986, 987, 3, 2, 2, 2,
	987, 992, 3, 2, 2, 2, 988, 989, 7, 10, 2, 2, 989, 993, 5, 104, 53, 2, 990,
	991, 7, 23, 2, 2, 991, 993, 5, 104, 53, 2, 992, 988, 3, 2, 2, 2, 992, 990,
	3, 2, 2, 2, 992, 993, 3, 2, 2, 2, 993, 995, 3, 2, 2, 2, 994, 996, 5, 138,
	70, 2, 995, 994, 3, 2, 2, 2, 995, 996, 3, 2, 2, 2, 996, 997, 3, 2, 2, 2,
	997, 998, 7, 85, 2, 2, 998, 103, 3, 2, 2, 2, 999, 1009, 7, 103, 2, 2, 1000,
	1009, 7, 102, 2, 2, 1001, 1009, 7, 104, 2, 2, 1002, 1009, 7, 100, 2, 2,
	1003, 1009, 7, 99, 2, 2, 1004, 1009, 5, 112, 57, 2, 1005, 1009, 5, 116,
	59, 2, 1006, 1009, 5, 118, 60, 2, 1007, 1009, 5, 106, 54, 2, 1008, 999,
	3, 2, 2, 2, 1008, 1000, 3, 2, 2, 2, 1008, 1001, 3, 2, 2, 2, 1008, 1002,
	3, 2, 2, 2, 1008, 1003, 3, 2, 2, 2, 1008, 1004, 3, 2, 2, 2, 1008, 1005,
	3, 2, 2, 2, 1008, 1006, 3, 2, 2, 2, 1008, 1007, 3, 2, 2, 2, 1009, 105,
	3, 2, 2, 2, 1010, 1011, 7, 105, 2, 2, 1011, 107, 3, 2, 2, 2, 1012, 1017,
	7, 105, 2, 2, 1013, 1014, 7, 27, 2, 2, 1014, 1016, 7, 105, 2, 2, 1015,
	1013, 3, 2, 2, 2, 1016, 1019, 3, 2, 2, 2, 1017, 1015, 3, 2, 2, 2, 1017,
	1018, 3, 2, 2, 2, 1018, 1022, 3, 2, 2, 2, 1019, 1017, 3, 2, 2, 2, 1020,
	1022, 5, 110, 56, 2, 1021, 1012, 3, 2, 2, 2, 1021, 1020, 3, 2, 2, 2, 1022,
	109, 3, 2, 2, 2, 1023, 1027, 5, 112, 57, 2, 1024, 1027, 5, 116, 59, 2,
	1025, 1027, 5, 118, 60, 2, 1026, 1023, 3, 2, 2, 2, 1026, 1024, 3, 2, 2,
	2, 1026, 1025, 3, 2, 2, 2, 1027, 111, 3, 2, 2, 2, 1028, 1037, 7, 51, 2,
	2, 1029, 1034, 5, 104, 53, 2, 1030, 1031, 7, 18, 2, 2, 1031, 1033, 5, 104,
	53, 2, 1032, 1030, 3, 2, 2, 2, 1033, 1036, 3, 2, 2, 2, 1034, 1032, 3, 2,
	2, 2, 1034, 1035, 3, 2, 2, 2, 1035, 1038, 3, 2, 2, 2, 1036, 1034, 3, 2,
	2, 2, 1037, 1029, 3, 2, 2, 2, 1037, 1038, 3, 2, 2, 2, 1038, 1039, 3, 2,
	2, 2, 1039, 1040, 7, 52, 2, 2, 1040, 113, 3, 2, 2, 2, 1041, 1044, 5, 10,
	6, 2, 1042, 1043, 7, 17, 2, 2, 1043, 1045, 5, 130, 66, 2, 1044, 1042, 3,
	2, 2, 2, 1044, 1045, 3, 2, 2, 2, 1045, 1046, 3, 2, 2, 2, 1046, 1047, 7,
	10, 2, 2, 1047, 1048, 5, 104, 53, 2, 1048, 115, 3, 2, 2, 2, 1049, 1061,
	7, 53, 2, 2, 1050, 1055, 5, 114, 58, 2, 1051, 1052, 7, 85, 2, 2, 1052,
	1054, 5, 114, 58, 2, 1053, 1051, 3, 2, 2, 2, 1054, 1057, 3, 2, 2, 2, 1055,
	1053, 3, 2, 2, 2, 1055, 1056, 3, 2, 2, 2, 1056, 1059, 3, 2, 2, 2, 1057,
	1055, 3, 2, 2, 2, 1058, 1060, 7, 85, 2, 2, 1059, 1058, 3, 2, 2, 2, 1059,
	1060, 3, 2, 2, 2, 1060, 1062, 3, 2, 2, 2, 1061, 1050, 3, 2, 2, 2, 1061,
	1062, 3, 2, 2, 2, 1062, 1063, 3, 2, 2, 2, 1063, 1064, 7, 54, 2, 2, 1064,
	117, 3, 2, 2, 2, 1065, 1074, 7, 57, 2, 2, 1066, 1071, 5, 104, 53, 2, 1067,
	1068, 7, 18, 2, 2, 1068, 1070, 5, 104, 53, 2, 1069, 1067, 3, 2, 2, 2, 1070,
	1073, 3, 2, 2, 2, 1071, 1069, 3, 2, 2, 2, 1071, 1072, 3, 2, 2, 2, 1072,
	1075, 3, 2, 2, 2, 1073, 1071, 3, 2, 2, 2, 1074, 1066, 3, 2, 2, 2, 1074,
	1075, 3, 2, 2, 2, 1075, 1076, 3, 2, 2, 2, 1076, 1077, 7, 58, 2, 2, 1077,
	119, 3, 2, 2, 2, 1078, 1079, 7, 76, 2, 2, 1079, 1083, 7, 53, 2, 2, 1080,
	1082, 5, 128, 65, 2, 1081, 1080, 3, 2, 2, 2, 1082, 1085, 3, 2, 2, 2, 1083,
	1081, 3, 2, 2, 2, 1083, 1084, 3, 2, 2, 2, 1084, 1086, 3, 2, 2, 2, 1085,
	1083, 3, 2, 2, 2, 1086, 1087, 7, 54, 2, 2, 1087, 121, 3, 2, 2, 2, 1088,
	1089, 7, 86, 2, 2, 1089, 1091, 7, 51, 2, 2, 1090, 1092, 5, 222, 112, 2,
	1091, 1090, 3, 2, 2, 2, 1091, 1092, 3, 2, 2, 2, 1092, 1093, 3, 2, 2, 2,
	1093, 1094, 7, 52, 2, 2, 1094, 123, 3, 2, 2, 2, 1095, 1096, 7, 83, 2, 2,
	1096, 1098, 7, 57, 2, 2, 1097, 1099, 5, 130, 66, 2, 1098, 1097, 3, 2, 2,
	2, 1098, 1099, 3, 2, 2, 2, 1099, 1100, 3, 2, 2, 2, 1100, 1101, 7, 58, 2,
	2, 1101, 125, 3, 2, 2, 2, 1102, 1103, 7, 30, 2, 2, 1103, 1104, 7, 51, 2,
	2, 1104, 1109, 5, 10, 6, 2, 1105, 1106, 7, 18, 2, 2, 1106, 1108, 5, 10,
	6, 2, 1107, 1105, 3, 2, 2, 2, 1108, 1111, 3, 2, 2, 2, 1109, 1107, 3, 2,
	2, 2, 1109, 1110, 3, 2, 2, 2, 1110, 1112, 3, 2, 2, 2, 1111, 1109, 3, 2,
	2, 2, 1112, 1113, 7, 52, 2, 2, 1113, 127, 3, 2, 2, 2, 1114, 1115, 5, 10,
	6, 2, 1115, 1116, 7, 17, 2, 2, 1116, 1117, 5, 130, 66, 2, 1117, 1118, 7,
	85, 2, 2, 1118, 129, 3, 2, 2, 2, 1119, 1122, 5, 132, 67, 2, 1120, 1122,
	5, 54, 28, 2, 1121, 1119, 3, 2, 2, 2, 1121, 1120, 3, 2, 2, 2, 1122, 131,
	3, 2, 2, 2, 1123, 1134, 5, 142, 72, 2, 1124, 1134, 5, 140, 71, 2, 1125,
	1134, 5, 144, 73, 2, 1126, 1134, 5, 146, 74, 2, 1127, 1134, 5, 148, 75,
	2, 1128, 1134, 5, 150, 76, 2, 1129, 1134, 5, 120, 61, 2, 1130, 1134, 5,
	122, 62, 2, 1131, 1134, 5, 124, 63, 2, 1132, 1134, 5, 126, 64, 2, 1133,
	1123, 3, 2, 2, 2, 1133, 1124, 3, 2, 2, 2, 1133, 1125, 3, 2, 2, 2, 1133,
	1126, 3, 2, 2, 2, 1133, 1127, 3, 2, 2, 2, 1133, 1128, 3, 2, 2, 2, 1133,
	1129, 3, 2, 2, 2, 1133, 1130, 3, 2, 2, 2, 1133, 1131, 3, 2, 2, 2, 1133,
	1132, 3, 2, 2, 2, 1134, 133, 3, 2, 2, 2, 1135, 1136, 7, 72, 2, 2, 1136,
	1137, 7, 94, 2, 2, 1137, 1154, 5, 10, 6, 2, 1138, 1155, 7, 85, 2, 2, 1139,
	1150, 7, 10, 2, 2, 1140, 1151, 5, 140, 71, 2, 1141, 1151, 5, 144, 73, 2,
	1142, 1151, 5, 146, 74, 2, 1143, 1151, 5, 148, 75, 2, 1144, 1151, 5, 150,
	76, 2, 1145, 1151, 5, 120, 61, 2, 1146, 1151, 5, 122, 62, 2, 1147, 1151,
	5, 124, 63, 2, 1148, 1151, 5, 126, 64, 2, 1149, 1151, 5, 142, 72, 2, 1150,
	1140, 3, 2, 2, 2, 1150, 1141, 3, 2, 2, 2, 1150, 1142, 3, 2, 2, 2, 1150,
	1143, 3, 2, 2, 2, 1150, 1144, 3, 2, 2, 2, 1150, 1145, 3, 2, 2, 2, 1150,
	1146, 3, 2, 2, 2, 1150, 1147, 3, 2, 2, 2, 1150, 1148, 3, 2, 2, 2, 1150,
	1149, 3, 2, 2, 2, 1151, 1152, 3, 2, 2, 2, 1152, 1153, 7, 85, 2, 2, 1153,
	1155, 3, 2, 2, 2, 1154, 1138, 3, 2, 2, 2, 1154, 1139, 3, 2, 2, 2, 1155,
	135, 3, 2, 2, 2, 1156, 1159, 5, 10, 6, 2, 1157, 1158, 7, 17, 2, 2, 1158,
	1160, 5, 130, 66, 2, 1159, 1157, 3, 2, 2, 2, 1159, 1160, 3, 2, 2, 2, 1160,
	1165, 3, 2, 2, 2, 1161, 1162, 7, 10, 2, 2, 1162, 1166, 5, 104, 53, 2, 1163,
	1164, 7, 23, 2, 2, 1164, 1166, 5, 104, 53, 2, 1165, 1161, 3, 2, 2, 2, 1165,
	1163, 3, 2, 2, 2, 1165, 1166, 3, 2, 2, 2, 1166, 1167, 3, 2, 2, 2, 1167,
	1168, 7, 85, 2, 2, 1168, 137, 3, 2, 2, 2, 1169, 1171, 7, 74, 2, 2, 1170,
	1172, 5, 136, 69, 2, 1171, 1170, 3, 2, 2, 2, 1172, 1173, 3, 2, 2, 2, 1173,
	1171, 3, 2, 2, 2, 1173, 1174, 3, 2, 2, 2, 1174, 1175, 3, 2, 2, 2, 1175,
	1176, 7, 75, 2, 2, 1176, 139, 3, 2, 2, 2, 1177, 1178, 7, 48, 2, 2, 1178,
	141, 3, 2, 2, 2, 1179, 1180, 7, 9, 2, 2, 1180, 143, 3, 2, 2, 2, 1181, 1182,
	7, 40, 2, 2, 1182, 145, 3, 2, 2, 2, 1183, 1184, 7, 28, 2, 2, 1184, 147,
	3, 2, 2, 2, 1185, 1186, 7, 90, 2, 2, 1186, 149, 3, 2, 2, 2, 1187, 1188,
	7, 101, 2, 2, 1188, 151, 3, 2, 2, 2, 1189, 1190, 7, 97, 2, 2, 1190, 1193,
	5, 10, 6, 2, 1191, 1192, 7, 17, 2, 2, 1192, 1194, 5, 44, 23, 2, 1193, 1191,
	3, 2, 2, 2, 1193, 1194, 3, 2, 2, 2, 1194, 1214, 3, 2, 2, 2, 1195, 1215,
	7, 85, 2, 2, 1196, 1212, 7, 10, 2, 2, 1197, 1199, 5, 156, 79, 2, 1198,
	1200, 7, 85, 2, 2, 1199, 1198, 3, 2, 2, 2, 1199, 1200, 3, 2, 2, 2, 1200,
	1213, 3, 2, 2, 2, 1201, 1202, 7, 61, 2, 2, 1202, 1210, 5, 46, 24, 2, 1203,
	1211, 7, 85, 2, 2, 1204, 1205, 7, 31, 2, 2, 1205, 1206, 7, 96, 2, 2, 1206,
	1208, 5, 156, 79, 2, 1207, 1209, 7, 85, 2, 2, 1208, 1207, 3, 2, 2, 2, 1208,
	1209, 3, 2, 2, 2, 1209, 1211, 3, 2, 2, 2, 1210, 1203, 3, 2, 2, 2, 1210,
	1204, 3, 2, 2, 2, 1211, 1213, 3, 2, 2, 2, 1212, 1197, 3, 2, 2, 2, 1212,
	1201, 3, 2, 2, 2, 1213, 1215, 3, 2, 2, 2, 1214, 1195, 3, 2, 2, 2, 1214,
	1196, 3, 2, 2, 2, 1215, 153, 3, 2, 2, 2, 1216, 1217, 7, 97, 2, 2, 1217,
	1218, 7, 94, 2, 2, 1218, 1237, 5, 10, 6, 2, 1219, 1238, 7, 85, 2, 2, 1220,
	1221, 7, 10, 2, 2, 1221, 1223, 5, 156, 79, 2, 1222, 1224, 7, 85, 2, 2,
	1223, 1222, 3, 2, 2, 2, 1223, 1224, 3, 2, 2, 2, 1224, 1236, 3, 2, 2, 2,
	1225, 1226, 7, 32, 2, 2, 1226, 1233, 5, 44, 23, 2, 1227, 1234, 7, 85, 2,
	2, 1228, 1229, 7, 96, 2, 2, 1229, 1231, 5, 156, 79, 2, 1230, 1232, 7, 85,
	2, 2, 1231, 1230, 3, 2, 2, 2, 1231, 1232, 3, 2, 2, 2, 1232, 1234, 3, 2,
	2, 2, 1233, 1227, 3, 2, 2, 2, 1233, 1228, 3, 2, 2, 2, 1234, 1236, 3, 2,
	2, 2, 1235, 1220, 3, 2, 2, 2, 1235, 1225, 3, 2, 2, 2, 1236, 1238, 3, 2,
	2, 2, 1237, 1219, 3, 2, 2, 2, 1237, 1235, 3, 2, 2, 2, 1238, 155, 3, 2,
	2, 2, 1239, 1240, 7, 51, 2, 2, 1240, 1241, 7, 52, 2, 2, 1241, 157, 3, 2,
	2, 2, 1242, 1244, 7, 25, 2, 2, 1243, 1242, 3, 2, 2, 2, 1243, 1244, 3, 2,
	2, 2, 1244, 1250, 3, 2, 2, 2, 1245, 1246, 7, 81, 2, 2, 1246, 1248, 7, 105,
	2, 2, 1247, 1249, 7, 10, 2, 2, 1248, 1247, 3, 2, 2, 2, 1248, 1249, 3, 2,
	2, 2, 1249, 1251, 3, 2, 2, 2, 1250, 1245, 3, 2, 2, 2, 1250, 1251, 3, 2,
	2, 2, 1251, 1258, 3, 2, 2, 2, 1252, 1253, 7, 49, 2, 2, 1253, 1257, 5, 166,
	84, 2, 1254, 1255, 7, 44, 2, 2, 1255, 1257, 5, 166, 84, 2, 1256, 1252,
	3, 2, 2, 2, 1256, 1254, 3, 2, 2, 2, 1257, 1259, 3, 2, 2, 2, 1258, 1256,
	3, 2, 2, 2, 1258, 1259, 3, 2, 2, 2, 1259, 1261, 3, 2, 2, 2, 1260, 1262,
	5, 138, 70, 2, 1261, 1260, 3, 2, 2, 2, 1261, 1262, 3, 2, 2, 2, 1262, 1263,
	3, 2, 2, 2, 1263, 1264, 7, 85, 2, 2, 1264, 159, 3, 2, 2, 2, 1265, 1267,
	7, 25, 2, 2, 1266, 1265, 3, 2, 2, 2, 1266, 1267, 3, 2, 2, 2, 1267, 1268,
	3, 2, 2, 2, 1268, 1269, 7, 7, 2, 2, 1269, 1270, 7, 105, 2, 2, 1270, 1279,
	7, 55, 2, 2, 1271, 1276, 5, 162, 82, 2, 1272, 1273, 7, 18, 2, 2, 1273,
	1275, 5, 162, 82, 2, 1274, 1272, 3, 2, 2, 2, 1275, 1278, 3, 2, 2, 2, 1276,
	1274, 3, 2, 2, 2, 1276, 1277, 3, 2, 2, 2, 1277, 1280, 3, 2, 2, 2, 1278,
	1276, 3, 2, 2, 2, 1279, 1271, 3, 2, 2, 2, 1279, 1280, 3, 2, 2, 2, 1280,
	1281, 3, 2, 2, 2, 1281, 1282, 7, 56, 2, 2, 1282, 1283, 7, 17, 2, 2, 1283,
	1284, 5, 222, 112, 2, 1284, 1285, 7, 10, 2, 2, 1285, 1287, 5, 166, 84,
	2, 1286, 1288, 5, 138, 70, 2, 1287, 1286, 3, 2, 2, 2, 1287, 1288, 3, 2,
	2, 2, 1288, 1289, 3, 2, 2, 2, 1289, 1290, 7, 85, 2, 2, 1290, 1326, 3, 2,
	2, 2, 1291, 1293, 7, 33, 2, 2, 1292, 1294, 7, 25, 2, 2, 1293, 1292, 3,
	2, 2, 2, 1293, 1294, 3, 2, 2, 2, 1294, 1295, 3, 2, 2, 2, 1295, 1296, 7,
	7, 2, 2, 1296, 1297, 7, 105, 2, 2, 1297, 1306, 7, 55, 2, 2, 1298, 1303,
	5, 162, 82, 2, 1299, 1300, 7, 18, 2, 2, 1300, 1302, 5, 162, 82, 2, 1301,
	1299, 3, 2, 2, 2, 1302, 1305, 3, 2, 2, 2, 1303, 1301, 3, 2, 2, 2, 1303,
	1304, 3, 2, 2, 2, 1304, 1307, 3, 2, 2, 2, 1305, 1303, 3, 2, 2, 2, 1306,
	1298, 3, 2, 2, 2, 1306, 1307, 3, 2, 2, 2, 1307, 1308, 3, 2, 2, 2, 1308,
	1309, 7, 56, 2, 2, 1309, 1310, 7, 17, 2, 2, 1310, 1311, 5, 222, 112, 2,
	1311, 1321, 7, 10, 2, 2, 1312, 1322, 5, 12, 7, 2, 1313, 1318, 5, 10, 6,
	2, 1314, 1315, 7, 27, 2, 2, 1315, 1317, 5, 10, 6, 2, 1316, 1314, 3, 2,
	2, 2, 1317, 1320, 3, 2, 2, 2, 1318, 1316, 3, 2, 2, 2, 1318, 1319, 3, 2,
	2, 2, 1319, 1322, 3, 2, 2, 2, 1320, 1318, 3, 2, 2, 2, 1321, 1312, 3, 2,
	2, 2, 1321, 1313, 3, 2, 2, 2, 1322, 1323, 3, 2, 2, 2, 1323, 1324, 7, 85,
	2, 2, 1324, 1326, 3, 2, 2, 2, 1325, 1266, 3, 2, 2, 2, 1325, 1291, 3, 2,
	2, 2, 1326, 161, 3, 2, 2, 2, 1327, 1328, 5, 10, 6, 2, 1328, 1329, 7, 17,
	2, 2, 1329, 1330, 5, 222, 112, 2, 1330, 163, 3, 2, 2, 2, 1331, 1332, 5,
	166, 84, 2, 1332, 1333, 7, 85, 2, 2, 1333, 165, 3, 2, 2, 2, 1334, 1339,
	5, 168, 85, 2, 1335, 1336, 7, 64, 2, 2, 1336, 1338, 5, 168, 85, 2, 1337,
	1335, 3, 2, 2, 2, 1338, 1341, 3, 2, 2, 2, 1339, 1337, 3, 2, 2, 2, 1339,
	1340, 3, 2, 2, 2, 1340, 167, 3, 2, 2, 2, 1341, 1339, 3, 2, 2, 2, 1342,
	1347, 5, 170, 86, 2, 1343, 1344, 7, 50, 2, 2, 1344, 1346, 5, 170, 86, 2,
	1345, 1343, 3, 2, 2, 2, 1346, 1349, 3, 2, 2, 2, 1347, 1345, 3, 2, 2, 2,
	1347, 1348, 3, 2, 2, 2, 1348, 169, 3, 2, 2, 2, 1349, 1347, 3, 2, 2, 2,
	1350, 1355, 5, 172, 87, 2, 1351, 1352, 7, 45, 2, 2, 1352, 1354, 5, 172,
	87, 2, 1353, 1351, 3, 2, 2, 2, 1354, 1357, 3, 2, 2, 2, 1355, 1353, 3, 2,
	2, 2, 1355, 1356, 3, 2, 2, 2, 1356, 171, 3, 2, 2, 2, 1357, 1355, 3, 2,
	2, 2, 1358, 1363, 5, 174, 88, 2, 1359, 1360, 7, 8, 2, 2, 1360, 1362, 5,
	174, 88, 2, 1361, 1359, 3, 2, 2, 2, 1362, 1365, 3, 2, 2, 2, 1363, 1361,
	3, 2, 2, 2, 1363, 1364, 3, 2, 2, 2, 1364, 173, 3, 2, 2, 2, 1365, 1363,
	3, 2, 2, 2, 1366, 1367, 7, 15, 2, 2, 1367, 1370, 5, 174, 88, 2, 1368, 1370,
	5, 176, 89, 2, 1369, 1366, 3, 2, 2, 2, 1369, 1368, 3, 2, 2, 2, 1370, 175,
	3, 2, 2, 2, 1371, 1378, 5, 178, 90, 2, 1372, 1373, 7, 36, 2, 2, 1373, 1377,
	5, 178, 90, 2, 1374, 1375, 7, 60, 2, 2, 1375, 1377, 5, 178, 90, 2, 1376,
	1372, 3, 2, 2, 2, 1376, 1374, 3, 2, 2, 2, 1377, 1380, 3, 2, 2, 2, 1378,
	1376, 3, 2, 2, 2, 1378, 1379, 3, 2, 2, 2, 1379, 177, 3, 2, 2, 2, 1380,
	1378, 3, 2, 2, 2, 1381, 1392, 5, 180, 91, 2, 1382, 1383, 7, 57, 2, 2, 1383,
	1391, 5, 180, 91, 2, 1384, 1385, 7, 58, 2, 2, 1385, 1391, 5, 180, 91, 2,
	1386, 1387, 7, 59, 2, 2, 1387, 1391, 5, 180, 91, 2, 1388, 1389, 7, 43,
	2, 2, 1389, 1391, 5, 180, 91, 2, 1390, 1382, 3, 2, 2, 2, 1390, 1384, 3,
	2, 2, 2, 1390, 1386, 3, 2, 2, 2, 1390, 1388, 3, 2, 2, 2, 1391, 1394, 3,
	2, 2, 2, 1392, 1390, 3, 2, 2, 2, 1392, 1393, 3, 2, 2, 2, 1393, 179, 3,
	2, 2, 2, 1394, 1392, 3, 2, 2, 2, 1395, 1402, 5, 182, 92, 2, 1396, 1397,
	7, 69, 2, 2, 1397, 1401, 5, 182, 92, 2, 1398, 1399, 7, 63, 2, 2, 1399,
	1401, 5, 182, 92, 2, 1400, 1396, 3, 2, 2, 2, 1400, 1398, 3, 2, 2, 2, 1401,
	1404, 3, 2, 2, 2, 1402, 1400, 3, 2, 2, 2, 1402, 1403, 3, 2, 2, 2, 1403,
	181, 3, 2, 2, 2, 1404, 1402, 3, 2, 2, 2, 1405, 1416, 5, 184, 93, 2, 1406,
	1407, 7, 89, 2, 2, 1407, 1415, 5, 184, 93, 2, 1408, 1409, 7, 88, 2, 2,
	1409, 1415, 5, 184, 93, 2, 1410, 1411, 7, 78, 2, 2, 1411, 1415, 5, 184,
	93, 2, 1412, 1413, 7, 68, 2, 2, 1413, 1415, 5, 184, 93, 2, 1414, 1406,
	3, 2, 2, 2, 1414, 1408, 3, 2, 2, 2, 1414, 1410, 3, 2, 2, 2, 1414, 1412,
	3, 2, 2, 2, 1415, 1418, 3, 2, 2, 2, 1416, 1414, 3, 2, 2, 2, 1416, 1417,
	3, 2, 2, 2, 1417, 183, 3, 2, 2, 2, 1418, 1416, 3, 2, 2, 2, 1419, 1420,
	7, 63, 2, 2, 1420, 1423, 5, 184, 93, 2, 1421, 1423, 5, 186, 94, 2, 1422,
	1419, 3, 2, 2, 2, 1422, 1421, 3, 2, 2, 2, 1423, 185, 3, 2, 2, 2, 1424,
	1433, 5, 196, 99, 2, 1425, 1433, 5, 190, 96, 2, 1426, 1433, 5, 188, 95,
	2, 1427, 1433, 5, 206, 104, 2, 1428, 1433, 5, 214, 108, 2, 1429, 1433,
	5, 218, 110, 2, 1430, 1433, 5, 198, 100, 2, 1431, 1433, 5, 204, 103, 2,
	1432, 1424, 3, 2, 2, 2, 1432, 1425, 3, 2, 2, 2, 1432, 1426, 3, 2, 2, 2,
	1432, 1427, 3, 2, 2, 2, 1432, 1428, 3, 2, 2, 2, 1432, 1429, 3, 2, 2, 2,
	1432, 1430, 3, 2, 2, 2, 1432, 1431, 3, 2, 2, 2, 1433, 187, 3, 2, 2, 2,
	1434, 1435, 7, 55, 2, 2, 1435, 1436, 5, 166, 84, 2, 1436, 1437, 7, 56,
	2, 2, 1437, 189, 3, 2, 2, 2, 1438, 1446, 5, 10, 6, 2, 1439, 1442, 7, 27,
	2, 2, 1440, 1443, 5, 10, 6, 2, 1441, 1443, 5, 192, 97, 2, 1442, 1440, 3,
	2, 2, 2, 1442, 1441, 3, 2, 2, 2, 1443, 1445, 3, 2, 2, 2, 1444, 1439, 3,
	2, 2, 2, 1445, 1448, 3, 2, 2, 2, 1446, 1444, 3, 2, 2, 2, 1446, 1447, 3,
	2, 2, 2, 1447, 1450, 3, 2, 2, 2, 1448, 1446, 3, 2, 2, 2, 1449, 1451, 5,
	194, 98, 2, 1450, 1449, 3, 2, 2, 2, 1450, 1451, 3, 2, 2, 2, 1451, 191,
	3, 2, 2, 2, 1452, 1464, 7, 94, 2, 2, 1453, 1464, 7, 21, 2, 2, 1454, 1464,
	7, 24, 2, 2, 1455, 1464, 7, 71, 2, 2, 1456, 1464, 7, 82, 2, 2, 1457, 1464,
	7, 42, 2, 2, 1458, 1464, 7, 62, 2, 2, 1459, 1464, 7, 73, 2, 2, 1460, 1464,
	7, 79, 2, 2, 1461, 1464, 7, 13, 2, 2, 1462, 1464, 7, 14, 2, 2, 1463, 1452,
	3, 2, 2, 2, 1463, 1453, 3, 2, 2, 2, 1463, 1454, 3, 2, 2, 2, 1463, 1455,
	3, 2, 2, 2, 1463, 1456, 3, 2, 2, 2, 1463, 1457, 3, 2, 2, 2, 1463, 1458,
	3, 2, 2, 2, 1463, 1459, 3, 2, 2, 2, 1463, 1460, 3, 2, 2, 2, 1463, 1461,
	3, 2, 2, 2, 1463, 1462, 3, 2, 2, 2, 1464, 193, 3, 2, 2, 2, 1465, 1474,
	7, 55, 2, 2, 1466, 1471, 5, 166, 84, 2, 1467, 1468, 7, 18, 2, 2, 1468,
	1470, 5, 166, 84, 2, 1469, 1467, 3, 2, 2, 2, 1470, 1473, 3, 2, 2, 2, 1471,
	1469, 3, 2, 2, 2, 1471, 1472, 3, 2, 2, 2, 1472, 1475, 3, 2, 2, 2, 1473,
	1471, 3, 2, 2, 2, 1474, 1466, 3, 2, 2, 2, 1474, 1475, 3, 2, 2, 2, 1475,
	1476, 3, 2, 2, 2, 1476, 1477, 7, 56, 2, 2, 1477, 195, 3, 2, 2, 2, 1478,
	1501, 7, 103, 2, 2, 1479, 1501, 7, 102, 2, 2, 1480, 1501, 7, 104, 2, 2,
	1481, 1501, 7, 99, 2, 2, 1482, 1501, 7, 100, 2, 2, 1483, 1501, 7, 20, 2,
	2, 1484, 1501, 7, 41, 2, 2, 1485, 1501, 7, 22, 2, 2, 1486, 1501, 7, 70,
	2, 2, 1487, 1501, 7, 80, 2, 2, 1488, 1501, 7, 92, 2, 2, 1489, 1501, 7,
	29, 2, 2, 1490, 1501, 7, 72, 2, 2, 1491, 1501, 7, 48, 2, 2, 1492, 1501,
	7, 40, 2, 2, 1493, 1501, 7, 28, 2, 2, 1494, 1501, 7, 90, 2, 2, 1495, 1501,
	7, 101, 2, 2, 1496, 1501, 7, 30, 2, 2, 1497, 1501, 7, 86, 2, 2, 1498, 1501,
	7, 83, 2, 2, 1499, 1501, 7, 76, 2, 2, 1500, 1478, 3, 2, 2, 2, 1500, 1479,
	3, 2, 2, 2, 1500, 1480, 3, 2, 2, 2, 1500, 1481, 3, 2, 2, 2, 1500, 1482,
	3, 2, 2, 2, 1500, 1483, 3, 2, 2, 2, 1500, 1484, 3, 2, 2, 2, 1500, 1485,
	3, 2, 2, 2, 1500, 1486, 3, 2, 2, 2, 1500, 1487, 3, 2, 2, 2, 1500, 1488,
	3, 2, 2, 2, 1500, 1489, 3, 2, 2, 2, 1500, 1490, 3, 2, 2, 2, 1500, 1491,
	3, 2, 2, 2, 1500, 1492, 3, 2, 2, 2, 1500, 1493, 3, 2, 2, 2, 1500, 1494,
	3, 2, 2, 2, 1500, 1495, 3, 2, 2, 2, 1500, 1496, 3, 2, 2, 2, 1500, 1497,
	3, 2, 2, 2, 1500, 1498, 3, 2, 2, 2, 1500, 1499, 3, 2, 2, 2, 1501, 197,
	3, 2, 2, 2, 1502, 1508, 7, 39, 2, 2, 1503, 1505, 7, 34, 2, 2, 1504, 1506,
	7, 95, 2, 2, 1505, 1504, 3, 2, 2, 2, 1505, 1506, 3, 2, 2, 2, 1506, 1508,
	3, 2, 2, 2, 1507, 1502, 3, 2, 2, 2, 1507, 1503, 3, 2, 2, 2, 1508, 1509,
	3, 2, 2, 2, 1509, 1514, 5, 202, 102, 2, 1510, 1511, 7, 18, 2, 2, 1511,
	1513, 5, 202, 102, 2, 1512, 1510, 3, 2, 2, 2, 1513, 1516, 3, 2, 2, 2, 1514,
	1512, 3, 2, 2, 2, 1514, 1515, 3, 2, 2, 2, 1515, 1517, 3, 2, 2, 2, 1516,
	1514, 3, 2, 2, 2, 1517, 1518, 7, 98, 2, 2, 1518, 1519, 5, 166, 84, 2, 1519,
	199, 3, 2, 2, 2, 1520, 1521, 7, 26, 2, 2, 1521, 1526, 5, 10, 6, 2, 1522,
	1523, 7, 18, 2, 2, 1523, 1525, 5, 10, 6, 2, 1524, 1522, 3, 2, 2, 2, 1525,
	1528, 3, 2, 2, 2, 1526, 1524, 3, 2, 2, 2, 1526, 1527, 3, 2, 2, 2, 1527,
	1531, 3, 2, 2, 2, 1528, 1526, 3, 2, 2, 2, 1529, 1530, 9, 7, 2, 2, 1530,
	1532, 5, 222, 112, 2, 1531, 1529, 3, 2, 2, 2, 1531, 1532, 3, 2, 2, 2, 1532,
	1533, 3, 2, 2, 2, 1533, 1536, 7, 47, 2, 2, 1534, 1537, 5, 206, 104, 2,
	1535, 1537, 5, 190, 96, 2, 1536, 1534, 3, 2, 2, 2, 1536, 1535, 3, 2, 2,
	2, 1537, 201, 3, 2, 2, 2, 1538, 1557, 5, 200, 101, 2, 1539, 1544, 5, 10,
	6, 2, 1540, 1541, 7, 18, 2, 2, 1541, 1543, 5, 10, 6, 2, 1542, 1540, 3,
	2, 2, 2, 1543, 1546, 3, 2, 2, 2, 1544, 1542, 3, 2, 2, 2, 1544, 1545, 3,
	2, 2, 2, 1545, 1549, 3, 2, 2, 2, 1546, 1544, 3, 2, 2, 2, 1547, 1548, 9,
	7, 2, 2, 1548, 1550, 5, 222, 112, 2, 1549, 1547, 3, 2, 2, 2, 1549, 1550,
	3, 2, 2, 2, 1550, 1551, 3, 2, 2, 2, 1551, 1554, 7, 47, 2, 2, 1552, 1555,
	5, 206, 104, 2, 1553, 1555, 5, 190, 96, 2, 1554, 1552, 3, 2, 2, 2, 1554,
	1553, 3, 2, 2, 2, 1555, 1557, 3, 2, 2, 2, 1556, 1538, 3, 2, 2, 2, 1556,
	1539, 3, 2, 2, 2, 1557, 203, 3, 2, 2, 2, 1558, 1559, 7, 57, 2, 2, 1559,
	1560, 5, 208, 105, 2, 1560, 1561, 7, 58, 2, 2, 1561, 205, 3, 2, 2, 2, 1562,
	1566, 5, 212, 107, 2, 1563, 1566, 5, 220, 111, 2, 1564, 1566, 5, 208, 105,
	2, 1565, 1562, 3, 2, 2, 2, 1565, 1563, 3, 2, 2, 2, 1565, 1564, 3, 2, 2,
	2, 1566, 207, 3, 2, 2, 2, 1567, 1568, 7, 88, 2, 2, 1568, 1571, 5, 190,
	96, 2, 1569, 1570, 9, 7, 2, 2, 1570, 1572, 5, 222, 112, 2, 1571, 1569,
	3, 2, 2, 2, 1571, 1572, 3, 2, 2, 2, 1572, 1577, 3, 2, 2, 2, 1573, 1574,
	7, 53, 2, 2, 1574, 1575, 5, 166, 84, 2, 1575, 1576, 7, 54, 2, 2, 1576,
	1578, 3, 2, 2, 2, 1577, 1573, 3, 2, 2, 2, 1577, 1578, 3, 2, 2, 2, 1578,
	1583, 3, 2, 2, 2, 1579, 1580, 7, 88, 2, 2, 1580, 1582, 5, 210, 106, 2,
	1581, 1579, 3, 2, 2, 2, 1582, 1585, 3, 2, 2, 2, 1583, 1581, 3, 2, 2, 2,
	1583, 1584, 3, 2, 2, 2, 1584, 209, 3, 2, 2, 2, 1585, 1583, 3, 2, 2, 2,
	1586, 1589, 5, 192, 97, 2, 1587, 1588, 9, 7, 2, 2, 1588, 1590, 5, 222,
	112, 2, 1589, 1587, 3, 2, 2, 2, 1589, 1590, 3, 2, 2, 2, 1590, 1595, 3,
	2, 2, 2, 1591, 1592, 7, 53, 2, 2, 1592, 1593, 5, 166, 84, 2, 1593, 1594,
	7, 54, 2, 2, 1594, 1596, 3, 2, 2, 2, 1595, 1591, 3, 2, 2, 2, 1595, 1596,
	3, 2, 2, 2, 1596, 1601, 3, 2, 2, 2, 1597, 1598, 7, 88, 2, 2, 1598, 1600,
	5, 210, 106, 2, 1599, 1597, 3, 2, 2, 2, 1600, 1603, 3, 2, 2, 2, 1601, 1599,
	3, 2, 2, 2, 1601, 1602, 3, 2, 2, 2, 1602, 1609, 3, 2, 2, 2, 1603, 1601,
	3, 2, 2, 2, 1604, 1606, 7, 35, 2, 2, 1605, 1604, 3, 2, 2, 2, 1605, 1606,
	3, 2, 2, 2, 1606, 1607, 3, 2, 2, 2, 1607, 1609, 5, 190, 96, 2, 1608, 1586,
	3, 2, 2, 2, 1608, 1605, 3, 2, 2, 2, 1609, 211, 3, 2, 2, 2, 1610, 1611,
	7, 51, 2, 2, 1611, 1630, 7, 52, 2, 2, 1612, 1615, 7, 51, 2, 2, 1613, 1616,
	5, 196, 99, 2, 1614, 1616, 5, 190, 96, 2, 1615, 1613, 3, 2, 2, 2, 1615,
	1614, 3, 2, 2, 2, 1616, 1624, 3, 2, 2, 2, 1617, 1620, 7, 18, 2, 2, 1618,
	1621, 5, 196, 99, 2, 1619, 1621, 5, 190, 96, 2, 1620, 1618, 3, 2, 2, 2,
	1620, 1619, 3, 2, 2, 2, 1621, 1623, 3, 2, 2, 2, 1622, 1617, 3, 2, 2, 2,
	1623, 1626, 3, 2, 2, 2, 1624, 1622, 3, 2, 2, 2, 1624, 1625, 3, 2, 2, 2,
	1625, 1627, 3, 2, 2, 2, 1626, 1624, 3, 2, 2, 2, 1627, 1628, 7, 52, 2, 2,
	1628, 1630, 3, 2, 2, 2, 1629, 1610, 3, 2, 2, 2, 1629, 1612, 3, 2, 2, 2,
	1630, 213, 3, 2, 2, 2, 1631, 1632, 7, 57, 2, 2, 1632, 1651, 7, 58, 2, 2,
	1633, 1636, 7, 57, 2, 2, 1634, 1637, 5, 196, 99, 2, 1635, 1637, 5, 190,
	96, 2, 1636, 1634, 3, 2, 2, 2, 1636, 1635, 3, 2, 2, 2, 1637, 1645, 3, 2,
	2, 2, 1638, 1641, 7, 18, 2, 2, 1639, 1642, 5, 196, 99, 2, 1640, 1642, 5,
	190, 96, 2, 1641, 1639, 3, 2, 2, 2, 1641, 1640, 3, 2, 2, 2, 1642, 1644,
	3, 2, 2, 2, 1643, 1638, 3, 2, 2, 2, 1644, 1647, 3, 2, 2, 2, 1645, 1643,
	3, 2, 2, 2, 1645, 1646, 3, 2, 2, 2, 1646, 1648, 3, 2, 2, 2, 1647, 1645,
	3, 2, 2, 2, 1648, 1649, 7, 58, 2, 2, 1649, 1651, 3, 2, 2, 2, 1650, 1631,
	3, 2, 2, 2, 1650, 1633, 3, 2, 2, 2, 1651, 215, 3, 2, 2, 2, 1652, 1655,
	5, 10, 6, 2, 1653, 1654, 7, 17, 2, 2, 1654, 1656, 5, 130, 66, 2, 1655,
	1653, 3, 2, 2, 2, 1655, 1656, 3, 2, 2, 2, 1656, 1657, 3, 2, 2, 2, 1657,
	1658, 7, 10, 2, 2, 1658, 1659, 5, 196, 99, 2, 1659, 217, 3, 2, 2, 2, 1660,
	1672, 7, 53, 2, 2, 1661, 1666, 5, 216, 109, 2, 1662, 1663, 7, 85, 2, 2,
	1663, 1665, 5, 216, 109, 2, 1664, 1662, 3, 2, 2, 2, 1665, 1668, 3, 2, 2,
	2, 1666, 1664, 3, 2, 2, 2, 1666, 1667, 3, 2, 2, 2, 1667, 1670, 3, 2, 2,
	2, 1668, 1666, 3, 2, 2, 2, 1669, 1671, 7, 85, 2, 2, 1670, 1669, 3, 2, 2,
	2, 1670, 1671, 3, 2, 2, 2, 1671, 1673, 3, 2, 2, 2, 1672, 1661, 3, 2, 2,
	2, 1672, 1673, 3, 2, 2, 2, 1673, 1674, 3, 2, 2, 2, 1674, 1675, 7, 54, 2,
	2, 1675, 219, 3, 2, 2, 2, 1676, 1678, 7, 51, 2, 2, 1677, 1676, 3, 2, 2,
	2, 1677, 1678, 3, 2, 2, 2, 1678, 1679, 3, 2, 2, 2, 1679, 1680, 7, 84, 2,
	2, 1680, 1681, 5, 202, 102, 2, 1681, 1682, 7, 98, 2, 2, 1682, 1684, 5,
	166, 84, 2, 1683, 1685, 7, 52, 2, 2, 1684, 1683, 3, 2, 2, 2, 1684, 1685,
	3, 2, 2, 2, 1685, 1704, 3, 2, 2, 2, 1686, 1688, 7, 51, 2, 2, 1687, 1686,
	3, 2, 2, 2, 1687, 1688, 3, 2, 2, 2, 1688, 1689, 3, 2, 2, 2, 1689, 1690,
	7, 19, 2, 2, 1690, 1691, 5, 190, 96, 2, 1691, 1692, 7, 17, 2, 2, 1692,
	1693, 5, 222, 112, 2, 1693, 1696, 7, 47, 2, 2, 1694, 1697, 5, 206, 104,
	2, 1695, 1697, 5, 190, 96, 2, 1696, 1694, 3, 2, 2, 2, 1696, 1695, 3, 2,
	2, 2, 1697, 1698, 3, 2, 2, 2, 1698, 1699, 7, 98, 2, 2, 1699, 1701, 5, 166,
	84, 2, 1700, 1702, 7, 52, 2, 2, 1701, 1700, 3, 2, 2, 2, 1701, 1702, 3,
	2, 2, 2, 1702, 1704, 3, 2, 2, 2, 1703, 1677, 3, 2, 2, 2, 1703, 1687, 3,
	2, 2, 2, 1704, 221, 3, 2, 2, 2, 1705, 1718, 7, 92, 2, 2, 1706, 1718, 7,
	20, 2, 2, 1707, 1718, 7, 41, 2, 2, 1708, 1718, 7, 22, 2, 2, 1709, 1718,
	7, 70, 2, 2, 1710, 1718, 7, 80, 2, 2, 1711, 1718, 7, 72, 2, 2, 1712, 1718,
	7, 29, 2, 2, 1713, 1718, 7, 94, 2, 2, 1714, 1718, 7, 77, 2, 2, 1715, 1718,
	5, 190, 96, 2, 1716, 1718, 5, 132, 67, 2, 1717, 1705, 3, 2, 2, 2, 1717,
	1706, 3, 2, 2, 2, 1717, 1707, 3, 2, 2, 2, 1717, 1708, 3, 2, 2, 2, 1717,
	1709, 3, 2, 2, 2, 1717, 1710, 3, 2, 2, 2, 1717, 1711, 3, 2, 2, 2, 1717,
	1712, 3, 2, 2, 2, 1717, 1713, 3, 2, 2, 2, 1717, 1714, 3, 2, 2, 2, 1717,
	1715, 3, 2, 2, 2, 1717, 1716, 3, 2, 2, 2, 1718, 223, 3, 2, 2, 2, 257, 227,
	233, 235, 240, 247, 253, 258, 271, 279, 286, 288, 290, 294, 297, 306, 317,
	319, 321, 334, 337, 343, 351, 359, 361, 363, 365, 374, 376, 386, 391, 396,
	401, 406, 411, 416, 421, 426, 431, 436, 441, 446, 453, 458, 465, 475, 483,
	490, 492, 494, 496, 501, 503, 515, 523, 530, 532, 534, 536, 546, 549, 555,
	563, 571, 573, 575, 577, 583, 585, 597, 600, 604, 613, 621, 628, 630, 632,
	634, 644, 647, 650, 655, 663, 671, 673, 675, 677, 683, 685, 697, 705, 712,
	714, 716, 718, 728, 731, 737, 745, 753, 755, 757, 759, 765, 767, 779, 787,
	794, 796, 798, 800, 810, 813, 819, 827, 835, 837, 839, 841, 848, 850, 862,
	870, 877, 879, 881, 883, 893, 896, 902, 910, 918, 920, 922, 924, 931, 933,
	941, 946, 950, 957, 962, 972, 986, 992, 995, 1008, 1017, 1021, 1026, 1034,
	1037, 1044, 1055, 1059, 1061, 1071, 1074, 1083, 1091, 1098, 1109, 1121,
	1133, 1150, 1154, 1159, 1165, 1173, 1193, 1199, 1208, 1210, 1212, 1214,
	1223, 1231, 1233, 1235, 1237, 1243, 1248, 1250, 1256, 1258, 1261, 1266,
	1276, 1279, 1287, 1293, 1303, 1306, 1318, 1321, 1325, 1339, 1347, 1355,
	1363, 1369, 1376, 1378, 1390, 1392, 1400, 1402, 1414, 1416, 1422, 1432,
	1442, 1446, 1450, 1463, 1471, 1474, 1500, 1505, 1507, 1514, 1526, 1531,
	1536, 1544, 1549, 1554, 1556, 1565, 1571, 1577, 1583, 1589, 1595, 1601,
	1605, 1608, 1615, 1620, 1624, 1629, 1636, 1641, 1645, 1650, 1655, 1666,
	1670, 1672, 1677, 1684, 1687, 1696, 1701, 1703, 1717,
}
var literalNames = []string{
	"", "'$'", "'\\'", "'\\\\'", "", "", "", "", "'='", "", "", "", "", "'!'",
	"", "':'", "','", "", "", "", "", "", "", "", "", "'.'", "", "", "", "",
	"", "", "", "'...'", "'=='", "", "", "", "", "", "", "'>='", "", "'<->'",
	"", "", "", "", "'->'", "'{'", "'}'", "'['", "']'", "'('", "')'", "'<'",
	"'>'", "'<='", "'!='", "", "", "'-'", "", "", "", "", "", "'+'", "", "",
	"", "", "'<<'", "'>>'", "", "", "'%'", "", "", "", "", "", "", "';'", "",
	"':!'", "'/'", "'*'", "", "", "", "", "", "", "", "", "'|'",
}
var symbolicNames = []string{
	"", "", "", "", "ABSTRACT", "ANALYSIS", "AND", "ANY", "ASSIGN", "ATTACHMENT",
	"ATTACHMENTS", "ATTACHEDPORTS", "ATTACHEDROLES", "BANG", "BINDINGS", "COLON",
	"COMMA", "COLLECT", "COMPONENT", "COMPONENTS", "CONNECTOR", "CONTAINASSIGN",
	"CONNECTORS", "DESIGN", "DISTINCT", "DOT", "DOUBLE", "ELEMENT", "ENUM",
	"EXTENDED", "EXTENDS", "EXTERNAL", "EXISTS", "ELLIPSIS", "EQ", "FAMILY",
	"FINAL", "FORALL", "FLOAT", "GROUP", "GROUPS", "GE", "HEURISTIC", "IFF",
	"IMPORT", "IN", "INT", "INVARIANT", "IMPLIES", "LBRACE", "RBRACE", "LBRACKET",
	"RBRACKET", "LPAREN", "RPAREN", "LANGLE", "RANGLE", "LE", "NE", "NEW",
	"MEMBERS", "MINUS", "OR", "PATHSEPARATOR", "PUBLIC", "PRIVATE", "POWER",
	"PLUS", "PORT", "PORTS", "PROPERTY", "PROPERTIES", "PROPBEGIN", "PROPEND",
	"RECORD", "REPRESENTATION", "REM", "REPRESENTATIONS", "ROLE", "RULE", "ROLES",
	"SEQUENCE", "SELECT", "SEMICOLON", "SET", "SET_DECLARE", "SLASH", "STAR",
	"STRING", "STYLE", "SYSTEM", "TO", "TYPE", "UNIQUE", "WITH", "VIEW", "BIT_OR",
	"TRUE", "FALSE", "BOOLEAN", "FLOATING_POINT_LITERAL", "INTEGER_LITERAL",
	"STRING_LITERAL", "IDENTIFIER", "LINE_COMMENT", "BLOCK_COMMENT", "WS",
}

var ruleNames = []string{
	"acmeCompUnit", "acmeImportDeclaration", "stringLiteral", "filename", "identifier",
	"codeLiteral", "acmeFamilyDeclaration", "acmeFamilyBody", "acmeSystemDeclaration",
	"acmeSystemBody", "acmeDesignDeclaration", "acmeComponentTypeRef", "acmeComponentInstantiatedTypeRef",
	"acmeConnectorTypeRef", "acmeConnectorInstantiatedTypeRef", "acmePortTypeRef",
	"acmePortInstantiatedTypeRef", "acmeGroupTypeRef", "acmeGroupInstantiatedTypeRef",
	"acmeRoleTypeRef", "acmeRoleInstantiatedTypeRef", "acmeViewTypeRef", "acmeViewInstantiatedTypeRef",
	"acmeFamilyRef", "acmeFamilyInstantiationRef", "acmeElementTypeRef", "acmePropertyTypeDeclarationRef",
	"acmeInstanceRef", "acmeGenericElementTypeDeclaration", "acmeGenericElementBody",
	"acmeGroupTypeDeclaration", "acmeGroupDeclaration", "acmeGroupBody", "acmeMembersBlock",
	"acmePortTypeDeclaration", "acmePortDeclaration", "acmePortBody", "acmeRoleTypeDeclaration",
	"acmeRoleDeclaration", "acmeRoleBody", "acmeComponentTypeDeclaration",
	"acmeComponentDeclaration", "acmeComponentBody", "acmeConnectorTypeDeclaration",
	"acmeConnectorDeclaration", "acmeConnectorBody", "acmeRepresentationDeclaration",
	"acmeBindingsMapDeclaration", "acmeBindingDeclaration", "acmeAttachmentDeclaration",
	"acmePropertyDeclaration", "acmePropertyValueDeclaration", "enumidentifier",
	"acmePropertyElement", "acmePropertyCompoundElement", "acmePropertySet",
	"acmePropertyRecordEntry", "acmePropertyRecord", "acmePropertySequence",
	"acmePropertyTypeRecord", "acmePropertyTypeSet", "acmePropertyTypeSequence",
	"acmePropertyTypeEnum", "acmePropertyRecordFieldDescription", "acmePropertyTypeRef",
	"acmePropertyTypeStructure", "acmePropertyTypeDeclaration", "acmePropertyBlockEntry",
	"acmePropertyBlock", "acmePropertyTypeInt", "acmePropertyTypeAny", "acmePropertyTypeFloat",
	"acmePropertyTypeDouble", "acmePropertyTypeString", "acmePropertyTypeBoolean",
	"acmeViewDeclaration", "acmeViewTypeDeclaration", "acmeViewBody", "designRule",
	"acmeDesignAnalysisDeclaration", "formalParam", "terminatedDesignRuleExpression",
	"designRuleExpression", "aSTDRImpliesExpression", "dRIffExpression", "dRAndExpression",
	"dRNegateExpression", "dREqualityExpression", "dRRelationalExpression",
	"dRAdditiveExpression", "dRMultiplicativeExpression", "dRNegativeExpression",
	"primitiveExpression", "parentheticalExpression", "reference", "setReference",
	"actualParams", "literalConstant", "quantifiedExpression", "distinctVariableSetDeclaration",
	"variableSetDeclaration", "sequenceExpression", "setExpression", "pathExpression",
	"pathExpressionContinuation", "literalSet", "literalSequence", "literalRecordEntry",
	"literalRecord", "setConstructor", "acmeTypeRef",
}

type acmeParser struct {
	*antlr.BaseParser
}

// NewacmeParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *acmeParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewacmeParser(input antlr.TokenStream) *acmeParser {
	this := new(acmeParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "acme.g4"

	return this
}

// acmeParser tokens.
const (
	acmeParserEOF                    = antlr.TokenEOF
	acmeParserT__0                   = 1
	acmeParserT__1                   = 2
	acmeParserT__2                   = 3
	acmeParserABSTRACT               = 4
	acmeParserANALYSIS               = 5
	acmeParserAND                    = 6
	acmeParserANY                    = 7
	acmeParserASSIGN                 = 8
	acmeParserATTACHMENT             = 9
	acmeParserATTACHMENTS            = 10
	acmeParserATTACHEDPORTS          = 11
	acmeParserATTACHEDROLES          = 12
	acmeParserBANG                   = 13
	acmeParserBINDINGS               = 14
	acmeParserCOLON                  = 15
	acmeParserCOMMA                  = 16
	acmeParserCOLLECT                = 17
	acmeParserCOMPONENT              = 18
	acmeParserCOMPONENTS             = 19
	acmeParserCONNECTOR              = 20
	acmeParserCONTAINASSIGN          = 21
	acmeParserCONNECTORS             = 22
	acmeParserDESIGN                 = 23
	acmeParserDISTINCT               = 24
	acmeParserDOT                    = 25
	acmeParserDOUBLE                 = 26
	acmeParserELEMENT                = 27
	acmeParserENUM                   = 28
	acmeParserEXTENDED               = 29
	acmeParserEXTENDS                = 30
	acmeParserEXTERNAL               = 31
	acmeParserEXISTS                 = 32
	acmeParserELLIPSIS               = 33
	acmeParserEQ                     = 34
	acmeParserFAMILY                 = 35
	acmeParserFINAL                  = 36
	acmeParserFORALL                 = 37
	acmeParserFLOAT                  = 38
	acmeParserGROUP                  = 39
	acmeParserGROUPS                 = 40
	acmeParserGE                     = 41
	acmeParserHEURISTIC              = 42
	acmeParserIFF                    = 43
	acmeParserIMPORT                 = 44
	acmeParserIN                     = 45
	acmeParserINT                    = 46
	acmeParserINVARIANT              = 47
	acmeParserIMPLIES                = 48
	acmeParserLBRACE                 = 49
	acmeParserRBRACE                 = 50
	acmeParserLBRACKET               = 51
	acmeParserRBRACKET               = 52
	acmeParserLPAREN                 = 53
	acmeParserRPAREN                 = 54
	acmeParserLANGLE                 = 55
	acmeParserRANGLE                 = 56
	acmeParserLE                     = 57
	acmeParserNE                     = 58
	acmeParserNEW                    = 59
	acmeParserMEMBERS                = 60
	acmeParserMINUS                  = 61
	acmeParserOR                     = 62
	acmeParserPATHSEPARATOR          = 63
	acmeParserPUBLIC                 = 64
	acmeParserPRIVATE                = 65
	acmeParserPOWER                  = 66
	acmeParserPLUS                   = 67
	acmeParserPORT                   = 68
	acmeParserPORTS                  = 69
	acmeParserPROPERTY               = 70
	acmeParserPROPERTIES             = 71
	acmeParserPROPBEGIN              = 72
	acmeParserPROPEND                = 73
	acmeParserRECORD                 = 74
	acmeParserREPRESENTATION         = 75
	acmeParserREM                    = 76
	acmeParserREPRESENTATIONS        = 77
	acmeParserROLE                   = 78
	acmeParserRULE                   = 79
	acmeParserROLES                  = 80
	acmeParserSEQUENCE               = 81
	acmeParserSELECT                 = 82
	acmeParserSEMICOLON              = 83
	acmeParserSET                    = 84
	acmeParserSET_DECLARE            = 85
	acmeParserSLASH                  = 86
	acmeParserSTAR                   = 87
	acmeParserSTRING                 = 88
	acmeParserSTYLE                  = 89
	acmeParserSYSTEM                 = 90
	acmeParserTO                     = 91
	acmeParserTYPE                   = 92
	acmeParserUNIQUE                 = 93
	acmeParserWITH                   = 94
	acmeParserVIEW                   = 95
	acmeParserBIT_OR                 = 96
	acmeParserTRUE                   = 97
	acmeParserFALSE                  = 98
	acmeParserBOOLEAN                = 99
	acmeParserFLOATING_POINT_LITERAL = 100
	acmeParserINTEGER_LITERAL        = 101
	acmeParserSTRING_LITERAL         = 102
	acmeParserIDENTIFIER             = 103
	acmeParserLINE_COMMENT           = 104
	acmeParserBLOCK_COMMENT          = 105
	acmeParserWS                     = 106
)

// acmeParser rules.
const (
	acmeParserRULE_acmeCompUnit                       = 0
	acmeParserRULE_acmeImportDeclaration              = 1
	acmeParserRULE_stringLiteral                      = 2
	acmeParserRULE_filename                           = 3
	acmeParserRULE_identifier                         = 4
	acmeParserRULE_codeLiteral                        = 5
	acmeParserRULE_acmeFamilyDeclaration              = 6
	acmeParserRULE_acmeFamilyBody                     = 7
	acmeParserRULE_acmeSystemDeclaration              = 8
	acmeParserRULE_acmeSystemBody                     = 9
	acmeParserRULE_acmeDesignDeclaration              = 10
	acmeParserRULE_acmeComponentTypeRef               = 11
	acmeParserRULE_acmeComponentInstantiatedTypeRef   = 12
	acmeParserRULE_acmeConnectorTypeRef               = 13
	acmeParserRULE_acmeConnectorInstantiatedTypeRef   = 14
	acmeParserRULE_acmePortTypeRef                    = 15
	acmeParserRULE_acmePortInstantiatedTypeRef        = 16
	acmeParserRULE_acmeGroupTypeRef                   = 17
	acmeParserRULE_acmeGroupInstantiatedTypeRef       = 18
	acmeParserRULE_acmeRoleTypeRef                    = 19
	acmeParserRULE_acmeRoleInstantiatedTypeRef        = 20
	acmeParserRULE_acmeViewTypeRef                    = 21
	acmeParserRULE_acmeViewInstantiatedTypeRef        = 22
	acmeParserRULE_acmeFamilyRef                      = 23
	acmeParserRULE_acmeFamilyInstantiationRef         = 24
	acmeParserRULE_acmeElementTypeRef                 = 25
	acmeParserRULE_acmePropertyTypeDeclarationRef     = 26
	acmeParserRULE_acmeInstanceRef                    = 27
	acmeParserRULE_acmeGenericElementTypeDeclaration  = 28
	acmeParserRULE_acmeGenericElementBody             = 29
	acmeParserRULE_acmeGroupTypeDeclaration           = 30
	acmeParserRULE_acmeGroupDeclaration               = 31
	acmeParserRULE_acmeGroupBody                      = 32
	acmeParserRULE_acmeMembersBlock                   = 33
	acmeParserRULE_acmePortTypeDeclaration            = 34
	acmeParserRULE_acmePortDeclaration                = 35
	acmeParserRULE_acmePortBody                       = 36
	acmeParserRULE_acmeRoleTypeDeclaration            = 37
	acmeParserRULE_acmeRoleDeclaration                = 38
	acmeParserRULE_acmeRoleBody                       = 39
	acmeParserRULE_acmeComponentTypeDeclaration       = 40
	acmeParserRULE_acmeComponentDeclaration           = 41
	acmeParserRULE_acmeComponentBody                  = 42
	acmeParserRULE_acmeConnectorTypeDeclaration       = 43
	acmeParserRULE_acmeConnectorDeclaration           = 44
	acmeParserRULE_acmeConnectorBody                  = 45
	acmeParserRULE_acmeRepresentationDeclaration      = 46
	acmeParserRULE_acmeBindingsMapDeclaration         = 47
	acmeParserRULE_acmeBindingDeclaration             = 48
	acmeParserRULE_acmeAttachmentDeclaration          = 49
	acmeParserRULE_acmePropertyDeclaration            = 50
	acmeParserRULE_acmePropertyValueDeclaration       = 51
	acmeParserRULE_enumidentifier                     = 52
	acmeParserRULE_acmePropertyElement                = 53
	acmeParserRULE_acmePropertyCompoundElement        = 54
	acmeParserRULE_acmePropertySet                    = 55
	acmeParserRULE_acmePropertyRecordEntry            = 56
	acmeParserRULE_acmePropertyRecord                 = 57
	acmeParserRULE_acmePropertySequence               = 58
	acmeParserRULE_acmePropertyTypeRecord             = 59
	acmeParserRULE_acmePropertyTypeSet                = 60
	acmeParserRULE_acmePropertyTypeSequence           = 61
	acmeParserRULE_acmePropertyTypeEnum               = 62
	acmeParserRULE_acmePropertyRecordFieldDescription = 63
	acmeParserRULE_acmePropertyTypeRef                = 64
	acmeParserRULE_acmePropertyTypeStructure          = 65
	acmeParserRULE_acmePropertyTypeDeclaration        = 66
	acmeParserRULE_acmePropertyBlockEntry             = 67
	acmeParserRULE_acmePropertyBlock                  = 68
	acmeParserRULE_acmePropertyTypeInt                = 69
	acmeParserRULE_acmePropertyTypeAny                = 70
	acmeParserRULE_acmePropertyTypeFloat              = 71
	acmeParserRULE_acmePropertyTypeDouble             = 72
	acmeParserRULE_acmePropertyTypeString             = 73
	acmeParserRULE_acmePropertyTypeBoolean            = 74
	acmeParserRULE_acmeViewDeclaration                = 75
	acmeParserRULE_acmeViewTypeDeclaration            = 76
	acmeParserRULE_acmeViewBody                       = 77
	acmeParserRULE_designRule                         = 78
	acmeParserRULE_acmeDesignAnalysisDeclaration      = 79
	acmeParserRULE_formalParam                        = 80
	acmeParserRULE_terminatedDesignRuleExpression     = 81
	acmeParserRULE_designRuleExpression               = 82
	acmeParserRULE_aSTDRImpliesExpression             = 83
	acmeParserRULE_dRIffExpression                    = 84
	acmeParserRULE_dRAndExpression                    = 85
	acmeParserRULE_dRNegateExpression                 = 86
	acmeParserRULE_dREqualityExpression               = 87
	acmeParserRULE_dRRelationalExpression             = 88
	acmeParserRULE_dRAdditiveExpression               = 89
	acmeParserRULE_dRMultiplicativeExpression         = 90
	acmeParserRULE_dRNegativeExpression               = 91
	acmeParserRULE_primitiveExpression                = 92
	acmeParserRULE_parentheticalExpression            = 93
	acmeParserRULE_reference                          = 94
	acmeParserRULE_setReference                       = 95
	acmeParserRULE_actualParams                       = 96
	acmeParserRULE_literalConstant                    = 97
	acmeParserRULE_quantifiedExpression               = 98
	acmeParserRULE_distinctVariableSetDeclaration     = 99
	acmeParserRULE_variableSetDeclaration             = 100
	acmeParserRULE_sequenceExpression                 = 101
	acmeParserRULE_setExpression                      = 102
	acmeParserRULE_pathExpression                     = 103
	acmeParserRULE_pathExpressionContinuation         = 104
	acmeParserRULE_literalSet                         = 105
	acmeParserRULE_literalSequence                    = 106
	acmeParserRULE_literalRecordEntry                 = 107
	acmeParserRULE_literalRecord                      = 108
	acmeParserRULE_setConstructor                     = 109
	acmeParserRULE_acmeTypeRef                        = 110
)

// IAcmeCompUnitContext is an interface to support dynamic dispatch.
type IAcmeCompUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeCompUnitContext differentiates from other interfaces.
	IsAcmeCompUnitContext()
}

type AcmeCompUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeCompUnitContext() *AcmeCompUnitContext {
	var p = new(AcmeCompUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeCompUnit
	return p
}

func (*AcmeCompUnitContext) IsAcmeCompUnitContext() {}

func NewAcmeCompUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeCompUnitContext {
	var p = new(AcmeCompUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeCompUnit

	return p
}

func (s *AcmeCompUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeCompUnitContext) AllAcmeImportDeclaration() []IAcmeImportDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeImportDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeImportDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeImportDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeCompUnitContext) AcmeImportDeclaration(i int) IAcmeImportDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeImportDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeImportDeclarationContext)
}

func (s *AcmeCompUnitContext) AllAcmeSystemDeclaration() []IAcmeSystemDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeSystemDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeSystemDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeSystemDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeCompUnitContext) AcmeSystemDeclaration(i int) IAcmeSystemDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeSystemDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeSystemDeclarationContext)
}

func (s *AcmeCompUnitContext) AllAcmeFamilyDeclaration() []IAcmeFamilyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeFamilyDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeFamilyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeFamilyDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeCompUnitContext) AcmeFamilyDeclaration(i int) IAcmeFamilyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeFamilyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeFamilyDeclarationContext)
}

func (s *AcmeCompUnitContext) AllAcmeDesignDeclaration() []IAcmeDesignDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeDesignDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeDesignDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeDesignDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeCompUnitContext) AcmeDesignDeclaration(i int) IAcmeDesignDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeDesignDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeDesignDeclarationContext)
}

func (s *AcmeCompUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeCompUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeCompUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeCompUnit(s)
	}
}

func (s *AcmeCompUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeCompUnit(s)
	}
}

func (p *acmeParser) AcmeCompUnit() (localctx IAcmeCompUnitContext) {
	this := p
	_ = this

	localctx = NewAcmeCompUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, acmeParserRULE_acmeCompUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(225)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == acmeParserIMPORT {
		{
			p.SetState(222)
			p.AcmeImportDeclaration()
		}

		p.SetState(227)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(231)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == acmeParserDESIGN || _la == acmeParserFAMILY || _la == acmeParserSTYLE || _la == acmeParserSYSTEM {
		p.SetState(231)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserSYSTEM:
			{
				p.SetState(228)
				p.AcmeSystemDeclaration()
			}

		case acmeParserFAMILY, acmeParserSTYLE:
			{
				p.SetState(229)
				p.AcmeFamilyDeclaration()
			}

		case acmeParserDESIGN:
			{
				p.SetState(230)
				p.AcmeDesignDeclaration()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(233)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAcmeImportDeclarationContext is an interface to support dynamic dispatch.
type IAcmeImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeImportDeclarationContext differentiates from other interfaces.
	IsAcmeImportDeclarationContext()
}

type AcmeImportDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeImportDeclarationContext() *AcmeImportDeclarationContext {
	var p = new(AcmeImportDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeImportDeclaration
	return p
}

func (*AcmeImportDeclarationContext) IsAcmeImportDeclarationContext() {}

func NewAcmeImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeImportDeclarationContext {
	var p = new(AcmeImportDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeImportDeclaration

	return p
}

func (s *AcmeImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeImportDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(acmeParserIMPORT, 0)
}

func (s *AcmeImportDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeImportDeclarationContext) Filename() IFilenameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilenameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilenameContext)
}

func (s *AcmeImportDeclarationContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AcmeImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeImportDeclaration(s)
	}
}

func (s *AcmeImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeImportDeclaration(s)
	}
}

func (p *acmeParser) AcmeImportDeclaration() (localctx IAcmeImportDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, acmeParserRULE_acmeImportDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(235)
		p.Match(acmeParserIMPORT)
	}
	p.SetState(238)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserT__0, acmeParserREM, acmeParserIDENTIFIER:
		{
			p.SetState(236)
			p.Filename()
		}

	case acmeParserSTRING_LITERAL:
		{
			p.SetState(237)
			p.StringLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(240)
		p.Match(acmeParserSEMICOLON)
	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(acmeParserSTRING_LITERAL, 0)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *acmeParser) StringLiteral() (localctx IStringLiteralContext) {
	this := p
	_ = this

	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, acmeParserRULE_stringLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(242)
		p.Match(acmeParserSTRING_LITERAL)
	}

	return localctx
}

// IFilenameContext is an interface to support dynamic dispatch.
type IFilenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilenameContext differentiates from other interfaces.
	IsFilenameContext()
}

type FilenameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilenameContext() *FilenameContext {
	var p = new(FilenameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_filename
	return p
}

func (*FilenameContext) IsFilenameContext() {}

func NewFilenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilenameContext {
	var p = new(FilenameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_filename

	return p
}

func (s *FilenameContext) GetParser() antlr.Parser { return s.parser }

func (s *FilenameContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(acmeParserIDENTIFIER)
}

func (s *FilenameContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserIDENTIFIER, i)
}

func (s *FilenameContext) AllREM() []antlr.TerminalNode {
	return s.GetTokens(acmeParserREM)
}

func (s *FilenameContext) REM(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserREM, i)
}

func (s *FilenameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(acmeParserDOT)
}

func (s *FilenameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, i)
}

func (s *FilenameContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOLON)
}

func (s *FilenameContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, i)
}

func (s *FilenameContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(acmeParserMINUS)
}

func (s *FilenameContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserMINUS, i)
}

func (s *FilenameContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(acmeParserPLUS)
}

func (s *FilenameContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserPLUS, i)
}

func (s *FilenameContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(acmeParserSLASH)
}

func (s *FilenameContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserSLASH, i)
}

func (s *FilenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterFilename(s)
	}
}

func (s *FilenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitFilename(s)
	}
}

func (p *acmeParser) Filename() (localctx IFilenameContext) {
	this := p
	_ = this

	localctx = NewFilenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, acmeParserRULE_filename)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(245)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserT__0 || _la == acmeParserREM {
		{
			p.SetState(244)
			_la = p.GetTokenStream().LA(1)

			if !(_la == acmeParserT__0 || _la == acmeParserREM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(247)
		p.Match(acmeParserIDENTIFIER)
	}
	p.SetState(256)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<acmeParserT__0)|(1<<acmeParserT__1)|(1<<acmeParserT__2)|(1<<acmeParserCOLON)|(1<<acmeParserDOT))) != 0) || (((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(acmeParserMINUS-61))|(1<<(acmeParserPLUS-61))|(1<<(acmeParserREM-61))|(1<<(acmeParserSLASH-61)))) != 0) {
		p.SetState(249)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<acmeParserT__0)|(1<<acmeParserT__1)|(1<<acmeParserT__2)|(1<<acmeParserCOLON)|(1<<acmeParserDOT))) != 0) || (((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(acmeParserMINUS-61))|(1<<(acmeParserPLUS-61))|(1<<(acmeParserREM-61))|(1<<(acmeParserSLASH-61)))) != 0) {
			{
				p.SetState(248)
				_la = p.GetTokenStream().LA(1)

				if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<acmeParserT__0)|(1<<acmeParserT__1)|(1<<acmeParserT__2)|(1<<acmeParserCOLON)|(1<<acmeParserDOT))) != 0) || (((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(acmeParserMINUS-61))|(1<<(acmeParserPLUS-61))|(1<<(acmeParserREM-61))|(1<<(acmeParserSLASH-61)))) != 0)) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(251)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(253)
			p.Match(acmeParserIDENTIFIER)
		}

		p.SetState(258)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(acmeParserIDENTIFIER, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *acmeParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, acmeParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(259)
		p.Match(acmeParserIDENTIFIER)
	}

	return localctx
}

// ICodeLiteralContext is an interface to support dynamic dispatch.
type ICodeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCodeLiteralContext differentiates from other interfaces.
	IsCodeLiteralContext()
}

type CodeLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeLiteralContext() *CodeLiteralContext {
	var p = new(CodeLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_codeLiteral
	return p
}

func (*CodeLiteralContext) IsCodeLiteralContext() {}

func NewCodeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeLiteralContext {
	var p = new(CodeLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_codeLiteral

	return p
}

func (s *CodeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeLiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(acmeParserSTRING_LITERAL, 0)
}

func (s *CodeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterCodeLiteral(s)
	}
}

func (s *CodeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitCodeLiteral(s)
	}
}

func (p *acmeParser) CodeLiteral() (localctx ICodeLiteralContext) {
	this := p
	_ = this

	localctx = NewCodeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, acmeParserRULE_codeLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(261)
		p.Match(acmeParserSTRING_LITERAL)
	}

	return localctx
}

// IAcmeFamilyDeclarationContext is an interface to support dynamic dispatch.
type IAcmeFamilyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeFamilyDeclarationContext differentiates from other interfaces.
	IsAcmeFamilyDeclarationContext()
}

type AcmeFamilyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeFamilyDeclarationContext() *AcmeFamilyDeclarationContext {
	var p = new(AcmeFamilyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeFamilyDeclaration
	return p
}

func (*AcmeFamilyDeclarationContext) IsAcmeFamilyDeclarationContext() {}

func NewAcmeFamilyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeFamilyDeclarationContext {
	var p = new(AcmeFamilyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeFamilyDeclaration

	return p
}

func (s *AcmeFamilyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeFamilyDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeFamilyDeclarationContext) FAMILY() antlr.TerminalNode {
	return s.GetToken(acmeParserFAMILY, 0)
}

func (s *AcmeFamilyDeclarationContext) STYLE() antlr.TerminalNode {
	return s.GetToken(acmeParserSTYLE, 0)
}

func (s *AcmeFamilyDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeFamilyDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeFamilyDeclarationContext) AcmeFamilyBody() IAcmeFamilyBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeFamilyBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeFamilyBodyContext)
}

func (s *AcmeFamilyDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDS, 0)
}

func (s *AcmeFamilyDeclarationContext) AllAcmeFamilyRef() []IAcmeFamilyRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeFamilyRefContext)(nil)).Elem())
	var tst = make([]IAcmeFamilyRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeFamilyRefContext)
		}
	}

	return tst
}

func (s *AcmeFamilyDeclarationContext) AcmeFamilyRef(i int) IAcmeFamilyRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeFamilyRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeFamilyRefContext)
}

func (s *AcmeFamilyDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmeFamilyDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmeFamilyDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmeFamilyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeFamilyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeFamilyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeFamilyDeclaration(s)
	}
}

func (s *AcmeFamilyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeFamilyDeclaration(s)
	}
}

func (p *acmeParser) AcmeFamilyDeclaration() (localctx IAcmeFamilyDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeFamilyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, acmeParserRULE_acmeFamilyDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(263)
		_la = p.GetTokenStream().LA(1)

		if !(_la == acmeParserFAMILY || _la == acmeParserSTYLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(264)
		p.Identifier()
	}
	p.SetState(288)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(265)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN:
		{
			p.SetState(266)
			p.Match(acmeParserASSIGN)
		}
		{
			p.SetState(267)
			p.AcmeFamilyBody()
		}
		p.SetState(269)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserSEMICOLON {
			{
				p.SetState(268)
				p.Match(acmeParserSEMICOLON)
			}

		}

	case acmeParserEXTENDS:
		{
			p.SetState(271)
			p.Match(acmeParserEXTENDS)
		}
		{
			p.SetState(272)
			p.AcmeFamilyRef()
		}
		p.SetState(277)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserCOMMA {
			{
				p.SetState(273)
				p.Match(acmeParserCOMMA)
			}
			{
				p.SetState(274)
				p.AcmeFamilyRef()
			}

			p.SetState(279)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(286)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserSEMICOLON:
			{
				p.SetState(280)
				p.Match(acmeParserSEMICOLON)
			}

		case acmeParserWITH:
			{
				p.SetState(281)
				p.Match(acmeParserWITH)
			}
			{
				p.SetState(282)
				p.AcmeFamilyBody()
			}
			p.SetState(284)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == acmeParserSEMICOLON {
				{
					p.SetState(283)
					p.Match(acmeParserSEMICOLON)
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmeFamilyBodyContext is an interface to support dynamic dispatch.
type IAcmeFamilyBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeFamilyBodyContext differentiates from other interfaces.
	IsAcmeFamilyBodyContext()
}

type AcmeFamilyBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeFamilyBodyContext() *AcmeFamilyBodyContext {
	var p = new(AcmeFamilyBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeFamilyBody
	return p
}

func (*AcmeFamilyBodyContext) IsAcmeFamilyBodyContext() {}

func NewAcmeFamilyBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeFamilyBodyContext {
	var p = new(AcmeFamilyBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeFamilyBody

	return p
}

func (s *AcmeFamilyBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeFamilyBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmeFamilyBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmeFamilyBodyContext) AllAcmeDesignAnalysisDeclaration() []IAcmeDesignAnalysisDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeDesignAnalysisDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeDesignAnalysisDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeDesignAnalysisDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmeDesignAnalysisDeclaration(i int) IAcmeDesignAnalysisDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeDesignAnalysisDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeDesignAnalysisDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllDesignRule() []IDesignRuleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem())
	var tst = make([]IDesignRuleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDesignRuleContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) DesignRule(i int) IDesignRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleContext)
}

func (s *AcmeFamilyBodyContext) AllAcmePortDeclaration() []IAcmePortDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePortDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmePortDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePortDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmePortDeclaration(i int) IAcmePortDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePortDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePortDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllAcmeRoleDeclaration() []IAcmeRoleDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeRoleDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeRoleDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeRoleDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmeRoleDeclaration(i int) IAcmeRoleDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeRoleDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeRoleDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllAcmeComponentDeclaration() []IAcmeComponentDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeComponentDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeComponentDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeComponentDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmeComponentDeclaration(i int) IAcmeComponentDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeComponentDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeComponentDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllAcmeConnectorDeclaration() []IAcmeConnectorDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeConnectorDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeConnectorDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeConnectorDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmeConnectorDeclaration(i int) IAcmeConnectorDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeConnectorDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeConnectorDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllAcmePropertyDeclaration() []IAcmePropertyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmePropertyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePropertyDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmePropertyDeclaration(i int) IAcmePropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllAcmeGroupDeclaration() []IAcmeGroupDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeGroupDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeGroupDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeGroupDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmeGroupDeclaration(i int) IAcmeGroupDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeGroupDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeGroupDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllAcmeAttachmentDeclaration() []IAcmeAttachmentDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeAttachmentDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeAttachmentDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeAttachmentDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmeAttachmentDeclaration(i int) IAcmeAttachmentDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeAttachmentDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeAttachmentDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllAcmePortTypeDeclaration() []IAcmePortTypeDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePortTypeDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmePortTypeDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePortTypeDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmePortTypeDeclaration(i int) IAcmePortTypeDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePortTypeDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePortTypeDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllAcmeRoleTypeDeclaration() []IAcmeRoleTypeDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeRoleTypeDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeRoleTypeDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeRoleTypeDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmeRoleTypeDeclaration(i int) IAcmeRoleTypeDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeRoleTypeDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeRoleTypeDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllAcmeComponentTypeDeclaration() []IAcmeComponentTypeDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeComponentTypeDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeComponentTypeDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeComponentTypeDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmeComponentTypeDeclaration(i int) IAcmeComponentTypeDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeComponentTypeDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeComponentTypeDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllAcmeConnectorTypeDeclaration() []IAcmeConnectorTypeDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeConnectorTypeDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeConnectorTypeDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeConnectorTypeDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmeConnectorTypeDeclaration(i int) IAcmeConnectorTypeDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeConnectorTypeDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeConnectorTypeDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllAcmeGenericElementTypeDeclaration() []IAcmeGenericElementTypeDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeGenericElementTypeDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeGenericElementTypeDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeGenericElementTypeDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmeGenericElementTypeDeclaration(i int) IAcmeGenericElementTypeDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeGenericElementTypeDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeGenericElementTypeDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllAcmePropertyTypeDeclaration() []IAcmePropertyTypeDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePropertyTypeDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmePropertyTypeDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePropertyTypeDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmePropertyTypeDeclaration(i int) IAcmePropertyTypeDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllAcmeGroupTypeDeclaration() []IAcmeGroupTypeDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeGroupTypeDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeGroupTypeDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeGroupTypeDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeFamilyBodyContext) AcmeGroupTypeDeclaration(i int) IAcmeGroupTypeDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeGroupTypeDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeGroupTypeDeclarationContext)
}

func (s *AcmeFamilyBodyContext) AllPUBLIC() []antlr.TerminalNode {
	return s.GetTokens(acmeParserPUBLIC)
}

func (s *AcmeFamilyBodyContext) PUBLIC(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserPUBLIC, i)
}

func (s *AcmeFamilyBodyContext) AllPRIVATE() []antlr.TerminalNode {
	return s.GetTokens(acmeParserPRIVATE)
}

func (s *AcmeFamilyBodyContext) PRIVATE(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserPRIVATE, i)
}

func (s *AcmeFamilyBodyContext) AllFINAL() []antlr.TerminalNode {
	return s.GetTokens(acmeParserFINAL)
}

func (s *AcmeFamilyBodyContext) FINAL(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserFINAL, i)
}

func (s *AcmeFamilyBodyContext) AllABSTRACT() []antlr.TerminalNode {
	return s.GetTokens(acmeParserABSTRACT)
}

func (s *AcmeFamilyBodyContext) ABSTRACT(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserABSTRACT, i)
}

func (s *AcmeFamilyBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeFamilyBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeFamilyBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeFamilyBody(s)
	}
}

func (s *AcmeFamilyBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeFamilyBody(s)
	}
}

func (p *acmeParser) AcmeFamilyBody() (localctx IAcmeFamilyBodyContext) {
	this := p
	_ = this

	localctx = NewAcmeFamilyBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, acmeParserRULE_acmeFamilyBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(290)
		p.Match(acmeParserLBRACE)
	}
	p.SetState(319)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<acmeParserABSTRACT)|(1<<acmeParserANALYSIS)|(1<<acmeParserATTACHMENT)|(1<<acmeParserCOMPONENT)|(1<<acmeParserCONNECTOR)|(1<<acmeParserDESIGN)|(1<<acmeParserELEMENT)|(1<<acmeParserEXTERNAL))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(acmeParserFINAL-36))|(1<<(acmeParserGROUP-36))|(1<<(acmeParserHEURISTIC-36))|(1<<(acmeParserINVARIANT-36))|(1<<(acmeParserPUBLIC-36))|(1<<(acmeParserPRIVATE-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(acmeParserPORT-68))|(1<<(acmeParserPROPERTY-68))|(1<<(acmeParserPROPBEGIN-68))|(1<<(acmeParserROLE-68))|(1<<(acmeParserRULE-68))|(1<<(acmeParserSEMICOLON-68)))) != 0) {
		p.SetState(317)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) {
		case 1:
			p.SetState(292)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == acmeParserPUBLIC || _la == acmeParserPRIVATE {
				{
					p.SetState(291)
					_la = p.GetTokenStream().LA(1)

					if !(_la == acmeParserPUBLIC || _la == acmeParserPRIVATE) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(295)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == acmeParserABSTRACT || _la == acmeParserFINAL {
				{
					p.SetState(294)
					_la = p.GetTokenStream().LA(1)

					if !(_la == acmeParserABSTRACT || _la == acmeParserFINAL) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(304)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserPORT:
				{
					p.SetState(297)
					p.AcmePortTypeDeclaration()
				}

			case acmeParserROLE:
				{
					p.SetState(298)
					p.AcmeRoleTypeDeclaration()
				}

			case acmeParserCOMPONENT:
				{
					p.SetState(299)
					p.AcmeComponentTypeDeclaration()
				}

			case acmeParserCONNECTOR:
				{
					p.SetState(300)
					p.AcmeConnectorTypeDeclaration()
				}

			case acmeParserELEMENT:
				{
					p.SetState(301)
					p.AcmeGenericElementTypeDeclaration()
				}

			case acmeParserPROPERTY:
				{
					p.SetState(302)
					p.AcmePropertyTypeDeclaration()
				}

			case acmeParserGROUP:
				{
					p.SetState(303)
					p.AcmeGroupTypeDeclaration()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		case 2:
			p.SetState(315)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(306)
					p.AcmeDesignAnalysisDeclaration()
				}

			case 2:
				{
					p.SetState(307)
					p.DesignRule()
				}

			case 3:
				{
					p.SetState(308)
					p.AcmePortDeclaration()
				}

			case 4:
				{
					p.SetState(309)
					p.AcmeRoleDeclaration()
				}

			case 5:
				{
					p.SetState(310)
					p.AcmeComponentDeclaration()
				}

			case 6:
				{
					p.SetState(311)
					p.AcmeConnectorDeclaration()
				}

			case 7:
				{
					p.SetState(312)
					p.AcmePropertyDeclaration()
				}

			case 8:
				{
					p.SetState(313)
					p.AcmeGroupDeclaration()
				}

			case 9:
				{
					p.SetState(314)
					p.AcmeAttachmentDeclaration()
				}

			}

		}

		p.SetState(321)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(322)
		p.Match(acmeParserRBRACE)
	}

	return localctx
}

// IAcmeSystemDeclarationContext is an interface to support dynamic dispatch.
type IAcmeSystemDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeSystemDeclarationContext differentiates from other interfaces.
	IsAcmeSystemDeclarationContext()
}

type AcmeSystemDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeSystemDeclarationContext() *AcmeSystemDeclarationContext {
	var p = new(AcmeSystemDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeSystemDeclaration
	return p
}

func (*AcmeSystemDeclarationContext) IsAcmeSystemDeclarationContext() {}

func NewAcmeSystemDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeSystemDeclarationContext {
	var p = new(AcmeSystemDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeSystemDeclaration

	return p
}

func (s *AcmeSystemDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeSystemDeclarationContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(acmeParserSYSTEM, 0)
}

func (s *AcmeSystemDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeSystemDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *AcmeSystemDeclarationContext) AllAcmeFamilyRef() []IAcmeFamilyRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeFamilyRefContext)(nil)).Elem())
	var tst = make([]IAcmeFamilyRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeFamilyRefContext)
		}
	}

	return tst
}

func (s *AcmeSystemDeclarationContext) AcmeFamilyRef(i int) IAcmeFamilyRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeFamilyRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeFamilyRefContext)
}

func (s *AcmeSystemDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeSystemDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeSystemDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmeSystemDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmeSystemDeclarationContext) AcmeSystemBody() IAcmeSystemBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeSystemBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeSystemBodyContext)
}

func (s *AcmeSystemDeclarationContext) NEW() antlr.TerminalNode {
	return s.GetToken(acmeParserNEW, 0)
}

func (s *AcmeSystemDeclarationContext) AllAcmeFamilyInstantiationRef() []IAcmeFamilyInstantiationRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeFamilyInstantiationRefContext)(nil)).Elem())
	var tst = make([]IAcmeFamilyInstantiationRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeFamilyInstantiationRefContext)
		}
	}

	return tst
}

func (s *AcmeSystemDeclarationContext) AcmeFamilyInstantiationRef(i int) IAcmeFamilyInstantiationRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeFamilyInstantiationRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeFamilyInstantiationRefContext)
}

func (s *AcmeSystemDeclarationContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDED, 0)
}

func (s *AcmeSystemDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmeSystemDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeSystemDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeSystemDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeSystemDeclaration(s)
	}
}

func (s *AcmeSystemDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeSystemDeclaration(s)
	}
}

func (p *acmeParser) AcmeSystemDeclaration() (localctx IAcmeSystemDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeSystemDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, acmeParserRULE_acmeSystemDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(324)
		p.Match(acmeParserSYSTEM)
	}
	{
		p.SetState(325)
		p.Identifier()
	}
	p.SetState(335)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserCOLON {
		{
			p.SetState(326)
			p.Match(acmeParserCOLON)
		}
		{
			p.SetState(327)
			p.AcmeFamilyRef()
		}
		p.SetState(332)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserCOMMA {
			{
				p.SetState(328)
				p.Match(acmeParserCOMMA)
			}
			{
				p.SetState(329)
				p.AcmeFamilyRef()
			}

			p.SetState(334)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(363)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(337)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN:
		{
			p.SetState(338)
			p.Match(acmeParserASSIGN)
		}
		p.SetState(361)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserLBRACE:
			{
				p.SetState(339)
				p.AcmeSystemBody()
			}
			p.SetState(341)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == acmeParserSEMICOLON {
				{
					p.SetState(340)
					p.Match(acmeParserSEMICOLON)
				}

			}

		case acmeParserNEW:
			{
				p.SetState(343)
				p.Match(acmeParserNEW)
			}
			{
				p.SetState(344)
				p.AcmeFamilyInstantiationRef()
			}
			p.SetState(349)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserCOMMA {
				{
					p.SetState(345)
					p.Match(acmeParserCOMMA)
				}
				{
					p.SetState(346)
					p.AcmeFamilyInstantiationRef()
				}

				p.SetState(351)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(359)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSEMICOLON:
				{
					p.SetState(352)
					p.Match(acmeParserSEMICOLON)
				}

			case acmeParserEXTENDED:
				{
					p.SetState(353)
					p.Match(acmeParserEXTENDED)
				}
				{
					p.SetState(354)
					p.Match(acmeParserWITH)
				}
				{
					p.SetState(355)
					p.AcmeSystemBody()
				}
				p.SetState(357)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == acmeParserSEMICOLON {
					{
						p.SetState(356)
						p.Match(acmeParserSEMICOLON)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmeSystemBodyContext is an interface to support dynamic dispatch.
type IAcmeSystemBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeSystemBodyContext differentiates from other interfaces.
	IsAcmeSystemBodyContext()
}

type AcmeSystemBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeSystemBodyContext() *AcmeSystemBodyContext {
	var p = new(AcmeSystemBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeSystemBody
	return p
}

func (*AcmeSystemBodyContext) IsAcmeSystemBodyContext() {}

func NewAcmeSystemBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeSystemBodyContext {
	var p = new(AcmeSystemBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeSystemBody

	return p
}

func (s *AcmeSystemBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeSystemBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmeSystemBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmeSystemBodyContext) AllAcmePropertyDeclaration() []IAcmePropertyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmePropertyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePropertyDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeSystemBodyContext) AcmePropertyDeclaration(i int) IAcmePropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyDeclarationContext)
}

func (s *AcmeSystemBodyContext) AllAcmeComponentDeclaration() []IAcmeComponentDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeComponentDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeComponentDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeComponentDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeSystemBodyContext) AcmeComponentDeclaration(i int) IAcmeComponentDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeComponentDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeComponentDeclarationContext)
}

func (s *AcmeSystemBodyContext) AllAcmeConnectorDeclaration() []IAcmeConnectorDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeConnectorDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeConnectorDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeConnectorDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeSystemBodyContext) AcmeConnectorDeclaration(i int) IAcmeConnectorDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeConnectorDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeConnectorDeclarationContext)
}

func (s *AcmeSystemBodyContext) AllAcmeAttachmentDeclaration() []IAcmeAttachmentDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeAttachmentDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeAttachmentDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeAttachmentDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeSystemBodyContext) AcmeAttachmentDeclaration(i int) IAcmeAttachmentDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeAttachmentDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeAttachmentDeclarationContext)
}

func (s *AcmeSystemBodyContext) AllAcmeGroupDeclaration() []IAcmeGroupDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeGroupDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeGroupDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeGroupDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeSystemBodyContext) AcmeGroupDeclaration(i int) IAcmeGroupDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeGroupDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeGroupDeclarationContext)
}

func (s *AcmeSystemBodyContext) AllDesignRule() []IDesignRuleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem())
	var tst = make([]IDesignRuleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDesignRuleContext)
		}
	}

	return tst
}

func (s *AcmeSystemBodyContext) DesignRule(i int) IDesignRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleContext)
}

func (s *AcmeSystemBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeSystemBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeSystemBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeSystemBody(s)
	}
}

func (s *AcmeSystemBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeSystemBody(s)
	}
}

func (p *acmeParser) AcmeSystemBody() (localctx IAcmeSystemBodyContext) {
	this := p
	_ = this

	localctx = NewAcmeSystemBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, acmeParserRULE_acmeSystemBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(365)
		p.Match(acmeParserLBRACE)
	}
	p.SetState(374)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<acmeParserATTACHMENT)|(1<<acmeParserCOMPONENT)|(1<<acmeParserCONNECTOR)|(1<<acmeParserDESIGN))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(acmeParserGROUP-39))|(1<<(acmeParserHEURISTIC-39))|(1<<(acmeParserINVARIANT-39))|(1<<(acmeParserPROPERTY-39)))) != 0) || (((_la-72)&-(0x1f+1)) == 0 && ((1<<uint((_la-72)))&((1<<(acmeParserPROPBEGIN-72))|(1<<(acmeParserRULE-72))|(1<<(acmeParserSEMICOLON-72)))) != 0) {
		p.SetState(372)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserPROPERTY:
			{
				p.SetState(366)
				p.AcmePropertyDeclaration()
			}

		case acmeParserCOMPONENT:
			{
				p.SetState(367)
				p.AcmeComponentDeclaration()
			}

		case acmeParserCONNECTOR:
			{
				p.SetState(368)
				p.AcmeConnectorDeclaration()
			}

		case acmeParserATTACHMENT:
			{
				p.SetState(369)
				p.AcmeAttachmentDeclaration()
			}

		case acmeParserGROUP:
			{
				p.SetState(370)
				p.AcmeGroupDeclaration()
			}

		case acmeParserDESIGN, acmeParserHEURISTIC, acmeParserINVARIANT, acmeParserPROPBEGIN, acmeParserRULE, acmeParserSEMICOLON:
			{
				p.SetState(371)
				p.DesignRule()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(376)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(377)
		p.Match(acmeParserRBRACE)
	}

	return localctx
}

// IAcmeDesignDeclarationContext is an interface to support dynamic dispatch.
type IAcmeDesignDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeDesignDeclarationContext differentiates from other interfaces.
	IsAcmeDesignDeclarationContext()
}

type AcmeDesignDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeDesignDeclarationContext() *AcmeDesignDeclarationContext {
	var p = new(AcmeDesignDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeDesignDeclaration
	return p
}

func (*AcmeDesignDeclarationContext) IsAcmeDesignDeclarationContext() {}

func NewAcmeDesignDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeDesignDeclarationContext {
	var p = new(AcmeDesignDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeDesignDeclaration

	return p
}

func (s *AcmeDesignDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeDesignDeclarationContext) DESIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserDESIGN, 0)
}

func (s *AcmeDesignDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeDesignDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeDesignDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeDesignDeclaration(s)
	}
}

func (s *AcmeDesignDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeDesignDeclaration(s)
	}
}

func (p *acmeParser) AcmeDesignDeclaration() (localctx IAcmeDesignDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeDesignDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, acmeParserRULE_acmeDesignDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.Match(acmeParserDESIGN)
	}

	return localctx
}

// IAcmeComponentTypeRefContext is an interface to support dynamic dispatch.
type IAcmeComponentTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeComponentTypeRefContext differentiates from other interfaces.
	IsAcmeComponentTypeRefContext()
}

type AcmeComponentTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeComponentTypeRefContext() *AcmeComponentTypeRefContext {
	var p = new(AcmeComponentTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeComponentTypeRef
	return p
}

func (*AcmeComponentTypeRefContext) IsAcmeComponentTypeRefContext() {}

func NewAcmeComponentTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeComponentTypeRefContext {
	var p = new(AcmeComponentTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeComponentTypeRef

	return p
}

func (s *AcmeComponentTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeComponentTypeRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmeComponentTypeRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeComponentTypeRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmeComponentTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeComponentTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeComponentTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeComponentTypeRef(s)
	}
}

func (s *AcmeComponentTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeComponentTypeRef(s)
	}
}

func (p *acmeParser) AcmeComponentTypeRef() (localctx IAcmeComponentTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmeComponentTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, acmeParserRULE_acmeComponentTypeRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(381)
		p.Identifier()
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(382)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(383)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmeComponentInstantiatedTypeRefContext is an interface to support dynamic dispatch.
type IAcmeComponentInstantiatedTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeComponentInstantiatedTypeRefContext differentiates from other interfaces.
	IsAcmeComponentInstantiatedTypeRefContext()
}

type AcmeComponentInstantiatedTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeComponentInstantiatedTypeRefContext() *AcmeComponentInstantiatedTypeRefContext {
	var p = new(AcmeComponentInstantiatedTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeComponentInstantiatedTypeRef
	return p
}

func (*AcmeComponentInstantiatedTypeRefContext) IsAcmeComponentInstantiatedTypeRefContext() {}

func NewAcmeComponentInstantiatedTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeComponentInstantiatedTypeRefContext {
	var p = new(AcmeComponentInstantiatedTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeComponentInstantiatedTypeRef

	return p
}

func (s *AcmeComponentInstantiatedTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeComponentInstantiatedTypeRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmeComponentInstantiatedTypeRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeComponentInstantiatedTypeRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmeComponentInstantiatedTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeComponentInstantiatedTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeComponentInstantiatedTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeComponentInstantiatedTypeRef(s)
	}
}

func (s *AcmeComponentInstantiatedTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeComponentInstantiatedTypeRef(s)
	}
}

func (p *acmeParser) AcmeComponentInstantiatedTypeRef() (localctx IAcmeComponentInstantiatedTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmeComponentInstantiatedTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, acmeParserRULE_acmeComponentInstantiatedTypeRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(386)
		p.Identifier()
	}
	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(387)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(388)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmeConnectorTypeRefContext is an interface to support dynamic dispatch.
type IAcmeConnectorTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeConnectorTypeRefContext differentiates from other interfaces.
	IsAcmeConnectorTypeRefContext()
}

type AcmeConnectorTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeConnectorTypeRefContext() *AcmeConnectorTypeRefContext {
	var p = new(AcmeConnectorTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeConnectorTypeRef
	return p
}

func (*AcmeConnectorTypeRefContext) IsAcmeConnectorTypeRefContext() {}

func NewAcmeConnectorTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeConnectorTypeRefContext {
	var p = new(AcmeConnectorTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeConnectorTypeRef

	return p
}

func (s *AcmeConnectorTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeConnectorTypeRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmeConnectorTypeRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeConnectorTypeRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmeConnectorTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeConnectorTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeConnectorTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeConnectorTypeRef(s)
	}
}

func (s *AcmeConnectorTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeConnectorTypeRef(s)
	}
}

func (p *acmeParser) AcmeConnectorTypeRef() (localctx IAcmeConnectorTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmeConnectorTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, acmeParserRULE_acmeConnectorTypeRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(391)
		p.Identifier()
	}
	p.SetState(394)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(392)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(393)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmeConnectorInstantiatedTypeRefContext is an interface to support dynamic dispatch.
type IAcmeConnectorInstantiatedTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeConnectorInstantiatedTypeRefContext differentiates from other interfaces.
	IsAcmeConnectorInstantiatedTypeRefContext()
}

type AcmeConnectorInstantiatedTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeConnectorInstantiatedTypeRefContext() *AcmeConnectorInstantiatedTypeRefContext {
	var p = new(AcmeConnectorInstantiatedTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeConnectorInstantiatedTypeRef
	return p
}

func (*AcmeConnectorInstantiatedTypeRefContext) IsAcmeConnectorInstantiatedTypeRefContext() {}

func NewAcmeConnectorInstantiatedTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeConnectorInstantiatedTypeRefContext {
	var p = new(AcmeConnectorInstantiatedTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeConnectorInstantiatedTypeRef

	return p
}

func (s *AcmeConnectorInstantiatedTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeConnectorInstantiatedTypeRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmeConnectorInstantiatedTypeRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeConnectorInstantiatedTypeRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmeConnectorInstantiatedTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeConnectorInstantiatedTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeConnectorInstantiatedTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeConnectorInstantiatedTypeRef(s)
	}
}

func (s *AcmeConnectorInstantiatedTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeConnectorInstantiatedTypeRef(s)
	}
}

func (p *acmeParser) AcmeConnectorInstantiatedTypeRef() (localctx IAcmeConnectorInstantiatedTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmeConnectorInstantiatedTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, acmeParserRULE_acmeConnectorInstantiatedTypeRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(396)
		p.Identifier()
	}
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(397)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(398)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmePortTypeRefContext is an interface to support dynamic dispatch.
type IAcmePortTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePortTypeRefContext differentiates from other interfaces.
	IsAcmePortTypeRefContext()
}

type AcmePortTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePortTypeRefContext() *AcmePortTypeRefContext {
	var p = new(AcmePortTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePortTypeRef
	return p
}

func (*AcmePortTypeRefContext) IsAcmePortTypeRefContext() {}

func NewAcmePortTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePortTypeRefContext {
	var p = new(AcmePortTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePortTypeRef

	return p
}

func (s *AcmePortTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePortTypeRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmePortTypeRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmePortTypeRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmePortTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePortTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePortTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePortTypeRef(s)
	}
}

func (s *AcmePortTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePortTypeRef(s)
	}
}

func (p *acmeParser) AcmePortTypeRef() (localctx IAcmePortTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmePortTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, acmeParserRULE_acmePortTypeRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(401)
		p.Identifier()
	}
	p.SetState(404)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(402)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(403)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmePortInstantiatedTypeRefContext is an interface to support dynamic dispatch.
type IAcmePortInstantiatedTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePortInstantiatedTypeRefContext differentiates from other interfaces.
	IsAcmePortInstantiatedTypeRefContext()
}

type AcmePortInstantiatedTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePortInstantiatedTypeRefContext() *AcmePortInstantiatedTypeRefContext {
	var p = new(AcmePortInstantiatedTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePortInstantiatedTypeRef
	return p
}

func (*AcmePortInstantiatedTypeRefContext) IsAcmePortInstantiatedTypeRefContext() {}

func NewAcmePortInstantiatedTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePortInstantiatedTypeRefContext {
	var p = new(AcmePortInstantiatedTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePortInstantiatedTypeRef

	return p
}

func (s *AcmePortInstantiatedTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePortInstantiatedTypeRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmePortInstantiatedTypeRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmePortInstantiatedTypeRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmePortInstantiatedTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePortInstantiatedTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePortInstantiatedTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePortInstantiatedTypeRef(s)
	}
}

func (s *AcmePortInstantiatedTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePortInstantiatedTypeRef(s)
	}
}

func (p *acmeParser) AcmePortInstantiatedTypeRef() (localctx IAcmePortInstantiatedTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmePortInstantiatedTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, acmeParserRULE_acmePortInstantiatedTypeRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(406)
		p.Identifier()
	}
	p.SetState(409)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(407)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(408)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmeGroupTypeRefContext is an interface to support dynamic dispatch.
type IAcmeGroupTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeGroupTypeRefContext differentiates from other interfaces.
	IsAcmeGroupTypeRefContext()
}

type AcmeGroupTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeGroupTypeRefContext() *AcmeGroupTypeRefContext {
	var p = new(AcmeGroupTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeGroupTypeRef
	return p
}

func (*AcmeGroupTypeRefContext) IsAcmeGroupTypeRefContext() {}

func NewAcmeGroupTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeGroupTypeRefContext {
	var p = new(AcmeGroupTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeGroupTypeRef

	return p
}

func (s *AcmeGroupTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeGroupTypeRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmeGroupTypeRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeGroupTypeRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmeGroupTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeGroupTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeGroupTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeGroupTypeRef(s)
	}
}

func (s *AcmeGroupTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeGroupTypeRef(s)
	}
}

func (p *acmeParser) AcmeGroupTypeRef() (localctx IAcmeGroupTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmeGroupTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, acmeParserRULE_acmeGroupTypeRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(411)
		p.Identifier()
	}
	p.SetState(414)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(412)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(413)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmeGroupInstantiatedTypeRefContext is an interface to support dynamic dispatch.
type IAcmeGroupInstantiatedTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeGroupInstantiatedTypeRefContext differentiates from other interfaces.
	IsAcmeGroupInstantiatedTypeRefContext()
}

type AcmeGroupInstantiatedTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeGroupInstantiatedTypeRefContext() *AcmeGroupInstantiatedTypeRefContext {
	var p = new(AcmeGroupInstantiatedTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeGroupInstantiatedTypeRef
	return p
}

func (*AcmeGroupInstantiatedTypeRefContext) IsAcmeGroupInstantiatedTypeRefContext() {}

func NewAcmeGroupInstantiatedTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeGroupInstantiatedTypeRefContext {
	var p = new(AcmeGroupInstantiatedTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeGroupInstantiatedTypeRef

	return p
}

func (s *AcmeGroupInstantiatedTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeGroupInstantiatedTypeRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmeGroupInstantiatedTypeRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeGroupInstantiatedTypeRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmeGroupInstantiatedTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeGroupInstantiatedTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeGroupInstantiatedTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeGroupInstantiatedTypeRef(s)
	}
}

func (s *AcmeGroupInstantiatedTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeGroupInstantiatedTypeRef(s)
	}
}

func (p *acmeParser) AcmeGroupInstantiatedTypeRef() (localctx IAcmeGroupInstantiatedTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmeGroupInstantiatedTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, acmeParserRULE_acmeGroupInstantiatedTypeRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(416)
		p.Identifier()
	}
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(417)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(418)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmeRoleTypeRefContext is an interface to support dynamic dispatch.
type IAcmeRoleTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeRoleTypeRefContext differentiates from other interfaces.
	IsAcmeRoleTypeRefContext()
}

type AcmeRoleTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeRoleTypeRefContext() *AcmeRoleTypeRefContext {
	var p = new(AcmeRoleTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeRoleTypeRef
	return p
}

func (*AcmeRoleTypeRefContext) IsAcmeRoleTypeRefContext() {}

func NewAcmeRoleTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeRoleTypeRefContext {
	var p = new(AcmeRoleTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeRoleTypeRef

	return p
}

func (s *AcmeRoleTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeRoleTypeRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmeRoleTypeRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeRoleTypeRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmeRoleTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeRoleTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeRoleTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeRoleTypeRef(s)
	}
}

func (s *AcmeRoleTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeRoleTypeRef(s)
	}
}

func (p *acmeParser) AcmeRoleTypeRef() (localctx IAcmeRoleTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmeRoleTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, acmeParserRULE_acmeRoleTypeRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(421)
		p.Identifier()
	}
	p.SetState(424)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(422)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(423)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmeRoleInstantiatedTypeRefContext is an interface to support dynamic dispatch.
type IAcmeRoleInstantiatedTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeRoleInstantiatedTypeRefContext differentiates from other interfaces.
	IsAcmeRoleInstantiatedTypeRefContext()
}

type AcmeRoleInstantiatedTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeRoleInstantiatedTypeRefContext() *AcmeRoleInstantiatedTypeRefContext {
	var p = new(AcmeRoleInstantiatedTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeRoleInstantiatedTypeRef
	return p
}

func (*AcmeRoleInstantiatedTypeRefContext) IsAcmeRoleInstantiatedTypeRefContext() {}

func NewAcmeRoleInstantiatedTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeRoleInstantiatedTypeRefContext {
	var p = new(AcmeRoleInstantiatedTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeRoleInstantiatedTypeRef

	return p
}

func (s *AcmeRoleInstantiatedTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeRoleInstantiatedTypeRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmeRoleInstantiatedTypeRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeRoleInstantiatedTypeRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmeRoleInstantiatedTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeRoleInstantiatedTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeRoleInstantiatedTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeRoleInstantiatedTypeRef(s)
	}
}

func (s *AcmeRoleInstantiatedTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeRoleInstantiatedTypeRef(s)
	}
}

func (p *acmeParser) AcmeRoleInstantiatedTypeRef() (localctx IAcmeRoleInstantiatedTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmeRoleInstantiatedTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, acmeParserRULE_acmeRoleInstantiatedTypeRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(426)
		p.Identifier()
	}
	p.SetState(429)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(427)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(428)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmeViewTypeRefContext is an interface to support dynamic dispatch.
type IAcmeViewTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeViewTypeRefContext differentiates from other interfaces.
	IsAcmeViewTypeRefContext()
}

type AcmeViewTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeViewTypeRefContext() *AcmeViewTypeRefContext {
	var p = new(AcmeViewTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeViewTypeRef
	return p
}

func (*AcmeViewTypeRefContext) IsAcmeViewTypeRefContext() {}

func NewAcmeViewTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeViewTypeRefContext {
	var p = new(AcmeViewTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeViewTypeRef

	return p
}

func (s *AcmeViewTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeViewTypeRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmeViewTypeRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeViewTypeRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmeViewTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeViewTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeViewTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeViewTypeRef(s)
	}
}

func (s *AcmeViewTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeViewTypeRef(s)
	}
}

func (p *acmeParser) AcmeViewTypeRef() (localctx IAcmeViewTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmeViewTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, acmeParserRULE_acmeViewTypeRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(431)
		p.Identifier()
	}
	p.SetState(434)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(432)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(433)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmeViewInstantiatedTypeRefContext is an interface to support dynamic dispatch.
type IAcmeViewInstantiatedTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeViewInstantiatedTypeRefContext differentiates from other interfaces.
	IsAcmeViewInstantiatedTypeRefContext()
}

type AcmeViewInstantiatedTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeViewInstantiatedTypeRefContext() *AcmeViewInstantiatedTypeRefContext {
	var p = new(AcmeViewInstantiatedTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeViewInstantiatedTypeRef
	return p
}

func (*AcmeViewInstantiatedTypeRefContext) IsAcmeViewInstantiatedTypeRefContext() {}

func NewAcmeViewInstantiatedTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeViewInstantiatedTypeRefContext {
	var p = new(AcmeViewInstantiatedTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeViewInstantiatedTypeRef

	return p
}

func (s *AcmeViewInstantiatedTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeViewInstantiatedTypeRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmeViewInstantiatedTypeRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeViewInstantiatedTypeRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmeViewInstantiatedTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeViewInstantiatedTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeViewInstantiatedTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeViewInstantiatedTypeRef(s)
	}
}

func (s *AcmeViewInstantiatedTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeViewInstantiatedTypeRef(s)
	}
}

func (p *acmeParser) AcmeViewInstantiatedTypeRef() (localctx IAcmeViewInstantiatedTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmeViewInstantiatedTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, acmeParserRULE_acmeViewInstantiatedTypeRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(436)
		p.Identifier()
	}
	p.SetState(439)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(437)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(438)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmeFamilyRefContext is an interface to support dynamic dispatch.
type IAcmeFamilyRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeFamilyRefContext differentiates from other interfaces.
	IsAcmeFamilyRefContext()
}

type AcmeFamilyRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeFamilyRefContext() *AcmeFamilyRefContext {
	var p = new(AcmeFamilyRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeFamilyRef
	return p
}

func (*AcmeFamilyRefContext) IsAcmeFamilyRefContext() {}

func NewAcmeFamilyRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeFamilyRefContext {
	var p = new(AcmeFamilyRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeFamilyRef

	return p
}

func (s *AcmeFamilyRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeFamilyRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmeFamilyRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeFamilyRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmeFamilyRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeFamilyRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeFamilyRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeFamilyRef(s)
	}
}

func (s *AcmeFamilyRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeFamilyRef(s)
	}
}

func (p *acmeParser) AcmeFamilyRef() (localctx IAcmeFamilyRefContext) {
	this := p
	_ = this

	localctx = NewAcmeFamilyRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, acmeParserRULE_acmeFamilyRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(441)
		p.Identifier()
	}
	p.SetState(444)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(442)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(443)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmeFamilyInstantiationRefContext is an interface to support dynamic dispatch.
type IAcmeFamilyInstantiationRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeFamilyInstantiationRefContext differentiates from other interfaces.
	IsAcmeFamilyInstantiationRefContext()
}

type AcmeFamilyInstantiationRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeFamilyInstantiationRefContext() *AcmeFamilyInstantiationRefContext {
	var p = new(AcmeFamilyInstantiationRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeFamilyInstantiationRef
	return p
}

func (*AcmeFamilyInstantiationRefContext) IsAcmeFamilyInstantiationRefContext() {}

func NewAcmeFamilyInstantiationRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeFamilyInstantiationRefContext {
	var p = new(AcmeFamilyInstantiationRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeFamilyInstantiationRef

	return p
}

func (s *AcmeFamilyInstantiationRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeFamilyInstantiationRefContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeFamilyInstantiationRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeFamilyInstantiationRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeFamilyInstantiationRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeFamilyInstantiationRef(s)
	}
}

func (s *AcmeFamilyInstantiationRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeFamilyInstantiationRef(s)
	}
}

func (p *acmeParser) AcmeFamilyInstantiationRef() (localctx IAcmeFamilyInstantiationRefContext) {
	this := p
	_ = this

	localctx = NewAcmeFamilyInstantiationRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, acmeParserRULE_acmeFamilyInstantiationRef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(446)
		p.Identifier()
	}

	return localctx
}

// IAcmeElementTypeRefContext is an interface to support dynamic dispatch.
type IAcmeElementTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeElementTypeRefContext differentiates from other interfaces.
	IsAcmeElementTypeRefContext()
}

type AcmeElementTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeElementTypeRefContext() *AcmeElementTypeRefContext {
	var p = new(AcmeElementTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeElementTypeRef
	return p
}

func (*AcmeElementTypeRefContext) IsAcmeElementTypeRefContext() {}

func NewAcmeElementTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeElementTypeRefContext {
	var p = new(AcmeElementTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeElementTypeRef

	return p
}

func (s *AcmeElementTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeElementTypeRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmeElementTypeRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeElementTypeRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmeElementTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeElementTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeElementTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeElementTypeRef(s)
	}
}

func (s *AcmeElementTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeElementTypeRef(s)
	}
}

func (p *acmeParser) AcmeElementTypeRef() (localctx IAcmeElementTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmeElementTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, acmeParserRULE_acmeElementTypeRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(448)
		p.Identifier()
	}
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(449)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(450)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmePropertyTypeDeclarationRefContext is an interface to support dynamic dispatch.
type IAcmePropertyTypeDeclarationRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyTypeDeclarationRefContext differentiates from other interfaces.
	IsAcmePropertyTypeDeclarationRefContext()
}

type AcmePropertyTypeDeclarationRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyTypeDeclarationRefContext() *AcmePropertyTypeDeclarationRefContext {
	var p = new(AcmePropertyTypeDeclarationRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyTypeDeclarationRef
	return p
}

func (*AcmePropertyTypeDeclarationRefContext) IsAcmePropertyTypeDeclarationRefContext() {}

func NewAcmePropertyTypeDeclarationRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyTypeDeclarationRefContext {
	var p = new(AcmePropertyTypeDeclarationRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyTypeDeclarationRef

	return p
}

func (s *AcmePropertyTypeDeclarationRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyTypeDeclarationRefContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmePropertyTypeDeclarationRefContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmePropertyTypeDeclarationRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, 0)
}

func (s *AcmePropertyTypeDeclarationRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyTypeDeclarationRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyTypeDeclarationRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyTypeDeclarationRef(s)
	}
}

func (s *AcmePropertyTypeDeclarationRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyTypeDeclarationRef(s)
	}
}

func (p *acmeParser) AcmePropertyTypeDeclarationRef() (localctx IAcmePropertyTypeDeclarationRefContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyTypeDeclarationRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, acmeParserRULE_acmePropertyTypeDeclarationRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		p.Identifier()
	}
	p.SetState(456)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDOT {
		{
			p.SetState(454)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(455)
			p.Identifier()
		}

	}

	return localctx
}

// IAcmeInstanceRefContext is an interface to support dynamic dispatch.
type IAcmeInstanceRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeInstanceRefContext differentiates from other interfaces.
	IsAcmeInstanceRefContext()
}

type AcmeInstanceRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeInstanceRefContext() *AcmeInstanceRefContext {
	var p = new(AcmeInstanceRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeInstanceRef
	return p
}

func (*AcmeInstanceRefContext) IsAcmeInstanceRefContext() {}

func NewAcmeInstanceRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeInstanceRefContext {
	var p = new(AcmeInstanceRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeInstanceRef

	return p
}

func (s *AcmeInstanceRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeInstanceRefContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(acmeParserIDENTIFIER)
}

func (s *AcmeInstanceRefContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserIDENTIFIER, i)
}

func (s *AcmeInstanceRefContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(acmeParserDOT)
}

func (s *AcmeInstanceRefContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, i)
}

func (s *AcmeInstanceRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeInstanceRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeInstanceRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeInstanceRef(s)
	}
}

func (s *AcmeInstanceRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeInstanceRef(s)
	}
}

func (p *acmeParser) AcmeInstanceRef() (localctx IAcmeInstanceRefContext) {
	this := p
	_ = this

	localctx = NewAcmeInstanceRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, acmeParserRULE_acmeInstanceRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		p.Match(acmeParserIDENTIFIER)
	}
	p.SetState(463)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == acmeParserDOT {
		{
			p.SetState(459)
			p.Match(acmeParserDOT)
		}
		{
			p.SetState(460)
			p.Match(acmeParserIDENTIFIER)
		}

		p.SetState(465)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAcmeGenericElementTypeDeclarationContext is an interface to support dynamic dispatch.
type IAcmeGenericElementTypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeGenericElementTypeDeclarationContext differentiates from other interfaces.
	IsAcmeGenericElementTypeDeclarationContext()
}

type AcmeGenericElementTypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeGenericElementTypeDeclarationContext() *AcmeGenericElementTypeDeclarationContext {
	var p = new(AcmeGenericElementTypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeGenericElementTypeDeclaration
	return p
}

func (*AcmeGenericElementTypeDeclarationContext) IsAcmeGenericElementTypeDeclarationContext() {}

func NewAcmeGenericElementTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeGenericElementTypeDeclarationContext {
	var p = new(AcmeGenericElementTypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeGenericElementTypeDeclaration

	return p
}

func (s *AcmeGenericElementTypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeGenericElementTypeDeclarationContext) ELEMENT() antlr.TerminalNode {
	return s.GetToken(acmeParserELEMENT, 0)
}

func (s *AcmeGenericElementTypeDeclarationContext) TYPE() antlr.TerminalNode {
	return s.GetToken(acmeParserTYPE, 0)
}

func (s *AcmeGenericElementTypeDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeGenericElementTypeDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeGenericElementTypeDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeGenericElementTypeDeclarationContext) AcmeGenericElementBody() IAcmeGenericElementBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeGenericElementBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeGenericElementBodyContext)
}

func (s *AcmeGenericElementTypeDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDS, 0)
}

func (s *AcmeGenericElementTypeDeclarationContext) AllAcmeElementTypeRef() []IAcmeElementTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeElementTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmeElementTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeElementTypeRefContext)
		}
	}

	return tst
}

func (s *AcmeGenericElementTypeDeclarationContext) AcmeElementTypeRef(i int) IAcmeElementTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeElementTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeElementTypeRefContext)
}

func (s *AcmeGenericElementTypeDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmeGenericElementTypeDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmeGenericElementTypeDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmeGenericElementTypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeGenericElementTypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeGenericElementTypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeGenericElementTypeDeclaration(s)
	}
}

func (s *AcmeGenericElementTypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeGenericElementTypeDeclaration(s)
	}
}

func (p *acmeParser) AcmeGenericElementTypeDeclaration() (localctx IAcmeGenericElementTypeDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeGenericElementTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, acmeParserRULE_acmeGenericElementTypeDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(466)
		p.Match(acmeParserELEMENT)
	}
	{
		p.SetState(467)
		p.Match(acmeParserTYPE)
	}
	{
		p.SetState(468)
		p.Identifier()
	}
	p.SetState(494)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(469)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN, acmeParserEXTENDS:
		p.SetState(492)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserASSIGN:
			{
				p.SetState(470)
				p.Match(acmeParserASSIGN)
			}
			{
				p.SetState(471)
				p.AcmeGenericElementBody()
			}
			p.SetState(473)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(472)
					p.Match(acmeParserSEMICOLON)
				}

			}

		case acmeParserEXTENDS:
			{
				p.SetState(475)
				p.Match(acmeParserEXTENDS)
			}
			{
				p.SetState(476)
				p.AcmeElementTypeRef()
			}
			p.SetState(481)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserCOMMA {
				{
					p.SetState(477)
					p.Match(acmeParserCOMMA)
				}
				{
					p.SetState(478)
					p.AcmeElementTypeRef()
				}

				p.SetState(483)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(490)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSEMICOLON:
				{
					p.SetState(484)
					p.Match(acmeParserSEMICOLON)
				}

			case acmeParserWITH:
				{
					p.SetState(485)
					p.Match(acmeParserWITH)
				}
				{
					p.SetState(486)
					p.AcmeGenericElementBody()
				}
				p.SetState(488)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(487)
						p.Match(acmeParserSEMICOLON)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmeGenericElementBodyContext is an interface to support dynamic dispatch.
type IAcmeGenericElementBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeGenericElementBodyContext differentiates from other interfaces.
	IsAcmeGenericElementBodyContext()
}

type AcmeGenericElementBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeGenericElementBodyContext() *AcmeGenericElementBodyContext {
	var p = new(AcmeGenericElementBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeGenericElementBody
	return p
}

func (*AcmeGenericElementBodyContext) IsAcmeGenericElementBodyContext() {}

func NewAcmeGenericElementBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeGenericElementBodyContext {
	var p = new(AcmeGenericElementBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeGenericElementBody

	return p
}

func (s *AcmeGenericElementBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeGenericElementBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmeGenericElementBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmeGenericElementBodyContext) AllAcmePropertyDeclaration() []IAcmePropertyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmePropertyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePropertyDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeGenericElementBodyContext) AcmePropertyDeclaration(i int) IAcmePropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyDeclarationContext)
}

func (s *AcmeGenericElementBodyContext) AllDesignRule() []IDesignRuleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem())
	var tst = make([]IDesignRuleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDesignRuleContext)
		}
	}

	return tst
}

func (s *AcmeGenericElementBodyContext) DesignRule(i int) IDesignRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleContext)
}

func (s *AcmeGenericElementBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeGenericElementBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeGenericElementBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeGenericElementBody(s)
	}
}

func (s *AcmeGenericElementBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeGenericElementBody(s)
	}
}

func (p *acmeParser) AcmeGenericElementBody() (localctx IAcmeGenericElementBodyContext) {
	this := p
	_ = this

	localctx = NewAcmeGenericElementBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, acmeParserRULE_acmeGenericElementBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(496)
		p.Match(acmeParserLBRACE)
	}
	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-23)&-(0x1f+1)) == 0 && ((1<<uint((_la-23)))&((1<<(acmeParserDESIGN-23))|(1<<(acmeParserHEURISTIC-23))|(1<<(acmeParserINVARIANT-23)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(acmeParserPROPERTY-70))|(1<<(acmeParserPROPBEGIN-70))|(1<<(acmeParserRULE-70))|(1<<(acmeParserSEMICOLON-70)))) != 0) {
		p.SetState(499)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserPROPERTY:
			{
				p.SetState(497)
				p.AcmePropertyDeclaration()
			}

		case acmeParserDESIGN, acmeParserHEURISTIC, acmeParserINVARIANT, acmeParserPROPBEGIN, acmeParserRULE, acmeParserSEMICOLON:
			{
				p.SetState(498)
				p.DesignRule()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(503)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(504)
		p.Match(acmeParserRBRACE)
	}

	return localctx
}

// IAcmeGroupTypeDeclarationContext is an interface to support dynamic dispatch.
type IAcmeGroupTypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeGroupTypeDeclarationContext differentiates from other interfaces.
	IsAcmeGroupTypeDeclarationContext()
}

type AcmeGroupTypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeGroupTypeDeclarationContext() *AcmeGroupTypeDeclarationContext {
	var p = new(AcmeGroupTypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeGroupTypeDeclaration
	return p
}

func (*AcmeGroupTypeDeclarationContext) IsAcmeGroupTypeDeclarationContext() {}

func NewAcmeGroupTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeGroupTypeDeclarationContext {
	var p = new(AcmeGroupTypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeGroupTypeDeclaration

	return p
}

func (s *AcmeGroupTypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeGroupTypeDeclarationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(acmeParserGROUP, 0)
}

func (s *AcmeGroupTypeDeclarationContext) TYPE() antlr.TerminalNode {
	return s.GetToken(acmeParserTYPE, 0)
}

func (s *AcmeGroupTypeDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeGroupTypeDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeGroupTypeDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeGroupTypeDeclarationContext) AcmeGroupBody() IAcmeGroupBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeGroupBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeGroupBodyContext)
}

func (s *AcmeGroupTypeDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDS, 0)
}

func (s *AcmeGroupTypeDeclarationContext) AllAcmeGroupTypeRef() []IAcmeGroupTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeGroupTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmeGroupTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeGroupTypeRefContext)
		}
	}

	return tst
}

func (s *AcmeGroupTypeDeclarationContext) AcmeGroupTypeRef(i int) IAcmeGroupTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeGroupTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeGroupTypeRefContext)
}

func (s *AcmeGroupTypeDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmeGroupTypeDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmeGroupTypeDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmeGroupTypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeGroupTypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeGroupTypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeGroupTypeDeclaration(s)
	}
}

func (s *AcmeGroupTypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeGroupTypeDeclaration(s)
	}
}

func (p *acmeParser) AcmeGroupTypeDeclaration() (localctx IAcmeGroupTypeDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeGroupTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, acmeParserRULE_acmeGroupTypeDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(506)
		p.Match(acmeParserGROUP)
	}
	{
		p.SetState(507)
		p.Match(acmeParserTYPE)
	}
	{
		p.SetState(508)
		p.Identifier()
	}
	p.SetState(534)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(509)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN, acmeParserEXTENDS:
		p.SetState(532)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserASSIGN:
			{
				p.SetState(510)
				p.Match(acmeParserASSIGN)
			}
			{
				p.SetState(511)
				p.AcmeGroupBody()
			}
			p.SetState(513)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(512)
					p.Match(acmeParserSEMICOLON)
				}

			}

		case acmeParserEXTENDS:
			{
				p.SetState(515)
				p.Match(acmeParserEXTENDS)
			}
			{
				p.SetState(516)
				p.AcmeGroupTypeRef()
			}
			p.SetState(521)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserCOMMA {
				{
					p.SetState(517)
					p.Match(acmeParserCOMMA)
				}
				{
					p.SetState(518)
					p.AcmeGroupTypeRef()
				}

				p.SetState(523)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(530)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSEMICOLON:
				{
					p.SetState(524)
					p.Match(acmeParserSEMICOLON)
				}

			case acmeParserWITH:
				{
					p.SetState(525)
					p.Match(acmeParserWITH)
				}
				{
					p.SetState(526)
					p.AcmeGroupBody()
				}
				p.SetState(528)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(527)
						p.Match(acmeParserSEMICOLON)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmeGroupDeclarationContext is an interface to support dynamic dispatch.
type IAcmeGroupDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeGroupDeclarationContext differentiates from other interfaces.
	IsAcmeGroupDeclarationContext()
}

type AcmeGroupDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeGroupDeclarationContext() *AcmeGroupDeclarationContext {
	var p = new(AcmeGroupDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeGroupDeclaration
	return p
}

func (*AcmeGroupDeclarationContext) IsAcmeGroupDeclarationContext() {}

func NewAcmeGroupDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeGroupDeclarationContext {
	var p = new(AcmeGroupDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeGroupDeclaration

	return p
}

func (s *AcmeGroupDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeGroupDeclarationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(acmeParserGROUP, 0)
}

func (s *AcmeGroupDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeGroupDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeGroupDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *AcmeGroupDeclarationContext) AllAcmeGroupTypeRef() []IAcmeGroupTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeGroupTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmeGroupTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeGroupTypeRefContext)
		}
	}

	return tst
}

func (s *AcmeGroupDeclarationContext) AcmeGroupTypeRef(i int) IAcmeGroupTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeGroupTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeGroupTypeRefContext)
}

func (s *AcmeGroupDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeGroupDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmeGroupDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmeGroupDeclarationContext) AcmeGroupBody() IAcmeGroupBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeGroupBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeGroupBodyContext)
}

func (s *AcmeGroupDeclarationContext) NEW() antlr.TerminalNode {
	return s.GetToken(acmeParserNEW, 0)
}

func (s *AcmeGroupDeclarationContext) AllAcmeGroupInstantiatedTypeRef() []IAcmeGroupInstantiatedTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeGroupInstantiatedTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmeGroupInstantiatedTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeGroupInstantiatedTypeRefContext)
		}
	}

	return tst
}

func (s *AcmeGroupDeclarationContext) AcmeGroupInstantiatedTypeRef(i int) IAcmeGroupInstantiatedTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeGroupInstantiatedTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeGroupInstantiatedTypeRefContext)
}

func (s *AcmeGroupDeclarationContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDED, 0)
}

func (s *AcmeGroupDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmeGroupDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeGroupDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeGroupDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeGroupDeclaration(s)
	}
}

func (s *AcmeGroupDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeGroupDeclaration(s)
	}
}

func (p *acmeParser) AcmeGroupDeclaration() (localctx IAcmeGroupDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeGroupDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, acmeParserRULE_acmeGroupDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(536)
		p.Match(acmeParserGROUP)
	}
	{
		p.SetState(537)
		p.Identifier()
	}
	p.SetState(547)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserCOLON {
		{
			p.SetState(538)
			p.Match(acmeParserCOLON)
		}
		{
			p.SetState(539)
			p.AcmeGroupTypeRef()
		}
		p.SetState(544)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserCOMMA {
			{
				p.SetState(540)
				p.Match(acmeParserCOMMA)
			}
			{
				p.SetState(541)
				p.AcmeGroupTypeRef()
			}

			p.SetState(546)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(575)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(549)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN:
		{
			p.SetState(550)
			p.Match(acmeParserASSIGN)
		}
		p.SetState(573)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserLBRACE:
			{
				p.SetState(551)
				p.AcmeGroupBody()
			}
			p.SetState(553)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(552)
					p.Match(acmeParserSEMICOLON)
				}

			}

		case acmeParserNEW:
			{
				p.SetState(555)
				p.Match(acmeParserNEW)
			}
			{
				p.SetState(556)
				p.AcmeGroupInstantiatedTypeRef()
			}
			p.SetState(561)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserCOMMA {
				{
					p.SetState(557)
					p.Match(acmeParserCOMMA)
				}
				{
					p.SetState(558)
					p.AcmeGroupInstantiatedTypeRef()
				}

				p.SetState(563)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(571)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSEMICOLON:
				{
					p.SetState(564)
					p.Match(acmeParserSEMICOLON)
				}

			case acmeParserEXTENDED:
				{
					p.SetState(565)
					p.Match(acmeParserEXTENDED)
				}
				{
					p.SetState(566)
					p.Match(acmeParserWITH)
				}
				{
					p.SetState(567)
					p.AcmeGroupBody()
				}
				p.SetState(569)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(568)
						p.Match(acmeParserSEMICOLON)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmeGroupBodyContext is an interface to support dynamic dispatch.
type IAcmeGroupBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeGroupBodyContext differentiates from other interfaces.
	IsAcmeGroupBodyContext()
}

type AcmeGroupBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeGroupBodyContext() *AcmeGroupBodyContext {
	var p = new(AcmeGroupBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeGroupBody
	return p
}

func (*AcmeGroupBodyContext) IsAcmeGroupBodyContext() {}

func NewAcmeGroupBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeGroupBodyContext {
	var p = new(AcmeGroupBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeGroupBody

	return p
}

func (s *AcmeGroupBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeGroupBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmeGroupBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmeGroupBodyContext) AllAcmeMembersBlock() []IAcmeMembersBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeMembersBlockContext)(nil)).Elem())
	var tst = make([]IAcmeMembersBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeMembersBlockContext)
		}
	}

	return tst
}

func (s *AcmeGroupBodyContext) AcmeMembersBlock(i int) IAcmeMembersBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeMembersBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeMembersBlockContext)
}

func (s *AcmeGroupBodyContext) AllAcmePropertyDeclaration() []IAcmePropertyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmePropertyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePropertyDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeGroupBodyContext) AcmePropertyDeclaration(i int) IAcmePropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyDeclarationContext)
}

func (s *AcmeGroupBodyContext) AllDesignRule() []IDesignRuleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem())
	var tst = make([]IDesignRuleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDesignRuleContext)
		}
	}

	return tst
}

func (s *AcmeGroupBodyContext) DesignRule(i int) IDesignRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleContext)
}

func (s *AcmeGroupBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeGroupBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeGroupBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeGroupBody(s)
	}
}

func (s *AcmeGroupBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeGroupBody(s)
	}
}

func (p *acmeParser) AcmeGroupBody() (localctx IAcmeGroupBodyContext) {
	this := p
	_ = this

	localctx = NewAcmeGroupBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, acmeParserRULE_acmeGroupBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(577)
		p.Match(acmeParserLBRACE)
	}
	p.SetState(583)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-23)&-(0x1f+1)) == 0 && ((1<<uint((_la-23)))&((1<<(acmeParserDESIGN-23))|(1<<(acmeParserHEURISTIC-23))|(1<<(acmeParserINVARIANT-23)))) != 0) || (((_la-60)&-(0x1f+1)) == 0 && ((1<<uint((_la-60)))&((1<<(acmeParserMEMBERS-60))|(1<<(acmeParserPROPERTY-60))|(1<<(acmeParserPROPBEGIN-60))|(1<<(acmeParserRULE-60))|(1<<(acmeParserSEMICOLON-60)))) != 0) {
		p.SetState(581)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserMEMBERS:
			{
				p.SetState(578)
				p.AcmeMembersBlock()
			}

		case acmeParserPROPERTY:
			{
				p.SetState(579)
				p.AcmePropertyDeclaration()
			}

		case acmeParserDESIGN, acmeParserHEURISTIC, acmeParserINVARIANT, acmeParserPROPBEGIN, acmeParserRULE, acmeParserSEMICOLON:
			{
				p.SetState(580)
				p.DesignRule()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(585)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(586)
		p.Match(acmeParserRBRACE)
	}

	return localctx
}

// IAcmeMembersBlockContext is an interface to support dynamic dispatch.
type IAcmeMembersBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeMembersBlockContext differentiates from other interfaces.
	IsAcmeMembersBlockContext()
}

type AcmeMembersBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeMembersBlockContext() *AcmeMembersBlockContext {
	var p = new(AcmeMembersBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeMembersBlock
	return p
}

func (*AcmeMembersBlockContext) IsAcmeMembersBlockContext() {}

func NewAcmeMembersBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeMembersBlockContext {
	var p = new(AcmeMembersBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeMembersBlock

	return p
}

func (s *AcmeMembersBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeMembersBlockContext) MEMBERS() antlr.TerminalNode {
	return s.GetToken(acmeParserMEMBERS, 0)
}

func (s *AcmeMembersBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmeMembersBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmeMembersBlockContext) AllAcmeInstanceRef() []IAcmeInstanceRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeInstanceRefContext)(nil)).Elem())
	var tst = make([]IAcmeInstanceRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeInstanceRefContext)
		}
	}

	return tst
}

func (s *AcmeMembersBlockContext) AcmeInstanceRef(i int) IAcmeInstanceRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeInstanceRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeInstanceRefContext)
}

func (s *AcmeMembersBlockContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeMembersBlockContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmeMembersBlockContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmeMembersBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeMembersBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeMembersBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeMembersBlock(s)
	}
}

func (s *AcmeMembersBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeMembersBlock(s)
	}
}

func (p *acmeParser) AcmeMembersBlock() (localctx IAcmeMembersBlockContext) {
	this := p
	_ = this

	localctx = NewAcmeMembersBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, acmeParserRULE_acmeMembersBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(588)
		p.Match(acmeParserMEMBERS)
	}
	{
		p.SetState(589)
		p.Match(acmeParserLBRACE)
	}
	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserIDENTIFIER {
		{
			p.SetState(590)
			p.AcmeInstanceRef()
		}
		p.SetState(595)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserCOMMA {
			{
				p.SetState(591)
				p.Match(acmeParserCOMMA)
			}
			{
				p.SetState(592)
				p.AcmeInstanceRef()
			}

			p.SetState(597)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(600)
		p.Match(acmeParserRBRACE)
	}
	p.SetState(602)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(601)
			p.Match(acmeParserSEMICOLON)
		}

	}

	return localctx
}

// IAcmePortTypeDeclarationContext is an interface to support dynamic dispatch.
type IAcmePortTypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePortTypeDeclarationContext differentiates from other interfaces.
	IsAcmePortTypeDeclarationContext()
}

type AcmePortTypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePortTypeDeclarationContext() *AcmePortTypeDeclarationContext {
	var p = new(AcmePortTypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePortTypeDeclaration
	return p
}

func (*AcmePortTypeDeclarationContext) IsAcmePortTypeDeclarationContext() {}

func NewAcmePortTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePortTypeDeclarationContext {
	var p = new(AcmePortTypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePortTypeDeclaration

	return p
}

func (s *AcmePortTypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePortTypeDeclarationContext) PORT() antlr.TerminalNode {
	return s.GetToken(acmeParserPORT, 0)
}

func (s *AcmePortTypeDeclarationContext) TYPE() antlr.TerminalNode {
	return s.GetToken(acmeParserTYPE, 0)
}

func (s *AcmePortTypeDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmePortTypeDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmePortTypeDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmePortTypeDeclarationContext) AcmePortBody() IAcmePortBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePortBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePortBodyContext)
}

func (s *AcmePortTypeDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDS, 0)
}

func (s *AcmePortTypeDeclarationContext) AllAcmePortTypeRef() []IAcmePortTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePortTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmePortTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePortTypeRefContext)
		}
	}

	return tst
}

func (s *AcmePortTypeDeclarationContext) AcmePortTypeRef(i int) IAcmePortTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePortTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePortTypeRefContext)
}

func (s *AcmePortTypeDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmePortTypeDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmePortTypeDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmePortTypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePortTypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePortTypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePortTypeDeclaration(s)
	}
}

func (s *AcmePortTypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePortTypeDeclaration(s)
	}
}

func (p *acmeParser) AcmePortTypeDeclaration() (localctx IAcmePortTypeDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmePortTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, acmeParserRULE_acmePortTypeDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)
		p.Match(acmeParserPORT)
	}
	{
		p.SetState(605)
		p.Match(acmeParserTYPE)
	}
	{
		p.SetState(606)
		p.Identifier()
	}
	p.SetState(632)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(607)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN, acmeParserEXTENDS:
		p.SetState(630)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserASSIGN:
			{
				p.SetState(608)
				p.Match(acmeParserASSIGN)
			}
			{
				p.SetState(609)
				p.AcmePortBody()
			}
			p.SetState(611)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(610)
					p.Match(acmeParserSEMICOLON)
				}

			}

		case acmeParserEXTENDS:
			{
				p.SetState(613)
				p.Match(acmeParserEXTENDS)
			}
			{
				p.SetState(614)
				p.AcmePortTypeRef()
			}
			p.SetState(619)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserCOMMA {
				{
					p.SetState(615)
					p.Match(acmeParserCOMMA)
				}
				{
					p.SetState(616)
					p.AcmePortTypeRef()
				}

				p.SetState(621)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(628)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSEMICOLON:
				{
					p.SetState(622)
					p.Match(acmeParserSEMICOLON)
				}

			case acmeParserWITH:
				{
					p.SetState(623)
					p.Match(acmeParserWITH)
				}
				{
					p.SetState(624)
					p.AcmePortBody()
				}
				p.SetState(626)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(625)
						p.Match(acmeParserSEMICOLON)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmePortDeclarationContext is an interface to support dynamic dispatch.
type IAcmePortDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePortDeclarationContext differentiates from other interfaces.
	IsAcmePortDeclarationContext()
}

type AcmePortDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePortDeclarationContext() *AcmePortDeclarationContext {
	var p = new(AcmePortDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePortDeclaration
	return p
}

func (*AcmePortDeclarationContext) IsAcmePortDeclarationContext() {}

func NewAcmePortDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePortDeclarationContext {
	var p = new(AcmePortDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePortDeclaration

	return p
}

func (s *AcmePortDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePortDeclarationContext) PORT() antlr.TerminalNode {
	return s.GetToken(acmeParserPORT, 0)
}

func (s *AcmePortDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmePortDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *AcmePortDeclarationContext) AllAcmePortTypeRef() []IAcmePortTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePortTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmePortTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePortTypeRefContext)
		}
	}

	return tst
}

func (s *AcmePortDeclarationContext) AcmePortTypeRef(i int) IAcmePortTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePortTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePortTypeRefContext)
}

func (s *AcmePortDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmePortDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmePortDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmePortDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmePortDeclarationContext) AcmePortBody() IAcmePortBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePortBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePortBodyContext)
}

func (s *AcmePortDeclarationContext) NEW() antlr.TerminalNode {
	return s.GetToken(acmeParserNEW, 0)
}

func (s *AcmePortDeclarationContext) AllAcmePortInstantiatedTypeRef() []IAcmePortInstantiatedTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePortInstantiatedTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmePortInstantiatedTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePortInstantiatedTypeRefContext)
		}
	}

	return tst
}

func (s *AcmePortDeclarationContext) AcmePortInstantiatedTypeRef(i int) IAcmePortInstantiatedTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePortInstantiatedTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePortInstantiatedTypeRefContext)
}

func (s *AcmePortDeclarationContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDED, 0)
}

func (s *AcmePortDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmePortDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePortDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePortDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePortDeclaration(s)
	}
}

func (s *AcmePortDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePortDeclaration(s)
	}
}

func (p *acmeParser) AcmePortDeclaration() (localctx IAcmePortDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmePortDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, acmeParserRULE_acmePortDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(634)
		p.Match(acmeParserPORT)
	}
	{
		p.SetState(635)
		p.Identifier()
	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserCOLON {
		{
			p.SetState(636)
			p.Match(acmeParserCOLON)
		}
		{
			p.SetState(637)
			p.AcmePortTypeRef()
		}
		p.SetState(642)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserCOMMA {
			{
				p.SetState(638)
				p.Match(acmeParserCOMMA)
			}
			{
				p.SetState(639)
				p.AcmePortTypeRef()
			}

			p.SetState(644)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(675)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserABSTRACT, acmeParserANALYSIS, acmeParserATTACHMENT, acmeParserCOMPONENT, acmeParserCONNECTOR, acmeParserDESIGN, acmeParserELEMENT, acmeParserEXTERNAL, acmeParserFINAL, acmeParserGROUP, acmeParserHEURISTIC, acmeParserINVARIANT, acmeParserRBRACE, acmeParserPUBLIC, acmeParserPRIVATE, acmeParserPORT, acmeParserPROPERTY, acmeParserPROPBEGIN, acmeParserREPRESENTATION, acmeParserROLE, acmeParserRULE, acmeParserSEMICOLON:
		p.SetState(648)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(647)
				p.Match(acmeParserSEMICOLON)
			}

		}

	case acmeParserASSIGN:
		{
			p.SetState(650)
			p.Match(acmeParserASSIGN)
		}
		p.SetState(673)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserLBRACE:
			{
				p.SetState(651)
				p.AcmePortBody()
			}
			p.SetState(653)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(652)
					p.Match(acmeParserSEMICOLON)
				}

			}

		case acmeParserNEW:
			{
				p.SetState(655)
				p.Match(acmeParserNEW)
			}
			{
				p.SetState(656)
				p.AcmePortInstantiatedTypeRef()
			}
			p.SetState(661)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserCOMMA {
				{
					p.SetState(657)
					p.Match(acmeParserCOMMA)
				}
				{
					p.SetState(658)
					p.AcmePortInstantiatedTypeRef()
				}

				p.SetState(663)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(671)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSEMICOLON:
				{
					p.SetState(664)
					p.Match(acmeParserSEMICOLON)
				}

			case acmeParserEXTENDED:
				{
					p.SetState(665)
					p.Match(acmeParserEXTENDED)
				}
				{
					p.SetState(666)
					p.Match(acmeParserWITH)
				}
				{
					p.SetState(667)
					p.AcmePortBody()
				}
				p.SetState(669)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(668)
						p.Match(acmeParserSEMICOLON)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmePortBodyContext is an interface to support dynamic dispatch.
type IAcmePortBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePortBodyContext differentiates from other interfaces.
	IsAcmePortBodyContext()
}

type AcmePortBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePortBodyContext() *AcmePortBodyContext {
	var p = new(AcmePortBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePortBody
	return p
}

func (*AcmePortBodyContext) IsAcmePortBodyContext() {}

func NewAcmePortBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePortBodyContext {
	var p = new(AcmePortBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePortBody

	return p
}

func (s *AcmePortBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePortBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmePortBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmePortBodyContext) AllAcmePropertyDeclaration() []IAcmePropertyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmePropertyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePropertyDeclarationContext)
		}
	}

	return tst
}

func (s *AcmePortBodyContext) AcmePropertyDeclaration(i int) IAcmePropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyDeclarationContext)
}

func (s *AcmePortBodyContext) AllDesignRule() []IDesignRuleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem())
	var tst = make([]IDesignRuleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDesignRuleContext)
		}
	}

	return tst
}

func (s *AcmePortBodyContext) DesignRule(i int) IDesignRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleContext)
}

func (s *AcmePortBodyContext) AllAcmeRepresentationDeclaration() []IAcmeRepresentationDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeRepresentationDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeRepresentationDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeRepresentationDeclarationContext)
		}
	}

	return tst
}

func (s *AcmePortBodyContext) AcmeRepresentationDeclaration(i int) IAcmeRepresentationDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeRepresentationDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeRepresentationDeclarationContext)
}

func (s *AcmePortBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePortBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePortBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePortBody(s)
	}
}

func (s *AcmePortBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePortBody(s)
	}
}

func (p *acmeParser) AcmePortBody() (localctx IAcmePortBodyContext) {
	this := p
	_ = this

	localctx = NewAcmePortBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, acmeParserRULE_acmePortBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(677)
		p.Match(acmeParserLBRACE)
	}
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-23)&-(0x1f+1)) == 0 && ((1<<uint((_la-23)))&((1<<(acmeParserDESIGN-23))|(1<<(acmeParserHEURISTIC-23))|(1<<(acmeParserINVARIANT-23)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(acmeParserPROPERTY-70))|(1<<(acmeParserPROPBEGIN-70))|(1<<(acmeParserREPRESENTATION-70))|(1<<(acmeParserRULE-70))|(1<<(acmeParserSEMICOLON-70)))) != 0) {
		p.SetState(681)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserPROPERTY:
			{
				p.SetState(678)
				p.AcmePropertyDeclaration()
			}

		case acmeParserDESIGN, acmeParserHEURISTIC, acmeParserINVARIANT, acmeParserPROPBEGIN, acmeParserRULE, acmeParserSEMICOLON:
			{
				p.SetState(679)
				p.DesignRule()
			}

		case acmeParserREPRESENTATION:
			{
				p.SetState(680)
				p.AcmeRepresentationDeclaration()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(685)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(686)
		p.Match(acmeParserRBRACE)
	}

	return localctx
}

// IAcmeRoleTypeDeclarationContext is an interface to support dynamic dispatch.
type IAcmeRoleTypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeRoleTypeDeclarationContext differentiates from other interfaces.
	IsAcmeRoleTypeDeclarationContext()
}

type AcmeRoleTypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeRoleTypeDeclarationContext() *AcmeRoleTypeDeclarationContext {
	var p = new(AcmeRoleTypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeRoleTypeDeclaration
	return p
}

func (*AcmeRoleTypeDeclarationContext) IsAcmeRoleTypeDeclarationContext() {}

func NewAcmeRoleTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeRoleTypeDeclarationContext {
	var p = new(AcmeRoleTypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeRoleTypeDeclaration

	return p
}

func (s *AcmeRoleTypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeRoleTypeDeclarationContext) ROLE() antlr.TerminalNode {
	return s.GetToken(acmeParserROLE, 0)
}

func (s *AcmeRoleTypeDeclarationContext) TYPE() antlr.TerminalNode {
	return s.GetToken(acmeParserTYPE, 0)
}

func (s *AcmeRoleTypeDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeRoleTypeDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeRoleTypeDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeRoleTypeDeclarationContext) AcmeRoleBody() IAcmeRoleBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeRoleBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeRoleBodyContext)
}

func (s *AcmeRoleTypeDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDS, 0)
}

func (s *AcmeRoleTypeDeclarationContext) AllAcmeRoleTypeRef() []IAcmeRoleTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeRoleTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmeRoleTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeRoleTypeRefContext)
		}
	}

	return tst
}

func (s *AcmeRoleTypeDeclarationContext) AcmeRoleTypeRef(i int) IAcmeRoleTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeRoleTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeRoleTypeRefContext)
}

func (s *AcmeRoleTypeDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmeRoleTypeDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmeRoleTypeDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmeRoleTypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeRoleTypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeRoleTypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeRoleTypeDeclaration(s)
	}
}

func (s *AcmeRoleTypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeRoleTypeDeclaration(s)
	}
}

func (p *acmeParser) AcmeRoleTypeDeclaration() (localctx IAcmeRoleTypeDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeRoleTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, acmeParserRULE_acmeRoleTypeDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(688)
		p.Match(acmeParserROLE)
	}
	{
		p.SetState(689)
		p.Match(acmeParserTYPE)
	}
	{
		p.SetState(690)
		p.Identifier()
	}
	p.SetState(716)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(691)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN, acmeParserEXTENDS:
		p.SetState(714)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserASSIGN:
			{
				p.SetState(692)
				p.Match(acmeParserASSIGN)
			}
			{
				p.SetState(693)
				p.AcmeRoleBody()
			}
			p.SetState(695)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(694)
					p.Match(acmeParserSEMICOLON)
				}

			}

		case acmeParserEXTENDS:
			{
				p.SetState(697)
				p.Match(acmeParserEXTENDS)
			}
			{
				p.SetState(698)
				p.AcmeRoleTypeRef()
			}
			p.SetState(703)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserCOMMA {
				{
					p.SetState(699)
					p.Match(acmeParserCOMMA)
				}
				{
					p.SetState(700)
					p.AcmeRoleTypeRef()
				}

				p.SetState(705)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(712)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSEMICOLON:
				{
					p.SetState(706)
					p.Match(acmeParserSEMICOLON)
				}

			case acmeParserWITH:
				{
					p.SetState(707)
					p.Match(acmeParserWITH)
				}
				{
					p.SetState(708)
					p.AcmeRoleBody()
				}
				p.SetState(710)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(709)
						p.Match(acmeParserSEMICOLON)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmeRoleDeclarationContext is an interface to support dynamic dispatch.
type IAcmeRoleDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeRoleDeclarationContext differentiates from other interfaces.
	IsAcmeRoleDeclarationContext()
}

type AcmeRoleDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeRoleDeclarationContext() *AcmeRoleDeclarationContext {
	var p = new(AcmeRoleDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeRoleDeclaration
	return p
}

func (*AcmeRoleDeclarationContext) IsAcmeRoleDeclarationContext() {}

func NewAcmeRoleDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeRoleDeclarationContext {
	var p = new(AcmeRoleDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeRoleDeclaration

	return p
}

func (s *AcmeRoleDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeRoleDeclarationContext) ROLE() antlr.TerminalNode {
	return s.GetToken(acmeParserROLE, 0)
}

func (s *AcmeRoleDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeRoleDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *AcmeRoleDeclarationContext) AllAcmeRoleTypeRef() []IAcmeRoleTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeRoleTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmeRoleTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeRoleTypeRefContext)
		}
	}

	return tst
}

func (s *AcmeRoleDeclarationContext) AcmeRoleTypeRef(i int) IAcmeRoleTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeRoleTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeRoleTypeRefContext)
}

func (s *AcmeRoleDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeRoleDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeRoleDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmeRoleDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmeRoleDeclarationContext) AcmeRoleBody() IAcmeRoleBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeRoleBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeRoleBodyContext)
}

func (s *AcmeRoleDeclarationContext) NEW() antlr.TerminalNode {
	return s.GetToken(acmeParserNEW, 0)
}

func (s *AcmeRoleDeclarationContext) AllAcmeRoleInstantiatedTypeRef() []IAcmeRoleInstantiatedTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeRoleInstantiatedTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmeRoleInstantiatedTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeRoleInstantiatedTypeRefContext)
		}
	}

	return tst
}

func (s *AcmeRoleDeclarationContext) AcmeRoleInstantiatedTypeRef(i int) IAcmeRoleInstantiatedTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeRoleInstantiatedTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeRoleInstantiatedTypeRefContext)
}

func (s *AcmeRoleDeclarationContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDED, 0)
}

func (s *AcmeRoleDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmeRoleDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeRoleDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeRoleDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeRoleDeclaration(s)
	}
}

func (s *AcmeRoleDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeRoleDeclaration(s)
	}
}

func (p *acmeParser) AcmeRoleDeclaration() (localctx IAcmeRoleDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeRoleDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, acmeParserRULE_acmeRoleDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		p.Match(acmeParserROLE)
	}
	{
		p.SetState(719)
		p.Identifier()
	}
	p.SetState(729)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserCOLON {
		{
			p.SetState(720)
			p.Match(acmeParserCOLON)
		}
		{
			p.SetState(721)
			p.AcmeRoleTypeRef()
		}
		p.SetState(726)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserCOMMA {
			{
				p.SetState(722)
				p.Match(acmeParserCOMMA)
			}
			{
				p.SetState(723)
				p.AcmeRoleTypeRef()
			}

			p.SetState(728)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(757)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(731)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN:
		{
			p.SetState(732)
			p.Match(acmeParserASSIGN)
		}
		p.SetState(755)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserLBRACE:
			{
				p.SetState(733)
				p.AcmeRoleBody()
			}
			p.SetState(735)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(734)
					p.Match(acmeParserSEMICOLON)
				}

			}

		case acmeParserNEW:
			{
				p.SetState(737)
				p.Match(acmeParserNEW)
			}
			{
				p.SetState(738)
				p.AcmeRoleInstantiatedTypeRef()
			}
			p.SetState(743)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserCOMMA {
				{
					p.SetState(739)
					p.Match(acmeParserCOMMA)
				}
				{
					p.SetState(740)
					p.AcmeRoleInstantiatedTypeRef()
				}

				p.SetState(745)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(753)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSEMICOLON:
				{
					p.SetState(746)
					p.Match(acmeParserSEMICOLON)
				}

			case acmeParserEXTENDED:
				{
					p.SetState(747)
					p.Match(acmeParserEXTENDED)
				}
				{
					p.SetState(748)
					p.Match(acmeParserWITH)
				}
				{
					p.SetState(749)
					p.AcmeRoleBody()
				}
				p.SetState(751)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(750)
						p.Match(acmeParserSEMICOLON)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmeRoleBodyContext is an interface to support dynamic dispatch.
type IAcmeRoleBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeRoleBodyContext differentiates from other interfaces.
	IsAcmeRoleBodyContext()
}

type AcmeRoleBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeRoleBodyContext() *AcmeRoleBodyContext {
	var p = new(AcmeRoleBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeRoleBody
	return p
}

func (*AcmeRoleBodyContext) IsAcmeRoleBodyContext() {}

func NewAcmeRoleBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeRoleBodyContext {
	var p = new(AcmeRoleBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeRoleBody

	return p
}

func (s *AcmeRoleBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeRoleBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmeRoleBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmeRoleBodyContext) AllAcmePropertyDeclaration() []IAcmePropertyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmePropertyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePropertyDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeRoleBodyContext) AcmePropertyDeclaration(i int) IAcmePropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyDeclarationContext)
}

func (s *AcmeRoleBodyContext) AllDesignRule() []IDesignRuleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem())
	var tst = make([]IDesignRuleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDesignRuleContext)
		}
	}

	return tst
}

func (s *AcmeRoleBodyContext) DesignRule(i int) IDesignRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleContext)
}

func (s *AcmeRoleBodyContext) AllAcmeRepresentationDeclaration() []IAcmeRepresentationDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeRepresentationDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeRepresentationDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeRepresentationDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeRoleBodyContext) AcmeRepresentationDeclaration(i int) IAcmeRepresentationDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeRepresentationDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeRepresentationDeclarationContext)
}

func (s *AcmeRoleBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeRoleBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeRoleBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeRoleBody(s)
	}
}

func (s *AcmeRoleBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeRoleBody(s)
	}
}

func (p *acmeParser) AcmeRoleBody() (localctx IAcmeRoleBodyContext) {
	this := p
	_ = this

	localctx = NewAcmeRoleBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, acmeParserRULE_acmeRoleBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.Match(acmeParserLBRACE)
	}
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-23)&-(0x1f+1)) == 0 && ((1<<uint((_la-23)))&((1<<(acmeParserDESIGN-23))|(1<<(acmeParserHEURISTIC-23))|(1<<(acmeParserINVARIANT-23)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(acmeParserPROPERTY-70))|(1<<(acmeParserPROPBEGIN-70))|(1<<(acmeParserREPRESENTATION-70))|(1<<(acmeParserRULE-70))|(1<<(acmeParserSEMICOLON-70)))) != 0) {
		p.SetState(763)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserPROPERTY:
			{
				p.SetState(760)
				p.AcmePropertyDeclaration()
			}

		case acmeParserDESIGN, acmeParserHEURISTIC, acmeParserINVARIANT, acmeParserPROPBEGIN, acmeParserRULE, acmeParserSEMICOLON:
			{
				p.SetState(761)
				p.DesignRule()
			}

		case acmeParserREPRESENTATION:
			{
				p.SetState(762)
				p.AcmeRepresentationDeclaration()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(767)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(768)
		p.Match(acmeParserRBRACE)
	}

	return localctx
}

// IAcmeComponentTypeDeclarationContext is an interface to support dynamic dispatch.
type IAcmeComponentTypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeComponentTypeDeclarationContext differentiates from other interfaces.
	IsAcmeComponentTypeDeclarationContext()
}

type AcmeComponentTypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeComponentTypeDeclarationContext() *AcmeComponentTypeDeclarationContext {
	var p = new(AcmeComponentTypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeComponentTypeDeclaration
	return p
}

func (*AcmeComponentTypeDeclarationContext) IsAcmeComponentTypeDeclarationContext() {}

func NewAcmeComponentTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeComponentTypeDeclarationContext {
	var p = new(AcmeComponentTypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeComponentTypeDeclaration

	return p
}

func (s *AcmeComponentTypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeComponentTypeDeclarationContext) COMPONENT() antlr.TerminalNode {
	return s.GetToken(acmeParserCOMPONENT, 0)
}

func (s *AcmeComponentTypeDeclarationContext) TYPE() antlr.TerminalNode {
	return s.GetToken(acmeParserTYPE, 0)
}

func (s *AcmeComponentTypeDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeComponentTypeDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeComponentTypeDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeComponentTypeDeclarationContext) AcmeComponentBody() IAcmeComponentBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeComponentBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeComponentBodyContext)
}

func (s *AcmeComponentTypeDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDS, 0)
}

func (s *AcmeComponentTypeDeclarationContext) AllAcmeComponentTypeRef() []IAcmeComponentTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeComponentTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmeComponentTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeComponentTypeRefContext)
		}
	}

	return tst
}

func (s *AcmeComponentTypeDeclarationContext) AcmeComponentTypeRef(i int) IAcmeComponentTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeComponentTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeComponentTypeRefContext)
}

func (s *AcmeComponentTypeDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmeComponentTypeDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmeComponentTypeDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmeComponentTypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeComponentTypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeComponentTypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeComponentTypeDeclaration(s)
	}
}

func (s *AcmeComponentTypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeComponentTypeDeclaration(s)
	}
}

func (p *acmeParser) AcmeComponentTypeDeclaration() (localctx IAcmeComponentTypeDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeComponentTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, acmeParserRULE_acmeComponentTypeDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(770)
		p.Match(acmeParserCOMPONENT)
	}
	{
		p.SetState(771)
		p.Match(acmeParserTYPE)
	}
	{
		p.SetState(772)
		p.Identifier()
	}
	p.SetState(798)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(773)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN, acmeParserEXTENDS:
		p.SetState(796)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserASSIGN:
			{
				p.SetState(774)
				p.Match(acmeParserASSIGN)
			}
			{
				p.SetState(775)
				p.AcmeComponentBody()
			}
			p.SetState(777)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(776)
					p.Match(acmeParserSEMICOLON)
				}

			}

		case acmeParserEXTENDS:
			{
				p.SetState(779)
				p.Match(acmeParserEXTENDS)
			}
			{
				p.SetState(780)
				p.AcmeComponentTypeRef()
			}
			p.SetState(785)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserCOMMA {
				{
					p.SetState(781)
					p.Match(acmeParserCOMMA)
				}
				{
					p.SetState(782)
					p.AcmeComponentTypeRef()
				}

				p.SetState(787)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(794)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSEMICOLON:
				{
					p.SetState(788)
					p.Match(acmeParserSEMICOLON)
				}

			case acmeParserWITH:
				{
					p.SetState(789)
					p.Match(acmeParserWITH)
				}
				{
					p.SetState(790)
					p.AcmeComponentBody()
				}
				p.SetState(792)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(791)
						p.Match(acmeParserSEMICOLON)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmeComponentDeclarationContext is an interface to support dynamic dispatch.
type IAcmeComponentDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeComponentDeclarationContext differentiates from other interfaces.
	IsAcmeComponentDeclarationContext()
}

type AcmeComponentDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeComponentDeclarationContext() *AcmeComponentDeclarationContext {
	var p = new(AcmeComponentDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeComponentDeclaration
	return p
}

func (*AcmeComponentDeclarationContext) IsAcmeComponentDeclarationContext() {}

func NewAcmeComponentDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeComponentDeclarationContext {
	var p = new(AcmeComponentDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeComponentDeclaration

	return p
}

func (s *AcmeComponentDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeComponentDeclarationContext) COMPONENT() antlr.TerminalNode {
	return s.GetToken(acmeParserCOMPONENT, 0)
}

func (s *AcmeComponentDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeComponentDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *AcmeComponentDeclarationContext) AllAcmeComponentTypeRef() []IAcmeComponentTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeComponentTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmeComponentTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeComponentTypeRefContext)
		}
	}

	return tst
}

func (s *AcmeComponentDeclarationContext) AcmeComponentTypeRef(i int) IAcmeComponentTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeComponentTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeComponentTypeRefContext)
}

func (s *AcmeComponentDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeComponentDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeComponentDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmeComponentDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmeComponentDeclarationContext) AcmeComponentBody() IAcmeComponentBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeComponentBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeComponentBodyContext)
}

func (s *AcmeComponentDeclarationContext) NEW() antlr.TerminalNode {
	return s.GetToken(acmeParserNEW, 0)
}

func (s *AcmeComponentDeclarationContext) AllAcmeComponentInstantiatedTypeRef() []IAcmeComponentInstantiatedTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeComponentInstantiatedTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmeComponentInstantiatedTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeComponentInstantiatedTypeRefContext)
		}
	}

	return tst
}

func (s *AcmeComponentDeclarationContext) AcmeComponentInstantiatedTypeRef(i int) IAcmeComponentInstantiatedTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeComponentInstantiatedTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeComponentInstantiatedTypeRefContext)
}

func (s *AcmeComponentDeclarationContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDED, 0)
}

func (s *AcmeComponentDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmeComponentDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeComponentDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeComponentDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeComponentDeclaration(s)
	}
}

func (s *AcmeComponentDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeComponentDeclaration(s)
	}
}

func (p *acmeParser) AcmeComponentDeclaration() (localctx IAcmeComponentDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeComponentDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, acmeParserRULE_acmeComponentDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(800)
		p.Match(acmeParserCOMPONENT)
	}
	{
		p.SetState(801)
		p.Identifier()
	}
	p.SetState(811)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserCOLON {
		{
			p.SetState(802)
			p.Match(acmeParserCOLON)
		}
		{
			p.SetState(803)
			p.AcmeComponentTypeRef()
		}
		p.SetState(808)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserCOMMA {
			{
				p.SetState(804)
				p.Match(acmeParserCOMMA)
			}
			{
				p.SetState(805)
				p.AcmeComponentTypeRef()
			}

			p.SetState(810)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(839)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(813)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN:
		{
			p.SetState(814)
			p.Match(acmeParserASSIGN)
		}
		p.SetState(837)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserLBRACE:
			{
				p.SetState(815)
				p.AcmeComponentBody()
			}
			p.SetState(817)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(816)
					p.Match(acmeParserSEMICOLON)
				}

			}

		case acmeParserNEW:
			{
				p.SetState(819)
				p.Match(acmeParserNEW)
			}
			{
				p.SetState(820)
				p.AcmeComponentInstantiatedTypeRef()
			}
			p.SetState(825)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserCOMMA {
				{
					p.SetState(821)
					p.Match(acmeParserCOMMA)
				}
				{
					p.SetState(822)
					p.AcmeComponentInstantiatedTypeRef()
				}

				p.SetState(827)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(835)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSEMICOLON:
				{
					p.SetState(828)
					p.Match(acmeParserSEMICOLON)
				}

			case acmeParserEXTENDED:
				{
					p.SetState(829)
					p.Match(acmeParserEXTENDED)
				}
				{
					p.SetState(830)
					p.Match(acmeParserWITH)
				}
				{
					p.SetState(831)
					p.AcmeComponentBody()
				}
				p.SetState(833)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(832)
						p.Match(acmeParserSEMICOLON)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmeComponentBodyContext is an interface to support dynamic dispatch.
type IAcmeComponentBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeComponentBodyContext differentiates from other interfaces.
	IsAcmeComponentBodyContext()
}

type AcmeComponentBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeComponentBodyContext() *AcmeComponentBodyContext {
	var p = new(AcmeComponentBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeComponentBody
	return p
}

func (*AcmeComponentBodyContext) IsAcmeComponentBodyContext() {}

func NewAcmeComponentBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeComponentBodyContext {
	var p = new(AcmeComponentBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeComponentBody

	return p
}

func (s *AcmeComponentBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeComponentBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmeComponentBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmeComponentBodyContext) AllAcmePropertyDeclaration() []IAcmePropertyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmePropertyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePropertyDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeComponentBodyContext) AcmePropertyDeclaration(i int) IAcmePropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyDeclarationContext)
}

func (s *AcmeComponentBodyContext) AllAcmePortDeclaration() []IAcmePortDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePortDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmePortDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePortDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeComponentBodyContext) AcmePortDeclaration(i int) IAcmePortDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePortDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePortDeclarationContext)
}

func (s *AcmeComponentBodyContext) AllDesignRule() []IDesignRuleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem())
	var tst = make([]IDesignRuleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDesignRuleContext)
		}
	}

	return tst
}

func (s *AcmeComponentBodyContext) DesignRule(i int) IDesignRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleContext)
}

func (s *AcmeComponentBodyContext) AllAcmeRepresentationDeclaration() []IAcmeRepresentationDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeRepresentationDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeRepresentationDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeRepresentationDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeComponentBodyContext) AcmeRepresentationDeclaration(i int) IAcmeRepresentationDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeRepresentationDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeRepresentationDeclarationContext)
}

func (s *AcmeComponentBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeComponentBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeComponentBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeComponentBody(s)
	}
}

func (s *AcmeComponentBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeComponentBody(s)
	}
}

func (p *acmeParser) AcmeComponentBody() (localctx IAcmeComponentBodyContext) {
	this := p
	_ = this

	localctx = NewAcmeComponentBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, acmeParserRULE_acmeComponentBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(841)
		p.Match(acmeParserLBRACE)
	}
	p.SetState(848)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-23)&-(0x1f+1)) == 0 && ((1<<uint((_la-23)))&((1<<(acmeParserDESIGN-23))|(1<<(acmeParserHEURISTIC-23))|(1<<(acmeParserINVARIANT-23)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(acmeParserPORT-68))|(1<<(acmeParserPROPERTY-68))|(1<<(acmeParserPROPBEGIN-68))|(1<<(acmeParserREPRESENTATION-68))|(1<<(acmeParserRULE-68))|(1<<(acmeParserSEMICOLON-68)))) != 0) {
		p.SetState(846)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserPROPERTY:
			{
				p.SetState(842)
				p.AcmePropertyDeclaration()
			}

		case acmeParserPORT:
			{
				p.SetState(843)
				p.AcmePortDeclaration()
			}

		case acmeParserDESIGN, acmeParserHEURISTIC, acmeParserINVARIANT, acmeParserPROPBEGIN, acmeParserRULE, acmeParserSEMICOLON:
			{
				p.SetState(844)
				p.DesignRule()
			}

		case acmeParserREPRESENTATION:
			{
				p.SetState(845)
				p.AcmeRepresentationDeclaration()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(851)
		p.Match(acmeParserRBRACE)
	}

	return localctx
}

// IAcmeConnectorTypeDeclarationContext is an interface to support dynamic dispatch.
type IAcmeConnectorTypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeConnectorTypeDeclarationContext differentiates from other interfaces.
	IsAcmeConnectorTypeDeclarationContext()
}

type AcmeConnectorTypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeConnectorTypeDeclarationContext() *AcmeConnectorTypeDeclarationContext {
	var p = new(AcmeConnectorTypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeConnectorTypeDeclaration
	return p
}

func (*AcmeConnectorTypeDeclarationContext) IsAcmeConnectorTypeDeclarationContext() {}

func NewAcmeConnectorTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeConnectorTypeDeclarationContext {
	var p = new(AcmeConnectorTypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeConnectorTypeDeclaration

	return p
}

func (s *AcmeConnectorTypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeConnectorTypeDeclarationContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(acmeParserCONNECTOR, 0)
}

func (s *AcmeConnectorTypeDeclarationContext) TYPE() antlr.TerminalNode {
	return s.GetToken(acmeParserTYPE, 0)
}

func (s *AcmeConnectorTypeDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeConnectorTypeDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeConnectorTypeDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeConnectorTypeDeclarationContext) AcmeConnectorBody() IAcmeConnectorBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeConnectorBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeConnectorBodyContext)
}

func (s *AcmeConnectorTypeDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDS, 0)
}

func (s *AcmeConnectorTypeDeclarationContext) AllAcmeConnectorTypeRef() []IAcmeConnectorTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeConnectorTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmeConnectorTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeConnectorTypeRefContext)
		}
	}

	return tst
}

func (s *AcmeConnectorTypeDeclarationContext) AcmeConnectorTypeRef(i int) IAcmeConnectorTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeConnectorTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeConnectorTypeRefContext)
}

func (s *AcmeConnectorTypeDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmeConnectorTypeDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmeConnectorTypeDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmeConnectorTypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeConnectorTypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeConnectorTypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeConnectorTypeDeclaration(s)
	}
}

func (s *AcmeConnectorTypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeConnectorTypeDeclaration(s)
	}
}

func (p *acmeParser) AcmeConnectorTypeDeclaration() (localctx IAcmeConnectorTypeDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeConnectorTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, acmeParserRULE_acmeConnectorTypeDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(853)
		p.Match(acmeParserCONNECTOR)
	}
	{
		p.SetState(854)
		p.Match(acmeParserTYPE)
	}
	{
		p.SetState(855)
		p.Identifier()
	}
	p.SetState(881)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(856)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN, acmeParserEXTENDS:
		p.SetState(879)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserASSIGN:
			{
				p.SetState(857)
				p.Match(acmeParserASSIGN)
			}
			{
				p.SetState(858)
				p.AcmeConnectorBody()
			}
			p.SetState(860)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(859)
					p.Match(acmeParserSEMICOLON)
				}

			}

		case acmeParserEXTENDS:
			{
				p.SetState(862)
				p.Match(acmeParserEXTENDS)
			}
			{
				p.SetState(863)
				p.AcmeConnectorTypeRef()
			}
			p.SetState(868)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserCOMMA {
				{
					p.SetState(864)
					p.Match(acmeParserCOMMA)
				}
				{
					p.SetState(865)
					p.AcmeConnectorTypeRef()
				}

				p.SetState(870)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(877)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSEMICOLON:
				{
					p.SetState(871)
					p.Match(acmeParserSEMICOLON)
				}

			case acmeParserWITH:
				{
					p.SetState(872)
					p.Match(acmeParserWITH)
				}
				{
					p.SetState(873)
					p.AcmeConnectorBody()
				}
				p.SetState(875)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(874)
						p.Match(acmeParserSEMICOLON)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmeConnectorDeclarationContext is an interface to support dynamic dispatch.
type IAcmeConnectorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeConnectorDeclarationContext differentiates from other interfaces.
	IsAcmeConnectorDeclarationContext()
}

type AcmeConnectorDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeConnectorDeclarationContext() *AcmeConnectorDeclarationContext {
	var p = new(AcmeConnectorDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeConnectorDeclaration
	return p
}

func (*AcmeConnectorDeclarationContext) IsAcmeConnectorDeclarationContext() {}

func NewAcmeConnectorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeConnectorDeclarationContext {
	var p = new(AcmeConnectorDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeConnectorDeclaration

	return p
}

func (s *AcmeConnectorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeConnectorDeclarationContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(acmeParserCONNECTOR, 0)
}

func (s *AcmeConnectorDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeConnectorDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *AcmeConnectorDeclarationContext) AllAcmeConnectorTypeRef() []IAcmeConnectorTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeConnectorTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmeConnectorTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeConnectorTypeRefContext)
		}
	}

	return tst
}

func (s *AcmeConnectorDeclarationContext) AcmeConnectorTypeRef(i int) IAcmeConnectorTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeConnectorTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeConnectorTypeRefContext)
}

func (s *AcmeConnectorDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeConnectorDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeConnectorDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmeConnectorDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmeConnectorDeclarationContext) AcmeConnectorBody() IAcmeConnectorBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeConnectorBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeConnectorBodyContext)
}

func (s *AcmeConnectorDeclarationContext) NEW() antlr.TerminalNode {
	return s.GetToken(acmeParserNEW, 0)
}

func (s *AcmeConnectorDeclarationContext) AllAcmeConnectorInstantiatedTypeRef() []IAcmeConnectorInstantiatedTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeConnectorInstantiatedTypeRefContext)(nil)).Elem())
	var tst = make([]IAcmeConnectorInstantiatedTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeConnectorInstantiatedTypeRefContext)
		}
	}

	return tst
}

func (s *AcmeConnectorDeclarationContext) AcmeConnectorInstantiatedTypeRef(i int) IAcmeConnectorInstantiatedTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeConnectorInstantiatedTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeConnectorInstantiatedTypeRefContext)
}

func (s *AcmeConnectorDeclarationContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDED, 0)
}

func (s *AcmeConnectorDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmeConnectorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeConnectorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeConnectorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeConnectorDeclaration(s)
	}
}

func (s *AcmeConnectorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeConnectorDeclaration(s)
	}
}

func (p *acmeParser) AcmeConnectorDeclaration() (localctx IAcmeConnectorDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeConnectorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, acmeParserRULE_acmeConnectorDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(883)
		p.Match(acmeParserCONNECTOR)
	}
	{
		p.SetState(884)
		p.Identifier()
	}
	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserCOLON {
		{
			p.SetState(885)
			p.Match(acmeParserCOLON)
		}
		{
			p.SetState(886)
			p.AcmeConnectorTypeRef()
		}
		p.SetState(891)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserCOMMA {
			{
				p.SetState(887)
				p.Match(acmeParserCOMMA)
			}
			{
				p.SetState(888)
				p.AcmeConnectorTypeRef()
			}

			p.SetState(893)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(922)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(896)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN:
		{
			p.SetState(897)
			p.Match(acmeParserASSIGN)
		}
		p.SetState(920)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserLBRACE:
			{
				p.SetState(898)
				p.AcmeConnectorBody()
			}
			p.SetState(900)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(899)
					p.Match(acmeParserSEMICOLON)
				}

			}

		case acmeParserNEW:
			{
				p.SetState(902)
				p.Match(acmeParserNEW)
			}
			{
				p.SetState(903)
				p.AcmeConnectorInstantiatedTypeRef()
			}
			p.SetState(908)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserCOMMA {
				{
					p.SetState(904)
					p.Match(acmeParserCOMMA)
				}
				{
					p.SetState(905)
					p.AcmeConnectorInstantiatedTypeRef()
				}

				p.SetState(910)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(918)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSEMICOLON:
				{
					p.SetState(911)
					p.Match(acmeParserSEMICOLON)
				}

			case acmeParserEXTENDED:
				{
					p.SetState(912)
					p.Match(acmeParserEXTENDED)
				}
				{
					p.SetState(913)
					p.Match(acmeParserWITH)
				}
				{
					p.SetState(914)
					p.AcmeConnectorBody()
				}
				p.SetState(916)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(915)
						p.Match(acmeParserSEMICOLON)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmeConnectorBodyContext is an interface to support dynamic dispatch.
type IAcmeConnectorBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeConnectorBodyContext differentiates from other interfaces.
	IsAcmeConnectorBodyContext()
}

type AcmeConnectorBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeConnectorBodyContext() *AcmeConnectorBodyContext {
	var p = new(AcmeConnectorBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeConnectorBody
	return p
}

func (*AcmeConnectorBodyContext) IsAcmeConnectorBodyContext() {}

func NewAcmeConnectorBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeConnectorBodyContext {
	var p = new(AcmeConnectorBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeConnectorBody

	return p
}

func (s *AcmeConnectorBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeConnectorBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmeConnectorBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmeConnectorBodyContext) AllAcmePropertyDeclaration() []IAcmePropertyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmePropertyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePropertyDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeConnectorBodyContext) AcmePropertyDeclaration(i int) IAcmePropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyDeclarationContext)
}

func (s *AcmeConnectorBodyContext) AllAcmeRoleDeclaration() []IAcmeRoleDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeRoleDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeRoleDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeRoleDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeConnectorBodyContext) AcmeRoleDeclaration(i int) IAcmeRoleDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeRoleDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeRoleDeclarationContext)
}

func (s *AcmeConnectorBodyContext) AllDesignRule() []IDesignRuleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem())
	var tst = make([]IDesignRuleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDesignRuleContext)
		}
	}

	return tst
}

func (s *AcmeConnectorBodyContext) DesignRule(i int) IDesignRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleContext)
}

func (s *AcmeConnectorBodyContext) AllAcmeRepresentationDeclaration() []IAcmeRepresentationDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeRepresentationDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeRepresentationDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeRepresentationDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeConnectorBodyContext) AcmeRepresentationDeclaration(i int) IAcmeRepresentationDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeRepresentationDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeRepresentationDeclarationContext)
}

func (s *AcmeConnectorBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeConnectorBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeConnectorBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeConnectorBody(s)
	}
}

func (s *AcmeConnectorBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeConnectorBody(s)
	}
}

func (p *acmeParser) AcmeConnectorBody() (localctx IAcmeConnectorBodyContext) {
	this := p
	_ = this

	localctx = NewAcmeConnectorBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, acmeParserRULE_acmeConnectorBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(924)
		p.Match(acmeParserLBRACE)
	}
	p.SetState(931)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-23)&-(0x1f+1)) == 0 && ((1<<uint((_la-23)))&((1<<(acmeParserDESIGN-23))|(1<<(acmeParserHEURISTIC-23))|(1<<(acmeParserINVARIANT-23)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(acmeParserPROPERTY-70))|(1<<(acmeParserPROPBEGIN-70))|(1<<(acmeParserREPRESENTATION-70))|(1<<(acmeParserROLE-70))|(1<<(acmeParserRULE-70))|(1<<(acmeParserSEMICOLON-70)))) != 0) {
		p.SetState(929)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserPROPERTY:
			{
				p.SetState(925)
				p.AcmePropertyDeclaration()
			}

		case acmeParserROLE:
			{
				p.SetState(926)
				p.AcmeRoleDeclaration()
			}

		case acmeParserDESIGN, acmeParserHEURISTIC, acmeParserINVARIANT, acmeParserPROPBEGIN, acmeParserRULE, acmeParserSEMICOLON:
			{
				p.SetState(927)
				p.DesignRule()
			}

		case acmeParserREPRESENTATION:
			{
				p.SetState(928)
				p.AcmeRepresentationDeclaration()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(933)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(934)
		p.Match(acmeParserRBRACE)
	}

	return localctx
}

// IAcmeRepresentationDeclarationContext is an interface to support dynamic dispatch.
type IAcmeRepresentationDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeRepresentationDeclarationContext differentiates from other interfaces.
	IsAcmeRepresentationDeclarationContext()
}

type AcmeRepresentationDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeRepresentationDeclarationContext() *AcmeRepresentationDeclarationContext {
	var p = new(AcmeRepresentationDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeRepresentationDeclaration
	return p
}

func (*AcmeRepresentationDeclarationContext) IsAcmeRepresentationDeclarationContext() {}

func NewAcmeRepresentationDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeRepresentationDeclarationContext {
	var p = new(AcmeRepresentationDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeRepresentationDeclaration

	return p
}

func (s *AcmeRepresentationDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeRepresentationDeclarationContext) REPRESENTATION() antlr.TerminalNode {
	return s.GetToken(acmeParserREPRESENTATION, 0)
}

func (s *AcmeRepresentationDeclarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmeRepresentationDeclarationContext) AcmeSystemDeclaration() IAcmeSystemDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeSystemDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeSystemDeclarationContext)
}

func (s *AcmeRepresentationDeclarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmeRepresentationDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(acmeParserIDENTIFIER, 0)
}

func (s *AcmeRepresentationDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeRepresentationDeclarationContext) AcmeBindingsMapDeclaration() IAcmeBindingsMapDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeBindingsMapDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeBindingsMapDeclarationContext)
}

func (s *AcmeRepresentationDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeRepresentationDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeRepresentationDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeRepresentationDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeRepresentationDeclaration(s)
	}
}

func (s *AcmeRepresentationDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeRepresentationDeclaration(s)
	}
}

func (p *acmeParser) AcmeRepresentationDeclaration() (localctx IAcmeRepresentationDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeRepresentationDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, acmeParserRULE_acmeRepresentationDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(936)
		p.Match(acmeParserREPRESENTATION)
	}
	p.SetState(939)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserIDENTIFIER {
		{
			p.SetState(937)
			p.Match(acmeParserIDENTIFIER)
		}
		{
			p.SetState(938)
			p.Match(acmeParserASSIGN)
		}

	}
	{
		p.SetState(941)
		p.Match(acmeParserLBRACE)
	}
	{
		p.SetState(942)
		p.AcmeSystemDeclaration()
	}
	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserBINDINGS {
		{
			p.SetState(943)
			p.AcmeBindingsMapDeclaration()
		}

	}
	{
		p.SetState(946)
		p.Match(acmeParserRBRACE)
	}
	p.SetState(948)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(947)
			p.Match(acmeParserSEMICOLON)
		}

	}

	return localctx
}

// IAcmeBindingsMapDeclarationContext is an interface to support dynamic dispatch.
type IAcmeBindingsMapDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeBindingsMapDeclarationContext differentiates from other interfaces.
	IsAcmeBindingsMapDeclarationContext()
}

type AcmeBindingsMapDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeBindingsMapDeclarationContext() *AcmeBindingsMapDeclarationContext {
	var p = new(AcmeBindingsMapDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeBindingsMapDeclaration
	return p
}

func (*AcmeBindingsMapDeclarationContext) IsAcmeBindingsMapDeclarationContext() {}

func NewAcmeBindingsMapDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeBindingsMapDeclarationContext {
	var p = new(AcmeBindingsMapDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeBindingsMapDeclaration

	return p
}

func (s *AcmeBindingsMapDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeBindingsMapDeclarationContext) BINDINGS() antlr.TerminalNode {
	return s.GetToken(acmeParserBINDINGS, 0)
}

func (s *AcmeBindingsMapDeclarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmeBindingsMapDeclarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmeBindingsMapDeclarationContext) AllAcmeBindingDeclaration() []IAcmeBindingDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeBindingDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmeBindingDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeBindingDeclarationContext)
		}
	}

	return tst
}

func (s *AcmeBindingsMapDeclarationContext) AcmeBindingDeclaration(i int) IAcmeBindingDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeBindingDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeBindingDeclarationContext)
}

func (s *AcmeBindingsMapDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeBindingsMapDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeBindingsMapDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeBindingsMapDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeBindingsMapDeclaration(s)
	}
}

func (s *AcmeBindingsMapDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeBindingsMapDeclaration(s)
	}
}

func (p *acmeParser) AcmeBindingsMapDeclaration() (localctx IAcmeBindingsMapDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeBindingsMapDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, acmeParserRULE_acmeBindingsMapDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(950)
		p.Match(acmeParserBINDINGS)
	}
	{
		p.SetState(951)
		p.Match(acmeParserLBRACE)
	}
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == acmeParserIDENTIFIER {
		{
			p.SetState(952)
			p.AcmeBindingDeclaration()
		}

		p.SetState(957)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(958)
		p.Match(acmeParserRBRACE)
	}
	p.SetState(960)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserSEMICOLON {
		{
			p.SetState(959)
			p.Match(acmeParserSEMICOLON)
		}

	}

	return localctx
}

// IAcmeBindingDeclarationContext is an interface to support dynamic dispatch.
type IAcmeBindingDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeBindingDeclarationContext differentiates from other interfaces.
	IsAcmeBindingDeclarationContext()
}

type AcmeBindingDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeBindingDeclarationContext() *AcmeBindingDeclarationContext {
	var p = new(AcmeBindingDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeBindingDeclaration
	return p
}

func (*AcmeBindingDeclarationContext) IsAcmeBindingDeclarationContext() {}

func NewAcmeBindingDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeBindingDeclarationContext {
	var p = new(AcmeBindingDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeBindingDeclaration

	return p
}

func (s *AcmeBindingDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeBindingDeclarationContext) AllAcmeInstanceRef() []IAcmeInstanceRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeInstanceRefContext)(nil)).Elem())
	var tst = make([]IAcmeInstanceRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeInstanceRefContext)
		}
	}

	return tst
}

func (s *AcmeBindingDeclarationContext) AcmeInstanceRef(i int) IAcmeInstanceRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeInstanceRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeInstanceRefContext)
}

func (s *AcmeBindingDeclarationContext) TO() antlr.TerminalNode {
	return s.GetToken(acmeParserTO, 0)
}

func (s *AcmeBindingDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeBindingDeclarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmeBindingDeclarationContext) AcmePropertyDeclaration() IAcmePropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyDeclarationContext)
}

func (s *AcmeBindingDeclarationContext) AcmePropertyBlock() IAcmePropertyBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyBlockContext)
}

func (s *AcmeBindingDeclarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmeBindingDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeBindingDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeBindingDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeBindingDeclaration(s)
	}
}

func (s *AcmeBindingDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeBindingDeclaration(s)
	}
}

func (p *acmeParser) AcmeBindingDeclaration() (localctx IAcmeBindingDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeBindingDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, acmeParserRULE_acmeBindingDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(962)
		p.AcmeInstanceRef()
	}
	{
		p.SetState(963)
		p.Match(acmeParserTO)
	}
	{
		p.SetState(964)
		p.AcmeInstanceRef()
	}
	p.SetState(970)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserLBRACE {
		{
			p.SetState(965)
			p.Match(acmeParserLBRACE)
		}
		{
			p.SetState(966)
			p.AcmePropertyDeclaration()
		}
		{
			p.SetState(967)
			p.AcmePropertyBlock()
		}
		{
			p.SetState(968)
			p.Match(acmeParserRBRACE)
		}

	}
	{
		p.SetState(972)
		p.Match(acmeParserSEMICOLON)
	}

	return localctx
}

// IAcmeAttachmentDeclarationContext is an interface to support dynamic dispatch.
type IAcmeAttachmentDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeAttachmentDeclarationContext differentiates from other interfaces.
	IsAcmeAttachmentDeclarationContext()
}

type AcmeAttachmentDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeAttachmentDeclarationContext() *AcmeAttachmentDeclarationContext {
	var p = new(AcmeAttachmentDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeAttachmentDeclaration
	return p
}

func (*AcmeAttachmentDeclarationContext) IsAcmeAttachmentDeclarationContext() {}

func NewAcmeAttachmentDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeAttachmentDeclarationContext {
	var p = new(AcmeAttachmentDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeAttachmentDeclaration

	return p
}

func (s *AcmeAttachmentDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeAttachmentDeclarationContext) ATTACHMENT() antlr.TerminalNode {
	return s.GetToken(acmeParserATTACHMENT, 0)
}

func (s *AcmeAttachmentDeclarationContext) AllAcmeInstanceRef() []IAcmeInstanceRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmeInstanceRefContext)(nil)).Elem())
	var tst = make([]IAcmeInstanceRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmeInstanceRefContext)
		}
	}

	return tst
}

func (s *AcmeAttachmentDeclarationContext) AcmeInstanceRef(i int) IAcmeInstanceRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeInstanceRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmeInstanceRefContext)
}

func (s *AcmeAttachmentDeclarationContext) TO() antlr.TerminalNode {
	return s.GetToken(acmeParserTO, 0)
}

func (s *AcmeAttachmentDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeAttachmentDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeAttachmentDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeAttachmentDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeAttachmentDeclaration(s)
	}
}

func (s *AcmeAttachmentDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeAttachmentDeclaration(s)
	}
}

func (p *acmeParser) AcmeAttachmentDeclaration() (localctx IAcmeAttachmentDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeAttachmentDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, acmeParserRULE_acmeAttachmentDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(974)
		p.Match(acmeParserATTACHMENT)
	}
	{
		p.SetState(975)
		p.AcmeInstanceRef()
	}
	{
		p.SetState(976)
		p.Match(acmeParserTO)
	}
	{
		p.SetState(977)
		p.AcmeInstanceRef()
	}
	{
		p.SetState(978)
		p.Match(acmeParserSEMICOLON)
	}

	return localctx
}

// IAcmePropertyDeclarationContext is an interface to support dynamic dispatch.
type IAcmePropertyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyDeclarationContext differentiates from other interfaces.
	IsAcmePropertyDeclarationContext()
}

type AcmePropertyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyDeclarationContext() *AcmePropertyDeclarationContext {
	var p = new(AcmePropertyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyDeclaration
	return p
}

func (*AcmePropertyDeclarationContext) IsAcmePropertyDeclarationContext() {}

func NewAcmePropertyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyDeclarationContext {
	var p = new(AcmePropertyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyDeclaration

	return p
}

func (s *AcmePropertyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyDeclarationContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(acmeParserPROPERTY, 0)
}

func (s *AcmePropertyDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmePropertyDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmePropertyDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *AcmePropertyDeclarationContext) AcmePropertyTypeRef() IAcmePropertyTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeRefContext)
}

func (s *AcmePropertyDeclarationContext) AcmePropertyBlock() IAcmePropertyBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyBlockContext)
}

func (s *AcmePropertyDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmePropertyDeclarationContext) AcmePropertyValueDeclaration() IAcmePropertyValueDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyValueDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyValueDeclarationContext)
}

func (s *AcmePropertyDeclarationContext) CONTAINASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserCONTAINASSIGN, 0)
}

func (s *AcmePropertyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyDeclaration(s)
	}
}

func (s *AcmePropertyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyDeclaration(s)
	}
}

func (p *acmeParser) AcmePropertyDeclaration() (localctx IAcmePropertyDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, acmeParserRULE_acmePropertyDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(980)
		p.Match(acmeParserPROPERTY)
	}
	{
		p.SetState(981)
		p.Identifier()
	}
	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserCOLON {
		{
			p.SetState(982)
			p.Match(acmeParserCOLON)
		}
		{
			p.SetState(983)
			p.AcmePropertyTypeRef()
		}

	}
	p.SetState(990)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserASSIGN:
		{
			p.SetState(986)
			p.Match(acmeParserASSIGN)
		}
		{
			p.SetState(987)
			p.AcmePropertyValueDeclaration()
		}

	case acmeParserCONTAINASSIGN:
		{
			p.SetState(988)
			p.Match(acmeParserCONTAINASSIGN)
		}
		{
			p.SetState(989)
			p.AcmePropertyValueDeclaration()
		}

	case acmeParserPROPBEGIN, acmeParserSEMICOLON:

	default:
	}
	p.SetState(993)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserPROPBEGIN {
		{
			p.SetState(992)
			p.AcmePropertyBlock()
		}

	}
	{
		p.SetState(995)
		p.Match(acmeParserSEMICOLON)
	}

	return localctx
}

// IAcmePropertyValueDeclarationContext is an interface to support dynamic dispatch.
type IAcmePropertyValueDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyValueDeclarationContext differentiates from other interfaces.
	IsAcmePropertyValueDeclarationContext()
}

type AcmePropertyValueDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyValueDeclarationContext() *AcmePropertyValueDeclarationContext {
	var p = new(AcmePropertyValueDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyValueDeclaration
	return p
}

func (*AcmePropertyValueDeclarationContext) IsAcmePropertyValueDeclarationContext() {}

func NewAcmePropertyValueDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyValueDeclarationContext {
	var p = new(AcmePropertyValueDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyValueDeclaration

	return p
}

func (s *AcmePropertyValueDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyValueDeclarationContext) INTEGER_LITERAL() antlr.TerminalNode {
	return s.GetToken(acmeParserINTEGER_LITERAL, 0)
}

func (s *AcmePropertyValueDeclarationContext) FLOATING_POINT_LITERAL() antlr.TerminalNode {
	return s.GetToken(acmeParserFLOATING_POINT_LITERAL, 0)
}

func (s *AcmePropertyValueDeclarationContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(acmeParserSTRING_LITERAL, 0)
}

func (s *AcmePropertyValueDeclarationContext) FALSE() antlr.TerminalNode {
	return s.GetToken(acmeParserFALSE, 0)
}

func (s *AcmePropertyValueDeclarationContext) TRUE() antlr.TerminalNode {
	return s.GetToken(acmeParserTRUE, 0)
}

func (s *AcmePropertyValueDeclarationContext) AcmePropertySet() IAcmePropertySetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertySetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertySetContext)
}

func (s *AcmePropertyValueDeclarationContext) AcmePropertyRecord() IAcmePropertyRecordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyRecordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyRecordContext)
}

func (s *AcmePropertyValueDeclarationContext) AcmePropertySequence() IAcmePropertySequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertySequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertySequenceContext)
}

func (s *AcmePropertyValueDeclarationContext) Enumidentifier() IEnumidentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumidentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumidentifierContext)
}

func (s *AcmePropertyValueDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyValueDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyValueDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyValueDeclaration(s)
	}
}

func (s *AcmePropertyValueDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyValueDeclaration(s)
	}
}

func (p *acmeParser) AcmePropertyValueDeclaration() (localctx IAcmePropertyValueDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyValueDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, acmeParserRULE_acmePropertyValueDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1006)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserINTEGER_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(997)
			p.Match(acmeParserINTEGER_LITERAL)
		}

	case acmeParserFLOATING_POINT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(998)
			p.Match(acmeParserFLOATING_POINT_LITERAL)
		}

	case acmeParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(999)
			p.Match(acmeParserSTRING_LITERAL)
		}

	case acmeParserFALSE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1000)
			p.Match(acmeParserFALSE)
		}

	case acmeParserTRUE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1001)
			p.Match(acmeParserTRUE)
		}

	case acmeParserLBRACE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1002)
			p.AcmePropertySet()
		}

	case acmeParserLBRACKET:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1003)
			p.AcmePropertyRecord()
		}

	case acmeParserLANGLE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1004)
			p.AcmePropertySequence()
		}

	case acmeParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1005)
			p.Enumidentifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnumidentifierContext is an interface to support dynamic dispatch.
type IEnumidentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumidentifierContext differentiates from other interfaces.
	IsEnumidentifierContext()
}

type EnumidentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumidentifierContext() *EnumidentifierContext {
	var p = new(EnumidentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_enumidentifier
	return p
}

func (*EnumidentifierContext) IsEnumidentifierContext() {}

func NewEnumidentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumidentifierContext {
	var p = new(EnumidentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_enumidentifier

	return p
}

func (s *EnumidentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumidentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(acmeParserIDENTIFIER, 0)
}

func (s *EnumidentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumidentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumidentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterEnumidentifier(s)
	}
}

func (s *EnumidentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitEnumidentifier(s)
	}
}

func (p *acmeParser) Enumidentifier() (localctx IEnumidentifierContext) {
	this := p
	_ = this

	localctx = NewEnumidentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, acmeParserRULE_enumidentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1008)
		p.Match(acmeParserIDENTIFIER)
	}

	return localctx
}

// IAcmePropertyElementContext is an interface to support dynamic dispatch.
type IAcmePropertyElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyElementContext differentiates from other interfaces.
	IsAcmePropertyElementContext()
}

type AcmePropertyElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyElementContext() *AcmePropertyElementContext {
	var p = new(AcmePropertyElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyElement
	return p
}

func (*AcmePropertyElementContext) IsAcmePropertyElementContext() {}

func NewAcmePropertyElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyElementContext {
	var p = new(AcmePropertyElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyElement

	return p
}

func (s *AcmePropertyElementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyElementContext) AcmePropertyCompoundElement() IAcmePropertyCompoundElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyCompoundElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyCompoundElementContext)
}

func (s *AcmePropertyElementContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(acmeParserIDENTIFIER)
}

func (s *AcmePropertyElementContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserIDENTIFIER, i)
}

func (s *AcmePropertyElementContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(acmeParserDOT)
}

func (s *AcmePropertyElementContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, i)
}

func (s *AcmePropertyElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyElement(s)
	}
}

func (s *AcmePropertyElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyElement(s)
	}
}

func (p *acmeParser) AcmePropertyElement() (localctx IAcmePropertyElementContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, acmeParserRULE_acmePropertyElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1019)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserIDENTIFIER:
		{
			p.SetState(1010)
			p.Match(acmeParserIDENTIFIER)
		}
		p.SetState(1015)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserDOT {
			{
				p.SetState(1011)
				p.Match(acmeParserDOT)
			}
			{
				p.SetState(1012)
				p.Match(acmeParserIDENTIFIER)
			}

			p.SetState(1017)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case acmeParserLBRACE, acmeParserLBRACKET, acmeParserLANGLE:
		{
			p.SetState(1018)
			p.AcmePropertyCompoundElement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmePropertyCompoundElementContext is an interface to support dynamic dispatch.
type IAcmePropertyCompoundElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyCompoundElementContext differentiates from other interfaces.
	IsAcmePropertyCompoundElementContext()
}

type AcmePropertyCompoundElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyCompoundElementContext() *AcmePropertyCompoundElementContext {
	var p = new(AcmePropertyCompoundElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyCompoundElement
	return p
}

func (*AcmePropertyCompoundElementContext) IsAcmePropertyCompoundElementContext() {}

func NewAcmePropertyCompoundElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyCompoundElementContext {
	var p = new(AcmePropertyCompoundElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyCompoundElement

	return p
}

func (s *AcmePropertyCompoundElementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyCompoundElementContext) AcmePropertySet() IAcmePropertySetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertySetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertySetContext)
}

func (s *AcmePropertyCompoundElementContext) AcmePropertyRecord() IAcmePropertyRecordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyRecordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyRecordContext)
}

func (s *AcmePropertyCompoundElementContext) AcmePropertySequence() IAcmePropertySequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertySequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertySequenceContext)
}

func (s *AcmePropertyCompoundElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyCompoundElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyCompoundElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyCompoundElement(s)
	}
}

func (s *AcmePropertyCompoundElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyCompoundElement(s)
	}
}

func (p *acmeParser) AcmePropertyCompoundElement() (localctx IAcmePropertyCompoundElementContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyCompoundElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, acmeParserRULE_acmePropertyCompoundElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1024)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserLBRACE:
		{
			p.SetState(1021)
			p.AcmePropertySet()
		}

	case acmeParserLBRACKET:
		{
			p.SetState(1022)
			p.AcmePropertyRecord()
		}

	case acmeParserLANGLE:
		{
			p.SetState(1023)
			p.AcmePropertySequence()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmePropertySetContext is an interface to support dynamic dispatch.
type IAcmePropertySetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertySetContext differentiates from other interfaces.
	IsAcmePropertySetContext()
}

type AcmePropertySetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertySetContext() *AcmePropertySetContext {
	var p = new(AcmePropertySetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertySet
	return p
}

func (*AcmePropertySetContext) IsAcmePropertySetContext() {}

func NewAcmePropertySetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertySetContext {
	var p = new(AcmePropertySetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertySet

	return p
}

func (s *AcmePropertySetContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertySetContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmePropertySetContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmePropertySetContext) AllAcmePropertyValueDeclaration() []IAcmePropertyValueDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePropertyValueDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmePropertyValueDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePropertyValueDeclarationContext)
		}
	}

	return tst
}

func (s *AcmePropertySetContext) AcmePropertyValueDeclaration(i int) IAcmePropertyValueDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyValueDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyValueDeclarationContext)
}

func (s *AcmePropertySetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmePropertySetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmePropertySetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertySetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertySetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertySet(s)
	}
}

func (s *AcmePropertySetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertySet(s)
	}
}

func (p *acmeParser) AcmePropertySet() (localctx IAcmePropertySetContext) {
	this := p
	_ = this

	localctx = NewAcmePropertySetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, acmeParserRULE_acmePropertySet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1026)
		p.Match(acmeParserLBRACE)
	}
	p.SetState(1035)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-49)&-(0x1f+1)) == 0 && ((1<<uint((_la-49)))&((1<<(acmeParserLBRACE-49))|(1<<(acmeParserLBRACKET-49))|(1<<(acmeParserLANGLE-49)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(acmeParserTRUE-97))|(1<<(acmeParserFALSE-97))|(1<<(acmeParserFLOATING_POINT_LITERAL-97))|(1<<(acmeParserINTEGER_LITERAL-97))|(1<<(acmeParserSTRING_LITERAL-97))|(1<<(acmeParserIDENTIFIER-97)))) != 0) {
		{
			p.SetState(1027)
			p.AcmePropertyValueDeclaration()
		}
		p.SetState(1032)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserCOMMA {
			{
				p.SetState(1028)
				p.Match(acmeParserCOMMA)
			}
			{
				p.SetState(1029)
				p.AcmePropertyValueDeclaration()
			}

			p.SetState(1034)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1037)
		p.Match(acmeParserRBRACE)
	}

	return localctx
}

// IAcmePropertyRecordEntryContext is an interface to support dynamic dispatch.
type IAcmePropertyRecordEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyRecordEntryContext differentiates from other interfaces.
	IsAcmePropertyRecordEntryContext()
}

type AcmePropertyRecordEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyRecordEntryContext() *AcmePropertyRecordEntryContext {
	var p = new(AcmePropertyRecordEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyRecordEntry
	return p
}

func (*AcmePropertyRecordEntryContext) IsAcmePropertyRecordEntryContext() {}

func NewAcmePropertyRecordEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyRecordEntryContext {
	var p = new(AcmePropertyRecordEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyRecordEntry

	return p
}

func (s *AcmePropertyRecordEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyRecordEntryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmePropertyRecordEntryContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmePropertyRecordEntryContext) AcmePropertyValueDeclaration() IAcmePropertyValueDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyValueDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyValueDeclarationContext)
}

func (s *AcmePropertyRecordEntryContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *AcmePropertyRecordEntryContext) AcmePropertyTypeRef() IAcmePropertyTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeRefContext)
}

func (s *AcmePropertyRecordEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyRecordEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyRecordEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyRecordEntry(s)
	}
}

func (s *AcmePropertyRecordEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyRecordEntry(s)
	}
}

func (p *acmeParser) AcmePropertyRecordEntry() (localctx IAcmePropertyRecordEntryContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyRecordEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, acmeParserRULE_acmePropertyRecordEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1039)
		p.Identifier()
	}
	p.SetState(1042)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserCOLON {
		{
			p.SetState(1040)
			p.Match(acmeParserCOLON)
		}
		{
			p.SetState(1041)
			p.AcmePropertyTypeRef()
		}

	}
	{
		p.SetState(1044)
		p.Match(acmeParserASSIGN)
	}
	{
		p.SetState(1045)
		p.AcmePropertyValueDeclaration()
	}

	return localctx
}

// IAcmePropertyRecordContext is an interface to support dynamic dispatch.
type IAcmePropertyRecordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyRecordContext differentiates from other interfaces.
	IsAcmePropertyRecordContext()
}

type AcmePropertyRecordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyRecordContext() *AcmePropertyRecordContext {
	var p = new(AcmePropertyRecordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyRecord
	return p
}

func (*AcmePropertyRecordContext) IsAcmePropertyRecordContext() {}

func NewAcmePropertyRecordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyRecordContext {
	var p = new(AcmePropertyRecordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyRecord

	return p
}

func (s *AcmePropertyRecordContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyRecordContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACKET, 0)
}

func (s *AcmePropertyRecordContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACKET, 0)
}

func (s *AcmePropertyRecordContext) AllAcmePropertyRecordEntry() []IAcmePropertyRecordEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePropertyRecordEntryContext)(nil)).Elem())
	var tst = make([]IAcmePropertyRecordEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePropertyRecordEntryContext)
		}
	}

	return tst
}

func (s *AcmePropertyRecordContext) AcmePropertyRecordEntry(i int) IAcmePropertyRecordEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyRecordEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyRecordEntryContext)
}

func (s *AcmePropertyRecordContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(acmeParserSEMICOLON)
}

func (s *AcmePropertyRecordContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, i)
}

func (s *AcmePropertyRecordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyRecordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyRecordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyRecord(s)
	}
}

func (s *AcmePropertyRecordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyRecord(s)
	}
}

func (p *acmeParser) AcmePropertyRecord() (localctx IAcmePropertyRecordContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyRecordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, acmeParserRULE_acmePropertyRecord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1047)
		p.Match(acmeParserLBRACKET)
	}
	p.SetState(1059)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserIDENTIFIER {
		{
			p.SetState(1048)
			p.AcmePropertyRecordEntry()
		}
		p.SetState(1053)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1049)
					p.Match(acmeParserSEMICOLON)
				}
				{
					p.SetState(1050)
					p.AcmePropertyRecordEntry()
				}

			}
			p.SetState(1055)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())
		}
		p.SetState(1057)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserSEMICOLON {
			{
				p.SetState(1056)
				p.Match(acmeParserSEMICOLON)
			}

		}

	}
	{
		p.SetState(1061)
		p.Match(acmeParserRBRACKET)
	}

	return localctx
}

// IAcmePropertySequenceContext is an interface to support dynamic dispatch.
type IAcmePropertySequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertySequenceContext differentiates from other interfaces.
	IsAcmePropertySequenceContext()
}

type AcmePropertySequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertySequenceContext() *AcmePropertySequenceContext {
	var p = new(AcmePropertySequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertySequence
	return p
}

func (*AcmePropertySequenceContext) IsAcmePropertySequenceContext() {}

func NewAcmePropertySequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertySequenceContext {
	var p = new(AcmePropertySequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertySequence

	return p
}

func (s *AcmePropertySequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertySequenceContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(acmeParserLANGLE, 0)
}

func (s *AcmePropertySequenceContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(acmeParserRANGLE, 0)
}

func (s *AcmePropertySequenceContext) AllAcmePropertyValueDeclaration() []IAcmePropertyValueDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePropertyValueDeclarationContext)(nil)).Elem())
	var tst = make([]IAcmePropertyValueDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePropertyValueDeclarationContext)
		}
	}

	return tst
}

func (s *AcmePropertySequenceContext) AcmePropertyValueDeclaration(i int) IAcmePropertyValueDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyValueDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyValueDeclarationContext)
}

func (s *AcmePropertySequenceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmePropertySequenceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmePropertySequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertySequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertySequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertySequence(s)
	}
}

func (s *AcmePropertySequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertySequence(s)
	}
}

func (p *acmeParser) AcmePropertySequence() (localctx IAcmePropertySequenceContext) {
	this := p
	_ = this

	localctx = NewAcmePropertySequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, acmeParserRULE_acmePropertySequence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1063)
		p.Match(acmeParserLANGLE)
	}
	p.SetState(1072)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-49)&-(0x1f+1)) == 0 && ((1<<uint((_la-49)))&((1<<(acmeParserLBRACE-49))|(1<<(acmeParserLBRACKET-49))|(1<<(acmeParserLANGLE-49)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(acmeParserTRUE-97))|(1<<(acmeParserFALSE-97))|(1<<(acmeParserFLOATING_POINT_LITERAL-97))|(1<<(acmeParserINTEGER_LITERAL-97))|(1<<(acmeParserSTRING_LITERAL-97))|(1<<(acmeParserIDENTIFIER-97)))) != 0) {
		{
			p.SetState(1064)
			p.AcmePropertyValueDeclaration()
		}
		p.SetState(1069)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserCOMMA {
			{
				p.SetState(1065)
				p.Match(acmeParserCOMMA)
			}
			{
				p.SetState(1066)
				p.AcmePropertyValueDeclaration()
			}

			p.SetState(1071)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1074)
		p.Match(acmeParserRANGLE)
	}

	return localctx
}

// IAcmePropertyTypeRecordContext is an interface to support dynamic dispatch.
type IAcmePropertyTypeRecordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyTypeRecordContext differentiates from other interfaces.
	IsAcmePropertyTypeRecordContext()
}

type AcmePropertyTypeRecordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyTypeRecordContext() *AcmePropertyTypeRecordContext {
	var p = new(AcmePropertyTypeRecordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyTypeRecord
	return p
}

func (*AcmePropertyTypeRecordContext) IsAcmePropertyTypeRecordContext() {}

func NewAcmePropertyTypeRecordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyTypeRecordContext {
	var p = new(AcmePropertyTypeRecordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyTypeRecord

	return p
}

func (s *AcmePropertyTypeRecordContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyTypeRecordContext) RECORD() antlr.TerminalNode {
	return s.GetToken(acmeParserRECORD, 0)
}

func (s *AcmePropertyTypeRecordContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACKET, 0)
}

func (s *AcmePropertyTypeRecordContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACKET, 0)
}

func (s *AcmePropertyTypeRecordContext) AllAcmePropertyRecordFieldDescription() []IAcmePropertyRecordFieldDescriptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePropertyRecordFieldDescriptionContext)(nil)).Elem())
	var tst = make([]IAcmePropertyRecordFieldDescriptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePropertyRecordFieldDescriptionContext)
		}
	}

	return tst
}

func (s *AcmePropertyTypeRecordContext) AcmePropertyRecordFieldDescription(i int) IAcmePropertyRecordFieldDescriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyRecordFieldDescriptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyRecordFieldDescriptionContext)
}

func (s *AcmePropertyTypeRecordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyTypeRecordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyTypeRecordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyTypeRecord(s)
	}
}

func (s *AcmePropertyTypeRecordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyTypeRecord(s)
	}
}

func (p *acmeParser) AcmePropertyTypeRecord() (localctx IAcmePropertyTypeRecordContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyTypeRecordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, acmeParserRULE_acmePropertyTypeRecord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1076)
		p.Match(acmeParserRECORD)
	}
	{
		p.SetState(1077)
		p.Match(acmeParserLBRACKET)
	}
	p.SetState(1081)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == acmeParserIDENTIFIER {
		{
			p.SetState(1078)
			p.AcmePropertyRecordFieldDescription()
		}

		p.SetState(1083)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1084)
		p.Match(acmeParserRBRACKET)
	}

	return localctx
}

// IAcmePropertyTypeSetContext is an interface to support dynamic dispatch.
type IAcmePropertyTypeSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyTypeSetContext differentiates from other interfaces.
	IsAcmePropertyTypeSetContext()
}

type AcmePropertyTypeSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyTypeSetContext() *AcmePropertyTypeSetContext {
	var p = new(AcmePropertyTypeSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyTypeSet
	return p
}

func (*AcmePropertyTypeSetContext) IsAcmePropertyTypeSetContext() {}

func NewAcmePropertyTypeSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyTypeSetContext {
	var p = new(AcmePropertyTypeSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyTypeSet

	return p
}

func (s *AcmePropertyTypeSetContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyTypeSetContext) SET() antlr.TerminalNode {
	return s.GetToken(acmeParserSET, 0)
}

func (s *AcmePropertyTypeSetContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmePropertyTypeSetContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmePropertyTypeSetContext) AcmeTypeRef() IAcmeTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeTypeRefContext)
}

func (s *AcmePropertyTypeSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyTypeSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyTypeSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyTypeSet(s)
	}
}

func (s *AcmePropertyTypeSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyTypeSet(s)
	}
}

func (p *acmeParser) AcmePropertyTypeSet() (localctx IAcmePropertyTypeSetContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyTypeSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, acmeParserRULE_acmePropertyTypeSet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1086)
		p.Match(acmeParserSET)
	}
	{
		p.SetState(1087)
		p.Match(acmeParserLBRACE)
	}
	p.SetState(1089)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-7)&-(0x1f+1)) == 0 && ((1<<uint((_la-7)))&((1<<(acmeParserANY-7))|(1<<(acmeParserCOMPONENT-7))|(1<<(acmeParserCONNECTOR-7))|(1<<(acmeParserDOUBLE-7))|(1<<(acmeParserELEMENT-7))|(1<<(acmeParserENUM-7))|(1<<(acmeParserFLOAT-7)))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(acmeParserGROUP-39))|(1<<(acmeParserINT-39))|(1<<(acmeParserPORT-39))|(1<<(acmeParserPROPERTY-39)))) != 0) || (((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(acmeParserRECORD-74))|(1<<(acmeParserREPRESENTATION-74))|(1<<(acmeParserROLE-74))|(1<<(acmeParserSEQUENCE-74))|(1<<(acmeParserSET-74))|(1<<(acmeParserSTRING-74))|(1<<(acmeParserSYSTEM-74))|(1<<(acmeParserTYPE-74))|(1<<(acmeParserBOOLEAN-74))|(1<<(acmeParserIDENTIFIER-74)))) != 0) {
		{
			p.SetState(1088)
			p.AcmeTypeRef()
		}

	}
	{
		p.SetState(1091)
		p.Match(acmeParserRBRACE)
	}

	return localctx
}

// IAcmePropertyTypeSequenceContext is an interface to support dynamic dispatch.
type IAcmePropertyTypeSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyTypeSequenceContext differentiates from other interfaces.
	IsAcmePropertyTypeSequenceContext()
}

type AcmePropertyTypeSequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyTypeSequenceContext() *AcmePropertyTypeSequenceContext {
	var p = new(AcmePropertyTypeSequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyTypeSequence
	return p
}

func (*AcmePropertyTypeSequenceContext) IsAcmePropertyTypeSequenceContext() {}

func NewAcmePropertyTypeSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyTypeSequenceContext {
	var p = new(AcmePropertyTypeSequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyTypeSequence

	return p
}

func (s *AcmePropertyTypeSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyTypeSequenceContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(acmeParserSEQUENCE, 0)
}

func (s *AcmePropertyTypeSequenceContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(acmeParserLANGLE, 0)
}

func (s *AcmePropertyTypeSequenceContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(acmeParserRANGLE, 0)
}

func (s *AcmePropertyTypeSequenceContext) AcmePropertyTypeRef() IAcmePropertyTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeRefContext)
}

func (s *AcmePropertyTypeSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyTypeSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyTypeSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyTypeSequence(s)
	}
}

func (s *AcmePropertyTypeSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyTypeSequence(s)
	}
}

func (p *acmeParser) AcmePropertyTypeSequence() (localctx IAcmePropertyTypeSequenceContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyTypeSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, acmeParserRULE_acmePropertyTypeSequence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1093)
		p.Match(acmeParserSEQUENCE)
	}
	{
		p.SetState(1094)
		p.Match(acmeParserLANGLE)
	}
	p.SetState(1096)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<acmeParserANY)|(1<<acmeParserDOUBLE)|(1<<acmeParserENUM))) != 0) || _la == acmeParserFLOAT || _la == acmeParserINT || (((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(acmeParserRECORD-74))|(1<<(acmeParserSEQUENCE-74))|(1<<(acmeParserSET-74))|(1<<(acmeParserSTRING-74))|(1<<(acmeParserBOOLEAN-74))|(1<<(acmeParserIDENTIFIER-74)))) != 0) {
		{
			p.SetState(1095)
			p.AcmePropertyTypeRef()
		}

	}
	{
		p.SetState(1098)
		p.Match(acmeParserRANGLE)
	}

	return localctx
}

// IAcmePropertyTypeEnumContext is an interface to support dynamic dispatch.
type IAcmePropertyTypeEnumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyTypeEnumContext differentiates from other interfaces.
	IsAcmePropertyTypeEnumContext()
}

type AcmePropertyTypeEnumContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyTypeEnumContext() *AcmePropertyTypeEnumContext {
	var p = new(AcmePropertyTypeEnumContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyTypeEnum
	return p
}

func (*AcmePropertyTypeEnumContext) IsAcmePropertyTypeEnumContext() {}

func NewAcmePropertyTypeEnumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyTypeEnumContext {
	var p = new(AcmePropertyTypeEnumContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyTypeEnum

	return p
}

func (s *AcmePropertyTypeEnumContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyTypeEnumContext) ENUM() antlr.TerminalNode {
	return s.GetToken(acmeParserENUM, 0)
}

func (s *AcmePropertyTypeEnumContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmePropertyTypeEnumContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmePropertyTypeEnumContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmePropertyTypeEnumContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmePropertyTypeEnumContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmePropertyTypeEnumContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmePropertyTypeEnumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyTypeEnumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyTypeEnumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyTypeEnum(s)
	}
}

func (s *AcmePropertyTypeEnumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyTypeEnum(s)
	}
}

func (p *acmeParser) AcmePropertyTypeEnum() (localctx IAcmePropertyTypeEnumContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyTypeEnumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, acmeParserRULE_acmePropertyTypeEnum)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1100)
		p.Match(acmeParserENUM)
	}
	{
		p.SetState(1101)
		p.Match(acmeParserLBRACE)
	}
	{
		p.SetState(1102)
		p.Identifier()
	}
	p.SetState(1107)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == acmeParserCOMMA {
		{
			p.SetState(1103)
			p.Match(acmeParserCOMMA)
		}
		{
			p.SetState(1104)
			p.Identifier()
		}

		p.SetState(1109)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1110)
		p.Match(acmeParserRBRACE)
	}

	return localctx
}

// IAcmePropertyRecordFieldDescriptionContext is an interface to support dynamic dispatch.
type IAcmePropertyRecordFieldDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyRecordFieldDescriptionContext differentiates from other interfaces.
	IsAcmePropertyRecordFieldDescriptionContext()
}

type AcmePropertyRecordFieldDescriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyRecordFieldDescriptionContext() *AcmePropertyRecordFieldDescriptionContext {
	var p = new(AcmePropertyRecordFieldDescriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyRecordFieldDescription
	return p
}

func (*AcmePropertyRecordFieldDescriptionContext) IsAcmePropertyRecordFieldDescriptionContext() {}

func NewAcmePropertyRecordFieldDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyRecordFieldDescriptionContext {
	var p = new(AcmePropertyRecordFieldDescriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyRecordFieldDescription

	return p
}

func (s *AcmePropertyRecordFieldDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyRecordFieldDescriptionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmePropertyRecordFieldDescriptionContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *AcmePropertyRecordFieldDescriptionContext) AcmePropertyTypeRef() IAcmePropertyTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeRefContext)
}

func (s *AcmePropertyRecordFieldDescriptionContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmePropertyRecordFieldDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyRecordFieldDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyRecordFieldDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyRecordFieldDescription(s)
	}
}

func (s *AcmePropertyRecordFieldDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyRecordFieldDescription(s)
	}
}

func (p *acmeParser) AcmePropertyRecordFieldDescription() (localctx IAcmePropertyRecordFieldDescriptionContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyRecordFieldDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, acmeParserRULE_acmePropertyRecordFieldDescription)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1112)
		p.Identifier()
	}
	{
		p.SetState(1113)
		p.Match(acmeParserCOLON)
	}
	{
		p.SetState(1114)
		p.AcmePropertyTypeRef()
	}
	{
		p.SetState(1115)
		p.Match(acmeParserSEMICOLON)
	}

	return localctx
}

// IAcmePropertyTypeRefContext is an interface to support dynamic dispatch.
type IAcmePropertyTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyTypeRefContext differentiates from other interfaces.
	IsAcmePropertyTypeRefContext()
}

type AcmePropertyTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyTypeRefContext() *AcmePropertyTypeRefContext {
	var p = new(AcmePropertyTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyTypeRef
	return p
}

func (*AcmePropertyTypeRefContext) IsAcmePropertyTypeRefContext() {}

func NewAcmePropertyTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyTypeRefContext {
	var p = new(AcmePropertyTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyTypeRef

	return p
}

func (s *AcmePropertyTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyTypeRefContext) AcmePropertyTypeStructure() IAcmePropertyTypeStructureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeStructureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeStructureContext)
}

func (s *AcmePropertyTypeRefContext) AcmePropertyTypeDeclarationRef() IAcmePropertyTypeDeclarationRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeDeclarationRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeDeclarationRefContext)
}

func (s *AcmePropertyTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyTypeRef(s)
	}
}

func (s *AcmePropertyTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyTypeRef(s)
	}
}

func (p *acmeParser) AcmePropertyTypeRef() (localctx IAcmePropertyTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, acmeParserRULE_acmePropertyTypeRef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1119)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserANY, acmeParserDOUBLE, acmeParserENUM, acmeParserFLOAT, acmeParserINT, acmeParserRECORD, acmeParserSEQUENCE, acmeParserSET, acmeParserSTRING, acmeParserBOOLEAN:
		{
			p.SetState(1117)
			p.AcmePropertyTypeStructure()
		}

	case acmeParserIDENTIFIER:
		{
			p.SetState(1118)
			p.AcmePropertyTypeDeclarationRef()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmePropertyTypeStructureContext is an interface to support dynamic dispatch.
type IAcmePropertyTypeStructureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyTypeStructureContext differentiates from other interfaces.
	IsAcmePropertyTypeStructureContext()
}

type AcmePropertyTypeStructureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyTypeStructureContext() *AcmePropertyTypeStructureContext {
	var p = new(AcmePropertyTypeStructureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyTypeStructure
	return p
}

func (*AcmePropertyTypeStructureContext) IsAcmePropertyTypeStructureContext() {}

func NewAcmePropertyTypeStructureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyTypeStructureContext {
	var p = new(AcmePropertyTypeStructureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyTypeStructure

	return p
}

func (s *AcmePropertyTypeStructureContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyTypeStructureContext) AcmePropertyTypeAny() IAcmePropertyTypeAnyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeAnyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeAnyContext)
}

func (s *AcmePropertyTypeStructureContext) AcmePropertyTypeInt() IAcmePropertyTypeIntContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeIntContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeIntContext)
}

func (s *AcmePropertyTypeStructureContext) AcmePropertyTypeFloat() IAcmePropertyTypeFloatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeFloatContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeFloatContext)
}

func (s *AcmePropertyTypeStructureContext) AcmePropertyTypeDouble() IAcmePropertyTypeDoubleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeDoubleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeDoubleContext)
}

func (s *AcmePropertyTypeStructureContext) AcmePropertyTypeString() IAcmePropertyTypeStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeStringContext)
}

func (s *AcmePropertyTypeStructureContext) AcmePropertyTypeBoolean() IAcmePropertyTypeBooleanContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeBooleanContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeBooleanContext)
}

func (s *AcmePropertyTypeStructureContext) AcmePropertyTypeRecord() IAcmePropertyTypeRecordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeRecordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeRecordContext)
}

func (s *AcmePropertyTypeStructureContext) AcmePropertyTypeSet() IAcmePropertyTypeSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeSetContext)
}

func (s *AcmePropertyTypeStructureContext) AcmePropertyTypeSequence() IAcmePropertyTypeSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeSequenceContext)
}

func (s *AcmePropertyTypeStructureContext) AcmePropertyTypeEnum() IAcmePropertyTypeEnumContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeEnumContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeEnumContext)
}

func (s *AcmePropertyTypeStructureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyTypeStructureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyTypeStructureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyTypeStructure(s)
	}
}

func (s *AcmePropertyTypeStructureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyTypeStructure(s)
	}
}

func (p *acmeParser) AcmePropertyTypeStructure() (localctx IAcmePropertyTypeStructureContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyTypeStructureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, acmeParserRULE_acmePropertyTypeStructure)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1131)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserANY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1121)
			p.AcmePropertyTypeAny()
		}

	case acmeParserINT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1122)
			p.AcmePropertyTypeInt()
		}

	case acmeParserFLOAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1123)
			p.AcmePropertyTypeFloat()
		}

	case acmeParserDOUBLE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1124)
			p.AcmePropertyTypeDouble()
		}

	case acmeParserSTRING:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1125)
			p.AcmePropertyTypeString()
		}

	case acmeParserBOOLEAN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1126)
			p.AcmePropertyTypeBoolean()
		}

	case acmeParserRECORD:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1127)
			p.AcmePropertyTypeRecord()
		}

	case acmeParserSET:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1128)
			p.AcmePropertyTypeSet()
		}

	case acmeParserSEQUENCE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1129)
			p.AcmePropertyTypeSequence()
		}

	case acmeParserENUM:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1130)
			p.AcmePropertyTypeEnum()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmePropertyTypeDeclarationContext is an interface to support dynamic dispatch.
type IAcmePropertyTypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyTypeDeclarationContext differentiates from other interfaces.
	IsAcmePropertyTypeDeclarationContext()
}

type AcmePropertyTypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyTypeDeclarationContext() *AcmePropertyTypeDeclarationContext {
	var p = new(AcmePropertyTypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyTypeDeclaration
	return p
}

func (*AcmePropertyTypeDeclarationContext) IsAcmePropertyTypeDeclarationContext() {}

func NewAcmePropertyTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyTypeDeclarationContext {
	var p = new(AcmePropertyTypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyTypeDeclaration

	return p
}

func (s *AcmePropertyTypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyTypeDeclarationContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(acmeParserPROPERTY, 0)
}

func (s *AcmePropertyTypeDeclarationContext) TYPE() antlr.TerminalNode {
	return s.GetToken(acmeParserTYPE, 0)
}

func (s *AcmePropertyTypeDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmePropertyTypeDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmePropertyTypeDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmePropertyTypeDeclarationContext) AcmePropertyTypeInt() IAcmePropertyTypeIntContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeIntContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeIntContext)
}

func (s *AcmePropertyTypeDeclarationContext) AcmePropertyTypeFloat() IAcmePropertyTypeFloatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeFloatContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeFloatContext)
}

func (s *AcmePropertyTypeDeclarationContext) AcmePropertyTypeDouble() IAcmePropertyTypeDoubleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeDoubleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeDoubleContext)
}

func (s *AcmePropertyTypeDeclarationContext) AcmePropertyTypeString() IAcmePropertyTypeStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeStringContext)
}

func (s *AcmePropertyTypeDeclarationContext) AcmePropertyTypeBoolean() IAcmePropertyTypeBooleanContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeBooleanContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeBooleanContext)
}

func (s *AcmePropertyTypeDeclarationContext) AcmePropertyTypeRecord() IAcmePropertyTypeRecordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeRecordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeRecordContext)
}

func (s *AcmePropertyTypeDeclarationContext) AcmePropertyTypeSet() IAcmePropertyTypeSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeSetContext)
}

func (s *AcmePropertyTypeDeclarationContext) AcmePropertyTypeSequence() IAcmePropertyTypeSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeSequenceContext)
}

func (s *AcmePropertyTypeDeclarationContext) AcmePropertyTypeEnum() IAcmePropertyTypeEnumContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeEnumContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeEnumContext)
}

func (s *AcmePropertyTypeDeclarationContext) AcmePropertyTypeAny() IAcmePropertyTypeAnyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeAnyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeAnyContext)
}

func (s *AcmePropertyTypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyTypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyTypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyTypeDeclaration(s)
	}
}

func (s *AcmePropertyTypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyTypeDeclaration(s)
	}
}

func (p *acmeParser) AcmePropertyTypeDeclaration() (localctx IAcmePropertyTypeDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, acmeParserRULE_acmePropertyTypeDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1133)
		p.Match(acmeParserPROPERTY)
	}
	{
		p.SetState(1134)
		p.Match(acmeParserTYPE)
	}
	{
		p.SetState(1135)
		p.Identifier()
	}
	p.SetState(1152)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(1136)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN:
		{
			p.SetState(1137)
			p.Match(acmeParserASSIGN)
		}
		p.SetState(1148)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserINT:
			{
				p.SetState(1138)
				p.AcmePropertyTypeInt()
			}

		case acmeParserFLOAT:
			{
				p.SetState(1139)
				p.AcmePropertyTypeFloat()
			}

		case acmeParserDOUBLE:
			{
				p.SetState(1140)
				p.AcmePropertyTypeDouble()
			}

		case acmeParserSTRING:
			{
				p.SetState(1141)
				p.AcmePropertyTypeString()
			}

		case acmeParserBOOLEAN:
			{
				p.SetState(1142)
				p.AcmePropertyTypeBoolean()
			}

		case acmeParserRECORD:
			{
				p.SetState(1143)
				p.AcmePropertyTypeRecord()
			}

		case acmeParserSET:
			{
				p.SetState(1144)
				p.AcmePropertyTypeSet()
			}

		case acmeParserSEQUENCE:
			{
				p.SetState(1145)
				p.AcmePropertyTypeSequence()
			}

		case acmeParserENUM:
			{
				p.SetState(1146)
				p.AcmePropertyTypeEnum()
			}

		case acmeParserANY:
			{
				p.SetState(1147)
				p.AcmePropertyTypeAny()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1150)
			p.Match(acmeParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmePropertyBlockEntryContext is an interface to support dynamic dispatch.
type IAcmePropertyBlockEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyBlockEntryContext differentiates from other interfaces.
	IsAcmePropertyBlockEntryContext()
}

type AcmePropertyBlockEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyBlockEntryContext() *AcmePropertyBlockEntryContext {
	var p = new(AcmePropertyBlockEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyBlockEntry
	return p
}

func (*AcmePropertyBlockEntryContext) IsAcmePropertyBlockEntryContext() {}

func NewAcmePropertyBlockEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyBlockEntryContext {
	var p = new(AcmePropertyBlockEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyBlockEntry

	return p
}

func (s *AcmePropertyBlockEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyBlockEntryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmePropertyBlockEntryContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmePropertyBlockEntryContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *AcmePropertyBlockEntryContext) AcmePropertyTypeRef() IAcmePropertyTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeRefContext)
}

func (s *AcmePropertyBlockEntryContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmePropertyBlockEntryContext) AcmePropertyValueDeclaration() IAcmePropertyValueDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyValueDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyValueDeclarationContext)
}

func (s *AcmePropertyBlockEntryContext) CONTAINASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserCONTAINASSIGN, 0)
}

func (s *AcmePropertyBlockEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyBlockEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyBlockEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyBlockEntry(s)
	}
}

func (s *AcmePropertyBlockEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyBlockEntry(s)
	}
}

func (p *acmeParser) AcmePropertyBlockEntry() (localctx IAcmePropertyBlockEntryContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyBlockEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, acmeParserRULE_acmePropertyBlockEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1154)
		p.Identifier()
	}
	p.SetState(1157)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserCOLON {
		{
			p.SetState(1155)
			p.Match(acmeParserCOLON)
		}
		{
			p.SetState(1156)
			p.AcmePropertyTypeRef()
		}

	}
	p.SetState(1163)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserASSIGN:
		{
			p.SetState(1159)
			p.Match(acmeParserASSIGN)
		}
		{
			p.SetState(1160)
			p.AcmePropertyValueDeclaration()
		}

	case acmeParserCONTAINASSIGN:
		{
			p.SetState(1161)
			p.Match(acmeParserCONTAINASSIGN)
		}
		{
			p.SetState(1162)
			p.AcmePropertyValueDeclaration()
		}

	case acmeParserSEMICOLON:

	default:
	}
	{
		p.SetState(1165)
		p.Match(acmeParserSEMICOLON)
	}

	return localctx
}

// IAcmePropertyBlockContext is an interface to support dynamic dispatch.
type IAcmePropertyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyBlockContext differentiates from other interfaces.
	IsAcmePropertyBlockContext()
}

type AcmePropertyBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyBlockContext() *AcmePropertyBlockContext {
	var p = new(AcmePropertyBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyBlock
	return p
}

func (*AcmePropertyBlockContext) IsAcmePropertyBlockContext() {}

func NewAcmePropertyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyBlockContext {
	var p = new(AcmePropertyBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyBlock

	return p
}

func (s *AcmePropertyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyBlockContext) PROPBEGIN() antlr.TerminalNode {
	return s.GetToken(acmeParserPROPBEGIN, 0)
}

func (s *AcmePropertyBlockContext) PROPEND() antlr.TerminalNode {
	return s.GetToken(acmeParserPROPEND, 0)
}

func (s *AcmePropertyBlockContext) AllAcmePropertyBlockEntry() []IAcmePropertyBlockEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAcmePropertyBlockEntryContext)(nil)).Elem())
	var tst = make([]IAcmePropertyBlockEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAcmePropertyBlockEntryContext)
		}
	}

	return tst
}

func (s *AcmePropertyBlockContext) AcmePropertyBlockEntry(i int) IAcmePropertyBlockEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyBlockEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyBlockEntryContext)
}

func (s *AcmePropertyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyBlock(s)
	}
}

func (s *AcmePropertyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyBlock(s)
	}
}

func (p *acmeParser) AcmePropertyBlock() (localctx IAcmePropertyBlockContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, acmeParserRULE_acmePropertyBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1167)
		p.Match(acmeParserPROPBEGIN)
	}
	p.SetState(1169)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == acmeParserIDENTIFIER {
		{
			p.SetState(1168)
			p.AcmePropertyBlockEntry()
		}

		p.SetState(1171)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1173)
		p.Match(acmeParserPROPEND)
	}

	return localctx
}

// IAcmePropertyTypeIntContext is an interface to support dynamic dispatch.
type IAcmePropertyTypeIntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyTypeIntContext differentiates from other interfaces.
	IsAcmePropertyTypeIntContext()
}

type AcmePropertyTypeIntContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyTypeIntContext() *AcmePropertyTypeIntContext {
	var p = new(AcmePropertyTypeIntContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyTypeInt
	return p
}

func (*AcmePropertyTypeIntContext) IsAcmePropertyTypeIntContext() {}

func NewAcmePropertyTypeIntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyTypeIntContext {
	var p = new(AcmePropertyTypeIntContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyTypeInt

	return p
}

func (s *AcmePropertyTypeIntContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyTypeIntContext) INT() antlr.TerminalNode {
	return s.GetToken(acmeParserINT, 0)
}

func (s *AcmePropertyTypeIntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyTypeIntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyTypeIntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyTypeInt(s)
	}
}

func (s *AcmePropertyTypeIntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyTypeInt(s)
	}
}

func (p *acmeParser) AcmePropertyTypeInt() (localctx IAcmePropertyTypeIntContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyTypeIntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, acmeParserRULE_acmePropertyTypeInt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1175)
		p.Match(acmeParserINT)
	}

	return localctx
}

// IAcmePropertyTypeAnyContext is an interface to support dynamic dispatch.
type IAcmePropertyTypeAnyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyTypeAnyContext differentiates from other interfaces.
	IsAcmePropertyTypeAnyContext()
}

type AcmePropertyTypeAnyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyTypeAnyContext() *AcmePropertyTypeAnyContext {
	var p = new(AcmePropertyTypeAnyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyTypeAny
	return p
}

func (*AcmePropertyTypeAnyContext) IsAcmePropertyTypeAnyContext() {}

func NewAcmePropertyTypeAnyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyTypeAnyContext {
	var p = new(AcmePropertyTypeAnyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyTypeAny

	return p
}

func (s *AcmePropertyTypeAnyContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyTypeAnyContext) ANY() antlr.TerminalNode {
	return s.GetToken(acmeParserANY, 0)
}

func (s *AcmePropertyTypeAnyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyTypeAnyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyTypeAnyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyTypeAny(s)
	}
}

func (s *AcmePropertyTypeAnyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyTypeAny(s)
	}
}

func (p *acmeParser) AcmePropertyTypeAny() (localctx IAcmePropertyTypeAnyContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyTypeAnyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, acmeParserRULE_acmePropertyTypeAny)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1177)
		p.Match(acmeParserANY)
	}

	return localctx
}

// IAcmePropertyTypeFloatContext is an interface to support dynamic dispatch.
type IAcmePropertyTypeFloatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyTypeFloatContext differentiates from other interfaces.
	IsAcmePropertyTypeFloatContext()
}

type AcmePropertyTypeFloatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyTypeFloatContext() *AcmePropertyTypeFloatContext {
	var p = new(AcmePropertyTypeFloatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyTypeFloat
	return p
}

func (*AcmePropertyTypeFloatContext) IsAcmePropertyTypeFloatContext() {}

func NewAcmePropertyTypeFloatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyTypeFloatContext {
	var p = new(AcmePropertyTypeFloatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyTypeFloat

	return p
}

func (s *AcmePropertyTypeFloatContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyTypeFloatContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(acmeParserFLOAT, 0)
}

func (s *AcmePropertyTypeFloatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyTypeFloatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyTypeFloatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyTypeFloat(s)
	}
}

func (s *AcmePropertyTypeFloatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyTypeFloat(s)
	}
}

func (p *acmeParser) AcmePropertyTypeFloat() (localctx IAcmePropertyTypeFloatContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyTypeFloatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, acmeParserRULE_acmePropertyTypeFloat)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1179)
		p.Match(acmeParserFLOAT)
	}

	return localctx
}

// IAcmePropertyTypeDoubleContext is an interface to support dynamic dispatch.
type IAcmePropertyTypeDoubleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyTypeDoubleContext differentiates from other interfaces.
	IsAcmePropertyTypeDoubleContext()
}

type AcmePropertyTypeDoubleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyTypeDoubleContext() *AcmePropertyTypeDoubleContext {
	var p = new(AcmePropertyTypeDoubleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyTypeDouble
	return p
}

func (*AcmePropertyTypeDoubleContext) IsAcmePropertyTypeDoubleContext() {}

func NewAcmePropertyTypeDoubleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyTypeDoubleContext {
	var p = new(AcmePropertyTypeDoubleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyTypeDouble

	return p
}

func (s *AcmePropertyTypeDoubleContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyTypeDoubleContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(acmeParserDOUBLE, 0)
}

func (s *AcmePropertyTypeDoubleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyTypeDoubleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyTypeDoubleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyTypeDouble(s)
	}
}

func (s *AcmePropertyTypeDoubleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyTypeDouble(s)
	}
}

func (p *acmeParser) AcmePropertyTypeDouble() (localctx IAcmePropertyTypeDoubleContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyTypeDoubleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, acmeParserRULE_acmePropertyTypeDouble)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1181)
		p.Match(acmeParserDOUBLE)
	}

	return localctx
}

// IAcmePropertyTypeStringContext is an interface to support dynamic dispatch.
type IAcmePropertyTypeStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyTypeStringContext differentiates from other interfaces.
	IsAcmePropertyTypeStringContext()
}

type AcmePropertyTypeStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyTypeStringContext() *AcmePropertyTypeStringContext {
	var p = new(AcmePropertyTypeStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyTypeString
	return p
}

func (*AcmePropertyTypeStringContext) IsAcmePropertyTypeStringContext() {}

func NewAcmePropertyTypeStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyTypeStringContext {
	var p = new(AcmePropertyTypeStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyTypeString

	return p
}

func (s *AcmePropertyTypeStringContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyTypeStringContext) STRING() antlr.TerminalNode {
	return s.GetToken(acmeParserSTRING, 0)
}

func (s *AcmePropertyTypeStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyTypeStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyTypeStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyTypeString(s)
	}
}

func (s *AcmePropertyTypeStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyTypeString(s)
	}
}

func (p *acmeParser) AcmePropertyTypeString() (localctx IAcmePropertyTypeStringContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyTypeStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, acmeParserRULE_acmePropertyTypeString)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1183)
		p.Match(acmeParserSTRING)
	}

	return localctx
}

// IAcmePropertyTypeBooleanContext is an interface to support dynamic dispatch.
type IAcmePropertyTypeBooleanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmePropertyTypeBooleanContext differentiates from other interfaces.
	IsAcmePropertyTypeBooleanContext()
}

type AcmePropertyTypeBooleanContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmePropertyTypeBooleanContext() *AcmePropertyTypeBooleanContext {
	var p = new(AcmePropertyTypeBooleanContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmePropertyTypeBoolean
	return p
}

func (*AcmePropertyTypeBooleanContext) IsAcmePropertyTypeBooleanContext() {}

func NewAcmePropertyTypeBooleanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmePropertyTypeBooleanContext {
	var p = new(AcmePropertyTypeBooleanContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmePropertyTypeBoolean

	return p
}

func (s *AcmePropertyTypeBooleanContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmePropertyTypeBooleanContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(acmeParserBOOLEAN, 0)
}

func (s *AcmePropertyTypeBooleanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmePropertyTypeBooleanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmePropertyTypeBooleanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmePropertyTypeBoolean(s)
	}
}

func (s *AcmePropertyTypeBooleanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmePropertyTypeBoolean(s)
	}
}

func (p *acmeParser) AcmePropertyTypeBoolean() (localctx IAcmePropertyTypeBooleanContext) {
	this := p
	_ = this

	localctx = NewAcmePropertyTypeBooleanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, acmeParserRULE_acmePropertyTypeBoolean)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1185)
		p.Match(acmeParserBOOLEAN)
	}

	return localctx
}

// IAcmeViewDeclarationContext is an interface to support dynamic dispatch.
type IAcmeViewDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeViewDeclarationContext differentiates from other interfaces.
	IsAcmeViewDeclarationContext()
}

type AcmeViewDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeViewDeclarationContext() *AcmeViewDeclarationContext {
	var p = new(AcmeViewDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeViewDeclaration
	return p
}

func (*AcmeViewDeclarationContext) IsAcmeViewDeclarationContext() {}

func NewAcmeViewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeViewDeclarationContext {
	var p = new(AcmeViewDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeViewDeclaration

	return p
}

func (s *AcmeViewDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeViewDeclarationContext) VIEW() antlr.TerminalNode {
	return s.GetToken(acmeParserVIEW, 0)
}

func (s *AcmeViewDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeViewDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *AcmeViewDeclarationContext) AcmeViewTypeRef() IAcmeViewTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeViewTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeViewTypeRefContext)
}

func (s *AcmeViewDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeViewDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeViewDeclarationContext) AcmeViewBody() IAcmeViewBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeViewBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeViewBodyContext)
}

func (s *AcmeViewDeclarationContext) NEW() antlr.TerminalNode {
	return s.GetToken(acmeParserNEW, 0)
}

func (s *AcmeViewDeclarationContext) AcmeViewInstantiatedTypeRef() IAcmeViewInstantiatedTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeViewInstantiatedTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeViewInstantiatedTypeRefContext)
}

func (s *AcmeViewDeclarationContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDED, 0)
}

func (s *AcmeViewDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmeViewDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeViewDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeViewDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeViewDeclaration(s)
	}
}

func (s *AcmeViewDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeViewDeclaration(s)
	}
}

func (p *acmeParser) AcmeViewDeclaration() (localctx IAcmeViewDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeViewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, acmeParserRULE_acmeViewDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1187)
		p.Match(acmeParserVIEW)
	}
	{
		p.SetState(1188)
		p.Identifier()
	}
	p.SetState(1191)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserCOLON {
		{
			p.SetState(1189)
			p.Match(acmeParserCOLON)
		}
		{
			p.SetState(1190)
			p.AcmeViewTypeRef()
		}

	}
	p.SetState(1212)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(1193)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN:
		{
			p.SetState(1194)
			p.Match(acmeParserASSIGN)
		}
		p.SetState(1210)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserLBRACE:
			{
				p.SetState(1195)
				p.AcmeViewBody()
			}
			p.SetState(1197)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == acmeParserSEMICOLON {
				{
					p.SetState(1196)
					p.Match(acmeParserSEMICOLON)
				}

			}

		case acmeParserNEW:
			{
				p.SetState(1199)
				p.Match(acmeParserNEW)
			}
			{
				p.SetState(1200)
				p.AcmeViewInstantiatedTypeRef()
			}
			p.SetState(1208)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSEMICOLON:
				{
					p.SetState(1201)
					p.Match(acmeParserSEMICOLON)
				}

			case acmeParserEXTENDED:
				{
					p.SetState(1202)
					p.Match(acmeParserEXTENDED)
				}
				{
					p.SetState(1203)
					p.Match(acmeParserWITH)
				}
				{
					p.SetState(1204)
					p.AcmeViewBody()
				}
				p.SetState(1206)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == acmeParserSEMICOLON {
					{
						p.SetState(1205)
						p.Match(acmeParserSEMICOLON)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmeViewTypeDeclarationContext is an interface to support dynamic dispatch.
type IAcmeViewTypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeViewTypeDeclarationContext differentiates from other interfaces.
	IsAcmeViewTypeDeclarationContext()
}

type AcmeViewTypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeViewTypeDeclarationContext() *AcmeViewTypeDeclarationContext {
	var p = new(AcmeViewTypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeViewTypeDeclaration
	return p
}

func (*AcmeViewTypeDeclarationContext) IsAcmeViewTypeDeclarationContext() {}

func NewAcmeViewTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeViewTypeDeclarationContext {
	var p = new(AcmeViewTypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeViewTypeDeclaration

	return p
}

func (s *AcmeViewTypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeViewTypeDeclarationContext) VIEW() antlr.TerminalNode {
	return s.GetToken(acmeParserVIEW, 0)
}

func (s *AcmeViewTypeDeclarationContext) TYPE() antlr.TerminalNode {
	return s.GetToken(acmeParserTYPE, 0)
}

func (s *AcmeViewTypeDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeViewTypeDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeViewTypeDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeViewTypeDeclarationContext) AcmeViewBody() IAcmeViewBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeViewBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeViewBodyContext)
}

func (s *AcmeViewTypeDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTENDS, 0)
}

func (s *AcmeViewTypeDeclarationContext) AcmeViewTypeRef() IAcmeViewTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeViewTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeViewTypeRefContext)
}

func (s *AcmeViewTypeDeclarationContext) WITH() antlr.TerminalNode {
	return s.GetToken(acmeParserWITH, 0)
}

func (s *AcmeViewTypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeViewTypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeViewTypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeViewTypeDeclaration(s)
	}
}

func (s *AcmeViewTypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeViewTypeDeclaration(s)
	}
}

func (p *acmeParser) AcmeViewTypeDeclaration() (localctx IAcmeViewTypeDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeViewTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, acmeParserRULE_acmeViewTypeDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1214)
		p.Match(acmeParserVIEW)
	}
	{
		p.SetState(1215)
		p.Match(acmeParserTYPE)
	}
	{
		p.SetState(1216)
		p.Identifier()
	}
	p.SetState(1235)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSEMICOLON:
		{
			p.SetState(1217)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserASSIGN, acmeParserEXTENDS:
		p.SetState(1233)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserASSIGN:
			{
				p.SetState(1218)
				p.Match(acmeParserASSIGN)
			}
			{
				p.SetState(1219)
				p.AcmeViewBody()
			}
			p.SetState(1221)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == acmeParserSEMICOLON {
				{
					p.SetState(1220)
					p.Match(acmeParserSEMICOLON)
				}

			}

		case acmeParserEXTENDS:
			{
				p.SetState(1223)
				p.Match(acmeParserEXTENDS)
			}
			{
				p.SetState(1224)
				p.AcmeViewTypeRef()
			}
			p.SetState(1231)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSEMICOLON:
				{
					p.SetState(1225)
					p.Match(acmeParserSEMICOLON)
				}

			case acmeParserWITH:
				{
					p.SetState(1226)
					p.Match(acmeParserWITH)
				}
				{
					p.SetState(1227)
					p.AcmeViewBody()
				}
				p.SetState(1229)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == acmeParserSEMICOLON {
					{
						p.SetState(1228)
						p.Match(acmeParserSEMICOLON)
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcmeViewBodyContext is an interface to support dynamic dispatch.
type IAcmeViewBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeViewBodyContext differentiates from other interfaces.
	IsAcmeViewBodyContext()
}

type AcmeViewBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeViewBodyContext() *AcmeViewBodyContext {
	var p = new(AcmeViewBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeViewBody
	return p
}

func (*AcmeViewBodyContext) IsAcmeViewBodyContext() {}

func NewAcmeViewBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeViewBodyContext {
	var p = new(AcmeViewBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeViewBody

	return p
}

func (s *AcmeViewBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeViewBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *AcmeViewBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *AcmeViewBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeViewBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeViewBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeViewBody(s)
	}
}

func (s *AcmeViewBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeViewBody(s)
	}
}

func (p *acmeParser) AcmeViewBody() (localctx IAcmeViewBodyContext) {
	this := p
	_ = this

	localctx = NewAcmeViewBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, acmeParserRULE_acmeViewBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1237)
		p.Match(acmeParserLBRACE)
	}
	{
		p.SetState(1238)
		p.Match(acmeParserRBRACE)
	}

	return localctx
}

// IDesignRuleContext is an interface to support dynamic dispatch.
type IDesignRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesignRuleContext differentiates from other interfaces.
	IsDesignRuleContext()
}

type DesignRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesignRuleContext() *DesignRuleContext {
	var p = new(DesignRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_designRule
	return p
}

func (*DesignRuleContext) IsDesignRuleContext() {}

func NewDesignRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DesignRuleContext {
	var p = new(DesignRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_designRule

	return p
}

func (s *DesignRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *DesignRuleContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *DesignRuleContext) DESIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserDESIGN, 0)
}

func (s *DesignRuleContext) RULE() antlr.TerminalNode {
	return s.GetToken(acmeParserRULE, 0)
}

func (s *DesignRuleContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(acmeParserIDENTIFIER, 0)
}

func (s *DesignRuleContext) AcmePropertyBlock() IAcmePropertyBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyBlockContext)
}

func (s *DesignRuleContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *DesignRuleContext) INVARIANT() antlr.TerminalNode {
	return s.GetToken(acmeParserINVARIANT, 0)
}

func (s *DesignRuleContext) DesignRuleExpression() IDesignRuleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleExpressionContext)
}

func (s *DesignRuleContext) HEURISTIC() antlr.TerminalNode {
	return s.GetToken(acmeParserHEURISTIC, 0)
}

func (s *DesignRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DesignRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DesignRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterDesignRule(s)
	}
}

func (s *DesignRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitDesignRule(s)
	}
}

func (p *acmeParser) DesignRule() (localctx IDesignRuleContext) {
	this := p
	_ = this

	localctx = NewDesignRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, acmeParserRULE_designRule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1241)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserDESIGN {
		{
			p.SetState(1240)
			p.Match(acmeParserDESIGN)
		}

	}
	p.SetState(1248)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserRULE {
		{
			p.SetState(1243)
			p.Match(acmeParserRULE)
		}
		{
			p.SetState(1244)
			p.Match(acmeParserIDENTIFIER)
		}
		p.SetState(1246)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserASSIGN {
			{
				p.SetState(1245)
				p.Match(acmeParserASSIGN)
			}

		}

	}
	p.SetState(1256)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserHEURISTIC || _la == acmeParserINVARIANT {
		p.SetState(1254)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserINVARIANT:
			{
				p.SetState(1250)
				p.Match(acmeParserINVARIANT)
			}
			{
				p.SetState(1251)
				p.DesignRuleExpression()
			}

		case acmeParserHEURISTIC:
			{
				p.SetState(1252)
				p.Match(acmeParserHEURISTIC)
			}
			{
				p.SetState(1253)
				p.DesignRuleExpression()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}
	p.SetState(1259)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserPROPBEGIN {
		{
			p.SetState(1258)
			p.AcmePropertyBlock()
		}

	}
	{
		p.SetState(1261)
		p.Match(acmeParserSEMICOLON)
	}

	return localctx
}

// IAcmeDesignAnalysisDeclarationContext is an interface to support dynamic dispatch.
type IAcmeDesignAnalysisDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeDesignAnalysisDeclarationContext differentiates from other interfaces.
	IsAcmeDesignAnalysisDeclarationContext()
}

type AcmeDesignAnalysisDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeDesignAnalysisDeclarationContext() *AcmeDesignAnalysisDeclarationContext {
	var p = new(AcmeDesignAnalysisDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeDesignAnalysisDeclaration
	return p
}

func (*AcmeDesignAnalysisDeclarationContext) IsAcmeDesignAnalysisDeclarationContext() {}

func NewAcmeDesignAnalysisDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeDesignAnalysisDeclarationContext {
	var p = new(AcmeDesignAnalysisDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeDesignAnalysisDeclaration

	return p
}

func (s *AcmeDesignAnalysisDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeDesignAnalysisDeclarationContext) ANALYSIS() antlr.TerminalNode {
	return s.GetToken(acmeParserANALYSIS, 0)
}

func (s *AcmeDesignAnalysisDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(acmeParserIDENTIFIER, 0)
}

func (s *AcmeDesignAnalysisDeclarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(acmeParserLPAREN, 0)
}

func (s *AcmeDesignAnalysisDeclarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(acmeParserRPAREN, 0)
}

func (s *AcmeDesignAnalysisDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *AcmeDesignAnalysisDeclarationContext) AcmeTypeRef() IAcmeTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeTypeRefContext)
}

func (s *AcmeDesignAnalysisDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *AcmeDesignAnalysisDeclarationContext) DesignRuleExpression() IDesignRuleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleExpressionContext)
}

func (s *AcmeDesignAnalysisDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *AcmeDesignAnalysisDeclarationContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(acmeParserEXTERNAL, 0)
}

func (s *AcmeDesignAnalysisDeclarationContext) CodeLiteral() ICodeLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeLiteralContext)
}

func (s *AcmeDesignAnalysisDeclarationContext) DESIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserDESIGN, 0)
}

func (s *AcmeDesignAnalysisDeclarationContext) AllFormalParam() []IFormalParamContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFormalParamContext)(nil)).Elem())
	var tst = make([]IFormalParamContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFormalParamContext)
		}
	}

	return tst
}

func (s *AcmeDesignAnalysisDeclarationContext) FormalParam(i int) IFormalParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParamContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFormalParamContext)
}

func (s *AcmeDesignAnalysisDeclarationContext) AcmePropertyBlock() IAcmePropertyBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyBlockContext)
}

func (s *AcmeDesignAnalysisDeclarationContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *AcmeDesignAnalysisDeclarationContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcmeDesignAnalysisDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *AcmeDesignAnalysisDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *AcmeDesignAnalysisDeclarationContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(acmeParserDOT)
}

func (s *AcmeDesignAnalysisDeclarationContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, i)
}

func (s *AcmeDesignAnalysisDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeDesignAnalysisDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeDesignAnalysisDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeDesignAnalysisDeclaration(s)
	}
}

func (s *AcmeDesignAnalysisDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeDesignAnalysisDeclaration(s)
	}
}

func (p *acmeParser) AcmeDesignAnalysisDeclaration() (localctx IAcmeDesignAnalysisDeclarationContext) {
	this := p
	_ = this

	localctx = NewAcmeDesignAnalysisDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, acmeParserRULE_acmeDesignAnalysisDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1323)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserANALYSIS, acmeParserDESIGN:
		p.SetState(1264)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserDESIGN {
			{
				p.SetState(1263)
				p.Match(acmeParserDESIGN)
			}

		}
		{
			p.SetState(1266)
			p.Match(acmeParserANALYSIS)
		}
		{
			p.SetState(1267)
			p.Match(acmeParserIDENTIFIER)
		}
		{
			p.SetState(1268)
			p.Match(acmeParserLPAREN)
		}
		p.SetState(1277)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserIDENTIFIER {
			{
				p.SetState(1269)
				p.FormalParam()
			}
			p.SetState(1274)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserCOMMA {
				{
					p.SetState(1270)
					p.Match(acmeParserCOMMA)
				}
				{
					p.SetState(1271)
					p.FormalParam()
				}

				p.SetState(1276)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1279)
			p.Match(acmeParserRPAREN)
		}
		{
			p.SetState(1280)
			p.Match(acmeParserCOLON)
		}
		{
			p.SetState(1281)
			p.AcmeTypeRef()
		}
		{
			p.SetState(1282)
			p.Match(acmeParserASSIGN)
		}
		{
			p.SetState(1283)
			p.DesignRuleExpression()
		}
		p.SetState(1285)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserPROPBEGIN {
			{
				p.SetState(1284)
				p.AcmePropertyBlock()
			}

		}
		{
			p.SetState(1287)
			p.Match(acmeParserSEMICOLON)
		}

	case acmeParserEXTERNAL:
		{
			p.SetState(1289)
			p.Match(acmeParserEXTERNAL)
		}
		p.SetState(1291)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserDESIGN {
			{
				p.SetState(1290)
				p.Match(acmeParserDESIGN)
			}

		}
		{
			p.SetState(1293)
			p.Match(acmeParserANALYSIS)
		}
		{
			p.SetState(1294)
			p.Match(acmeParserIDENTIFIER)
		}
		{
			p.SetState(1295)
			p.Match(acmeParserLPAREN)
		}
		p.SetState(1304)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserIDENTIFIER {
			{
				p.SetState(1296)
				p.FormalParam()
			}
			p.SetState(1301)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserCOMMA {
				{
					p.SetState(1297)
					p.Match(acmeParserCOMMA)
				}
				{
					p.SetState(1298)
					p.FormalParam()
				}

				p.SetState(1303)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1306)
			p.Match(acmeParserRPAREN)
		}
		{
			p.SetState(1307)
			p.Match(acmeParserCOLON)
		}
		{
			p.SetState(1308)
			p.AcmeTypeRef()
		}
		{
			p.SetState(1309)
			p.Match(acmeParserASSIGN)
		}
		p.SetState(1319)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserSTRING_LITERAL:
			{
				p.SetState(1310)
				p.CodeLiteral()
			}

		case acmeParserIDENTIFIER:
			{
				p.SetState(1311)
				p.Identifier()
			}
			p.SetState(1316)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == acmeParserDOT {
				{
					p.SetState(1312)
					p.Match(acmeParserDOT)
				}
				{
					p.SetState(1313)
					p.Identifier()
				}

				p.SetState(1318)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1321)
			p.Match(acmeParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFormalParamContext is an interface to support dynamic dispatch.
type IFormalParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParamContext differentiates from other interfaces.
	IsFormalParamContext()
}

type FormalParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParamContext() *FormalParamContext {
	var p = new(FormalParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_formalParam
	return p
}

func (*FormalParamContext) IsFormalParamContext() {}

func NewFormalParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParamContext {
	var p = new(FormalParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_formalParam

	return p
}

func (s *FormalParamContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParamContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FormalParamContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *FormalParamContext) AcmeTypeRef() IAcmeTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeTypeRefContext)
}

func (s *FormalParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterFormalParam(s)
	}
}

func (s *FormalParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitFormalParam(s)
	}
}

func (p *acmeParser) FormalParam() (localctx IFormalParamContext) {
	this := p
	_ = this

	localctx = NewFormalParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, acmeParserRULE_formalParam)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1325)
		p.Identifier()
	}
	{
		p.SetState(1326)
		p.Match(acmeParserCOLON)
	}
	{
		p.SetState(1327)
		p.AcmeTypeRef()
	}

	return localctx
}

// ITerminatedDesignRuleExpressionContext is an interface to support dynamic dispatch.
type ITerminatedDesignRuleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTerminatedDesignRuleExpressionContext differentiates from other interfaces.
	IsTerminatedDesignRuleExpressionContext()
}

type TerminatedDesignRuleExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminatedDesignRuleExpressionContext() *TerminatedDesignRuleExpressionContext {
	var p = new(TerminatedDesignRuleExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_terminatedDesignRuleExpression
	return p
}

func (*TerminatedDesignRuleExpressionContext) IsTerminatedDesignRuleExpressionContext() {}

func NewTerminatedDesignRuleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TerminatedDesignRuleExpressionContext {
	var p = new(TerminatedDesignRuleExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_terminatedDesignRuleExpression

	return p
}

func (s *TerminatedDesignRuleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TerminatedDesignRuleExpressionContext) DesignRuleExpression() IDesignRuleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleExpressionContext)
}

func (s *TerminatedDesignRuleExpressionContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, 0)
}

func (s *TerminatedDesignRuleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TerminatedDesignRuleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TerminatedDesignRuleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterTerminatedDesignRuleExpression(s)
	}
}

func (s *TerminatedDesignRuleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitTerminatedDesignRuleExpression(s)
	}
}

func (p *acmeParser) TerminatedDesignRuleExpression() (localctx ITerminatedDesignRuleExpressionContext) {
	this := p
	_ = this

	localctx = NewTerminatedDesignRuleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, acmeParserRULE_terminatedDesignRuleExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1329)
		p.DesignRuleExpression()
	}
	{
		p.SetState(1330)
		p.Match(acmeParserSEMICOLON)
	}

	return localctx
}

// IDesignRuleExpressionContext is an interface to support dynamic dispatch.
type IDesignRuleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesignRuleExpressionContext differentiates from other interfaces.
	IsDesignRuleExpressionContext()
}

type DesignRuleExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesignRuleExpressionContext() *DesignRuleExpressionContext {
	var p = new(DesignRuleExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_designRuleExpression
	return p
}

func (*DesignRuleExpressionContext) IsDesignRuleExpressionContext() {}

func NewDesignRuleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DesignRuleExpressionContext {
	var p = new(DesignRuleExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_designRuleExpression

	return p
}

func (s *DesignRuleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DesignRuleExpressionContext) AllASTDRImpliesExpression() []IASTDRImpliesExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IASTDRImpliesExpressionContext)(nil)).Elem())
	var tst = make([]IASTDRImpliesExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IASTDRImpliesExpressionContext)
		}
	}

	return tst
}

func (s *DesignRuleExpressionContext) ASTDRImpliesExpression(i int) IASTDRImpliesExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IASTDRImpliesExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IASTDRImpliesExpressionContext)
}

func (s *DesignRuleExpressionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(acmeParserOR)
}

func (s *DesignRuleExpressionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserOR, i)
}

func (s *DesignRuleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DesignRuleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DesignRuleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterDesignRuleExpression(s)
	}
}

func (s *DesignRuleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitDesignRuleExpression(s)
	}
}

func (p *acmeParser) DesignRuleExpression() (localctx IDesignRuleExpressionContext) {
	this := p
	_ = this

	localctx = NewDesignRuleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, acmeParserRULE_designRuleExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1332)
		p.ASTDRImpliesExpression()
	}
	p.SetState(1337)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 195, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1333)
				p.Match(acmeParserOR)
			}
			{
				p.SetState(1334)
				p.ASTDRImpliesExpression()
			}

		}
		p.SetState(1339)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 195, p.GetParserRuleContext())
	}

	return localctx
}

// IASTDRImpliesExpressionContext is an interface to support dynamic dispatch.
type IASTDRImpliesExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsASTDRImpliesExpressionContext differentiates from other interfaces.
	IsASTDRImpliesExpressionContext()
}

type ASTDRImpliesExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyASTDRImpliesExpressionContext() *ASTDRImpliesExpressionContext {
	var p = new(ASTDRImpliesExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_aSTDRImpliesExpression
	return p
}

func (*ASTDRImpliesExpressionContext) IsASTDRImpliesExpressionContext() {}

func NewASTDRImpliesExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ASTDRImpliesExpressionContext {
	var p = new(ASTDRImpliesExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_aSTDRImpliesExpression

	return p
}

func (s *ASTDRImpliesExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ASTDRImpliesExpressionContext) AllDRIffExpression() []IDRIffExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDRIffExpressionContext)(nil)).Elem())
	var tst = make([]IDRIffExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDRIffExpressionContext)
		}
	}

	return tst
}

func (s *ASTDRImpliesExpressionContext) DRIffExpression(i int) IDRIffExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDRIffExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDRIffExpressionContext)
}

func (s *ASTDRImpliesExpressionContext) AllIMPLIES() []antlr.TerminalNode {
	return s.GetTokens(acmeParserIMPLIES)
}

func (s *ASTDRImpliesExpressionContext) IMPLIES(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserIMPLIES, i)
}

func (s *ASTDRImpliesExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ASTDRImpliesExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ASTDRImpliesExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterASTDRImpliesExpression(s)
	}
}

func (s *ASTDRImpliesExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitASTDRImpliesExpression(s)
	}
}

func (p *acmeParser) ASTDRImpliesExpression() (localctx IASTDRImpliesExpressionContext) {
	this := p
	_ = this

	localctx = NewASTDRImpliesExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, acmeParserRULE_aSTDRImpliesExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1340)
		p.DRIffExpression()
	}
	p.SetState(1345)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1341)
				p.Match(acmeParserIMPLIES)
			}
			{
				p.SetState(1342)
				p.DRIffExpression()
			}

		}
		p.SetState(1347)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext())
	}

	return localctx
}

// IDRIffExpressionContext is an interface to support dynamic dispatch.
type IDRIffExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDRIffExpressionContext differentiates from other interfaces.
	IsDRIffExpressionContext()
}

type DRIffExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDRIffExpressionContext() *DRIffExpressionContext {
	var p = new(DRIffExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_dRIffExpression
	return p
}

func (*DRIffExpressionContext) IsDRIffExpressionContext() {}

func NewDRIffExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DRIffExpressionContext {
	var p = new(DRIffExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_dRIffExpression

	return p
}

func (s *DRIffExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DRIffExpressionContext) AllDRAndExpression() []IDRAndExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDRAndExpressionContext)(nil)).Elem())
	var tst = make([]IDRAndExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDRAndExpressionContext)
		}
	}

	return tst
}

func (s *DRIffExpressionContext) DRAndExpression(i int) IDRAndExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDRAndExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDRAndExpressionContext)
}

func (s *DRIffExpressionContext) AllIFF() []antlr.TerminalNode {
	return s.GetTokens(acmeParserIFF)
}

func (s *DRIffExpressionContext) IFF(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserIFF, i)
}

func (s *DRIffExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DRIffExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DRIffExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterDRIffExpression(s)
	}
}

func (s *DRIffExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitDRIffExpression(s)
	}
}

func (p *acmeParser) DRIffExpression() (localctx IDRIffExpressionContext) {
	this := p
	_ = this

	localctx = NewDRIffExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, acmeParserRULE_dRIffExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1348)
		p.DRAndExpression()
	}
	p.SetState(1353)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 197, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1349)
				p.Match(acmeParserIFF)
			}
			{
				p.SetState(1350)
				p.DRAndExpression()
			}

		}
		p.SetState(1355)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 197, p.GetParserRuleContext())
	}

	return localctx
}

// IDRAndExpressionContext is an interface to support dynamic dispatch.
type IDRAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDRAndExpressionContext differentiates from other interfaces.
	IsDRAndExpressionContext()
}

type DRAndExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDRAndExpressionContext() *DRAndExpressionContext {
	var p = new(DRAndExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_dRAndExpression
	return p
}

func (*DRAndExpressionContext) IsDRAndExpressionContext() {}

func NewDRAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DRAndExpressionContext {
	var p = new(DRAndExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_dRAndExpression

	return p
}

func (s *DRAndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DRAndExpressionContext) AllDRNegateExpression() []IDRNegateExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDRNegateExpressionContext)(nil)).Elem())
	var tst = make([]IDRNegateExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDRNegateExpressionContext)
		}
	}

	return tst
}

func (s *DRAndExpressionContext) DRNegateExpression(i int) IDRNegateExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDRNegateExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDRNegateExpressionContext)
}

func (s *DRAndExpressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(acmeParserAND)
}

func (s *DRAndExpressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserAND, i)
}

func (s *DRAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DRAndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DRAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterDRAndExpression(s)
	}
}

func (s *DRAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitDRAndExpression(s)
	}
}

func (p *acmeParser) DRAndExpression() (localctx IDRAndExpressionContext) {
	this := p
	_ = this

	localctx = NewDRAndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, acmeParserRULE_dRAndExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1356)
		p.DRNegateExpression()
	}
	p.SetState(1361)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 198, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1357)
				p.Match(acmeParserAND)
			}
			{
				p.SetState(1358)
				p.DRNegateExpression()
			}

		}
		p.SetState(1363)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 198, p.GetParserRuleContext())
	}

	return localctx
}

// IDRNegateExpressionContext is an interface to support dynamic dispatch.
type IDRNegateExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDRNegateExpressionContext differentiates from other interfaces.
	IsDRNegateExpressionContext()
}

type DRNegateExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDRNegateExpressionContext() *DRNegateExpressionContext {
	var p = new(DRNegateExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_dRNegateExpression
	return p
}

func (*DRNegateExpressionContext) IsDRNegateExpressionContext() {}

func NewDRNegateExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DRNegateExpressionContext {
	var p = new(DRNegateExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_dRNegateExpression

	return p
}

func (s *DRNegateExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DRNegateExpressionContext) BANG() antlr.TerminalNode {
	return s.GetToken(acmeParserBANG, 0)
}

func (s *DRNegateExpressionContext) DRNegateExpression() IDRNegateExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDRNegateExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDRNegateExpressionContext)
}

func (s *DRNegateExpressionContext) DREqualityExpression() IDREqualityExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDREqualityExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDREqualityExpressionContext)
}

func (s *DRNegateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DRNegateExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DRNegateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterDRNegateExpression(s)
	}
}

func (s *DRNegateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitDRNegateExpression(s)
	}
}

func (p *acmeParser) DRNegateExpression() (localctx IDRNegateExpressionContext) {
	this := p
	_ = this

	localctx = NewDRNegateExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, acmeParserRULE_dRNegateExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1367)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserBANG:
		{
			p.SetState(1364)
			p.Match(acmeParserBANG)
		}
		{
			p.SetState(1365)
			p.DRNegateExpression()
		}

	case acmeParserCOLLECT, acmeParserCOMPONENT, acmeParserCONNECTOR, acmeParserDOUBLE, acmeParserELEMENT, acmeParserENUM, acmeParserEXISTS, acmeParserFORALL, acmeParserFLOAT, acmeParserGROUP, acmeParserINT, acmeParserLBRACE, acmeParserLBRACKET, acmeParserLPAREN, acmeParserLANGLE, acmeParserMINUS, acmeParserPORT, acmeParserPROPERTY, acmeParserRECORD, acmeParserROLE, acmeParserSEQUENCE, acmeParserSELECT, acmeParserSET, acmeParserSLASH, acmeParserSTRING, acmeParserSYSTEM, acmeParserTRUE, acmeParserFALSE, acmeParserBOOLEAN, acmeParserFLOATING_POINT_LITERAL, acmeParserINTEGER_LITERAL, acmeParserSTRING_LITERAL, acmeParserIDENTIFIER:
		{
			p.SetState(1366)
			p.DREqualityExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDREqualityExpressionContext is an interface to support dynamic dispatch.
type IDREqualityExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDREqualityExpressionContext differentiates from other interfaces.
	IsDREqualityExpressionContext()
}

type DREqualityExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDREqualityExpressionContext() *DREqualityExpressionContext {
	var p = new(DREqualityExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_dREqualityExpression
	return p
}

func (*DREqualityExpressionContext) IsDREqualityExpressionContext() {}

func NewDREqualityExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DREqualityExpressionContext {
	var p = new(DREqualityExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_dREqualityExpression

	return p
}

func (s *DREqualityExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DREqualityExpressionContext) AllDRRelationalExpression() []IDRRelationalExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDRRelationalExpressionContext)(nil)).Elem())
	var tst = make([]IDRRelationalExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDRRelationalExpressionContext)
		}
	}

	return tst
}

func (s *DREqualityExpressionContext) DRRelationalExpression(i int) IDRRelationalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDRRelationalExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDRRelationalExpressionContext)
}

func (s *DREqualityExpressionContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(acmeParserEQ)
}

func (s *DREqualityExpressionContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserEQ, i)
}

func (s *DREqualityExpressionContext) AllNE() []antlr.TerminalNode {
	return s.GetTokens(acmeParserNE)
}

func (s *DREqualityExpressionContext) NE(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserNE, i)
}

func (s *DREqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DREqualityExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DREqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterDREqualityExpression(s)
	}
}

func (s *DREqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitDREqualityExpression(s)
	}
}

func (p *acmeParser) DREqualityExpression() (localctx IDREqualityExpressionContext) {
	this := p
	_ = this

	localctx = NewDREqualityExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, acmeParserRULE_dREqualityExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1369)
		p.DRRelationalExpression()
	}
	p.SetState(1376)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1374)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserEQ:
				{
					p.SetState(1370)
					p.Match(acmeParserEQ)
				}
				{
					p.SetState(1371)
					p.DRRelationalExpression()
				}

			case acmeParserNE:
				{
					p.SetState(1372)
					p.Match(acmeParserNE)
				}
				{
					p.SetState(1373)
					p.DRRelationalExpression()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(1378)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext())
	}

	return localctx
}

// IDRRelationalExpressionContext is an interface to support dynamic dispatch.
type IDRRelationalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDRRelationalExpressionContext differentiates from other interfaces.
	IsDRRelationalExpressionContext()
}

type DRRelationalExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDRRelationalExpressionContext() *DRRelationalExpressionContext {
	var p = new(DRRelationalExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_dRRelationalExpression
	return p
}

func (*DRRelationalExpressionContext) IsDRRelationalExpressionContext() {}

func NewDRRelationalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DRRelationalExpressionContext {
	var p = new(DRRelationalExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_dRRelationalExpression

	return p
}

func (s *DRRelationalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DRRelationalExpressionContext) AllDRAdditiveExpression() []IDRAdditiveExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDRAdditiveExpressionContext)(nil)).Elem())
	var tst = make([]IDRAdditiveExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDRAdditiveExpressionContext)
		}
	}

	return tst
}

func (s *DRRelationalExpressionContext) DRAdditiveExpression(i int) IDRAdditiveExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDRAdditiveExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDRAdditiveExpressionContext)
}

func (s *DRRelationalExpressionContext) AllLANGLE() []antlr.TerminalNode {
	return s.GetTokens(acmeParserLANGLE)
}

func (s *DRRelationalExpressionContext) LANGLE(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserLANGLE, i)
}

func (s *DRRelationalExpressionContext) AllRANGLE() []antlr.TerminalNode {
	return s.GetTokens(acmeParserRANGLE)
}

func (s *DRRelationalExpressionContext) RANGLE(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserRANGLE, i)
}

func (s *DRRelationalExpressionContext) AllLE() []antlr.TerminalNode {
	return s.GetTokens(acmeParserLE)
}

func (s *DRRelationalExpressionContext) LE(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserLE, i)
}

func (s *DRRelationalExpressionContext) AllGE() []antlr.TerminalNode {
	return s.GetTokens(acmeParserGE)
}

func (s *DRRelationalExpressionContext) GE(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserGE, i)
}

func (s *DRRelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DRRelationalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DRRelationalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterDRRelationalExpression(s)
	}
}

func (s *DRRelationalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitDRRelationalExpression(s)
	}
}

func (p *acmeParser) DRRelationalExpression() (localctx IDRRelationalExpressionContext) {
	this := p
	_ = this

	localctx = NewDRRelationalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, acmeParserRULE_dRRelationalExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1379)
		p.DRAdditiveExpression()
	}
	p.SetState(1390)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1388)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserLANGLE:
				{
					p.SetState(1380)
					p.Match(acmeParserLANGLE)
				}
				{
					p.SetState(1381)
					p.DRAdditiveExpression()
				}

			case acmeParserRANGLE:
				{
					p.SetState(1382)
					p.Match(acmeParserRANGLE)
				}
				{
					p.SetState(1383)
					p.DRAdditiveExpression()
				}

			case acmeParserLE:
				{
					p.SetState(1384)
					p.Match(acmeParserLE)
				}
				{
					p.SetState(1385)
					p.DRAdditiveExpression()
				}

			case acmeParserGE:
				{
					p.SetState(1386)
					p.Match(acmeParserGE)
				}
				{
					p.SetState(1387)
					p.DRAdditiveExpression()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(1392)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext())
	}

	return localctx
}

// IDRAdditiveExpressionContext is an interface to support dynamic dispatch.
type IDRAdditiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDRAdditiveExpressionContext differentiates from other interfaces.
	IsDRAdditiveExpressionContext()
}

type DRAdditiveExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDRAdditiveExpressionContext() *DRAdditiveExpressionContext {
	var p = new(DRAdditiveExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_dRAdditiveExpression
	return p
}

func (*DRAdditiveExpressionContext) IsDRAdditiveExpressionContext() {}

func NewDRAdditiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DRAdditiveExpressionContext {
	var p = new(DRAdditiveExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_dRAdditiveExpression

	return p
}

func (s *DRAdditiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DRAdditiveExpressionContext) AllDRMultiplicativeExpression() []IDRMultiplicativeExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDRMultiplicativeExpressionContext)(nil)).Elem())
	var tst = make([]IDRMultiplicativeExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDRMultiplicativeExpressionContext)
		}
	}

	return tst
}

func (s *DRAdditiveExpressionContext) DRMultiplicativeExpression(i int) IDRMultiplicativeExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDRMultiplicativeExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDRMultiplicativeExpressionContext)
}

func (s *DRAdditiveExpressionContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(acmeParserPLUS)
}

func (s *DRAdditiveExpressionContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserPLUS, i)
}

func (s *DRAdditiveExpressionContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(acmeParserMINUS)
}

func (s *DRAdditiveExpressionContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserMINUS, i)
}

func (s *DRAdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DRAdditiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DRAdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterDRAdditiveExpression(s)
	}
}

func (s *DRAdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitDRAdditiveExpression(s)
	}
}

func (p *acmeParser) DRAdditiveExpression() (localctx IDRAdditiveExpressionContext) {
	this := p
	_ = this

	localctx = NewDRAdditiveExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, acmeParserRULE_dRAdditiveExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1393)
		p.DRMultiplicativeExpression()
	}
	p.SetState(1400)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1398)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserPLUS:
				{
					p.SetState(1394)
					p.Match(acmeParserPLUS)
				}
				{
					p.SetState(1395)
					p.DRMultiplicativeExpression()
				}

			case acmeParserMINUS:
				{
					p.SetState(1396)
					p.Match(acmeParserMINUS)
				}
				{
					p.SetState(1397)
					p.DRMultiplicativeExpression()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(1402)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext())
	}

	return localctx
}

// IDRMultiplicativeExpressionContext is an interface to support dynamic dispatch.
type IDRMultiplicativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDRMultiplicativeExpressionContext differentiates from other interfaces.
	IsDRMultiplicativeExpressionContext()
}

type DRMultiplicativeExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDRMultiplicativeExpressionContext() *DRMultiplicativeExpressionContext {
	var p = new(DRMultiplicativeExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_dRMultiplicativeExpression
	return p
}

func (*DRMultiplicativeExpressionContext) IsDRMultiplicativeExpressionContext() {}

func NewDRMultiplicativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DRMultiplicativeExpressionContext {
	var p = new(DRMultiplicativeExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_dRMultiplicativeExpression

	return p
}

func (s *DRMultiplicativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DRMultiplicativeExpressionContext) AllDRNegativeExpression() []IDRNegativeExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDRNegativeExpressionContext)(nil)).Elem())
	var tst = make([]IDRNegativeExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDRNegativeExpressionContext)
		}
	}

	return tst
}

func (s *DRMultiplicativeExpressionContext) DRNegativeExpression(i int) IDRNegativeExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDRNegativeExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDRNegativeExpressionContext)
}

func (s *DRMultiplicativeExpressionContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(acmeParserSTAR)
}

func (s *DRMultiplicativeExpressionContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserSTAR, i)
}

func (s *DRMultiplicativeExpressionContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(acmeParserSLASH)
}

func (s *DRMultiplicativeExpressionContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserSLASH, i)
}

func (s *DRMultiplicativeExpressionContext) AllREM() []antlr.TerminalNode {
	return s.GetTokens(acmeParserREM)
}

func (s *DRMultiplicativeExpressionContext) REM(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserREM, i)
}

func (s *DRMultiplicativeExpressionContext) AllPOWER() []antlr.TerminalNode {
	return s.GetTokens(acmeParserPOWER)
}

func (s *DRMultiplicativeExpressionContext) POWER(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserPOWER, i)
}

func (s *DRMultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DRMultiplicativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DRMultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterDRMultiplicativeExpression(s)
	}
}

func (s *DRMultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitDRMultiplicativeExpression(s)
	}
}

func (p *acmeParser) DRMultiplicativeExpression() (localctx IDRMultiplicativeExpressionContext) {
	this := p
	_ = this

	localctx = NewDRMultiplicativeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, acmeParserRULE_dRMultiplicativeExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1403)
		p.DRNegativeExpression()
	}
	p.SetState(1414)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1412)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserSTAR:
				{
					p.SetState(1404)
					p.Match(acmeParserSTAR)
				}
				{
					p.SetState(1405)
					p.DRNegativeExpression()
				}

			case acmeParserSLASH:
				{
					p.SetState(1406)
					p.Match(acmeParserSLASH)
				}
				{
					p.SetState(1407)
					p.DRNegativeExpression()
				}

			case acmeParserREM:
				{
					p.SetState(1408)
					p.Match(acmeParserREM)
				}
				{
					p.SetState(1409)
					p.DRNegativeExpression()
				}

			case acmeParserPOWER:
				{
					p.SetState(1410)
					p.Match(acmeParserPOWER)
				}
				{
					p.SetState(1411)
					p.DRNegativeExpression()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(1416)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext())
	}

	return localctx
}

// IDRNegativeExpressionContext is an interface to support dynamic dispatch.
type IDRNegativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDRNegativeExpressionContext differentiates from other interfaces.
	IsDRNegativeExpressionContext()
}

type DRNegativeExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDRNegativeExpressionContext() *DRNegativeExpressionContext {
	var p = new(DRNegativeExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_dRNegativeExpression
	return p
}

func (*DRNegativeExpressionContext) IsDRNegativeExpressionContext() {}

func NewDRNegativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DRNegativeExpressionContext {
	var p = new(DRNegativeExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_dRNegativeExpression

	return p
}

func (s *DRNegativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DRNegativeExpressionContext) MINUS() antlr.TerminalNode {
	return s.GetToken(acmeParserMINUS, 0)
}

func (s *DRNegativeExpressionContext) DRNegativeExpression() IDRNegativeExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDRNegativeExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDRNegativeExpressionContext)
}

func (s *DRNegativeExpressionContext) PrimitiveExpression() IPrimitiveExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveExpressionContext)
}

func (s *DRNegativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DRNegativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DRNegativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterDRNegativeExpression(s)
	}
}

func (s *DRNegativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitDRNegativeExpression(s)
	}
}

func (p *acmeParser) DRNegativeExpression() (localctx IDRNegativeExpressionContext) {
	this := p
	_ = this

	localctx = NewDRNegativeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, acmeParserRULE_dRNegativeExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1420)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserMINUS:
		{
			p.SetState(1417)
			p.Match(acmeParserMINUS)
		}
		{
			p.SetState(1418)
			p.DRNegativeExpression()
		}

	case acmeParserCOLLECT, acmeParserCOMPONENT, acmeParserCONNECTOR, acmeParserDOUBLE, acmeParserELEMENT, acmeParserENUM, acmeParserEXISTS, acmeParserFORALL, acmeParserFLOAT, acmeParserGROUP, acmeParserINT, acmeParserLBRACE, acmeParserLBRACKET, acmeParserLPAREN, acmeParserLANGLE, acmeParserPORT, acmeParserPROPERTY, acmeParserRECORD, acmeParserROLE, acmeParserSEQUENCE, acmeParserSELECT, acmeParserSET, acmeParserSLASH, acmeParserSTRING, acmeParserSYSTEM, acmeParserTRUE, acmeParserFALSE, acmeParserBOOLEAN, acmeParserFLOATING_POINT_LITERAL, acmeParserINTEGER_LITERAL, acmeParserSTRING_LITERAL, acmeParserIDENTIFIER:
		{
			p.SetState(1419)
			p.PrimitiveExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPrimitiveExpressionContext is an interface to support dynamic dispatch.
type IPrimitiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveExpressionContext differentiates from other interfaces.
	IsPrimitiveExpressionContext()
}

type PrimitiveExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveExpressionContext() *PrimitiveExpressionContext {
	var p = new(PrimitiveExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_primitiveExpression
	return p
}

func (*PrimitiveExpressionContext) IsPrimitiveExpressionContext() {}

func NewPrimitiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveExpressionContext {
	var p = new(PrimitiveExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_primitiveExpression

	return p
}

func (s *PrimitiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveExpressionContext) LiteralConstant() ILiteralConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralConstantContext)
}

func (s *PrimitiveExpressionContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *PrimitiveExpressionContext) ParentheticalExpression() IParentheticalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParentheticalExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParentheticalExpressionContext)
}

func (s *PrimitiveExpressionContext) SetExpression() ISetExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetExpressionContext)
}

func (s *PrimitiveExpressionContext) LiteralSequence() ILiteralSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralSequenceContext)
}

func (s *PrimitiveExpressionContext) LiteralRecord() ILiteralRecordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralRecordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralRecordContext)
}

func (s *PrimitiveExpressionContext) QuantifiedExpression() IQuantifiedExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantifiedExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantifiedExpressionContext)
}

func (s *PrimitiveExpressionContext) SequenceExpression() ISequenceExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceExpressionContext)
}

func (s *PrimitiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterPrimitiveExpression(s)
	}
}

func (s *PrimitiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitPrimitiveExpression(s)
	}
}

func (p *acmeParser) PrimitiveExpression() (localctx IPrimitiveExpressionContext) {
	this := p
	_ = this

	localctx = NewPrimitiveExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, acmeParserRULE_primitiveExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1430)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 209, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1422)
			p.LiteralConstant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1423)
			p.Reference()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1424)
			p.ParentheticalExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1425)
			p.SetExpression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1426)
			p.LiteralSequence()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1427)
			p.LiteralRecord()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1428)
			p.QuantifiedExpression()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1429)
			p.SequenceExpression()
		}

	}

	return localctx
}

// IParentheticalExpressionContext is an interface to support dynamic dispatch.
type IParentheticalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParentheticalExpressionContext differentiates from other interfaces.
	IsParentheticalExpressionContext()
}

type ParentheticalExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParentheticalExpressionContext() *ParentheticalExpressionContext {
	var p = new(ParentheticalExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_parentheticalExpression
	return p
}

func (*ParentheticalExpressionContext) IsParentheticalExpressionContext() {}

func NewParentheticalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParentheticalExpressionContext {
	var p = new(ParentheticalExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_parentheticalExpression

	return p
}

func (s *ParentheticalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParentheticalExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(acmeParserLPAREN, 0)
}

func (s *ParentheticalExpressionContext) DesignRuleExpression() IDesignRuleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleExpressionContext)
}

func (s *ParentheticalExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(acmeParserRPAREN, 0)
}

func (s *ParentheticalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParentheticalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParentheticalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterParentheticalExpression(s)
	}
}

func (s *ParentheticalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitParentheticalExpression(s)
	}
}

func (p *acmeParser) ParentheticalExpression() (localctx IParentheticalExpressionContext) {
	this := p
	_ = this

	localctx = NewParentheticalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, acmeParserRULE_parentheticalExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1432)
		p.Match(acmeParserLPAREN)
	}
	{
		p.SetState(1433)
		p.DesignRuleExpression()
	}
	{
		p.SetState(1434)
		p.Match(acmeParserRPAREN)
	}

	return localctx
}

// IReferenceContext is an interface to support dynamic dispatch.
type IReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceContext differentiates from other interfaces.
	IsReferenceContext()
}

type ReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceContext() *ReferenceContext {
	var p = new(ReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_reference
	return p
}

func (*ReferenceContext) IsReferenceContext() {}

func NewReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceContext {
	var p = new(ReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_reference

	return p
}

func (s *ReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ReferenceContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReferenceContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(acmeParserDOT)
}

func (s *ReferenceContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserDOT, i)
}

func (s *ReferenceContext) ActualParams() IActualParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActualParamsContext)
}

func (s *ReferenceContext) AllSetReference() []ISetReferenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISetReferenceContext)(nil)).Elem())
	var tst = make([]ISetReferenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISetReferenceContext)
		}
	}

	return tst
}

func (s *ReferenceContext) SetReference(i int) ISetReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetReferenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISetReferenceContext)
}

func (s *ReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterReference(s)
	}
}

func (s *ReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitReference(s)
	}
}

func (p *acmeParser) Reference() (localctx IReferenceContext) {
	this := p
	_ = this

	localctx = NewReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, acmeParserRULE_reference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1436)
		p.Identifier()
	}
	p.SetState(1444)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == acmeParserDOT {
		{
			p.SetState(1437)
			p.Match(acmeParserDOT)
		}
		p.SetState(1440)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserIDENTIFIER:
			{
				p.SetState(1438)
				p.Identifier()
			}

		case acmeParserATTACHEDPORTS, acmeParserATTACHEDROLES, acmeParserCOMPONENTS, acmeParserCONNECTORS, acmeParserGROUPS, acmeParserMEMBERS, acmeParserPORTS, acmeParserPROPERTIES, acmeParserREPRESENTATIONS, acmeParserROLES, acmeParserTYPE:
			{
				p.SetState(1439)
				p.SetReference()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1446)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1448)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserLPAREN {
		{
			p.SetState(1447)
			p.ActualParams()
		}

	}

	return localctx
}

// ISetReferenceContext is an interface to support dynamic dispatch.
type ISetReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetReferenceContext differentiates from other interfaces.
	IsSetReferenceContext()
}

type SetReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetReferenceContext() *SetReferenceContext {
	var p = new(SetReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_setReference
	return p
}

func (*SetReferenceContext) IsSetReferenceContext() {}

func NewSetReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetReferenceContext {
	var p = new(SetReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_setReference

	return p
}

func (s *SetReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *SetReferenceContext) TYPE() antlr.TerminalNode {
	return s.GetToken(acmeParserTYPE, 0)
}

func (s *SetReferenceContext) COMPONENTS() antlr.TerminalNode {
	return s.GetToken(acmeParserCOMPONENTS, 0)
}

func (s *SetReferenceContext) CONNECTORS() antlr.TerminalNode {
	return s.GetToken(acmeParserCONNECTORS, 0)
}

func (s *SetReferenceContext) PORTS() antlr.TerminalNode {
	return s.GetToken(acmeParserPORTS, 0)
}

func (s *SetReferenceContext) ROLES() antlr.TerminalNode {
	return s.GetToken(acmeParserROLES, 0)
}

func (s *SetReferenceContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(acmeParserGROUPS, 0)
}

func (s *SetReferenceContext) MEMBERS() antlr.TerminalNode {
	return s.GetToken(acmeParserMEMBERS, 0)
}

func (s *SetReferenceContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(acmeParserPROPERTIES, 0)
}

func (s *SetReferenceContext) REPRESENTATIONS() antlr.TerminalNode {
	return s.GetToken(acmeParserREPRESENTATIONS, 0)
}

func (s *SetReferenceContext) ATTACHEDPORTS() antlr.TerminalNode {
	return s.GetToken(acmeParserATTACHEDPORTS, 0)
}

func (s *SetReferenceContext) ATTACHEDROLES() antlr.TerminalNode {
	return s.GetToken(acmeParserATTACHEDROLES, 0)
}

func (s *SetReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterSetReference(s)
	}
}

func (s *SetReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitSetReference(s)
	}
}

func (p *acmeParser) SetReference() (localctx ISetReferenceContext) {
	this := p
	_ = this

	localctx = NewSetReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, acmeParserRULE_setReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1461)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserTYPE:
		{
			p.SetState(1450)
			p.Match(acmeParserTYPE)
		}

	case acmeParserCOMPONENTS:
		{
			p.SetState(1451)
			p.Match(acmeParserCOMPONENTS)
		}

	case acmeParserCONNECTORS:
		{
			p.SetState(1452)
			p.Match(acmeParserCONNECTORS)
		}

	case acmeParserPORTS:
		{
			p.SetState(1453)
			p.Match(acmeParserPORTS)
		}

	case acmeParserROLES:
		{
			p.SetState(1454)
			p.Match(acmeParserROLES)
		}

	case acmeParserGROUPS:
		{
			p.SetState(1455)
			p.Match(acmeParserGROUPS)
		}

	case acmeParserMEMBERS:
		{
			p.SetState(1456)
			p.Match(acmeParserMEMBERS)
		}

	case acmeParserPROPERTIES:
		{
			p.SetState(1457)
			p.Match(acmeParserPROPERTIES)
		}

	case acmeParserREPRESENTATIONS:
		{
			p.SetState(1458)
			p.Match(acmeParserREPRESENTATIONS)
		}

	case acmeParserATTACHEDPORTS:
		{
			p.SetState(1459)
			p.Match(acmeParserATTACHEDPORTS)
		}

	case acmeParserATTACHEDROLES:
		{
			p.SetState(1460)
			p.Match(acmeParserATTACHEDROLES)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IActualParamsContext is an interface to support dynamic dispatch.
type IActualParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActualParamsContext differentiates from other interfaces.
	IsActualParamsContext()
}

type ActualParamsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualParamsContext() *ActualParamsContext {
	var p = new(ActualParamsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_actualParams
	return p
}

func (*ActualParamsContext) IsActualParamsContext() {}

func NewActualParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualParamsContext {
	var p = new(ActualParamsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_actualParams

	return p
}

func (s *ActualParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualParamsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(acmeParserLPAREN, 0)
}

func (s *ActualParamsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(acmeParserRPAREN, 0)
}

func (s *ActualParamsContext) AllDesignRuleExpression() []IDesignRuleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDesignRuleExpressionContext)(nil)).Elem())
	var tst = make([]IDesignRuleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDesignRuleExpressionContext)
		}
	}

	return tst
}

func (s *ActualParamsContext) DesignRuleExpression(i int) IDesignRuleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleExpressionContext)
}

func (s *ActualParamsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *ActualParamsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *ActualParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterActualParams(s)
	}
}

func (s *ActualParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitActualParams(s)
	}
}

func (p *acmeParser) ActualParams() (localctx IActualParamsContext) {
	this := p
	_ = this

	localctx = NewActualParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, acmeParserRULE_actualParams)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1463)
		p.Match(acmeParserLPAREN)
	}
	p.SetState(1472)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-13)&-(0x1f+1)) == 0 && ((1<<uint((_la-13)))&((1<<(acmeParserBANG-13))|(1<<(acmeParserCOLLECT-13))|(1<<(acmeParserCOMPONENT-13))|(1<<(acmeParserCONNECTOR-13))|(1<<(acmeParserDOUBLE-13))|(1<<(acmeParserELEMENT-13))|(1<<(acmeParserENUM-13))|(1<<(acmeParserEXISTS-13))|(1<<(acmeParserFORALL-13))|(1<<(acmeParserFLOAT-13))|(1<<(acmeParserGROUP-13)))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(acmeParserINT-46))|(1<<(acmeParserLBRACE-46))|(1<<(acmeParserLBRACKET-46))|(1<<(acmeParserLPAREN-46))|(1<<(acmeParserLANGLE-46))|(1<<(acmeParserMINUS-46))|(1<<(acmeParserPORT-46))|(1<<(acmeParserPROPERTY-46))|(1<<(acmeParserRECORD-46)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(acmeParserROLE-78))|(1<<(acmeParserSEQUENCE-78))|(1<<(acmeParserSELECT-78))|(1<<(acmeParserSET-78))|(1<<(acmeParserSLASH-78))|(1<<(acmeParserSTRING-78))|(1<<(acmeParserSYSTEM-78))|(1<<(acmeParserTRUE-78))|(1<<(acmeParserFALSE-78))|(1<<(acmeParserBOOLEAN-78))|(1<<(acmeParserFLOATING_POINT_LITERAL-78))|(1<<(acmeParserINTEGER_LITERAL-78))|(1<<(acmeParserSTRING_LITERAL-78))|(1<<(acmeParserIDENTIFIER-78)))) != 0) {
		{
			p.SetState(1464)
			p.DesignRuleExpression()
		}
		p.SetState(1469)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserCOMMA {
			{
				p.SetState(1465)
				p.Match(acmeParserCOMMA)
			}
			{
				p.SetState(1466)
				p.DesignRuleExpression()
			}

			p.SetState(1471)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1474)
		p.Match(acmeParserRPAREN)
	}

	return localctx
}

// ILiteralConstantContext is an interface to support dynamic dispatch.
type ILiteralConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralConstantContext differentiates from other interfaces.
	IsLiteralConstantContext()
}

type LiteralConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralConstantContext() *LiteralConstantContext {
	var p = new(LiteralConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_literalConstant
	return p
}

func (*LiteralConstantContext) IsLiteralConstantContext() {}

func NewLiteralConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralConstantContext {
	var p = new(LiteralConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_literalConstant

	return p
}

func (s *LiteralConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralConstantContext) INTEGER_LITERAL() antlr.TerminalNode {
	return s.GetToken(acmeParserINTEGER_LITERAL, 0)
}

func (s *LiteralConstantContext) FLOATING_POINT_LITERAL() antlr.TerminalNode {
	return s.GetToken(acmeParserFLOATING_POINT_LITERAL, 0)
}

func (s *LiteralConstantContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(acmeParserSTRING_LITERAL, 0)
}

func (s *LiteralConstantContext) TRUE() antlr.TerminalNode {
	return s.GetToken(acmeParserTRUE, 0)
}

func (s *LiteralConstantContext) FALSE() antlr.TerminalNode {
	return s.GetToken(acmeParserFALSE, 0)
}

func (s *LiteralConstantContext) COMPONENT() antlr.TerminalNode {
	return s.GetToken(acmeParserCOMPONENT, 0)
}

func (s *LiteralConstantContext) GROUP() antlr.TerminalNode {
	return s.GetToken(acmeParserGROUP, 0)
}

func (s *LiteralConstantContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(acmeParserCONNECTOR, 0)
}

func (s *LiteralConstantContext) PORT() antlr.TerminalNode {
	return s.GetToken(acmeParserPORT, 0)
}

func (s *LiteralConstantContext) ROLE() antlr.TerminalNode {
	return s.GetToken(acmeParserROLE, 0)
}

func (s *LiteralConstantContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(acmeParserSYSTEM, 0)
}

func (s *LiteralConstantContext) ELEMENT() antlr.TerminalNode {
	return s.GetToken(acmeParserELEMENT, 0)
}

func (s *LiteralConstantContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(acmeParserPROPERTY, 0)
}

func (s *LiteralConstantContext) INT() antlr.TerminalNode {
	return s.GetToken(acmeParserINT, 0)
}

func (s *LiteralConstantContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(acmeParserFLOAT, 0)
}

func (s *LiteralConstantContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(acmeParserDOUBLE, 0)
}

func (s *LiteralConstantContext) STRING() antlr.TerminalNode {
	return s.GetToken(acmeParserSTRING, 0)
}

func (s *LiteralConstantContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(acmeParserBOOLEAN, 0)
}

func (s *LiteralConstantContext) ENUM() antlr.TerminalNode {
	return s.GetToken(acmeParserENUM, 0)
}

func (s *LiteralConstantContext) SET() antlr.TerminalNode {
	return s.GetToken(acmeParserSET, 0)
}

func (s *LiteralConstantContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(acmeParserSEQUENCE, 0)
}

func (s *LiteralConstantContext) RECORD() antlr.TerminalNode {
	return s.GetToken(acmeParserRECORD, 0)
}

func (s *LiteralConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterLiteralConstant(s)
	}
}

func (s *LiteralConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitLiteralConstant(s)
	}
}

func (p *acmeParser) LiteralConstant() (localctx ILiteralConstantContext) {
	this := p
	_ = this

	localctx = NewLiteralConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, acmeParserRULE_literalConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1498)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserINTEGER_LITERAL:
		{
			p.SetState(1476)
			p.Match(acmeParserINTEGER_LITERAL)
		}

	case acmeParserFLOATING_POINT_LITERAL:
		{
			p.SetState(1477)
			p.Match(acmeParserFLOATING_POINT_LITERAL)
		}

	case acmeParserSTRING_LITERAL:
		{
			p.SetState(1478)
			p.Match(acmeParserSTRING_LITERAL)
		}

	case acmeParserTRUE:
		{
			p.SetState(1479)
			p.Match(acmeParserTRUE)
		}

	case acmeParserFALSE:
		{
			p.SetState(1480)
			p.Match(acmeParserFALSE)
		}

	case acmeParserCOMPONENT:
		{
			p.SetState(1481)
			p.Match(acmeParserCOMPONENT)
		}

	case acmeParserGROUP:
		{
			p.SetState(1482)
			p.Match(acmeParserGROUP)
		}

	case acmeParserCONNECTOR:
		{
			p.SetState(1483)
			p.Match(acmeParserCONNECTOR)
		}

	case acmeParserPORT:
		{
			p.SetState(1484)
			p.Match(acmeParserPORT)
		}

	case acmeParserROLE:
		{
			p.SetState(1485)
			p.Match(acmeParserROLE)
		}

	case acmeParserSYSTEM:
		{
			p.SetState(1486)
			p.Match(acmeParserSYSTEM)
		}

	case acmeParserELEMENT:
		{
			p.SetState(1487)
			p.Match(acmeParserELEMENT)
		}

	case acmeParserPROPERTY:
		{
			p.SetState(1488)
			p.Match(acmeParserPROPERTY)
		}

	case acmeParserINT:
		{
			p.SetState(1489)
			p.Match(acmeParserINT)
		}

	case acmeParserFLOAT:
		{
			p.SetState(1490)
			p.Match(acmeParserFLOAT)
		}

	case acmeParserDOUBLE:
		{
			p.SetState(1491)
			p.Match(acmeParserDOUBLE)
		}

	case acmeParserSTRING:
		{
			p.SetState(1492)
			p.Match(acmeParserSTRING)
		}

	case acmeParserBOOLEAN:
		{
			p.SetState(1493)
			p.Match(acmeParserBOOLEAN)
		}

	case acmeParserENUM:
		{
			p.SetState(1494)
			p.Match(acmeParserENUM)
		}

	case acmeParserSET:
		{
			p.SetState(1495)
			p.Match(acmeParserSET)
		}

	case acmeParserSEQUENCE:
		{
			p.SetState(1496)
			p.Match(acmeParserSEQUENCE)
		}

	case acmeParserRECORD:
		{
			p.SetState(1497)
			p.Match(acmeParserRECORD)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQuantifiedExpressionContext is an interface to support dynamic dispatch.
type IQuantifiedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantifiedExpressionContext differentiates from other interfaces.
	IsQuantifiedExpressionContext()
}

type QuantifiedExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantifiedExpressionContext() *QuantifiedExpressionContext {
	var p = new(QuantifiedExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_quantifiedExpression
	return p
}

func (*QuantifiedExpressionContext) IsQuantifiedExpressionContext() {}

func NewQuantifiedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantifiedExpressionContext {
	var p = new(QuantifiedExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_quantifiedExpression

	return p
}

func (s *QuantifiedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantifiedExpressionContext) AllVariableSetDeclaration() []IVariableSetDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableSetDeclarationContext)(nil)).Elem())
	var tst = make([]IVariableSetDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableSetDeclarationContext)
		}
	}

	return tst
}

func (s *QuantifiedExpressionContext) VariableSetDeclaration(i int) IVariableSetDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableSetDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableSetDeclarationContext)
}

func (s *QuantifiedExpressionContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(acmeParserBIT_OR, 0)
}

func (s *QuantifiedExpressionContext) DesignRuleExpression() IDesignRuleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleExpressionContext)
}

func (s *QuantifiedExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *QuantifiedExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *QuantifiedExpressionContext) FORALL() antlr.TerminalNode {
	return s.GetToken(acmeParserFORALL, 0)
}

func (s *QuantifiedExpressionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(acmeParserEXISTS, 0)
}

func (s *QuantifiedExpressionContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(acmeParserUNIQUE, 0)
}

func (s *QuantifiedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantifiedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterQuantifiedExpression(s)
	}
}

func (s *QuantifiedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitQuantifiedExpression(s)
	}
}

func (p *acmeParser) QuantifiedExpression() (localctx IQuantifiedExpressionContext) {
	this := p
	_ = this

	localctx = NewQuantifiedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, acmeParserRULE_quantifiedExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1505)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserFORALL:
		{
			p.SetState(1500)
			p.Match(acmeParserFORALL)
		}

	case acmeParserEXISTS:
		{
			p.SetState(1501)
			p.Match(acmeParserEXISTS)
		}
		p.SetState(1503)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserUNIQUE {
			{
				p.SetState(1502)
				p.Match(acmeParserUNIQUE)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1507)
		p.VariableSetDeclaration()
	}
	p.SetState(1512)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == acmeParserCOMMA {
		{
			p.SetState(1508)
			p.Match(acmeParserCOMMA)
		}
		{
			p.SetState(1509)
			p.VariableSetDeclaration()
		}

		p.SetState(1514)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1515)
		p.Match(acmeParserBIT_OR)
	}
	{
		p.SetState(1516)
		p.DesignRuleExpression()
	}

	return localctx
}

// IDistinctVariableSetDeclarationContext is an interface to support dynamic dispatch.
type IDistinctVariableSetDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDistinctVariableSetDeclarationContext differentiates from other interfaces.
	IsDistinctVariableSetDeclarationContext()
}

type DistinctVariableSetDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistinctVariableSetDeclarationContext() *DistinctVariableSetDeclarationContext {
	var p = new(DistinctVariableSetDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_distinctVariableSetDeclaration
	return p
}

func (*DistinctVariableSetDeclarationContext) IsDistinctVariableSetDeclarationContext() {}

func NewDistinctVariableSetDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistinctVariableSetDeclarationContext {
	var p = new(DistinctVariableSetDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_distinctVariableSetDeclaration

	return p
}

func (s *DistinctVariableSetDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DistinctVariableSetDeclarationContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(acmeParserDISTINCT, 0)
}

func (s *DistinctVariableSetDeclarationContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *DistinctVariableSetDeclarationContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DistinctVariableSetDeclarationContext) IN() antlr.TerminalNode {
	return s.GetToken(acmeParserIN, 0)
}

func (s *DistinctVariableSetDeclarationContext) SetExpression() ISetExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetExpressionContext)
}

func (s *DistinctVariableSetDeclarationContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *DistinctVariableSetDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *DistinctVariableSetDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *DistinctVariableSetDeclarationContext) AcmeTypeRef() IAcmeTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeTypeRefContext)
}

func (s *DistinctVariableSetDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *DistinctVariableSetDeclarationContext) SET_DECLARE() antlr.TerminalNode {
	return s.GetToken(acmeParserSET_DECLARE, 0)
}

func (s *DistinctVariableSetDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctVariableSetDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistinctVariableSetDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterDistinctVariableSetDeclaration(s)
	}
}

func (s *DistinctVariableSetDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitDistinctVariableSetDeclaration(s)
	}
}

func (p *acmeParser) DistinctVariableSetDeclaration() (localctx IDistinctVariableSetDeclarationContext) {
	this := p
	_ = this

	localctx = NewDistinctVariableSetDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, acmeParserRULE_distinctVariableSetDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1518)
		p.Match(acmeParserDISTINCT)
	}
	{
		p.SetState(1519)
		p.Identifier()
	}
	p.SetState(1524)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == acmeParserCOMMA {
		{
			p.SetState(1520)
			p.Match(acmeParserCOMMA)
		}
		{
			p.SetState(1521)
			p.Identifier()
		}

		p.SetState(1526)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1529)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserCOLON || _la == acmeParserSET_DECLARE {
		{
			p.SetState(1527)
			_la = p.GetTokenStream().LA(1)

			if !(_la == acmeParserCOLON || _la == acmeParserSET_DECLARE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1528)
			p.AcmeTypeRef()
		}

	}
	{
		p.SetState(1531)
		p.Match(acmeParserIN)
	}
	p.SetState(1534)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserCOLLECT, acmeParserLBRACE, acmeParserSELECT, acmeParserSLASH:
		{
			p.SetState(1532)
			p.SetExpression()
		}

	case acmeParserIDENTIFIER:
		{
			p.SetState(1533)
			p.Reference()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableSetDeclarationContext is an interface to support dynamic dispatch.
type IVariableSetDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableSetDeclarationContext differentiates from other interfaces.
	IsVariableSetDeclarationContext()
}

type VariableSetDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableSetDeclarationContext() *VariableSetDeclarationContext {
	var p = new(VariableSetDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_variableSetDeclaration
	return p
}

func (*VariableSetDeclarationContext) IsVariableSetDeclarationContext() {}

func NewVariableSetDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableSetDeclarationContext {
	var p = new(VariableSetDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_variableSetDeclaration

	return p
}

func (s *VariableSetDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableSetDeclarationContext) DistinctVariableSetDeclaration() IDistinctVariableSetDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDistinctVariableSetDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDistinctVariableSetDeclarationContext)
}

func (s *VariableSetDeclarationContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *VariableSetDeclarationContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableSetDeclarationContext) IN() antlr.TerminalNode {
	return s.GetToken(acmeParserIN, 0)
}

func (s *VariableSetDeclarationContext) SetExpression() ISetExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetExpressionContext)
}

func (s *VariableSetDeclarationContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *VariableSetDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *VariableSetDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *VariableSetDeclarationContext) AcmeTypeRef() IAcmeTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeTypeRefContext)
}

func (s *VariableSetDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *VariableSetDeclarationContext) SET_DECLARE() antlr.TerminalNode {
	return s.GetToken(acmeParserSET_DECLARE, 0)
}

func (s *VariableSetDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableSetDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableSetDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterVariableSetDeclaration(s)
	}
}

func (s *VariableSetDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitVariableSetDeclaration(s)
	}
}

func (p *acmeParser) VariableSetDeclaration() (localctx IVariableSetDeclarationContext) {
	this := p
	_ = this

	localctx = NewVariableSetDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, acmeParserRULE_variableSetDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1554)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserDISTINCT:
		{
			p.SetState(1536)
			p.DistinctVariableSetDeclaration()
		}

	case acmeParserIDENTIFIER:
		{
			p.SetState(1537)
			p.Identifier()
		}
		p.SetState(1542)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserCOMMA {
			{
				p.SetState(1538)
				p.Match(acmeParserCOMMA)
			}
			{
				p.SetState(1539)
				p.Identifier()
			}

			p.SetState(1544)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1547)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserCOLON || _la == acmeParserSET_DECLARE {
			{
				p.SetState(1545)
				_la = p.GetTokenStream().LA(1)

				if !(_la == acmeParserCOLON || _la == acmeParserSET_DECLARE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1546)
				p.AcmeTypeRef()
			}

		}
		{
			p.SetState(1549)
			p.Match(acmeParserIN)
		}
		p.SetState(1552)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserCOLLECT, acmeParserLBRACE, acmeParserSELECT, acmeParserSLASH:
			{
				p.SetState(1550)
				p.SetExpression()
			}

		case acmeParserIDENTIFIER:
			{
				p.SetState(1551)
				p.Reference()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISequenceExpressionContext is an interface to support dynamic dispatch.
type ISequenceExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequenceExpressionContext differentiates from other interfaces.
	IsSequenceExpressionContext()
}

type SequenceExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceExpressionContext() *SequenceExpressionContext {
	var p = new(SequenceExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_sequenceExpression
	return p
}

func (*SequenceExpressionContext) IsSequenceExpressionContext() {}

func NewSequenceExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceExpressionContext {
	var p = new(SequenceExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_sequenceExpression

	return p
}

func (s *SequenceExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceExpressionContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(acmeParserLANGLE, 0)
}

func (s *SequenceExpressionContext) PathExpression() IPathExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPathExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPathExpressionContext)
}

func (s *SequenceExpressionContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(acmeParserRANGLE, 0)
}

func (s *SequenceExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterSequenceExpression(s)
	}
}

func (s *SequenceExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitSequenceExpression(s)
	}
}

func (p *acmeParser) SequenceExpression() (localctx ISequenceExpressionContext) {
	this := p
	_ = this

	localctx = NewSequenceExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, acmeParserRULE_sequenceExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1556)
		p.Match(acmeParserLANGLE)
	}
	{
		p.SetState(1557)
		p.PathExpression()
	}
	{
		p.SetState(1558)
		p.Match(acmeParserRANGLE)
	}

	return localctx
}

// ISetExpressionContext is an interface to support dynamic dispatch.
type ISetExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetExpressionContext differentiates from other interfaces.
	IsSetExpressionContext()
}

type SetExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetExpressionContext() *SetExpressionContext {
	var p = new(SetExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_setExpression
	return p
}

func (*SetExpressionContext) IsSetExpressionContext() {}

func NewSetExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetExpressionContext {
	var p = new(SetExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_setExpression

	return p
}

func (s *SetExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SetExpressionContext) LiteralSet() ILiteralSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralSetContext)
}

func (s *SetExpressionContext) SetConstructor() ISetConstructorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetConstructorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetConstructorContext)
}

func (s *SetExpressionContext) PathExpression() IPathExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPathExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPathExpressionContext)
}

func (s *SetExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterSetExpression(s)
	}
}

func (s *SetExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitSetExpression(s)
	}
}

func (p *acmeParser) SetExpression() (localctx ISetExpressionContext) {
	this := p
	_ = this

	localctx = NewSetExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, acmeParserRULE_setExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1563)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 227, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1560)
			p.LiteralSet()
		}

	case 2:
		{
			p.SetState(1561)
			p.SetConstructor()
		}

	case 3:
		{
			p.SetState(1562)
			p.PathExpression()
		}

	}

	return localctx
}

// IPathExpressionContext is an interface to support dynamic dispatch.
type IPathExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPathExpressionContext differentiates from other interfaces.
	IsPathExpressionContext()
}

type PathExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathExpressionContext() *PathExpressionContext {
	var p = new(PathExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_pathExpression
	return p
}

func (*PathExpressionContext) IsPathExpressionContext() {}

func NewPathExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathExpressionContext {
	var p = new(PathExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_pathExpression

	return p
}

func (s *PathExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PathExpressionContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(acmeParserSLASH)
}

func (s *PathExpressionContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserSLASH, i)
}

func (s *PathExpressionContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *PathExpressionContext) AcmeTypeRef() IAcmeTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeTypeRefContext)
}

func (s *PathExpressionContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACKET, 0)
}

func (s *PathExpressionContext) DesignRuleExpression() IDesignRuleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleExpressionContext)
}

func (s *PathExpressionContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACKET, 0)
}

func (s *PathExpressionContext) AllPathExpressionContinuation() []IPathExpressionContinuationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPathExpressionContinuationContext)(nil)).Elem())
	var tst = make([]IPathExpressionContinuationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPathExpressionContinuationContext)
		}
	}

	return tst
}

func (s *PathExpressionContext) PathExpressionContinuation(i int) IPathExpressionContinuationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPathExpressionContinuationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPathExpressionContinuationContext)
}

func (s *PathExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *PathExpressionContext) SET_DECLARE() antlr.TerminalNode {
	return s.GetToken(acmeParserSET_DECLARE, 0)
}

func (s *PathExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterPathExpression(s)
	}
}

func (s *PathExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitPathExpression(s)
	}
}

func (p *acmeParser) PathExpression() (localctx IPathExpressionContext) {
	this := p
	_ = this

	localctx = NewPathExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, acmeParserRULE_pathExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1565)
		p.Match(acmeParserSLASH)
	}
	{
		p.SetState(1566)
		p.Reference()
	}
	p.SetState(1569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserCOLON || _la == acmeParserSET_DECLARE {
		{
			p.SetState(1567)
			_la = p.GetTokenStream().LA(1)

			if !(_la == acmeParserCOLON || _la == acmeParserSET_DECLARE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1568)
			p.AcmeTypeRef()
		}

	}
	p.SetState(1575)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserLBRACKET {
		{
			p.SetState(1571)
			p.Match(acmeParserLBRACKET)
		}
		{
			p.SetState(1572)
			p.DesignRuleExpression()
		}
		{
			p.SetState(1573)
			p.Match(acmeParserRBRACKET)
		}

	}
	p.SetState(1581)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 230, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1577)
				p.Match(acmeParserSLASH)
			}
			{
				p.SetState(1578)
				p.PathExpressionContinuation()
			}

		}
		p.SetState(1583)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 230, p.GetParserRuleContext())
	}

	return localctx
}

// IPathExpressionContinuationContext is an interface to support dynamic dispatch.
type IPathExpressionContinuationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPathExpressionContinuationContext differentiates from other interfaces.
	IsPathExpressionContinuationContext()
}

type PathExpressionContinuationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathExpressionContinuationContext() *PathExpressionContinuationContext {
	var p = new(PathExpressionContinuationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_pathExpressionContinuation
	return p
}

func (*PathExpressionContinuationContext) IsPathExpressionContinuationContext() {}

func NewPathExpressionContinuationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathExpressionContinuationContext {
	var p = new(PathExpressionContinuationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_pathExpressionContinuation

	return p
}

func (s *PathExpressionContinuationContext) GetParser() antlr.Parser { return s.parser }

func (s *PathExpressionContinuationContext) SetReference() ISetReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetReferenceContext)
}

func (s *PathExpressionContinuationContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *PathExpressionContinuationContext) AcmeTypeRef() IAcmeTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeTypeRefContext)
}

func (s *PathExpressionContinuationContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACKET, 0)
}

func (s *PathExpressionContinuationContext) DesignRuleExpression() IDesignRuleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleExpressionContext)
}

func (s *PathExpressionContinuationContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACKET, 0)
}

func (s *PathExpressionContinuationContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(acmeParserSLASH)
}

func (s *PathExpressionContinuationContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserSLASH, i)
}

func (s *PathExpressionContinuationContext) AllPathExpressionContinuation() []IPathExpressionContinuationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPathExpressionContinuationContext)(nil)).Elem())
	var tst = make([]IPathExpressionContinuationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPathExpressionContinuationContext)
		}
	}

	return tst
}

func (s *PathExpressionContinuationContext) PathExpressionContinuation(i int) IPathExpressionContinuationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPathExpressionContinuationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPathExpressionContinuationContext)
}

func (s *PathExpressionContinuationContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(acmeParserELLIPSIS, 0)
}

func (s *PathExpressionContinuationContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *PathExpressionContinuationContext) SET_DECLARE() antlr.TerminalNode {
	return s.GetToken(acmeParserSET_DECLARE, 0)
}

func (s *PathExpressionContinuationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathExpressionContinuationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathExpressionContinuationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterPathExpressionContinuation(s)
	}
}

func (s *PathExpressionContinuationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitPathExpressionContinuation(s)
	}
}

func (p *acmeParser) PathExpressionContinuation() (localctx IPathExpressionContinuationContext) {
	this := p
	_ = this

	localctx = NewPathExpressionContinuationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, acmeParserRULE_pathExpressionContinuation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1606)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserATTACHEDPORTS, acmeParserATTACHEDROLES, acmeParserCOMPONENTS, acmeParserCONNECTORS, acmeParserGROUPS, acmeParserMEMBERS, acmeParserPORTS, acmeParserPROPERTIES, acmeParserREPRESENTATIONS, acmeParserROLES, acmeParserTYPE:
		{
			p.SetState(1584)
			p.SetReference()
		}
		p.SetState(1587)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserCOLON || _la == acmeParserSET_DECLARE {
			{
				p.SetState(1585)
				_la = p.GetTokenStream().LA(1)

				if !(_la == acmeParserCOLON || _la == acmeParserSET_DECLARE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1586)
				p.AcmeTypeRef()
			}

		}
		p.SetState(1593)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserLBRACKET {
			{
				p.SetState(1589)
				p.Match(acmeParserLBRACKET)
			}
			{
				p.SetState(1590)
				p.DesignRuleExpression()
			}
			{
				p.SetState(1591)
				p.Match(acmeParserRBRACKET)
			}

		}
		p.SetState(1599)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1595)
					p.Match(acmeParserSLASH)
				}
				{
					p.SetState(1596)
					p.PathExpressionContinuation()
				}

			}
			p.SetState(1601)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext())
		}

	case acmeParserELLIPSIS, acmeParserIDENTIFIER:
		p.SetState(1603)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserELLIPSIS {
			{
				p.SetState(1602)
				p.Match(acmeParserELLIPSIS)
			}

		}
		{
			p.SetState(1605)
			p.Reference()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralSetContext is an interface to support dynamic dispatch.
type ILiteralSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralSetContext differentiates from other interfaces.
	IsLiteralSetContext()
}

type LiteralSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralSetContext() *LiteralSetContext {
	var p = new(LiteralSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_literalSet
	return p
}

func (*LiteralSetContext) IsLiteralSetContext() {}

func NewLiteralSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralSetContext {
	var p = new(LiteralSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_literalSet

	return p
}

func (s *LiteralSetContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralSetContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *LiteralSetContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *LiteralSetContext) AllLiteralConstant() []ILiteralConstantContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralConstantContext)(nil)).Elem())
	var tst = make([]ILiteralConstantContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralConstantContext)
		}
	}

	return tst
}

func (s *LiteralSetContext) LiteralConstant(i int) ILiteralConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralConstantContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralConstantContext)
}

func (s *LiteralSetContext) AllReference() []IReferenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReferenceContext)(nil)).Elem())
	var tst = make([]IReferenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReferenceContext)
		}
	}

	return tst
}

func (s *LiteralSetContext) Reference(i int) IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *LiteralSetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *LiteralSetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *LiteralSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterLiteralSet(s)
	}
}

func (s *LiteralSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitLiteralSet(s)
	}
}

func (p *acmeParser) LiteralSet() (localctx ILiteralSetContext) {
	this := p
	_ = this

	localctx = NewLiteralSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, acmeParserRULE_literalSet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1627)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 239, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1608)
			p.Match(acmeParserLBRACE)
		}
		{
			p.SetState(1609)
			p.Match(acmeParserRBRACE)
		}

	case 2:
		{
			p.SetState(1610)
			p.Match(acmeParserLBRACE)
		}
		p.SetState(1613)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserCOMPONENT, acmeParserCONNECTOR, acmeParserDOUBLE, acmeParserELEMENT, acmeParserENUM, acmeParserFLOAT, acmeParserGROUP, acmeParserINT, acmeParserPORT, acmeParserPROPERTY, acmeParserRECORD, acmeParserROLE, acmeParserSEQUENCE, acmeParserSET, acmeParserSTRING, acmeParserSYSTEM, acmeParserTRUE, acmeParserFALSE, acmeParserBOOLEAN, acmeParserFLOATING_POINT_LITERAL, acmeParserINTEGER_LITERAL, acmeParserSTRING_LITERAL:
			{
				p.SetState(1611)
				p.LiteralConstant()
			}

		case acmeParserIDENTIFIER:
			{
				p.SetState(1612)
				p.Reference()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(1622)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserCOMMA {
			{
				p.SetState(1615)
				p.Match(acmeParserCOMMA)
			}
			p.SetState(1618)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserCOMPONENT, acmeParserCONNECTOR, acmeParserDOUBLE, acmeParserELEMENT, acmeParserENUM, acmeParserFLOAT, acmeParserGROUP, acmeParserINT, acmeParserPORT, acmeParserPROPERTY, acmeParserRECORD, acmeParserROLE, acmeParserSEQUENCE, acmeParserSET, acmeParserSTRING, acmeParserSYSTEM, acmeParserTRUE, acmeParserFALSE, acmeParserBOOLEAN, acmeParserFLOATING_POINT_LITERAL, acmeParserINTEGER_LITERAL, acmeParserSTRING_LITERAL:
				{
					p.SetState(1616)
					p.LiteralConstant()
				}

			case acmeParserIDENTIFIER:
				{
					p.SetState(1617)
					p.Reference()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1624)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1625)
			p.Match(acmeParserRBRACE)
		}

	}

	return localctx
}

// ILiteralSequenceContext is an interface to support dynamic dispatch.
type ILiteralSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralSequenceContext differentiates from other interfaces.
	IsLiteralSequenceContext()
}

type LiteralSequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralSequenceContext() *LiteralSequenceContext {
	var p = new(LiteralSequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_literalSequence
	return p
}

func (*LiteralSequenceContext) IsLiteralSequenceContext() {}

func NewLiteralSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralSequenceContext {
	var p = new(LiteralSequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_literalSequence

	return p
}

func (s *LiteralSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralSequenceContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(acmeParserLANGLE, 0)
}

func (s *LiteralSequenceContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(acmeParserRANGLE, 0)
}

func (s *LiteralSequenceContext) AllLiteralConstant() []ILiteralConstantContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralConstantContext)(nil)).Elem())
	var tst = make([]ILiteralConstantContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralConstantContext)
		}
	}

	return tst
}

func (s *LiteralSequenceContext) LiteralConstant(i int) ILiteralConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralConstantContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralConstantContext)
}

func (s *LiteralSequenceContext) AllReference() []IReferenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReferenceContext)(nil)).Elem())
	var tst = make([]IReferenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReferenceContext)
		}
	}

	return tst
}

func (s *LiteralSequenceContext) Reference(i int) IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *LiteralSequenceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(acmeParserCOMMA)
}

func (s *LiteralSequenceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserCOMMA, i)
}

func (s *LiteralSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterLiteralSequence(s)
	}
}

func (s *LiteralSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitLiteralSequence(s)
	}
}

func (p *acmeParser) LiteralSequence() (localctx ILiteralSequenceContext) {
	this := p
	_ = this

	localctx = NewLiteralSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, acmeParserRULE_literalSequence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1648)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 243, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1629)
			p.Match(acmeParserLANGLE)
		}
		{
			p.SetState(1630)
			p.Match(acmeParserRANGLE)
		}

	case 2:
		{
			p.SetState(1631)
			p.Match(acmeParserLANGLE)
		}
		p.SetState(1634)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserCOMPONENT, acmeParserCONNECTOR, acmeParserDOUBLE, acmeParserELEMENT, acmeParserENUM, acmeParserFLOAT, acmeParserGROUP, acmeParserINT, acmeParserPORT, acmeParserPROPERTY, acmeParserRECORD, acmeParserROLE, acmeParserSEQUENCE, acmeParserSET, acmeParserSTRING, acmeParserSYSTEM, acmeParserTRUE, acmeParserFALSE, acmeParserBOOLEAN, acmeParserFLOATING_POINT_LITERAL, acmeParserINTEGER_LITERAL, acmeParserSTRING_LITERAL:
			{
				p.SetState(1632)
				p.LiteralConstant()
			}

		case acmeParserIDENTIFIER:
			{
				p.SetState(1633)
				p.Reference()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(1643)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == acmeParserCOMMA {
			{
				p.SetState(1636)
				p.Match(acmeParserCOMMA)
			}
			p.SetState(1639)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case acmeParserCOMPONENT, acmeParserCONNECTOR, acmeParserDOUBLE, acmeParserELEMENT, acmeParserENUM, acmeParserFLOAT, acmeParserGROUP, acmeParserINT, acmeParserPORT, acmeParserPROPERTY, acmeParserRECORD, acmeParserROLE, acmeParserSEQUENCE, acmeParserSET, acmeParserSTRING, acmeParserSYSTEM, acmeParserTRUE, acmeParserFALSE, acmeParserBOOLEAN, acmeParserFLOATING_POINT_LITERAL, acmeParserINTEGER_LITERAL, acmeParserSTRING_LITERAL:
				{
					p.SetState(1637)
					p.LiteralConstant()
				}

			case acmeParserIDENTIFIER:
				{
					p.SetState(1638)
					p.Reference()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1645)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1646)
			p.Match(acmeParserRANGLE)
		}

	}

	return localctx
}

// ILiteralRecordEntryContext is an interface to support dynamic dispatch.
type ILiteralRecordEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralRecordEntryContext differentiates from other interfaces.
	IsLiteralRecordEntryContext()
}

type LiteralRecordEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralRecordEntryContext() *LiteralRecordEntryContext {
	var p = new(LiteralRecordEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_literalRecordEntry
	return p
}

func (*LiteralRecordEntryContext) IsLiteralRecordEntryContext() {}

func NewLiteralRecordEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralRecordEntryContext {
	var p = new(LiteralRecordEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_literalRecordEntry

	return p
}

func (s *LiteralRecordEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralRecordEntryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LiteralRecordEntryContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(acmeParserASSIGN, 0)
}

func (s *LiteralRecordEntryContext) LiteralConstant() ILiteralConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralConstantContext)
}

func (s *LiteralRecordEntryContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *LiteralRecordEntryContext) AcmePropertyTypeRef() IAcmePropertyTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeRefContext)
}

func (s *LiteralRecordEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralRecordEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralRecordEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterLiteralRecordEntry(s)
	}
}

func (s *LiteralRecordEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitLiteralRecordEntry(s)
	}
}

func (p *acmeParser) LiteralRecordEntry() (localctx ILiteralRecordEntryContext) {
	this := p
	_ = this

	localctx = NewLiteralRecordEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, acmeParserRULE_literalRecordEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1650)
		p.Identifier()
	}
	p.SetState(1653)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserCOLON {
		{
			p.SetState(1651)
			p.Match(acmeParserCOLON)
		}
		{
			p.SetState(1652)
			p.AcmePropertyTypeRef()
		}

	}
	{
		p.SetState(1655)
		p.Match(acmeParserASSIGN)
	}
	{
		p.SetState(1656)
		p.LiteralConstant()
	}

	return localctx
}

// ILiteralRecordContext is an interface to support dynamic dispatch.
type ILiteralRecordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralRecordContext differentiates from other interfaces.
	IsLiteralRecordContext()
}

type LiteralRecordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralRecordContext() *LiteralRecordContext {
	var p = new(LiteralRecordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_literalRecord
	return p
}

func (*LiteralRecordContext) IsLiteralRecordContext() {}

func NewLiteralRecordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralRecordContext {
	var p = new(LiteralRecordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_literalRecord

	return p
}

func (s *LiteralRecordContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralRecordContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACKET, 0)
}

func (s *LiteralRecordContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACKET, 0)
}

func (s *LiteralRecordContext) AllLiteralRecordEntry() []ILiteralRecordEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralRecordEntryContext)(nil)).Elem())
	var tst = make([]ILiteralRecordEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralRecordEntryContext)
		}
	}

	return tst
}

func (s *LiteralRecordContext) LiteralRecordEntry(i int) ILiteralRecordEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralRecordEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralRecordEntryContext)
}

func (s *LiteralRecordContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(acmeParserSEMICOLON)
}

func (s *LiteralRecordContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(acmeParserSEMICOLON, i)
}

func (s *LiteralRecordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralRecordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralRecordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterLiteralRecord(s)
	}
}

func (s *LiteralRecordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitLiteralRecord(s)
	}
}

func (p *acmeParser) LiteralRecord() (localctx ILiteralRecordContext) {
	this := p
	_ = this

	localctx = NewLiteralRecordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, acmeParserRULE_literalRecord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1658)
		p.Match(acmeParserLBRACKET)
	}
	p.SetState(1670)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == acmeParserIDENTIFIER {
		{
			p.SetState(1659)
			p.LiteralRecordEntry()
		}
		p.SetState(1664)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 245, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1660)
					p.Match(acmeParserSEMICOLON)
				}
				{
					p.SetState(1661)
					p.LiteralRecordEntry()
				}

			}
			p.SetState(1666)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 245, p.GetParserRuleContext())
		}
		p.SetState(1668)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserSEMICOLON {
			{
				p.SetState(1667)
				p.Match(acmeParserSEMICOLON)
			}

		}

	}
	{
		p.SetState(1672)
		p.Match(acmeParserRBRACKET)
	}

	return localctx
}

// ISetConstructorContext is an interface to support dynamic dispatch.
type ISetConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetConstructorContext differentiates from other interfaces.
	IsSetConstructorContext()
}

type SetConstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetConstructorContext() *SetConstructorContext {
	var p = new(SetConstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_setConstructor
	return p
}

func (*SetConstructorContext) IsSetConstructorContext() {}

func NewSetConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetConstructorContext {
	var p = new(SetConstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_setConstructor

	return p
}

func (s *SetConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *SetConstructorContext) SELECT() antlr.TerminalNode {
	return s.GetToken(acmeParserSELECT, 0)
}

func (s *SetConstructorContext) VariableSetDeclaration() IVariableSetDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableSetDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableSetDeclarationContext)
}

func (s *SetConstructorContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(acmeParserBIT_OR, 0)
}

func (s *SetConstructorContext) DesignRuleExpression() IDesignRuleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignRuleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesignRuleExpressionContext)
}

func (s *SetConstructorContext) COLLECT() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLLECT, 0)
}

func (s *SetConstructorContext) AllReference() []IReferenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReferenceContext)(nil)).Elem())
	var tst = make([]IReferenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReferenceContext)
		}
	}

	return tst
}

func (s *SetConstructorContext) Reference(i int) IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *SetConstructorContext) COLON() antlr.TerminalNode {
	return s.GetToken(acmeParserCOLON, 0)
}

func (s *SetConstructorContext) AcmeTypeRef() IAcmeTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmeTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmeTypeRefContext)
}

func (s *SetConstructorContext) IN() antlr.TerminalNode {
	return s.GetToken(acmeParserIN, 0)
}

func (s *SetConstructorContext) SetExpression() ISetExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetExpressionContext)
}

func (s *SetConstructorContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserLBRACE, 0)
}

func (s *SetConstructorContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(acmeParserRBRACE, 0)
}

func (s *SetConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterSetConstructor(s)
	}
}

func (s *SetConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitSetConstructor(s)
	}
}

func (p *acmeParser) SetConstructor() (localctx ISetConstructorContext) {
	this := p
	_ = this

	localctx = NewSetConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, acmeParserRULE_setConstructor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1701)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 253, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1675)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserLBRACE {
			{
				p.SetState(1674)
				p.Match(acmeParserLBRACE)
			}

		}
		{
			p.SetState(1677)
			p.Match(acmeParserSELECT)
		}
		{
			p.SetState(1678)
			p.VariableSetDeclaration()
		}
		{
			p.SetState(1679)
			p.Match(acmeParserBIT_OR)
		}
		{
			p.SetState(1680)
			p.DesignRuleExpression()
		}
		p.SetState(1682)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 249, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1681)
				p.Match(acmeParserRBRACE)
			}

		}

	case 2:
		p.SetState(1685)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == acmeParserLBRACE {
			{
				p.SetState(1684)
				p.Match(acmeParserLBRACE)
			}

		}
		{
			p.SetState(1687)
			p.Match(acmeParserCOLLECT)
		}
		{
			p.SetState(1688)
			p.Reference()
		}
		{
			p.SetState(1689)
			p.Match(acmeParserCOLON)
		}
		{
			p.SetState(1690)
			p.AcmeTypeRef()
		}
		{
			p.SetState(1691)
			p.Match(acmeParserIN)
		}
		p.SetState(1694)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case acmeParserCOLLECT, acmeParserLBRACE, acmeParserSELECT, acmeParserSLASH:
			{
				p.SetState(1692)
				p.SetExpression()
			}

		case acmeParserIDENTIFIER:
			{
				p.SetState(1693)
				p.Reference()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1696)
			p.Match(acmeParserBIT_OR)
		}
		{
			p.SetState(1697)
			p.DesignRuleExpression()
		}
		p.SetState(1699)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 252, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1698)
				p.Match(acmeParserRBRACE)
			}

		}

	}

	return localctx
}

// IAcmeTypeRefContext is an interface to support dynamic dispatch.
type IAcmeTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcmeTypeRefContext differentiates from other interfaces.
	IsAcmeTypeRefContext()
}

type AcmeTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcmeTypeRefContext() *AcmeTypeRefContext {
	var p = new(AcmeTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = acmeParserRULE_acmeTypeRef
	return p
}

func (*AcmeTypeRefContext) IsAcmeTypeRefContext() {}

func NewAcmeTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcmeTypeRefContext {
	var p = new(AcmeTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = acmeParserRULE_acmeTypeRef

	return p
}

func (s *AcmeTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *AcmeTypeRefContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(acmeParserSYSTEM, 0)
}

func (s *AcmeTypeRefContext) COMPONENT() antlr.TerminalNode {
	return s.GetToken(acmeParserCOMPONENT, 0)
}

func (s *AcmeTypeRefContext) GROUP() antlr.TerminalNode {
	return s.GetToken(acmeParserGROUP, 0)
}

func (s *AcmeTypeRefContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(acmeParserCONNECTOR, 0)
}

func (s *AcmeTypeRefContext) PORT() antlr.TerminalNode {
	return s.GetToken(acmeParserPORT, 0)
}

func (s *AcmeTypeRefContext) ROLE() antlr.TerminalNode {
	return s.GetToken(acmeParserROLE, 0)
}

func (s *AcmeTypeRefContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(acmeParserPROPERTY, 0)
}

func (s *AcmeTypeRefContext) ELEMENT() antlr.TerminalNode {
	return s.GetToken(acmeParserELEMENT, 0)
}

func (s *AcmeTypeRefContext) TYPE() antlr.TerminalNode {
	return s.GetToken(acmeParserTYPE, 0)
}

func (s *AcmeTypeRefContext) REPRESENTATION() antlr.TerminalNode {
	return s.GetToken(acmeParserREPRESENTATION, 0)
}

func (s *AcmeTypeRefContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *AcmeTypeRefContext) AcmePropertyTypeStructure() IAcmePropertyTypeStructureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcmePropertyTypeStructureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcmePropertyTypeStructureContext)
}

func (s *AcmeTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcmeTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcmeTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.EnterAcmeTypeRef(s)
	}
}

func (s *AcmeTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(acmeListener); ok {
		listenerT.ExitAcmeTypeRef(s)
	}
}

func (p *acmeParser) AcmeTypeRef() (localctx IAcmeTypeRefContext) {
	this := p
	_ = this

	localctx = NewAcmeTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, acmeParserRULE_acmeTypeRef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1715)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case acmeParserSYSTEM:
		{
			p.SetState(1703)
			p.Match(acmeParserSYSTEM)
		}

	case acmeParserCOMPONENT:
		{
			p.SetState(1704)
			p.Match(acmeParserCOMPONENT)
		}

	case acmeParserGROUP:
		{
			p.SetState(1705)
			p.Match(acmeParserGROUP)
		}

	case acmeParserCONNECTOR:
		{
			p.SetState(1706)
			p.Match(acmeParserCONNECTOR)
		}

	case acmeParserPORT:
		{
			p.SetState(1707)
			p.Match(acmeParserPORT)
		}

	case acmeParserROLE:
		{
			p.SetState(1708)
			p.Match(acmeParserROLE)
		}

	case acmeParserPROPERTY:
		{
			p.SetState(1709)
			p.Match(acmeParserPROPERTY)
		}

	case acmeParserELEMENT:
		{
			p.SetState(1710)
			p.Match(acmeParserELEMENT)
		}

	case acmeParserTYPE:
		{
			p.SetState(1711)
			p.Match(acmeParserTYPE)
		}

	case acmeParserREPRESENTATION:
		{
			p.SetState(1712)
			p.Match(acmeParserREPRESENTATION)
		}

	case acmeParserIDENTIFIER:
		{
			p.SetState(1713)
			p.Reference()
		}

	case acmeParserANY, acmeParserDOUBLE, acmeParserENUM, acmeParserFLOAT, acmeParserINT, acmeParserRECORD, acmeParserSEQUENCE, acmeParserSET, acmeParserSTRING, acmeParserBOOLEAN:
		{
			p.SetState(1714)
			p.AcmePropertyTypeStructure()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}
