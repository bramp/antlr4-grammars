// Code generated from VerilogParser.g4 by ANTLR 4.9.3. DO NOT EDIT.

package verilog // VerilogParser
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 384, 4186,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 4, 182, 9, 182, 4, 183,
	9, 183, 4, 184, 9, 184, 4, 185, 9, 185, 4, 186, 9, 186, 4, 187, 9, 187,
	4, 188, 9, 188, 4, 189, 9, 189, 4, 190, 9, 190, 4, 191, 9, 191, 4, 192,
	9, 192, 4, 193, 9, 193, 4, 194, 9, 194, 4, 195, 9, 195, 4, 196, 9, 196,
	4, 197, 9, 197, 4, 198, 9, 198, 4, 199, 9, 199, 4, 200, 9, 200, 4, 201,
	9, 201, 4, 202, 9, 202, 4, 203, 9, 203, 4, 204, 9, 204, 4, 205, 9, 205,
	4, 206, 9, 206, 4, 207, 9, 207, 4, 208, 9, 208, 4, 209, 9, 209, 4, 210,
	9, 210, 4, 211, 9, 211, 4, 212, 9, 212, 4, 213, 9, 213, 4, 214, 9, 214,
	4, 215, 9, 215, 4, 216, 9, 216, 4, 217, 9, 217, 4, 218, 9, 218, 4, 219,
	9, 219, 4, 220, 9, 220, 4, 221, 9, 221, 4, 222, 9, 222, 4, 223, 9, 223,
	4, 224, 9, 224, 4, 225, 9, 225, 4, 226, 9, 226, 4, 227, 9, 227, 4, 228,
	9, 228, 4, 229, 9, 229, 4, 230, 9, 230, 4, 231, 9, 231, 4, 232, 9, 232,
	4, 233, 9, 233, 4, 234, 9, 234, 4, 235, 9, 235, 4, 236, 9, 236, 4, 237,
	9, 237, 4, 238, 9, 238, 4, 239, 9, 239, 4, 240, 9, 240, 4, 241, 9, 241,
	4, 242, 9, 242, 4, 243, 9, 243, 4, 244, 9, 244, 4, 245, 9, 245, 4, 246,
	9, 246, 4, 247, 9, 247, 4, 248, 9, 248, 4, 249, 9, 249, 4, 250, 9, 250,
	4, 251, 9, 251, 4, 252, 9, 252, 4, 253, 9, 253, 4, 254, 9, 254, 4, 255,
	9, 255, 4, 256, 9, 256, 4, 257, 9, 257, 4, 258, 9, 258, 4, 259, 9, 259,
	4, 260, 9, 260, 4, 261, 9, 261, 4, 262, 9, 262, 4, 263, 9, 263, 4, 264,
	9, 264, 4, 265, 9, 265, 4, 266, 9, 266, 4, 267, 9, 267, 4, 268, 9, 268,
	4, 269, 9, 269, 4, 270, 9, 270, 4, 271, 9, 271, 4, 272, 9, 272, 4, 273,
	9, 273, 4, 274, 9, 274, 4, 275, 9, 275, 4, 276, 9, 276, 4, 277, 9, 277,
	4, 278, 9, 278, 4, 279, 9, 279, 4, 280, 9, 280, 4, 281, 9, 281, 4, 282,
	9, 282, 4, 283, 9, 283, 4, 284, 9, 284, 4, 285, 9, 285, 4, 286, 9, 286,
	4, 287, 9, 287, 4, 288, 9, 288, 4, 289, 9, 289, 4, 290, 9, 290, 4, 291,
	9, 291, 4, 292, 9, 292, 4, 293, 9, 293, 4, 294, 9, 294, 4, 295, 9, 295,
	4, 296, 9, 296, 4, 297, 9, 297, 4, 298, 9, 298, 4, 299, 9, 299, 4, 300,
	9, 300, 4, 301, 9, 301, 4, 302, 9, 302, 4, 303, 9, 303, 4, 304, 9, 304,
	4, 305, 9, 305, 4, 306, 9, 306, 4, 307, 9, 307, 4, 308, 9, 308, 4, 309,
	9, 309, 4, 310, 9, 310, 4, 311, 9, 311, 4, 312, 9, 312, 4, 313, 9, 313,
	4, 314, 9, 314, 4, 315, 9, 315, 4, 316, 9, 316, 4, 317, 9, 317, 4, 318,
	9, 318, 4, 319, 9, 319, 4, 320, 9, 320, 4, 321, 9, 321, 4, 322, 9, 322,
	4, 323, 9, 323, 4, 324, 9, 324, 4, 325, 9, 325, 4, 326, 9, 326, 4, 327,
	9, 327, 4, 328, 9, 328, 4, 329, 9, 329, 4, 330, 9, 330, 4, 331, 9, 331,
	4, 332, 9, 332, 4, 333, 9, 333, 4, 334, 9, 334, 4, 335, 9, 335, 4, 336,
	9, 336, 4, 337, 9, 337, 4, 338, 9, 338, 4, 339, 9, 339, 4, 340, 9, 340,
	4, 341, 9, 341, 4, 342, 9, 342, 4, 343, 9, 343, 4, 344, 9, 344, 4, 345,
	9, 345, 4, 346, 9, 346, 4, 347, 9, 347, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5,
	2, 700, 10, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 4, 5, 4, 707, 10, 4, 3, 4, 3,
	4, 7, 4, 711, 10, 4, 12, 4, 14, 4, 714, 11, 4, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 5, 5, 721, 10, 5, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 728, 10, 6,
	3, 6, 3, 6, 3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 739, 10, 8,
	3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 747, 10, 8, 3, 9, 3, 9, 3, 10,
	3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3,
	10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 769, 10, 10, 3, 11,
	3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3,
	11, 5, 11, 783, 10, 11, 3, 12, 3, 12, 3, 13, 3, 13, 3, 14, 3, 14, 3, 15,
	3, 15, 5, 15, 793, 10, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16, 800,
	10, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16,
	810, 10, 16, 3, 16, 3, 16, 3, 16, 5, 16, 815, 10, 16, 3, 17, 3, 17, 3,
	18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 828,
	10, 18, 5, 18, 830, 10, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3,
	18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 844, 10, 18, 5, 18, 846,
	10, 18, 3, 18, 3, 18, 3, 18, 5, 18, 851, 10, 18, 3, 19, 3, 19, 3, 20, 3,
	20, 3, 21, 3, 21, 3, 22, 3, 22, 5, 22, 861, 10, 22, 3, 23, 3, 23, 3, 23,
	3, 23, 3, 23, 5, 23, 868, 10, 23, 3, 23, 3, 23, 3, 24, 3, 24, 3, 25, 3,
	25, 3, 25, 3, 25, 3, 25, 5, 25, 879, 10, 25, 3, 25, 3, 25, 3, 26, 3, 26,
	3, 27, 3, 27, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 30, 3,
	30, 3, 31, 3, 31, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32, 903, 10, 32,
	3, 33, 3, 33, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3,
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34,
	3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3,
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34,
	3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3,
	34, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 962, 10, 34, 3, 35, 3, 35, 3, 36,
	3, 36, 3, 37, 3, 37, 3, 38, 3, 38, 3, 39, 3, 39, 3, 40, 3, 40, 3, 41, 3,
	41, 5, 41, 978, 10, 41, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 43, 3, 43,
	3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5,
	43, 997, 10, 43, 3, 44, 3, 44, 3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 5, 47, 1016,
	10, 47, 3, 47, 3, 47, 3, 47, 5, 47, 1021, 10, 47, 3, 48, 3, 48, 3, 48,
	7, 48, 1026, 10, 48, 12, 48, 14, 48, 1029, 11, 48, 3, 49, 3, 49, 5, 49,
	1033, 10, 49, 3, 50, 3, 50, 3, 51, 3, 51, 3, 51, 3, 52, 3, 52, 3, 52, 3,
	53, 3, 53, 3, 53, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55,
	3, 56, 3, 56, 3, 56, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3,
	57, 3, 58, 3, 58, 3, 58, 7, 58, 1068, 10, 58, 12, 58, 14, 58, 1071, 11,
	58, 3, 59, 3, 59, 3, 59, 5, 59, 1076, 10, 59, 3, 60, 3, 60, 3, 60, 3, 60,
	3, 60, 3, 60, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3,
	62, 3, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63,
	3, 63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 65, 7, 65, 1111, 10,
	65, 12, 65, 14, 65, 1114, 11, 65, 3, 66, 3, 66, 3, 66, 5, 66, 1119, 10,
	66, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 7, 67, 1126, 10, 67, 12, 67, 14,
	67, 1129, 11, 67, 3, 67, 3, 67, 3, 67, 3, 67, 7, 67, 1135, 10, 67, 12,
	67, 14, 67, 1138, 11, 67, 5, 67, 1140, 10, 67, 3, 67, 3, 67, 3, 68, 3,
	68, 3, 68, 3, 68, 3, 69, 7, 69, 1149, 10, 69, 12, 69, 14, 69, 1152, 11,
	69, 3, 69, 3, 69, 3, 70, 3, 70, 5, 70, 1158, 10, 70, 3, 71, 7, 71, 1161,
	10, 71, 12, 71, 14, 71, 1164, 11, 71, 3, 71, 3, 71, 3, 71, 5, 71, 1169,
	10, 71, 3, 71, 3, 71, 3, 71, 7, 71, 1174, 10, 71, 12, 71, 14, 71, 1177,
	11, 71, 3, 71, 3, 71, 3, 71, 7, 71, 1182, 10, 71, 12, 71, 14, 71, 1185,
	11, 71, 3, 71, 3, 71, 3, 71, 5, 71, 1190, 10, 71, 3, 71, 5, 71, 1193, 10,
	71, 3, 71, 3, 71, 7, 71, 1197, 10, 71, 12, 71, 14, 71, 1200, 11, 71, 3,
	71, 3, 71, 5, 71, 1204, 10, 71, 3, 72, 3, 72, 3, 73, 3, 73, 3, 73, 3, 73,
	3, 73, 7, 73, 1213, 10, 73, 12, 73, 14, 73, 1216, 11, 73, 3, 73, 3, 73,
	3, 74, 3, 74, 3, 74, 3, 74, 7, 74, 1224, 10, 74, 12, 74, 14, 74, 1227,
	11, 74, 3, 74, 3, 74, 3, 75, 3, 75, 3, 75, 3, 75, 7, 75, 1235, 10, 75,
	12, 75, 14, 75, 1238, 11, 75, 3, 75, 3, 75, 3, 75, 3, 75, 5, 75, 1244,
	10, 75, 3, 76, 5, 76, 1247, 10, 76, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76,
	1253, 10, 76, 3, 76, 3, 76, 5, 76, 1257, 10, 76, 3, 77, 3, 77, 3, 77, 3,
	77, 3, 77, 7, 77, 1264, 10, 77, 12, 77, 14, 77, 1267, 11, 77, 3, 77, 3,
	77, 5, 77, 1271, 10, 77, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 5, 78, 1278,
	10, 78, 3, 79, 7, 79, 1281, 10, 79, 12, 79, 14, 79, 1284, 11, 79, 3, 79,
	3, 79, 7, 79, 1288, 10, 79, 12, 79, 14, 79, 1291, 11, 79, 3, 79, 3, 79,
	7, 79, 1295, 10, 79, 12, 79, 14, 79, 1298, 11, 79, 3, 79, 5, 79, 1301,
	10, 79, 3, 80, 3, 80, 3, 80, 3, 80, 5, 80, 1307, 10, 80, 3, 81, 7, 81,
	1310, 10, 81, 12, 81, 14, 81, 1313, 11, 81, 3, 81, 3, 81, 7, 81, 1317,
	10, 81, 12, 81, 14, 81, 1320, 11, 81, 3, 81, 3, 81, 3, 81, 3, 81, 7, 81,
	1326, 10, 81, 12, 81, 14, 81, 1329, 11, 81, 3, 81, 3, 81, 7, 81, 1333,
	10, 81, 12, 81, 14, 81, 1336, 11, 81, 3, 81, 3, 81, 7, 81, 1340, 10, 81,
	12, 81, 14, 81, 1343, 11, 81, 3, 81, 3, 81, 7, 81, 1347, 10, 81, 12, 81,
	14, 81, 1350, 11, 81, 3, 81, 3, 81, 7, 81, 1354, 10, 81, 12, 81, 14, 81,
	1357, 11, 81, 3, 81, 3, 81, 7, 81, 1361, 10, 81, 12, 81, 14, 81, 1364,
	11, 81, 3, 81, 3, 81, 7, 81, 1368, 10, 81, 12, 81, 14, 81, 1371, 11, 81,
	3, 81, 3, 81, 7, 81, 1375, 10, 81, 12, 81, 14, 81, 1378, 11, 81, 3, 81,
	5, 81, 1381, 10, 81, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3,
	82, 3, 82, 3, 82, 5, 82, 1393, 10, 82, 3, 83, 3, 83, 3, 83, 3, 83, 7, 83,
	1399, 10, 83, 12, 83, 14, 83, 1402, 11, 83, 3, 83, 3, 83, 3, 83, 3, 83,
	7, 83, 1408, 10, 83, 12, 83, 14, 83, 1411, 11, 83, 3, 83, 5, 83, 1414,
	10, 83, 3, 84, 3, 84, 3, 84, 3, 84, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85,
	7, 85, 1425, 10, 85, 12, 85, 14, 85, 1428, 11, 85, 3, 85, 3, 85, 3, 86,
	3, 86, 3, 86, 3, 86, 5, 86, 1436, 10, 86, 3, 86, 7, 86, 1439, 10, 86, 12,
	86, 14, 86, 1442, 11, 86, 3, 86, 3, 86, 3, 87, 3, 87, 3, 87, 3, 87, 3,
	87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87,
	5, 87, 1461, 10, 87, 3, 88, 3, 88, 3, 89, 3, 89, 3, 89, 3, 90, 3, 90, 3,
	90, 7, 90, 1471, 10, 90, 12, 90, 14, 90, 1474, 11, 90, 3, 91, 3, 91, 3,
	91, 3, 91, 5, 91, 1480, 10, 91, 3, 91, 3, 91, 3, 92, 3, 92, 7, 92, 1486,
	10, 92, 12, 92, 14, 92, 1489, 11, 92, 3, 93, 3, 93, 3, 93, 3, 93, 5, 93,
	1495, 10, 93, 3, 93, 3, 93, 3, 93, 5, 93, 1500, 10, 93, 3, 94, 3, 94, 5,
	94, 1504, 10, 94, 3, 94, 5, 94, 1507, 10, 94, 3, 94, 3, 94, 3, 94, 3, 94,
	3, 94, 5, 94, 1514, 10, 94, 3, 95, 3, 95, 5, 95, 1518, 10, 95, 3, 95, 5,
	95, 1521, 10, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 5, 95, 1528, 10, 95,
	3, 96, 3, 96, 5, 96, 1532, 10, 96, 3, 96, 3, 96, 3, 96, 3, 97, 3, 97, 3,
	98, 3, 98, 5, 98, 1541, 10, 98, 3, 98, 5, 98, 1544, 10, 98, 3, 98, 5, 98,
	1547, 10, 98, 3, 98, 3, 98, 3, 99, 3, 99, 5, 99, 1553, 10, 99, 3, 99, 5,
	99, 1556, 10, 99, 3, 99, 5, 99, 1559, 10, 99, 3, 99, 3, 99, 3, 100, 3,
	100, 5, 100, 1565, 10, 100, 3, 100, 5, 100, 1568, 10, 100, 3, 100, 5, 100,
	1571, 10, 100, 3, 100, 3, 100, 3, 100, 3, 100, 5, 100, 1577, 10, 100, 3,
	100, 5, 100, 1580, 10, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 5,
	100, 1587, 10, 100, 3, 101, 3, 101, 3, 101, 3, 101, 3, 102, 3, 102, 3,
	102, 3, 102, 3, 103, 3, 103, 5, 103, 1599, 10, 103, 3, 103, 5, 103, 1602,
	10, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 5, 103, 1609, 10, 103,
	3, 103, 5, 103, 1612, 10, 103, 3, 103, 5, 103, 1615, 10, 103, 3, 103, 3,
	103, 3, 103, 3, 103, 3, 103, 5, 103, 1622, 10, 103, 3, 103, 5, 103, 1625,
	10, 103, 3, 103, 3, 103, 5, 103, 1629, 10, 103, 3, 103, 3, 103, 3, 103,
	3, 103, 3, 103, 5, 103, 1636, 10, 103, 3, 103, 5, 103, 1639, 10, 103, 3,
	103, 5, 103, 1642, 10, 103, 3, 103, 3, 103, 5, 103, 1646, 10, 103, 3, 103,
	3, 103, 3, 103, 3, 103, 3, 103, 5, 103, 1653, 10, 103, 3, 103, 5, 103,
	1656, 10, 103, 3, 103, 5, 103, 1659, 10, 103, 3, 103, 3, 103, 3, 103, 3,
	103, 3, 103, 5, 103, 1666, 10, 103, 3, 103, 5, 103, 1669, 10, 103, 3, 103,
	5, 103, 1672, 10, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 5, 103,
	1679, 10, 103, 3, 103, 5, 103, 1682, 10, 103, 3, 103, 5, 103, 1685, 10,
	103, 3, 103, 3, 103, 5, 103, 1689, 10, 103, 3, 103, 3, 103, 3, 103, 3,
	103, 3, 103, 5, 103, 1696, 10, 103, 3, 103, 5, 103, 1699, 10, 103, 3, 103,
	5, 103, 1702, 10, 103, 3, 103, 3, 103, 5, 103, 1706, 10, 103, 3, 103, 3,
	103, 3, 103, 5, 103, 1711, 10, 103, 3, 104, 3, 104, 3, 104, 3, 104, 3,
	105, 3, 105, 3, 105, 3, 105, 3, 106, 3, 106, 5, 106, 1723, 10, 106, 3,
	106, 5, 106, 1726, 10, 106, 3, 106, 3, 106, 3, 106, 3, 107, 3, 107, 3,
	107, 3, 107, 3, 108, 3, 108, 3, 109, 3, 109, 3, 110, 3, 110, 7, 110, 1741,
	10, 110, 12, 110, 14, 110, 1744, 11, 110, 3, 110, 3, 110, 3, 110, 3, 110,
	5, 110, 1750, 10, 110, 3, 111, 3, 111, 7, 111, 1754, 10, 111, 12, 111,
	14, 111, 1757, 11, 111, 3, 111, 3, 111, 3, 111, 3, 111, 5, 111, 1763, 10,
	111, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3,
	112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3,
	112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3,
	112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3,
	112, 5, 112, 1801, 10, 112, 3, 113, 3, 113, 3, 114, 3, 114, 3, 115, 3,
	115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 5, 115, 1816,
	10, 115, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116,
	3, 116, 5, 116, 1827, 10, 116, 5, 116, 1829, 10, 116, 3, 116, 3, 116, 5,
	116, 1833, 10, 116, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3,
	117, 5, 117, 1842, 10, 117, 3, 117, 3, 117, 5, 117, 1846, 10, 117, 3, 118,
	3, 118, 3, 118, 5, 118, 1851, 10, 118, 3, 119, 3, 119, 3, 119, 7, 119,
	1856, 10, 119, 12, 119, 14, 119, 1859, 11, 119, 3, 120, 3, 120, 7, 120,
	1863, 10, 120, 12, 120, 14, 120, 1866, 11, 120, 3, 120, 3, 120, 3, 120,
	7, 120, 1871, 10, 120, 12, 120, 14, 120, 1874, 11, 120, 7, 120, 1876, 10,
	120, 12, 120, 14, 120, 1879, 11, 120, 3, 121, 3, 121, 3, 121, 7, 121, 1884,
	10, 121, 12, 121, 14, 121, 1887, 11, 121, 3, 122, 3, 122, 7, 122, 1891,
	10, 122, 12, 122, 14, 122, 1894, 11, 122, 3, 122, 3, 122, 3, 122, 7, 122,
	1899, 10, 122, 12, 122, 14, 122, 1902, 11, 122, 7, 122, 1904, 10, 122,
	12, 122, 14, 122, 1907, 11, 122, 3, 123, 3, 123, 3, 123, 7, 123, 1912,
	10, 123, 12, 123, 14, 123, 1915, 11, 123, 3, 124, 3, 124, 3, 124, 7, 124,
	1920, 10, 124, 12, 124, 14, 124, 1923, 11, 124, 3, 125, 3, 125, 3, 125,
	7, 125, 1928, 10, 125, 12, 125, 14, 125, 1931, 11, 125, 3, 126, 3, 126,
	3, 126, 7, 126, 1936, 10, 126, 12, 126, 14, 126, 1939, 11, 126, 3, 127,
	3, 127, 3, 127, 7, 127, 1944, 10, 127, 12, 127, 14, 127, 1947, 11, 127,
	3, 128, 3, 128, 3, 128, 5, 128, 1952, 10, 128, 3, 128, 3, 128, 3, 128,
	3, 128, 5, 128, 1958, 10, 128, 7, 128, 1960, 10, 128, 12, 128, 14, 128,
	1963, 11, 128, 3, 129, 3, 129, 3, 129, 3, 129, 3, 130, 3, 130, 3, 130,
	3, 130, 3, 131, 3, 131, 3, 131, 3, 131, 3, 132, 3, 132, 3, 132, 3, 132,
	3, 132, 5, 132, 1982, 10, 132, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133,
	3, 133, 5, 133, 1990, 10, 133, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133,
	3, 133, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133, 5, 133, 2003, 10, 133,
	3, 133, 3, 133, 5, 133, 2007, 10, 133, 3, 134, 3, 134, 3, 135, 3, 135,
	3, 136, 3, 136, 3, 137, 3, 137, 3, 137, 3, 137, 3, 137, 3, 137, 3, 138,
	3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 139, 3, 139, 5, 139, 2029, 10,
	139, 3, 139, 5, 139, 2032, 10, 139, 3, 139, 3, 139, 3, 139, 3, 139, 7,
	139, 2038, 10, 139, 12, 139, 14, 139, 2041, 11, 139, 3, 139, 3, 139, 3,
	139, 3, 139, 3, 139, 5, 139, 2048, 10, 139, 3, 139, 5, 139, 2051, 10, 139,
	3, 139, 3, 139, 3, 139, 3, 139, 3, 139, 3, 139, 7, 139, 2059, 10, 139,
	12, 139, 14, 139, 2062, 11, 139, 3, 139, 3, 139, 3, 139, 5, 139, 2067,
	10, 139, 3, 140, 3, 140, 7, 140, 2071, 10, 140, 12, 140, 14, 140, 2074,
	11, 140, 3, 140, 3, 140, 3, 140, 5, 140, 2079, 10, 140, 3, 141, 7, 141,
	2082, 10, 141, 12, 141, 14, 141, 2085, 11, 141, 3, 141, 3, 141, 3, 141,
	7, 141, 2090, 10, 141, 12, 141, 14, 141, 2093, 11, 141, 3, 141, 7, 141,
	2096, 10, 141, 12, 141, 14, 141, 2099, 11, 141, 3, 142, 5, 142, 2102, 10,
	142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 5, 142, 2109, 10, 142, 3,
	143, 3, 143, 5, 143, 2113, 10, 143, 3, 143, 3, 143, 3, 143, 7, 143, 2118,
	10, 143, 12, 143, 14, 143, 2121, 11, 143, 3, 143, 3, 143, 3, 143, 3, 143,
	3, 143, 5, 143, 2128, 10, 143, 3, 143, 3, 143, 3, 143, 5, 143, 2133, 10,
	143, 3, 143, 3, 143, 3, 143, 7, 143, 2138, 10, 143, 12, 143, 14, 143, 2141,
	11, 143, 3, 143, 3, 143, 3, 143, 5, 143, 2146, 10, 143, 3, 144, 3, 144,
	7, 144, 2150, 10, 144, 12, 144, 14, 144, 2153, 11, 144, 3, 144, 3, 144,
	3, 144, 3, 144, 7, 144, 2159, 10, 144, 12, 144, 14, 144, 2162, 11, 144,
	3, 144, 3, 144, 3, 144, 3, 144, 7, 144, 2168, 10, 144, 12, 144, 14, 144,
	2171, 11, 144, 3, 144, 3, 144, 3, 144, 5, 144, 2176, 10, 144, 3, 145, 3,
	145, 3, 145, 7, 145, 2181, 10, 145, 12, 145, 14, 145, 2184, 11, 145, 3,
	146, 7, 146, 2187, 10, 146, 12, 146, 14, 146, 2190, 11, 146, 3, 146, 3,
	146, 7, 146, 2194, 10, 146, 12, 146, 14, 146, 2197, 11, 146, 3, 146, 3,
	146, 7, 146, 2201, 10, 146, 12, 146, 14, 146, 2204, 11, 146, 3, 146, 5,
	146, 2207, 10, 146, 3, 147, 3, 147, 5, 147, 2211, 10, 147, 3, 147, 5, 147,
	2214, 10, 147, 3, 147, 5, 147, 2217, 10, 147, 3, 147, 3, 147, 3, 147, 3,
	147, 3, 147, 5, 147, 2224, 10, 147, 3, 148, 3, 148, 5, 148, 2228, 10, 148,
	3, 148, 5, 148, 2231, 10, 148, 3, 148, 5, 148, 2234, 10, 148, 3, 148, 3,
	148, 3, 148, 3, 148, 3, 148, 5, 148, 2241, 10, 148, 3, 149, 3, 149, 5,
	149, 2245, 10, 149, 3, 149, 5, 149, 2248, 10, 149, 3, 149, 5, 149, 2251,
	10, 149, 3, 149, 3, 149, 3, 149, 3, 149, 3, 149, 5, 149, 2258, 10, 149,
	3, 150, 3, 150, 3, 151, 7, 151, 2263, 10, 151, 12, 151, 14, 151, 2266,
	11, 151, 3, 151, 3, 151, 5, 151, 2270, 10, 151, 3, 151, 5, 151, 2273, 10,
	151, 3, 151, 3, 151, 3, 151, 3, 151, 7, 151, 2279, 10, 151, 12, 151, 14,
	151, 2282, 11, 151, 3, 151, 3, 151, 3, 151, 3, 151, 3, 151, 7, 151, 2289,
	10, 151, 12, 151, 14, 151, 2292, 11, 151, 3, 151, 3, 151, 3, 151, 3, 151,
	3, 151, 7, 151, 2299, 10, 151, 12, 151, 14, 151, 2302, 11, 151, 3, 151,
	3, 151, 3, 151, 3, 151, 3, 151, 7, 151, 2309, 10, 151, 12, 151, 14, 151,
	2312, 11, 151, 3, 151, 3, 151, 3, 151, 3, 151, 3, 151, 7, 151, 2319, 10,
	151, 12, 151, 14, 151, 2322, 11, 151, 3, 151, 3, 151, 7, 151, 2326, 10,
	151, 12, 151, 14, 151, 2329, 11, 151, 3, 151, 3, 151, 3, 151, 3, 151, 7,
	151, 2335, 10, 151, 12, 151, 14, 151, 2338, 11, 151, 3, 151, 3, 151, 3,
	151, 5, 151, 2343, 10, 151, 3, 152, 3, 152, 3, 152, 7, 152, 2348, 10, 152,
	12, 152, 14, 152, 2351, 11, 152, 3, 153, 3, 153, 3, 153, 7, 153, 2356,
	10, 153, 12, 153, 14, 153, 2359, 11, 153, 3, 154, 3, 154, 7, 154, 2363,
	10, 154, 12, 154, 14, 154, 2366, 11, 154, 3, 155, 3, 155, 7, 155, 2370,
	10, 155, 12, 155, 14, 155, 2373, 11, 155, 3, 156, 3, 156, 5, 156, 2377,
	10, 156, 3, 156, 3, 156, 3, 156, 7, 156, 2382, 10, 156, 12, 156, 14, 156,
	2385, 11, 156, 3, 156, 3, 156, 3, 156, 3, 156, 5, 156, 2391, 10, 156, 3,
	156, 5, 156, 2394, 10, 156, 3, 156, 3, 156, 3, 156, 7, 156, 2399, 10, 156,
	12, 156, 14, 156, 2402, 11, 156, 3, 156, 3, 156, 3, 156, 3, 156, 5, 156,
	2408, 10, 156, 3, 156, 3, 156, 3, 156, 7, 156, 2413, 10, 156, 12, 156,
	14, 156, 2416, 11, 156, 3, 156, 3, 156, 3, 156, 3, 156, 5, 156, 2422, 10,
	156, 3, 156, 5, 156, 2425, 10, 156, 3, 156, 3, 156, 3, 156, 7, 156, 2430,
	10, 156, 12, 156, 14, 156, 2433, 11, 156, 3, 156, 3, 156, 3, 156, 3, 156,
	5, 156, 2439, 10, 156, 3, 156, 5, 156, 2442, 10, 156, 3, 156, 3, 156, 3,
	156, 7, 156, 2447, 10, 156, 12, 156, 14, 156, 2450, 11, 156, 3, 156, 3,
	156, 3, 156, 3, 156, 5, 156, 2456, 10, 156, 3, 156, 3, 156, 3, 156, 7,
	156, 2461, 10, 156, 12, 156, 14, 156, 2464, 11, 156, 3, 156, 3, 156, 3,
	156, 3, 156, 3, 156, 3, 156, 7, 156, 2472, 10, 156, 12, 156, 14, 156, 2475,
	11, 156, 3, 156, 3, 156, 3, 156, 3, 156, 5, 156, 2481, 10, 156, 3, 156,
	3, 156, 3, 156, 7, 156, 2486, 10, 156, 12, 156, 14, 156, 2489, 11, 156,
	3, 156, 3, 156, 3, 156, 3, 156, 5, 156, 2495, 10, 156, 3, 156, 3, 156,
	3, 156, 7, 156, 2500, 10, 156, 12, 156, 14, 156, 2503, 11, 156, 3, 156,
	3, 156, 5, 156, 2507, 10, 156, 3, 157, 5, 157, 2510, 10, 157, 3, 157, 3,
	157, 3, 157, 3, 157, 3, 157, 3, 157, 3, 157, 3, 157, 3, 157, 3, 157, 3,
	158, 5, 158, 2523, 10, 158, 3, 158, 3, 158, 3, 158, 3, 158, 3, 158, 3,
	158, 3, 158, 3, 158, 3, 159, 5, 159, 2534, 10, 159, 3, 159, 3, 159, 3,
	159, 3, 159, 3, 159, 3, 159, 3, 159, 3, 159, 3, 160, 5, 160, 2545, 10,
	160, 3, 160, 3, 160, 3, 160, 3, 160, 3, 160, 3, 160, 7, 160, 2553, 10,
	160, 12, 160, 14, 160, 2556, 11, 160, 3, 160, 3, 160, 3, 161, 5, 161, 2561,
	10, 161, 3, 161, 3, 161, 3, 161, 3, 161, 7, 161, 2567, 10, 161, 12, 161,
	14, 161, 2570, 11, 161, 3, 161, 3, 161, 3, 161, 3, 161, 3, 162, 5, 162,
	2577, 10, 162, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 3, 163,
	5, 163, 2586, 10, 163, 3, 163, 3, 163, 3, 163, 3, 163, 3, 163, 3, 163,
	3, 163, 3, 163, 3, 164, 5, 164, 2597, 10, 164, 3, 164, 3, 164, 3, 164,
	3, 164, 3, 165, 3, 165, 5, 165, 2605, 10, 165, 3, 166, 3, 166, 3, 166,
	3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166,
	3, 166, 3, 166, 3, 166, 3, 166, 5, 166, 2623, 10, 166, 3, 167, 3, 167,
	3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167,
	3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 5, 167, 2641, 10, 167, 3, 168,
	3, 168, 3, 169, 3, 169, 3, 170, 3, 170, 3, 171, 3, 171, 3, 172, 3, 172,
	3, 173, 3, 173, 3, 174, 3, 174, 3, 175, 3, 175, 3, 176, 3, 176, 3, 177,
	3, 177, 3, 178, 3, 178, 3, 179, 3, 179, 3, 180, 3, 180, 3, 181, 3, 181,
	5, 181, 2671, 10, 181, 3, 181, 3, 181, 3, 181, 7, 181, 2676, 10, 181, 12,
	181, 14, 181, 2679, 11, 181, 3, 181, 3, 181, 3, 182, 3, 182, 3, 182, 3,
	182, 3, 182, 3, 183, 3, 183, 3, 183, 7, 183, 2691, 10, 183, 12, 183, 14,
	183, 2694, 11, 183, 3, 183, 3, 183, 3, 183, 7, 183, 2699, 10, 183, 12,
	183, 14, 183, 2702, 11, 183, 5, 183, 2704, 10, 183, 3, 184, 3, 184, 3,
	185, 3, 185, 3, 185, 3, 185, 5, 185, 2712, 10, 185, 3, 185, 3, 185, 3,
	186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 187, 3, 187, 5, 187, 2723, 10,
	187, 3, 188, 3, 188, 3, 188, 7, 188, 2728, 10, 188, 12, 188, 14, 188, 2731,
	11, 188, 3, 188, 3, 188, 3, 188, 7, 188, 2736, 10, 188, 12, 188, 14, 188,
	2739, 11, 188, 5, 188, 2741, 10, 188, 3, 189, 7, 189, 2744, 10, 189, 12,
	189, 14, 189, 2747, 11, 189, 3, 189, 5, 189, 2750, 10, 189, 3, 190, 7,
	190, 2753, 10, 190, 12, 190, 14, 190, 2756, 11, 190, 3, 190, 3, 190, 3,
	190, 3, 190, 5, 190, 2762, 10, 190, 3, 190, 3, 190, 3, 191, 3, 191, 7,
	191, 2768, 10, 191, 12, 191, 14, 191, 2771, 11, 191, 3, 191, 3, 191, 3,
	192, 3, 192, 3, 192, 3, 192, 3, 193, 3, 193, 3, 193, 7, 193, 2782, 10,
	193, 12, 193, 14, 193, 2785, 11, 193, 3, 194, 3, 194, 3, 194, 3, 194, 3,
	194, 3, 194, 3, 194, 3, 194, 3, 194, 3, 194, 3, 195, 3, 195, 3, 195, 3,
	195, 3, 196, 3, 196, 3, 196, 3, 196, 7, 196, 2805, 10, 196, 12, 196, 14,
	196, 2808, 11, 196, 3, 196, 3, 196, 5, 196, 2812, 10, 196, 3, 196, 3, 196,
	3, 196, 7, 196, 2817, 10, 196, 12, 196, 14, 196, 2820, 11, 196, 3, 196,
	3, 196, 3, 196, 3, 196, 3, 196, 7, 196, 2827, 10, 196, 12, 196, 14, 196,
	2830, 11, 196, 3, 196, 3, 196, 3, 196, 3, 196, 7, 196, 2836, 10, 196, 12,
	196, 14, 196, 2839, 11, 196, 3, 197, 3, 197, 3, 197, 3, 197, 3, 198, 3,
	198, 5, 198, 2847, 10, 198, 3, 199, 3, 199, 5, 199, 2851, 10, 199, 3, 200,
	3, 200, 3, 200, 3, 200, 3, 200, 3, 200, 3, 200, 5, 200, 2860, 10, 200,
	3, 201, 3, 201, 3, 201, 7, 201, 2865, 10, 201, 12, 201, 14, 201, 2868,
	11, 201, 3, 201, 3, 201, 3, 201, 3, 201, 3, 201, 5, 201, 2875, 10, 201,
	3, 201, 5, 201, 2878, 10, 201, 3, 202, 3, 202, 3, 202, 3, 202, 5, 202,
	2884, 10, 202, 3, 202, 7, 202, 2887, 10, 202, 12, 202, 14, 202, 2890, 11,
	202, 3, 202, 5, 202, 2893, 10, 202, 3, 203, 3, 203, 5, 203, 2897, 10, 203,
	3, 204, 3, 204, 5, 204, 2901, 10, 204, 3, 204, 5, 204, 2904, 10, 204, 3,
	204, 3, 204, 3, 204, 3, 205, 3, 205, 3, 205, 7, 205, 2912, 10, 205, 12,
	205, 14, 205, 2915, 11, 205, 3, 206, 3, 206, 3, 206, 3, 206, 3, 207, 3,
	207, 3, 207, 3, 208, 3, 208, 3, 208, 3, 209, 3, 209, 3, 209, 5, 209, 2930,
	10, 209, 3, 209, 3, 209, 3, 210, 3, 210, 3, 210, 5, 210, 2937, 10, 210,
	3, 210, 3, 210, 3, 211, 3, 211, 3, 211, 3, 211, 3, 211, 3, 211, 3, 211,
	3, 211, 3, 211, 3, 211, 3, 211, 3, 211, 5, 211, 2953, 10, 211, 3, 212,
	3, 212, 3, 212, 3, 212, 3, 213, 3, 213, 3, 213, 3, 213, 7, 213, 2963, 10,
	213, 12, 213, 14, 213, 2966, 11, 213, 5, 213, 2968, 10, 213, 3, 213, 7,
	213, 2971, 10, 213, 12, 213, 14, 213, 2974, 11, 213, 3, 213, 3, 213, 3,
	214, 3, 214, 3, 214, 3, 214, 7, 214, 2982, 10, 214, 12, 214, 14, 214, 2985,
	11, 214, 5, 214, 2987, 10, 214, 3, 214, 7, 214, 2990, 10, 214, 12, 214,
	14, 214, 2993, 11, 214, 3, 214, 3, 214, 3, 215, 7, 215, 2998, 10, 215,
	12, 215, 14, 215, 3001, 11, 215, 3, 215, 3, 215, 3, 215, 3, 215, 7, 215,
	3007, 10, 215, 12, 215, 14, 215, 3010, 11, 215, 3, 215, 3, 215, 7, 215,
	3014, 10, 215, 12, 215, 14, 215, 3017, 11, 215, 3, 215, 3, 215, 7, 215,
	3021, 10, 215, 12, 215, 14, 215, 3024, 11, 215, 3, 215, 3, 215, 7, 215,
	3028, 10, 215, 12, 215, 14, 215, 3031, 11, 215, 3, 215, 3, 215, 7, 215,
	3035, 10, 215, 12, 215, 14, 215, 3038, 11, 215, 3, 215, 3, 215, 7, 215,
	3042, 10, 215, 12, 215, 14, 215, 3045, 11, 215, 3, 215, 3, 215, 3, 215,
	3, 215, 7, 215, 3051, 10, 215, 12, 215, 14, 215, 3054, 11, 215, 3, 215,
	3, 215, 7, 215, 3058, 10, 215, 12, 215, 14, 215, 3061, 11, 215, 3, 215,
	3, 215, 3, 215, 3, 215, 7, 215, 3067, 10, 215, 12, 215, 14, 215, 3070,
	11, 215, 3, 215, 3, 215, 7, 215, 3074, 10, 215, 12, 215, 14, 215, 3077,
	11, 215, 3, 215, 3, 215, 7, 215, 3081, 10, 215, 12, 215, 14, 215, 3084,
	11, 215, 3, 215, 3, 215, 7, 215, 3088, 10, 215, 12, 215, 14, 215, 3091,
	11, 215, 3, 215, 3, 215, 7, 215, 3095, 10, 215, 12, 215, 14, 215, 3098,
	11, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215,
	3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215,
	3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 5, 215, 3123, 10, 215,
	3, 216, 3, 216, 7, 216, 3127, 10, 216, 12, 216, 14, 216, 3130, 11, 216,
	3, 216, 5, 216, 3133, 10, 216, 3, 217, 3, 217, 3, 218, 3, 218, 3, 218,
	3, 218, 3, 218, 3, 218, 3, 218, 5, 218, 3144, 10, 218, 3, 219, 3, 219,
	3, 219, 3, 219, 3, 219, 3, 219, 3, 219, 3, 219, 5, 219, 3154, 10, 219,
	3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 5, 220,
	3164, 10, 220, 3, 221, 3, 221, 3, 221, 3, 221, 3, 221, 3, 221, 3, 221,
	3, 221, 3, 221, 3, 221, 3, 221, 3, 221, 3, 221, 5, 221, 3179, 10, 221,
	3, 222, 3, 222, 3, 222, 7, 222, 3184, 10, 222, 12, 222, 14, 222, 3187,
	11, 222, 3, 222, 3, 222, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223,
	5, 223, 3197, 10, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223,
	7, 223, 3205, 10, 223, 12, 223, 14, 223, 3208, 11, 223, 3, 224, 3, 224,
	3, 224, 3, 224, 3, 224, 5, 224, 3215, 10, 224, 3, 225, 3, 225, 5, 225,
	3219, 10, 225, 3, 226, 3, 226, 3, 226, 3, 227, 3, 227, 3, 227, 3, 227,
	3, 227, 3, 227, 3, 228, 3, 228, 3, 228, 3, 228, 3, 228, 3, 228, 3, 228,
	3, 228, 3, 228, 3, 228, 3, 228, 3, 228, 7, 228, 3242, 10, 228, 12, 228,
	14, 228, 3245, 11, 228, 3, 228, 3, 228, 5, 228, 3249, 10, 228, 3, 229,
	3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 7, 229, 3257, 10, 229, 12, 229,
	14, 229, 3260, 11, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229,
	3, 229, 3, 229, 7, 229, 3270, 10, 229, 12, 229, 14, 229, 3273, 11, 229,
	3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 7, 229,
	3283, 10, 229, 12, 229, 14, 229, 3286, 11, 229, 3, 229, 3, 229, 5, 229,
	3290, 10, 229, 3, 230, 3, 230, 3, 230, 7, 230, 3295, 10, 230, 12, 230,
	14, 230, 3298, 11, 230, 3, 230, 3, 230, 3, 230, 3, 230, 3, 230, 5, 230,
	3305, 10, 230, 3, 230, 5, 230, 3308, 10, 230, 3, 231, 3, 231, 3, 231, 3,
	231, 3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3,
	231, 3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3,
	231, 3, 231, 3, 231, 5, 231, 3334, 10, 231, 3, 232, 3, 232, 3, 232, 5,
	232, 3339, 10, 232, 3, 232, 3, 232, 5, 232, 3343, 10, 232, 7, 232, 3345,
	10, 232, 12, 232, 14, 232, 3348, 11, 232, 3, 232, 5, 232, 3351, 10, 232,
	3, 232, 3, 232, 3, 233, 3, 233, 3, 233, 3, 233, 3, 233, 7, 233, 3360, 10,
	233, 12, 233, 14, 233, 3363, 11, 233, 3, 233, 3, 233, 5, 233, 3367, 10,
	233, 3, 233, 3, 233, 3, 234, 3, 234, 7, 234, 3373, 10, 234, 12, 234, 14,
	234, 3376, 11, 234, 3, 234, 3, 234, 3, 235, 3, 235, 3, 235, 3, 235, 5,
	235, 3384, 10, 235, 3, 236, 3, 236, 3, 236, 3, 236, 3, 236, 3, 236, 3,
	236, 3, 236, 5, 236, 3394, 10, 236, 3, 237, 3, 237, 3, 237, 3, 237, 3,
	237, 3, 237, 3, 237, 3, 237, 5, 237, 3404, 10, 237, 3, 238, 3, 238, 3,
	238, 3, 238, 3, 238, 3, 238, 3, 238, 3, 238, 3, 238, 5, 238, 3415, 10,
	238, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 5,
	239, 3425, 10, 239, 3, 240, 3, 240, 3, 240, 5, 240, 3430, 10, 240, 3, 240,
	3, 240, 3, 240, 3, 240, 3, 241, 3, 241, 3, 241, 5, 241, 3439, 10, 241,
	3, 241, 3, 241, 3, 241, 3, 241, 3, 242, 3, 242, 3, 242, 7, 242, 3448, 10,
	242, 12, 242, 14, 242, 3451, 11, 242, 3, 243, 3, 243, 3, 243, 7, 243, 3456,
	10, 243, 12, 243, 14, 243, 3459, 11, 243, 3, 244, 3, 244, 3, 244, 3, 244,
	3, 244, 5, 244, 3466, 10, 244, 3, 245, 3, 245, 3, 245, 3, 245, 3, 245,
	5, 245, 3473, 10, 245, 3, 246, 3, 246, 5, 246, 3477, 10, 246, 3, 247, 3,
	247, 5, 247, 3481, 10, 247, 3, 248, 3, 248, 3, 248, 3, 248, 3, 248, 5,
	248, 3488, 10, 248, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3,
	249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3,
	249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3,
	249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3,
	249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3,
	249, 3, 249, 3, 249, 3, 249, 3, 249, 5, 249, 3537, 10, 249, 3, 250, 3,
	250, 3, 251, 3, 251, 3, 252, 3, 252, 3, 253, 3, 253, 3, 254, 3, 254, 3,
	255, 3, 255, 3, 256, 3, 256, 3, 257, 3, 257, 3, 258, 3, 258, 3, 259, 3,
	259, 3, 260, 3, 260, 3, 261, 3, 261, 3, 262, 3, 262, 3, 263, 3, 263, 3,
	264, 3, 264, 3, 265, 3, 265, 3, 266, 3, 266, 3, 267, 3, 267, 3, 267, 3,
	267, 3, 267, 3, 267, 3, 267, 3, 267, 5, 267, 3581, 10, 267, 3, 268, 3,
	268, 5, 268, 3585, 10, 268, 3, 268, 3, 268, 3, 268, 3, 268, 3, 268, 5,
	268, 3592, 10, 268, 3, 268, 3, 268, 3, 268, 3, 268, 3, 268, 3, 269, 3,
	269, 5, 269, 3601, 10, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 5,
	269, 3608, 10, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 270, 3,
	270, 3, 271, 3, 271, 3, 272, 3, 272, 3, 272, 3, 272, 3, 272, 3, 272, 3,
	272, 3, 272, 3, 272, 3, 272, 3, 272, 3, 272, 3, 272, 3, 272, 5, 272, 3633,
	10, 272, 3, 273, 3, 273, 3, 274, 3, 274, 3, 274, 3, 274, 7, 274, 3641,
	10, 274, 12, 274, 14, 274, 3644, 11, 274, 3, 274, 3, 274, 3, 275, 3, 275,
	3, 275, 3, 275, 7, 275, 3652, 10, 275, 12, 275, 14, 275, 3655, 11, 275,
	3, 275, 3, 275, 3, 276, 3, 276, 3, 276, 3, 276, 3, 276, 3, 277, 3, 277,
	3, 277, 3, 277, 7, 277, 3668, 10, 277, 12, 277, 14, 277, 3671, 11, 277,
	3, 277, 3, 277, 3, 278, 3, 278, 3, 278, 3, 278, 3, 278, 3, 279, 3, 279,
	3, 279, 3, 279, 3, 279, 3, 280, 3, 280, 7, 280, 3687, 10, 280, 12, 280,
	14, 280, 3690, 11, 280, 3, 280, 3, 280, 3, 280, 3, 280, 7, 280, 3696, 10,
	280, 12, 280, 14, 280, 3699, 11, 280, 3, 280, 3, 280, 3, 281, 3, 281, 3,
	281, 3, 281, 3, 281, 7, 281, 3708, 10, 281, 12, 281, 14, 281, 3711, 11,
	281, 3, 281, 3, 281, 3, 282, 3, 282, 7, 282, 3717, 10, 282, 12, 282, 14,
	282, 3720, 11, 282, 3, 282, 3, 282, 3, 282, 3, 282, 7, 282, 3726, 10, 282,
	12, 282, 14, 282, 3729, 11, 282, 3, 282, 3, 282, 3, 283, 3, 283, 3, 283,
	3, 283, 3, 283, 7, 283, 3738, 10, 283, 12, 283, 14, 283, 3741, 11, 283,
	3, 283, 3, 283, 5, 283, 3745, 10, 283, 3, 284, 3, 284, 3, 285, 3, 285,
	3, 286, 3, 286, 3, 286, 3, 286, 7, 286, 3755, 10, 286, 12, 286, 14, 286,
	3758, 11, 286, 3, 286, 3, 286, 5, 286, 3762, 10, 286, 3, 286, 3, 286, 3,
	286, 7, 286, 3767, 10, 286, 12, 286, 14, 286, 3770, 11, 286, 3, 286, 3,
	286, 3, 286, 3, 286, 3, 286, 7, 286, 3777, 10, 286, 12, 286, 14, 286, 3780,
	11, 286, 3, 286, 3, 286, 3, 286, 3, 286, 7, 286, 3786, 10, 286, 12, 286,
	14, 286, 3789, 11, 286, 3, 287, 3, 287, 3, 287, 3, 287, 3, 287, 3, 287,
	3, 287, 5, 287, 3798, 10, 287, 3, 288, 3, 288, 3, 288, 3, 288, 3, 288,
	3, 288, 3, 288, 3, 288, 3, 288, 3, 288, 3, 288, 3, 288, 3, 288, 5, 288,
	3813, 10, 288, 3, 289, 3, 289, 3, 290, 3, 290, 3, 290, 3, 290, 7, 290,
	3821, 10, 290, 12, 290, 14, 290, 3824, 11, 290, 3, 290, 3, 290, 5, 290,
	3828, 10, 290, 3, 290, 3, 290, 3, 290, 7, 290, 3833, 10, 290, 12, 290,
	14, 290, 3836, 11, 290, 3, 290, 3, 290, 3, 290, 3, 290, 3, 290, 7, 290,
	3843, 10, 290, 12, 290, 14, 290, 3846, 11, 290, 3, 290, 3, 290, 3, 290,
	3, 290, 7, 290, 3852, 10, 290, 12, 290, 14, 290, 3855, 11, 290, 3, 291,
	3, 291, 3, 292, 3, 292, 3, 292, 3, 292, 3, 292, 3, 292, 3, 292, 5, 292,
	3866, 10, 292, 3, 293, 3, 293, 3, 293, 3, 293, 7, 293, 3872, 10, 293, 12,
	293, 14, 293, 3875, 11, 293, 3, 293, 3, 293, 5, 293, 3879, 10, 293, 3,
	293, 3, 293, 3, 293, 7, 293, 3884, 10, 293, 12, 293, 14, 293, 3887, 11,
	293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 7, 293, 3894, 10, 293, 12,
	293, 14, 293, 3897, 11, 293, 3, 293, 3, 293, 3, 293, 3, 293, 7, 293, 3903,
	10, 293, 12, 293, 14, 293, 3906, 11, 293, 3, 294, 3, 294, 3, 294, 3, 294,
	3, 294, 3, 294, 3, 294, 5, 294, 3915, 10, 294, 3, 295, 3, 295, 3, 296,
	3, 296, 3, 296, 3, 296, 3, 296, 3, 296, 3, 296, 3, 296, 3, 296, 3, 296,
	3, 296, 3, 296, 3, 296, 5, 296, 3932, 10, 296, 3, 297, 3, 297, 3, 298,
	3, 298, 3, 298, 3, 298, 3, 298, 3, 298, 5, 298, 3942, 10, 298, 3, 298,
	3, 298, 3, 298, 3, 298, 3, 298, 5, 298, 3949, 10, 298, 3, 298, 3, 298,
	3, 298, 3, 298, 3, 298, 3, 298, 3, 298, 3, 298, 3, 298, 3, 298, 3, 298,
	3, 298, 3, 298, 5, 298, 3964, 10, 298, 3, 299, 3, 299, 3, 299, 3, 299,
	3, 299, 3, 299, 3, 299, 3, 299, 3, 299, 3, 299, 5, 299, 3976, 10, 299,
	3, 300, 3, 300, 3, 300, 3, 300, 3, 300, 3, 300, 7, 300, 3984, 10, 300,
	12, 300, 14, 300, 3987, 11, 300, 3, 300, 3, 300, 3, 300, 3, 300, 5, 300,
	3993, 10, 300, 3, 300, 3, 300, 3, 300, 3, 300, 3, 300, 3, 300, 3, 300,
	3, 300, 3, 300, 3, 300, 3, 300, 3, 300, 3, 300, 5, 300, 4008, 10, 300,
	3, 301, 3, 301, 3, 301, 3, 301, 3, 301, 7, 301, 4015, 10, 301, 12, 301,
	14, 301, 4018, 11, 301, 3, 301, 3, 301, 3, 301, 3, 301, 5, 301, 4024, 10,
	301, 3, 301, 3, 301, 3, 301, 3, 301, 7, 301, 4030, 10, 301, 12, 301, 14,
	301, 4033, 11, 301, 3, 301, 3, 301, 5, 301, 4037, 10, 301, 3, 302, 3, 302,
	3, 302, 3, 302, 3, 302, 7, 302, 4044, 10, 302, 12, 302, 14, 302, 4047,
	11, 302, 3, 302, 3, 302, 3, 302, 3, 302, 5, 302, 4053, 10, 302, 3, 302,
	3, 302, 3, 302, 3, 302, 7, 302, 4059, 10, 302, 12, 302, 14, 302, 4062,
	11, 302, 3, 302, 3, 302, 5, 302, 4066, 10, 302, 3, 303, 3, 303, 3, 304,
	3, 304, 3, 305, 3, 305, 3, 306, 3, 306, 3, 307, 3, 307, 3, 308, 3, 308,
	3, 308, 3, 308, 3, 308, 7, 308, 4083, 10, 308, 12, 308, 14, 308, 4086,
	11, 308, 3, 308, 3, 308, 3, 308, 3, 309, 3, 309, 3, 309, 5, 309, 4094,
	10, 309, 3, 310, 3, 310, 3, 311, 3, 311, 3, 312, 3, 312, 3, 313, 3, 313,
	3, 314, 3, 314, 3, 315, 3, 315, 3, 316, 3, 316, 3, 317, 3, 317, 3, 318,
	3, 318, 3, 319, 3, 319, 3, 320, 3, 320, 3, 321, 3, 321, 3, 322, 3, 322,
	3, 322, 3, 322, 3, 322, 5, 322, 4125, 10, 322, 3, 322, 3, 322, 7, 322,
	4129, 10, 322, 12, 322, 14, 322, 4132, 11, 322, 3, 322, 3, 322, 3, 323,
	3, 323, 3, 324, 3, 324, 3, 325, 3, 325, 3, 326, 3, 326, 3, 327, 3, 327,
	3, 328, 3, 328, 3, 329, 3, 329, 3, 330, 3, 330, 3, 331, 3, 331, 3, 332,
	3, 332, 3, 333, 3, 333, 3, 334, 3, 334, 3, 335, 3, 335, 3, 336, 3, 336,
	3, 337, 3, 337, 3, 338, 3, 338, 3, 339, 3, 339, 3, 340, 3, 340, 3, 341,
	3, 341, 3, 342, 3, 342, 3, 343, 3, 343, 3, 344, 3, 344, 3, 345, 3, 345,
	3, 346, 3, 346, 3, 347, 3, 347, 3, 347, 6, 1864, 1872, 1892, 1900, 7, 390,
	444, 570, 578, 584, 348, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
	28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
	64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98,
	100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128,
	130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158,
	160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188,
	190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218,
	220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248,
	250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278,
	280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308,
	310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338,
	340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368,
	370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396, 398,
	400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426, 428,
	430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456, 458,
	460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482, 484, 486, 488,
	490, 492, 494, 496, 498, 500, 502, 504, 506, 508, 510, 512, 514, 516, 518,
	520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548,
	550, 552, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572, 574, 576, 578,
	580, 582, 584, 586, 588, 590, 592, 594, 596, 598, 600, 602, 604, 606, 608,
	610, 612, 614, 616, 618, 620, 622, 624, 626, 628, 630, 632, 634, 636, 638,
	640, 642, 644, 646, 648, 650, 652, 654, 656, 658, 660, 662, 664, 666, 668,
	670, 672, 674, 676, 678, 680, 682, 684, 686, 688, 690, 692, 2, 31, 3, 2,
	127, 134, 3, 2, 135, 138, 3, 2, 139, 142, 4, 2, 146, 153, 165, 172, 3,
	2, 211, 216, 5, 2, 228, 231, 233, 240, 243, 248, 4, 2, 232, 232, 241, 242,
	4, 2, 58, 58, 60, 60, 5, 2, 52, 52, 82, 83, 104, 104, 4, 2, 92, 92, 117,
	117, 6, 2, 100, 101, 108, 112, 119, 119, 123, 124, 4, 2, 52, 52, 104, 104,
	6, 2, 75, 75, 98, 98, 100, 100, 120, 120, 6, 2, 76, 76, 99, 99, 101, 101,
	121, 121, 4, 2, 15, 15, 81, 81, 4, 2, 9, 10, 67, 68, 5, 2, 63, 63, 72,
	72, 87, 88, 7, 2, 4, 4, 61, 61, 64, 64, 69, 69, 125, 126, 4, 2, 8, 8, 66,
	66, 4, 2, 90, 91, 106, 107, 4, 2, 89, 89, 105, 105, 4, 2, 62, 62, 73, 73,
	3, 2, 302, 303, 3, 2, 302, 312, 7, 2, 302, 303, 306, 306, 308, 308, 310,
	329, 334, 334, 3, 2, 304, 312, 7, 2, 306, 306, 308, 308, 310, 312, 315,
	316, 319, 320, 3, 2, 284, 288, 3, 2, 292, 293, 2, 4406, 2, 694, 3, 2, 2,
	2, 4, 703, 3, 2, 2, 2, 6, 706, 3, 2, 2, 2, 8, 720, 3, 2, 2, 2, 10, 722,
	3, 2, 2, 2, 12, 731, 3, 2, 2, 2, 14, 746, 3, 2, 2, 2, 16, 748, 3, 2, 2,
	2, 18, 768, 3, 2, 2, 2, 20, 782, 3, 2, 2, 2, 22, 784, 3, 2, 2, 2, 24, 786,
	3, 2, 2, 2, 26, 788, 3, 2, 2, 2, 28, 792, 3, 2, 2, 2, 30, 814, 3, 2, 2,
	2, 32, 816, 3, 2, 2, 2, 34, 850, 3, 2, 2, 2, 36, 852, 3, 2, 2, 2, 38, 854,
	3, 2, 2, 2, 40, 856, 3, 2, 2, 2, 42, 860, 3, 2, 2, 2, 44, 862, 3, 2, 2,
	2, 46, 871, 3, 2, 2, 2, 48, 873, 3, 2, 2, 2, 50, 882, 3, 2, 2, 2, 52, 884,
	3, 2, 2, 2, 54, 886, 3, 2, 2, 2, 56, 888, 3, 2, 2, 2, 58, 893, 3, 2, 2,
	2, 60, 895, 3, 2, 2, 2, 62, 897, 3, 2, 2, 2, 64, 904, 3, 2, 2, 2, 66, 961,
	3, 2, 2, 2, 68, 963, 3, 2, 2, 2, 70, 965, 3, 2, 2, 2, 72, 967, 3, 2, 2,
	2, 74, 969, 3, 2, 2, 2, 76, 971, 3, 2, 2, 2, 78, 973, 3, 2, 2, 2, 80, 977,
	3, 2, 2, 2, 82, 979, 3, 2, 2, 2, 84, 996, 3, 2, 2, 2, 86, 998, 3, 2, 2,
	2, 88, 1000, 3, 2, 2, 2, 90, 1002, 3, 2, 2, 2, 92, 1020, 3, 2, 2, 2, 94,
	1022, 3, 2, 2, 2, 96, 1032, 3, 2, 2, 2, 98, 1034, 3, 2, 2, 2, 100, 1036,
	3, 2, 2, 2, 102, 1039, 3, 2, 2, 2, 104, 1042, 3, 2, 2, 2, 106, 1045, 3,
	2, 2, 2, 108, 1051, 3, 2, 2, 2, 110, 1053, 3, 2, 2, 2, 112, 1056, 3, 2,
	2, 2, 114, 1064, 3, 2, 2, 2, 116, 1075, 3, 2, 2, 2, 118, 1077, 3, 2, 2,
	2, 120, 1083, 3, 2, 2, 2, 122, 1089, 3, 2, 2, 2, 124, 1095, 3, 2, 2, 2,
	126, 1103, 3, 2, 2, 2, 128, 1112, 3, 2, 2, 2, 130, 1118, 3, 2, 2, 2, 132,
	1120, 3, 2, 2, 2, 134, 1143, 3, 2, 2, 2, 136, 1150, 3, 2, 2, 2, 138, 1157,
	3, 2, 2, 2, 140, 1203, 3, 2, 2, 2, 142, 1205, 3, 2, 2, 2, 144, 1207, 3,
	2, 2, 2, 146, 1219, 3, 2, 2, 2, 148, 1243, 3, 2, 2, 2, 150, 1256, 3, 2,
	2, 2, 152, 1270, 3, 2, 2, 2, 154, 1272, 3, 2, 2, 2, 156, 1300, 3, 2, 2,
	2, 158, 1306, 3, 2, 2, 2, 160, 1380, 3, 2, 2, 2, 162, 1392, 3, 2, 2, 2,
	164, 1413, 3, 2, 2, 2, 166, 1415, 3, 2, 2, 2, 168, 1419, 3, 2, 2, 2, 170,
	1431, 3, 2, 2, 2, 172, 1460, 3, 2, 2, 2, 174, 1462, 3, 2, 2, 2, 176, 1464,
	3, 2, 2, 2, 178, 1467, 3, 2, 2, 2, 180, 1475, 3, 2, 2, 2, 182, 1483, 3,
	2, 2, 2, 184, 1490, 3, 2, 2, 2, 186, 1513, 3, 2, 2, 2, 188, 1527, 3, 2,
	2, 2, 190, 1529, 3, 2, 2, 2, 192, 1536, 3, 2, 2, 2, 194, 1538, 3, 2, 2,
	2, 196, 1550, 3, 2, 2, 2, 198, 1586, 3, 2, 2, 2, 200, 1588, 3, 2, 2, 2,
	202, 1592, 3, 2, 2, 2, 204, 1710, 3, 2, 2, 2, 206, 1712, 3, 2, 2, 2, 208,
	1716, 3, 2, 2, 2, 210, 1720, 3, 2, 2, 2, 212, 1730, 3, 2, 2, 2, 214, 1734,
	3, 2, 2, 2, 216, 1736, 3, 2, 2, 2, 218, 1749, 3, 2, 2, 2, 220, 1762, 3,
	2, 2, 2, 222, 1800, 3, 2, 2, 2, 224, 1802, 3, 2, 2, 2, 226, 1804, 3, 2,
	2, 2, 228, 1815, 3, 2, 2, 2, 230, 1832, 3, 2, 2, 2, 232, 1845, 3, 2, 2,
	2, 234, 1850, 3, 2, 2, 2, 236, 1852, 3, 2, 2, 2, 238, 1860, 3, 2, 2, 2,
	240, 1880, 3, 2, 2, 2, 242, 1888, 3, 2, 2, 2, 244, 1908, 3, 2, 2, 2, 246,
	1916, 3, 2, 2, 2, 248, 1924, 3, 2, 2, 2, 250, 1932, 3, 2, 2, 2, 252, 1940,
	3, 2, 2, 2, 254, 1948, 3, 2, 2, 2, 256, 1964, 3, 2, 2, 2, 258, 1968, 3,
	2, 2, 2, 260, 1972, 3, 2, 2, 2, 262, 1981, 3, 2, 2, 2, 264, 2006, 3, 2,
	2, 2, 266, 2008, 3, 2, 2, 2, 268, 2010, 3, 2, 2, 2, 270, 2012, 3, 2, 2,
	2, 272, 2014, 3, 2, 2, 2, 274, 2020, 3, 2, 2, 2, 276, 2066, 3, 2, 2, 2,
	278, 2078, 3, 2, 2, 2, 280, 2083, 3, 2, 2, 2, 282, 2108, 3, 2, 2, 2, 284,
	2145, 3, 2, 2, 2, 286, 2175, 3, 2, 2, 2, 288, 2177, 3, 2, 2, 2, 290, 2206,
	3, 2, 2, 2, 292, 2223, 3, 2, 2, 2, 294, 2240, 3, 2, 2, 2, 296, 2257, 3,
	2, 2, 2, 298, 2259, 3, 2, 2, 2, 300, 2342, 3, 2, 2, 2, 302, 2344, 3, 2,
	2, 2, 304, 2352, 3, 2, 2, 2, 306, 2360, 3, 2, 2, 2, 308, 2367, 3, 2, 2,
	2, 310, 2506, 3, 2, 2, 2, 312, 2509, 3, 2, 2, 2, 314, 2522, 3, 2, 2, 2,
	316, 2533, 3, 2, 2, 2, 318, 2544, 3, 2, 2, 2, 320, 2560, 3, 2, 2, 2, 322,
	2576, 3, 2, 2, 2, 324, 2585, 3, 2, 2, 2, 326, 2596, 3, 2, 2, 2, 328, 2602,
	3, 2, 2, 2, 330, 2622, 3, 2, 2, 2, 332, 2640, 3, 2, 2, 2, 334, 2642, 3,
	2, 2, 2, 336, 2644, 3, 2, 2, 2, 338, 2646, 3, 2, 2, 2, 340, 2648, 3, 2,
	2, 2, 342, 2650, 3, 2, 2, 2, 344, 2652, 3, 2, 2, 2, 346, 2654, 3, 2, 2,
	2, 348, 2656, 3, 2, 2, 2, 350, 2658, 3, 2, 2, 2, 352, 2660, 3, 2, 2, 2,
	354, 2662, 3, 2, 2, 2, 356, 2664, 3, 2, 2, 2, 358, 2666, 3, 2, 2, 2, 360,
	2668, 3, 2, 2, 2, 362, 2682, 3, 2, 2, 2, 364, 2703, 3, 2, 2, 2, 366, 2705,
	3, 2, 2, 2, 368, 2707, 3, 2, 2, 2, 370, 2715, 3, 2, 2, 2, 372, 2720, 3,
	2, 2, 2, 374, 2740, 3, 2, 2, 2, 376, 2745, 3, 2, 2, 2, 378, 2754, 3, 2,
	2, 2, 380, 2765, 3, 2, 2, 2, 382, 2774, 3, 2, 2, 2, 384, 2778, 3, 2, 2,
	2, 386, 2786, 3, 2, 2, 2, 388, 2796, 3, 2, 2, 2, 390, 2811, 3, 2, 2, 2,
	392, 2840, 3, 2, 2, 2, 394, 2846, 3, 2, 2, 2, 396, 2850, 3, 2, 2, 2, 398,
	2852, 3, 2, 2, 2, 400, 2877, 3, 2, 2, 2, 402, 2892, 3, 2, 2, 2, 404, 2896,
	3, 2, 2, 2, 406, 2898, 3, 2, 2, 2, 408, 2908, 3, 2, 2, 2, 410, 2916, 3,
	2, 2, 2, 412, 2920, 3, 2, 2, 2, 414, 2923, 3, 2, 2, 2, 416, 2926, 3, 2,
	2, 2, 418, 2933, 3, 2, 2, 2, 420, 2952, 3, 2, 2, 2, 422, 2954, 3, 2, 2,
	2, 424, 2958, 3, 2, 2, 2, 426, 2977, 3, 2, 2, 2, 428, 3122, 3, 2, 2, 2,
	430, 3132, 3, 2, 2, 2, 432, 3134, 3, 2, 2, 2, 434, 3143, 3, 2, 2, 2, 436,
	3153, 3, 2, 2, 2, 438, 3163, 3, 2, 2, 2, 440, 3178, 3, 2, 2, 2, 442, 3180,
	3, 2, 2, 2, 444, 3196, 3, 2, 2, 2, 446, 3214, 3, 2, 2, 2, 448, 3218, 3,
	2, 2, 2, 450, 3220, 3, 2, 2, 2, 452, 3223, 3, 2, 2, 2, 454, 3229, 3, 2,
	2, 2, 456, 3289, 3, 2, 2, 2, 458, 3307, 3, 2, 2, 2, 460, 3333, 3, 2, 2,
	2, 462, 3335, 3, 2, 2, 2, 464, 3354, 3, 2, 2, 2, 466, 3370, 3, 2, 2, 2,
	468, 3383, 3, 2, 2, 2, 470, 3393, 3, 2, 2, 2, 472, 3403, 3, 2, 2, 2, 474,
	3414, 3, 2, 2, 2, 476, 3424, 3, 2, 2, 2, 478, 3426, 3, 2, 2, 2, 480, 3435,
	3, 2, 2, 2, 482, 3444, 3, 2, 2, 2, 484, 3452, 3, 2, 2, 2, 486, 3460, 3,
	2, 2, 2, 488, 3467, 3, 2, 2, 2, 490, 3476, 3, 2, 2, 2, 492, 3480, 3, 2,
	2, 2, 494, 3487, 3, 2, 2, 2, 496, 3536, 3, 2, 2, 2, 498, 3538, 3, 2, 2,
	2, 500, 3540, 3, 2, 2, 2, 502, 3542, 3, 2, 2, 2, 504, 3544, 3, 2, 2, 2,
	506, 3546, 3, 2, 2, 2, 508, 3548, 3, 2, 2, 2, 510, 3550, 3, 2, 2, 2, 512,
	3552, 3, 2, 2, 2, 514, 3554, 3, 2, 2, 2, 516, 3556, 3, 2, 2, 2, 518, 3558,
	3, 2, 2, 2, 520, 3560, 3, 2, 2, 2, 522, 3562, 3, 2, 2, 2, 524, 3564, 3,
	2, 2, 2, 526, 3566, 3, 2, 2, 2, 528, 3568, 3, 2, 2, 2, 530, 3570, 3, 2,
	2, 2, 532, 3580, 3, 2, 2, 2, 534, 3582, 3, 2, 2, 2, 536, 3598, 3, 2, 2,
	2, 538, 3614, 3, 2, 2, 2, 540, 3616, 3, 2, 2, 2, 542, 3632, 3, 2, 2, 2,
	544, 3634, 3, 2, 2, 2, 546, 3636, 3, 2, 2, 2, 548, 3647, 3, 2, 2, 2, 550,
	3658, 3, 2, 2, 2, 552, 3663, 3, 2, 2, 2, 554, 3674, 3, 2, 2, 2, 556, 3679,
	3, 2, 2, 2, 558, 3684, 3, 2, 2, 2, 560, 3702, 3, 2, 2, 2, 562, 3714, 3,
	2, 2, 2, 564, 3732, 3, 2, 2, 2, 566, 3746, 3, 2, 2, 2, 568, 3748, 3, 2,
	2, 2, 570, 3761, 3, 2, 2, 2, 572, 3797, 3, 2, 2, 2, 574, 3812, 3, 2, 2,
	2, 576, 3814, 3, 2, 2, 2, 578, 3827, 3, 2, 2, 2, 580, 3856, 3, 2, 2, 2,
	582, 3865, 3, 2, 2, 2, 584, 3878, 3, 2, 2, 2, 586, 3914, 3, 2, 2, 2, 588,
	3916, 3, 2, 2, 2, 590, 3931, 3, 2, 2, 2, 592, 3933, 3, 2, 2, 2, 594, 3963,
	3, 2, 2, 2, 596, 3975, 3, 2, 2, 2, 598, 4007, 3, 2, 2, 2, 600, 4036, 3,
	2, 2, 2, 602, 4065, 3, 2, 2, 2, 604, 4067, 3, 2, 2, 2, 606, 4069, 3, 2,
	2, 2, 608, 4071, 3, 2, 2, 2, 610, 4073, 3, 2, 2, 2, 612, 4075, 3, 2, 2,
	2, 614, 4077, 3, 2, 2, 2, 616, 4090, 3, 2, 2, 2, 618, 4095, 3, 2, 2, 2,
	620, 4097, 3, 2, 2, 2, 622, 4099, 3, 2, 2, 2, 624, 4101, 3, 2, 2, 2, 626,
	4103, 3, 2, 2, 2, 628, 4105, 3, 2, 2, 2, 630, 4107, 3, 2, 2, 2, 632, 4109,
	3, 2, 2, 2, 634, 4111, 3, 2, 2, 2, 636, 4113, 3, 2, 2, 2, 638, 4115, 3,
	2, 2, 2, 640, 4117, 3, 2, 2, 2, 642, 4130, 3, 2, 2, 2, 644, 4135, 3, 2,
	2, 2, 646, 4137, 3, 2, 2, 2, 648, 4139, 3, 2, 2, 2, 650, 4141, 3, 2, 2,
	2, 652, 4143, 3, 2, 2, 2, 654, 4145, 3, 2, 2, 2, 656, 4147, 3, 2, 2, 2,
	658, 4149, 3, 2, 2, 2, 660, 4151, 3, 2, 2, 2, 662, 4153, 3, 2, 2, 2, 664,
	4155, 3, 2, 2, 2, 666, 4157, 3, 2, 2, 2, 668, 4159, 3, 2, 2, 2, 670, 4161,
	3, 2, 2, 2, 672, 4163, 3, 2, 2, 2, 674, 4165, 3, 2, 2, 2, 676, 4167, 3,
	2, 2, 2, 678, 4169, 3, 2, 2, 2, 680, 4171, 3, 2, 2, 2, 682, 4173, 3, 2,
	2, 2, 684, 4175, 3, 2, 2, 2, 686, 4177, 3, 2, 2, 2, 688, 4179, 3, 2, 2,
	2, 690, 4181, 3, 2, 2, 2, 692, 4183, 3, 2, 2, 2, 694, 699, 5, 4, 3, 2,
	695, 696, 7, 296, 2, 2, 696, 697, 5, 6, 4, 2, 697, 698, 7, 297, 2, 2, 698,
	700, 3, 2, 2, 2, 699, 695, 3, 2, 2, 2, 699, 700, 3, 2, 2, 2, 700, 701,
	3, 2, 2, 2, 701, 702, 7, 333, 2, 2, 702, 3, 3, 2, 2, 2, 703, 704, 9, 2,
	2, 2, 704, 5, 3, 2, 2, 2, 705, 707, 5, 8, 5, 2, 706, 705, 3, 2, 2, 2, 706,
	707, 3, 2, 2, 2, 707, 712, 3, 2, 2, 2, 708, 709, 7, 331, 2, 2, 709, 711,
	5, 8, 5, 2, 710, 708, 3, 2, 2, 2, 711, 714, 3, 2, 2, 2, 712, 710, 3, 2,
	2, 2, 712, 713, 3, 2, 2, 2, 713, 7, 3, 2, 2, 2, 714, 712, 3, 2, 2, 2, 715,
	721, 5, 578, 290, 2, 716, 721, 5, 570, 286, 2, 717, 721, 5, 50, 26, 2,
	718, 721, 5, 52, 27, 2, 719, 721, 5, 54, 28, 2, 720, 715, 3, 2, 2, 2, 720,
	716, 3, 2, 2, 2, 720, 717, 3, 2, 2, 2, 720, 718, 3, 2, 2, 2, 720, 719,
	3, 2, 2, 2, 721, 9, 3, 2, 2, 2, 722, 727, 5, 12, 7, 2, 723, 724, 7, 296,
	2, 2, 724, 725, 5, 6, 4, 2, 725, 726, 7, 297, 2, 2, 726, 728, 3, 2, 2,
	2, 727, 723, 3, 2, 2, 2, 727, 728, 3, 2, 2, 2, 728, 729, 3, 2, 2, 2, 729,
	730, 7, 333, 2, 2, 730, 11, 3, 2, 2, 2, 731, 732, 9, 3, 2, 2, 732, 13,
	3, 2, 2, 2, 733, 738, 5, 16, 9, 2, 734, 735, 7, 296, 2, 2, 735, 736, 5,
	6, 4, 2, 736, 737, 7, 297, 2, 2, 737, 739, 3, 2, 2, 2, 738, 734, 3, 2,
	2, 2, 738, 739, 3, 2, 2, 2, 739, 740, 3, 2, 2, 2, 740, 741, 7, 333, 2,
	2, 741, 747, 3, 2, 2, 2, 742, 743, 7, 144, 2, 2, 743, 747, 7, 333, 2, 2,
	744, 745, 7, 143, 2, 2, 745, 747, 7, 333, 2, 2, 746, 733, 3, 2, 2, 2, 746,
	742, 3, 2, 2, 2, 746, 744, 3, 2, 2, 2, 747, 15, 3, 2, 2, 2, 748, 749, 9,
	4, 2, 2, 749, 17, 3, 2, 2, 2, 750, 751, 5, 22, 12, 2, 751, 752, 7, 335,
	2, 2, 752, 753, 7, 164, 2, 2, 753, 754, 7, 296, 2, 2, 754, 755, 5, 26,
	14, 2, 755, 756, 7, 297, 2, 2, 756, 757, 7, 333, 2, 2, 757, 769, 3, 2,
	2, 2, 758, 759, 5, 24, 13, 2, 759, 760, 7, 335, 2, 2, 760, 761, 7, 164,
	2, 2, 761, 762, 7, 296, 2, 2, 762, 763, 5, 26, 14, 2, 763, 764, 7, 331,
	2, 2, 764, 765, 5, 28, 15, 2, 765, 766, 7, 297, 2, 2, 766, 767, 7, 333,
	2, 2, 767, 769, 3, 2, 2, 2, 768, 750, 3, 2, 2, 2, 768, 758, 3, 2, 2, 2,
	769, 19, 3, 2, 2, 2, 770, 771, 7, 145, 2, 2, 771, 772, 7, 296, 2, 2, 772,
	773, 5, 22, 12, 2, 773, 774, 7, 297, 2, 2, 774, 775, 7, 333, 2, 2, 775,
	783, 3, 2, 2, 2, 776, 777, 7, 145, 2, 2, 777, 778, 7, 296, 2, 2, 778, 779,
	5, 24, 13, 2, 779, 780, 7, 297, 2, 2, 780, 781, 7, 333, 2, 2, 781, 783,
	3, 2, 2, 2, 782, 770, 3, 2, 2, 2, 782, 776, 3, 2, 2, 2, 783, 21, 3, 2,
	2, 2, 784, 785, 5, 692, 347, 2, 785, 23, 3, 2, 2, 2, 786, 787, 5, 692,
	347, 2, 787, 25, 3, 2, 2, 2, 788, 789, 7, 289, 2, 2, 789, 27, 3, 2, 2,
	2, 790, 793, 7, 289, 2, 2, 791, 793, 5, 692, 347, 2, 792, 790, 3, 2, 2,
	2, 792, 791, 3, 2, 2, 2, 793, 29, 3, 2, 2, 2, 794, 795, 5, 32, 17, 2, 795,
	796, 7, 296, 2, 2, 796, 799, 5, 22, 12, 2, 797, 798, 7, 331, 2, 2, 798,
	800, 5, 6, 4, 2, 799, 797, 3, 2, 2, 2, 799, 800, 3, 2, 2, 2, 800, 801,
	3, 2, 2, 2, 801, 802, 7, 297, 2, 2, 802, 803, 7, 333, 2, 2, 803, 815, 3,
	2, 2, 2, 804, 805, 5, 32, 17, 2, 805, 806, 7, 296, 2, 2, 806, 809, 5, 24,
	13, 2, 807, 808, 7, 331, 2, 2, 808, 810, 5, 6, 4, 2, 809, 807, 3, 2, 2,
	2, 809, 810, 3, 2, 2, 2, 810, 811, 3, 2, 2, 2, 811, 812, 7, 297, 2, 2,
	812, 813, 7, 333, 2, 2, 813, 815, 3, 2, 2, 2, 814, 794, 3, 2, 2, 2, 814,
	804, 3, 2, 2, 2, 815, 31, 3, 2, 2, 2, 816, 817, 9, 5, 2, 2, 817, 33, 3,
	2, 2, 2, 818, 819, 7, 181, 2, 2, 819, 820, 7, 296, 2, 2, 820, 821, 5, 42,
	22, 2, 821, 822, 7, 331, 2, 2, 822, 829, 5, 36, 19, 2, 823, 824, 7, 331,
	2, 2, 824, 827, 5, 38, 20, 2, 825, 826, 7, 331, 2, 2, 826, 828, 5, 40,
	21, 2, 827, 825, 3, 2, 2, 2, 827, 828, 3, 2, 2, 2, 828, 830, 3, 2, 2, 2,
	829, 823, 3, 2, 2, 2, 829, 830, 3, 2, 2, 2, 830, 831, 3, 2, 2, 2, 831,
	832, 7, 297, 2, 2, 832, 833, 7, 333, 2, 2, 833, 851, 3, 2, 2, 2, 834, 835,
	7, 182, 2, 2, 835, 836, 7, 296, 2, 2, 836, 837, 5, 42, 22, 2, 837, 838,
	7, 331, 2, 2, 838, 845, 5, 36, 19, 2, 839, 840, 7, 331, 2, 2, 840, 843,
	5, 38, 20, 2, 841, 842, 7, 331, 2, 2, 842, 844, 5, 40, 21, 2, 843, 841,
	3, 2, 2, 2, 843, 844, 3, 2, 2, 2, 844, 846, 3, 2, 2, 2, 845, 839, 3, 2,
	2, 2, 845, 846, 3, 2, 2, 2, 846, 847, 3, 2, 2, 2, 847, 848, 7, 297, 2,
	2, 848, 849, 7, 333, 2, 2, 849, 851, 3, 2, 2, 2, 850, 818, 3, 2, 2, 2,
	850, 834, 3, 2, 2, 2, 851, 35, 3, 2, 2, 2, 852, 853, 5, 692, 347, 2, 853,
	37, 3, 2, 2, 2, 854, 855, 7, 285, 2, 2, 855, 39, 3, 2, 2, 2, 856, 857,
	7, 285, 2, 2, 857, 41, 3, 2, 2, 2, 858, 861, 7, 289, 2, 2, 859, 861, 5,
	692, 347, 2, 860, 858, 3, 2, 2, 2, 860, 859, 3, 2, 2, 2, 861, 43, 3, 2,
	2, 2, 862, 867, 7, 185, 2, 2, 863, 864, 7, 296, 2, 2, 864, 865, 5, 46,
	24, 2, 865, 866, 7, 297, 2, 2, 866, 868, 3, 2, 2, 2, 867, 863, 3, 2, 2,
	2, 867, 868, 3, 2, 2, 2, 868, 869, 3, 2, 2, 2, 869, 870, 7, 333, 2, 2,
	870, 45, 3, 2, 2, 2, 871, 872, 7, 285, 2, 2, 872, 47, 3, 2, 2, 2, 873,
	878, 7, 186, 2, 2, 874, 875, 7, 296, 2, 2, 875, 876, 5, 46, 24, 2, 876,
	877, 7, 297, 2, 2, 877, 879, 3, 2, 2, 2, 878, 874, 3, 2, 2, 2, 878, 879,
	3, 2, 2, 2, 879, 880, 3, 2, 2, 2, 880, 881, 7, 333, 2, 2, 881, 49, 3, 2,
	2, 2, 882, 883, 7, 104, 2, 2, 883, 51, 3, 2, 2, 2, 884, 885, 7, 210, 2,
	2, 885, 53, 3, 2, 2, 2, 886, 887, 7, 83, 2, 2, 887, 55, 3, 2, 2, 2, 888,
	889, 5, 58, 30, 2, 889, 890, 7, 296, 2, 2, 890, 891, 5, 60, 31, 2, 891,
	892, 7, 297, 2, 2, 892, 57, 3, 2, 2, 2, 893, 894, 9, 6, 2, 2, 894, 59,
	3, 2, 2, 2, 895, 896, 5, 570, 286, 2, 896, 61, 3, 2, 2, 2, 897, 902, 7,
	217, 2, 2, 898, 899, 7, 296, 2, 2, 899, 900, 5, 64, 33, 2, 900, 901, 7,
	297, 2, 2, 901, 903, 3, 2, 2, 2, 902, 898, 3, 2, 2, 2, 902, 903, 3, 2,
	2, 2, 903, 63, 3, 2, 2, 2, 904, 905, 5, 692, 347, 2, 905, 65, 3, 2, 2,
	2, 906, 907, 7, 224, 2, 2, 907, 908, 7, 296, 2, 2, 908, 909, 5, 64, 33,
	2, 909, 910, 7, 331, 2, 2, 910, 911, 5, 68, 35, 2, 911, 912, 7, 331, 2,
	2, 912, 913, 5, 70, 36, 2, 913, 914, 7, 297, 2, 2, 914, 962, 3, 2, 2, 2,
	915, 916, 7, 219, 2, 2, 916, 917, 7, 296, 2, 2, 917, 918, 5, 64, 33, 2,
	918, 919, 7, 331, 2, 2, 919, 920, 5, 72, 37, 2, 920, 921, 7, 331, 2, 2,
	921, 922, 5, 74, 38, 2, 922, 923, 7, 297, 2, 2, 923, 962, 3, 2, 2, 2, 924,
	925, 7, 222, 2, 2, 925, 926, 7, 296, 2, 2, 926, 927, 5, 64, 33, 2, 927,
	928, 7, 331, 2, 2, 928, 929, 5, 72, 37, 2, 929, 930, 7, 297, 2, 2, 930,
	962, 3, 2, 2, 2, 931, 932, 7, 223, 2, 2, 932, 933, 7, 296, 2, 2, 933, 934,
	5, 64, 33, 2, 934, 935, 7, 331, 2, 2, 935, 936, 5, 72, 37, 2, 936, 937,
	7, 297, 2, 2, 937, 962, 3, 2, 2, 2, 938, 939, 7, 221, 2, 2, 939, 940, 7,
	296, 2, 2, 940, 941, 5, 64, 33, 2, 941, 942, 7, 331, 2, 2, 942, 943, 5,
	76, 39, 2, 943, 944, 7, 297, 2, 2, 944, 962, 3, 2, 2, 2, 945, 946, 7, 220,
	2, 2, 946, 947, 7, 296, 2, 2, 947, 948, 5, 64, 33, 2, 948, 949, 7, 331,
	2, 2, 949, 950, 5, 76, 39, 2, 950, 951, 7, 297, 2, 2, 951, 962, 3, 2, 2,
	2, 952, 953, 7, 218, 2, 2, 953, 954, 7, 296, 2, 2, 954, 955, 5, 64, 33,
	2, 955, 956, 7, 331, 2, 2, 956, 957, 5, 78, 40, 2, 957, 958, 7, 331, 2,
	2, 958, 959, 5, 72, 37, 2, 959, 960, 7, 297, 2, 2, 960, 962, 3, 2, 2, 2,
	961, 906, 3, 2, 2, 2, 961, 915, 3, 2, 2, 2, 961, 924, 3, 2, 2, 2, 961,
	931, 3, 2, 2, 2, 961, 938, 3, 2, 2, 2, 961, 945, 3, 2, 2, 2, 961, 952,
	3, 2, 2, 2, 962, 67, 3, 2, 2, 2, 963, 964, 7, 285, 2, 2, 964, 69, 3, 2,
	2, 2, 965, 966, 7, 285, 2, 2, 966, 71, 3, 2, 2, 2, 967, 968, 7, 285, 2,
	2, 968, 73, 3, 2, 2, 2, 969, 970, 7, 285, 2, 2, 970, 75, 3, 2, 2, 2, 971,
	972, 7, 285, 2, 2, 972, 77, 3, 2, 2, 2, 973, 974, 7, 285, 2, 2, 974, 79,
	3, 2, 2, 2, 975, 978, 5, 82, 42, 2, 976, 978, 5, 84, 43, 2, 977, 975, 3,
	2, 2, 2, 977, 976, 3, 2, 2, 2, 978, 81, 3, 2, 2, 2, 979, 980, 7, 227, 2,
	2, 980, 981, 7, 296, 2, 2, 981, 982, 5, 60, 31, 2, 982, 983, 7, 297, 2,
	2, 983, 83, 3, 2, 2, 2, 984, 985, 5, 86, 44, 2, 985, 986, 7, 296, 2, 2,
	986, 987, 5, 60, 31, 2, 987, 988, 7, 297, 2, 2, 988, 997, 3, 2, 2, 2, 989,
	990, 5, 88, 45, 2, 990, 991, 7, 296, 2, 2, 991, 992, 5, 60, 31, 2, 992,
	993, 7, 331, 2, 2, 993, 994, 5, 60, 31, 2, 994, 995, 7, 297, 2, 2, 995,
	997, 3, 2, 2, 2, 996, 984, 3, 2, 2, 2, 996, 989, 3, 2, 2, 2, 997, 85, 3,
	2, 2, 2, 998, 999, 9, 7, 2, 2, 999, 87, 3, 2, 2, 2, 1000, 1001, 9, 8, 2,
	2, 1001, 89, 3, 2, 2, 2, 1002, 1003, 7, 249, 2, 2, 1003, 1004, 7, 296,
	2, 2, 1004, 1005, 5, 42, 22, 2, 1005, 1006, 7, 297, 2, 2, 1006, 1007, 7,
	333, 2, 2, 1007, 91, 3, 2, 2, 2, 1008, 1009, 7, 250, 2, 2, 1009, 1021,
	7, 333, 2, 2, 1010, 1011, 7, 250, 2, 2, 1011, 1012, 7, 296, 2, 2, 1012,
	1015, 5, 98, 50, 2, 1013, 1014, 7, 331, 2, 2, 1014, 1016, 5, 94, 48, 2,
	1015, 1013, 3, 2, 2, 2, 1015, 1016, 3, 2, 2, 2, 1016, 1017, 3, 2, 2, 2,
	1017, 1018, 7, 297, 2, 2, 1018, 1019, 7, 333, 2, 2, 1019, 1021, 3, 2, 2,
	2, 1020, 1008, 3, 2, 2, 2, 1020, 1010, 3, 2, 2, 2, 1021, 93, 3, 2, 2, 2,
	1022, 1027, 5, 96, 49, 2, 1023, 1024, 7, 331, 2, 2, 1024, 1026, 5, 96,
	49, 2, 1025, 1023, 3, 2, 2, 2, 1026, 1029, 3, 2, 2, 2, 1027, 1025, 3, 2,
	2, 2, 1027, 1028, 3, 2, 2, 2, 1028, 95, 3, 2, 2, 2, 1029, 1027, 3, 2, 2,
	2, 1030, 1033, 5, 662, 332, 2, 1031, 1033, 5, 692, 347, 2, 1032, 1030,
	3, 2, 2, 2, 1032, 1031, 3, 2, 2, 2, 1033, 97, 3, 2, 2, 2, 1034, 1035, 7,
	285, 2, 2, 1035, 99, 3, 2, 2, 2, 1036, 1037, 7, 251, 2, 2, 1037, 1038,
	7, 333, 2, 2, 1038, 101, 3, 2, 2, 2, 1039, 1040, 7, 252, 2, 2, 1040, 1041,
	7, 333, 2, 2, 1041, 103, 3, 2, 2, 2, 1042, 1043, 7, 253, 2, 2, 1043, 1044,
	7, 333, 2, 2, 1044, 105, 3, 2, 2, 2, 1045, 1046, 7, 254, 2, 2, 1046, 1047,
	7, 296, 2, 2, 1047, 1048, 5, 108, 55, 2, 1048, 1049, 7, 297, 2, 2, 1049,
	1050, 7, 333, 2, 2, 1050, 107, 3, 2, 2, 2, 1051, 1052, 7, 285, 2, 2, 1052,
	109, 3, 2, 2, 2, 1053, 1054, 7, 255, 2, 2, 1054, 1055, 7, 333, 2, 2, 1055,
	111, 3, 2, 2, 2, 1056, 1057, 7, 265, 2, 2, 1057, 1058, 7, 296, 2, 2, 1058,
	1059, 5, 114, 58, 2, 1059, 1060, 7, 331, 2, 2, 1060, 1061, 5, 116, 59,
	2, 1061, 1062, 7, 297, 2, 2, 1062, 1063, 7, 333, 2, 2, 1063, 113, 3, 2,
	2, 2, 1064, 1069, 5, 662, 332, 2, 1065, 1066, 7, 331, 2, 2, 1066, 1068,
	5, 662, 332, 2, 1067, 1065, 3, 2, 2, 2, 1068, 1071, 3, 2, 2, 2, 1069, 1067,
	3, 2, 2, 2, 1069, 1070, 3, 2, 2, 2, 1070, 115, 3, 2, 2, 2, 1071, 1069,
	3, 2, 2, 2, 1072, 1076, 7, 289, 2, 2, 1073, 1076, 5, 692, 347, 2, 1074,
	1076, 5, 578, 290, 2, 1075, 1072, 3, 2, 2, 2, 1075, 1073, 3, 2, 2, 2, 1075,
	1074, 3, 2, 2, 2, 1076, 117, 3, 2, 2, 2, 1077, 1078, 7, 266, 2, 2, 1078,
	1079, 7, 296, 2, 2, 1079, 1080, 5, 116, 59, 2, 1080, 1081, 7, 297, 2, 2,
	1081, 1082, 7, 333, 2, 2, 1082, 119, 3, 2, 2, 2, 1083, 1084, 7, 267, 2,
	2, 1084, 1085, 7, 296, 2, 2, 1085, 1086, 5, 116, 59, 2, 1086, 1087, 7,
	297, 2, 2, 1087, 1088, 7, 333, 2, 2, 1088, 121, 3, 2, 2, 2, 1089, 1090,
	7, 268, 2, 2, 1090, 1091, 7, 296, 2, 2, 1091, 1092, 5, 116, 59, 2, 1092,
	1093, 7, 297, 2, 2, 1093, 1094, 7, 333, 2, 2, 1094, 123, 3, 2, 2, 2, 1095,
	1096, 7, 269, 2, 2, 1096, 1097, 7, 296, 2, 2, 1097, 1098, 5, 108, 55, 2,
	1098, 1099, 7, 331, 2, 2, 1099, 1100, 5, 116, 59, 2, 1100, 1101, 7, 297,
	2, 2, 1101, 1102, 7, 333, 2, 2, 1102, 125, 3, 2, 2, 2, 1103, 1104, 7, 270,
	2, 2, 1104, 1105, 7, 296, 2, 2, 1105, 1106, 5, 116, 59, 2, 1106, 1107,
	7, 297, 2, 2, 1107, 1108, 7, 333, 2, 2, 1108, 127, 3, 2, 2, 2, 1109, 1111,
	5, 130, 66, 2, 1110, 1109, 3, 2, 2, 2, 1111, 1114, 3, 2, 2, 2, 1112, 1110,
	3, 2, 2, 2, 1112, 1113, 3, 2, 2, 2, 1113, 129, 3, 2, 2, 2, 1114, 1112,
	3, 2, 2, 2, 1115, 1119, 5, 132, 67, 2, 1116, 1119, 5, 134, 68, 2, 1117,
	1119, 5, 168, 85, 2, 1118, 1115, 3, 2, 2, 2, 1118, 1116, 3, 2, 2, 2, 1118,
	1117, 3, 2, 2, 2, 1119, 131, 3, 2, 2, 2, 1120, 1121, 7, 56, 2, 2, 1121,
	1122, 5, 660, 331, 2, 1122, 1127, 7, 347, 2, 2, 1123, 1124, 7, 331, 2,
	2, 1124, 1126, 7, 347, 2, 2, 1125, 1123, 3, 2, 2, 2, 1126, 1129, 3, 2,
	2, 2, 1127, 1125, 3, 2, 2, 2, 1127, 1128, 3, 2, 2, 2, 1128, 1139, 3, 2,
	2, 2, 1129, 1127, 3, 2, 2, 2, 1130, 1131, 7, 348, 2, 2, 1131, 1136, 7,
	347, 2, 2, 1132, 1133, 7, 331, 2, 2, 1133, 1135, 7, 347, 2, 2, 1134, 1132,
	3, 2, 2, 2, 1135, 1138, 3, 2, 2, 2, 1136, 1134, 3, 2, 2, 2, 1136, 1137,
	3, 2, 2, 2, 1137, 1140, 3, 2, 2, 2, 1138, 1136, 3, 2, 2, 2, 1139, 1130,
	3, 2, 2, 2, 1139, 1140, 3, 2, 2, 2, 1140, 1141, 3, 2, 2, 2, 1141, 1142,
	7, 333, 2, 2, 1142, 133, 3, 2, 2, 2, 1143, 1144, 7, 47, 2, 2, 1144, 1145,
	7, 347, 2, 2, 1145, 1146, 7, 333, 2, 2, 1146, 135, 3, 2, 2, 2, 1147, 1149,
	5, 138, 70, 2, 1148, 1147, 3, 2, 2, 2, 1149, 1152, 3, 2, 2, 2, 1150, 1148,
	3, 2, 2, 2, 1150, 1151, 3, 2, 2, 2, 1151, 1153, 3, 2, 2, 2, 1152, 1150,
	3, 2, 2, 2, 1153, 1154, 7, 2, 2, 3, 1154, 137, 3, 2, 2, 2, 1155, 1158,
	5, 140, 71, 2, 1156, 1158, 5, 168, 85, 2, 1157, 1155, 3, 2, 2, 2, 1157,
	1156, 3, 2, 2, 2, 1158, 139, 3, 2, 2, 2, 1159, 1161, 5, 614, 308, 2, 1160,
	1159, 3, 2, 2, 2, 1161, 1164, 3, 2, 2, 2, 1162, 1160, 3, 2, 2, 2, 1162,
	1163, 3, 2, 2, 2, 1163, 1165, 3, 2, 2, 2, 1164, 1162, 3, 2, 2, 2, 1165,
	1166, 5, 142, 72, 2, 1166, 1168, 5, 662, 332, 2, 1167, 1169, 5, 144, 73,
	2, 1168, 1167, 3, 2, 2, 2, 1168, 1169, 3, 2, 2, 2, 1169, 1170, 3, 2, 2,
	2, 1170, 1171, 5, 146, 74, 2, 1171, 1175, 7, 333, 2, 2, 1172, 1174, 5,
	158, 80, 2, 1173, 1172, 3, 2, 2, 2, 1174, 1177, 3, 2, 2, 2, 1175, 1173,
	3, 2, 2, 2, 1175, 1176, 3, 2, 2, 2, 1176, 1178, 3, 2, 2, 2, 1177, 1175,
	3, 2, 2, 2, 1178, 1179, 7, 29, 2, 2, 1179, 1204, 3, 2, 2, 2, 1180, 1182,
	5, 614, 308, 2, 1181, 1180, 3, 2, 2, 2, 1182, 1185, 3, 2, 2, 2, 1183, 1181,
	3, 2, 2, 2, 1183, 1184, 3, 2, 2, 2, 1184, 1186, 3, 2, 2, 2, 1185, 1183,
	3, 2, 2, 2, 1186, 1187, 5, 142, 72, 2, 1187, 1189, 5, 662, 332, 2, 1188,
	1190, 5, 144, 73, 2, 1189, 1188, 3, 2, 2, 2, 1189, 1190, 3, 2, 2, 2, 1190,
	1192, 3, 2, 2, 2, 1191, 1193, 5, 148, 75, 2, 1192, 1191, 3, 2, 2, 2, 1192,
	1193, 3, 2, 2, 2, 1193, 1194, 3, 2, 2, 2, 1194, 1198, 7, 333, 2, 2, 1195,
	1197, 5, 164, 83, 2, 1196, 1195, 3, 2, 2, 2, 1197, 1200, 3, 2, 2, 2, 1198,
	1196, 3, 2, 2, 2, 1198, 1199, 3, 2, 2, 2, 1199, 1201, 3, 2, 2, 2, 1200,
	1198, 3, 2, 2, 2, 1201, 1202, 7, 29, 2, 2, 1202, 1204, 3, 2, 2, 2, 1203,
	1162, 3, 2, 2, 2, 1203, 1183, 3, 2, 2, 2, 1204, 141, 3, 2, 2, 2, 1205,
	1206, 9, 9, 2, 2, 1206, 143, 3, 2, 2, 2, 1207, 1208, 7, 338, 2, 2, 1208,
	1209, 7, 296, 2, 2, 1209, 1214, 5, 188, 95, 2, 1210, 1211, 7, 331, 2, 2,
	1211, 1213, 5, 188, 95, 2, 1212, 1210, 3, 2, 2, 2, 1213, 1216, 3, 2, 2,
	2, 1214, 1212, 3, 2, 2, 2, 1214, 1215, 3, 2, 2, 2, 1215, 1217, 3, 2, 2,
	2, 1216, 1214, 3, 2, 2, 2, 1217, 1218, 7, 297, 2, 2, 1218, 145, 3, 2, 2,
	2, 1219, 1220, 7, 296, 2, 2, 1220, 1225, 5, 150, 76, 2, 1221, 1222, 7,
	331, 2, 2, 1222, 1224, 5, 150, 76, 2, 1223, 1221, 3, 2, 2, 2, 1224, 1227,
	3, 2, 2, 2, 1225, 1223, 3, 2, 2, 2, 1225, 1226, 3, 2, 2, 2, 1226, 1228,
	3, 2, 2, 2, 1227, 1225, 3, 2, 2, 2, 1228, 1229, 7, 297, 2, 2, 1229, 147,
	3, 2, 2, 2, 1230, 1231, 7, 296, 2, 2, 1231, 1236, 5, 156, 79, 2, 1232,
	1233, 7, 331, 2, 2, 1233, 1235, 5, 156, 79, 2, 1234, 1232, 3, 2, 2, 2,
	1235, 1238, 3, 2, 2, 2, 1236, 1234, 3, 2, 2, 2, 1236, 1237, 3, 2, 2, 2,
	1237, 1239, 3, 2, 2, 2, 1238, 1236, 3, 2, 2, 2, 1239, 1240, 7, 297, 2,
	2, 1240, 1244, 3, 2, 2, 2, 1241, 1242, 7, 296, 2, 2, 1242, 1244, 7, 297,
	2, 2, 1243, 1230, 3, 2, 2, 2, 1243, 1241, 3, 2, 2, 2, 1244, 149, 3, 2,
	2, 2, 1245, 1247, 5, 152, 77, 2, 1246, 1245, 3, 2, 2, 2, 1246, 1247, 3,
	2, 2, 2, 1247, 1257, 3, 2, 2, 2, 1248, 1249, 7, 330, 2, 2, 1249, 1250,
	5, 672, 337, 2, 1250, 1252, 7, 296, 2, 2, 1251, 1253, 5, 152, 77, 2, 1252,
	1251, 3, 2, 2, 2, 1252, 1253, 3, 2, 2, 2, 1253, 1254, 3, 2, 2, 2, 1254,
	1255, 7, 297, 2, 2, 1255, 1257, 3, 2, 2, 2, 1256, 1246, 3, 2, 2, 2, 1256,
	1248, 3, 2, 2, 2, 1257, 151, 3, 2, 2, 2, 1258, 1271, 5, 154, 78, 2, 1259,
	1260, 7, 300, 2, 2, 1260, 1265, 5, 154, 78, 2, 1261, 1262, 7, 331, 2, 2,
	1262, 1264, 5, 154, 78, 2, 1263, 1261, 3, 2, 2, 2, 1264, 1267, 3, 2, 2,
	2, 1265, 1263, 3, 2, 2, 2, 1265, 1266, 3, 2, 2, 2, 1266, 1268, 3, 2, 2,
	2, 1267, 1265, 3, 2, 2, 2, 1268, 1269, 7, 301, 2, 2, 1269, 1271, 3, 2,
	2, 2, 1270, 1258, 3, 2, 2, 2, 1270, 1259, 3, 2, 2, 2, 1271, 153, 3, 2,
	2, 2, 1272, 1277, 5, 672, 337, 2, 1273, 1274, 7, 298, 2, 2, 1274, 1275,
	5, 574, 288, 2, 1275, 1276, 7, 299, 2, 2, 1276, 1278, 3, 2, 2, 2, 1277,
	1273, 3, 2, 2, 2, 1277, 1278, 3, 2, 2, 2, 1278, 155, 3, 2, 2, 2, 1279,
	1281, 5, 614, 308, 2, 1280, 1279, 3, 2, 2, 2, 1281, 1284, 3, 2, 2, 2, 1282,
	1280, 3, 2, 2, 2, 1282, 1283, 3, 2, 2, 2, 1283, 1285, 3, 2, 2, 2, 1284,
	1282, 3, 2, 2, 2, 1285, 1301, 5, 194, 98, 2, 1286, 1288, 5, 614, 308, 2,
	1287, 1286, 3, 2, 2, 2, 1288, 1291, 3, 2, 2, 2, 1289, 1287, 3, 2, 2, 2,
	1289, 1290, 3, 2, 2, 2, 1290, 1292, 3, 2, 2, 2, 1291, 1289, 3, 2, 2, 2,
	1292, 1301, 5, 196, 99, 2, 1293, 1295, 5, 614, 308, 2, 1294, 1293, 3, 2,
	2, 2, 1295, 1298, 3, 2, 2, 2, 1296, 1294, 3, 2, 2, 2, 1296, 1297, 3, 2,
	2, 2, 1297, 1299, 3, 2, 2, 2, 1298, 1296, 3, 2, 2, 2, 1299, 1301, 5, 198,
	100, 2, 1300, 1282, 3, 2, 2, 2, 1300, 1289, 3, 2, 2, 2, 1300, 1296, 3,
	2, 2, 2, 1301, 157, 3, 2, 2, 2, 1302, 1303, 5, 156, 79, 2, 1303, 1304,
	7, 333, 2, 2, 1304, 1307, 3, 2, 2, 2, 1305, 1307, 5, 164, 83, 2, 1306,
	1302, 3, 2, 2, 2, 1306, 1305, 3, 2, 2, 2, 1307, 159, 3, 2, 2, 2, 1308,
	1310, 5, 614, 308, 2, 1309, 1308, 3, 2, 2, 2, 1310, 1313, 3, 2, 2, 2, 1311,
	1309, 3, 2, 2, 2, 1311, 1312, 3, 2, 2, 2, 1312, 1314, 3, 2, 2, 2, 1313,
	1311, 3, 2, 2, 2, 1314, 1381, 5, 162, 82, 2, 1315, 1317, 5, 614, 308, 2,
	1316, 1315, 3, 2, 2, 2, 1317, 1320, 3, 2, 2, 2, 1318, 1316, 3, 2, 2, 2,
	1318, 1319, 3, 2, 2, 2, 1319, 1321, 3, 2, 2, 2, 1320, 1318, 3, 2, 2, 2,
	1321, 1322, 5, 186, 94, 2, 1322, 1323, 7, 333, 2, 2, 1323, 1381, 3, 2,
	2, 2, 1324, 1326, 5, 614, 308, 2, 1325, 1324, 3, 2, 2, 2, 1326, 1329, 3,
	2, 2, 2, 1327, 1325, 3, 2, 2, 2, 1327, 1328, 3, 2, 2, 2, 1328, 1330, 3,
	2, 2, 2, 1329, 1327, 3, 2, 2, 2, 1330, 1381, 5, 166, 84, 2, 1331, 1333,
	5, 614, 308, 2, 1332, 1331, 3, 2, 2, 2, 1333, 1336, 3, 2, 2, 2, 1334, 1332,
	3, 2, 2, 2, 1334, 1335, 3, 2, 2, 2, 1335, 1337, 3, 2, 2, 2, 1336, 1334,
	3, 2, 2, 2, 1337, 1381, 5, 406, 204, 2, 1338, 1340, 5, 614, 308, 2, 1339,
	1338, 3, 2, 2, 2, 1340, 1343, 3, 2, 2, 2, 1341, 1339, 3, 2, 2, 2, 1341,
	1342, 3, 2, 2, 2, 1342, 1344, 3, 2, 2, 2, 1343, 1341, 3, 2, 2, 2, 1344,
	1381, 5, 310, 156, 2, 1345, 1347, 5, 614, 308, 2, 1346, 1345, 3, 2, 2,
	2, 1347, 1350, 3, 2, 2, 2, 1348, 1346, 3, 2, 2, 2, 1348, 1349, 3, 2, 2,
	2, 1349, 1351, 3, 2, 2, 2, 1350, 1348, 3, 2, 2, 2, 1351, 1381, 5, 360,
	181, 2, 1352, 1354, 5, 614, 308, 2, 1353, 1352, 3, 2, 2, 2, 1354, 1357,
	3, 2, 2, 2, 1355, 1353, 3, 2, 2, 2, 1355, 1356, 3, 2, 2, 2, 1356, 1358,
	3, 2, 2, 2, 1357, 1355, 3, 2, 2, 2, 1358, 1381, 5, 412, 207, 2, 1359, 1361,
	5, 614, 308, 2, 1360, 1359, 3, 2, 2, 2, 1361, 1364, 3, 2, 2, 2, 1362, 1360,
	3, 2, 2, 2, 1362, 1363, 3, 2, 2, 2, 1363, 1365, 3, 2, 2, 2, 1364, 1362,
	3, 2, 2, 2, 1365, 1381, 5, 414, 208, 2, 1366, 1368, 5, 614, 308, 2, 1367,
	1366, 3, 2, 2, 2, 1368, 1371, 3, 2, 2, 2, 1369, 1367, 3, 2, 2, 2, 1369,
	1370, 3, 2, 2, 2, 1370, 1372, 3, 2, 2, 2, 1371, 1369, 3, 2, 2, 2, 1372,
	1381, 5, 386, 194, 2, 1373, 1375, 5, 614, 308, 2, 1374, 1373, 3, 2, 2,
	2, 1375, 1378, 3, 2, 2, 2, 1376, 1374, 3, 2, 2, 2, 1376, 1377, 3, 2, 2,
	2, 1377, 1379, 3, 2, 2, 2, 1378, 1376, 3, 2, 2, 2, 1379, 1381, 5, 396,
	199, 2, 1380, 1311, 3, 2, 2, 2, 1380, 1318, 3, 2, 2, 2, 1380, 1327, 3,
	2, 2, 2, 1380, 1334, 3, 2, 2, 2, 1380, 1341, 3, 2, 2, 2, 1380, 1348, 3,
	2, 2, 2, 1380, 1355, 3, 2, 2, 2, 1380, 1362, 3, 2, 2, 2, 1380, 1369, 3,
	2, 2, 2, 1380, 1376, 3, 2, 2, 2, 1381, 161, 3, 2, 2, 2, 1382, 1393, 5,
	204, 103, 2, 1383, 1393, 5, 210, 106, 2, 1384, 1393, 5, 202, 102, 2, 1385,
	1393, 5, 206, 104, 2, 1386, 1393, 5, 212, 107, 2, 1387, 1393, 5, 208, 105,
	2, 1388, 1393, 5, 200, 101, 2, 1389, 1393, 5, 382, 192, 2, 1390, 1393,
	5, 284, 143, 2, 1391, 1393, 5, 276, 139, 2, 1392, 1382, 3, 2, 2, 2, 1392,
	1383, 3, 2, 2, 2, 1392, 1384, 3, 2, 2, 2, 1392, 1385, 3, 2, 2, 2, 1392,
	1386, 3, 2, 2, 2, 1392, 1387, 3, 2, 2, 2, 1392, 1388, 3, 2, 2, 2, 1392,
	1389, 3, 2, 2, 2, 1392, 1390, 3, 2, 2, 2, 1392, 1391, 3, 2, 2, 2, 1393,
	163, 3, 2, 2, 2, 1394, 1414, 5, 160, 81, 2, 1395, 1414, 5, 380, 191, 2,
	1396, 1414, 5, 466, 234, 2, 1397, 1399, 5, 614, 308, 2, 1398, 1397, 3,
	2, 2, 2, 1399, 1402, 3, 2, 2, 2, 1400, 1398, 3, 2, 2, 2, 1400, 1401, 3,
	2, 2, 2, 1401, 1403, 3, 2, 2, 2, 1402, 1400, 3, 2, 2, 2, 1403, 1404, 5,
	188, 95, 2, 1404, 1405, 7, 333, 2, 2, 1405, 1414, 3, 2, 2, 2, 1406, 1408,
	5, 614, 308, 2, 1407, 1406, 3, 2, 2, 2, 1408, 1411, 3, 2, 2, 2, 1409, 1407,
	3, 2, 2, 2, 1409, 1410, 3, 2, 2, 2, 1410, 1412, 3, 2, 2, 2, 1411, 1409,
	3, 2, 2, 2, 1412, 1414, 5, 190, 96, 2, 1413, 1394, 3, 2, 2, 2, 1413, 1395,
	3, 2, 2, 2, 1413, 1396, 3, 2, 2, 2, 1413, 1400, 3, 2, 2, 2, 1413, 1409,
	3, 2, 2, 2, 1414, 165, 3, 2, 2, 2, 1415, 1416, 7, 19, 2, 2, 1416, 1417,
	5, 244, 123, 2, 1417, 1418, 7, 333, 2, 2, 1418, 167, 3, 2, 2, 2, 1419,
	1420, 7, 16, 2, 2, 1420, 1421, 5, 624, 313, 2, 1421, 1422, 7, 333, 2, 2,
	1422, 1426, 5, 170, 86, 2, 1423, 1425, 5, 172, 87, 2, 1424, 1423, 3, 2,
	2, 2, 1425, 1428, 3, 2, 2, 2, 1426, 1424, 3, 2, 2, 2, 1426, 1427, 3, 2,
	2, 2, 1427, 1429, 3, 2, 2, 2, 1428, 1426, 3, 2, 2, 2, 1429, 1430, 7, 26,
	2, 2, 1430, 169, 3, 2, 2, 2, 1431, 1440, 7, 20, 2, 2, 1432, 1433, 5, 660,
	331, 2, 1433, 1434, 7, 330, 2, 2, 1434, 1436, 3, 2, 2, 2, 1435, 1432, 3,
	2, 2, 2, 1435, 1436, 3, 2, 2, 2, 1436, 1437, 3, 2, 2, 2, 1437, 1439, 5,
	622, 312, 2, 1438, 1435, 3, 2, 2, 2, 1439, 1442, 3, 2, 2, 2, 1440, 1438,
	3, 2, 2, 2, 1440, 1441, 3, 2, 2, 2, 1441, 1443, 3, 2, 2, 2, 1442, 1440,
	3, 2, 2, 2, 1443, 1444, 7, 333, 2, 2, 1444, 171, 3, 2, 2, 2, 1445, 1446,
	5, 174, 88, 2, 1446, 1447, 5, 182, 92, 2, 1447, 1461, 3, 2, 2, 2, 1448,
	1449, 5, 176, 89, 2, 1449, 1450, 5, 182, 92, 2, 1450, 1461, 3, 2, 2, 2,
	1451, 1452, 5, 176, 89, 2, 1452, 1453, 5, 184, 93, 2, 1453, 1461, 3, 2,
	2, 2, 1454, 1455, 5, 180, 91, 2, 1455, 1456, 5, 182, 92, 2, 1456, 1461,
	3, 2, 2, 2, 1457, 1458, 5, 180, 91, 2, 1458, 1459, 5, 184, 93, 2, 1459,
	1461, 3, 2, 2, 2, 1460, 1445, 3, 2, 2, 2, 1460, 1448, 3, 2, 2, 2, 1460,
	1451, 3, 2, 2, 2, 1460, 1454, 3, 2, 2, 2, 1460, 1457, 3, 2, 2, 2, 1461,
	173, 3, 2, 2, 2, 1462, 1463, 7, 18, 2, 2, 1463, 175, 3, 2, 2, 2, 1464,
	1465, 7, 51, 2, 2, 1465, 1466, 5, 178, 90, 2, 1466, 177, 3, 2, 2, 2, 1467,
	1472, 5, 686, 344, 2, 1468, 1469, 7, 330, 2, 2, 1469, 1471, 5, 658, 330,
	2, 1470, 1468, 3, 2, 2, 2, 1471, 1474, 3, 2, 2, 2, 1472, 1470, 3, 2, 2,
	2, 1472, 1473, 3, 2, 2, 2, 1473, 179, 3, 2, 2, 2, 1474, 1472, 3, 2, 2,
	2, 1475, 1479, 7, 14, 2, 2, 1476, 1477, 5, 660, 331, 2, 1477, 1478, 7,
	330, 2, 2, 1478, 1480, 3, 2, 2, 2, 1479, 1476, 3, 2, 2, 2, 1479, 1480,
	3, 2, 2, 2, 1480, 1481, 3, 2, 2, 2, 1481, 1482, 5, 622, 312, 2, 1482, 181,
	3, 2, 2, 2, 1483, 1487, 7, 55, 2, 2, 1484, 1486, 5, 660, 331, 2, 1485,
	1484, 3, 2, 2, 2, 1486, 1489, 3, 2, 2, 2, 1487, 1485, 3, 2, 2, 2, 1487,
	1488, 3, 2, 2, 2, 1488, 183, 3, 2, 2, 2, 1489, 1487, 3, 2, 2, 2, 1490,
	1494, 7, 115, 2, 2, 1491, 1492, 5, 660, 331, 2, 1492, 1493, 7, 330, 2,
	2, 1493, 1495, 3, 2, 2, 2, 1494, 1491, 3, 2, 2, 2, 1494, 1495, 3, 2, 2,
	2, 1495, 1496, 3, 2, 2, 2, 1496, 1499, 5, 622, 312, 2, 1497, 1498, 7, 332,
	2, 2, 1498, 1500, 7, 16, 2, 2, 1499, 1497, 3, 2, 2, 2, 1499, 1500, 3, 2,
	2, 2, 1500, 185, 3, 2, 2, 2, 1501, 1503, 7, 57, 2, 2, 1502, 1504, 7, 94,
	2, 2, 1503, 1502, 3, 2, 2, 2, 1503, 1504, 3, 2, 2, 2, 1504, 1506, 3, 2,
	2, 2, 1505, 1507, 5, 274, 138, 2, 1506, 1505, 3, 2, 2, 2, 1506, 1507, 3,
	2, 2, 2, 1507, 1508, 3, 2, 2, 2, 1508, 1514, 5, 244, 123, 2, 1509, 1510,
	7, 57, 2, 2, 1510, 1511, 5, 192, 97, 2, 1511, 1512, 5, 244, 123, 2, 1512,
	1514, 3, 2, 2, 2, 1513, 1501, 3, 2, 2, 2, 1513, 1509, 3, 2, 2, 2, 1514,
	187, 3, 2, 2, 2, 1515, 1517, 7, 71, 2, 2, 1516, 1518, 7, 94, 2, 2, 1517,
	1516, 3, 2, 2, 2, 1517, 1518, 3, 2, 2, 2, 1518, 1520, 3, 2, 2, 2, 1519,
	1521, 5, 274, 138, 2, 1520, 1519, 3, 2, 2, 2, 1520, 1521, 3, 2, 2, 2, 1521,
	1522, 3, 2, 2, 2, 1522, 1528, 5, 244, 123, 2, 1523, 1524, 7, 71, 2, 2,
	1524, 1525, 5, 192, 97, 2, 1525, 1526, 5, 244, 123, 2, 1526, 1528, 3, 2,
	2, 2, 1527, 1515, 3, 2, 2, 2, 1527, 1523, 3, 2, 2, 2, 1528, 189, 3, 2,
	2, 2, 1529, 1531, 7, 97, 2, 2, 1530, 1532, 5, 274, 138, 2, 1531, 1530,
	3, 2, 2, 2, 1531, 1532, 3, 2, 2, 2, 1532, 1533, 3, 2, 2, 2, 1533, 1534,
	5, 250, 126, 2, 1534, 1535, 7, 333, 2, 2, 1535, 191, 3, 2, 2, 2, 1536,
	1537, 9, 10, 2, 2, 1537, 193, 3, 2, 2, 2, 1538, 1540, 7, 49, 2, 2, 1539,
	1541, 5, 214, 108, 2, 1540, 1539, 3, 2, 2, 2, 1540, 1541, 3, 2, 2, 2, 1541,
	1543, 3, 2, 2, 2, 1542, 1544, 7, 94, 2, 2, 1543, 1542, 3, 2, 2, 2, 1543,
	1544, 3, 2, 2, 2, 1544, 1546, 3, 2, 2, 2, 1545, 1547, 5, 274, 138, 2, 1546,
	1545, 3, 2, 2, 2, 1546, 1547, 3, 2, 2, 2, 1547, 1548, 3, 2, 2, 2, 1548,
	1549, 5, 246, 124, 2, 1549, 195, 3, 2, 2, 2, 1550, 1552, 7, 50, 2, 2, 1551,
	1553, 5, 214, 108, 2, 1552, 1551, 3, 2, 2, 2, 1552, 1553, 3, 2, 2, 2, 1553,
	1555, 3, 2, 2, 2, 1554, 1556, 7, 94, 2, 2, 1555, 1554, 3, 2, 2, 2, 1555,
	1556, 3, 2, 2, 2, 1556, 1558, 3, 2, 2, 2, 1557, 1559, 5, 274, 138, 2, 1558,
	1557, 3, 2, 2, 2, 1558, 1559, 3, 2, 2, 2, 1559, 1560, 3, 2, 2, 2, 1560,
	1561, 5, 246, 124, 2, 1561, 197, 3, 2, 2, 2, 1562, 1564, 7, 70, 2, 2, 1563,
	1565, 5, 214, 108, 2, 1564, 1563, 3, 2, 2, 2, 1564, 1565, 3, 2, 2, 2, 1565,
	1567, 3, 2, 2, 2, 1566, 1568, 7, 94, 2, 2, 1567, 1566, 3, 2, 2, 2, 1567,
	1568, 3, 2, 2, 2, 1568, 1570, 3, 2, 2, 2, 1569, 1571, 5, 274, 138, 2, 1570,
	1569, 3, 2, 2, 2, 1570, 1571, 3, 2, 2, 2, 1571, 1572, 3, 2, 2, 2, 1572,
	1587, 5, 246, 124, 2, 1573, 1574, 7, 70, 2, 2, 1574, 1576, 7, 84, 2, 2,
	1575, 1577, 7, 94, 2, 2, 1576, 1575, 3, 2, 2, 2, 1576, 1577, 3, 2, 2, 2,
	1577, 1579, 3, 2, 2, 2, 1578, 1580, 5, 274, 138, 2, 1579, 1578, 3, 2, 2,
	2, 1579, 1580, 3, 2, 2, 2, 1580, 1581, 3, 2, 2, 2, 1581, 1587, 5, 254,
	128, 2, 1582, 1583, 7, 70, 2, 2, 1583, 1584, 5, 216, 109, 2, 1584, 1585,
	5, 254, 128, 2, 1585, 1587, 3, 2, 2, 2, 1586, 1562, 3, 2, 2, 2, 1586, 1573,
	3, 2, 2, 2, 1586, 1582, 3, 2, 2, 2, 1587, 199, 3, 2, 2, 2, 1588, 1589,
	7, 34, 2, 2, 1589, 1590, 5, 238, 120, 2, 1590, 1591, 7, 333, 2, 2, 1591,
	201, 3, 2, 2, 2, 1592, 1593, 7, 52, 2, 2, 1593, 1594, 5, 252, 127, 2, 1594,
	1595, 7, 333, 2, 2, 1595, 203, 3, 2, 2, 2, 1596, 1598, 5, 214, 108, 2,
	1597, 1599, 7, 94, 2, 2, 1598, 1597, 3, 2, 2, 2, 1598, 1599, 3, 2, 2, 2,
	1599, 1601, 3, 2, 2, 2, 1600, 1602, 5, 230, 116, 2, 1601, 1600, 3, 2, 2,
	2, 1601, 1602, 3, 2, 2, 2, 1602, 1603, 3, 2, 2, 2, 1603, 1604, 5, 242,
	122, 2, 1604, 1605, 7, 333, 2, 2, 1605, 1711, 3, 2, 2, 2, 1606, 1608, 5,
	214, 108, 2, 1607, 1609, 5, 222, 112, 2, 1608, 1607, 3, 2, 2, 2, 1608,
	1609, 3, 2, 2, 2, 1609, 1611, 3, 2, 2, 2, 1610, 1612, 7, 94, 2, 2, 1611,
	1610, 3, 2, 2, 2, 1611, 1612, 3, 2, 2, 2, 1612, 1614, 3, 2, 2, 2, 1613,
	1615, 5, 230, 116, 2, 1614, 1613, 3, 2, 2, 2, 1614, 1615, 3, 2, 2, 2, 1615,
	1616, 3, 2, 2, 2, 1616, 1617, 5, 240, 121, 2, 1617, 1618, 7, 333, 2, 2,
	1618, 1711, 3, 2, 2, 2, 1619, 1621, 5, 214, 108, 2, 1620, 1622, 9, 11,
	2, 2, 1621, 1620, 3, 2, 2, 2, 1621, 1622, 3, 2, 2, 2, 1622, 1624, 3, 2,
	2, 2, 1623, 1625, 7, 94, 2, 2, 1624, 1623, 3, 2, 2, 2, 1624, 1625, 3, 2,
	2, 2, 1625, 1626, 3, 2, 2, 2, 1626, 1628, 5, 274, 138, 2, 1627, 1629, 5,
	230, 116, 2, 1628, 1627, 3, 2, 2, 2, 1628, 1629, 3, 2, 2, 2, 1629, 1630,
	3, 2, 2, 2, 1630, 1631, 5, 242, 122, 2, 1631, 1632, 7, 333, 2, 2, 1632,
	1711, 3, 2, 2, 2, 1633, 1635, 5, 214, 108, 2, 1634, 1636, 5, 222, 112,
	2, 1635, 1634, 3, 2, 2, 2, 1635, 1636, 3, 2, 2, 2, 1636, 1638, 3, 2, 2,
	2, 1637, 1639, 9, 11, 2, 2, 1638, 1637, 3, 2, 2, 2, 1638, 1639, 3, 2, 2,
	2, 1639, 1641, 3, 2, 2, 2, 1640, 1642, 7, 94, 2, 2, 1641, 1640, 3, 2, 2,
	2, 1641, 1642, 3, 2, 2, 2, 1642, 1643, 3, 2, 2, 2, 1643, 1645, 5, 274,
	138, 2, 1644, 1646, 5, 230, 116, 2, 1645, 1644, 3, 2, 2, 2, 1645, 1646,
	3, 2, 2, 2, 1646, 1647, 3, 2, 2, 2, 1647, 1648, 5, 240, 121, 2, 1648, 1649,
	7, 333, 2, 2, 1649, 1711, 3, 2, 2, 2, 1650, 1652, 7, 113, 2, 2, 1651, 1653,
	5, 228, 115, 2, 1652, 1651, 3, 2, 2, 2, 1652, 1653, 3, 2, 2, 2, 1653, 1655,
	3, 2, 2, 2, 1654, 1656, 7, 94, 2, 2, 1655, 1654, 3, 2, 2, 2, 1655, 1656,
	3, 2, 2, 2, 1656, 1658, 3, 2, 2, 2, 1657, 1659, 5, 230, 116, 2, 1658, 1657,
	3, 2, 2, 2, 1658, 1659, 3, 2, 2, 2, 1659, 1660, 3, 2, 2, 2, 1660, 1661,
	5, 242, 122, 2, 1661, 1662, 7, 333, 2, 2, 1662, 1711, 3, 2, 2, 2, 1663,
	1665, 7, 113, 2, 2, 1664, 1666, 5, 222, 112, 2, 1665, 1664, 3, 2, 2, 2,
	1665, 1666, 3, 2, 2, 2, 1666, 1668, 3, 2, 2, 2, 1667, 1669, 7, 94, 2, 2,
	1668, 1667, 3, 2, 2, 2, 1668, 1669, 3, 2, 2, 2, 1669, 1671, 3, 2, 2, 2,
	1670, 1672, 5, 230, 116, 2, 1671, 1670, 3, 2, 2, 2, 1671, 1672, 3, 2, 2,
	2, 1672, 1673, 3, 2, 2, 2, 1673, 1674, 5, 240, 121, 2, 1674, 1675, 7, 333,
	2, 2, 1675, 1711, 3, 2, 2, 2, 1676, 1678, 7, 113, 2, 2, 1677, 1679, 5,
	228, 115, 2, 1678, 1677, 3, 2, 2, 2, 1678, 1679, 3, 2, 2, 2, 1679, 1681,
	3, 2, 2, 2, 1680, 1682, 9, 11, 2, 2, 1681, 1680, 3, 2, 2, 2, 1681, 1682,
	3, 2, 2, 2, 1682, 1684, 3, 2, 2, 2, 1683, 1685, 7, 94, 2, 2, 1684, 1683,
	3, 2, 2, 2, 1684, 1685, 3, 2, 2, 2, 1685, 1686, 3, 2, 2, 2, 1686, 1688,
	5, 274, 138, 2, 1687, 1689, 5, 230, 116, 2, 1688, 1687, 3, 2, 2, 2, 1688,
	1689, 3, 2, 2, 2, 1689, 1690, 3, 2, 2, 2, 1690, 1691, 5, 242, 122, 2, 1691,
	1692, 7, 333, 2, 2, 1692, 1711, 3, 2, 2, 2, 1693, 1695, 7, 113, 2, 2, 1694,
	1696, 5, 222, 112, 2, 1695, 1694, 3, 2, 2, 2, 1695, 1696, 3, 2, 2, 2, 1696,
	1698, 3, 2, 2, 2, 1697, 1699, 9, 11, 2, 2, 1698, 1697, 3, 2, 2, 2, 1698,
	1699, 3, 2, 2, 2, 1699, 1701, 3, 2, 2, 2, 1700, 1702, 7, 94, 2, 2, 1701,
	1700, 3, 2, 2, 2, 1701, 1702, 3, 2, 2, 2, 1702, 1703, 3, 2, 2, 2, 1703,
	1705, 5, 274, 138, 2, 1704, 1706, 5, 230, 116, 2, 1705, 1704, 3, 2, 2,
	2, 1705, 1706, 3, 2, 2, 2, 1706, 1707, 3, 2, 2, 2, 1707, 1708, 5, 240,
	121, 2, 1708, 1709, 7, 333, 2, 2, 1709, 1711, 3, 2, 2, 2, 1710, 1596, 3,
	2, 2, 2, 1710, 1606, 3, 2, 2, 2, 1710, 1619, 3, 2, 2, 2, 1710, 1633, 3,
	2, 2, 2, 1710, 1650, 3, 2, 2, 2, 1710, 1663, 3, 2, 2, 2, 1710, 1676, 3,
	2, 2, 2, 1710, 1693, 3, 2, 2, 2, 1711, 205, 3, 2, 2, 2, 1712, 1713, 7,
	82, 2, 2, 1713, 1714, 5, 248, 125, 2, 1714, 1715, 7, 333, 2, 2, 1715, 207,
	3, 2, 2, 2, 1716, 1717, 7, 83, 2, 2, 1717, 1718, 5, 248, 125, 2, 1718,
	1719, 7, 333, 2, 2, 1719, 209, 3, 2, 2, 2, 1720, 1722, 7, 84, 2, 2, 1721,
	1723, 7, 94, 2, 2, 1722, 1721, 3, 2, 2, 2, 1722, 1723, 3, 2, 2, 2, 1723,
	1725, 3, 2, 2, 2, 1724, 1726, 5, 274, 138, 2, 1725, 1724, 3, 2, 2, 2, 1725,
	1726, 3, 2, 2, 2, 1726, 1727, 3, 2, 2, 2, 1727, 1728, 5, 252, 127, 2, 1728,
	1729, 7, 333, 2, 2, 1729, 211, 3, 2, 2, 2, 1730, 1731, 7, 104, 2, 2, 1731,
	1732, 5, 252, 127, 2, 1732, 1733, 7, 333, 2, 2, 1733, 213, 3, 2, 2, 2,
	1734, 1735, 9, 12, 2, 2, 1735, 215, 3, 2, 2, 2, 1736, 1737, 9, 13, 2, 2,
	1737, 217, 3, 2, 2, 2, 1738, 1742, 5, 674, 338, 2, 1739, 1741, 5, 272,
	137, 2, 1740, 1739, 3, 2, 2, 2, 1741, 1744, 3, 2, 2, 2, 1742, 1740, 3,
	2, 2, 2, 1742, 1743, 3, 2, 2, 2, 1743, 1750, 3, 2, 2, 2, 1744, 1742, 3,
	2, 2, 2, 1745, 1746, 5, 674, 338, 2, 1746, 1747, 7, 335, 2, 2, 1747, 1748,
	5, 570, 286, 2, 1748, 1750, 3, 2, 2, 2, 1749, 1738, 3, 2, 2, 2, 1749, 1745,
	3, 2, 2, 2, 1750, 219, 3, 2, 2, 2, 1751, 1755, 5, 692, 347, 2, 1752, 1754,
	5, 272, 137, 2, 1753, 1752, 3, 2, 2, 2, 1754, 1757, 3, 2, 2, 2, 1755, 1753,
	3, 2, 2, 2, 1755, 1756, 3, 2, 2, 2, 1756, 1763, 3, 2, 2, 2, 1757, 1755,
	3, 2, 2, 2, 1758, 1759, 5, 692, 347, 2, 1759, 1760, 7, 335, 2, 2, 1760,
	1761, 5, 570, 286, 2, 1761, 1763, 3, 2, 2, 2, 1762, 1751, 3, 2, 2, 2, 1762,
	1758, 3, 2, 2, 2, 1763, 221, 3, 2, 2, 2, 1764, 1765, 7, 296, 2, 2, 1765,
	1766, 5, 224, 113, 2, 1766, 1767, 7, 331, 2, 2, 1767, 1768, 5, 226, 114,
	2, 1768, 1769, 7, 297, 2, 2, 1769, 1801, 3, 2, 2, 2, 1770, 1771, 7, 296,
	2, 2, 1771, 1772, 5, 226, 114, 2, 1772, 1773, 7, 331, 2, 2, 1773, 1774,
	5, 224, 113, 2, 1774, 1775, 7, 297, 2, 2, 1775, 1801, 3, 2, 2, 2, 1776,
	1777, 7, 296, 2, 2, 1777, 1778, 5, 224, 113, 2, 1778, 1779, 7, 331, 2,
	2, 1779, 1780, 7, 43, 2, 2, 1780, 1781, 7, 297, 2, 2, 1781, 1801, 3, 2,
	2, 2, 1782, 1783, 7, 296, 2, 2, 1783, 1784, 5, 226, 114, 2, 1784, 1785,
	7, 331, 2, 2, 1785, 1786, 7, 42, 2, 2, 1786, 1787, 7, 297, 2, 2, 1787,
	1801, 3, 2, 2, 2, 1788, 1789, 7, 296, 2, 2, 1789, 1790, 7, 42, 2, 2, 1790,
	1791, 7, 331, 2, 2, 1791, 1792, 5, 226, 114, 2, 1792, 1793, 7, 297, 2,
	2, 1793, 1801, 3, 2, 2, 2, 1794, 1795, 7, 296, 2, 2, 1795, 1796, 7, 43,
	2, 2, 1796, 1797, 7, 331, 2, 2, 1797, 1798, 5, 224, 113, 2, 1798, 1799,
	7, 297, 2, 2, 1799, 1801, 3, 2, 2, 2, 1800, 1764, 3, 2, 2, 2, 1800, 1770,
	3, 2, 2, 2, 1800, 1776, 3, 2, 2, 2, 1800, 1782, 3, 2, 2, 2, 1800, 1788,
	3, 2, 2, 2, 1800, 1794, 3, 2, 2, 2, 1801, 223, 3, 2, 2, 2, 1802, 1803,
	9, 14, 2, 2, 1803, 225, 3, 2, 2, 2, 1804, 1805, 9, 15, 2, 2, 1805, 227,
	3, 2, 2, 2, 1806, 1807, 7, 296, 2, 2, 1807, 1808, 7, 95, 2, 2, 1808, 1816,
	7, 297, 2, 2, 1809, 1810, 7, 296, 2, 2, 1810, 1811, 7, 59, 2, 2, 1811,
	1816, 7, 297, 2, 2, 1812, 1813, 7, 296, 2, 2, 1813, 1814, 7, 54, 2, 2,
	1814, 1816, 7, 297, 2, 2, 1815, 1806, 3, 2, 2, 2, 1815, 1809, 3, 2, 2,
	2, 1815, 1812, 3, 2, 2, 2, 1816, 229, 3, 2, 2, 2, 1817, 1818, 7, 338, 2,
	2, 1818, 1833, 5, 234, 118, 2, 1819, 1820, 7, 338, 2, 2, 1820, 1821, 7,
	296, 2, 2, 1821, 1828, 5, 582, 292, 2, 1822, 1823, 7, 331, 2, 2, 1823,
	1826, 5, 582, 292, 2, 1824, 1825, 7, 331, 2, 2, 1825, 1827, 5, 582, 292,
	2, 1826, 1824, 3, 2, 2, 2, 1826, 1827, 3, 2, 2, 2, 1827, 1829, 3, 2, 2,
	2, 1828, 1822, 3, 2, 2, 2, 1828, 1829, 3, 2, 2, 2, 1829, 1830, 3, 2, 2,
	2, 1830, 1831, 7, 297, 2, 2, 1831, 1833, 3, 2, 2, 2, 1832, 1817, 3, 2,
	2, 2, 1832, 1819, 3, 2, 2, 2, 1833, 231, 3, 2, 2, 2, 1834, 1835, 7, 338,
	2, 2, 1835, 1846, 5, 234, 118, 2, 1836, 1837, 7, 338, 2, 2, 1837, 1838,
	7, 296, 2, 2, 1838, 1841, 5, 582, 292, 2, 1839, 1840, 7, 331, 2, 2, 1840,
	1842, 5, 582, 292, 2, 1841, 1839, 3, 2, 2, 2, 1841, 1842, 3, 2, 2, 2, 1842,
	1843, 3, 2, 2, 2, 1843, 1844, 7, 297, 2, 2, 1844, 1846, 3, 2, 2, 2, 1845,
	1834, 3, 2, 2, 2, 1845, 1836, 3, 2, 2, 2, 1846, 233, 3, 2, 2, 2, 1847,
	1851, 7, 285, 2, 2, 1848, 1851, 7, 284, 2, 2, 1849, 1851, 5, 652, 327,
	2, 1850, 1847, 3, 2, 2, 2, 1850, 1848, 3, 2, 2, 2, 1850, 1849, 3, 2, 2,
	2, 1851, 235, 3, 2, 2, 2, 1852, 1857, 5, 256, 129, 2, 1853, 1854, 7, 331,
	2, 2, 1854, 1856, 5, 256, 129, 2, 1855, 1853, 3, 2, 2, 2, 1856, 1859, 3,
	2, 2, 2, 1857, 1855, 3, 2, 2, 2, 1857, 1858, 3, 2, 2, 2, 1858, 237, 3,
	2, 2, 2, 1859, 1857, 3, 2, 2, 2, 1860, 1864, 5, 626, 314, 2, 1861, 1863,
	5, 272, 137, 2, 1862, 1861, 3, 2, 2, 2, 1863, 1866, 3, 2, 2, 2, 1864, 1865,
	3, 2, 2, 2, 1864, 1862, 3, 2, 2, 2, 1865, 1877, 3, 2, 2, 2, 1866, 1864,
	3, 2, 2, 2, 1867, 1868, 7, 331, 2, 2, 1868, 1872, 5, 626, 314, 2, 1869,
	1871, 5, 272, 137, 2, 1870, 1869, 3, 2, 2, 2, 1871, 1874, 3, 2, 2, 2, 1872,
	1873, 3, 2, 2, 2, 1872, 1870, 3, 2, 2, 2, 1873, 1876, 3, 2, 2, 2, 1874,
	1872, 3, 2, 2, 2, 1875, 1867, 3, 2, 2, 2, 1876, 1879, 3, 2, 2, 2, 1877,
	1875, 3, 2, 2, 2, 1877, 1878, 3, 2, 2, 2, 1878, 239, 3, 2, 2, 2, 1879,
	1877, 3, 2, 2, 2, 1880, 1885, 5, 258, 130, 2, 1881, 1882, 7, 331, 2, 2,
	1882, 1884, 5, 258, 130, 2, 1883, 1881, 3, 2, 2, 2, 1884, 1887, 3, 2, 2,
	2, 1885, 1883, 3, 2, 2, 2, 1885, 1886, 3, 2, 2, 2, 1886, 241, 3, 2, 2,
	2, 1887, 1885, 3, 2, 2, 2, 1888, 1892, 5, 666, 334, 2, 1889, 1891, 5, 272,
	137, 2, 1890, 1889, 3, 2, 2, 2, 1891, 1894, 3, 2, 2, 2, 1892, 1893, 3,
	2, 2, 2, 1892, 1890, 3, 2, 2, 2, 1893, 1905, 3, 2, 2, 2, 1894, 1892, 3,
	2, 2, 2, 1895, 1896, 7, 331, 2, 2, 1896, 1900, 5, 666, 334, 2, 1897, 1899,
	5, 272, 137, 2, 1898, 1897, 3, 2, 2, 2, 1899, 1902, 3, 2, 2, 2, 1900, 1901,
	3, 2, 2, 2, 1900, 1898, 3, 2, 2, 2, 1901, 1904, 3, 2, 2, 2, 1902, 1900,
	3, 2, 2, 2, 1903, 1895, 3, 2, 2, 2, 1904, 1907, 3, 2, 2, 2, 1905, 1903,
	3, 2, 2, 2, 1905, 1906, 3, 2, 2, 2, 1906, 243, 3, 2, 2, 2, 1907, 1905,
	3, 2, 2, 2, 1908, 1913, 5, 260, 131, 2, 1909, 1910, 7, 331, 2, 2, 1910,
	1912, 5, 260, 131, 2, 1911, 1909, 3, 2, 2, 2, 1912, 1915, 3, 2, 2, 2, 1913,
	1911, 3, 2, 2, 2, 1913, 1914, 3, 2, 2, 2, 1914, 245, 3, 2, 2, 2, 1915,
	1913, 3, 2, 2, 2, 1916, 1921, 5, 672, 337, 2, 1917, 1918, 7, 331, 2, 2,
	1918, 1920, 5, 672, 337, 2, 1919, 1917, 3, 2, 2, 2, 1920, 1923, 3, 2, 2,
	2, 1921, 1919, 3, 2, 2, 2, 1921, 1922, 3, 2, 2, 2, 1922, 247, 3, 2, 2,
	2, 1923, 1921, 3, 2, 2, 2, 1924, 1929, 5, 218, 110, 2, 1925, 1926, 7, 331,
	2, 2, 1926, 1928, 5, 218, 110, 2, 1927, 1925, 3, 2, 2, 2, 1928, 1931, 3,
	2, 2, 2, 1929, 1927, 3, 2, 2, 2, 1929, 1930, 3, 2, 2, 2, 1930, 249, 3,
	2, 2, 2, 1931, 1929, 3, 2, 2, 2, 1932, 1937, 5, 262, 132, 2, 1933, 1934,
	7, 331, 2, 2, 1934, 1936, 5, 262, 132, 2, 1935, 1933, 3, 2, 2, 2, 1936,
	1939, 3, 2, 2, 2, 1937, 1935, 3, 2, 2, 2, 1937, 1938, 3, 2, 2, 2, 1938,
	251, 3, 2, 2, 2, 1939, 1937, 3, 2, 2, 2, 1940, 1945, 5, 220, 111, 2, 1941,
	1942, 7, 331, 2, 2, 1942, 1944, 5, 220, 111, 2, 1943, 1941, 3, 2, 2, 2,
	1944, 1947, 3, 2, 2, 2, 1945, 1943, 3, 2, 2, 2, 1945, 1946, 3, 2, 2, 2,
	1946, 253, 3, 2, 2, 2, 1947, 1945, 3, 2, 2, 2, 1948, 1951, 5, 672, 337,
	2, 1949, 1950, 7, 335, 2, 2, 1950, 1952, 5, 570, 286, 2, 1951, 1949, 3,
	2, 2, 2, 1951, 1952, 3, 2, 2, 2, 1952, 1961, 3, 2, 2, 2, 1953, 1954, 7,
	331, 2, 2, 1954, 1957, 5, 672, 337, 2, 1955, 1956, 7, 335, 2, 2, 1956,
	1958, 5, 570, 286, 2, 1957, 1955, 3, 2, 2, 2, 1957, 1958, 3, 2, 2, 2, 1958,
	1960, 3, 2, 2, 2, 1959, 1953, 3, 2, 2, 2, 1960, 1963, 3, 2, 2, 2, 1961,
	1959, 3, 2, 2, 2, 1961, 1962, 3, 2, 2, 2, 1962, 255, 3, 2, 2, 2, 1963,
	1961, 3, 2, 2, 2, 1964, 1965, 5, 646, 324, 2, 1965, 1966, 7, 335, 2, 2,
	1966, 1967, 5, 572, 287, 2, 1967, 257, 3, 2, 2, 2, 1968, 1969, 5, 666,
	334, 2, 1969, 1970, 7, 335, 2, 2, 1970, 1971, 5, 578, 290, 2, 1971, 259,
	3, 2, 2, 2, 1972, 1973, 5, 670, 336, 2, 1973, 1974, 7, 335, 2, 2, 1974,
	1975, 5, 572, 287, 2, 1975, 261, 3, 2, 2, 2, 1976, 1977, 5, 676, 339, 2,
	1977, 1978, 7, 335, 2, 2, 1978, 1979, 5, 572, 287, 2, 1979, 1982, 3, 2,
	2, 2, 1980, 1982, 5, 264, 133, 2, 1981, 1976, 3, 2, 2, 2, 1981, 1980, 3,
	2, 2, 2, 1982, 263, 3, 2, 2, 2, 1983, 1984, 7, 346, 2, 2, 1984, 1985, 7,
	335, 2, 2, 1985, 1986, 7, 296, 2, 2, 1986, 1989, 5, 268, 135, 2, 1987,
	1988, 7, 331, 2, 2, 1988, 1990, 5, 266, 134, 2, 1989, 1987, 3, 2, 2, 2,
	1989, 1990, 3, 2, 2, 2, 1990, 1991, 3, 2, 2, 2, 1991, 1992, 7, 297, 2,
	2, 1992, 2007, 3, 2, 2, 2, 1993, 1994, 7, 346, 2, 2, 1994, 1995, 5, 486,
	244, 2, 1995, 1996, 7, 330, 2, 2, 1996, 1997, 5, 488, 245, 2, 1997, 1998,
	7, 335, 2, 2, 1998, 1999, 7, 296, 2, 2, 1999, 2002, 5, 268, 135, 2, 2000,
	2001, 7, 331, 2, 2, 2001, 2003, 5, 266, 134, 2, 2002, 2000, 3, 2, 2, 2,
	2002, 2003, 3, 2, 2, 2, 2003, 2004, 3, 2, 2, 2, 2004, 2005, 7, 297, 2,
	2, 2005, 2007, 3, 2, 2, 2, 2006, 1983, 3, 2, 2, 2, 2006, 1993, 3, 2, 2,
	2, 2007, 265, 3, 2, 2, 2, 2008, 2009, 5, 270, 136, 2, 2009, 267, 3, 2,
	2, 2, 2010, 2011, 5, 270, 136, 2, 2011, 269, 3, 2, 2, 2, 2012, 2013, 5,
	572, 287, 2, 2013, 271, 3, 2, 2, 2, 2014, 2015, 7, 298, 2, 2, 2015, 2016,
	5, 576, 289, 2, 2016, 2017, 7, 332, 2, 2, 2017, 2018, 5, 576, 289, 2, 2018,
	2019, 7, 299, 2, 2, 2019, 273, 3, 2, 2, 2, 2020, 2021, 7, 298, 2, 2, 2021,
	2022, 5, 588, 295, 2, 2022, 2023, 7, 332, 2, 2, 2023, 2024, 5, 580, 291,
	2, 2024, 2025, 7, 299, 2, 2, 2025, 275, 3, 2, 2, 2, 2026, 2028, 7, 39,
	2, 2, 2027, 2029, 7, 6, 2, 2, 2028, 2027, 3, 2, 2, 2, 2028, 2029, 3, 2,
	2, 2, 2029, 2031, 3, 2, 2, 2, 2030, 2032, 5, 282, 142, 2, 2031, 2030, 3,
	2, 2, 2, 2031, 2032, 3, 2, 2, 2, 2032, 2033, 3, 2, 2, 2, 2033, 2034, 5,
	628, 315, 2, 2034, 2035, 7, 333, 2, 2, 2035, 2039, 5, 278, 140, 2, 2036,
	2038, 5, 278, 140, 2, 2037, 2036, 3, 2, 2, 2, 2038, 2041, 3, 2, 2, 2, 2039,
	2037, 3, 2, 2, 2, 2039, 2040, 3, 2, 2, 2, 2040, 2042, 3, 2, 2, 2, 2041,
	2039, 3, 2, 2, 2, 2042, 2043, 5, 432, 217, 2, 2043, 2044, 7, 27, 2, 2,
	2044, 2067, 3, 2, 2, 2, 2045, 2047, 7, 39, 2, 2, 2046, 2048, 7, 6, 2, 2,
	2047, 2046, 3, 2, 2, 2, 2047, 2048, 3, 2, 2, 2, 2048, 2050, 3, 2, 2, 2,
	2049, 2051, 5, 282, 142, 2, 2050, 2049, 3, 2, 2, 2, 2050, 2051, 3, 2, 2,
	2, 2051, 2052, 3, 2, 2, 2, 2052, 2053, 5, 628, 315, 2, 2053, 2054, 7, 296,
	2, 2, 2054, 2055, 5, 280, 141, 2, 2055, 2056, 7, 297, 2, 2, 2056, 2060,
	7, 333, 2, 2, 2057, 2059, 5, 300, 151, 2, 2058, 2057, 3, 2, 2, 2, 2059,
	2062, 3, 2, 2, 2, 2060, 2058, 3, 2, 2, 2, 2060, 2061, 3, 2, 2, 2, 2061,
	2063, 3, 2, 2, 2, 2062, 2060, 3, 2, 2, 2, 2063, 2064, 5, 432, 217, 2, 2064,
	2065, 7, 27, 2, 2, 2065, 2067, 3, 2, 2, 2, 2066, 2026, 3, 2, 2, 2, 2066,
	2045, 3, 2, 2, 2, 2067, 277, 3, 2, 2, 2, 2068, 2079, 5, 300, 151, 2, 2069,
	2071, 5, 614, 308, 2, 2070, 2069, 3, 2, 2, 2, 2071, 2074, 3, 2, 2, 2, 2072,
	2070, 3, 2, 2, 2, 2072, 2073, 3, 2, 2, 2, 2073, 2075, 3, 2, 2, 2, 2074,
	2072, 3, 2, 2, 2, 2075, 2076, 5, 292, 147, 2, 2076, 2077, 7, 333, 2, 2,
	2077, 2079, 3, 2, 2, 2, 2078, 2068, 3, 2, 2, 2, 2078, 2072, 3, 2, 2, 2,
	2079, 279, 3, 2, 2, 2, 2080, 2082, 5, 614, 308, 2, 2081, 2080, 3, 2, 2,
	2, 2082, 2085, 3, 2, 2, 2, 2083, 2081, 3, 2, 2, 2, 2083, 2084, 3, 2, 2,
	2, 2084, 2086, 3, 2, 2, 2, 2085, 2083, 3, 2, 2, 2, 2086, 2097, 5, 292,
	147, 2, 2087, 2091, 7, 331, 2, 2, 2088, 2090, 5, 614, 308, 2, 2089, 2088,
	3, 2, 2, 2, 2090, 2093, 3, 2, 2, 2, 2091, 2089, 3, 2, 2, 2, 2091, 2092,
	3, 2, 2, 2, 2092, 2094, 3, 2, 2, 2, 2093, 2091, 3, 2, 2, 2, 2094, 2096,
	5, 292, 147, 2, 2095, 2087, 3, 2, 2, 2, 2096, 2099, 3, 2, 2, 2, 2097, 2095,
	3, 2, 2, 2, 2097, 2098, 3, 2, 2, 2, 2098, 281, 3, 2, 2, 2, 2099, 2097,
	3, 2, 2, 2, 2100, 2102, 7, 94, 2, 2, 2101, 2100, 3, 2, 2, 2, 2101, 2102,
	3, 2, 2, 2, 2102, 2103, 3, 2, 2, 2, 2103, 2109, 5, 274, 138, 2, 2104, 2109,
	7, 52, 2, 2, 2105, 2109, 7, 82, 2, 2, 2106, 2109, 7, 83, 2, 2, 2107, 2109,
	7, 104, 2, 2, 2108, 2101, 3, 2, 2, 2, 2108, 2104, 3, 2, 2, 2, 2108, 2105,
	3, 2, 2, 2, 2108, 2106, 3, 2, 2, 2, 2108, 2107, 3, 2, 2, 2, 2109, 283,
	3, 2, 2, 2, 2110, 2112, 7, 103, 2, 2, 2111, 2113, 7, 6, 2, 2, 2112, 2111,
	3, 2, 2, 2, 2112, 2113, 3, 2, 2, 2, 2113, 2114, 3, 2, 2, 2, 2114, 2115,
	5, 682, 342, 2, 2115, 2119, 7, 333, 2, 2, 2116, 2118, 5, 286, 144, 2, 2117,
	2116, 3, 2, 2, 2, 2118, 2121, 3, 2, 2, 2, 2119, 2117, 3, 2, 2, 2, 2119,
	2120, 3, 2, 2, 2, 2120, 2122, 3, 2, 2, 2, 2121, 2119, 3, 2, 2, 2, 2122,
	2123, 5, 430, 216, 2, 2123, 2124, 7, 33, 2, 2, 2124, 2146, 3, 2, 2, 2,
	2125, 2127, 7, 103, 2, 2, 2126, 2128, 7, 6, 2, 2, 2127, 2126, 3, 2, 2,
	2, 2127, 2128, 3, 2, 2, 2, 2128, 2129, 3, 2, 2, 2, 2129, 2130, 5, 682,
	342, 2, 2130, 2132, 7, 296, 2, 2, 2131, 2133, 5, 288, 145, 2, 2132, 2131,
	3, 2, 2, 2, 2132, 2133, 3, 2, 2, 2, 2133, 2134, 3, 2, 2, 2, 2134, 2135,
	7, 297, 2, 2, 2135, 2139, 7, 333, 2, 2, 2136, 2138, 5, 300, 151, 2, 2137,
	2136, 3, 2, 2, 2, 2138, 2141, 3, 2, 2, 2, 2139, 2137, 3, 2, 2, 2, 2139,
	2140, 3, 2, 2, 2, 2140, 2142, 3, 2, 2, 2, 2141, 2139, 3, 2, 2, 2, 2142,
	2143, 5, 430, 216, 2, 2143, 2144, 7, 33, 2, 2, 2144, 2146, 3, 2, 2, 2,
	2145, 2110, 3, 2, 2, 2, 2145, 2125, 3, 2, 2, 2, 2146, 285, 3, 2, 2, 2,
	2147, 2176, 5, 300, 151, 2, 2148, 2150, 5, 614, 308, 2, 2149, 2148, 3,
	2, 2, 2, 2150, 2153, 3, 2, 2, 2, 2151, 2149, 3, 2, 2, 2, 2151, 2152, 3,
	2, 2, 2, 2152, 2154, 3, 2, 2, 2, 2153, 2151, 3, 2, 2, 2, 2154, 2155, 5,
	292, 147, 2, 2155, 2156, 7, 333, 2, 2, 2156, 2176, 3, 2, 2, 2, 2157, 2159,
	5, 614, 308, 2, 2158, 2157, 3, 2, 2, 2, 2159, 2162, 3, 2, 2, 2, 2160, 2158,
	3, 2, 2, 2, 2160, 2161, 3, 2, 2, 2, 2161, 2163, 3, 2, 2, 2, 2162, 2160,
	3, 2, 2, 2, 2163, 2164, 5, 294, 148, 2, 2164, 2165, 7, 333, 2, 2, 2165,
	2176, 3, 2, 2, 2, 2166, 2168, 5, 614, 308, 2, 2167, 2166, 3, 2, 2, 2, 2168,
	2171, 3, 2, 2, 2, 2169, 2167, 3, 2, 2, 2, 2169, 2170, 3, 2, 2, 2, 2170,
	2172, 3, 2, 2, 2, 2171, 2169, 3, 2, 2, 2, 2172, 2173, 5, 296, 149, 2, 2173,
	2174, 7, 333, 2, 2, 2174, 2176, 3, 2, 2, 2, 2175, 2147, 3, 2, 2, 2, 2175,
	2151, 3, 2, 2, 2, 2175, 2160, 3, 2, 2, 2, 2175, 2169, 3, 2, 2, 2, 2176,
	287, 3, 2, 2, 2, 2177, 2182, 5, 290, 146, 2, 2178, 2179, 7, 331, 2, 2,
	2179, 2181, 5, 290, 146, 2, 2180, 2178, 3, 2, 2, 2, 2181, 2184, 3, 2, 2,
	2, 2182, 2180, 3, 2, 2, 2, 2182, 2183, 3, 2, 2, 2, 2183, 289, 3, 2, 2,
	2, 2184, 2182, 3, 2, 2, 2, 2185, 2187, 5, 614, 308, 2, 2186, 2185, 3, 2,
	2, 2, 2187, 2190, 3, 2, 2, 2, 2188, 2186, 3, 2, 2, 2, 2188, 2189, 3, 2,
	2, 2, 2189, 2191, 3, 2, 2, 2, 2190, 2188, 3, 2, 2, 2, 2191, 2207, 5, 292,
	147, 2, 2192, 2194, 5, 614, 308, 2, 2193, 2192, 3, 2, 2, 2, 2194, 2197,
	3, 2, 2, 2, 2195, 2193, 3, 2, 2, 2, 2195, 2196, 3, 2, 2, 2, 2196, 2198,
	3, 2, 2, 2, 2197, 2195, 3, 2, 2, 2, 2198, 2207, 5, 294, 148, 2, 2199, 2201,
	5, 614, 308, 2, 2200, 2199, 3, 2, 2, 2, 2201, 2204, 3, 2, 2, 2, 2202, 2200,
	3, 2, 2, 2, 2202, 2203, 3, 2, 2, 2, 2203, 2205, 3, 2, 2, 2, 2204, 2202,
	3, 2, 2, 2, 2205, 2207, 5, 296, 149, 2, 2206, 2188, 3, 2, 2, 2, 2206, 2195,
	3, 2, 2, 2, 2206, 2202, 3, 2, 2, 2, 2207, 291, 3, 2, 2, 2, 2208, 2210,
	7, 50, 2, 2, 2209, 2211, 7, 84, 2, 2, 2210, 2209, 3, 2, 2, 2, 2210, 2211,
	3, 2, 2, 2, 2211, 2213, 3, 2, 2, 2, 2212, 2214, 7, 94, 2, 2, 2213, 2212,
	3, 2, 2, 2, 2213, 2214, 3, 2, 2, 2, 2214, 2216, 3, 2, 2, 2, 2215, 2217,
	5, 274, 138, 2, 2216, 2215, 3, 2, 2, 2, 2216, 2217, 3, 2, 2, 2, 2217, 2218,
	3, 2, 2, 2, 2218, 2224, 5, 246, 124, 2, 2219, 2220, 7, 50, 2, 2, 2220,
	2221, 5, 298, 150, 2, 2221, 2222, 5, 246, 124, 2, 2222, 2224, 3, 2, 2,
	2, 2223, 2208, 3, 2, 2, 2, 2223, 2219, 3, 2, 2, 2, 2224, 293, 3, 2, 2,
	2, 2225, 2227, 7, 70, 2, 2, 2226, 2228, 7, 84, 2, 2, 2227, 2226, 3, 2,
	2, 2, 2227, 2228, 3, 2, 2, 2, 2228, 2230, 3, 2, 2, 2, 2229, 2231, 7, 94,
	2, 2, 2230, 2229, 3, 2, 2, 2, 2230, 2231, 3, 2, 2, 2, 2231, 2233, 3, 2,
	2, 2, 2232, 2234, 5, 274, 138, 2, 2233, 2232, 3, 2, 2, 2, 2233, 2234, 3,
	2, 2, 2, 2234, 2235, 3, 2, 2, 2, 2235, 2241, 5, 246, 124, 2, 2236, 2237,
	7, 70, 2, 2, 2237, 2238, 5, 298, 150, 2, 2238, 2239, 5, 246, 124, 2, 2239,
	2241, 3, 2, 2, 2, 2240, 2225, 3, 2, 2, 2, 2240, 2236, 3, 2, 2, 2, 2241,
	295, 3, 2, 2, 2, 2242, 2244, 7, 49, 2, 2, 2243, 2245, 7, 84, 2, 2, 2244,
	2243, 3, 2, 2, 2, 2244, 2245, 3, 2, 2, 2, 2245, 2247, 3, 2, 2, 2, 2246,
	2248, 7, 94, 2, 2, 2247, 2246, 3, 2, 2, 2, 2247, 2248, 3, 2, 2, 2, 2248,
	2250, 3, 2, 2, 2, 2249, 2251, 5, 274, 138, 2, 2250, 2249, 3, 2, 2, 2, 2250,
	2251, 3, 2, 2, 2, 2251, 2252, 3, 2, 2, 2, 2252, 2258, 5, 246, 124, 2, 2253,
	2254, 7, 49, 2, 2, 2254, 2255, 5, 298, 150, 2, 2255, 2256, 5, 246, 124,
	2, 2256, 2258, 3, 2, 2, 2, 2257, 2242, 3, 2, 2, 2, 2257, 2253, 3, 2, 2,
	2, 2258, 297, 3, 2, 2, 2, 2259, 2260, 9, 10, 2, 2, 2260, 299, 3, 2, 2,
	2, 2261, 2263, 5, 614, 308, 2, 2262, 2261, 3, 2, 2, 2, 2263, 2266, 3, 2,
	2, 2, 2264, 2262, 3, 2, 2, 2, 2264, 2265, 3, 2, 2, 2, 2265, 2267, 3, 2,
	2, 2, 2266, 2264, 3, 2, 2, 2, 2267, 2269, 7, 84, 2, 2, 2268, 2270, 7, 94,
	2, 2, 2269, 2268, 3, 2, 2, 2, 2269, 2270, 3, 2, 2, 2, 2270, 2272, 3, 2,
	2, 2, 2271, 2273, 5, 274, 138, 2, 2272, 2271, 3, 2, 2, 2, 2272, 2273, 3,
	2, 2, 2, 2273, 2274, 3, 2, 2, 2, 2274, 2275, 5, 302, 152, 2, 2275, 2276,
	7, 333, 2, 2, 2276, 2343, 3, 2, 2, 2, 2277, 2279, 5, 614, 308, 2, 2278,
	2277, 3, 2, 2, 2, 2279, 2282, 3, 2, 2, 2, 2280, 2278, 3, 2, 2, 2, 2280,
	2281, 3, 2, 2, 2, 2281, 2283, 3, 2, 2, 2, 2282, 2280, 3, 2, 2, 2, 2283,
	2284, 7, 52, 2, 2, 2284, 2285, 5, 302, 152, 2, 2285, 2286, 7, 333, 2, 2,
	2286, 2343, 3, 2, 2, 2, 2287, 2289, 5, 614, 308, 2, 2288, 2287, 3, 2, 2,
	2, 2289, 2292, 3, 2, 2, 2, 2290, 2288, 3, 2, 2, 2, 2290, 2291, 3, 2, 2,
	2, 2291, 2293, 3, 2, 2, 2, 2292, 2290, 3, 2, 2, 2, 2293, 2294, 7, 104,
	2, 2, 2294, 2295, 5, 302, 152, 2, 2295, 2296, 7, 333, 2, 2, 2296, 2343,
	3, 2, 2, 2, 2297, 2299, 5, 614, 308, 2, 2298, 2297, 3, 2, 2, 2, 2299, 2302,
	3, 2, 2, 2, 2300, 2298, 3, 2, 2, 2, 2300, 2301, 3, 2, 2, 2, 2301, 2303,
	3, 2, 2, 2, 2302, 2300, 3, 2, 2, 2, 2303, 2304, 7, 82, 2, 2, 2304, 2305,
	5, 304, 153, 2, 2305, 2306, 7, 333, 2, 2, 2306, 2343, 3, 2, 2, 2, 2307,
	2309, 5, 614, 308, 2, 2308, 2307, 3, 2, 2, 2, 2309, 2312, 3, 2, 2, 2, 2310,
	2308, 3, 2, 2, 2, 2310, 2311, 3, 2, 2, 2, 2311, 2313, 3, 2, 2, 2, 2312,
	2310, 3, 2, 2, 2, 2313, 2314, 7, 83, 2, 2, 2314, 2315, 5, 304, 153, 2,
	2315, 2316, 7, 333, 2, 2, 2316, 2343, 3, 2, 2, 2, 2317, 2319, 5, 614, 308,
	2, 2318, 2317, 3, 2, 2, 2, 2319, 2322, 3, 2, 2, 2, 2320, 2318, 3, 2, 2,
	2, 2320, 2321, 3, 2, 2, 2, 2321, 2323, 3, 2, 2, 2, 2322, 2320, 3, 2, 2,
	2, 2323, 2343, 5, 200, 101, 2, 2324, 2326, 5, 614, 308, 2, 2325, 2324,
	3, 2, 2, 2, 2326, 2329, 3, 2, 2, 2, 2327, 2325, 3, 2, 2, 2, 2327, 2328,
	3, 2, 2, 2, 2328, 2330, 3, 2, 2, 2, 2329, 2327, 3, 2, 2, 2, 2330, 2331,
	5, 186, 94, 2, 2331, 2332, 7, 333, 2, 2, 2332, 2343, 3, 2, 2, 2, 2333,
	2335, 5, 614, 308, 2, 2334, 2333, 3, 2, 2, 2, 2335, 2338, 3, 2, 2, 2, 2336,
	2334, 3, 2, 2, 2, 2336, 2337, 3, 2, 2, 2, 2337, 2339, 3, 2, 2, 2, 2338,
	2336, 3, 2, 2, 2, 2339, 2340, 5, 188, 95, 2, 2340, 2341, 7, 333, 2, 2,
	2341, 2343, 3, 2, 2, 2, 2342, 2264, 3, 2, 2, 2, 2342, 2280, 3, 2, 2, 2,
	2342, 2290, 3, 2, 2, 2, 2342, 2300, 3, 2, 2, 2, 2342, 2310, 3, 2, 2, 2,
	2342, 2320, 3, 2, 2, 2, 2342, 2327, 3, 2, 2, 2, 2342, 2336, 3, 2, 2, 2,
	2343, 301, 3, 2, 2, 2, 2344, 2349, 5, 306, 154, 2, 2345, 2346, 7, 331,
	2, 2, 2346, 2348, 5, 306, 154, 2, 2347, 2345, 3, 2, 2, 2, 2348, 2351, 3,
	2, 2, 2, 2349, 2347, 3, 2, 2, 2, 2349, 2350, 3, 2, 2, 2, 2350, 303, 3,
	2, 2, 2, 2351, 2349, 3, 2, 2, 2, 2352, 2357, 5, 308, 155, 2, 2353, 2354,
	7, 331, 2, 2, 2354, 2356, 5, 308, 155, 2, 2355, 2353, 3, 2, 2, 2, 2356,
	2359, 3, 2, 2, 2, 2357, 2355, 3, 2, 2, 2, 2357, 2358, 3, 2, 2, 2, 2358,
	305, 3, 2, 2, 2, 2359, 2357, 3, 2, 2, 2, 2360, 2364, 5, 692, 347, 2, 2361,
	2363, 5, 272, 137, 2, 2362, 2361, 3, 2, 2, 2, 2363, 2366, 3, 2, 2, 2, 2364,
	2362, 3, 2, 2, 2, 2364, 2365, 3, 2, 2, 2, 2365, 307, 3, 2, 2, 2, 2366,
	2364, 3, 2, 2, 2, 2367, 2371, 5, 674, 338, 2, 2368, 2370, 5, 272, 137,
	2, 2369, 2368, 3, 2, 2, 2, 2370, 2373, 3, 2, 2, 2, 2371, 2369, 3, 2, 2,
	2, 2371, 2372, 3, 2, 2, 2, 2372, 309, 3, 2, 2, 2, 2373, 2371, 3, 2, 2,
	2, 2374, 2376, 5, 346, 174, 2, 2375, 2377, 5, 230, 116, 2, 2376, 2375,
	3, 2, 2, 2, 2376, 2377, 3, 2, 2, 2, 2377, 2378, 3, 2, 2, 2, 2378, 2383,
	5, 312, 157, 2, 2379, 2380, 7, 331, 2, 2, 2380, 2382, 5, 312, 157, 2, 2381,
	2379, 3, 2, 2, 2, 2382, 2385, 3, 2, 2, 2, 2383, 2381, 3, 2, 2, 2, 2383,
	2384, 3, 2, 2, 2, 2384, 2386, 3, 2, 2, 2, 2385, 2383, 3, 2, 2, 2, 2386,
	2387, 7, 333, 2, 2, 2387, 2507, 3, 2, 2, 2, 2388, 2390, 5, 348, 175, 2,
	2389, 2391, 5, 222, 112, 2, 2390, 2389, 3, 2, 2, 2, 2390, 2391, 3, 2, 2,
	2, 2391, 2393, 3, 2, 2, 2, 2392, 2394, 5, 230, 116, 2, 2393, 2392, 3, 2,
	2, 2, 2393, 2394, 3, 2, 2, 2, 2394, 2395, 3, 2, 2, 2, 2395, 2400, 5, 314,
	158, 2, 2396, 2397, 7, 331, 2, 2, 2397, 2399, 5, 314, 158, 2, 2398, 2396,
	3, 2, 2, 2, 2399, 2402, 3, 2, 2, 2, 2400, 2398, 3, 2, 2, 2, 2400, 2401,
	3, 2, 2, 2, 2401, 2403, 3, 2, 2, 2, 2402, 2400, 3, 2, 2, 2, 2403, 2404,
	7, 333, 2, 2, 2404, 2507, 3, 2, 2, 2, 2405, 2407, 5, 350, 176, 2, 2406,
	2408, 5, 230, 116, 2, 2407, 2406, 3, 2, 2, 2, 2407, 2408, 3, 2, 2, 2, 2408,
	2409, 3, 2, 2, 2, 2409, 2414, 5, 316, 159, 2, 2410, 2411, 7, 331, 2, 2,
	2411, 2413, 5, 316, 159, 2, 2412, 2410, 3, 2, 2, 2, 2413, 2416, 3, 2, 2,
	2, 2414, 2412, 3, 2, 2, 2, 2414, 2415, 3, 2, 2, 2, 2415, 2417, 3, 2, 2,
	2, 2416, 2414, 3, 2, 2, 2, 2417, 2418, 7, 333, 2, 2, 2418, 2507, 3, 2,
	2, 2, 2419, 2421, 5, 352, 177, 2, 2420, 2422, 5, 222, 112, 2, 2421, 2420,
	3, 2, 2, 2, 2421, 2422, 3, 2, 2, 2, 2422, 2424, 3, 2, 2, 2, 2423, 2425,
	5, 232, 117, 2, 2424, 2423, 3, 2, 2, 2, 2424, 2425, 3, 2, 2, 2, 2425, 2426,
	3, 2, 2, 2, 2426, 2431, 5, 318, 160, 2, 2427, 2428, 7, 331, 2, 2, 2428,
	2430, 5, 318, 160, 2, 2429, 2427, 3, 2, 2, 2, 2430, 2433, 3, 2, 2, 2, 2431,
	2429, 3, 2, 2, 2, 2431, 2432, 3, 2, 2, 2, 2432, 2434, 3, 2, 2, 2, 2433,
	2431, 3, 2, 2, 2, 2434, 2435, 7, 333, 2, 2, 2435, 2507, 3, 2, 2, 2, 2436,
	2438, 5, 354, 178, 2, 2437, 2439, 5, 222, 112, 2, 2438, 2437, 3, 2, 2,
	2, 2438, 2439, 3, 2, 2, 2, 2439, 2441, 3, 2, 2, 2, 2440, 2442, 5, 232,
	117, 2, 2441, 2440, 3, 2, 2, 2, 2441, 2442, 3, 2, 2, 2, 2442, 2443, 3,
	2, 2, 2, 2443, 2448, 5, 320, 161, 2, 2444, 2445, 7, 331, 2, 2, 2445, 2447,
	5, 320, 161, 2, 2446, 2444, 3, 2, 2, 2, 2447, 2450, 3, 2, 2, 2, 2448, 2446,
	3, 2, 2, 2, 2448, 2449, 3, 2, 2, 2, 2449, 2451, 3, 2, 2, 2, 2450, 2448,
	3, 2, 2, 2, 2451, 2452, 7, 333, 2, 2, 2452, 2507, 3, 2, 2, 2, 2453, 2455,
	5, 356, 179, 2, 2454, 2456, 5, 232, 117, 2, 2455, 2454, 3, 2, 2, 2, 2455,
	2456, 3, 2, 2, 2, 2456, 2457, 3, 2, 2, 2, 2457, 2462, 5, 324, 163, 2, 2458,
	2459, 7, 331, 2, 2, 2459, 2461, 5, 324, 163, 2, 2460, 2458, 3, 2, 2, 2,
	2461, 2464, 3, 2, 2, 2, 2462, 2460, 3, 2, 2, 2, 2462, 2463, 3, 2, 2, 2,
	2463, 2465, 3, 2, 2, 2, 2464, 2462, 3, 2, 2, 2, 2465, 2466, 7, 333, 2,
	2, 2466, 2507, 3, 2, 2, 2, 2467, 2468, 5, 358, 180, 2, 2468, 2473, 5, 322,
	162, 2, 2469, 2470, 7, 331, 2, 2, 2470, 2472, 5, 322, 162, 2, 2471, 2469,
	3, 2, 2, 2, 2472, 2475, 3, 2, 2, 2, 2473, 2471, 3, 2, 2, 2, 2473, 2474,
	3, 2, 2, 2, 2474, 2476, 3, 2, 2, 2, 2475, 2473, 3, 2, 2, 2, 2476, 2477,
	7, 333, 2, 2, 2477, 2507, 3, 2, 2, 2, 2478, 2480, 7, 77, 2, 2, 2479, 2481,
	5, 330, 166, 2, 2480, 2479, 3, 2, 2, 2, 2480, 2481, 3, 2, 2, 2, 2481, 2482,
	3, 2, 2, 2, 2482, 2487, 5, 326, 164, 2, 2483, 2484, 7, 331, 2, 2, 2484,
	2486, 5, 326, 164, 2, 2485, 2483, 3, 2, 2, 2, 2486, 2489, 3, 2, 2, 2, 2487,
	2485, 3, 2, 2, 2, 2487, 2488, 3, 2, 2, 2, 2488, 2490, 3, 2, 2, 2, 2489,
	2487, 3, 2, 2, 2, 2490, 2491, 7, 333, 2, 2, 2491, 2507, 3, 2, 2, 2, 2492,
	2494, 7, 78, 2, 2, 2493, 2495, 5, 332, 167, 2, 2494, 2493, 3, 2, 2, 2,
	2494, 2495, 3, 2, 2, 2, 2495, 2496, 3, 2, 2, 2, 2496, 2501, 5, 326, 164,
	2, 2497, 2498, 7, 331, 2, 2, 2498, 2500, 5, 326, 164, 2, 2499, 2497, 3,
	2, 2, 2, 2500, 2503, 3, 2, 2, 2, 2501, 2499, 3, 2, 2, 2, 2501, 2502, 3,
	2, 2, 2, 2502, 2504, 3, 2, 2, 2, 2503, 2501, 3, 2, 2, 2, 2504, 2505, 7,
	333, 2, 2, 2505, 2507, 3, 2, 2, 2, 2506, 2374, 3, 2, 2, 2, 2506, 2388,
	3, 2, 2, 2, 2506, 2405, 3, 2, 2, 2, 2506, 2419, 3, 2, 2, 2, 2506, 2436,
	3, 2, 2, 2, 2506, 2453, 3, 2, 2, 2, 2506, 2467, 3, 2, 2, 2, 2506, 2478,
	3, 2, 2, 2, 2506, 2492, 3, 2, 2, 2, 2507, 311, 3, 2, 2, 2, 2508, 2510,
	5, 328, 165, 2, 2509, 2508, 3, 2, 2, 2, 2509, 2510, 3, 2, 2, 2, 2510, 2511,
	3, 2, 2, 2, 2511, 2512, 7, 296, 2, 2, 2512, 2513, 5, 342, 172, 2, 2513,
	2514, 7, 331, 2, 2, 2514, 2515, 5, 338, 170, 2, 2515, 2516, 7, 331, 2,
	2, 2516, 2517, 5, 340, 171, 2, 2517, 2518, 7, 331, 2, 2, 2518, 2519, 5,
	344, 173, 2, 2519, 2520, 7, 297, 2, 2, 2520, 313, 3, 2, 2, 2, 2521, 2523,
	5, 328, 165, 2, 2522, 2521, 3, 2, 2, 2, 2522, 2523, 3, 2, 2, 2, 2523, 2524,
	3, 2, 2, 2, 2524, 2525, 7, 296, 2, 2, 2525, 2526, 5, 342, 172, 2, 2526,
	2527, 7, 331, 2, 2, 2527, 2528, 5, 338, 170, 2, 2528, 2529, 7, 331, 2,
	2, 2529, 2530, 5, 334, 168, 2, 2530, 2531, 7, 297, 2, 2, 2531, 315, 3,
	2, 2, 2, 2532, 2534, 5, 328, 165, 2, 2533, 2532, 3, 2, 2, 2, 2533, 2534,
	3, 2, 2, 2, 2534, 2535, 3, 2, 2, 2, 2535, 2536, 7, 296, 2, 2, 2536, 2537,
	5, 342, 172, 2, 2537, 2538, 7, 331, 2, 2, 2538, 2539, 5, 338, 170, 2, 2539,
	2540, 7, 331, 2, 2, 2540, 2541, 5, 334, 168, 2, 2541, 2542, 7, 297, 2,
	2, 2542, 317, 3, 2, 2, 2, 2543, 2545, 5, 328, 165, 2, 2544, 2543, 3, 2,
	2, 2, 2544, 2545, 3, 2, 2, 2, 2545, 2546, 3, 2, 2, 2, 2546, 2547, 7, 296,
	2, 2, 2547, 2548, 5, 342, 172, 2, 2548, 2549, 7, 331, 2, 2, 2549, 2554,
	5, 338, 170, 2, 2550, 2551, 7, 331, 2, 2, 2551, 2553, 5, 338, 170, 2, 2552,
	2550, 3, 2, 2, 2, 2553, 2556, 3, 2, 2, 2, 2554, 2552, 3, 2, 2, 2, 2554,
	2555, 3, 2, 2, 2, 2555, 2557, 3, 2, 2, 2, 2556, 2554, 3, 2, 2, 2, 2557,
	2558, 7, 297, 2, 2, 2558, 319, 3, 2, 2, 2, 2559, 2561, 5, 328, 165, 2,
	2560, 2559, 3, 2, 2, 2, 2560, 2561, 3, 2, 2, 2, 2561, 2562, 3, 2, 2, 2,
	2562, 2563, 7, 296, 2, 2, 2563, 2568, 5, 342, 172, 2, 2564, 2565, 7, 331,
	2, 2, 2565, 2567, 5, 342, 172, 2, 2566, 2564, 3, 2, 2, 2, 2567, 2570, 3,
	2, 2, 2, 2568, 2566, 3, 2, 2, 2, 2568, 2569, 3, 2, 2, 2, 2569, 2571, 3,
	2, 2, 2, 2570, 2568, 3, 2, 2, 2, 2571, 2572, 7, 331, 2, 2, 2572, 2573,
	5, 338, 170, 2, 2573, 2574, 7, 297, 2, 2, 2574, 321, 3, 2, 2, 2, 2575,
	2577, 5, 328, 165, 2, 2576, 2575, 3, 2, 2, 2, 2576, 2577, 3, 2, 2, 2, 2577,
	2578, 3, 2, 2, 2, 2578, 2579, 7, 296, 2, 2, 2579, 2580, 5, 336, 169, 2,
	2580, 2581, 7, 331, 2, 2, 2581, 2582, 5, 336, 169, 2, 2582, 2583, 7, 297,
	2, 2, 2583, 323, 3, 2, 2, 2, 2584, 2586, 5, 328, 165, 2, 2585, 2584, 3,
	2, 2, 2, 2585, 2586, 3, 2, 2, 2, 2586, 2587, 3, 2, 2, 2, 2587, 2588, 7,
	296, 2, 2, 2588, 2589, 5, 336, 169, 2, 2589, 2590, 7, 331, 2, 2, 2590,
	2591, 5, 336, 169, 2, 2591, 2592, 7, 331, 2, 2, 2592, 2593, 5, 334, 168,
	2, 2593, 2594, 7, 297, 2, 2, 2594, 325, 3, 2, 2, 2, 2595, 2597, 5, 328,
	165, 2, 2596, 2595, 3, 2, 2, 2, 2596, 2597, 3, 2, 2, 2, 2597, 2598, 3,
	2, 2, 2, 2598, 2599, 7, 296, 2, 2, 2599, 2600, 5, 342, 172, 2, 2600, 2601,
	7, 297, 2, 2, 2601, 327, 3, 2, 2, 2, 2602, 2604, 5, 630, 316, 2, 2603,
	2605, 5, 274, 138, 2, 2604, 2603, 3, 2, 2, 2, 2604, 2605, 3, 2, 2, 2, 2605,
	329, 3, 2, 2, 2, 2606, 2607, 7, 296, 2, 2, 2607, 2608, 5, 224, 113, 2,
	2608, 2609, 7, 331, 2, 2, 2609, 2610, 5, 226, 114, 2, 2610, 2611, 7, 297,
	2, 2, 2611, 2623, 3, 2, 2, 2, 2612, 2613, 7, 296, 2, 2, 2613, 2614, 5,
	226, 114, 2, 2614, 2615, 7, 331, 2, 2, 2615, 2616, 5, 224, 113, 2, 2616,
	2617, 7, 297, 2, 2, 2617, 2623, 3, 2, 2, 2, 2618, 2619, 7, 296, 2, 2, 2619,
	2620, 5, 224, 113, 2, 2620, 2621, 7, 297, 2, 2, 2621, 2623, 3, 2, 2, 2,
	2622, 2606, 3, 2, 2, 2, 2622, 2612, 3, 2, 2, 2, 2622, 2618, 3, 2, 2, 2,
	2623, 331, 3, 2, 2, 2, 2624, 2625, 7, 296, 2, 2, 2625, 2626, 5, 224, 113,
	2, 2626, 2627, 7, 331, 2, 2, 2627, 2628, 5, 226, 114, 2, 2628, 2629, 7,
	297, 2, 2, 2629, 2641, 3, 2, 2, 2, 2630, 2631, 7, 296, 2, 2, 2631, 2632,
	5, 226, 114, 2, 2632, 2633, 7, 331, 2, 2, 2633, 2634, 5, 224, 113, 2, 2634,
	2635, 7, 297, 2, 2, 2635, 2641, 3, 2, 2, 2, 2636, 2637, 7, 296, 2, 2, 2637,
	2638, 5, 226, 114, 2, 2638, 2639, 7, 297, 2, 2, 2639, 2641, 3, 2, 2, 2,
	2640, 2624, 3, 2, 2, 2, 2640, 2630, 3, 2, 2, 2, 2640, 2636, 3, 2, 2, 2,
	2641, 333, 3, 2, 2, 2, 2642, 2643, 5, 578, 290, 2, 2643, 335, 3, 2, 2,
	2, 2644, 2645, 5, 600, 301, 2, 2645, 337, 3, 2, 2, 2, 2646, 2647, 5, 578,
	290, 2, 2647, 339, 3, 2, 2, 2, 2648, 2649, 5, 578, 290, 2, 2649, 341, 3,
	2, 2, 2, 2650, 2651, 5, 600, 301, 2, 2651, 343, 3, 2, 2, 2, 2652, 2653,
	5, 578, 290, 2, 2653, 345, 3, 2, 2, 2, 2654, 2655, 9, 16, 2, 2, 2655, 347,
	3, 2, 2, 2, 2656, 2657, 9, 17, 2, 2, 2657, 349, 3, 2, 2, 2, 2658, 2659,
	9, 18, 2, 2, 2659, 351, 3, 2, 2, 2, 2660, 2661, 9, 19, 2, 2, 2661, 353,
	3, 2, 2, 2, 2662, 2663, 9, 20, 2, 2, 2663, 355, 3, 2, 2, 2, 2664, 2665,
	9, 21, 2, 2, 2665, 357, 3, 2, 2, 2, 2666, 2667, 9, 22, 2, 2, 2667, 359,
	3, 2, 2, 2, 2668, 2670, 5, 662, 332, 2, 2669, 2671, 5, 362, 182, 2, 2670,
	2669, 3, 2, 2, 2, 2670, 2671, 3, 2, 2, 2, 2671, 2672, 3, 2, 2, 2, 2672,
	2677, 5, 370, 186, 2, 2673, 2674, 7, 331, 2, 2, 2674, 2676, 5, 370, 186,
	2, 2675, 2673, 3, 2, 2, 2, 2676, 2679, 3, 2, 2, 2, 2677, 2675, 3, 2, 2,
	2, 2677, 2678, 3, 2, 2, 2, 2678, 2680, 3, 2, 2, 2, 2679, 2677, 3, 2, 2,
	2, 2680, 2681, 7, 333, 2, 2, 2681, 361, 3, 2, 2, 2, 2682, 2683, 7, 338,
	2, 2, 2683, 2684, 7, 296, 2, 2, 2684, 2685, 5, 364, 183, 2, 2685, 2686,
	7, 297, 2, 2, 2686, 363, 3, 2, 2, 2, 2687, 2692, 5, 366, 184, 2, 2688,
	2689, 7, 331, 2, 2, 2689, 2691, 5, 366, 184, 2, 2690, 2688, 3, 2, 2, 2,
	2691, 2694, 3, 2, 2, 2, 2692, 2690, 3, 2, 2, 2, 2692, 2693, 3, 2, 2, 2,
	2693, 2704, 3, 2, 2, 2, 2694, 2692, 3, 2, 2, 2, 2695, 2700, 5, 368, 185,
	2, 2696, 2697, 7, 331, 2, 2, 2697, 2699, 5, 368, 185, 2, 2698, 2696, 3,
	2, 2, 2, 2699, 2702, 3, 2, 2, 2, 2700, 2698, 3, 2, 2, 2, 2700, 2701, 3,
	2, 2, 2, 2701, 2704, 3, 2, 2, 2, 2702, 2700, 3, 2, 2, 2, 2703, 2687, 3,
	2, 2, 2, 2703, 2695, 3, 2, 2, 2, 2704, 365, 3, 2, 2, 2, 2705, 2706, 5,
	578, 290, 2, 2706, 367, 3, 2, 2, 2, 2707, 2708, 7, 330, 2, 2, 2708, 2709,
	5, 670, 336, 2, 2709, 2711, 7, 296, 2, 2, 2710, 2712, 5, 582, 292, 2, 2711,
	2710, 3, 2, 2, 2, 2711, 2712, 3, 2, 2, 2, 2712, 2713, 3, 2, 2, 2, 2713,
	2714, 7, 297, 2, 2, 2714, 369, 3, 2, 2, 2, 2715, 2716, 5, 372, 187, 2,
	2716, 2717, 7, 296, 2, 2, 2717, 2718, 5, 374, 188, 2, 2718, 2719, 7, 297,
	2, 2, 2719, 371, 3, 2, 2, 2, 2720, 2722, 5, 664, 333, 2, 2721, 2723, 5,
	274, 138, 2, 2722, 2721, 3, 2, 2, 2, 2722, 2723, 3, 2, 2, 2, 2723, 373,
	3, 2, 2, 2, 2724, 2729, 5, 376, 189, 2, 2725, 2726, 7, 331, 2, 2, 2726,
	2728, 5, 376, 189, 2, 2727, 2725, 3, 2, 2, 2, 2728, 2731, 3, 2, 2, 2, 2729,
	2727, 3, 2, 2, 2, 2729, 2730, 3, 2, 2, 2, 2730, 2741, 3, 2, 2, 2, 2731,
	2729, 3, 2, 2, 2, 2732, 2737, 5, 378, 190, 2, 2733, 2734, 7, 331, 2, 2,
	2734, 2736, 5, 378, 190, 2, 2735, 2733, 3, 2, 2, 2, 2736, 2739, 3, 2, 2,
	2, 2737, 2735, 3, 2, 2, 2, 2737, 2738, 3, 2, 2, 2, 2738, 2741, 3, 2, 2,
	2, 2739, 2737, 3, 2, 2, 2, 2740, 2724, 3, 2, 2, 2, 2740, 2732, 3, 2, 2,
	2, 2741, 375, 3, 2, 2, 2, 2742, 2744, 5, 614, 308, 2, 2743, 2742, 3, 2,
	2, 2, 2744, 2747, 3, 2, 2, 2, 2745, 2743, 3, 2, 2, 2, 2745, 2746, 3, 2,
	2, 2, 2746, 2749, 3, 2, 2, 2, 2747, 2745, 3, 2, 2, 2, 2748, 2750, 5, 578,
	290, 2, 2749, 2748, 3, 2, 2, 2, 2749, 2750, 3, 2, 2, 2, 2750, 377, 3, 2,
	2, 2, 2751, 2753, 5, 614, 308, 2, 2752, 2751, 3, 2, 2, 2, 2753, 2756, 3,
	2, 2, 2, 2754, 2752, 3, 2, 2, 2, 2754, 2755, 3, 2, 2, 2, 2755, 2757, 3,
	2, 2, 2, 2756, 2754, 3, 2, 2, 2, 2757, 2758, 7, 330, 2, 2, 2758, 2759,
	5, 672, 337, 2, 2759, 2761, 7, 296, 2, 2, 2760, 2762, 5, 578, 290, 2, 2761,
	2760, 3, 2, 2, 2, 2761, 2762, 3, 2, 2, 2, 2762, 2763, 3, 2, 2, 2, 2763,
	2764, 7, 297, 2, 2, 2764, 379, 3, 2, 2, 2, 2765, 2769, 7, 40, 2, 2, 2766,
	2768, 5, 160, 81, 2, 2767, 2766, 3, 2, 2, 2, 2768, 2771, 3, 2, 2, 2, 2769,
	2767, 3, 2, 2, 2, 2769, 2770, 3, 2, 2, 2, 2770, 2772, 3, 2, 2, 2, 2771,
	2769, 3, 2, 2, 2, 2772, 2773, 7, 28, 2, 2, 2773, 381, 3, 2, 2, 2, 2774,
	2775, 7, 41, 2, 2, 2775, 2776, 5, 384, 193, 2, 2776, 2777, 7, 333, 2, 2,
	2777, 383, 3, 2, 2, 2, 2778, 2783, 5, 634, 318, 2, 2779, 2780, 7, 331,
	2, 2, 2780, 2782, 5, 634, 318, 2, 2781, 2779, 3, 2, 2, 2, 2782, 2785, 3,
	2, 2, 2, 2783, 2781, 3, 2, 2, 2, 2783, 2784, 3, 2, 2, 2, 2784, 385, 3,
	2, 2, 2, 2785, 2783, 3, 2, 2, 2, 2786, 2787, 7, 35, 2, 2, 2787, 2788, 7,
	296, 2, 2, 2788, 2789, 5, 388, 195, 2, 2789, 2790, 7, 333, 2, 2, 2790,
	2791, 5, 390, 196, 2, 2791, 2792, 7, 333, 2, 2, 2792, 2793, 5, 392, 197,
	2, 2793, 2794, 7, 297, 2, 2, 2794, 2795, 5, 402, 202, 2, 2795, 387, 3,
	2, 2, 2, 2796, 2797, 5, 634, 318, 2, 2797, 2798, 7, 335, 2, 2, 2798, 2799,
	5, 570, 286, 2, 2799, 389, 3, 2, 2, 2, 2800, 2801, 8, 196, 1, 2, 2801,
	2812, 5, 394, 198, 2, 2802, 2806, 5, 604, 303, 2, 2803, 2805, 5, 614, 308,
	2, 2804, 2803, 3, 2, 2, 2, 2805, 2808, 3, 2, 2, 2, 2806, 2804, 3, 2, 2,
	2, 2806, 2807, 3, 2, 2, 2, 2807, 2809, 3, 2, 2, 2, 2808, 2806, 3, 2, 2,
	2, 2809, 2810, 5, 394, 198, 2, 2810, 2812, 3, 2, 2, 2, 2811, 2800, 3, 2,
	2, 2, 2811, 2802, 3, 2, 2, 2, 2812, 2837, 3, 2, 2, 2, 2813, 2814, 12, 4,
	2, 2, 2814, 2818, 5, 606, 304, 2, 2815, 2817, 5, 614, 308, 2, 2816, 2815,
	3, 2, 2, 2, 2817, 2820, 3, 2, 2, 2, 2818, 2816, 3, 2, 2, 2, 2818, 2819,
	3, 2, 2, 2, 2819, 2821, 3, 2, 2, 2, 2820, 2818, 3, 2, 2, 2, 2821, 2822,
	5, 390, 196, 5, 2822, 2836, 3, 2, 2, 2, 2823, 2824, 12, 3, 2, 2, 2824,
	2828, 7, 336, 2, 2, 2825, 2827, 5, 614, 308, 2, 2826, 2825, 3, 2, 2, 2,
	2827, 2830, 3, 2, 2, 2, 2828, 2826, 3, 2, 2, 2, 2828, 2829, 3, 2, 2, 2,
	2829, 2831, 3, 2, 2, 2, 2830, 2828, 3, 2, 2, 2, 2831, 2832, 5, 390, 196,
	2, 2832, 2833, 7, 332, 2, 2, 2833, 2834, 5, 390, 196, 4, 2834, 2836, 3,
	2, 2, 2, 2835, 2813, 3, 2, 2, 2, 2835, 2823, 3, 2, 2, 2, 2836, 2839, 3,
	2, 2, 2, 2837, 2835, 3, 2, 2, 2, 2837, 2838, 3, 2, 2, 2, 2838, 391, 3,
	2, 2, 2, 2839, 2837, 3, 2, 2, 2, 2840, 2841, 5, 634, 318, 2, 2841, 2842,
	7, 335, 2, 2, 2842, 2843, 5, 390, 196, 2, 2843, 393, 3, 2, 2, 2, 2844,
	2847, 5, 594, 298, 2, 2845, 2847, 5, 634, 318, 2, 2846, 2844, 3, 2, 2,
	2, 2846, 2845, 3, 2, 2, 2, 2847, 395, 3, 2, 2, 2, 2848, 2851, 5, 398, 200,
	2, 2849, 2851, 5, 400, 201, 2, 2850, 2848, 3, 2, 2, 2, 2850, 2849, 3, 2,
	2, 2, 2851, 397, 3, 2, 2, 2, 2852, 2853, 7, 44, 2, 2, 2853, 2854, 7, 296,
	2, 2, 2854, 2855, 5, 570, 286, 2, 2855, 2856, 7, 297, 2, 2, 2856, 2859,
	5, 404, 203, 2, 2857, 2858, 7, 23, 2, 2, 2858, 2860, 5, 404, 203, 2, 2859,
	2857, 3, 2, 2, 2, 2859, 2860, 3, 2, 2, 2, 2860, 399, 3, 2, 2, 2, 2861,
	2866, 5, 570, 286, 2, 2862, 2863, 7, 331, 2, 2, 2863, 2865, 5, 570, 286,
	2, 2864, 2862, 3, 2, 2, 2, 2865, 2868, 3, 2, 2, 2, 2866, 2864, 3, 2, 2,
	2, 2866, 2867, 3, 2, 2, 2, 2867, 2869, 3, 2, 2, 2, 2868, 2866, 3, 2, 2,
	2, 2869, 2870, 7, 332, 2, 2, 2870, 2871, 5, 404, 203, 2, 2871, 2878, 3,
	2, 2, 2, 2872, 2874, 7, 18, 2, 2, 2873, 2875, 7, 332, 2, 2, 2874, 2873,
	3, 2, 2, 2, 2874, 2875, 3, 2, 2, 2, 2875, 2876, 3, 2, 2, 2, 2876, 2878,
	5, 404, 203, 2, 2877, 2861, 3, 2, 2, 2, 2877, 2872, 3, 2, 2, 2, 2878, 401,
	3, 2, 2, 2, 2879, 2893, 5, 160, 81, 2, 2880, 2883, 7, 7, 2, 2, 2881, 2882,
	7, 332, 2, 2, 2882, 2884, 5, 632, 317, 2, 2883, 2881, 3, 2, 2, 2, 2883,
	2884, 3, 2, 2, 2, 2884, 2888, 3, 2, 2, 2, 2885, 2887, 5, 160, 81, 2, 2886,
	2885, 3, 2, 2, 2, 2887, 2890, 3, 2, 2, 2, 2888, 2886, 3, 2, 2, 2, 2888,
	2889, 3, 2, 2, 2, 2889, 2891, 3, 2, 2, 2, 2890, 2888, 3, 2, 2, 2, 2891,
	2893, 7, 24, 2, 2, 2892, 2879, 3, 2, 2, 2, 2892, 2880, 3, 2, 2, 2, 2893,
	403, 3, 2, 2, 2, 2894, 2897, 5, 402, 202, 2, 2895, 2897, 7, 333, 2, 2,
	2896, 2894, 3, 2, 2, 2, 2896, 2895, 3, 2, 2, 2, 2897, 405, 3, 2, 2, 2,
	2898, 2900, 7, 5, 2, 2, 2899, 2901, 5, 222, 112, 2, 2900, 2899, 3, 2, 2,
	2, 2900, 2901, 3, 2, 2, 2, 2901, 2903, 3, 2, 2, 2, 2902, 2904, 5, 230,
	116, 2, 2903, 2902, 3, 2, 2, 2, 2903, 2904, 3, 2, 2, 2, 2904, 2905, 3,
	2, 2, 2, 2905, 2906, 5, 408, 205, 2, 2906, 2907, 7, 333, 2, 2, 2907, 407,
	3, 2, 2, 2, 2908, 2913, 5, 410, 206, 2, 2909, 2910, 7, 331, 2, 2, 2910,
	2912, 5, 410, 206, 2, 2911, 2909, 3, 2, 2, 2, 2912, 2915, 3, 2, 2, 2, 2913,
	2911, 3, 2, 2, 2, 2913, 2914, 3, 2, 2, 2, 2914, 409, 3, 2, 2, 2, 2915,
	2913, 3, 2, 2, 2, 2916, 2917, 5, 600, 301, 2, 2917, 2918, 7, 335, 2, 2,
	2918, 2919, 5, 578, 290, 2, 2919, 411, 3, 2, 2, 2, 2920, 2921, 7, 48, 2,
	2, 2921, 2922, 5, 428, 215, 2, 2922, 413, 3, 2, 2, 2, 2923, 2924, 7, 3,
	2, 2, 2924, 2925, 5, 428, 215, 2, 2925, 415, 3, 2, 2, 2, 2926, 2927, 5,
	602, 302, 2, 2927, 2929, 7, 335, 2, 2, 2928, 2930, 5, 436, 219, 2, 2929,
	2928, 3, 2, 2, 2, 2929, 2930, 3, 2, 2, 2, 2930, 2931, 3, 2, 2, 2, 2931,
	2932, 5, 578, 290, 2, 2932, 417, 3, 2, 2, 2, 2933, 2934, 5, 602, 302, 2,
	2934, 2936, 7, 323, 2, 2, 2935, 2937, 5, 436, 219, 2, 2936, 2935, 3, 2,
	2, 2, 2936, 2937, 3, 2, 2, 2, 2937, 2938, 3, 2, 2, 2, 2938, 2939, 5, 578,
	290, 2, 2939, 419, 3, 2, 2, 2, 2940, 2941, 7, 5, 2, 2, 2941, 2953, 5, 422,
	212, 2, 2942, 2943, 7, 17, 2, 2, 2943, 2953, 5, 602, 302, 2, 2944, 2945,
	7, 36, 2, 2, 2945, 2953, 5, 422, 212, 2, 2946, 2947, 7, 36, 2, 2, 2947,
	2953, 5, 410, 206, 2, 2948, 2949, 7, 85, 2, 2, 2949, 2953, 5, 602, 302,
	2, 2950, 2951, 7, 85, 2, 2, 2951, 2953, 5, 600, 301, 2, 2952, 2940, 3,
	2, 2, 2, 2952, 2942, 3, 2, 2, 2, 2952, 2944, 3, 2, 2, 2, 2952, 2946, 3,
	2, 2, 2, 2952, 2948, 3, 2, 2, 2, 2952, 2950, 3, 2, 2, 2, 2953, 421, 3,
	2, 2, 2, 2954, 2955, 5, 602, 302, 2, 2955, 2956, 7, 335, 2, 2, 2956, 2957,
	5, 578, 290, 2, 2957, 423, 3, 2, 2, 2, 2958, 2967, 7, 38, 2, 2, 2959, 2960,
	7, 332, 2, 2, 2960, 2964, 5, 620, 311, 2, 2961, 2963, 5, 300, 151, 2, 2962,
	2961, 3, 2, 2, 2, 2963, 2966, 3, 2, 2, 2, 2964, 2962, 3, 2, 2, 2, 2964,
	2965, 3, 2, 2, 2, 2965, 2968, 3, 2, 2, 2, 2966, 2964, 3, 2, 2, 2, 2967,
	2959, 3, 2, 2, 2, 2967, 2968, 3, 2, 2, 2, 2968, 2972, 3, 2, 2, 2, 2969,
	2971, 5, 428, 215, 2, 2970, 2969, 3, 2, 2, 2, 2971, 2974, 3, 2, 2, 2, 2972,
	2970, 3, 2, 2, 2, 2972, 2973, 3, 2, 2, 2, 2973, 2975, 3, 2, 2, 2, 2974,
	2972, 3, 2, 2, 2, 2975, 2976, 7, 53, 2, 2, 2976, 425, 3, 2, 2, 2, 2977,
	2986, 7, 7, 2, 2, 2978, 2979, 7, 332, 2, 2, 2979, 2983, 5, 620, 311, 2,
	2980, 2982, 5, 300, 151, 2, 2981, 2980, 3, 2, 2, 2, 2982, 2985, 3, 2, 2,
	2, 2983, 2981, 3, 2, 2, 2, 2983, 2984, 3, 2, 2, 2, 2984, 2987, 3, 2, 2,
	2, 2985, 2983, 3, 2, 2, 2, 2986, 2978, 3, 2, 2, 2, 2986, 2987, 3, 2, 2,
	2, 2987, 2991, 3, 2, 2, 2, 2988, 2990, 5, 428, 215, 2, 2989, 2988, 3, 2,
	2, 2, 2990, 2993, 3, 2, 2, 2, 2991, 2989, 3, 2, 2, 2, 2991, 2992, 3, 2,
	2, 2, 2992, 2994, 3, 2, 2, 2, 2993, 2991, 3, 2, 2, 2, 2994, 2995, 7, 24,
	2, 2, 2995, 427, 3, 2, 2, 2, 2996, 2998, 5, 614, 308, 2, 2997, 2996, 3,
	2, 2, 2, 2998, 3001, 3, 2, 2, 2, 2999, 2997, 3, 2, 2, 2, 2999, 3000, 3,
	2, 2, 2, 3000, 3002, 3, 2, 2, 2, 3001, 2999, 3, 2, 2, 2, 3002, 3003, 5,
	416, 209, 2, 3003, 3004, 7, 333, 2, 2, 3004, 3123, 3, 2, 2, 2, 3005, 3007,
	5, 614, 308, 2, 3006, 3005, 3, 2, 2, 2, 3007, 3010, 3, 2, 2, 2, 3008, 3006,
	3, 2, 2, 2, 3008, 3009, 3, 2, 2, 2, 3009, 3011, 3, 2, 2, 2, 3010, 3008,
	3, 2, 2, 2, 3011, 3123, 5, 456, 229, 2, 3012, 3014, 5, 614, 308, 2, 3013,
	3012, 3, 2, 2, 2, 3014, 3017, 3, 2, 2, 2, 3015, 3013, 3, 2, 2, 2, 3015,
	3016, 3, 2, 2, 2, 3016, 3018, 3, 2, 2, 2, 3017, 3015, 3, 2, 2, 2, 3018,
	3123, 5, 454, 228, 2, 3019, 3021, 5, 614, 308, 2, 3020, 3019, 3, 2, 2,
	2, 3021, 3024, 3, 2, 2, 2, 3022, 3020, 3, 2, 2, 2, 3022, 3023, 3, 2, 2,
	2, 3023, 3025, 3, 2, 2, 2, 3024, 3022, 3, 2, 2, 2, 3025, 3123, 5, 438,
	220, 2, 3026, 3028, 5, 614, 308, 2, 3027, 3026, 3, 2, 2, 2, 3028, 3031,
	3, 2, 2, 2, 3029, 3027, 3, 2, 2, 2, 3029, 3030, 3, 2, 2, 2, 3030, 3032,
	3, 2, 2, 2, 3031, 3029, 3, 2, 2, 2, 3032, 3123, 5, 442, 222, 2, 3033, 3035,
	5, 614, 308, 2, 3034, 3033, 3, 2, 2, 2, 3035, 3038, 3, 2, 2, 2, 3036, 3034,
	3, 2, 2, 2, 3036, 3037, 3, 2, 2, 2, 3037, 3039, 3, 2, 2, 2, 3038, 3036,
	3, 2, 2, 2, 3039, 3123, 5, 460, 231, 2, 3040, 3042, 5, 614, 308, 2, 3041,
	3040, 3, 2, 2, 2, 3042, 3045, 3, 2, 2, 2, 3043, 3041, 3, 2, 2, 2, 3043,
	3044, 3, 2, 2, 2, 3044, 3046, 3, 2, 2, 2, 3045, 3043, 3, 2, 2, 2, 3046,
	3047, 5, 418, 210, 2, 3047, 3048, 7, 333, 2, 2, 3048, 3123, 3, 2, 2, 2,
	3049, 3051, 5, 614, 308, 2, 3050, 3049, 3, 2, 2, 2, 3051, 3054, 3, 2, 2,
	2, 3052, 3050, 3, 2, 2, 2, 3052, 3053, 3, 2, 2, 2, 3053, 3055, 3, 2, 2,
	2, 3054, 3052, 3, 2, 2, 2, 3055, 3123, 5, 424, 213, 2, 3056, 3058, 5, 614,
	308, 2, 3057, 3056, 3, 2, 2, 2, 3058, 3061, 3, 2, 2, 2, 3059, 3057, 3,
	2, 2, 2, 3059, 3060, 3, 2, 2, 2, 3060, 3062, 3, 2, 2, 2, 3061, 3059, 3,
	2, 2, 2, 3062, 3063, 5, 420, 211, 2, 3063, 3064, 7, 333, 2, 2, 3064, 3123,
	3, 2, 2, 2, 3065, 3067, 5, 614, 308, 2, 3066, 3065, 3, 2, 2, 2, 3067, 3070,
	3, 2, 2, 2, 3068, 3066, 3, 2, 2, 2, 3068, 3069, 3, 2, 2, 2, 3069, 3071,
	3, 2, 2, 2, 3070, 3068, 3, 2, 2, 2, 3071, 3123, 5, 450, 226, 2, 3072, 3074,
	5, 614, 308, 2, 3073, 3072, 3, 2, 2, 2, 3074, 3077, 3, 2, 2, 2, 3075, 3073,
	3, 2, 2, 2, 3075, 3076, 3, 2, 2, 2, 3076, 3078, 3, 2, 2, 2, 3077, 3075,
	3, 2, 2, 2, 3078, 3123, 5, 426, 214, 2, 3079, 3081, 5, 614, 308, 2, 3080,
	3079, 3, 2, 2, 2, 3081, 3084, 3, 2, 2, 2, 3082, 3080, 3, 2, 2, 2, 3082,
	3083, 3, 2, 2, 2, 3083, 3085, 3, 2, 2, 2, 3084, 3082, 3, 2, 2, 2, 3085,
	3123, 5, 462, 232, 2, 3086, 3088, 5, 614, 308, 2, 3087, 3086, 3, 2, 2,
	2, 3088, 3091, 3, 2, 2, 2, 3089, 3087, 3, 2, 2, 2, 3089, 3090, 3, 2, 2,
	2, 3090, 3092, 3, 2, 2, 2, 3091, 3089, 3, 2, 2, 2, 3092, 3123, 5, 464,
	233, 2, 3093, 3095, 5, 614, 308, 2, 3094, 3093, 3, 2, 2, 2, 3095, 3098,
	3, 2, 2, 2, 3096, 3094, 3, 2, 2, 2, 3096, 3097, 3, 2, 2, 2, 3097, 3099,
	3, 2, 2, 2, 3098, 3096, 3, 2, 2, 2, 3099, 3123, 5, 452, 227, 2, 3100, 3123,
	5, 2, 2, 2, 3101, 3123, 5, 10, 6, 2, 3102, 3123, 5, 14, 8, 2, 3103, 3123,
	5, 18, 10, 2, 3104, 3123, 5, 20, 11, 2, 3105, 3123, 5, 30, 16, 2, 3106,
	3123, 5, 34, 18, 2, 3107, 3123, 5, 44, 23, 2, 3108, 3123, 5, 48, 25, 2,
	3109, 3123, 5, 104, 53, 2, 3110, 3123, 5, 90, 46, 2, 3111, 3123, 5, 110,
	56, 2, 3112, 3123, 5, 106, 54, 2, 3113, 3123, 5, 100, 51, 2, 3114, 3123,
	5, 102, 52, 2, 3115, 3123, 5, 112, 57, 2, 3116, 3123, 5, 122, 62, 2, 3117,
	3123, 5, 126, 64, 2, 3118, 3123, 5, 124, 63, 2, 3119, 3123, 5, 118, 60,
	2, 3120, 3123, 5, 120, 61, 2, 3121, 3123, 5, 92, 47, 2, 3122, 2999, 3,
	2, 2, 2, 3122, 3008, 3, 2, 2, 2, 3122, 3015, 3, 2, 2, 2, 3122, 3022, 3,
	2, 2, 2, 3122, 3029, 3, 2, 2, 2, 3122, 3036, 3, 2, 2, 2, 3122, 3043, 3,
	2, 2, 2, 3122, 3052, 3, 2, 2, 2, 3122, 3059, 3, 2, 2, 2, 3122, 3068, 3,
	2, 2, 2, 3122, 3075, 3, 2, 2, 2, 3122, 3082, 3, 2, 2, 2, 3122, 3089, 3,
	2, 2, 2, 3122, 3096, 3, 2, 2, 2, 3122, 3100, 3, 2, 2, 2, 3122, 3101, 3,
	2, 2, 2, 3122, 3102, 3, 2, 2, 2, 3122, 3103, 3, 2, 2, 2, 3122, 3104, 3,
	2, 2, 2, 3122, 3105, 3, 2, 2, 2, 3122, 3106, 3, 2, 2, 2, 3122, 3107, 3,
	2, 2, 2, 3122, 3108, 3, 2, 2, 2, 3122, 3109, 3, 2, 2, 2, 3122, 3110, 3,
	2, 2, 2, 3122, 3111, 3, 2, 2, 2, 3122, 3112, 3, 2, 2, 2, 3122, 3113, 3,
	2, 2, 2, 3122, 3114, 3, 2, 2, 2, 3122, 3115, 3, 2, 2, 2, 3122, 3116, 3,
	2, 2, 2, 3122, 3117, 3, 2, 2, 2, 3122, 3118, 3, 2, 2, 2, 3122, 3119, 3,
	2, 2, 2, 3122, 3120, 3, 2, 2, 2, 3122, 3121, 3, 2, 2, 2, 3123, 429, 3,
	2, 2, 2, 3124, 3133, 5, 428, 215, 2, 3125, 3127, 5, 614, 308, 2, 3126,
	3125, 3, 2, 2, 2, 3127, 3130, 3, 2, 2, 2, 3128, 3126, 3, 2, 2, 2, 3128,
	3129, 3, 2, 2, 2, 3129, 3131, 3, 2, 2, 2, 3130, 3128, 3, 2, 2, 2, 3131,
	3133, 7, 333, 2, 2, 3132, 3124, 3, 2, 2, 2, 3132, 3128, 3, 2, 2, 2, 3133,
	431, 3, 2, 2, 2, 3134, 3135, 5, 428, 215, 2, 3135, 433, 3, 2, 2, 2, 3136,
	3137, 7, 338, 2, 2, 3137, 3144, 5, 234, 118, 2, 3138, 3139, 7, 338, 2,
	2, 3139, 3140, 7, 296, 2, 2, 3140, 3141, 5, 582, 292, 2, 3141, 3142, 7,
	297, 2, 2, 3142, 3144, 3, 2, 2, 2, 3143, 3136, 3, 2, 2, 2, 3143, 3138,
	3, 2, 2, 2, 3144, 435, 3, 2, 2, 2, 3145, 3154, 5, 434, 218, 2, 3146, 3154,
	5, 440, 221, 2, 3147, 3148, 7, 86, 2, 2, 3148, 3149, 7, 296, 2, 2, 3149,
	3150, 5, 578, 290, 2, 3150, 3151, 7, 297, 2, 2, 3151, 3152, 5, 440, 221,
	2, 3152, 3154, 3, 2, 2, 2, 3153, 3145, 3, 2, 2, 2, 3153, 3146, 3, 2, 2,
	2, 3153, 3147, 3, 2, 2, 2, 3154, 437, 3, 2, 2, 2, 3155, 3156, 7, 21, 2,
	2, 3156, 3157, 5, 650, 326, 2, 3157, 3158, 7, 333, 2, 2, 3158, 3164, 3,
	2, 2, 2, 3159, 3160, 7, 21, 2, 2, 3160, 3161, 5, 636, 319, 2, 3161, 3162,
	7, 333, 2, 2, 3162, 3164, 3, 2, 2, 2, 3163, 3155, 3, 2, 2, 2, 3163, 3159,
	3, 2, 2, 2, 3164, 439, 3, 2, 2, 2, 3165, 3166, 7, 337, 2, 2, 3166, 3179,
	5, 638, 320, 2, 3167, 3168, 7, 337, 2, 2, 3168, 3169, 7, 296, 2, 2, 3169,
	3170, 5, 444, 223, 2, 3170, 3171, 7, 297, 2, 2, 3171, 3179, 3, 2, 2, 2,
	3172, 3173, 7, 337, 2, 2, 3173, 3179, 7, 313, 2, 2, 3174, 3175, 7, 337,
	2, 2, 3175, 3176, 7, 296, 2, 2, 3176, 3177, 7, 313, 2, 2, 3177, 3179, 7,
	297, 2, 2, 3178, 3165, 3, 2, 2, 2, 3178, 3167, 3, 2, 2, 2, 3178, 3172,
	3, 2, 2, 2, 3178, 3174, 3, 2, 2, 2, 3179, 441, 3, 2, 2, 2, 3180, 3181,
	7, 342, 2, 2, 3181, 3185, 5, 638, 320, 2, 3182, 3184, 5, 578, 290, 2, 3183,
	3182, 3, 2, 2, 2, 3184, 3187, 3, 2, 2, 2, 3185, 3183, 3, 2, 2, 2, 3185,
	3186, 3, 2, 2, 2, 3186, 3188, 3, 2, 2, 2, 3187, 3185, 3, 2, 2, 2, 3188,
	3189, 7, 333, 2, 2, 3189, 443, 3, 2, 2, 2, 3190, 3191, 8, 223, 1, 2, 3191,
	3197, 5, 578, 290, 2, 3192, 3193, 7, 73, 2, 2, 3193, 3197, 5, 578, 290,
	2, 3194, 3195, 7, 62, 2, 2, 3195, 3197, 5, 578, 290, 2, 3196, 3190, 3,
	2, 2, 2, 3196, 3192, 3, 2, 2, 2, 3196, 3194, 3, 2, 2, 2, 3197, 3206, 3,
	2, 2, 2, 3198, 3199, 12, 4, 2, 2, 3199, 3200, 7, 69, 2, 2, 3200, 3205,
	5, 444, 223, 5, 3201, 3202, 12, 3, 2, 2, 3202, 3203, 7, 331, 2, 2, 3203,
	3205, 5, 444, 223, 4, 3204, 3198, 3, 2, 2, 2, 3204, 3201, 3, 2, 2, 2, 3205,
	3208, 3, 2, 2, 2, 3206, 3204, 3, 2, 2, 2, 3206, 3207, 3, 2, 2, 2, 3207,
	445, 3, 2, 2, 2, 3208, 3206, 3, 2, 2, 2, 3209, 3215, 5, 578, 290, 2, 3210,
	3211, 7, 73, 2, 2, 3211, 3215, 5, 578, 290, 2, 3212, 3213, 7, 62, 2, 2,
	3213, 3215, 5, 578, 290, 2, 3214, 3209, 3, 2, 2, 2, 3214, 3210, 3, 2, 2,
	2, 3214, 3212, 3, 2, 2, 2, 3215, 447, 3, 2, 2, 2, 3216, 3219, 5, 434, 218,
	2, 3217, 3219, 5, 440, 221, 2, 3218, 3216, 3, 2, 2, 2, 3218, 3217, 3, 2,
	2, 2, 3219, 449, 3, 2, 2, 2, 3220, 3221, 5, 448, 225, 2, 3221, 3222, 5,
	430, 216, 2, 3222, 451, 3, 2, 2, 2, 3223, 3224, 7, 118, 2, 2, 3224, 3225,
	7, 296, 2, 2, 3225, 3226, 5, 578, 290, 2, 3226, 3227, 7, 297, 2, 2, 3227,
	3228, 5, 430, 216, 2, 3228, 453, 3, 2, 2, 2, 3229, 3230, 7, 44, 2, 2, 3230,
	3231, 7, 296, 2, 2, 3231, 3232, 5, 578, 290, 2, 3232, 3233, 7, 297, 2,
	2, 3233, 3243, 5, 430, 216, 2, 3234, 3235, 7, 23, 2, 2, 3235, 3236, 7,
	44, 2, 2, 3236, 3237, 7, 296, 2, 2, 3237, 3238, 5, 578, 290, 2, 3238, 3239,
	7, 297, 2, 2, 3239, 3240, 5, 430, 216, 2, 3240, 3242, 3, 2, 2, 2, 3241,
	3234, 3, 2, 2, 2, 3242, 3245, 3, 2, 2, 2, 3243, 3241, 3, 2, 2, 2, 3243,
	3244, 3, 2, 2, 2, 3244, 3248, 3, 2, 2, 2, 3245, 3243, 3, 2, 2, 2, 3246,
	3247, 7, 23, 2, 2, 3247, 3249, 5, 430, 216, 2, 3248, 3246, 3, 2, 2, 2,
	3248, 3249, 3, 2, 2, 2, 3249, 455, 3, 2, 2, 2, 3250, 3251, 7, 11, 2, 2,
	3251, 3252, 7, 296, 2, 2, 3252, 3253, 5, 578, 290, 2, 3253, 3254, 7, 297,
	2, 2, 3254, 3258, 5, 458, 230, 2, 3255, 3257, 5, 458, 230, 2, 3256, 3255,
	3, 2, 2, 2, 3257, 3260, 3, 2, 2, 2, 3258, 3256, 3, 2, 2, 2, 3258, 3259,
	3, 2, 2, 2, 3259, 3261, 3, 2, 2, 2, 3260, 3258, 3, 2, 2, 2, 3261, 3262,
	7, 25, 2, 2, 3262, 3290, 3, 2, 2, 2, 3263, 3264, 7, 13, 2, 2, 3264, 3265,
	7, 296, 2, 2, 3265, 3266, 5, 578, 290, 2, 3266, 3267, 7, 297, 2, 2, 3267,
	3271, 5, 458, 230, 2, 3268, 3270, 5, 458, 230, 2, 3269, 3268, 3, 2, 2,
	2, 3270, 3273, 3, 2, 2, 2, 3271, 3269, 3, 2, 2, 2, 3271, 3272, 3, 2, 2,
	2, 3272, 3274, 3, 2, 2, 2, 3273, 3271, 3, 2, 2, 2, 3274, 3275, 7, 25, 2,
	2, 3275, 3290, 3, 2, 2, 2, 3276, 3277, 7, 12, 2, 2, 3277, 3278, 7, 296,
	2, 2, 3278, 3279, 5, 578, 290, 2, 3279, 3280, 7, 297, 2, 2, 3280, 3284,
	5, 458, 230, 2, 3281, 3283, 5, 458, 230, 2, 3282, 3281, 3, 2, 2, 2, 3283,
	3286, 3, 2, 2, 2, 3284, 3282, 3, 2, 2, 2, 3284, 3285, 3, 2, 2, 2, 3285,
	3287, 3, 2, 2, 2, 3286, 3284, 3, 2, 2, 2, 3287, 3288, 7, 25, 2, 2, 3288,
	3290, 3, 2, 2, 2, 3289, 3250, 3, 2, 2, 2, 3289, 3263, 3, 2, 2, 2, 3289,
	3276, 3, 2, 2, 2, 3290, 457, 3, 2, 2, 2, 3291, 3296, 5, 578, 290, 2, 3292,
	3293, 7, 331, 2, 2, 3293, 3295, 5, 578, 290, 2, 3294, 3292, 3, 2, 2, 2,
	3295, 3298, 3, 2, 2, 2, 3296, 3294, 3, 2, 2, 2, 3296, 3297, 3, 2, 2, 2,
	3297, 3299, 3, 2, 2, 2, 3298, 3296, 3, 2, 2, 2, 3299, 3300, 7, 332, 2,
	2, 3300, 3301, 5, 430, 216, 2, 3301, 3308, 3, 2, 2, 2, 3302, 3304, 7, 18,
	2, 2, 3303, 3305, 7, 332, 2, 2, 3304, 3303, 3, 2, 2, 2, 3304, 3305, 3,
	2, 2, 2, 3305, 3306, 3, 2, 2, 2, 3306, 3308, 5, 430, 216, 2, 3307, 3291,
	3, 2, 2, 2, 3307, 3302, 3, 2, 2, 2, 3308, 459, 3, 2, 2, 2, 3309, 3310,
	7, 37, 2, 2, 3310, 3334, 5, 428, 215, 2, 3311, 3312, 7, 86, 2, 2, 3312,
	3313, 7, 296, 2, 2, 3313, 3314, 5, 578, 290, 2, 3314, 3315, 7, 297, 2,
	2, 3315, 3316, 5, 428, 215, 2, 3316, 3334, 3, 2, 2, 2, 3317, 3318, 7, 122,
	2, 2, 3318, 3319, 7, 296, 2, 2, 3319, 3320, 5, 578, 290, 2, 3320, 3321,
	7, 297, 2, 2, 3321, 3322, 5, 428, 215, 2, 3322, 3334, 3, 2, 2, 2, 3323,
	3324, 7, 35, 2, 2, 3324, 3325, 7, 296, 2, 2, 3325, 3326, 5, 422, 212, 2,
	3326, 3327, 7, 333, 2, 2, 3327, 3328, 5, 578, 290, 2, 3328, 3329, 7, 333,
	2, 2, 3329, 3330, 5, 422, 212, 2, 3330, 3331, 7, 297, 2, 2, 3331, 3332,
	5, 428, 215, 2, 3332, 3334, 3, 2, 2, 2, 3333, 3309, 3, 2, 2, 2, 3333, 3311,
	3, 2, 2, 2, 3333, 3317, 3, 2, 2, 2, 3333, 3323, 3, 2, 2, 2, 3334, 461,
	3, 2, 2, 2, 3335, 3350, 5, 680, 341, 2, 3336, 3338, 7, 296, 2, 2, 3337,
	3339, 5, 578, 290, 2, 3338, 3337, 3, 2, 2, 2, 3338, 3339, 3, 2, 2, 2, 3339,
	3346, 3, 2, 2, 2, 3340, 3342, 7, 331, 2, 2, 3341, 3343, 5, 578, 290, 2,
	3342, 3341, 3, 2, 2, 2, 3342, 3343, 3, 2, 2, 2, 3343, 3345, 3, 2, 2, 2,
	3344, 3340, 3, 2, 2, 2, 3345, 3348, 3, 2, 2, 2, 3346, 3344, 3, 2, 2, 2,
	3346, 3347, 3, 2, 2, 2, 3347, 3349, 3, 2, 2, 2, 3348, 3346, 3, 2, 2, 2,
	3349, 3351, 7, 297, 2, 2, 3350, 3336, 3, 2, 2, 2, 3350, 3351, 3, 2, 2,
	2, 3351, 3352, 3, 2, 2, 2, 3352, 3353, 7, 333, 2, 2, 3353, 463, 3, 2, 2,
	2, 3354, 3366, 5, 650, 326, 2, 3355, 3356, 7, 296, 2, 2, 3356, 3361, 5,
	578, 290, 2, 3357, 3358, 7, 331, 2, 2, 3358, 3360, 5, 578, 290, 2, 3359,
	3357, 3, 2, 2, 2, 3360, 3363, 3, 2, 2, 2, 3361, 3359, 3, 2, 2, 2, 3361,
	3362, 3, 2, 2, 2, 3362, 3364, 3, 2, 2, 2, 3363, 3361, 3, 2, 2, 2, 3364,
	3365, 7, 297, 2, 2, 3365, 3367, 3, 2, 2, 2, 3366, 3355, 3, 2, 2, 2, 3366,
	3367, 3, 2, 2, 2, 3367, 3368, 3, 2, 2, 2, 3368, 3369, 7, 333, 2, 2, 3369,
	465, 3, 2, 2, 2, 3370, 3374, 7, 96, 2, 2, 3371, 3373, 5, 468, 235, 2, 3372,
	3371, 3, 2, 2, 2, 3373, 3376, 3, 2, 2, 2, 3374, 3372, 3, 2, 2, 2, 3374,
	3375, 3, 2, 2, 2, 3375, 3377, 3, 2, 2, 2, 3376, 3374, 3, 2, 2, 2, 3377,
	3378, 7, 31, 2, 2, 3378, 467, 3, 2, 2, 2, 3379, 3384, 5, 190, 96, 2, 3380,
	3384, 5, 470, 236, 2, 3381, 3384, 5, 472, 237, 2, 3382, 3384, 5, 474, 238,
	2, 3383, 3379, 3, 2, 2, 2, 3383, 3380, 3, 2, 2, 2, 3383, 3381, 3, 2, 2,
	2, 3383, 3382, 3, 2, 2, 2, 3384, 469, 3, 2, 2, 2, 3385, 3386, 7, 79, 2,
	2, 3386, 3387, 5, 484, 243, 2, 3387, 3388, 7, 333, 2, 2, 3388, 3394, 3,
	2, 2, 2, 3389, 3390, 7, 80, 2, 2, 3390, 3391, 5, 484, 243, 2, 3391, 3392,
	7, 333, 2, 2, 3392, 3394, 3, 2, 2, 2, 3393, 3385, 3, 2, 2, 2, 3393, 3389,
	3, 2, 2, 2, 3394, 471, 3, 2, 2, 2, 3395, 3396, 7, 93, 2, 2, 3396, 3397,
	5, 484, 243, 2, 3397, 3398, 7, 333, 2, 2, 3398, 3404, 3, 2, 2, 2, 3399,
	3400, 7, 65, 2, 2, 3400, 3401, 5, 484, 243, 2, 3401, 3402, 7, 333, 2, 2,
	3402, 3404, 3, 2, 2, 2, 3403, 3395, 3, 2, 2, 2, 3403, 3399, 3, 2, 2, 2,
	3404, 473, 3, 2, 2, 2, 3405, 3406, 5, 476, 239, 2, 3406, 3407, 7, 333,
	2, 2, 3407, 3415, 3, 2, 2, 2, 3408, 3409, 5, 532, 267, 2, 3409, 3410, 7,
	333, 2, 2, 3410, 3415, 3, 2, 2, 2, 3411, 3412, 5, 542, 272, 2, 3412, 3413,
	7, 333, 2, 2, 3413, 3415, 3, 2, 2, 2, 3414, 3405, 3, 2, 2, 2, 3414, 3408,
	3, 2, 2, 2, 3414, 3411, 3, 2, 2, 2, 3415, 475, 3, 2, 2, 2, 3416, 3417,
	5, 478, 240, 2, 3417, 3418, 7, 335, 2, 2, 3418, 3419, 5, 494, 248, 2, 3419,
	3425, 3, 2, 2, 2, 3420, 3421, 5, 480, 241, 2, 3421, 3422, 7, 335, 2, 2,
	3422, 3423, 5, 494, 248, 2, 3423, 3425, 3, 2, 2, 2, 3424, 3416, 3, 2, 2,
	2, 3424, 3420, 3, 2, 2, 2, 3425, 477, 3, 2, 2, 2, 3426, 3427, 7, 296, 2,
	2, 3427, 3429, 5, 486, 244, 2, 3428, 3430, 5, 544, 273, 2, 3429, 3428,
	3, 2, 2, 2, 3429, 3430, 3, 2, 2, 2, 3430, 3431, 3, 2, 2, 2, 3431, 3432,
	7, 343, 2, 2, 3432, 3433, 5, 488, 245, 2, 3433, 3434, 7, 297, 2, 2, 3434,
	479, 3, 2, 2, 2, 3435, 3436, 7, 296, 2, 2, 3436, 3438, 5, 482, 242, 2,
	3437, 3439, 5, 544, 273, 2, 3438, 3437, 3, 2, 2, 2, 3438, 3439, 3, 2, 2,
	2, 3439, 3440, 3, 2, 2, 2, 3440, 3441, 7, 344, 2, 2, 3441, 3442, 5, 484,
	243, 2, 3442, 3443, 7, 297, 2, 2, 3443, 481, 3, 2, 2, 2, 3444, 3449, 5,
	486, 244, 2, 3445, 3446, 7, 331, 2, 2, 3446, 3448, 5, 486, 244, 2, 3447,
	3445, 3, 2, 2, 2, 3448, 3451, 3, 2, 2, 2, 3449, 3447, 3, 2, 2, 2, 3449,
	3450, 3, 2, 2, 2, 3450, 483, 3, 2, 2, 2, 3451, 3449, 3, 2, 2, 2, 3452,
	3457, 5, 488, 245, 2, 3453, 3454, 7, 331, 2, 2, 3454, 3456, 5, 488, 245,
	2, 3455, 3453, 3, 2, 2, 2, 3456, 3459, 3, 2, 2, 2, 3457, 3455, 3, 2, 2,
	2, 3457, 3458, 3, 2, 2, 2, 3458, 485, 3, 2, 2, 2, 3459, 3457, 3, 2, 2,
	2, 3460, 3465, 5, 490, 246, 2, 3461, 3462, 7, 298, 2, 2, 3462, 3463, 5,
	574, 288, 2, 3463, 3464, 7, 299, 2, 2, 3464, 3466, 3, 2, 2, 2, 3465, 3461,
	3, 2, 2, 2, 3465, 3466, 3, 2, 2, 2, 3466, 487, 3, 2, 2, 2, 3467, 3472,
	5, 492, 247, 2, 3468, 3469, 7, 298, 2, 2, 3469, 3470, 5, 574, 288, 2, 3470,
	3471, 7, 299, 2, 2, 3471, 3473, 3, 2, 2, 2, 3472, 3468, 3, 2, 2, 2, 3472,
	3473, 3, 2, 2, 2, 3473, 489, 3, 2, 2, 2, 3474, 3477, 5, 656, 329, 2, 3475,
	3477, 5, 654, 328, 2, 3476, 3474, 3, 2, 2, 2, 3476, 3475, 3, 2, 2, 2, 3477,
	491, 3, 2, 2, 2, 3478, 3481, 5, 668, 335, 2, 3479, 3481, 5, 654, 328, 2,
	3480, 3478, 3, 2, 2, 2, 3480, 3479, 3, 2, 2, 2, 3481, 493, 3, 2, 2, 2,
	3482, 3488, 5, 496, 249, 2, 3483, 3484, 7, 296, 2, 2, 3484, 3485, 5, 496,
	249, 2, 3485, 3486, 7, 297, 2, 2, 3486, 3488, 3, 2, 2, 2, 3487, 3482, 3,
	2, 2, 2, 3487, 3483, 3, 2, 2, 2, 3488, 495, 3, 2, 2, 2, 3489, 3537, 5,
	498, 250, 2, 3490, 3491, 5, 500, 251, 2, 3491, 3492, 7, 331, 2, 2, 3492,
	3493, 5, 502, 252, 2, 3493, 3537, 3, 2, 2, 2, 3494, 3495, 5, 500, 251,
	2, 3495, 3496, 7, 331, 2, 2, 3496, 3497, 5, 502, 252, 2, 3497, 3498, 7,
	331, 2, 2, 3498, 3499, 5, 504, 253, 2, 3499, 3537, 3, 2, 2, 2, 3500, 3501,
	5, 506, 254, 2, 3501, 3502, 7, 331, 2, 2, 3502, 3503, 5, 508, 255, 2, 3503,
	3504, 7, 331, 2, 2, 3504, 3505, 5, 510, 256, 2, 3505, 3506, 7, 331, 2,
	2, 3506, 3507, 5, 512, 257, 2, 3507, 3508, 7, 331, 2, 2, 3508, 3509, 5,
	514, 258, 2, 3509, 3510, 7, 331, 2, 2, 3510, 3511, 5, 516, 259, 2, 3511,
	3537, 3, 2, 2, 2, 3512, 3513, 5, 506, 254, 2, 3513, 3514, 7, 331, 2, 2,
	3514, 3515, 5, 508, 255, 2, 3515, 3516, 7, 331, 2, 2, 3516, 3517, 5, 510,
	256, 2, 3517, 3518, 7, 331, 2, 2, 3518, 3519, 5, 512, 257, 2, 3519, 3520,
	7, 331, 2, 2, 3520, 3521, 5, 514, 258, 2, 3521, 3522, 7, 331, 2, 2, 3522,
	3523, 5, 516, 259, 2, 3523, 3524, 7, 331, 2, 2, 3524, 3525, 5, 518, 260,
	2, 3525, 3526, 7, 331, 2, 2, 3526, 3527, 5, 520, 261, 2, 3527, 3528, 7,
	331, 2, 2, 3528, 3529, 5, 522, 262, 2, 3529, 3530, 7, 331, 2, 2, 3530,
	3531, 5, 524, 263, 2, 3531, 3532, 7, 331, 2, 2, 3532, 3533, 5, 526, 264,
	2, 3533, 3534, 7, 331, 2, 2, 3534, 3535, 5, 528, 265, 2, 3535, 3537, 3,
	2, 2, 2, 3536, 3489, 3, 2, 2, 2, 3536, 3490, 3, 2, 2, 2, 3536, 3494, 3,
	2, 2, 2, 3536, 3500, 3, 2, 2, 2, 3536, 3512, 3, 2, 2, 2, 3537, 497, 3,
	2, 2, 2, 3538, 3539, 5, 530, 266, 2, 3539, 499, 3, 2, 2, 2, 3540, 3541,
	5, 530, 266, 2, 3541, 501, 3, 2, 2, 2, 3542, 3543, 5, 530, 266, 2, 3543,
	503, 3, 2, 2, 2, 3544, 3545, 5, 530, 266, 2, 3545, 505, 3, 2, 2, 2, 3546,
	3547, 5, 530, 266, 2, 3547, 507, 3, 2, 2, 2, 3548, 3549, 5, 530, 266, 2,
	3549, 509, 3, 2, 2, 2, 3550, 3551, 5, 530, 266, 2, 3551, 511, 3, 2, 2,
	2, 3552, 3553, 5, 530, 266, 2, 3553, 513, 3, 2, 2, 2, 3554, 3555, 5, 530,
	266, 2, 3555, 515, 3, 2, 2, 2, 3556, 3557, 5, 530, 266, 2, 3557, 517, 3,
	2, 2, 2, 3558, 3559, 5, 530, 266, 2, 3559, 519, 3, 2, 2, 2, 3560, 3561,
	5, 530, 266, 2, 3561, 521, 3, 2, 2, 2, 3562, 3563, 5, 530, 266, 2, 3563,
	523, 3, 2, 2, 2, 3564, 3565, 5, 530, 266, 2, 3565, 525, 3, 2, 2, 2, 3566,
	3567, 5, 530, 266, 2, 3567, 527, 3, 2, 2, 2, 3568, 3569, 5, 530, 266, 2,
	3569, 529, 3, 2, 2, 2, 3570, 3571, 5, 572, 287, 2, 3571, 531, 3, 2, 2,
	2, 3572, 3573, 5, 534, 268, 2, 3573, 3574, 7, 335, 2, 2, 3574, 3575, 5,
	494, 248, 2, 3575, 3581, 3, 2, 2, 2, 3576, 3577, 5, 536, 269, 2, 3577,
	3578, 7, 335, 2, 2, 3578, 3579, 5, 494, 248, 2, 3579, 3581, 3, 2, 2, 2,
	3580, 3572, 3, 2, 2, 2, 3580, 3576, 3, 2, 2, 2, 3581, 533, 3, 2, 2, 2,
	3582, 3584, 7, 296, 2, 2, 3583, 3585, 5, 540, 271, 2, 3584, 3583, 3, 2,
	2, 2, 3584, 3585, 3, 2, 2, 2, 3585, 3586, 3, 2, 2, 2, 3586, 3587, 5, 486,
	244, 2, 3587, 3588, 7, 343, 2, 2, 3588, 3589, 7, 296, 2, 2, 3589, 3591,
	5, 488, 245, 2, 3590, 3592, 5, 544, 273, 2, 3591, 3590, 3, 2, 2, 2, 3591,
	3592, 3, 2, 2, 2, 3592, 3593, 3, 2, 2, 2, 3593, 3594, 7, 332, 2, 2, 3594,
	3595, 5, 538, 270, 2, 3595, 3596, 7, 297, 2, 2, 3596, 3597, 7, 297, 2,
	2, 3597, 535, 3, 2, 2, 2, 3598, 3600, 7, 296, 2, 2, 3599, 3601, 5, 540,
	271, 2, 3600, 3599, 3, 2, 2, 2, 3600, 3601, 3, 2, 2, 2, 3601, 3602, 3,
	2, 2, 2, 3602, 3603, 5, 482, 242, 2, 3603, 3604, 7, 344, 2, 2, 3604, 3605,
	7, 296, 2, 2, 3605, 3607, 5, 484, 243, 2, 3606, 3608, 5, 544, 273, 2, 3607,
	3606, 3, 2, 2, 2, 3607, 3608, 3, 2, 2, 2, 3608, 3609, 3, 2, 2, 2, 3609,
	3610, 7, 332, 2, 2, 3610, 3611, 5, 538, 270, 2, 3611, 3612, 7, 297, 2,
	2, 3612, 3613, 7, 297, 2, 2, 3613, 537, 3, 2, 2, 2, 3614, 3615, 5, 578,
	290, 2, 3615, 539, 3, 2, 2, 2, 3616, 3617, 9, 23, 2, 2, 3617, 541, 3, 2,
	2, 2, 3618, 3619, 7, 44, 2, 2, 3619, 3620, 7, 296, 2, 2, 3620, 3621, 5,
	584, 293, 2, 3621, 3622, 7, 297, 2, 2, 3622, 3623, 5, 476, 239, 2, 3623,
	3633, 3, 2, 2, 2, 3624, 3625, 7, 44, 2, 2, 3625, 3626, 7, 296, 2, 2, 3626,
	3627, 5, 584, 293, 2, 3627, 3628, 7, 297, 2, 2, 3628, 3629, 5, 532, 267,
	2, 3629, 3633, 3, 2, 2, 2, 3630, 3631, 7, 45, 2, 2, 3631, 3633, 5, 476,
	239, 2, 3632, 3618, 3, 2, 2, 2, 3632, 3624, 3, 2, 2, 2, 3632, 3630, 3,
	2, 2, 2, 3633, 543, 3, 2, 2, 2, 3634, 3635, 9, 24, 2, 2, 3635, 545, 3,
	2, 2, 2, 3636, 3637, 7, 300, 2, 2, 3637, 3642, 5, 578, 290, 2, 3638, 3639,
	7, 331, 2, 2, 3639, 3641, 5, 578, 290, 2, 3640, 3638, 3, 2, 2, 2, 3641,
	3644, 3, 2, 2, 2, 3642, 3640, 3, 2, 2, 2, 3642, 3643, 3, 2, 2, 2, 3643,
	3645, 3, 2, 2, 2, 3644, 3642, 3, 2, 2, 2, 3645, 3646, 7, 301, 2, 2, 3646,
	547, 3, 2, 2, 2, 3647, 3648, 7, 300, 2, 2, 3648, 3653, 5, 570, 286, 2,
	3649, 3650, 7, 331, 2, 2, 3650, 3652, 5, 570, 286, 2, 3651, 3649, 3, 2,
	2, 2, 3652, 3655, 3, 2, 2, 2, 3653, 3651, 3, 2, 2, 2, 3653, 3654, 3, 2,
	2, 2, 3654, 3656, 3, 2, 2, 2, 3655, 3653, 3, 2, 2, 2, 3656, 3657, 7, 301,
	2, 2, 3657, 549, 3, 2, 2, 2, 3658, 3659, 7, 300, 2, 2, 3659, 3660, 5, 570,
	286, 2, 3660, 3661, 5, 548, 275, 2, 3661, 3662, 7, 301, 2, 2, 3662, 551,
	3, 2, 2, 2, 3663, 3664, 7, 300, 2, 2, 3664, 3669, 5, 584, 293, 2, 3665,
	3666, 7, 331, 2, 2, 3666, 3668, 5, 584, 293, 2, 3667, 3665, 3, 2, 2, 2,
	3668, 3671, 3, 2, 2, 2, 3669, 3667, 3, 2, 2, 2, 3669, 3670, 3, 2, 2, 2,
	3670, 3672, 3, 2, 2, 2, 3671, 3669, 3, 2, 2, 2, 3672, 3673, 7, 301, 2,
	2, 3673, 553, 3, 2, 2, 2, 3674, 3675, 7, 300, 2, 2, 3675, 3676, 5, 570,
	286, 2, 3676, 3677, 5, 552, 277, 2, 3677, 3678, 7, 301, 2, 2, 3678, 555,
	3, 2, 2, 2, 3679, 3680, 7, 300, 2, 2, 3680, 3681, 5, 570, 286, 2, 3681,
	3682, 5, 546, 274, 2, 3682, 3683, 7, 301, 2, 2, 3683, 557, 3, 2, 2, 2,
	3684, 3688, 5, 628, 315, 2, 3685, 3687, 5, 614, 308, 2, 3686, 3685, 3,
	2, 2, 2, 3687, 3690, 3, 2, 2, 2, 3688, 3686, 3, 2, 2, 2, 3688, 3689, 3,
	2, 2, 2, 3689, 3691, 3, 2, 2, 2, 3690, 3688, 3, 2, 2, 2, 3691, 3692, 7,
	296, 2, 2, 3692, 3697, 5, 570, 286, 2, 3693, 3694, 7, 331, 2, 2, 3694,
	3696, 5, 570, 286, 2, 3695, 3693, 3, 2, 2, 2, 3696, 3699, 3, 2, 2, 2, 3697,
	3695, 3, 2, 2, 2, 3697, 3698, 3, 2, 2, 2, 3698, 3700, 3, 2, 2, 2, 3699,
	3697, 3, 2, 2, 2, 3700, 3701, 7, 297, 2, 2, 3701, 559, 3, 2, 2, 2, 3702,
	3703, 5, 678, 340, 2, 3703, 3704, 7, 296, 2, 2, 3704, 3709, 5, 570, 286,
	2, 3705, 3706, 7, 331, 2, 2, 3706, 3708, 5, 570, 286, 2, 3707, 3705, 3,
	2, 2, 2, 3708, 3711, 3, 2, 2, 2, 3709, 3707, 3, 2, 2, 2, 3709, 3710, 3,
	2, 2, 2, 3710, 3712, 3, 2, 2, 2, 3711, 3709, 3, 2, 2, 2, 3712, 3713, 7,
	297, 2, 2, 3713, 561, 3, 2, 2, 2, 3714, 3718, 5, 640, 321, 2, 3715, 3717,
	5, 614, 308, 2, 3716, 3715, 3, 2, 2, 2, 3717, 3720, 3, 2, 2, 2, 3718, 3716,
	3, 2, 2, 2, 3718, 3719, 3, 2, 2, 2, 3719, 3721, 3, 2, 2, 2, 3720, 3718,
	3, 2, 2, 2, 3721, 3722, 7, 296, 2, 2, 3722, 3727, 5, 578, 290, 2, 3723,
	3724, 7, 331, 2, 2, 3724, 3726, 5, 578, 290, 2, 3725, 3723, 3, 2, 2, 2,
	3726, 3729, 3, 2, 2, 2, 3727, 3725, 3, 2, 2, 2, 3727, 3728, 3, 2, 2, 2,
	3728, 3730, 3, 2, 2, 2, 3729, 3727, 3, 2, 2, 2, 3730, 3731, 7, 297, 2,
	2, 3731, 563, 3, 2, 2, 2, 3732, 3744, 5, 678, 340, 2, 3733, 3734, 7, 296,
	2, 2, 3734, 3739, 5, 578, 290, 2, 3735, 3736, 7, 331, 2, 2, 3736, 3738,
	5, 578, 290, 2, 3737, 3735, 3, 2, 2, 2, 3738, 3741, 3, 2, 2, 2, 3739, 3737,
	3, 2, 2, 2, 3739, 3740, 3, 2, 2, 2, 3740, 3742, 3, 2, 2, 2, 3741, 3739,
	3, 2, 2, 2, 3742, 3743, 7, 297, 2, 2, 3743, 3745, 3, 2, 2, 2, 3744, 3733,
	3, 2, 2, 2, 3744, 3745, 3, 2, 2, 2, 3745, 565, 3, 2, 2, 2, 3746, 3747,
	5, 578, 290, 2, 3747, 567, 3, 2, 2, 2, 3748, 3749, 5, 570, 286, 2, 3749,
	569, 3, 2, 2, 2, 3750, 3751, 8, 286, 1, 2, 3751, 3762, 5, 594, 298, 2,
	3752, 3756, 5, 604, 303, 2, 3753, 3755, 5, 614, 308, 2, 3754, 3753, 3,
	2, 2, 2, 3755, 3758, 3, 2, 2, 2, 3756, 3754, 3, 2, 2, 2, 3756, 3757, 3,
	2, 2, 2, 3757, 3759, 3, 2, 2, 2, 3758, 3756, 3, 2, 2, 2, 3759, 3760, 5,
	594, 298, 2, 3760, 3762, 3, 2, 2, 2, 3761, 3750, 3, 2, 2, 2, 3761, 3752,
	3, 2, 2, 2, 3762, 3787, 3, 2, 2, 2, 3763, 3764, 12, 4, 2, 2, 3764, 3768,
	5, 606, 304, 2, 3765, 3767, 5, 614, 308, 2, 3766, 3765, 3, 2, 2, 2, 3767,
	3770, 3, 2, 2, 2, 3768, 3766, 3, 2, 2, 2, 3768, 3769, 3, 2, 2, 2, 3769,
	3771, 3, 2, 2, 2, 3770, 3768, 3, 2, 2, 2, 3771, 3772, 5, 570, 286, 5, 3772,
	3786, 3, 2, 2, 2, 3773, 3774, 12, 3, 2, 2, 3774, 3778, 7, 336, 2, 2, 3775,
	3777, 5, 614, 308, 2, 3776, 3775, 3, 2, 2, 2, 3777, 3780, 3, 2, 2, 2, 3778,
	3776, 3, 2, 2, 2, 3778, 3779, 3, 2, 2, 2, 3779, 3781, 3, 2, 2, 2, 3780,
	3778, 3, 2, 2, 2, 3781, 3782, 5, 570, 286, 2, 3782, 3783, 7, 332, 2, 2,
	3783, 3784, 5, 570, 286, 4, 3784, 3786, 3, 2, 2, 2, 3785, 3763, 3, 2, 2,
	2, 3785, 3773, 3, 2, 2, 2, 3786, 3789, 3, 2, 2, 2, 3787, 3785, 3, 2, 2,
	2, 3787, 3788, 3, 2, 2, 2, 3788, 571, 3, 2, 2, 2, 3789, 3787, 3, 2, 2,
	2, 3790, 3798, 5, 570, 286, 2, 3791, 3792, 5, 570, 286, 2, 3792, 3793,
	7, 332, 2, 2, 3793, 3794, 5, 570, 286, 2, 3794, 3795, 7, 332, 2, 2, 3795,
	3796, 5, 570, 286, 2, 3796, 3798, 3, 2, 2, 2, 3797, 3790, 3, 2, 2, 2, 3797,
	3791, 3, 2, 2, 2, 3798, 573, 3, 2, 2, 2, 3799, 3813, 5, 570, 286, 2, 3800,
	3801, 5, 588, 295, 2, 3801, 3802, 7, 332, 2, 2, 3802, 3803, 5, 580, 291,
	2, 3803, 3813, 3, 2, 2, 2, 3804, 3805, 5, 568, 285, 2, 3805, 3806, 7, 340,
	2, 2, 3806, 3807, 5, 592, 297, 2, 3807, 3813, 3, 2, 2, 2, 3808, 3809, 5,
	568, 285, 2, 3809, 3810, 7, 341, 2, 2, 3810, 3811, 5, 592, 297, 2, 3811,
	3813, 3, 2, 2, 2, 3812, 3799, 3, 2, 2, 2, 3812, 3800, 3, 2, 2, 2, 3812,
	3804, 3, 2, 2, 2, 3812, 3808, 3, 2, 2, 2, 3813, 575, 3, 2, 2, 2, 3814,
	3815, 5, 570, 286, 2, 3815, 577, 3, 2, 2, 2, 3816, 3817, 8, 290, 1, 2,
	3817, 3828, 5, 598, 300, 2, 3818, 3822, 5, 604, 303, 2, 3819, 3821, 5,
	614, 308, 2, 3820, 3819, 3, 2, 2, 2, 3821, 3824, 3, 2, 2, 2, 3822, 3820,
	3, 2, 2, 2, 3822, 3823, 3, 2, 2, 2, 3823, 3825, 3, 2, 2, 2, 3824, 3822,
	3, 2, 2, 2, 3825, 3826, 5, 598, 300, 2, 3826, 3828, 3, 2, 2, 2, 3827, 3816,
	3, 2, 2, 2, 3827, 3818, 3, 2, 2, 2, 3828, 3853, 3, 2, 2, 2, 3829, 3830,
	12, 4, 2, 2, 3830, 3834, 5, 606, 304, 2, 3831, 3833, 5, 614, 308, 2, 3832,
	3831, 3, 2, 2, 2, 3833, 3836, 3, 2, 2, 2, 3834, 3832, 3, 2, 2, 2, 3834,
	3835, 3, 2, 2, 2, 3835, 3837, 3, 2, 2, 2, 3836, 3834, 3, 2, 2, 2, 3837,
	3838, 5, 578, 290, 5, 3838, 3852, 3, 2, 2, 2, 3839, 3840, 12, 3, 2, 2,
	3840, 3844, 7, 336, 2, 2, 3841, 3843, 5, 614, 308, 2, 3842, 3841, 3, 2,
	2, 2, 3843, 3846, 3, 2, 2, 2, 3844, 3842, 3, 2, 2, 2, 3844, 3845, 3, 2,
	2, 2, 3845, 3847, 3, 2, 2, 2, 3846, 3844, 3, 2, 2, 2, 3847, 3848, 5, 578,
	290, 2, 3848, 3849, 7, 332, 2, 2, 3849, 3850, 5, 578, 290, 4, 3850, 3852,
	3, 2, 2, 2, 3851, 3829, 3, 2, 2, 2, 3851, 3839, 3, 2, 2, 2, 3852, 3855,
	3, 2, 2, 2, 3853, 3851, 3, 2, 2, 2, 3853, 3854, 3, 2, 2, 2, 3854, 579,
	3, 2, 2, 2, 3855, 3853, 3, 2, 2, 2, 3856, 3857, 5, 570, 286, 2, 3857, 581,
	3, 2, 2, 2, 3858, 3866, 5, 578, 290, 2, 3859, 3860, 5, 578, 290, 2, 3860,
	3861, 7, 332, 2, 2, 3861, 3862, 5, 578, 290, 2, 3862, 3863, 7, 332, 2,
	2, 3863, 3864, 5, 578, 290, 2, 3864, 3866, 3, 2, 2, 2, 3865, 3858, 3, 2,
	2, 2, 3865, 3859, 3, 2, 2, 2, 3866, 583, 3, 2, 2, 2, 3867, 3868, 8, 293,
	1, 2, 3868, 3879, 5, 596, 299, 2, 3869, 3873, 5, 608, 305, 2, 3870, 3872,
	5, 614, 308, 2, 3871, 3870, 3, 2, 2, 2, 3872, 3875, 3, 2, 2, 2, 3873, 3871,
	3, 2, 2, 2, 3873, 3874, 3, 2, 2, 2, 3874, 3876, 3, 2, 2, 2, 3875, 3873,
	3, 2, 2, 2, 3876, 3877, 5, 596, 299, 2, 3877, 3879, 3, 2, 2, 2, 3878, 3867,
	3, 2, 2, 2, 3878, 3869, 3, 2, 2, 2, 3879, 3904, 3, 2, 2, 2, 3880, 3881,
	12, 4, 2, 2, 3881, 3885, 5, 610, 306, 2, 3882, 3884, 5, 614, 308, 2, 3883,
	3882, 3, 2, 2, 2, 3884, 3887, 3, 2, 2, 2, 3885, 3883, 3, 2, 2, 2, 3885,
	3886, 3, 2, 2, 2, 3886, 3888, 3, 2, 2, 2, 3887, 3885, 3, 2, 2, 2, 3888,
	3889, 5, 584, 293, 5, 3889, 3903, 3, 2, 2, 2, 3890, 3891, 12, 3, 2, 2,
	3891, 3895, 7, 336, 2, 2, 3892, 3894, 5, 614, 308, 2, 3893, 3892, 3, 2,
	2, 2, 3894, 3897, 3, 2, 2, 2, 3895, 3893, 3, 2, 2, 2, 3895, 3896, 3, 2,
	2, 2, 3896, 3898, 3, 2, 2, 2, 3897, 3895, 3, 2, 2, 2, 3898, 3899, 5, 584,
	293, 2, 3899, 3900, 7, 332, 2, 2, 3900, 3901, 5, 584, 293, 4, 3901, 3903,
	3, 2, 2, 2, 3902, 3880, 3, 2, 2, 2, 3902, 3890, 3, 2, 2, 2, 3903, 3906,
	3, 2, 2, 2, 3904, 3902, 3, 2, 2, 2, 3904, 3905, 3, 2, 2, 2, 3905, 585,
	3, 2, 2, 2, 3906, 3904, 3, 2, 2, 2, 3907, 3915, 5, 584, 293, 2, 3908, 3909,
	5, 584, 293, 2, 3909, 3910, 7, 332, 2, 2, 3910, 3911, 5, 584, 293, 2, 3911,
	3912, 7, 332, 2, 2, 3912, 3913, 5, 584, 293, 2, 3913, 3915, 3, 2, 2, 2,
	3914, 3907, 3, 2, 2, 2, 3914, 3908, 3, 2, 2, 2, 3915, 587, 3, 2, 2, 2,
	3916, 3917, 5, 570, 286, 2, 3917, 589, 3, 2, 2, 2, 3918, 3932, 5, 578,
	290, 2, 3919, 3920, 5, 588, 295, 2, 3920, 3921, 7, 332, 2, 2, 3921, 3922,
	5, 580, 291, 2, 3922, 3932, 3, 2, 2, 2, 3923, 3924, 5, 566, 284, 2, 3924,
	3925, 7, 340, 2, 2, 3925, 3926, 5, 592, 297, 2, 3926, 3932, 3, 2, 2, 2,
	3927, 3928, 5, 566, 284, 2, 3928, 3929, 7, 341, 2, 2, 3929, 3930, 5, 592,
	297, 2, 3930, 3932, 3, 2, 2, 2, 3931, 3918, 3, 2, 2, 2, 3931, 3919, 3,
	2, 2, 2, 3931, 3923, 3, 2, 2, 2, 3931, 3927, 3, 2, 2, 2, 3932, 591, 3,
	2, 2, 2, 3933, 3934, 5, 570, 286, 2, 3934, 593, 3, 2, 2, 2, 3935, 3964,
	5, 612, 307, 2, 3936, 3941, 5, 670, 336, 2, 3937, 3938, 7, 298, 2, 2, 3938,
	3939, 5, 574, 288, 2, 3939, 3940, 7, 299, 2, 2, 3940, 3942, 3, 2, 2, 2,
	3941, 3937, 3, 2, 2, 2, 3941, 3942, 3, 2, 2, 2, 3942, 3964, 3, 2, 2, 2,
	3943, 3948, 5, 676, 339, 2, 3944, 3945, 7, 298, 2, 2, 3945, 3946, 5, 574,
	288, 2, 3946, 3947, 7, 299, 2, 2, 3947, 3949, 3, 2, 2, 2, 3948, 3944, 3,
	2, 2, 2, 3948, 3949, 3, 2, 2, 2, 3949, 3964, 3, 2, 2, 2, 3950, 3964, 5,
	548, 275, 2, 3951, 3964, 5, 550, 276, 2, 3952, 3964, 5, 558, 280, 2, 3953,
	3964, 5, 560, 281, 2, 3954, 3955, 7, 296, 2, 2, 3955, 3956, 5, 572, 287,
	2, 3956, 3957, 7, 297, 2, 2, 3957, 3964, 3, 2, 2, 2, 3958, 3964, 7, 289,
	2, 2, 3959, 3964, 5, 56, 29, 2, 3960, 3964, 5, 62, 32, 2, 3961, 3964, 5,
	66, 34, 2, 3962, 3964, 5, 80, 41, 2, 3963, 3935, 3, 2, 2, 2, 3963, 3936,
	3, 2, 2, 2, 3963, 3943, 3, 2, 2, 2, 3963, 3950, 3, 2, 2, 2, 3963, 3951,
	3, 2, 2, 2, 3963, 3952, 3, 2, 2, 2, 3963, 3953, 3, 2, 2, 2, 3963, 3954,
	3, 2, 2, 2, 3963, 3958, 3, 2, 2, 2, 3963, 3959, 3, 2, 2, 2, 3963, 3960,
	3, 2, 2, 2, 3963, 3961, 3, 2, 2, 2, 3963, 3962, 3, 2, 2, 2, 3964, 595,
	3, 2, 2, 2, 3965, 3976, 5, 612, 307, 2, 3966, 3976, 5, 652, 327, 2, 3967,
	3976, 5, 552, 277, 2, 3968, 3976, 5, 554, 278, 2, 3969, 3976, 5, 562, 282,
	2, 3970, 3976, 5, 564, 283, 2, 3971, 3972, 7, 296, 2, 2, 3972, 3973, 5,
	586, 294, 2, 3973, 3974, 7, 297, 2, 2, 3974, 3976, 3, 2, 2, 2, 3975, 3965,
	3, 2, 2, 2, 3975, 3966, 3, 2, 2, 2, 3975, 3967, 3, 2, 2, 2, 3975, 3968,
	3, 2, 2, 2, 3975, 3969, 3, 2, 2, 2, 3975, 3970, 3, 2, 2, 2, 3975, 3971,
	3, 2, 2, 2, 3976, 597, 3, 2, 2, 2, 3977, 4008, 5, 612, 307, 2, 3978, 3992,
	5, 642, 322, 2, 3979, 3980, 7, 298, 2, 2, 3980, 3981, 5, 578, 290, 2, 3981,
	3982, 7, 299, 2, 2, 3982, 3984, 3, 2, 2, 2, 3983, 3979, 3, 2, 2, 2, 3984,
	3987, 3, 2, 2, 2, 3985, 3983, 3, 2, 2, 2, 3985, 3986, 3, 2, 2, 2, 3986,
	3988, 3, 2, 2, 2, 3987, 3985, 3, 2, 2, 2, 3988, 3989, 7, 298, 2, 2, 3989,
	3990, 5, 590, 296, 2, 3990, 3991, 7, 299, 2, 2, 3991, 3993, 3, 2, 2, 2,
	3992, 3985, 3, 2, 2, 2, 3992, 3993, 3, 2, 2, 2, 3993, 4008, 3, 2, 2, 2,
	3994, 4008, 5, 546, 274, 2, 3995, 4008, 5, 556, 279, 2, 3996, 4008, 5,
	562, 282, 2, 3997, 4008, 5, 564, 283, 2, 3998, 3999, 7, 296, 2, 2, 3999,
	4000, 5, 582, 292, 2, 4000, 4001, 7, 297, 2, 2, 4001, 4008, 3, 2, 2, 2,
	4002, 4008, 7, 289, 2, 2, 4003, 4008, 5, 56, 29, 2, 4004, 4008, 5, 62,
	32, 2, 4005, 4008, 5, 66, 34, 2, 4006, 4008, 5, 80, 41, 2, 4007, 3977,
	3, 2, 2, 2, 4007, 3978, 3, 2, 2, 2, 4007, 3994, 3, 2, 2, 2, 4007, 3995,
	3, 2, 2, 2, 4007, 3996, 3, 2, 2, 2, 4007, 3997, 3, 2, 2, 2, 4007, 3998,
	3, 2, 2, 2, 4007, 4002, 3, 2, 2, 2, 4007, 4003, 3, 2, 2, 2, 4007, 4004,
	3, 2, 2, 2, 4007, 4005, 3, 2, 2, 2, 4007, 4006, 3, 2, 2, 2, 4008, 599,
	3, 2, 2, 2, 4009, 4023, 5, 644, 323, 2, 4010, 4011, 7, 298, 2, 2, 4011,
	4012, 5, 570, 286, 2, 4012, 4013, 7, 299, 2, 2, 4013, 4015, 3, 2, 2, 2,
	4014, 4010, 3, 2, 2, 2, 4015, 4018, 3, 2, 2, 2, 4016, 4014, 3, 2, 2, 2,
	4016, 4017, 3, 2, 2, 2, 4017, 4019, 3, 2, 2, 2, 4018, 4016, 3, 2, 2, 2,
	4019, 4020, 7, 298, 2, 2, 4020, 4021, 5, 574, 288, 2, 4021, 4022, 7, 299,
	2, 2, 4022, 4024, 3, 2, 2, 2, 4023, 4016, 3, 2, 2, 2, 4023, 4024, 3, 2,
	2, 2, 4024, 4037, 3, 2, 2, 2, 4025, 4026, 7, 300, 2, 2, 4026, 4031, 5,
	600, 301, 2, 4027, 4028, 7, 331, 2, 2, 4028, 4030, 5, 600, 301, 2, 4029,
	4027, 3, 2, 2, 2, 4030, 4033, 3, 2, 2, 2, 4031, 4029, 3, 2, 2, 2, 4031,
	4032, 3, 2, 2, 2, 4032, 4034, 3, 2, 2, 2, 4033, 4031, 3, 2, 2, 2, 4034,
	4035, 7, 301, 2, 2, 4035, 4037, 3, 2, 2, 2, 4036, 4009, 3, 2, 2, 2, 4036,
	4025, 3, 2, 2, 2, 4037, 601, 3, 2, 2, 2, 4038, 4052, 5, 648, 325, 2, 4039,
	4040, 7, 298, 2, 2, 4040, 4041, 5, 578, 290, 2, 4041, 4042, 7, 299, 2,
	2, 4042, 4044, 3, 2, 2, 2, 4043, 4039, 3, 2, 2, 2, 4044, 4047, 3, 2, 2,
	2, 4045, 4043, 3, 2, 2, 2, 4045, 4046, 3, 2, 2, 2, 4046, 4048, 3, 2, 2,
	2, 4047, 4045, 3, 2, 2, 2, 4048, 4049, 7, 298, 2, 2, 4049, 4050, 5, 590,
	296, 2, 4050, 4051, 7, 299, 2, 2, 4051, 4053, 3, 2, 2, 2, 4052, 4045, 3,
	2, 2, 2, 4052, 4053, 3, 2, 2, 2, 4053, 4066, 3, 2, 2, 2, 4054, 4055, 7,
	300, 2, 2, 4055, 4060, 5, 602, 302, 2, 4056, 4057, 7, 331, 2, 2, 4057,
	4059, 5, 602, 302, 2, 4058, 4056, 3, 2, 2, 2, 4059, 4062, 3, 2, 2, 2, 4060,
	4058, 3, 2, 2, 2, 4060, 4061, 3, 2, 2, 2, 4061, 4063, 3, 2, 2, 2, 4062,
	4060, 3, 2, 2, 2, 4063, 4064, 7, 301, 2, 2, 4064, 4066, 3, 2, 2, 2, 4065,
	4038, 3, 2, 2, 2, 4065, 4054, 3, 2, 2, 2, 4066, 603, 3, 2, 2, 2, 4067,
	4068, 9, 25, 2, 2, 4068, 605, 3, 2, 2, 2, 4069, 4070, 9, 26, 2, 2, 4070,
	607, 3, 2, 2, 2, 4071, 4072, 9, 27, 2, 2, 4072, 609, 3, 2, 2, 2, 4073,
	4074, 9, 28, 2, 2, 4074, 611, 3, 2, 2, 2, 4075, 4076, 9, 29, 2, 2, 4076,
	613, 3, 2, 2, 2, 4077, 4078, 7, 296, 2, 2, 4078, 4079, 7, 313, 2, 2, 4079,
	4084, 5, 616, 309, 2, 4080, 4081, 7, 331, 2, 2, 4081, 4083, 5, 616, 309,
	2, 4082, 4080, 3, 2, 2, 2, 4083, 4086, 3, 2, 2, 2, 4084, 4082, 3, 2, 2,
	2, 4084, 4085, 3, 2, 2, 2, 4085, 4087, 3, 2, 2, 2, 4086, 4084, 3, 2, 2,
	2, 4087, 4088, 7, 313, 2, 2, 4088, 4089, 7, 297, 2, 2, 4089, 615, 3, 2,
	2, 2, 4090, 4093, 5, 618, 310, 2, 4091, 4092, 7, 335, 2, 2, 4092, 4094,
	5, 570, 286, 2, 4093, 4091, 3, 2, 2, 2, 4093, 4094, 3, 2, 2, 2, 4094, 617,
	3, 2, 2, 2, 4095, 4096, 5, 652, 327, 2, 4096, 619, 3, 2, 2, 2, 4097, 4098,
	5, 652, 327, 2, 4098, 621, 3, 2, 2, 2, 4099, 4100, 5, 652, 327, 2, 4100,
	623, 3, 2, 2, 2, 4101, 4102, 5, 652, 327, 2, 4102, 625, 3, 2, 2, 2, 4103,
	4104, 5, 652, 327, 2, 4104, 627, 3, 2, 2, 2, 4105, 4106, 5, 652, 327, 2,
	4106, 629, 3, 2, 2, 2, 4107, 4108, 5, 652, 327, 2, 4108, 631, 3, 2, 2,
	2, 4109, 4110, 5, 652, 327, 2, 4110, 633, 3, 2, 2, 2, 4111, 4112, 5, 652,
	327, 2, 4112, 635, 3, 2, 2, 2, 4113, 4114, 5, 642, 322, 2, 4114, 637, 3,
	2, 2, 2, 4115, 4116, 5, 642, 322, 2, 4116, 639, 3, 2, 2, 2, 4117, 4118,
	5, 642, 322, 2, 4118, 641, 3, 2, 2, 2, 4119, 4124, 5, 652, 327, 2, 4120,
	4121, 7, 298, 2, 2, 4121, 4122, 5, 570, 286, 2, 4122, 4123, 7, 299, 2,
	2, 4123, 4125, 3, 2, 2, 2, 4124, 4120, 3, 2, 2, 2, 4124, 4125, 3, 2, 2,
	2, 4125, 4126, 3, 2, 2, 2, 4126, 4127, 7, 330, 2, 2, 4127, 4129, 3, 2,
	2, 2, 4128, 4119, 3, 2, 2, 2, 4129, 4132, 3, 2, 2, 2, 4130, 4128, 3, 2,
	2, 2, 4130, 4131, 3, 2, 2, 2, 4131, 4133, 3, 2, 2, 2, 4132, 4130, 3, 2,
	2, 2, 4133, 4134, 5, 652, 327, 2, 4134, 643, 3, 2, 2, 2, 4135, 4136, 5,
	642, 322, 2, 4136, 645, 3, 2, 2, 2, 4137, 4138, 5, 642, 322, 2, 4138, 647,
	3, 2, 2, 2, 4139, 4140, 5, 642, 322, 2, 4140, 649, 3, 2, 2, 2, 4141, 4142,
	5, 642, 322, 2, 4142, 651, 3, 2, 2, 2, 4143, 4144, 9, 30, 2, 2, 4144, 653,
	3, 2, 2, 2, 4145, 4146, 5, 652, 327, 2, 4146, 655, 3, 2, 2, 2, 4147, 4148,
	5, 652, 327, 2, 4148, 657, 3, 2, 2, 2, 4149, 4150, 5, 652, 327, 2, 4150,
	659, 3, 2, 2, 2, 4151, 4152, 5, 652, 327, 2, 4152, 661, 3, 2, 2, 2, 4153,
	4154, 5, 652, 327, 2, 4154, 663, 3, 2, 2, 2, 4155, 4156, 5, 652, 327, 2,
	4156, 665, 3, 2, 2, 2, 4157, 4158, 5, 652, 327, 2, 4158, 667, 3, 2, 2,
	2, 4159, 4160, 5, 652, 327, 2, 4160, 669, 3, 2, 2, 2, 4161, 4162, 5, 652,
	327, 2, 4162, 671, 3, 2, 2, 2, 4163, 4164, 5, 652, 327, 2, 4164, 673, 3,
	2, 2, 2, 4165, 4166, 5, 652, 327, 2, 4166, 675, 3, 2, 2, 2, 4167, 4168,
	5, 652, 327, 2, 4168, 677, 3, 2, 2, 2, 4169, 4170, 7, 294, 2, 2, 4170,
	679, 3, 2, 2, 2, 4171, 4172, 7, 294, 2, 2, 4172, 681, 3, 2, 2, 2, 4173,
	4174, 5, 652, 327, 2, 4174, 683, 3, 2, 2, 2, 4175, 4176, 5, 652, 327, 2,
	4176, 685, 3, 2, 2, 2, 4177, 4178, 5, 652, 327, 2, 4178, 687, 3, 2, 2,
	2, 4179, 4180, 5, 652, 327, 2, 4180, 689, 3, 2, 2, 2, 4181, 4182, 5, 652,
	327, 2, 4182, 691, 3, 2, 2, 2, 4183, 4184, 5, 652, 327, 2, 4184, 693, 3,
	2, 2, 2, 418, 699, 706, 712, 720, 727, 738, 746, 768, 782, 792, 799, 809,
	814, 827, 829, 843, 845, 850, 860, 867, 878, 902, 961, 977, 996, 1015,
	1020, 1027, 1032, 1069, 1075, 1112, 1118, 1127, 1136, 1139, 1150, 1157,
	1162, 1168, 1175, 1183, 1189, 1192, 1198, 1203, 1214, 1225, 1236, 1243,
	1246, 1252, 1256, 1265, 1270, 1277, 1282, 1289, 1296, 1300, 1306, 1311,
	1318, 1327, 1334, 1341, 1348, 1355, 1362, 1369, 1376, 1380, 1392, 1400,
	1409, 1413, 1426, 1435, 1440, 1460, 1472, 1479, 1487, 1494, 1499, 1503,
	1506, 1513, 1517, 1520, 1527, 1531, 1540, 1543, 1546, 1552, 1555, 1558,
	1564, 1567, 1570, 1576, 1579, 1586, 1598, 1601, 1608, 1611, 1614, 1621,
	1624, 1628, 1635, 1638, 1641, 1645, 1652, 1655, 1658, 1665, 1668, 1671,
	1678, 1681, 1684, 1688, 1695, 1698, 1701, 1705, 1710, 1722, 1725, 1742,
	1749, 1755, 1762, 1800, 1815, 1826, 1828, 1832, 1841, 1845, 1850, 1857,
	1864, 1872, 1877, 1885, 1892, 1900, 1905, 1913, 1921, 1929, 1937, 1945,
	1951, 1957, 1961, 1981, 1989, 2002, 2006, 2028, 2031, 2039, 2047, 2050,
	2060, 2066, 2072, 2078, 2083, 2091, 2097, 2101, 2108, 2112, 2119, 2127,
	2132, 2139, 2145, 2151, 2160, 2169, 2175, 2182, 2188, 2195, 2202, 2206,
	2210, 2213, 2216, 2223, 2227, 2230, 2233, 2240, 2244, 2247, 2250, 2257,
	2264, 2269, 2272, 2280, 2290, 2300, 2310, 2320, 2327, 2336, 2342, 2349,
	2357, 2364, 2371, 2376, 2383, 2390, 2393, 2400, 2407, 2414, 2421, 2424,
	2431, 2438, 2441, 2448, 2455, 2462, 2473, 2480, 2487, 2494, 2501, 2506,
	2509, 2522, 2533, 2544, 2554, 2560, 2568, 2576, 2585, 2596, 2604, 2622,
	2640, 2670, 2677, 2692, 2700, 2703, 2711, 2722, 2729, 2737, 2740, 2745,
	2749, 2754, 2761, 2769, 2783, 2806, 2811, 2818, 2828, 2835, 2837, 2846,
	2850, 2859, 2866, 2874, 2877, 2883, 2888, 2892, 2896, 2900, 2903, 2913,
	2929, 2936, 2952, 2964, 2967, 2972, 2983, 2986, 2991, 2999, 3008, 3015,
	3022, 3029, 3036, 3043, 3052, 3059, 3068, 3075, 3082, 3089, 3096, 3122,
	3128, 3132, 3143, 3153, 3163, 3178, 3185, 3196, 3204, 3206, 3214, 3218,
	3243, 3248, 3258, 3271, 3284, 3289, 3296, 3304, 3307, 3333, 3338, 3342,
	3346, 3350, 3361, 3366, 3374, 3383, 3393, 3403, 3414, 3424, 3429, 3438,
	3449, 3457, 3465, 3472, 3476, 3480, 3487, 3536, 3580, 3584, 3591, 3600,
	3607, 3632, 3642, 3653, 3669, 3688, 3697, 3709, 3718, 3727, 3739, 3744,
	3756, 3761, 3768, 3778, 3785, 3787, 3797, 3812, 3822, 3827, 3834, 3844,
	3851, 3853, 3865, 3873, 3878, 3885, 3895, 3902, 3904, 3914, 3931, 3941,
	3948, 3963, 3975, 3985, 3992, 4007, 4016, 4023, 4031, 4036, 4045, 4052,
	4060, 4065, 4084, 4093, 4124, 4130,
}
var literalNames = []string{
	"", "'always'", "'and'", "'assign'", "'automatic'", "'begin'", "'buf'",
	"'bufif0'", "'bufif1'", "'case'", "'casex'", "'casez'", "'cell'", "'cmos'",
	"'config'", "'deassign'", "'default'", "'defparam'", "'design'", "'disable'",
	"'edge'", "'else'", "'end'", "'endcase'", "'endconfig'", "'endfunction'",
	"'endgenerate'", "'endmodule'", "'endprimitive'", "'endspecify'", "'endtable'",
	"'endtask'", "'event'", "'for'", "'force'", "'forever'", "'fork'", "'function'",
	"'generate'", "'genvar'", "'highz0'", "'highz1'", "'if'", "'ifnone'", "'incdir'",
	"", "'initial'", "'inout'", "'input'", "'instance'", "'integer'", "'join'",
	"'large'", "'liblist'", "'library'", "'localparam'", "'macromodule'", "'medium'",
	"'module'", "'nand'", "'negedge'", "'nmos'", "'nor'", "'noshowcancelled'",
	"'not'", "'notif0'", "'notif1'", "'or'", "'output'", "'parameter'", "'pmos'",
	"'posedge'", "'primitive'", "'pull0'", "'pull1'", "'pulldown'", "'pullup'",
	"'pulsestyle_onevent'", "'pulsestyle_ondetect'", "'rcmos'", "'real'", "'realtime'",
	"'reg'", "'release'", "'repeat'", "'rnmos'", "'rpmos'", "'rtran'", "'rtranif0'",
	"'rtranif1'", "'scalared'", "'showcancelled'", "'signed'", "'small'", "'specify'",
	"'specparam'", "'strong0'", "'strong1'", "'supply0'", "'supply1'", "'table'",
	"'task'", "'time'", "'tran'", "'tranif0'", "'tranif1'", "'tri'", "'tri0'",
	"'tri1'", "'triand'", "'trior'", "'trireg'", "'unsigned'", "'use'", "'uwire'",
	"'vectored'", "'wait'", "'wand'", "'weak0'", "'weak1'", "'while'", "'wire'",
	"'wor'", "'xnor'", "'xor'", "'$display'", "'$displayb'", "'$displayh'",
	"'$displayo'", "'$write'", "'$writeb'", "'$writeh'", "'$writeo'", "'$strobe'",
	"'$strobeb'", "'$strobeh'", "'$strobeo'", "'$monitor'", "'$monitorb'",
	"'$monitorh'", "'$monitoro'", "'$monitoroff'", "'$monitoron'", "'$fclose'",
	"'$fdisplay'", "'$fdisplayb'", "'$fdisplayh'", "'$fdisplayo'", "'$fstrobe'",
	"'$fstrobeb'", "'$fstrobeh'", "'$fstrobeo'", "'$swrite'", "'$swriteb'",
	"'$swriteh'", "'$swriteo'", "'$fscanf'", "'$fread'", "'$fseek'", "'$fflush'",
	"'$feof'", "'$sdf_annotate'", "'$fopen'", "'$fwrite'", "'$fwriteb'", "'$fwriteh'",
	"'$fwriteo'", "'$fmonitor'", "'$fmonitorb'", "'$fmonitorh'", "'$fmonitoro'",
	"'$sformat'", "'$fgetc'", "'$ungetc'", "'$fgets'", "'$sscanf'", "'$rewind'",
	"'$ftell'", "'$ferror'", "'$readmemb'", "'$readmemh'", "'$printtimescale'",
	"'$timeformat'", "'$finish'", "'$stop'", "'$async$and$array'", "'$async$nand$array'",
	"'$async$or$array'", "'$async$nor$array'", "'$sync$and$array'", "'$sync$nand$array'",
	"'$sync$or$array'", "'$sync$nor$array'", "'$async$and$plane'", "'$async$nand$plane'",
	"'$async$or$plane'", "'$async$nor$plane'", "'$sync$and$plane'", "'$sync$nand$plane'",
	"'$sync$or$plane'", "'$sync$nor$plane'", "'$q_initialize'", "'$q_remove'",
	"'$q_exam'", "'$q_add'", "'$q_full'", "'$realtime'", "'$time'", "'$stime'",
	"'$bitstoreal'", "'$itor'", "'$signed'", "'$realtobits'", "'$rtoi'", "'$unsigned'",
	"'$random'", "'$dist_erlang'", "'$dist_normal'", "'$dist_t'", "'$dist_chi_square'",
	"'$dist_exponential'", "'$dist_poisson'", "'$dist_uniform'", "'$test$plusargs'",
	"'$value$plusargs'", "'$clog2'", "'$ln'", "'$log10'", "'$exp'", "'$sqrt'",
	"'$pow'", "'$floor'", "'$ceil'", "'$sin'", "'$cos'", "'$tan'", "'$asin'",
	"'$acos'", "'$atan'", "'$atan2'", "'$hypot'", "'$sinh'", "'$cosh'", "'$tanh'",
	"'$asinh'", "'$acosh'", "'$atanh'", "'$dumpfile'", "'$dumpvars'", "'$dumpoff'",
	"'$dumpon'", "'$dumpall'", "'$dumplimit'", "'$dumpflush'", "'$end'", "'$comment'",
	"'$date'", "'$enddefinitions'", "'$scope'", "'$timescale'", "'$upscope'",
	"'$var'", "'$version'", "'$dumpports'", "'$dumpportsoff'", "'$dumpportson'",
	"'$dumpportsall'", "'$dumpportslimit'", "'$dumpportsflush'", "'$vcdclose'",
	"'$setup'", "'$hold'", "'$setuphold'", "'$recovery'", "'$removal'", "'$recrem'",
	"'$skew'", "'$timeskew'", "'$fullskew'", "'$period'", "'$width'", "'$nochange'",
	"", "", "", "", "", "", "", "", "", "", "", "", "'('", "')'", "'['", "']'",
	"'{'", "'}'", "'+'", "'-'", "'!'", "'~'", "'&'", "'~&'", "'|'", "'~|'",
	"'^'", "'~^'", "'^~'", "'*'", "'%'", "'=='", "'!='", "'==='", "'!=='",
	"'&&'", "'||'", "'**'", "'<'", "'<='", "'>'", "'>='", "'>>'", "'<<'", "'>>>'",
	"'<<<'", "'.'", "", "':'", "';'", "", "'='", "'?'", "'@'", "'#'", "", "'+:'",
	"'-:'", "'->'", "'=>'", "'*>'", "'&&&'", "'PATHPULSE$'", "", "'-incdir'",
	"", "'begin_keywords'", "'celldefine'", "'default_nettype'", "", "", "",
	"'end_keywords'", "'endcelldefine'", "'endif'", "", "", "", "'line'", "'nounconnected_drive'",
	"'resetall'", "'timescale'", "'unconnected_drive'",
}
var symbolicNames = []string{
	"", "ALWAYS", "AND", "ASSIGN", "AUTOMATIC", "BEGIN", "BUF", "BUFIF0", "BUFIF1",
	"CASE", "CASEX", "CASEZ", "CELL", "CMOS", "CONFIG", "DEASSIGN", "DEFAULT",
	"DEFPARAM", "DESIGN", "DISABLE", "EDGE", "ELSE", "END", "ENDCASE", "ENDCONFIG",
	"ENDFUNCTION", "ENDGENERATE", "ENDMODULE", "ENDPRIMITIVE", "ENDSPECIFY",
	"ENDTABLE", "ENDTASK", "EVENT", "FOR", "FORCE", "FOREVER", "FORK", "FUNCTION",
	"GENERATE", "GENVAR", "HIGHZ0", "HIGHZ1", "IF", "IFNONE", "INCDIR", "INCLUDE",
	"INITIAL", "INOUT", "INPUT", "INSTANCE", "INTEGER", "JOIN", "LARGE", "LIBLIST",
	"LIBRARY", "LOCALPARAM", "MACROMODULE", "MEDIUM", "MODULE", "NAND", "NEGEDGE",
	"NMOS", "NOR", "NOSHOWCANCELLED", "NOT", "NOTIF0", "NOTIF1", "OR", "OUTPUT",
	"PARAMETER", "PMOS", "POSEDGE", "PRIMITIVE", "PULL0", "PULL1", "PULLDOWN",
	"PULLUP", "PULSESTYLE_ONEVENT", "PULSESTYLE_ONDETECT", "RCMOS", "REAL",
	"REALTIME", "REG", "RELEASE", "REPEAT", "RNMOS", "RPMOS", "RTRAN", "RTRANIF0",
	"RTRANIF1", "SCALARED", "SHOWCANCELLED", "SIGNED", "SMALL", "SPECIFY",
	"SPECPARAM", "STRONG0", "STRONG1", "SUPPLY0", "SUPPLY1", "TABLE", "TASK",
	"TIME", "TRAN", "TRANIF0", "TRANIF1", "TRI", "TRI0", "TRI1", "TRIAND",
	"TRIOR", "TRIREG", "UNSIGNED", "USE", "UWIRE", "VECTORED", "WAIT", "WAND",
	"WEAK0", "WEAK1", "WHILE", "WIRE", "WOR", "XNOR", "XOR", "DOLLAR_DISPLAY",
	"DOLLAR_DISPLAYB", "DOLLAR_DISPLAYH", "DOLLAR_DISPLAYO", "DOLLAR_WRITE",
	"DOLLAR_WRITEB", "DOLLAR_WRITEH", "DOLLAR_WRITEO", "DOLLAR_STROBE", "DOLLAR_STROBEB",
	"DOLLAR_STROBEH", "DOLLAR_STROBEO", "DOLLAR_MONITOR", "DOLLAR_MONITORB",
	"DOLLAR_MONITORH", "DOLLAR_MONITORO", "DOLLAR_MONITOROFF", "DOLLAR_MONITORON",
	"DOLLAR_FCLOSE", "DOLLAR_FDISPLAY", "DOLLAR_FDISPLAYB", "DOLLAR_FDISPLAYH",
	"DOLLAR_FDISPLAYO", "DOLLAR_FSTROBE", "DOLLAR_FSTROBEB", "DOLLAR_FSTROBEH",
	"DOLLAR_FSTROBEO", "DOLLAR_SWRITE", "DOLLAR_SWRITEB", "DOLLAR_SWRITEH",
	"DOLLAR_SWRITEO", "DOLLAR_FSCANF", "DOLLAR_FREAD", "DOLLAR_FSEEK", "DOLLAR_FFLUSH",
	"DOLLAR_FEOF", "DOLLAR_SDF_ANNOTATE", "DOLLAR_FOPEN", "DOLLAR_FWRITE",
	"DOLLAR_FWRITEB", "DOLLAR_FWRITEH", "DOLLAR_FWRITEO", "DOLLAR_FMONITOR",
	"DOLLAR_FMONITORB", "DOLLAR_FMONITORH", "DOLLAR_FMONITORO", "DOLLAR_SFORMAT",
	"DOLLAR_FGETC", "DOLLAR_UNGETC", "DOLLAR_FGETS", "DOLLAR_SSCANF", "DOLLAR_REWIND",
	"DOLLAR_FTELL", "DOLLAR_FERROR", "DOLLAR_READMEMB", "DOLLAR_READMEMH",
	"DOLLAR_PRINTTIMESCALE", "DOLLAR_TIMEFORMAT", "DOLLAR_FINISH", "DOLLAR_STOP",
	"DOLLAR_ASYNC_AND_ARRAY", "DOLLAR_ASYNC_NAND_ARRAY", "DOLLAR_ASYNC_OR_ARRAY",
	"DOLLAR_ASYNC_NOR_ARRAY", "DOLLAR_SYNC_AND_ARRAY", "DOLLAR_SYNC_NAND_ARRAY",
	"DOLLAR_SYNC_OR_ARRAY", "DOLLAR_SYNC_NOR_ARRAY", "DOLLAR_ASYNC_AND_PLANE",
	"DOLLAR_ASYNC_NAND_PLANE", "DOLLAR_ASYNC_OR_PLANE", "DOLLAR_ASYNC_NOR_PLANE",
	"DOLLAR_SYNC_AND_PLANE", "DOLLAR_SYNC_NAND_PLANE", "DOLLAR_SYNC_OR_PLANE",
	"DOLLAR_SYNC_NOR_PLANE", "DOLLAR_Q_INITIALIZE", "DOLLAR_Q_REMOVE", "DOLLAR_Q_EXAM",
	"DOLLAR_Q_ADD", "DOLLAR_Q_FULL", "DOLLAR_REALTIME", "DOLLAR_TIME", "DOLLAR_STIME",
	"DOLLAR_BITSTOREAL", "DOLLAR_ITOR", "DOLLAR_SIGNED", "DOLLAR_REALTOBITS",
	"DOLLAR_RTOI", "DOLLAR_UNSIGNED", "DOLLAR_RANDOM", "DOLLAR_DIST_ERLANG",
	"DOLLAR_DIST_NORMAL", "DOLLAR_DIST_T", "DOLLAR_DIST_CHI_SQUARE", "DOLLAR_DIST_EXPONENTIAL",
	"DOLLAR_DIST_POISSON", "DOLLAR_DIST_UNIFORM", "DOLLAR_TEST_PLUSARGS", "DOLLAR_VALUE_PLUSARGS",
	"DOLLAR_CLOG2", "DOLLAR_LN", "DOLLAR_LOG10", "DOLLAR_EXP", "DOLLAR_SQRT",
	"DOLLAR_POW", "DOLLAR_FLOOR", "DOLLAR_CEIL", "DOLLAR_SIN", "DOLLAR_COS",
	"DOLLAR_TAN", "DOLLAR_ASIN", "DOLLAR_ACOS", "DOLLAR_ATAN", "DOLLAR_ATAN2",
	"DOLLAR_HYPOT", "DOLLAR_SINH", "DOLLAR_COSH", "DOLLAR_TANH", "DOLLAR_ASINH",
	"DOLLAR_ACOSH", "DOLLAR_ATANH", "DOLLAR_DUMPFILE", "DOLLAR_DUMPVARS", "DOLLAR_DUMPOFF",
	"DOLLAR_DUMPON", "DOLLAR_DUMPALL", "DOLLAR_DUMPLIMIT", "DOLLAR_DUMPFLUSH",
	"DOLLAR_END", "DOLLAR_COMMENT", "DOLLAR_DATE", "DOLLAR_ENDDEFINITIONS",
	"DOLLAR_SCOPE", "DOLLAR_TIMESCALE", "DOLLAR_UPSCOPE", "DOLLAR_VAR", "DOLLAR_VERSION",
	"DOLLAR_DUMPPORTS", "DOLLAR_DUMPPORTSOFF", "DOLLAR_DUMPPORTSON", "DOLLAR_DUMPPORTSALL",
	"DOLLAR_DUMPPORTSLIMIT", "DOLLAR_DUMPPORTSFLUSH", "DOLLAR_VCDCLOSE", "DOLLAR_SETUP",
	"DOLLAR_HOLD", "DOLLAR_SETUPHOLD", "DOLLAR_RECOVERY", "DOLLAR_REMOVAL",
	"DOLLAR_RECREM", "DOLLAR_SKEW", "DOLLAR_TIMESKEW", "DOLLAR_FULLSKEW", "DOLLAR_PERIOD",
	"DOLLAR_WIDTH", "DOLLAR_NOCHANGE", "REAL_NUMBER", "DECIMAL_NUMBER", "BINARY_NUMBER",
	"OCTAL_NUMBER", "HEX_NUMBER", "STRING", "ONE_LINE_COMMENT", "BLOCK_COMMENT",
	"ESCAPED_IDENTIFIER", "SIMPLE_IDENTIFIER", "SYSTEM_TF_IDENTIFIER", "WHITE_SPACE_REGION",
	"LEFT_PARENTHESIS", "RIGHT_PARENTHESIS", "LEFT_BRACKET", "RIGHT_BRACKET",
	"LEFT_BRACE", "RIGHT_BRACE", "PLUS", "MINUS", "EXCLAMATION_MARK", "TILDE",
	"AMPERSAND", "TILDE_AMPERSAND", "VERTICAL_BAR", "TILDE_VERTICAL_BAR", "CARET",
	"TILDE_CARET", "CARET_TILDE", "ASTERISK", "PERCENT", "DOUBLE_EQUAL", "EXCLAMATION_MARK_EQUAL",
	"TRIPLE_EQUAL", "EXCLAMATION_MARK_DOUBLE_EQUAL", "DOUBLE_AMPERSAND", "DOUBLE_VERTICAL_BAR",
	"DOUBLE_ASTERISK", "LESS_THAN", "LESS_THAN_EQUAL", "GREATER_THAN", "GREATER_THAN_EQUAL",
	"DOUBLE_GREATER_THAN", "DOUBLE_LESS_THAN", "TRIPLE_GREATER_THAN", "TRIPLE_LESS_THAN",
	"DOT", "COMMA", "COLON", "SEMICOLON", "SLASH", "EQUAL", "QUESTION_MARK",
	"AT", "HASH", "GRAVE_ACCENT", "PLUS_COLON", "MINUS_COLON", "MINUS_GREATER_THAN",
	"EQUAL_GREATER_THAN", "ASTERISK_GREATER_THAN", "TRIPLE_AMPERSAND", "PATHPULSE_DOLLAR",
	"FILE_PATH_SPEC", "MINUS_INCDIR", "LIBRARY_NEWLINE", "DIRECTIVE_BEGIN_KEYWORDS",
	"DIRECTIVE_CELLDEFINE", "DIRECTIVE_DEFAULT_NETTYPE", "DIRECTIVE_DEFINE",
	"DIRECTIVE_ELSE", "DIRECTIVE_ELSIF", "DIRECTIVE_END_KEYWORDS", "DIRECTIVE_ENDCELLDEFINE",
	"DIRECTIVE_ENDIF", "DIRECTIVE_IFDEF", "DIRECTIVE_IFNDEF", "DIRECTIVE_INCLUDE",
	"DIRECTIVE_LINE", "DIRECTIVE_NOUNCONNECTED_DRIVE", "DIRECTIVE_RESETALL",
	"DIRECTIVE_TIMESCALE", "DIRECTIVE_UNCONNECTED_DRIVE", "DIRECTIVE_UNDEF",
	"DEFAULT_NETTYPE_VALUE", "TIME_UNIT", "UNCONNECTED_DRIVE_VALUE", "DIRECTIVE_NUMBER",
	"DIRECTIVE_STRING", "DIRECTIVE_IDENTIFIER", "DIRECTIVE_SLASH", "DIRECTIVE_COMMENT",
	"DIRECTIVE_WHITE_SPACE", "DIRECTIVE_NEWLINE", "MACRO_TEXT", "MACRO_TEXT_BACKSLASH_NEWLINE",
	"DIRECTIVE_LIST_OF_ARGUMENTS", "MACRO_USAGE_BACKSLASH_NEWLINE", "ANY_OTHER_TOKEN",
	"SOURCE_TEXT", "SOURCE_TEXT_BACKSLASH_NEWLINE",
}

var ruleNames = []string{
	"display_tasks", "display_task_name", "list_of_arguments", "argument",
	"strobe_tasks", "strobe_task_name", "monitor_tasks", "monitor_task_name",
	"file_open_function", "file_close_task", "multi_channel_descriptor", "fd",
	"file_name", "type_", "file_output_tasks", "file_output_task_name", "load_memory_tasks",
	"memory_name", "start_addr", "finish_addr", "filename", "finish_task",
	"finish_number", "stop_task", "time_function", "stime_function", "realtime_function",
	"conversion_functions", "conversion_function_name", "constant_argument",
	"random_function", "seed", "dist_functions", "start_", "end", "mean", "standard_deviation",
	"degree_of_freedom", "k_stage", "math_functions", "integer_math_functions",
	"real_math_functions", "single_argument_real_math_function_name", "double_argument_real_math_function_name",
	"dumpfile_task", "dumpvars_task", "list_of_modules_or_variables", "module_or_variable",
	"levels", "dumpoff_task", "dumpon_task", "dumpall_task", "dumplimit_task",
	"file_size", "dumpflush_task", "dumpports_task", "scope_list", "file_pathname",
	"dumpportsoff_task", "dumpportson_task", "dumpportsall_task", "dumpportslimit_task",
	"dumpportsflush_task", "library_text", "library_description", "library_declaration",
	"include_statement", "source_text", "description", "module_declaration",
	"module_keyword", "module_parameter_port_list", "list_of_ports", "list_of_port_declarations",
	"port", "port_expression", "port_reference", "port_declaration", "module_item",
	"module_or_generate_item", "module_or_generate_item_declaration", "non_port_module_item",
	"parameter_override", "config_declaration", "design_statement", "config_rule_statement",
	"default_clause", "inst_clause", "inst_name", "cell_clause", "liblist_clause",
	"use_clause", "local_parameter_declaration", "parameter_declaration", "specparam_declaration",
	"parameter_type", "inout_declaration", "input_declaration", "output_declaration",
	"event_declaration", "integer_declaration", "net_declaration", "real_declaration",
	"realtime_declaration", "reg_declaration", "time_declaration", "net_type",
	"output_variable_type", "real_type", "variable_type", "drive_strength",
	"strength0", "strength1", "charge_strength", "delay3", "delay2", "delay_value",
	"list_of_defparam_assignments", "list_of_event_identifiers", "list_of_net_decl_assignments",
	"list_of_net_identifiers", "list_of_param_assignments", "list_of_port_identifiers",
	"list_of_real_identifiers", "list_of_specparam_assignments", "list_of_variable_identifiers",
	"list_of_variable_port_identifiers", "defparam_assignment", "net_decl_assignment",
	"param_assignment", "specparam_assignment", "pulse_control_specparam",
	"error_limit_value", "reject_limit_value", "limit_value", "dimension",
	"range_", "function_declaration", "function_item_declaration", "function_port_list",
	"function_range_or_type", "task_declaration", "task_item_declaration",
	"task_port_list", "task_port_item", "tf_input_declaration", "tf_output_declaration",
	"tf_inout_declaration", "task_port_type", "block_item_declaration", "list_of_block_variable_identifiers",
	"list_of_block_real_identifiers", "block_variable_type", "block_real_type",
	"gate_instantiation", "cmos_switch_instance", "enable_gate_instance", "mos_switch_instance",
	"n_input_gate_instance", "n_output_gate_instance", "pass_switch_instance",
	"pass_enable_switch_instance", "pull_gate_instance", "name_of_gate_instance",
	"pulldown_strength", "pullup_strength", "enable_terminal", "inout_terminal",
	"input_terminal", "ncontrol_terminal", "output_terminal", "pcontrol_terminal",
	"cmos_switchtype", "enable_gatetype", "mos_switchtype", "n_input_gatetype",
	"n_output_gatetype", "pass_en_switchtype", "pass_switchtype", "module_instantiation",
	"parameter_value_assignment", "list_of_parameter_assignments", "ordered_parameter_assignment",
	"named_parameter_assignment", "module_instance", "name_of_module_instance",
	"list_of_port_connections", "ordered_port_connection", "named_port_connection",
	"generate_region", "genvar_declaration", "list_of_genvar_identifiers",
	"loop_generate_construct", "genvar_initialization", "genvar_expression",
	"genvar_iteration", "genvar_primary", "conditional_generate_construct",
	"if_generate_construct", "case_generate_construct", "generate_block", "generate_block_or_null",
	"continuous_assign", "list_of_net_assignments", "net_assignment", "initial_construct",
	"always_construct", "blocking_assignment", "nonblocking_assignment", "procedural_continuous_assignments",
	"variable_assignment", "par_block", "seq_block", "statement", "statement_or_null",
	"function_statement", "delay_control", "delay_or_event_control", "disable_statement",
	"event_control", "event_trigger", "event_expression", "event_primary",
	"procedural_timing_control", "procedural_timing_control_statement", "wait_statement",
	"conditional_statement", "case_statement", "case_item", "loop_statement",
	"system_task_enable", "task_enable", "specify_block", "specify_item", "pulsestyle_declaration",
	"showcancelled_declaration", "path_declaration", "simple_path_declaration",
	"parallel_path_description", "full_path_description", "list_of_path_inputs",
	"list_of_path_outputs", "specify_input_terminal_descriptor", "specify_output_terminal_descriptor",
	"input_identifier", "output_identifier", "path_delay_value", "list_of_path_delay_expressions",
	"t_path_delay_expression", "trise_path_delay_expression", "tfall_path_delay_expression",
	"tz_path_delay_expression", "t01_path_delay_expression", "t10_path_delay_expression",
	"t0z_path_delay_expression", "tz1_path_delay_expression", "t1z_path_delay_expression",
	"tz0_path_delay_expression", "t0x_path_delay_expression", "tx1_path_delay_expression",
	"t1x_path_delay_expression", "tx0_path_delay_expression", "txz_path_delay_expression",
	"tzx_path_delay_expression", "path_delay_expression", "edge_sensitive_path_declaration",
	"parallel_edge_sensitive_path_description", "full_edge_sensitive_path_description",
	"data_source_expression", "edge_identifier", "state_dependent_path_declaration",
	"polarity_operator", "concatenation", "constant_concatenation", "constant_multiple_concatenation",
	"module_path_concatenation", "module_path_multiple_concatenation", "multiple_concatenation",
	"constant_function_call", "constant_system_function_call", "function_call",
	"system_function_call", "base_expression", "constant_base_expression",
	"constant_expression", "constant_mintypmax_expression", "constant_range_expression",
	"dimension_constant_expression", "expression", "lsb_constant_expression",
	"mintypmax_expression", "module_path_expression", "module_path_mintypmax_expression",
	"msb_constant_expression", "range_expression", "width_constant_expression",
	"constant_primary", "module_path_primary", "primary", "net_lvalue", "variable_lvalue",
	"unary_operator", "binary_operator", "unary_module_path_operator", "binary_module_path_operator",
	"number", "attribute_instance", "attr_spec", "attr_name", "block_identifier",
	"cell_identifier", "config_identifier", "event_identifier", "function_identifier",
	"gate_instance_identifier", "generate_block_identifier", "genvar_identifier",
	"hierarchical_block_identifier", "hierarchical_event_identifier", "hierarchical_function_identifier",
	"hierarchical_identifier", "hierarchical_net_identifier", "hierarchical_parameter_identifier",
	"hierarchical_variable_identifier", "hierarchical_task_identifier", "identifier",
	"inout_port_identifier", "input_port_identifier", "instance_identifier",
	"library_identifier", "module_identifier", "module_instance_identifier",
	"net_identifier", "output_port_identifier", "parameter_identifier", "port_identifier",
	"real_identifier", "specparam_identifier", "system_function_identifier",
	"system_task_identifier", "task_identifier", "terminal_identifier", "topmodule_identifier",
	"udp_identifier", "udp_instance_identifier", "variable_identifier",
}

type VerilogParser struct {
	*antlr.BaseParser
}

// NewVerilogParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *VerilogParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewVerilogParser(input antlr.TokenStream) *VerilogParser {
	this := new(VerilogParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "VerilogParser.g4"

	return this
}

// VerilogParser tokens.
const (
	VerilogParserEOF                           = antlr.TokenEOF
	VerilogParserALWAYS                        = 1
	VerilogParserAND                           = 2
	VerilogParserASSIGN                        = 3
	VerilogParserAUTOMATIC                     = 4
	VerilogParserBEGIN                         = 5
	VerilogParserBUF                           = 6
	VerilogParserBUFIF0                        = 7
	VerilogParserBUFIF1                        = 8
	VerilogParserCASE                          = 9
	VerilogParserCASEX                         = 10
	VerilogParserCASEZ                         = 11
	VerilogParserCELL                          = 12
	VerilogParserCMOS                          = 13
	VerilogParserCONFIG                        = 14
	VerilogParserDEASSIGN                      = 15
	VerilogParserDEFAULT                       = 16
	VerilogParserDEFPARAM                      = 17
	VerilogParserDESIGN                        = 18
	VerilogParserDISABLE                       = 19
	VerilogParserEDGE                          = 20
	VerilogParserELSE                          = 21
	VerilogParserEND                           = 22
	VerilogParserENDCASE                       = 23
	VerilogParserENDCONFIG                     = 24
	VerilogParserENDFUNCTION                   = 25
	VerilogParserENDGENERATE                   = 26
	VerilogParserENDMODULE                     = 27
	VerilogParserENDPRIMITIVE                  = 28
	VerilogParserENDSPECIFY                    = 29
	VerilogParserENDTABLE                      = 30
	VerilogParserENDTASK                       = 31
	VerilogParserEVENT                         = 32
	VerilogParserFOR                           = 33
	VerilogParserFORCE                         = 34
	VerilogParserFOREVER                       = 35
	VerilogParserFORK                          = 36
	VerilogParserFUNCTION                      = 37
	VerilogParserGENERATE                      = 38
	VerilogParserGENVAR                        = 39
	VerilogParserHIGHZ0                        = 40
	VerilogParserHIGHZ1                        = 41
	VerilogParserIF                            = 42
	VerilogParserIFNONE                        = 43
	VerilogParserINCDIR                        = 44
	VerilogParserINCLUDE                       = 45
	VerilogParserINITIAL                       = 46
	VerilogParserINOUT                         = 47
	VerilogParserINPUT                         = 48
	VerilogParserINSTANCE                      = 49
	VerilogParserINTEGER                       = 50
	VerilogParserJOIN                          = 51
	VerilogParserLARGE                         = 52
	VerilogParserLIBLIST                       = 53
	VerilogParserLIBRARY                       = 54
	VerilogParserLOCALPARAM                    = 55
	VerilogParserMACROMODULE                   = 56
	VerilogParserMEDIUM                        = 57
	VerilogParserMODULE                        = 58
	VerilogParserNAND                          = 59
	VerilogParserNEGEDGE                       = 60
	VerilogParserNMOS                          = 61
	VerilogParserNOR                           = 62
	VerilogParserNOSHOWCANCELLED               = 63
	VerilogParserNOT                           = 64
	VerilogParserNOTIF0                        = 65
	VerilogParserNOTIF1                        = 66
	VerilogParserOR                            = 67
	VerilogParserOUTPUT                        = 68
	VerilogParserPARAMETER                     = 69
	VerilogParserPMOS                          = 70
	VerilogParserPOSEDGE                       = 71
	VerilogParserPRIMITIVE                     = 72
	VerilogParserPULL0                         = 73
	VerilogParserPULL1                         = 74
	VerilogParserPULLDOWN                      = 75
	VerilogParserPULLUP                        = 76
	VerilogParserPULSESTYLE_ONEVENT            = 77
	VerilogParserPULSESTYLE_ONDETECT           = 78
	VerilogParserRCMOS                         = 79
	VerilogParserREAL                          = 80
	VerilogParserREALTIME                      = 81
	VerilogParserREG                           = 82
	VerilogParserRELEASE                       = 83
	VerilogParserREPEAT                        = 84
	VerilogParserRNMOS                         = 85
	VerilogParserRPMOS                         = 86
	VerilogParserRTRAN                         = 87
	VerilogParserRTRANIF0                      = 88
	VerilogParserRTRANIF1                      = 89
	VerilogParserSCALARED                      = 90
	VerilogParserSHOWCANCELLED                 = 91
	VerilogParserSIGNED                        = 92
	VerilogParserSMALL                         = 93
	VerilogParserSPECIFY                       = 94
	VerilogParserSPECPARAM                     = 95
	VerilogParserSTRONG0                       = 96
	VerilogParserSTRONG1                       = 97
	VerilogParserSUPPLY0                       = 98
	VerilogParserSUPPLY1                       = 99
	VerilogParserTABLE                         = 100
	VerilogParserTASK                          = 101
	VerilogParserTIME                          = 102
	VerilogParserTRAN                          = 103
	VerilogParserTRANIF0                       = 104
	VerilogParserTRANIF1                       = 105
	VerilogParserTRI                           = 106
	VerilogParserTRI0                          = 107
	VerilogParserTRI1                          = 108
	VerilogParserTRIAND                        = 109
	VerilogParserTRIOR                         = 110
	VerilogParserTRIREG                        = 111
	VerilogParserUNSIGNED                      = 112
	VerilogParserUSE                           = 113
	VerilogParserUWIRE                         = 114
	VerilogParserVECTORED                      = 115
	VerilogParserWAIT                          = 116
	VerilogParserWAND                          = 117
	VerilogParserWEAK0                         = 118
	VerilogParserWEAK1                         = 119
	VerilogParserWHILE                         = 120
	VerilogParserWIRE                          = 121
	VerilogParserWOR                           = 122
	VerilogParserXNOR                          = 123
	VerilogParserXOR                           = 124
	VerilogParserDOLLAR_DISPLAY                = 125
	VerilogParserDOLLAR_DISPLAYB               = 126
	VerilogParserDOLLAR_DISPLAYH               = 127
	VerilogParserDOLLAR_DISPLAYO               = 128
	VerilogParserDOLLAR_WRITE                  = 129
	VerilogParserDOLLAR_WRITEB                 = 130
	VerilogParserDOLLAR_WRITEH                 = 131
	VerilogParserDOLLAR_WRITEO                 = 132
	VerilogParserDOLLAR_STROBE                 = 133
	VerilogParserDOLLAR_STROBEB                = 134
	VerilogParserDOLLAR_STROBEH                = 135
	VerilogParserDOLLAR_STROBEO                = 136
	VerilogParserDOLLAR_MONITOR                = 137
	VerilogParserDOLLAR_MONITORB               = 138
	VerilogParserDOLLAR_MONITORH               = 139
	VerilogParserDOLLAR_MONITORO               = 140
	VerilogParserDOLLAR_MONITOROFF             = 141
	VerilogParserDOLLAR_MONITORON              = 142
	VerilogParserDOLLAR_FCLOSE                 = 143
	VerilogParserDOLLAR_FDISPLAY               = 144
	VerilogParserDOLLAR_FDISPLAYB              = 145
	VerilogParserDOLLAR_FDISPLAYH              = 146
	VerilogParserDOLLAR_FDISPLAYO              = 147
	VerilogParserDOLLAR_FSTROBE                = 148
	VerilogParserDOLLAR_FSTROBEB               = 149
	VerilogParserDOLLAR_FSTROBEH               = 150
	VerilogParserDOLLAR_FSTROBEO               = 151
	VerilogParserDOLLAR_SWRITE                 = 152
	VerilogParserDOLLAR_SWRITEB                = 153
	VerilogParserDOLLAR_SWRITEH                = 154
	VerilogParserDOLLAR_SWRITEO                = 155
	VerilogParserDOLLAR_FSCANF                 = 156
	VerilogParserDOLLAR_FREAD                  = 157
	VerilogParserDOLLAR_FSEEK                  = 158
	VerilogParserDOLLAR_FFLUSH                 = 159
	VerilogParserDOLLAR_FEOF                   = 160
	VerilogParserDOLLAR_SDF_ANNOTATE           = 161
	VerilogParserDOLLAR_FOPEN                  = 162
	VerilogParserDOLLAR_FWRITE                 = 163
	VerilogParserDOLLAR_FWRITEB                = 164
	VerilogParserDOLLAR_FWRITEH                = 165
	VerilogParserDOLLAR_FWRITEO                = 166
	VerilogParserDOLLAR_FMONITOR               = 167
	VerilogParserDOLLAR_FMONITORB              = 168
	VerilogParserDOLLAR_FMONITORH              = 169
	VerilogParserDOLLAR_FMONITORO              = 170
	VerilogParserDOLLAR_SFORMAT                = 171
	VerilogParserDOLLAR_FGETC                  = 172
	VerilogParserDOLLAR_UNGETC                 = 173
	VerilogParserDOLLAR_FGETS                  = 174
	VerilogParserDOLLAR_SSCANF                 = 175
	VerilogParserDOLLAR_REWIND                 = 176
	VerilogParserDOLLAR_FTELL                  = 177
	VerilogParserDOLLAR_FERROR                 = 178
	VerilogParserDOLLAR_READMEMB               = 179
	VerilogParserDOLLAR_READMEMH               = 180
	VerilogParserDOLLAR_PRINTTIMESCALE         = 181
	VerilogParserDOLLAR_TIMEFORMAT             = 182
	VerilogParserDOLLAR_FINISH                 = 183
	VerilogParserDOLLAR_STOP                   = 184
	VerilogParserDOLLAR_ASYNC_AND_ARRAY        = 185
	VerilogParserDOLLAR_ASYNC_NAND_ARRAY       = 186
	VerilogParserDOLLAR_ASYNC_OR_ARRAY         = 187
	VerilogParserDOLLAR_ASYNC_NOR_ARRAY        = 188
	VerilogParserDOLLAR_SYNC_AND_ARRAY         = 189
	VerilogParserDOLLAR_SYNC_NAND_ARRAY        = 190
	VerilogParserDOLLAR_SYNC_OR_ARRAY          = 191
	VerilogParserDOLLAR_SYNC_NOR_ARRAY         = 192
	VerilogParserDOLLAR_ASYNC_AND_PLANE        = 193
	VerilogParserDOLLAR_ASYNC_NAND_PLANE       = 194
	VerilogParserDOLLAR_ASYNC_OR_PLANE         = 195
	VerilogParserDOLLAR_ASYNC_NOR_PLANE        = 196
	VerilogParserDOLLAR_SYNC_AND_PLANE         = 197
	VerilogParserDOLLAR_SYNC_NAND_PLANE        = 198
	VerilogParserDOLLAR_SYNC_OR_PLANE          = 199
	VerilogParserDOLLAR_SYNC_NOR_PLANE         = 200
	VerilogParserDOLLAR_Q_INITIALIZE           = 201
	VerilogParserDOLLAR_Q_REMOVE               = 202
	VerilogParserDOLLAR_Q_EXAM                 = 203
	VerilogParserDOLLAR_Q_ADD                  = 204
	VerilogParserDOLLAR_Q_FULL                 = 205
	VerilogParserDOLLAR_REALTIME               = 206
	VerilogParserDOLLAR_TIME                   = 207
	VerilogParserDOLLAR_STIME                  = 208
	VerilogParserDOLLAR_BITSTOREAL             = 209
	VerilogParserDOLLAR_ITOR                   = 210
	VerilogParserDOLLAR_SIGNED                 = 211
	VerilogParserDOLLAR_REALTOBITS             = 212
	VerilogParserDOLLAR_RTOI                   = 213
	VerilogParserDOLLAR_UNSIGNED               = 214
	VerilogParserDOLLAR_RANDOM                 = 215
	VerilogParserDOLLAR_DIST_ERLANG            = 216
	VerilogParserDOLLAR_DIST_NORMAL            = 217
	VerilogParserDOLLAR_DIST_T                 = 218
	VerilogParserDOLLAR_DIST_CHI_SQUARE        = 219
	VerilogParserDOLLAR_DIST_EXPONENTIAL       = 220
	VerilogParserDOLLAR_DIST_POISSON           = 221
	VerilogParserDOLLAR_DIST_UNIFORM           = 222
	VerilogParserDOLLAR_TEST_PLUSARGS          = 223
	VerilogParserDOLLAR_VALUE_PLUSARGS         = 224
	VerilogParserDOLLAR_CLOG2                  = 225
	VerilogParserDOLLAR_LN                     = 226
	VerilogParserDOLLAR_LOG10                  = 227
	VerilogParserDOLLAR_EXP                    = 228
	VerilogParserDOLLAR_SQRT                   = 229
	VerilogParserDOLLAR_POW                    = 230
	VerilogParserDOLLAR_FLOOR                  = 231
	VerilogParserDOLLAR_CEIL                   = 232
	VerilogParserDOLLAR_SIN                    = 233
	VerilogParserDOLLAR_COS                    = 234
	VerilogParserDOLLAR_TAN                    = 235
	VerilogParserDOLLAR_ASIN                   = 236
	VerilogParserDOLLAR_ACOS                   = 237
	VerilogParserDOLLAR_ATAN                   = 238
	VerilogParserDOLLAR_ATAN2                  = 239
	VerilogParserDOLLAR_HYPOT                  = 240
	VerilogParserDOLLAR_SINH                   = 241
	VerilogParserDOLLAR_COSH                   = 242
	VerilogParserDOLLAR_TANH                   = 243
	VerilogParserDOLLAR_ASINH                  = 244
	VerilogParserDOLLAR_ACOSH                  = 245
	VerilogParserDOLLAR_ATANH                  = 246
	VerilogParserDOLLAR_DUMPFILE               = 247
	VerilogParserDOLLAR_DUMPVARS               = 248
	VerilogParserDOLLAR_DUMPOFF                = 249
	VerilogParserDOLLAR_DUMPON                 = 250
	VerilogParserDOLLAR_DUMPALL                = 251
	VerilogParserDOLLAR_DUMPLIMIT              = 252
	VerilogParserDOLLAR_DUMPFLUSH              = 253
	VerilogParserDOLLAR_END                    = 254
	VerilogParserDOLLAR_COMMENT                = 255
	VerilogParserDOLLAR_DATE                   = 256
	VerilogParserDOLLAR_ENDDEFINITIONS         = 257
	VerilogParserDOLLAR_SCOPE                  = 258
	VerilogParserDOLLAR_TIMESCALE              = 259
	VerilogParserDOLLAR_UPSCOPE                = 260
	VerilogParserDOLLAR_VAR                    = 261
	VerilogParserDOLLAR_VERSION                = 262
	VerilogParserDOLLAR_DUMPPORTS              = 263
	VerilogParserDOLLAR_DUMPPORTSOFF           = 264
	VerilogParserDOLLAR_DUMPPORTSON            = 265
	VerilogParserDOLLAR_DUMPPORTSALL           = 266
	VerilogParserDOLLAR_DUMPPORTSLIMIT         = 267
	VerilogParserDOLLAR_DUMPPORTSFLUSH         = 268
	VerilogParserDOLLAR_VCDCLOSE               = 269
	VerilogParserDOLLAR_SETUP                  = 270
	VerilogParserDOLLAR_HOLD                   = 271
	VerilogParserDOLLAR_SETUPHOLD              = 272
	VerilogParserDOLLAR_RECOVERY               = 273
	VerilogParserDOLLAR_REMOVAL                = 274
	VerilogParserDOLLAR_RECREM                 = 275
	VerilogParserDOLLAR_SKEW                   = 276
	VerilogParserDOLLAR_TIMESKEW               = 277
	VerilogParserDOLLAR_FULLSKEW               = 278
	VerilogParserDOLLAR_PERIOD                 = 279
	VerilogParserDOLLAR_WIDTH                  = 280
	VerilogParserDOLLAR_NOCHANGE               = 281
	VerilogParserREAL_NUMBER                   = 282
	VerilogParserDECIMAL_NUMBER                = 283
	VerilogParserBINARY_NUMBER                 = 284
	VerilogParserOCTAL_NUMBER                  = 285
	VerilogParserHEX_NUMBER                    = 286
	VerilogParserSTRING                        = 287
	VerilogParserONE_LINE_COMMENT              = 288
	VerilogParserBLOCK_COMMENT                 = 289
	VerilogParserESCAPED_IDENTIFIER            = 290
	VerilogParserSIMPLE_IDENTIFIER             = 291
	VerilogParserSYSTEM_TF_IDENTIFIER          = 292
	VerilogParserWHITE_SPACE_REGION            = 293
	VerilogParserLEFT_PARENTHESIS              = 294
	VerilogParserRIGHT_PARENTHESIS             = 295
	VerilogParserLEFT_BRACKET                  = 296
	VerilogParserRIGHT_BRACKET                 = 297
	VerilogParserLEFT_BRACE                    = 298
	VerilogParserRIGHT_BRACE                   = 299
	VerilogParserPLUS                          = 300
	VerilogParserMINUS                         = 301
	VerilogParserEXCLAMATION_MARK              = 302
	VerilogParserTILDE                         = 303
	VerilogParserAMPERSAND                     = 304
	VerilogParserTILDE_AMPERSAND               = 305
	VerilogParserVERTICAL_BAR                  = 306
	VerilogParserTILDE_VERTICAL_BAR            = 307
	VerilogParserCARET                         = 308
	VerilogParserTILDE_CARET                   = 309
	VerilogParserCARET_TILDE                   = 310
	VerilogParserASTERISK                      = 311
	VerilogParserPERCENT                       = 312
	VerilogParserDOUBLE_EQUAL                  = 313
	VerilogParserEXCLAMATION_MARK_EQUAL        = 314
	VerilogParserTRIPLE_EQUAL                  = 315
	VerilogParserEXCLAMATION_MARK_DOUBLE_EQUAL = 316
	VerilogParserDOUBLE_AMPERSAND              = 317
	VerilogParserDOUBLE_VERTICAL_BAR           = 318
	VerilogParserDOUBLE_ASTERISK               = 319
	VerilogParserLESS_THAN                     = 320
	VerilogParserLESS_THAN_EQUAL               = 321
	VerilogParserGREATER_THAN                  = 322
	VerilogParserGREATER_THAN_EQUAL            = 323
	VerilogParserDOUBLE_GREATER_THAN           = 324
	VerilogParserDOUBLE_LESS_THAN              = 325
	VerilogParserTRIPLE_GREATER_THAN           = 326
	VerilogParserTRIPLE_LESS_THAN              = 327
	VerilogParserDOT                           = 328
	VerilogParserCOMMA                         = 329
	VerilogParserCOLON                         = 330
	VerilogParserSEMICOLON                     = 331
	VerilogParserSLASH                         = 332
	VerilogParserEQUAL                         = 333
	VerilogParserQUESTION_MARK                 = 334
	VerilogParserAT                            = 335
	VerilogParserHASH                          = 336
	VerilogParserGRAVE_ACCENT                  = 337
	VerilogParserPLUS_COLON                    = 338
	VerilogParserMINUS_COLON                   = 339
	VerilogParserMINUS_GREATER_THAN            = 340
	VerilogParserEQUAL_GREATER_THAN            = 341
	VerilogParserASTERISK_GREATER_THAN         = 342
	VerilogParserTRIPLE_AMPERSAND              = 343
	VerilogParserPATHPULSE_DOLLAR              = 344
	VerilogParserFILE_PATH_SPEC                = 345
	VerilogParserMINUS_INCDIR                  = 346
	VerilogParserLIBRARY_NEWLINE               = 347
	VerilogParserDIRECTIVE_BEGIN_KEYWORDS      = 348
	VerilogParserDIRECTIVE_CELLDEFINE          = 349
	VerilogParserDIRECTIVE_DEFAULT_NETTYPE     = 350
	VerilogParserDIRECTIVE_DEFINE              = 351
	VerilogParserDIRECTIVE_ELSE                = 352
	VerilogParserDIRECTIVE_ELSIF               = 353
	VerilogParserDIRECTIVE_END_KEYWORDS        = 354
	VerilogParserDIRECTIVE_ENDCELLDEFINE       = 355
	VerilogParserDIRECTIVE_ENDIF               = 356
	VerilogParserDIRECTIVE_IFDEF               = 357
	VerilogParserDIRECTIVE_IFNDEF              = 358
	VerilogParserDIRECTIVE_INCLUDE             = 359
	VerilogParserDIRECTIVE_LINE                = 360
	VerilogParserDIRECTIVE_NOUNCONNECTED_DRIVE = 361
	VerilogParserDIRECTIVE_RESETALL            = 362
	VerilogParserDIRECTIVE_TIMESCALE           = 363
	VerilogParserDIRECTIVE_UNCONNECTED_DRIVE   = 364
	VerilogParserDIRECTIVE_UNDEF               = 365
	VerilogParserDEFAULT_NETTYPE_VALUE         = 366
	VerilogParserTIME_UNIT                     = 367
	VerilogParserUNCONNECTED_DRIVE_VALUE       = 368
	VerilogParserDIRECTIVE_NUMBER              = 369
	VerilogParserDIRECTIVE_STRING              = 370
	VerilogParserDIRECTIVE_IDENTIFIER          = 371
	VerilogParserDIRECTIVE_SLASH               = 372
	VerilogParserDIRECTIVE_COMMENT             = 373
	VerilogParserDIRECTIVE_WHITE_SPACE         = 374
	VerilogParserDIRECTIVE_NEWLINE             = 375
	VerilogParserMACRO_TEXT                    = 376
	VerilogParserMACRO_TEXT_BACKSLASH_NEWLINE  = 377
	VerilogParserDIRECTIVE_LIST_OF_ARGUMENTS   = 378
	VerilogParserMACRO_USAGE_BACKSLASH_NEWLINE = 379
	VerilogParserANY_OTHER_TOKEN               = 380
	VerilogParserSOURCE_TEXT                   = 381
	VerilogParserSOURCE_TEXT_BACKSLASH_NEWLINE = 382
)

// VerilogParser rules.
const (
	VerilogParserRULE_display_tasks                            = 0
	VerilogParserRULE_display_task_name                        = 1
	VerilogParserRULE_list_of_arguments                        = 2
	VerilogParserRULE_argument                                 = 3
	VerilogParserRULE_strobe_tasks                             = 4
	VerilogParserRULE_strobe_task_name                         = 5
	VerilogParserRULE_monitor_tasks                            = 6
	VerilogParserRULE_monitor_task_name                        = 7
	VerilogParserRULE_file_open_function                       = 8
	VerilogParserRULE_file_close_task                          = 9
	VerilogParserRULE_multi_channel_descriptor                 = 10
	VerilogParserRULE_fd                                       = 11
	VerilogParserRULE_file_name                                = 12
	VerilogParserRULE_type_                                    = 13
	VerilogParserRULE_file_output_tasks                        = 14
	VerilogParserRULE_file_output_task_name                    = 15
	VerilogParserRULE_load_memory_tasks                        = 16
	VerilogParserRULE_memory_name                              = 17
	VerilogParserRULE_start_addr                               = 18
	VerilogParserRULE_finish_addr                              = 19
	VerilogParserRULE_filename                                 = 20
	VerilogParserRULE_finish_task                              = 21
	VerilogParserRULE_finish_number                            = 22
	VerilogParserRULE_stop_task                                = 23
	VerilogParserRULE_time_function                            = 24
	VerilogParserRULE_stime_function                           = 25
	VerilogParserRULE_realtime_function                        = 26
	VerilogParserRULE_conversion_functions                     = 27
	VerilogParserRULE_conversion_function_name                 = 28
	VerilogParserRULE_constant_argument                        = 29
	VerilogParserRULE_random_function                          = 30
	VerilogParserRULE_seed                                     = 31
	VerilogParserRULE_dist_functions                           = 32
	VerilogParserRULE_start_                                   = 33
	VerilogParserRULE_end                                      = 34
	VerilogParserRULE_mean                                     = 35
	VerilogParserRULE_standard_deviation                       = 36
	VerilogParserRULE_degree_of_freedom                        = 37
	VerilogParserRULE_k_stage                                  = 38
	VerilogParserRULE_math_functions                           = 39
	VerilogParserRULE_integer_math_functions                   = 40
	VerilogParserRULE_real_math_functions                      = 41
	VerilogParserRULE_single_argument_real_math_function_name  = 42
	VerilogParserRULE_double_argument_real_math_function_name  = 43
	VerilogParserRULE_dumpfile_task                            = 44
	VerilogParserRULE_dumpvars_task                            = 45
	VerilogParserRULE_list_of_modules_or_variables             = 46
	VerilogParserRULE_module_or_variable                       = 47
	VerilogParserRULE_levels                                   = 48
	VerilogParserRULE_dumpoff_task                             = 49
	VerilogParserRULE_dumpon_task                              = 50
	VerilogParserRULE_dumpall_task                             = 51
	VerilogParserRULE_dumplimit_task                           = 52
	VerilogParserRULE_file_size                                = 53
	VerilogParserRULE_dumpflush_task                           = 54
	VerilogParserRULE_dumpports_task                           = 55
	VerilogParserRULE_scope_list                               = 56
	VerilogParserRULE_file_pathname                            = 57
	VerilogParserRULE_dumpportsoff_task                        = 58
	VerilogParserRULE_dumpportson_task                         = 59
	VerilogParserRULE_dumpportsall_task                        = 60
	VerilogParserRULE_dumpportslimit_task                      = 61
	VerilogParserRULE_dumpportsflush_task                      = 62
	VerilogParserRULE_library_text                             = 63
	VerilogParserRULE_library_description                      = 64
	VerilogParserRULE_library_declaration                      = 65
	VerilogParserRULE_include_statement                        = 66
	VerilogParserRULE_source_text                              = 67
	VerilogParserRULE_description                              = 68
	VerilogParserRULE_module_declaration                       = 69
	VerilogParserRULE_module_keyword                           = 70
	VerilogParserRULE_module_parameter_port_list               = 71
	VerilogParserRULE_list_of_ports                            = 72
	VerilogParserRULE_list_of_port_declarations                = 73
	VerilogParserRULE_port                                     = 74
	VerilogParserRULE_port_expression                          = 75
	VerilogParserRULE_port_reference                           = 76
	VerilogParserRULE_port_declaration                         = 77
	VerilogParserRULE_module_item                              = 78
	VerilogParserRULE_module_or_generate_item                  = 79
	VerilogParserRULE_module_or_generate_item_declaration      = 80
	VerilogParserRULE_non_port_module_item                     = 81
	VerilogParserRULE_parameter_override                       = 82
	VerilogParserRULE_config_declaration                       = 83
	VerilogParserRULE_design_statement                         = 84
	VerilogParserRULE_config_rule_statement                    = 85
	VerilogParserRULE_default_clause                           = 86
	VerilogParserRULE_inst_clause                              = 87
	VerilogParserRULE_inst_name                                = 88
	VerilogParserRULE_cell_clause                              = 89
	VerilogParserRULE_liblist_clause                           = 90
	VerilogParserRULE_use_clause                               = 91
	VerilogParserRULE_local_parameter_declaration              = 92
	VerilogParserRULE_parameter_declaration                    = 93
	VerilogParserRULE_specparam_declaration                    = 94
	VerilogParserRULE_parameter_type                           = 95
	VerilogParserRULE_inout_declaration                        = 96
	VerilogParserRULE_input_declaration                        = 97
	VerilogParserRULE_output_declaration                       = 98
	VerilogParserRULE_event_declaration                        = 99
	VerilogParserRULE_integer_declaration                      = 100
	VerilogParserRULE_net_declaration                          = 101
	VerilogParserRULE_real_declaration                         = 102
	VerilogParserRULE_realtime_declaration                     = 103
	VerilogParserRULE_reg_declaration                          = 104
	VerilogParserRULE_time_declaration                         = 105
	VerilogParserRULE_net_type                                 = 106
	VerilogParserRULE_output_variable_type                     = 107
	VerilogParserRULE_real_type                                = 108
	VerilogParserRULE_variable_type                            = 109
	VerilogParserRULE_drive_strength                           = 110
	VerilogParserRULE_strength0                                = 111
	VerilogParserRULE_strength1                                = 112
	VerilogParserRULE_charge_strength                          = 113
	VerilogParserRULE_delay3                                   = 114
	VerilogParserRULE_delay2                                   = 115
	VerilogParserRULE_delay_value                              = 116
	VerilogParserRULE_list_of_defparam_assignments             = 117
	VerilogParserRULE_list_of_event_identifiers                = 118
	VerilogParserRULE_list_of_net_decl_assignments             = 119
	VerilogParserRULE_list_of_net_identifiers                  = 120
	VerilogParserRULE_list_of_param_assignments                = 121
	VerilogParserRULE_list_of_port_identifiers                 = 122
	VerilogParserRULE_list_of_real_identifiers                 = 123
	VerilogParserRULE_list_of_specparam_assignments            = 124
	VerilogParserRULE_list_of_variable_identifiers             = 125
	VerilogParserRULE_list_of_variable_port_identifiers        = 126
	VerilogParserRULE_defparam_assignment                      = 127
	VerilogParserRULE_net_decl_assignment                      = 128
	VerilogParserRULE_param_assignment                         = 129
	VerilogParserRULE_specparam_assignment                     = 130
	VerilogParserRULE_pulse_control_specparam                  = 131
	VerilogParserRULE_error_limit_value                        = 132
	VerilogParserRULE_reject_limit_value                       = 133
	VerilogParserRULE_limit_value                              = 134
	VerilogParserRULE_dimension                                = 135
	VerilogParserRULE_range_                                   = 136
	VerilogParserRULE_function_declaration                     = 137
	VerilogParserRULE_function_item_declaration                = 138
	VerilogParserRULE_function_port_list                       = 139
	VerilogParserRULE_function_range_or_type                   = 140
	VerilogParserRULE_task_declaration                         = 141
	VerilogParserRULE_task_item_declaration                    = 142
	VerilogParserRULE_task_port_list                           = 143
	VerilogParserRULE_task_port_item                           = 144
	VerilogParserRULE_tf_input_declaration                     = 145
	VerilogParserRULE_tf_output_declaration                    = 146
	VerilogParserRULE_tf_inout_declaration                     = 147
	VerilogParserRULE_task_port_type                           = 148
	VerilogParserRULE_block_item_declaration                   = 149
	VerilogParserRULE_list_of_block_variable_identifiers       = 150
	VerilogParserRULE_list_of_block_real_identifiers           = 151
	VerilogParserRULE_block_variable_type                      = 152
	VerilogParserRULE_block_real_type                          = 153
	VerilogParserRULE_gate_instantiation                       = 154
	VerilogParserRULE_cmos_switch_instance                     = 155
	VerilogParserRULE_enable_gate_instance                     = 156
	VerilogParserRULE_mos_switch_instance                      = 157
	VerilogParserRULE_n_input_gate_instance                    = 158
	VerilogParserRULE_n_output_gate_instance                   = 159
	VerilogParserRULE_pass_switch_instance                     = 160
	VerilogParserRULE_pass_enable_switch_instance              = 161
	VerilogParserRULE_pull_gate_instance                       = 162
	VerilogParserRULE_name_of_gate_instance                    = 163
	VerilogParserRULE_pulldown_strength                        = 164
	VerilogParserRULE_pullup_strength                          = 165
	VerilogParserRULE_enable_terminal                          = 166
	VerilogParserRULE_inout_terminal                           = 167
	VerilogParserRULE_input_terminal                           = 168
	VerilogParserRULE_ncontrol_terminal                        = 169
	VerilogParserRULE_output_terminal                          = 170
	VerilogParserRULE_pcontrol_terminal                        = 171
	VerilogParserRULE_cmos_switchtype                          = 172
	VerilogParserRULE_enable_gatetype                          = 173
	VerilogParserRULE_mos_switchtype                           = 174
	VerilogParserRULE_n_input_gatetype                         = 175
	VerilogParserRULE_n_output_gatetype                        = 176
	VerilogParserRULE_pass_en_switchtype                       = 177
	VerilogParserRULE_pass_switchtype                          = 178
	VerilogParserRULE_module_instantiation                     = 179
	VerilogParserRULE_parameter_value_assignment               = 180
	VerilogParserRULE_list_of_parameter_assignments            = 181
	VerilogParserRULE_ordered_parameter_assignment             = 182
	VerilogParserRULE_named_parameter_assignment               = 183
	VerilogParserRULE_module_instance                          = 184
	VerilogParserRULE_name_of_module_instance                  = 185
	VerilogParserRULE_list_of_port_connections                 = 186
	VerilogParserRULE_ordered_port_connection                  = 187
	VerilogParserRULE_named_port_connection                    = 188
	VerilogParserRULE_generate_region                          = 189
	VerilogParserRULE_genvar_declaration                       = 190
	VerilogParserRULE_list_of_genvar_identifiers               = 191
	VerilogParserRULE_loop_generate_construct                  = 192
	VerilogParserRULE_genvar_initialization                    = 193
	VerilogParserRULE_genvar_expression                        = 194
	VerilogParserRULE_genvar_iteration                         = 195
	VerilogParserRULE_genvar_primary                           = 196
	VerilogParserRULE_conditional_generate_construct           = 197
	VerilogParserRULE_if_generate_construct                    = 198
	VerilogParserRULE_case_generate_construct                  = 199
	VerilogParserRULE_generate_block                           = 200
	VerilogParserRULE_generate_block_or_null                   = 201
	VerilogParserRULE_continuous_assign                        = 202
	VerilogParserRULE_list_of_net_assignments                  = 203
	VerilogParserRULE_net_assignment                           = 204
	VerilogParserRULE_initial_construct                        = 205
	VerilogParserRULE_always_construct                         = 206
	VerilogParserRULE_blocking_assignment                      = 207
	VerilogParserRULE_nonblocking_assignment                   = 208
	VerilogParserRULE_procedural_continuous_assignments        = 209
	VerilogParserRULE_variable_assignment                      = 210
	VerilogParserRULE_par_block                                = 211
	VerilogParserRULE_seq_block                                = 212
	VerilogParserRULE_statement                                = 213
	VerilogParserRULE_statement_or_null                        = 214
	VerilogParserRULE_function_statement                       = 215
	VerilogParserRULE_delay_control                            = 216
	VerilogParserRULE_delay_or_event_control                   = 217
	VerilogParserRULE_disable_statement                        = 218
	VerilogParserRULE_event_control                            = 219
	VerilogParserRULE_event_trigger                            = 220
	VerilogParserRULE_event_expression                         = 221
	VerilogParserRULE_event_primary                            = 222
	VerilogParserRULE_procedural_timing_control                = 223
	VerilogParserRULE_procedural_timing_control_statement      = 224
	VerilogParserRULE_wait_statement                           = 225
	VerilogParserRULE_conditional_statement                    = 226
	VerilogParserRULE_case_statement                           = 227
	VerilogParserRULE_case_item                                = 228
	VerilogParserRULE_loop_statement                           = 229
	VerilogParserRULE_system_task_enable                       = 230
	VerilogParserRULE_task_enable                              = 231
	VerilogParserRULE_specify_block                            = 232
	VerilogParserRULE_specify_item                             = 233
	VerilogParserRULE_pulsestyle_declaration                   = 234
	VerilogParserRULE_showcancelled_declaration                = 235
	VerilogParserRULE_path_declaration                         = 236
	VerilogParserRULE_simple_path_declaration                  = 237
	VerilogParserRULE_parallel_path_description                = 238
	VerilogParserRULE_full_path_description                    = 239
	VerilogParserRULE_list_of_path_inputs                      = 240
	VerilogParserRULE_list_of_path_outputs                     = 241
	VerilogParserRULE_specify_input_terminal_descriptor        = 242
	VerilogParserRULE_specify_output_terminal_descriptor       = 243
	VerilogParserRULE_input_identifier                         = 244
	VerilogParserRULE_output_identifier                        = 245
	VerilogParserRULE_path_delay_value                         = 246
	VerilogParserRULE_list_of_path_delay_expressions           = 247
	VerilogParserRULE_t_path_delay_expression                  = 248
	VerilogParserRULE_trise_path_delay_expression              = 249
	VerilogParserRULE_tfall_path_delay_expression              = 250
	VerilogParserRULE_tz_path_delay_expression                 = 251
	VerilogParserRULE_t01_path_delay_expression                = 252
	VerilogParserRULE_t10_path_delay_expression                = 253
	VerilogParserRULE_t0z_path_delay_expression                = 254
	VerilogParserRULE_tz1_path_delay_expression                = 255
	VerilogParserRULE_t1z_path_delay_expression                = 256
	VerilogParserRULE_tz0_path_delay_expression                = 257
	VerilogParserRULE_t0x_path_delay_expression                = 258
	VerilogParserRULE_tx1_path_delay_expression                = 259
	VerilogParserRULE_t1x_path_delay_expression                = 260
	VerilogParserRULE_tx0_path_delay_expression                = 261
	VerilogParserRULE_txz_path_delay_expression                = 262
	VerilogParserRULE_tzx_path_delay_expression                = 263
	VerilogParserRULE_path_delay_expression                    = 264
	VerilogParserRULE_edge_sensitive_path_declaration          = 265
	VerilogParserRULE_parallel_edge_sensitive_path_description = 266
	VerilogParserRULE_full_edge_sensitive_path_description     = 267
	VerilogParserRULE_data_source_expression                   = 268
	VerilogParserRULE_edge_identifier                          = 269
	VerilogParserRULE_state_dependent_path_declaration         = 270
	VerilogParserRULE_polarity_operator                        = 271
	VerilogParserRULE_concatenation                            = 272
	VerilogParserRULE_constant_concatenation                   = 273
	VerilogParserRULE_constant_multiple_concatenation          = 274
	VerilogParserRULE_module_path_concatenation                = 275
	VerilogParserRULE_module_path_multiple_concatenation       = 276
	VerilogParserRULE_multiple_concatenation                   = 277
	VerilogParserRULE_constant_function_call                   = 278
	VerilogParserRULE_constant_system_function_call            = 279
	VerilogParserRULE_function_call                            = 280
	VerilogParserRULE_system_function_call                     = 281
	VerilogParserRULE_base_expression                          = 282
	VerilogParserRULE_constant_base_expression                 = 283
	VerilogParserRULE_constant_expression                      = 284
	VerilogParserRULE_constant_mintypmax_expression            = 285
	VerilogParserRULE_constant_range_expression                = 286
	VerilogParserRULE_dimension_constant_expression            = 287
	VerilogParserRULE_expression                               = 288
	VerilogParserRULE_lsb_constant_expression                  = 289
	VerilogParserRULE_mintypmax_expression                     = 290
	VerilogParserRULE_module_path_expression                   = 291
	VerilogParserRULE_module_path_mintypmax_expression         = 292
	VerilogParserRULE_msb_constant_expression                  = 293
	VerilogParserRULE_range_expression                         = 294
	VerilogParserRULE_width_constant_expression                = 295
	VerilogParserRULE_constant_primary                         = 296
	VerilogParserRULE_module_path_primary                      = 297
	VerilogParserRULE_primary                                  = 298
	VerilogParserRULE_net_lvalue                               = 299
	VerilogParserRULE_variable_lvalue                          = 300
	VerilogParserRULE_unary_operator                           = 301
	VerilogParserRULE_binary_operator                          = 302
	VerilogParserRULE_unary_module_path_operator               = 303
	VerilogParserRULE_binary_module_path_operator              = 304
	VerilogParserRULE_number                                   = 305
	VerilogParserRULE_attribute_instance                       = 306
	VerilogParserRULE_attr_spec                                = 307
	VerilogParserRULE_attr_name                                = 308
	VerilogParserRULE_block_identifier                         = 309
	VerilogParserRULE_cell_identifier                          = 310
	VerilogParserRULE_config_identifier                        = 311
	VerilogParserRULE_event_identifier                         = 312
	VerilogParserRULE_function_identifier                      = 313
	VerilogParserRULE_gate_instance_identifier                 = 314
	VerilogParserRULE_generate_block_identifier                = 315
	VerilogParserRULE_genvar_identifier                        = 316
	VerilogParserRULE_hierarchical_block_identifier            = 317
	VerilogParserRULE_hierarchical_event_identifier            = 318
	VerilogParserRULE_hierarchical_function_identifier         = 319
	VerilogParserRULE_hierarchical_identifier                  = 320
	VerilogParserRULE_hierarchical_net_identifier              = 321
	VerilogParserRULE_hierarchical_parameter_identifier        = 322
	VerilogParserRULE_hierarchical_variable_identifier         = 323
	VerilogParserRULE_hierarchical_task_identifier             = 324
	VerilogParserRULE_identifier                               = 325
	VerilogParserRULE_inout_port_identifier                    = 326
	VerilogParserRULE_input_port_identifier                    = 327
	VerilogParserRULE_instance_identifier                      = 328
	VerilogParserRULE_library_identifier                       = 329
	VerilogParserRULE_module_identifier                        = 330
	VerilogParserRULE_module_instance_identifier               = 331
	VerilogParserRULE_net_identifier                           = 332
	VerilogParserRULE_output_port_identifier                   = 333
	VerilogParserRULE_parameter_identifier                     = 334
	VerilogParserRULE_port_identifier                          = 335
	VerilogParserRULE_real_identifier                          = 336
	VerilogParserRULE_specparam_identifier                     = 337
	VerilogParserRULE_system_function_identifier               = 338
	VerilogParserRULE_system_task_identifier                   = 339
	VerilogParserRULE_task_identifier                          = 340
	VerilogParserRULE_terminal_identifier                      = 341
	VerilogParserRULE_topmodule_identifier                     = 342
	VerilogParserRULE_udp_identifier                           = 343
	VerilogParserRULE_udp_instance_identifier                  = 344
	VerilogParserRULE_variable_identifier                      = 345
)

// IDisplay_tasksContext is an interface to support dynamic dispatch.
type IDisplay_tasksContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplay_tasksContext differentiates from other interfaces.
	IsDisplay_tasksContext()
}

type Display_tasksContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplay_tasksContext() *Display_tasksContext {
	var p = new(Display_tasksContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_display_tasks
	return p
}

func (*Display_tasksContext) IsDisplay_tasksContext() {}

func NewDisplay_tasksContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Display_tasksContext {
	var p = new(Display_tasksContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_display_tasks

	return p
}

func (s *Display_tasksContext) GetParser() antlr.Parser { return s.parser }

func (s *Display_tasksContext) Display_task_name() IDisplay_task_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplay_task_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisplay_task_nameContext)
}

func (s *Display_tasksContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Display_tasksContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Display_tasksContext) List_of_arguments() IList_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_argumentsContext)
}

func (s *Display_tasksContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Display_tasksContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Display_tasksContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Display_tasksContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDisplay_tasks(s)
	}
}

func (s *Display_tasksContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDisplay_tasks(s)
	}
}

func (p *VerilogParser) Display_tasks() (localctx IDisplay_tasksContext) {
	this := p
	_ = this

	localctx = NewDisplay_tasksContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, VerilogParserRULE_display_tasks)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(692)
		p.Display_task_name()
	}
	p.SetState(697)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_PARENTHESIS {
		{
			p.SetState(693)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(694)
			p.List_of_arguments()
		}
		{
			p.SetState(695)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}
	{
		p.SetState(699)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IDisplay_task_nameContext is an interface to support dynamic dispatch.
type IDisplay_task_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplay_task_nameContext differentiates from other interfaces.
	IsDisplay_task_nameContext()
}

type Display_task_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplay_task_nameContext() *Display_task_nameContext {
	var p = new(Display_task_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_display_task_name
	return p
}

func (*Display_task_nameContext) IsDisplay_task_nameContext() {}

func NewDisplay_task_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Display_task_nameContext {
	var p = new(Display_task_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_display_task_name

	return p
}

func (s *Display_task_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Display_task_nameContext) DOLLAR_DISPLAY() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DISPLAY, 0)
}

func (s *Display_task_nameContext) DOLLAR_DISPLAYB() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DISPLAYB, 0)
}

func (s *Display_task_nameContext) DOLLAR_DISPLAYO() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DISPLAYO, 0)
}

func (s *Display_task_nameContext) DOLLAR_DISPLAYH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DISPLAYH, 0)
}

func (s *Display_task_nameContext) DOLLAR_WRITE() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_WRITE, 0)
}

func (s *Display_task_nameContext) DOLLAR_WRITEB() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_WRITEB, 0)
}

func (s *Display_task_nameContext) DOLLAR_WRITEO() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_WRITEO, 0)
}

func (s *Display_task_nameContext) DOLLAR_WRITEH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_WRITEH, 0)
}

func (s *Display_task_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Display_task_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Display_task_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDisplay_task_name(s)
	}
}

func (s *Display_task_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDisplay_task_name(s)
	}
}

func (p *VerilogParser) Display_task_name() (localctx IDisplay_task_nameContext) {
	this := p
	_ = this

	localctx = NewDisplay_task_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, VerilogParserRULE_display_task_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(701)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-125)&-(0x1f+1)) == 0 && ((1<<uint((_la-125)))&((1<<(VerilogParserDOLLAR_DISPLAY-125))|(1<<(VerilogParserDOLLAR_DISPLAYB-125))|(1<<(VerilogParserDOLLAR_DISPLAYH-125))|(1<<(VerilogParserDOLLAR_DISPLAYO-125))|(1<<(VerilogParserDOLLAR_WRITE-125))|(1<<(VerilogParserDOLLAR_WRITEB-125))|(1<<(VerilogParserDOLLAR_WRITEH-125))|(1<<(VerilogParserDOLLAR_WRITEO-125)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IList_of_argumentsContext is an interface to support dynamic dispatch.
type IList_of_argumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_argumentsContext differentiates from other interfaces.
	IsList_of_argumentsContext()
}

type List_of_argumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_argumentsContext() *List_of_argumentsContext {
	var p = new(List_of_argumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_arguments
	return p
}

func (*List_of_argumentsContext) IsList_of_argumentsContext() {}

func NewList_of_argumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_argumentsContext {
	var p = new(List_of_argumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_arguments

	return p
}

func (s *List_of_argumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_argumentsContext) AllArgument() []IArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentContext)(nil)).Elem())
	var tst = make([]IArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentContext)
		}
	}

	return tst
}

func (s *List_of_argumentsContext) Argument(i int) IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *List_of_argumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_argumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_argumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_argumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_argumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_arguments(s)
	}
}

func (s *List_of_argumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_arguments(s)
	}
}

func (p *VerilogParser) List_of_arguments() (localctx IList_of_argumentsContext) {
	this := p
	_ = this

	localctx = NewList_of_argumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, VerilogParserRULE_list_of_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserREALTIME || _la == VerilogParserTIME || (((_la-208)&-(0x1f+1)) == 0 && ((1<<uint((_la-208)))&((1<<(VerilogParserDOLLAR_STIME-208))|(1<<(VerilogParserDOLLAR_BITSTOREAL-208))|(1<<(VerilogParserDOLLAR_ITOR-208))|(1<<(VerilogParserDOLLAR_SIGNED-208))|(1<<(VerilogParserDOLLAR_REALTOBITS-208))|(1<<(VerilogParserDOLLAR_RTOI-208))|(1<<(VerilogParserDOLLAR_UNSIGNED-208))|(1<<(VerilogParserDOLLAR_RANDOM-208))|(1<<(VerilogParserDOLLAR_DIST_ERLANG-208))|(1<<(VerilogParserDOLLAR_DIST_NORMAL-208))|(1<<(VerilogParserDOLLAR_DIST_T-208))|(1<<(VerilogParserDOLLAR_DIST_CHI_SQUARE-208))|(1<<(VerilogParserDOLLAR_DIST_EXPONENTIAL-208))|(1<<(VerilogParserDOLLAR_DIST_POISSON-208))|(1<<(VerilogParserDOLLAR_DIST_UNIFORM-208))|(1<<(VerilogParserDOLLAR_CLOG2-208))|(1<<(VerilogParserDOLLAR_LN-208))|(1<<(VerilogParserDOLLAR_LOG10-208))|(1<<(VerilogParserDOLLAR_EXP-208))|(1<<(VerilogParserDOLLAR_SQRT-208))|(1<<(VerilogParserDOLLAR_POW-208))|(1<<(VerilogParserDOLLAR_FLOOR-208))|(1<<(VerilogParserDOLLAR_CEIL-208))|(1<<(VerilogParserDOLLAR_SIN-208))|(1<<(VerilogParserDOLLAR_COS-208))|(1<<(VerilogParserDOLLAR_TAN-208))|(1<<(VerilogParserDOLLAR_ASIN-208))|(1<<(VerilogParserDOLLAR_ACOS-208))|(1<<(VerilogParserDOLLAR_ATAN-208))|(1<<(VerilogParserDOLLAR_ATAN2-208)))) != 0) || (((_la-240)&-(0x1f+1)) == 0 && ((1<<uint((_la-240)))&((1<<(VerilogParserDOLLAR_HYPOT-240))|(1<<(VerilogParserDOLLAR_SINH-240))|(1<<(VerilogParserDOLLAR_COSH-240))|(1<<(VerilogParserDOLLAR_TANH-240))|(1<<(VerilogParserDOLLAR_ASINH-240))|(1<<(VerilogParserDOLLAR_ACOSH-240))|(1<<(VerilogParserDOLLAR_ATANH-240)))) != 0) || (((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282))|(1<<(VerilogParserSTRING-282))|(1<<(VerilogParserESCAPED_IDENTIFIER-282))|(1<<(VerilogParserSIMPLE_IDENTIFIER-282))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-282))|(1<<(VerilogParserLEFT_PARENTHESIS-282))|(1<<(VerilogParserLEFT_BRACE-282))|(1<<(VerilogParserPLUS-282))|(1<<(VerilogParserMINUS-282))|(1<<(VerilogParserEXCLAMATION_MARK-282))|(1<<(VerilogParserTILDE-282))|(1<<(VerilogParserAMPERSAND-282))|(1<<(VerilogParserTILDE_AMPERSAND-282))|(1<<(VerilogParserVERTICAL_BAR-282))|(1<<(VerilogParserTILDE_VERTICAL_BAR-282))|(1<<(VerilogParserCARET-282))|(1<<(VerilogParserTILDE_CARET-282))|(1<<(VerilogParserCARET_TILDE-282)))) != 0) {
		{
			p.SetState(703)
			p.Argument()
		}

	}
	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(706)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(707)
			p.Argument()
		}

		p.SetState(712)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArgumentContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *ArgumentContext) Time_function() ITime_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_functionContext)
}

func (s *ArgumentContext) Stime_function() IStime_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStime_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStime_functionContext)
}

func (s *ArgumentContext) Realtime_function() IRealtime_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRealtime_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRealtime_functionContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (p *VerilogParser) Argument() (localctx IArgumentContext) {
	this := p
	_ = this

	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, VerilogParserRULE_argument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(718)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(713)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(714)
			p.constant_expression(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(715)
			p.Time_function()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(716)
			p.Stime_function()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(717)
			p.Realtime_function()
		}

	}

	return localctx
}

// IStrobe_tasksContext is an interface to support dynamic dispatch.
type IStrobe_tasksContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrobe_tasksContext differentiates from other interfaces.
	IsStrobe_tasksContext()
}

type Strobe_tasksContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrobe_tasksContext() *Strobe_tasksContext {
	var p = new(Strobe_tasksContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_strobe_tasks
	return p
}

func (*Strobe_tasksContext) IsStrobe_tasksContext() {}

func NewStrobe_tasksContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Strobe_tasksContext {
	var p = new(Strobe_tasksContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_strobe_tasks

	return p
}

func (s *Strobe_tasksContext) GetParser() antlr.Parser { return s.parser }

func (s *Strobe_tasksContext) Strobe_task_name() IStrobe_task_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrobe_task_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrobe_task_nameContext)
}

func (s *Strobe_tasksContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Strobe_tasksContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Strobe_tasksContext) List_of_arguments() IList_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_argumentsContext)
}

func (s *Strobe_tasksContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Strobe_tasksContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Strobe_tasksContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Strobe_tasksContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStrobe_tasks(s)
	}
}

func (s *Strobe_tasksContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStrobe_tasks(s)
	}
}

func (p *VerilogParser) Strobe_tasks() (localctx IStrobe_tasksContext) {
	this := p
	_ = this

	localctx = NewStrobe_tasksContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, VerilogParserRULE_strobe_tasks)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(720)
		p.Strobe_task_name()
	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_PARENTHESIS {
		{
			p.SetState(721)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(722)
			p.List_of_arguments()
		}
		{
			p.SetState(723)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}
	{
		p.SetState(727)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IStrobe_task_nameContext is an interface to support dynamic dispatch.
type IStrobe_task_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrobe_task_nameContext differentiates from other interfaces.
	IsStrobe_task_nameContext()
}

type Strobe_task_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrobe_task_nameContext() *Strobe_task_nameContext {
	var p = new(Strobe_task_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_strobe_task_name
	return p
}

func (*Strobe_task_nameContext) IsStrobe_task_nameContext() {}

func NewStrobe_task_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Strobe_task_nameContext {
	var p = new(Strobe_task_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_strobe_task_name

	return p
}

func (s *Strobe_task_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Strobe_task_nameContext) DOLLAR_STROBE() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_STROBE, 0)
}

func (s *Strobe_task_nameContext) DOLLAR_STROBEB() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_STROBEB, 0)
}

func (s *Strobe_task_nameContext) DOLLAR_STROBEO() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_STROBEO, 0)
}

func (s *Strobe_task_nameContext) DOLLAR_STROBEH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_STROBEH, 0)
}

func (s *Strobe_task_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Strobe_task_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Strobe_task_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStrobe_task_name(s)
	}
}

func (s *Strobe_task_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStrobe_task_name(s)
	}
}

func (p *VerilogParser) Strobe_task_name() (localctx IStrobe_task_nameContext) {
	this := p
	_ = this

	localctx = NewStrobe_task_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, VerilogParserRULE_strobe_task_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-133)&-(0x1f+1)) == 0 && ((1<<uint((_la-133)))&((1<<(VerilogParserDOLLAR_STROBE-133))|(1<<(VerilogParserDOLLAR_STROBEB-133))|(1<<(VerilogParserDOLLAR_STROBEH-133))|(1<<(VerilogParserDOLLAR_STROBEO-133)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMonitor_tasksContext is an interface to support dynamic dispatch.
type IMonitor_tasksContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMonitor_tasksContext differentiates from other interfaces.
	IsMonitor_tasksContext()
}

type Monitor_tasksContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMonitor_tasksContext() *Monitor_tasksContext {
	var p = new(Monitor_tasksContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_monitor_tasks
	return p
}

func (*Monitor_tasksContext) IsMonitor_tasksContext() {}

func NewMonitor_tasksContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Monitor_tasksContext {
	var p = new(Monitor_tasksContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_monitor_tasks

	return p
}

func (s *Monitor_tasksContext) GetParser() antlr.Parser { return s.parser }

func (s *Monitor_tasksContext) Monitor_task_name() IMonitor_task_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMonitor_task_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMonitor_task_nameContext)
}

func (s *Monitor_tasksContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Monitor_tasksContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Monitor_tasksContext) List_of_arguments() IList_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_argumentsContext)
}

func (s *Monitor_tasksContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Monitor_tasksContext) DOLLAR_MONITORON() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_MONITORON, 0)
}

func (s *Monitor_tasksContext) DOLLAR_MONITOROFF() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_MONITOROFF, 0)
}

func (s *Monitor_tasksContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Monitor_tasksContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Monitor_tasksContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMonitor_tasks(s)
	}
}

func (s *Monitor_tasksContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMonitor_tasks(s)
	}
}

func (p *VerilogParser) Monitor_tasks() (localctx IMonitor_tasksContext) {
	this := p
	_ = this

	localctx = NewMonitor_tasksContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, VerilogParserRULE_monitor_tasks)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(744)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserDOLLAR_MONITOR, VerilogParserDOLLAR_MONITORB, VerilogParserDOLLAR_MONITORH, VerilogParserDOLLAR_MONITORO:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(731)
			p.Monitor_task_name()
		}
		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(732)
				p.Match(VerilogParserLEFT_PARENTHESIS)
			}
			{
				p.SetState(733)
				p.List_of_arguments()
			}
			{
				p.SetState(734)
				p.Match(VerilogParserRIGHT_PARENTHESIS)
			}

		}
		{
			p.SetState(738)
			p.Match(VerilogParserSEMICOLON)
		}

	case VerilogParserDOLLAR_MONITORON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(740)
			p.Match(VerilogParserDOLLAR_MONITORON)
		}
		{
			p.SetState(741)
			p.Match(VerilogParserSEMICOLON)
		}

	case VerilogParserDOLLAR_MONITOROFF:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(742)
			p.Match(VerilogParserDOLLAR_MONITOROFF)
		}
		{
			p.SetState(743)
			p.Match(VerilogParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMonitor_task_nameContext is an interface to support dynamic dispatch.
type IMonitor_task_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMonitor_task_nameContext differentiates from other interfaces.
	IsMonitor_task_nameContext()
}

type Monitor_task_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMonitor_task_nameContext() *Monitor_task_nameContext {
	var p = new(Monitor_task_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_monitor_task_name
	return p
}

func (*Monitor_task_nameContext) IsMonitor_task_nameContext() {}

func NewMonitor_task_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Monitor_task_nameContext {
	var p = new(Monitor_task_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_monitor_task_name

	return p
}

func (s *Monitor_task_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Monitor_task_nameContext) DOLLAR_MONITOR() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_MONITOR, 0)
}

func (s *Monitor_task_nameContext) DOLLAR_MONITORB() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_MONITORB, 0)
}

func (s *Monitor_task_nameContext) DOLLAR_MONITORO() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_MONITORO, 0)
}

func (s *Monitor_task_nameContext) DOLLAR_MONITORH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_MONITORH, 0)
}

func (s *Monitor_task_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Monitor_task_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Monitor_task_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMonitor_task_name(s)
	}
}

func (s *Monitor_task_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMonitor_task_name(s)
	}
}

func (p *VerilogParser) Monitor_task_name() (localctx IMonitor_task_nameContext) {
	this := p
	_ = this

	localctx = NewMonitor_task_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, VerilogParserRULE_monitor_task_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-137)&-(0x1f+1)) == 0 && ((1<<uint((_la-137)))&((1<<(VerilogParserDOLLAR_MONITOR-137))|(1<<(VerilogParserDOLLAR_MONITORB-137))|(1<<(VerilogParserDOLLAR_MONITORH-137))|(1<<(VerilogParserDOLLAR_MONITORO-137)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFile_open_functionContext is an interface to support dynamic dispatch.
type IFile_open_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_open_functionContext differentiates from other interfaces.
	IsFile_open_functionContext()
}

type File_open_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_open_functionContext() *File_open_functionContext {
	var p = new(File_open_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_file_open_function
	return p
}

func (*File_open_functionContext) IsFile_open_functionContext() {}

func NewFile_open_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_open_functionContext {
	var p = new(File_open_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_file_open_function

	return p
}

func (s *File_open_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *File_open_functionContext) Multi_channel_descriptor() IMulti_channel_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_channel_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_channel_descriptorContext)
}

func (s *File_open_functionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *File_open_functionContext) DOLLAR_FOPEN() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FOPEN, 0)
}

func (s *File_open_functionContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *File_open_functionContext) File_name() IFile_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *File_open_functionContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *File_open_functionContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *File_open_functionContext) Fd() IFdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFdContext)
}

func (s *File_open_functionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, 0)
}

func (s *File_open_functionContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *File_open_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_open_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_open_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFile_open_function(s)
	}
}

func (s *File_open_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFile_open_function(s)
	}
}

func (p *VerilogParser) File_open_function() (localctx IFile_open_functionContext) {
	this := p
	_ = this

	localctx = NewFile_open_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, VerilogParserRULE_file_open_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(766)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(748)
			p.Multi_channel_descriptor()
		}
		{
			p.SetState(749)
			p.Match(VerilogParserEQUAL)
		}
		{
			p.SetState(750)
			p.Match(VerilogParserDOLLAR_FOPEN)
		}
		{
			p.SetState(751)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(752)
			p.File_name()
		}
		{
			p.SetState(753)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(754)
			p.Match(VerilogParserSEMICOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(756)
			p.Fd()
		}
		{
			p.SetState(757)
			p.Match(VerilogParserEQUAL)
		}
		{
			p.SetState(758)
			p.Match(VerilogParserDOLLAR_FOPEN)
		}
		{
			p.SetState(759)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(760)
			p.File_name()
		}
		{
			p.SetState(761)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(762)
			p.Type_()
		}
		{
			p.SetState(763)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(764)
			p.Match(VerilogParserSEMICOLON)
		}

	}

	return localctx
}

// IFile_close_taskContext is an interface to support dynamic dispatch.
type IFile_close_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_close_taskContext differentiates from other interfaces.
	IsFile_close_taskContext()
}

type File_close_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_close_taskContext() *File_close_taskContext {
	var p = new(File_close_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_file_close_task
	return p
}

func (*File_close_taskContext) IsFile_close_taskContext() {}

func NewFile_close_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_close_taskContext {
	var p = new(File_close_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_file_close_task

	return p
}

func (s *File_close_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *File_close_taskContext) DOLLAR_FCLOSE() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FCLOSE, 0)
}

func (s *File_close_taskContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *File_close_taskContext) Multi_channel_descriptor() IMulti_channel_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_channel_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_channel_descriptorContext)
}

func (s *File_close_taskContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *File_close_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *File_close_taskContext) Fd() IFdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFdContext)
}

func (s *File_close_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_close_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_close_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFile_close_task(s)
	}
}

func (s *File_close_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFile_close_task(s)
	}
}

func (p *VerilogParser) File_close_task() (localctx IFile_close_taskContext) {
	this := p
	_ = this

	localctx = NewFile_close_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, VerilogParserRULE_file_close_task)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(780)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(768)
			p.Match(VerilogParserDOLLAR_FCLOSE)
		}
		{
			p.SetState(769)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(770)
			p.Multi_channel_descriptor()
		}
		{
			p.SetState(771)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(772)
			p.Match(VerilogParserSEMICOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(774)
			p.Match(VerilogParserDOLLAR_FCLOSE)
		}
		{
			p.SetState(775)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(776)
			p.Fd()
		}
		{
			p.SetState(777)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(778)
			p.Match(VerilogParserSEMICOLON)
		}

	}

	return localctx
}

// IMulti_channel_descriptorContext is an interface to support dynamic dispatch.
type IMulti_channel_descriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_channel_descriptorContext differentiates from other interfaces.
	IsMulti_channel_descriptorContext()
}

type Multi_channel_descriptorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_channel_descriptorContext() *Multi_channel_descriptorContext {
	var p = new(Multi_channel_descriptorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_multi_channel_descriptor
	return p
}

func (*Multi_channel_descriptorContext) IsMulti_channel_descriptorContext() {}

func NewMulti_channel_descriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_channel_descriptorContext {
	var p = new(Multi_channel_descriptorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_multi_channel_descriptor

	return p
}

func (s *Multi_channel_descriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_channel_descriptorContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Multi_channel_descriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_channel_descriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_channel_descriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMulti_channel_descriptor(s)
	}
}

func (s *Multi_channel_descriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMulti_channel_descriptor(s)
	}
}

func (p *VerilogParser) Multi_channel_descriptor() (localctx IMulti_channel_descriptorContext) {
	this := p
	_ = this

	localctx = NewMulti_channel_descriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, VerilogParserRULE_multi_channel_descriptor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(782)
		p.Variable_identifier()
	}

	return localctx
}

// IFdContext is an interface to support dynamic dispatch.
type IFdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFdContext differentiates from other interfaces.
	IsFdContext()
}

type FdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFdContext() *FdContext {
	var p = new(FdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_fd
	return p
}

func (*FdContext) IsFdContext() {}

func NewFdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FdContext {
	var p = new(FdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_fd

	return p
}

func (s *FdContext) GetParser() antlr.Parser { return s.parser }

func (s *FdContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *FdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFd(s)
	}
}

func (s *FdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFd(s)
	}
}

func (p *VerilogParser) Fd() (localctx IFdContext) {
	this := p
	_ = this

	localctx = NewFdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, VerilogParserRULE_fd)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.Variable_identifier()
	}

	return localctx
}

// IFile_nameContext is an interface to support dynamic dispatch.
type IFile_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_nameContext differentiates from other interfaces.
	IsFile_nameContext()
}

type File_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_nameContext() *File_nameContext {
	var p = new(File_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_file_name
	return p
}

func (*File_nameContext) IsFile_nameContext() {}

func NewFile_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_nameContext {
	var p = new(File_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_file_name

	return p
}

func (s *File_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *File_nameContext) STRING() antlr.TerminalNode {
	return s.GetToken(VerilogParserSTRING, 0)
}

func (s *File_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFile_name(s)
	}
}

func (s *File_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFile_name(s)
	}
}

func (p *VerilogParser) File_name() (localctx IFile_nameContext) {
	this := p
	_ = this

	localctx = NewFile_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, VerilogParserRULE_file_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(786)
		p.Match(VerilogParserSTRING)
	}

	return localctx
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_type_
	return p
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) STRING() antlr.TerminalNode {
	return s.GetToken(VerilogParserSTRING, 0)
}

func (s *Type_Context) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitType_(s)
	}
}

func (p *VerilogParser) Type_() (localctx IType_Context) {
	this := p
	_ = this

	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, VerilogParserRULE_type_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(790)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(788)
			p.Match(VerilogParserSTRING)
		}

	case VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(789)
			p.Variable_identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFile_output_tasksContext is an interface to support dynamic dispatch.
type IFile_output_tasksContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_output_tasksContext differentiates from other interfaces.
	IsFile_output_tasksContext()
}

type File_output_tasksContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_output_tasksContext() *File_output_tasksContext {
	var p = new(File_output_tasksContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_file_output_tasks
	return p
}

func (*File_output_tasksContext) IsFile_output_tasksContext() {}

func NewFile_output_tasksContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_output_tasksContext {
	var p = new(File_output_tasksContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_file_output_tasks

	return p
}

func (s *File_output_tasksContext) GetParser() antlr.Parser { return s.parser }

func (s *File_output_tasksContext) File_output_task_name() IFile_output_task_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_output_task_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_output_task_nameContext)
}

func (s *File_output_tasksContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *File_output_tasksContext) Multi_channel_descriptor() IMulti_channel_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_channel_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_channel_descriptorContext)
}

func (s *File_output_tasksContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *File_output_tasksContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *File_output_tasksContext) COMMA() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, 0)
}

func (s *File_output_tasksContext) List_of_arguments() IList_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_argumentsContext)
}

func (s *File_output_tasksContext) Fd() IFdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFdContext)
}

func (s *File_output_tasksContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_output_tasksContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_output_tasksContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFile_output_tasks(s)
	}
}

func (s *File_output_tasksContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFile_output_tasks(s)
	}
}

func (p *VerilogParser) File_output_tasks() (localctx IFile_output_tasksContext) {
	this := p
	_ = this

	localctx = NewFile_output_tasksContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, VerilogParserRULE_file_output_tasks)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(812)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(792)
			p.File_output_task_name()
		}
		{
			p.SetState(793)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(794)
			p.Multi_channel_descriptor()
		}
		p.SetState(797)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserCOMMA {
			{
				p.SetState(795)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(796)
				p.List_of_arguments()
			}

		}
		{
			p.SetState(799)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(800)
			p.Match(VerilogParserSEMICOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(802)
			p.File_output_task_name()
		}
		{
			p.SetState(803)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(804)
			p.Fd()
		}
		p.SetState(807)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserCOMMA {
			{
				p.SetState(805)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(806)
				p.List_of_arguments()
			}

		}
		{
			p.SetState(809)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(810)
			p.Match(VerilogParserSEMICOLON)
		}

	}

	return localctx
}

// IFile_output_task_nameContext is an interface to support dynamic dispatch.
type IFile_output_task_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_output_task_nameContext differentiates from other interfaces.
	IsFile_output_task_nameContext()
}

type File_output_task_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_output_task_nameContext() *File_output_task_nameContext {
	var p = new(File_output_task_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_file_output_task_name
	return p
}

func (*File_output_task_nameContext) IsFile_output_task_nameContext() {}

func NewFile_output_task_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_output_task_nameContext {
	var p = new(File_output_task_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_file_output_task_name

	return p
}

func (s *File_output_task_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *File_output_task_nameContext) DOLLAR_FDISPLAY() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FDISPLAY, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FDISPLAYB() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FDISPLAYB, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FDISPLAYH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FDISPLAYH, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FDISPLAYO() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FDISPLAYO, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FWRITE() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FWRITE, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FWRITEB() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FWRITEB, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FWRITEH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FWRITEH, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FWRITEO() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FWRITEO, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FSTROBE() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FSTROBE, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FSTROBEB() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FSTROBEB, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FSTROBEH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FSTROBEH, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FSTROBEO() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FSTROBEO, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FMONITOR() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FMONITOR, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FMONITORB() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FMONITORB, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FMONITORH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FMONITORH, 0)
}

func (s *File_output_task_nameContext) DOLLAR_FMONITORO() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FMONITORO, 0)
}

func (s *File_output_task_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_output_task_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_output_task_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFile_output_task_name(s)
	}
}

func (s *File_output_task_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFile_output_task_name(s)
	}
}

func (p *VerilogParser) File_output_task_name() (localctx IFile_output_task_nameContext) {
	this := p
	_ = this

	localctx = NewFile_output_task_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, VerilogParserRULE_file_output_task_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(814)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-144)&-(0x1f+1)) == 0 && ((1<<uint((_la-144)))&((1<<(VerilogParserDOLLAR_FDISPLAY-144))|(1<<(VerilogParserDOLLAR_FDISPLAYB-144))|(1<<(VerilogParserDOLLAR_FDISPLAYH-144))|(1<<(VerilogParserDOLLAR_FDISPLAYO-144))|(1<<(VerilogParserDOLLAR_FSTROBE-144))|(1<<(VerilogParserDOLLAR_FSTROBEB-144))|(1<<(VerilogParserDOLLAR_FSTROBEH-144))|(1<<(VerilogParserDOLLAR_FSTROBEO-144))|(1<<(VerilogParserDOLLAR_FWRITE-144))|(1<<(VerilogParserDOLLAR_FWRITEB-144))|(1<<(VerilogParserDOLLAR_FWRITEH-144))|(1<<(VerilogParserDOLLAR_FWRITEO-144))|(1<<(VerilogParserDOLLAR_FMONITOR-144))|(1<<(VerilogParserDOLLAR_FMONITORB-144))|(1<<(VerilogParserDOLLAR_FMONITORH-144))|(1<<(VerilogParserDOLLAR_FMONITORO-144)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILoad_memory_tasksContext is an interface to support dynamic dispatch.
type ILoad_memory_tasksContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoad_memory_tasksContext differentiates from other interfaces.
	IsLoad_memory_tasksContext()
}

type Load_memory_tasksContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoad_memory_tasksContext() *Load_memory_tasksContext {
	var p = new(Load_memory_tasksContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_load_memory_tasks
	return p
}

func (*Load_memory_tasksContext) IsLoad_memory_tasksContext() {}

func NewLoad_memory_tasksContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Load_memory_tasksContext {
	var p = new(Load_memory_tasksContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_load_memory_tasks

	return p
}

func (s *Load_memory_tasksContext) GetParser() antlr.Parser { return s.parser }

func (s *Load_memory_tasksContext) DOLLAR_READMEMB() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_READMEMB, 0)
}

func (s *Load_memory_tasksContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Load_memory_tasksContext) Filename() IFilenameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilenameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilenameContext)
}

func (s *Load_memory_tasksContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Load_memory_tasksContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Load_memory_tasksContext) Memory_name() IMemory_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemory_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemory_nameContext)
}

func (s *Load_memory_tasksContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Load_memory_tasksContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Load_memory_tasksContext) Start_addr() IStart_addrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStart_addrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStart_addrContext)
}

func (s *Load_memory_tasksContext) Finish_addr() IFinish_addrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinish_addrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinish_addrContext)
}

func (s *Load_memory_tasksContext) DOLLAR_READMEMH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_READMEMH, 0)
}

func (s *Load_memory_tasksContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Load_memory_tasksContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Load_memory_tasksContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLoad_memory_tasks(s)
	}
}

func (s *Load_memory_tasksContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLoad_memory_tasks(s)
	}
}

func (p *VerilogParser) Load_memory_tasks() (localctx ILoad_memory_tasksContext) {
	this := p
	_ = this

	localctx = NewLoad_memory_tasksContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, VerilogParserRULE_load_memory_tasks)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(848)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserDOLLAR_READMEMB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(816)
			p.Match(VerilogParserDOLLAR_READMEMB)
		}
		{
			p.SetState(817)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(818)
			p.Filename()
		}
		{
			p.SetState(819)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(820)
			p.Memory_name()
		}
		p.SetState(827)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserCOMMA {
			{
				p.SetState(821)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(822)
				p.Start_addr()
			}
			p.SetState(825)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == VerilogParserCOMMA {
				{
					p.SetState(823)
					p.Match(VerilogParserCOMMA)
				}
				{
					p.SetState(824)
					p.Finish_addr()
				}

			}

		}
		{
			p.SetState(829)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(830)
			p.Match(VerilogParserSEMICOLON)
		}

	case VerilogParserDOLLAR_READMEMH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(832)
			p.Match(VerilogParserDOLLAR_READMEMH)
		}
		{
			p.SetState(833)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(834)
			p.Filename()
		}
		{
			p.SetState(835)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(836)
			p.Memory_name()
		}
		p.SetState(843)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserCOMMA {
			{
				p.SetState(837)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(838)
				p.Start_addr()
			}
			p.SetState(841)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == VerilogParserCOMMA {
				{
					p.SetState(839)
					p.Match(VerilogParserCOMMA)
				}
				{
					p.SetState(840)
					p.Finish_addr()
				}

			}

		}
		{
			p.SetState(845)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(846)
			p.Match(VerilogParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMemory_nameContext is an interface to support dynamic dispatch.
type IMemory_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemory_nameContext differentiates from other interfaces.
	IsMemory_nameContext()
}

type Memory_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemory_nameContext() *Memory_nameContext {
	var p = new(Memory_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_memory_name
	return p
}

func (*Memory_nameContext) IsMemory_nameContext() {}

func NewMemory_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Memory_nameContext {
	var p = new(Memory_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_memory_name

	return p
}

func (s *Memory_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Memory_nameContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Memory_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Memory_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Memory_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMemory_name(s)
	}
}

func (s *Memory_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMemory_name(s)
	}
}

func (p *VerilogParser) Memory_name() (localctx IMemory_nameContext) {
	this := p
	_ = this

	localctx = NewMemory_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, VerilogParserRULE_memory_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.Variable_identifier()
	}

	return localctx
}

// IStart_addrContext is an interface to support dynamic dispatch.
type IStart_addrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStart_addrContext differentiates from other interfaces.
	IsStart_addrContext()
}

type Start_addrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStart_addrContext() *Start_addrContext {
	var p = new(Start_addrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_start_addr
	return p
}

func (*Start_addrContext) IsStart_addrContext() {}

func NewStart_addrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Start_addrContext {
	var p = new(Start_addrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_start_addr

	return p
}

func (s *Start_addrContext) GetParser() antlr.Parser { return s.parser }

func (s *Start_addrContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserDECIMAL_NUMBER, 0)
}

func (s *Start_addrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Start_addrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Start_addrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStart_addr(s)
	}
}

func (s *Start_addrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStart_addr(s)
	}
}

func (p *VerilogParser) Start_addr() (localctx IStart_addrContext) {
	this := p
	_ = this

	localctx = NewStart_addrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, VerilogParserRULE_start_addr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(852)
		p.Match(VerilogParserDECIMAL_NUMBER)
	}

	return localctx
}

// IFinish_addrContext is an interface to support dynamic dispatch.
type IFinish_addrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinish_addrContext differentiates from other interfaces.
	IsFinish_addrContext()
}

type Finish_addrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinish_addrContext() *Finish_addrContext {
	var p = new(Finish_addrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_finish_addr
	return p
}

func (*Finish_addrContext) IsFinish_addrContext() {}

func NewFinish_addrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Finish_addrContext {
	var p = new(Finish_addrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_finish_addr

	return p
}

func (s *Finish_addrContext) GetParser() antlr.Parser { return s.parser }

func (s *Finish_addrContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserDECIMAL_NUMBER, 0)
}

func (s *Finish_addrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Finish_addrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Finish_addrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFinish_addr(s)
	}
}

func (s *Finish_addrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFinish_addr(s)
	}
}

func (p *VerilogParser) Finish_addr() (localctx IFinish_addrContext) {
	this := p
	_ = this

	localctx = NewFinish_addrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, VerilogParserRULE_finish_addr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(854)
		p.Match(VerilogParserDECIMAL_NUMBER)
	}

	return localctx
}

// IFilenameContext is an interface to support dynamic dispatch.
type IFilenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilenameContext differentiates from other interfaces.
	IsFilenameContext()
}

type FilenameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilenameContext() *FilenameContext {
	var p = new(FilenameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_filename
	return p
}

func (*FilenameContext) IsFilenameContext() {}

func NewFilenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilenameContext {
	var p = new(FilenameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_filename

	return p
}

func (s *FilenameContext) GetParser() antlr.Parser { return s.parser }

func (s *FilenameContext) STRING() antlr.TerminalNode {
	return s.GetToken(VerilogParserSTRING, 0)
}

func (s *FilenameContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *FilenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFilename(s)
	}
}

func (s *FilenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFilename(s)
	}
}

func (p *VerilogParser) Filename() (localctx IFilenameContext) {
	this := p
	_ = this

	localctx = NewFilenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, VerilogParserRULE_filename)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(858)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(856)
			p.Match(VerilogParserSTRING)
		}

	case VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(857)
			p.Variable_identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFinish_taskContext is an interface to support dynamic dispatch.
type IFinish_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinish_taskContext differentiates from other interfaces.
	IsFinish_taskContext()
}

type Finish_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinish_taskContext() *Finish_taskContext {
	var p = new(Finish_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_finish_task
	return p
}

func (*Finish_taskContext) IsFinish_taskContext() {}

func NewFinish_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Finish_taskContext {
	var p = new(Finish_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_finish_task

	return p
}

func (s *Finish_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Finish_taskContext) DOLLAR_FINISH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FINISH, 0)
}

func (s *Finish_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Finish_taskContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Finish_taskContext) Finish_number() IFinish_numberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinish_numberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinish_numberContext)
}

func (s *Finish_taskContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Finish_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Finish_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Finish_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFinish_task(s)
	}
}

func (s *Finish_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFinish_task(s)
	}
}

func (p *VerilogParser) Finish_task() (localctx IFinish_taskContext) {
	this := p
	_ = this

	localctx = NewFinish_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, VerilogParserRULE_finish_task)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(860)
		p.Match(VerilogParserDOLLAR_FINISH)
	}
	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_PARENTHESIS {
		{
			p.SetState(861)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(862)
			p.Finish_number()
		}
		{
			p.SetState(863)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}
	{
		p.SetState(867)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IFinish_numberContext is an interface to support dynamic dispatch.
type IFinish_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinish_numberContext differentiates from other interfaces.
	IsFinish_numberContext()
}

type Finish_numberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinish_numberContext() *Finish_numberContext {
	var p = new(Finish_numberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_finish_number
	return p
}

func (*Finish_numberContext) IsFinish_numberContext() {}

func NewFinish_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Finish_numberContext {
	var p = new(Finish_numberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_finish_number

	return p
}

func (s *Finish_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Finish_numberContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserDECIMAL_NUMBER, 0)
}

func (s *Finish_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Finish_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Finish_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFinish_number(s)
	}
}

func (s *Finish_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFinish_number(s)
	}
}

func (p *VerilogParser) Finish_number() (localctx IFinish_numberContext) {
	this := p
	_ = this

	localctx = NewFinish_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, VerilogParserRULE_finish_number)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(869)
		p.Match(VerilogParserDECIMAL_NUMBER)
	}

	return localctx
}

// IStop_taskContext is an interface to support dynamic dispatch.
type IStop_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStop_taskContext differentiates from other interfaces.
	IsStop_taskContext()
}

type Stop_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStop_taskContext() *Stop_taskContext {
	var p = new(Stop_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_stop_task
	return p
}

func (*Stop_taskContext) IsStop_taskContext() {}

func NewStop_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Stop_taskContext {
	var p = new(Stop_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_stop_task

	return p
}

func (s *Stop_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Stop_taskContext) DOLLAR_STOP() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_STOP, 0)
}

func (s *Stop_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Stop_taskContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Stop_taskContext) Finish_number() IFinish_numberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinish_numberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinish_numberContext)
}

func (s *Stop_taskContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Stop_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stop_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Stop_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStop_task(s)
	}
}

func (s *Stop_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStop_task(s)
	}
}

func (p *VerilogParser) Stop_task() (localctx IStop_taskContext) {
	this := p
	_ = this

	localctx = NewStop_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, VerilogParserRULE_stop_task)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(871)
		p.Match(VerilogParserDOLLAR_STOP)
	}
	p.SetState(876)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_PARENTHESIS {
		{
			p.SetState(872)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(873)
			p.Finish_number()
		}
		{
			p.SetState(874)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}
	{
		p.SetState(878)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// ITime_functionContext is an interface to support dynamic dispatch.
type ITime_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTime_functionContext differentiates from other interfaces.
	IsTime_functionContext()
}

type Time_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTime_functionContext() *Time_functionContext {
	var p = new(Time_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_time_function
	return p
}

func (*Time_functionContext) IsTime_functionContext() {}

func NewTime_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Time_functionContext {
	var p = new(Time_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_time_function

	return p
}

func (s *Time_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Time_functionContext) TIME() antlr.TerminalNode {
	return s.GetToken(VerilogParserTIME, 0)
}

func (s *Time_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Time_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Time_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTime_function(s)
	}
}

func (s *Time_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTime_function(s)
	}
}

func (p *VerilogParser) Time_function() (localctx ITime_functionContext) {
	this := p
	_ = this

	localctx = NewTime_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, VerilogParserRULE_time_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(880)
		p.Match(VerilogParserTIME)
	}

	return localctx
}

// IStime_functionContext is an interface to support dynamic dispatch.
type IStime_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStime_functionContext differentiates from other interfaces.
	IsStime_functionContext()
}

type Stime_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStime_functionContext() *Stime_functionContext {
	var p = new(Stime_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_stime_function
	return p
}

func (*Stime_functionContext) IsStime_functionContext() {}

func NewStime_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Stime_functionContext {
	var p = new(Stime_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_stime_function

	return p
}

func (s *Stime_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Stime_functionContext) DOLLAR_STIME() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_STIME, 0)
}

func (s *Stime_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stime_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Stime_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStime_function(s)
	}
}

func (s *Stime_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStime_function(s)
	}
}

func (p *VerilogParser) Stime_function() (localctx IStime_functionContext) {
	this := p
	_ = this

	localctx = NewStime_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, VerilogParserRULE_stime_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(882)
		p.Match(VerilogParserDOLLAR_STIME)
	}

	return localctx
}

// IRealtime_functionContext is an interface to support dynamic dispatch.
type IRealtime_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRealtime_functionContext differentiates from other interfaces.
	IsRealtime_functionContext()
}

type Realtime_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRealtime_functionContext() *Realtime_functionContext {
	var p = new(Realtime_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_realtime_function
	return p
}

func (*Realtime_functionContext) IsRealtime_functionContext() {}

func NewRealtime_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Realtime_functionContext {
	var p = new(Realtime_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_realtime_function

	return p
}

func (s *Realtime_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Realtime_functionContext) REALTIME() antlr.TerminalNode {
	return s.GetToken(VerilogParserREALTIME, 0)
}

func (s *Realtime_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Realtime_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Realtime_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterRealtime_function(s)
	}
}

func (s *Realtime_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitRealtime_function(s)
	}
}

func (p *VerilogParser) Realtime_function() (localctx IRealtime_functionContext) {
	this := p
	_ = this

	localctx = NewRealtime_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, VerilogParserRULE_realtime_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(884)
		p.Match(VerilogParserREALTIME)
	}

	return localctx
}

// IConversion_functionsContext is an interface to support dynamic dispatch.
type IConversion_functionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConversion_functionsContext differentiates from other interfaces.
	IsConversion_functionsContext()
}

type Conversion_functionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConversion_functionsContext() *Conversion_functionsContext {
	var p = new(Conversion_functionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_conversion_functions
	return p
}

func (*Conversion_functionsContext) IsConversion_functionsContext() {}

func NewConversion_functionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conversion_functionsContext {
	var p = new(Conversion_functionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_conversion_functions

	return p
}

func (s *Conversion_functionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Conversion_functionsContext) Conversion_function_name() IConversion_function_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConversion_function_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConversion_function_nameContext)
}

func (s *Conversion_functionsContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Conversion_functionsContext) Constant_argument() IConstant_argumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_argumentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_argumentContext)
}

func (s *Conversion_functionsContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Conversion_functionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conversion_functionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conversion_functionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConversion_functions(s)
	}
}

func (s *Conversion_functionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConversion_functions(s)
	}
}

func (p *VerilogParser) Conversion_functions() (localctx IConversion_functionsContext) {
	this := p
	_ = this

	localctx = NewConversion_functionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, VerilogParserRULE_conversion_functions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(886)
		p.Conversion_function_name()
	}
	{
		p.SetState(887)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(888)
		p.Constant_argument()
	}
	{
		p.SetState(889)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IConversion_function_nameContext is an interface to support dynamic dispatch.
type IConversion_function_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConversion_function_nameContext differentiates from other interfaces.
	IsConversion_function_nameContext()
}

type Conversion_function_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConversion_function_nameContext() *Conversion_function_nameContext {
	var p = new(Conversion_function_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_conversion_function_name
	return p
}

func (*Conversion_function_nameContext) IsConversion_function_nameContext() {}

func NewConversion_function_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conversion_function_nameContext {
	var p = new(Conversion_function_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_conversion_function_name

	return p
}

func (s *Conversion_function_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Conversion_function_nameContext) DOLLAR_RTOI() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_RTOI, 0)
}

func (s *Conversion_function_nameContext) DOLLAR_ITOR() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_ITOR, 0)
}

func (s *Conversion_function_nameContext) DOLLAR_REALTOBITS() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_REALTOBITS, 0)
}

func (s *Conversion_function_nameContext) DOLLAR_BITSTOREAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_BITSTOREAL, 0)
}

func (s *Conversion_function_nameContext) DOLLAR_SIGNED() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_SIGNED, 0)
}

func (s *Conversion_function_nameContext) DOLLAR_UNSIGNED() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_UNSIGNED, 0)
}

func (s *Conversion_function_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conversion_function_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conversion_function_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConversion_function_name(s)
	}
}

func (s *Conversion_function_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConversion_function_name(s)
	}
}

func (p *VerilogParser) Conversion_function_name() (localctx IConversion_function_nameContext) {
	this := p
	_ = this

	localctx = NewConversion_function_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, VerilogParserRULE_conversion_function_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(891)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(VerilogParserDOLLAR_BITSTOREAL-209))|(1<<(VerilogParserDOLLAR_ITOR-209))|(1<<(VerilogParserDOLLAR_SIGNED-209))|(1<<(VerilogParserDOLLAR_REALTOBITS-209))|(1<<(VerilogParserDOLLAR_RTOI-209))|(1<<(VerilogParserDOLLAR_UNSIGNED-209)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IConstant_argumentContext is an interface to support dynamic dispatch.
type IConstant_argumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_argumentContext differentiates from other interfaces.
	IsConstant_argumentContext()
}

type Constant_argumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_argumentContext() *Constant_argumentContext {
	var p = new(Constant_argumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_argument
	return p
}

func (*Constant_argumentContext) IsConstant_argumentContext() {}

func NewConstant_argumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_argumentContext {
	var p = new(Constant_argumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_argument

	return p
}

func (s *Constant_argumentContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_argumentContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_argumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_argumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_argumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_argument(s)
	}
}

func (s *Constant_argumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_argument(s)
	}
}

func (p *VerilogParser) Constant_argument() (localctx IConstant_argumentContext) {
	this := p
	_ = this

	localctx = NewConstant_argumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, VerilogParserRULE_constant_argument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(893)
		p.constant_expression(0)
	}

	return localctx
}

// IRandom_functionContext is an interface to support dynamic dispatch.
type IRandom_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRandom_functionContext differentiates from other interfaces.
	IsRandom_functionContext()
}

type Random_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRandom_functionContext() *Random_functionContext {
	var p = new(Random_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_random_function
	return p
}

func (*Random_functionContext) IsRandom_functionContext() {}

func NewRandom_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Random_functionContext {
	var p = new(Random_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_random_function

	return p
}

func (s *Random_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Random_functionContext) DOLLAR_RANDOM() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_RANDOM, 0)
}

func (s *Random_functionContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Random_functionContext) Seed() ISeedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeedContext)
}

func (s *Random_functionContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Random_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Random_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Random_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterRandom_function(s)
	}
}

func (s *Random_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitRandom_function(s)
	}
}

func (p *VerilogParser) Random_function() (localctx IRandom_functionContext) {
	this := p
	_ = this

	localctx = NewRandom_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, VerilogParserRULE_random_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(895)
		p.Match(VerilogParserDOLLAR_RANDOM)
	}
	p.SetState(900)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(896)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(897)
			p.Seed()
		}
		{
			p.SetState(898)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}

	return localctx
}

// ISeedContext is an interface to support dynamic dispatch.
type ISeedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeedContext differentiates from other interfaces.
	IsSeedContext()
}

type SeedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeedContext() *SeedContext {
	var p = new(SeedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_seed
	return p
}

func (*SeedContext) IsSeedContext() {}

func NewSeedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SeedContext {
	var p = new(SeedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_seed

	return p
}

func (s *SeedContext) GetParser() antlr.Parser { return s.parser }

func (s *SeedContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *SeedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SeedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SeedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSeed(s)
	}
}

func (s *SeedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSeed(s)
	}
}

func (p *VerilogParser) Seed() (localctx ISeedContext) {
	this := p
	_ = this

	localctx = NewSeedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, VerilogParserRULE_seed)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(902)
		p.Variable_identifier()
	}

	return localctx
}

// IDist_functionsContext is an interface to support dynamic dispatch.
type IDist_functionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDist_functionsContext differentiates from other interfaces.
	IsDist_functionsContext()
}

type Dist_functionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDist_functionsContext() *Dist_functionsContext {
	var p = new(Dist_functionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dist_functions
	return p
}

func (*Dist_functionsContext) IsDist_functionsContext() {}

func NewDist_functionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dist_functionsContext {
	var p = new(Dist_functionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dist_functions

	return p
}

func (s *Dist_functionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Dist_functionsContext) DOLLAR_DIST_UNIFORM() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DIST_UNIFORM, 0)
}

func (s *Dist_functionsContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Dist_functionsContext) Seed() ISeedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeedContext)
}

func (s *Dist_functionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Dist_functionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Dist_functionsContext) Start_() IStart_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStart_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStart_Context)
}

func (s *Dist_functionsContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *Dist_functionsContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Dist_functionsContext) DOLLAR_DIST_NORMAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DIST_NORMAL, 0)
}

func (s *Dist_functionsContext) Mean() IMeanContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMeanContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMeanContext)
}

func (s *Dist_functionsContext) Standard_deviation() IStandard_deviationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStandard_deviationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStandard_deviationContext)
}

func (s *Dist_functionsContext) DOLLAR_DIST_EXPONENTIAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DIST_EXPONENTIAL, 0)
}

func (s *Dist_functionsContext) DOLLAR_DIST_POISSON() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DIST_POISSON, 0)
}

func (s *Dist_functionsContext) DOLLAR_DIST_CHI_SQUARE() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DIST_CHI_SQUARE, 0)
}

func (s *Dist_functionsContext) Degree_of_freedom() IDegree_of_freedomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDegree_of_freedomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDegree_of_freedomContext)
}

func (s *Dist_functionsContext) DOLLAR_DIST_T() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DIST_T, 0)
}

func (s *Dist_functionsContext) DOLLAR_DIST_ERLANG() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DIST_ERLANG, 0)
}

func (s *Dist_functionsContext) K_stage() IK_stageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IK_stageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IK_stageContext)
}

func (s *Dist_functionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dist_functionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dist_functionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDist_functions(s)
	}
}

func (s *Dist_functionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDist_functions(s)
	}
}

func (p *VerilogParser) Dist_functions() (localctx IDist_functionsContext) {
	this := p
	_ = this

	localctx = NewDist_functionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, VerilogParserRULE_dist_functions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(959)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserDOLLAR_DIST_UNIFORM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(904)
			p.Match(VerilogParserDOLLAR_DIST_UNIFORM)
		}
		{
			p.SetState(905)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(906)
			p.Seed()
		}
		{
			p.SetState(907)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(908)
			p.Start_()
		}
		{
			p.SetState(909)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(910)
			p.End()
		}
		{
			p.SetState(911)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case VerilogParserDOLLAR_DIST_NORMAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(913)
			p.Match(VerilogParserDOLLAR_DIST_NORMAL)
		}
		{
			p.SetState(914)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(915)
			p.Seed()
		}
		{
			p.SetState(916)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(917)
			p.Mean()
		}
		{
			p.SetState(918)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(919)
			p.Standard_deviation()
		}
		{
			p.SetState(920)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case VerilogParserDOLLAR_DIST_EXPONENTIAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(922)
			p.Match(VerilogParserDOLLAR_DIST_EXPONENTIAL)
		}
		{
			p.SetState(923)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(924)
			p.Seed()
		}
		{
			p.SetState(925)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(926)
			p.Mean()
		}
		{
			p.SetState(927)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case VerilogParserDOLLAR_DIST_POISSON:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(929)
			p.Match(VerilogParserDOLLAR_DIST_POISSON)
		}
		{
			p.SetState(930)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(931)
			p.Seed()
		}
		{
			p.SetState(932)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(933)
			p.Mean()
		}
		{
			p.SetState(934)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case VerilogParserDOLLAR_DIST_CHI_SQUARE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(936)
			p.Match(VerilogParserDOLLAR_DIST_CHI_SQUARE)
		}
		{
			p.SetState(937)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(938)
			p.Seed()
		}
		{
			p.SetState(939)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(940)
			p.Degree_of_freedom()
		}
		{
			p.SetState(941)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case VerilogParserDOLLAR_DIST_T:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(943)
			p.Match(VerilogParserDOLLAR_DIST_T)
		}
		{
			p.SetState(944)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(945)
			p.Seed()
		}
		{
			p.SetState(946)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(947)
			p.Degree_of_freedom()
		}
		{
			p.SetState(948)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case VerilogParserDOLLAR_DIST_ERLANG:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(950)
			p.Match(VerilogParserDOLLAR_DIST_ERLANG)
		}
		{
			p.SetState(951)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(952)
			p.Seed()
		}
		{
			p.SetState(953)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(954)
			p.K_stage()
		}
		{
			p.SetState(955)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(956)
			p.Mean()
		}
		{
			p.SetState(957)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStart_Context is an interface to support dynamic dispatch.
type IStart_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStart_Context differentiates from other interfaces.
	IsStart_Context()
}

type Start_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStart_Context() *Start_Context {
	var p = new(Start_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_start_
	return p
}

func (*Start_Context) IsStart_Context() {}

func NewStart_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Start_Context {
	var p = new(Start_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_start_

	return p
}

func (s *Start_Context) GetParser() antlr.Parser { return s.parser }

func (s *Start_Context) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserDECIMAL_NUMBER, 0)
}

func (s *Start_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Start_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Start_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStart_(s)
	}
}

func (s *Start_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStart_(s)
	}
}

func (p *VerilogParser) Start_() (localctx IStart_Context) {
	this := p
	_ = this

	localctx = NewStart_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, VerilogParserRULE_start_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(961)
		p.Match(VerilogParserDECIMAL_NUMBER)
	}

	return localctx
}

// IEndContext is an interface to support dynamic dispatch.
type IEndContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndContext differentiates from other interfaces.
	IsEndContext()
}

type EndContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndContext() *EndContext {
	var p = new(EndContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_end
	return p
}

func (*EndContext) IsEndContext() {}

func NewEndContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndContext {
	var p = new(EndContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_end

	return p
}

func (s *EndContext) GetParser() antlr.Parser { return s.parser }

func (s *EndContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserDECIMAL_NUMBER, 0)
}

func (s *EndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEnd(s)
	}
}

func (s *EndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEnd(s)
	}
}

func (p *VerilogParser) End() (localctx IEndContext) {
	this := p
	_ = this

	localctx = NewEndContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, VerilogParserRULE_end)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(963)
		p.Match(VerilogParserDECIMAL_NUMBER)
	}

	return localctx
}

// IMeanContext is an interface to support dynamic dispatch.
type IMeanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMeanContext differentiates from other interfaces.
	IsMeanContext()
}

type MeanContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMeanContext() *MeanContext {
	var p = new(MeanContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_mean
	return p
}

func (*MeanContext) IsMeanContext() {}

func NewMeanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MeanContext {
	var p = new(MeanContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_mean

	return p
}

func (s *MeanContext) GetParser() antlr.Parser { return s.parser }

func (s *MeanContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserDECIMAL_NUMBER, 0)
}

func (s *MeanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MeanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MeanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMean(s)
	}
}

func (s *MeanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMean(s)
	}
}

func (p *VerilogParser) Mean() (localctx IMeanContext) {
	this := p
	_ = this

	localctx = NewMeanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, VerilogParserRULE_mean)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(965)
		p.Match(VerilogParserDECIMAL_NUMBER)
	}

	return localctx
}

// IStandard_deviationContext is an interface to support dynamic dispatch.
type IStandard_deviationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandard_deviationContext differentiates from other interfaces.
	IsStandard_deviationContext()
}

type Standard_deviationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandard_deviationContext() *Standard_deviationContext {
	var p = new(Standard_deviationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_standard_deviation
	return p
}

func (*Standard_deviationContext) IsStandard_deviationContext() {}

func NewStandard_deviationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Standard_deviationContext {
	var p = new(Standard_deviationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_standard_deviation

	return p
}

func (s *Standard_deviationContext) GetParser() antlr.Parser { return s.parser }

func (s *Standard_deviationContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserDECIMAL_NUMBER, 0)
}

func (s *Standard_deviationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Standard_deviationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Standard_deviationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStandard_deviation(s)
	}
}

func (s *Standard_deviationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStandard_deviation(s)
	}
}

func (p *VerilogParser) Standard_deviation() (localctx IStandard_deviationContext) {
	this := p
	_ = this

	localctx = NewStandard_deviationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, VerilogParserRULE_standard_deviation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(967)
		p.Match(VerilogParserDECIMAL_NUMBER)
	}

	return localctx
}

// IDegree_of_freedomContext is an interface to support dynamic dispatch.
type IDegree_of_freedomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDegree_of_freedomContext differentiates from other interfaces.
	IsDegree_of_freedomContext()
}

type Degree_of_freedomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDegree_of_freedomContext() *Degree_of_freedomContext {
	var p = new(Degree_of_freedomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_degree_of_freedom
	return p
}

func (*Degree_of_freedomContext) IsDegree_of_freedomContext() {}

func NewDegree_of_freedomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Degree_of_freedomContext {
	var p = new(Degree_of_freedomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_degree_of_freedom

	return p
}

func (s *Degree_of_freedomContext) GetParser() antlr.Parser { return s.parser }

func (s *Degree_of_freedomContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserDECIMAL_NUMBER, 0)
}

func (s *Degree_of_freedomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Degree_of_freedomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Degree_of_freedomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDegree_of_freedom(s)
	}
}

func (s *Degree_of_freedomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDegree_of_freedom(s)
	}
}

func (p *VerilogParser) Degree_of_freedom() (localctx IDegree_of_freedomContext) {
	this := p
	_ = this

	localctx = NewDegree_of_freedomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, VerilogParserRULE_degree_of_freedom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(969)
		p.Match(VerilogParserDECIMAL_NUMBER)
	}

	return localctx
}

// IK_stageContext is an interface to support dynamic dispatch.
type IK_stageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsK_stageContext differentiates from other interfaces.
	IsK_stageContext()
}

type K_stageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyK_stageContext() *K_stageContext {
	var p = new(K_stageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_k_stage
	return p
}

func (*K_stageContext) IsK_stageContext() {}

func NewK_stageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *K_stageContext {
	var p = new(K_stageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_k_stage

	return p
}

func (s *K_stageContext) GetParser() antlr.Parser { return s.parser }

func (s *K_stageContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserDECIMAL_NUMBER, 0)
}

func (s *K_stageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *K_stageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *K_stageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterK_stage(s)
	}
}

func (s *K_stageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitK_stage(s)
	}
}

func (p *VerilogParser) K_stage() (localctx IK_stageContext) {
	this := p
	_ = this

	localctx = NewK_stageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, VerilogParserRULE_k_stage)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(971)
		p.Match(VerilogParserDECIMAL_NUMBER)
	}

	return localctx
}

// IMath_functionsContext is an interface to support dynamic dispatch.
type IMath_functionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMath_functionsContext differentiates from other interfaces.
	IsMath_functionsContext()
}

type Math_functionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMath_functionsContext() *Math_functionsContext {
	var p = new(Math_functionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_math_functions
	return p
}

func (*Math_functionsContext) IsMath_functionsContext() {}

func NewMath_functionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Math_functionsContext {
	var p = new(Math_functionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_math_functions

	return p
}

func (s *Math_functionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Math_functionsContext) Integer_math_functions() IInteger_math_functionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_math_functionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_math_functionsContext)
}

func (s *Math_functionsContext) Real_math_functions() IReal_math_functionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_math_functionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_math_functionsContext)
}

func (s *Math_functionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Math_functionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Math_functionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMath_functions(s)
	}
}

func (s *Math_functionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMath_functions(s)
	}
}

func (p *VerilogParser) Math_functions() (localctx IMath_functionsContext) {
	this := p
	_ = this

	localctx = NewMath_functionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, VerilogParserRULE_math_functions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(975)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserDOLLAR_CLOG2:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(973)
			p.Integer_math_functions()
		}

	case VerilogParserDOLLAR_LN, VerilogParserDOLLAR_LOG10, VerilogParserDOLLAR_EXP, VerilogParserDOLLAR_SQRT, VerilogParserDOLLAR_POW, VerilogParserDOLLAR_FLOOR, VerilogParserDOLLAR_CEIL, VerilogParserDOLLAR_SIN, VerilogParserDOLLAR_COS, VerilogParserDOLLAR_TAN, VerilogParserDOLLAR_ASIN, VerilogParserDOLLAR_ACOS, VerilogParserDOLLAR_ATAN, VerilogParserDOLLAR_ATAN2, VerilogParserDOLLAR_HYPOT, VerilogParserDOLLAR_SINH, VerilogParserDOLLAR_COSH, VerilogParserDOLLAR_TANH, VerilogParserDOLLAR_ASINH, VerilogParserDOLLAR_ACOSH, VerilogParserDOLLAR_ATANH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(974)
			p.Real_math_functions()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInteger_math_functionsContext is an interface to support dynamic dispatch.
type IInteger_math_functionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInteger_math_functionsContext differentiates from other interfaces.
	IsInteger_math_functionsContext()
}

type Integer_math_functionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_math_functionsContext() *Integer_math_functionsContext {
	var p = new(Integer_math_functionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_integer_math_functions
	return p
}

func (*Integer_math_functionsContext) IsInteger_math_functionsContext() {}

func NewInteger_math_functionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_math_functionsContext {
	var p = new(Integer_math_functionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_integer_math_functions

	return p
}

func (s *Integer_math_functionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_math_functionsContext) DOLLAR_CLOG2() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_CLOG2, 0)
}

func (s *Integer_math_functionsContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Integer_math_functionsContext) Constant_argument() IConstant_argumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_argumentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_argumentContext)
}

func (s *Integer_math_functionsContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Integer_math_functionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_math_functionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_math_functionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInteger_math_functions(s)
	}
}

func (s *Integer_math_functionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInteger_math_functions(s)
	}
}

func (p *VerilogParser) Integer_math_functions() (localctx IInteger_math_functionsContext) {
	this := p
	_ = this

	localctx = NewInteger_math_functionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, VerilogParserRULE_integer_math_functions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(977)
		p.Match(VerilogParserDOLLAR_CLOG2)
	}
	{
		p.SetState(978)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(979)
		p.Constant_argument()
	}
	{
		p.SetState(980)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IReal_math_functionsContext is an interface to support dynamic dispatch.
type IReal_math_functionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReal_math_functionsContext differentiates from other interfaces.
	IsReal_math_functionsContext()
}

type Real_math_functionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_math_functionsContext() *Real_math_functionsContext {
	var p = new(Real_math_functionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_real_math_functions
	return p
}

func (*Real_math_functionsContext) IsReal_math_functionsContext() {}

func NewReal_math_functionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_math_functionsContext {
	var p = new(Real_math_functionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_real_math_functions

	return p
}

func (s *Real_math_functionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_math_functionsContext) Single_argument_real_math_function_name() ISingle_argument_real_math_function_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_argument_real_math_function_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_argument_real_math_function_nameContext)
}

func (s *Real_math_functionsContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Real_math_functionsContext) AllConstant_argument() []IConstant_argumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_argumentContext)(nil)).Elem())
	var tst = make([]IConstant_argumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_argumentContext)
		}
	}

	return tst
}

func (s *Real_math_functionsContext) Constant_argument(i int) IConstant_argumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_argumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_argumentContext)
}

func (s *Real_math_functionsContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Real_math_functionsContext) Double_argument_real_math_function_name() IDouble_argument_real_math_function_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDouble_argument_real_math_function_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDouble_argument_real_math_function_nameContext)
}

func (s *Real_math_functionsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, 0)
}

func (s *Real_math_functionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_math_functionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_math_functionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterReal_math_functions(s)
	}
}

func (s *Real_math_functionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitReal_math_functions(s)
	}
}

func (p *VerilogParser) Real_math_functions() (localctx IReal_math_functionsContext) {
	this := p
	_ = this

	localctx = NewReal_math_functionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, VerilogParserRULE_real_math_functions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(994)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserDOLLAR_LN, VerilogParserDOLLAR_LOG10, VerilogParserDOLLAR_EXP, VerilogParserDOLLAR_SQRT, VerilogParserDOLLAR_FLOOR, VerilogParserDOLLAR_CEIL, VerilogParserDOLLAR_SIN, VerilogParserDOLLAR_COS, VerilogParserDOLLAR_TAN, VerilogParserDOLLAR_ASIN, VerilogParserDOLLAR_ACOS, VerilogParserDOLLAR_ATAN, VerilogParserDOLLAR_SINH, VerilogParserDOLLAR_COSH, VerilogParserDOLLAR_TANH, VerilogParserDOLLAR_ASINH, VerilogParserDOLLAR_ACOSH, VerilogParserDOLLAR_ATANH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(982)
			p.Single_argument_real_math_function_name()
		}
		{
			p.SetState(983)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(984)
			p.Constant_argument()
		}
		{
			p.SetState(985)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case VerilogParserDOLLAR_POW, VerilogParserDOLLAR_ATAN2, VerilogParserDOLLAR_HYPOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(987)
			p.Double_argument_real_math_function_name()
		}
		{
			p.SetState(988)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(989)
			p.Constant_argument()
		}
		{
			p.SetState(990)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(991)
			p.Constant_argument()
		}
		{
			p.SetState(992)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISingle_argument_real_math_function_nameContext is an interface to support dynamic dispatch.
type ISingle_argument_real_math_function_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingle_argument_real_math_function_nameContext differentiates from other interfaces.
	IsSingle_argument_real_math_function_nameContext()
}

type Single_argument_real_math_function_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_argument_real_math_function_nameContext() *Single_argument_real_math_function_nameContext {
	var p = new(Single_argument_real_math_function_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_single_argument_real_math_function_name
	return p
}

func (*Single_argument_real_math_function_nameContext) IsSingle_argument_real_math_function_nameContext() {
}

func NewSingle_argument_real_math_function_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_argument_real_math_function_nameContext {
	var p = new(Single_argument_real_math_function_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_single_argument_real_math_function_name

	return p
}

func (s *Single_argument_real_math_function_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_argument_real_math_function_nameContext) DOLLAR_LN() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_LN, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_LOG10() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_LOG10, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_EXP() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_EXP, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_SQRT() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_SQRT, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_FLOOR() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_FLOOR, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_CEIL() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_CEIL, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_SIN() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_SIN, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_COS() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_COS, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_TAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_TAN, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_ASIN() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_ASIN, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_ACOS() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_ACOS, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_ATAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_ATAN, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_SINH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_SINH, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_COSH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_COSH, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_TANH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_TANH, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_ASINH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_ASINH, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_ACOSH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_ACOSH, 0)
}

func (s *Single_argument_real_math_function_nameContext) DOLLAR_ATANH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_ATANH, 0)
}

func (s *Single_argument_real_math_function_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_argument_real_math_function_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_argument_real_math_function_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSingle_argument_real_math_function_name(s)
	}
}

func (s *Single_argument_real_math_function_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSingle_argument_real_math_function_name(s)
	}
}

func (p *VerilogParser) Single_argument_real_math_function_name() (localctx ISingle_argument_real_math_function_nameContext) {
	this := p
	_ = this

	localctx = NewSingle_argument_real_math_function_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, VerilogParserRULE_single_argument_real_math_function_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(996)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-226)&-(0x1f+1)) == 0 && ((1<<uint((_la-226)))&((1<<(VerilogParserDOLLAR_LN-226))|(1<<(VerilogParserDOLLAR_LOG10-226))|(1<<(VerilogParserDOLLAR_EXP-226))|(1<<(VerilogParserDOLLAR_SQRT-226))|(1<<(VerilogParserDOLLAR_FLOOR-226))|(1<<(VerilogParserDOLLAR_CEIL-226))|(1<<(VerilogParserDOLLAR_SIN-226))|(1<<(VerilogParserDOLLAR_COS-226))|(1<<(VerilogParserDOLLAR_TAN-226))|(1<<(VerilogParserDOLLAR_ASIN-226))|(1<<(VerilogParserDOLLAR_ACOS-226))|(1<<(VerilogParserDOLLAR_ATAN-226))|(1<<(VerilogParserDOLLAR_SINH-226))|(1<<(VerilogParserDOLLAR_COSH-226))|(1<<(VerilogParserDOLLAR_TANH-226))|(1<<(VerilogParserDOLLAR_ASINH-226))|(1<<(VerilogParserDOLLAR_ACOSH-226))|(1<<(VerilogParserDOLLAR_ATANH-226)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDouble_argument_real_math_function_nameContext is an interface to support dynamic dispatch.
type IDouble_argument_real_math_function_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDouble_argument_real_math_function_nameContext differentiates from other interfaces.
	IsDouble_argument_real_math_function_nameContext()
}

type Double_argument_real_math_function_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDouble_argument_real_math_function_nameContext() *Double_argument_real_math_function_nameContext {
	var p = new(Double_argument_real_math_function_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_double_argument_real_math_function_name
	return p
}

func (*Double_argument_real_math_function_nameContext) IsDouble_argument_real_math_function_nameContext() {
}

func NewDouble_argument_real_math_function_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Double_argument_real_math_function_nameContext {
	var p = new(Double_argument_real_math_function_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_double_argument_real_math_function_name

	return p
}

func (s *Double_argument_real_math_function_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Double_argument_real_math_function_nameContext) DOLLAR_POW() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_POW, 0)
}

func (s *Double_argument_real_math_function_nameContext) DOLLAR_ATAN2() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_ATAN2, 0)
}

func (s *Double_argument_real_math_function_nameContext) DOLLAR_HYPOT() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_HYPOT, 0)
}

func (s *Double_argument_real_math_function_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Double_argument_real_math_function_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Double_argument_real_math_function_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDouble_argument_real_math_function_name(s)
	}
}

func (s *Double_argument_real_math_function_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDouble_argument_real_math_function_name(s)
	}
}

func (p *VerilogParser) Double_argument_real_math_function_name() (localctx IDouble_argument_real_math_function_nameContext) {
	this := p
	_ = this

	localctx = NewDouble_argument_real_math_function_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, VerilogParserRULE_double_argument_real_math_function_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(998)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-230)&-(0x1f+1)) == 0 && ((1<<uint((_la-230)))&((1<<(VerilogParserDOLLAR_POW-230))|(1<<(VerilogParserDOLLAR_ATAN2-230))|(1<<(VerilogParserDOLLAR_HYPOT-230)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDumpfile_taskContext is an interface to support dynamic dispatch.
type IDumpfile_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDumpfile_taskContext differentiates from other interfaces.
	IsDumpfile_taskContext()
}

type Dumpfile_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDumpfile_taskContext() *Dumpfile_taskContext {
	var p = new(Dumpfile_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dumpfile_task
	return p
}

func (*Dumpfile_taskContext) IsDumpfile_taskContext() {}

func NewDumpfile_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dumpfile_taskContext {
	var p = new(Dumpfile_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dumpfile_task

	return p
}

func (s *Dumpfile_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Dumpfile_taskContext) DOLLAR_DUMPFILE() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DUMPFILE, 0)
}

func (s *Dumpfile_taskContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Dumpfile_taskContext) Filename() IFilenameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilenameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilenameContext)
}

func (s *Dumpfile_taskContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Dumpfile_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Dumpfile_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dumpfile_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dumpfile_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDumpfile_task(s)
	}
}

func (s *Dumpfile_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDumpfile_task(s)
	}
}

func (p *VerilogParser) Dumpfile_task() (localctx IDumpfile_taskContext) {
	this := p
	_ = this

	localctx = NewDumpfile_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, VerilogParserRULE_dumpfile_task)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1000)
		p.Match(VerilogParserDOLLAR_DUMPFILE)
	}
	{
		p.SetState(1001)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(1002)
		p.Filename()
	}
	{
		p.SetState(1003)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}
	{
		p.SetState(1004)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IDumpvars_taskContext is an interface to support dynamic dispatch.
type IDumpvars_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDumpvars_taskContext differentiates from other interfaces.
	IsDumpvars_taskContext()
}

type Dumpvars_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDumpvars_taskContext() *Dumpvars_taskContext {
	var p = new(Dumpvars_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dumpvars_task
	return p
}

func (*Dumpvars_taskContext) IsDumpvars_taskContext() {}

func NewDumpvars_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dumpvars_taskContext {
	var p = new(Dumpvars_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dumpvars_task

	return p
}

func (s *Dumpvars_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Dumpvars_taskContext) DOLLAR_DUMPVARS() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DUMPVARS, 0)
}

func (s *Dumpvars_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Dumpvars_taskContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Dumpvars_taskContext) Levels() ILevelsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILevelsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILevelsContext)
}

func (s *Dumpvars_taskContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Dumpvars_taskContext) COMMA() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, 0)
}

func (s *Dumpvars_taskContext) List_of_modules_or_variables() IList_of_modules_or_variablesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_modules_or_variablesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_modules_or_variablesContext)
}

func (s *Dumpvars_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dumpvars_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dumpvars_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDumpvars_task(s)
	}
}

func (s *Dumpvars_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDumpvars_task(s)
	}
}

func (p *VerilogParser) Dumpvars_task() (localctx IDumpvars_taskContext) {
	this := p
	_ = this

	localctx = NewDumpvars_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, VerilogParserRULE_dumpvars_task)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1018)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1006)
			p.Match(VerilogParserDOLLAR_DUMPVARS)
		}
		{
			p.SetState(1007)
			p.Match(VerilogParserSEMICOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1008)
			p.Match(VerilogParserDOLLAR_DUMPVARS)
		}
		{
			p.SetState(1009)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1010)
			p.Levels()
		}
		p.SetState(1013)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserCOMMA {
			{
				p.SetState(1011)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(1012)
				p.List_of_modules_or_variables()
			}

		}
		{
			p.SetState(1015)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(1016)
			p.Match(VerilogParserSEMICOLON)
		}

	}

	return localctx
}

// IList_of_modules_or_variablesContext is an interface to support dynamic dispatch.
type IList_of_modules_or_variablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_modules_or_variablesContext differentiates from other interfaces.
	IsList_of_modules_or_variablesContext()
}

type List_of_modules_or_variablesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_modules_or_variablesContext() *List_of_modules_or_variablesContext {
	var p = new(List_of_modules_or_variablesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_modules_or_variables
	return p
}

func (*List_of_modules_or_variablesContext) IsList_of_modules_or_variablesContext() {}

func NewList_of_modules_or_variablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_modules_or_variablesContext {
	var p = new(List_of_modules_or_variablesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_modules_or_variables

	return p
}

func (s *List_of_modules_or_variablesContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_modules_or_variablesContext) AllModule_or_variable() []IModule_or_variableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_or_variableContext)(nil)).Elem())
	var tst = make([]IModule_or_variableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_or_variableContext)
		}
	}

	return tst
}

func (s *List_of_modules_or_variablesContext) Module_or_variable(i int) IModule_or_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_variableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_or_variableContext)
}

func (s *List_of_modules_or_variablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_modules_or_variablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_modules_or_variablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_modules_or_variablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_modules_or_variablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_modules_or_variables(s)
	}
}

func (s *List_of_modules_or_variablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_modules_or_variables(s)
	}
}

func (p *VerilogParser) List_of_modules_or_variables() (localctx IList_of_modules_or_variablesContext) {
	this := p
	_ = this

	localctx = NewList_of_modules_or_variablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, VerilogParserRULE_list_of_modules_or_variables)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1020)
		p.Module_or_variable()
	}
	p.SetState(1025)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(1021)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1022)
			p.Module_or_variable()
		}

		p.SetState(1027)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IModule_or_variableContext is an interface to support dynamic dispatch.
type IModule_or_variableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_or_variableContext differentiates from other interfaces.
	IsModule_or_variableContext()
}

type Module_or_variableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_or_variableContext() *Module_or_variableContext {
	var p = new(Module_or_variableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_or_variable
	return p
}

func (*Module_or_variableContext) IsModule_or_variableContext() {}

func NewModule_or_variableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_or_variableContext {
	var p = new(Module_or_variableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_or_variable

	return p
}

func (s *Module_or_variableContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_or_variableContext) Module_identifier() IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Module_or_variableContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Module_or_variableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_or_variableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_or_variableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_or_variable(s)
	}
}

func (s *Module_or_variableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_or_variable(s)
	}
}

func (p *VerilogParser) Module_or_variable() (localctx IModule_or_variableContext) {
	this := p
	_ = this

	localctx = NewModule_or_variableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, VerilogParserRULE_module_or_variable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1030)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1028)
			p.Module_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1029)
			p.Variable_identifier()
		}

	}

	return localctx
}

// ILevelsContext is an interface to support dynamic dispatch.
type ILevelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLevelsContext differentiates from other interfaces.
	IsLevelsContext()
}

type LevelsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelsContext() *LevelsContext {
	var p = new(LevelsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_levels
	return p
}

func (*LevelsContext) IsLevelsContext() {}

func NewLevelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelsContext {
	var p = new(LevelsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_levels

	return p
}

func (s *LevelsContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelsContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserDECIMAL_NUMBER, 0)
}

func (s *LevelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LevelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLevels(s)
	}
}

func (s *LevelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLevels(s)
	}
}

func (p *VerilogParser) Levels() (localctx ILevelsContext) {
	this := p
	_ = this

	localctx = NewLevelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, VerilogParserRULE_levels)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1032)
		p.Match(VerilogParserDECIMAL_NUMBER)
	}

	return localctx
}

// IDumpoff_taskContext is an interface to support dynamic dispatch.
type IDumpoff_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDumpoff_taskContext differentiates from other interfaces.
	IsDumpoff_taskContext()
}

type Dumpoff_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDumpoff_taskContext() *Dumpoff_taskContext {
	var p = new(Dumpoff_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dumpoff_task
	return p
}

func (*Dumpoff_taskContext) IsDumpoff_taskContext() {}

func NewDumpoff_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dumpoff_taskContext {
	var p = new(Dumpoff_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dumpoff_task

	return p
}

func (s *Dumpoff_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Dumpoff_taskContext) DOLLAR_DUMPOFF() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DUMPOFF, 0)
}

func (s *Dumpoff_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Dumpoff_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dumpoff_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dumpoff_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDumpoff_task(s)
	}
}

func (s *Dumpoff_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDumpoff_task(s)
	}
}

func (p *VerilogParser) Dumpoff_task() (localctx IDumpoff_taskContext) {
	this := p
	_ = this

	localctx = NewDumpoff_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, VerilogParserRULE_dumpoff_task)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1034)
		p.Match(VerilogParserDOLLAR_DUMPOFF)
	}
	{
		p.SetState(1035)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IDumpon_taskContext is an interface to support dynamic dispatch.
type IDumpon_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDumpon_taskContext differentiates from other interfaces.
	IsDumpon_taskContext()
}

type Dumpon_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDumpon_taskContext() *Dumpon_taskContext {
	var p = new(Dumpon_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dumpon_task
	return p
}

func (*Dumpon_taskContext) IsDumpon_taskContext() {}

func NewDumpon_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dumpon_taskContext {
	var p = new(Dumpon_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dumpon_task

	return p
}

func (s *Dumpon_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Dumpon_taskContext) DOLLAR_DUMPON() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DUMPON, 0)
}

func (s *Dumpon_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Dumpon_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dumpon_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dumpon_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDumpon_task(s)
	}
}

func (s *Dumpon_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDumpon_task(s)
	}
}

func (p *VerilogParser) Dumpon_task() (localctx IDumpon_taskContext) {
	this := p
	_ = this

	localctx = NewDumpon_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, VerilogParserRULE_dumpon_task)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1037)
		p.Match(VerilogParserDOLLAR_DUMPON)
	}
	{
		p.SetState(1038)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IDumpall_taskContext is an interface to support dynamic dispatch.
type IDumpall_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDumpall_taskContext differentiates from other interfaces.
	IsDumpall_taskContext()
}

type Dumpall_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDumpall_taskContext() *Dumpall_taskContext {
	var p = new(Dumpall_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dumpall_task
	return p
}

func (*Dumpall_taskContext) IsDumpall_taskContext() {}

func NewDumpall_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dumpall_taskContext {
	var p = new(Dumpall_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dumpall_task

	return p
}

func (s *Dumpall_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Dumpall_taskContext) DOLLAR_DUMPALL() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DUMPALL, 0)
}

func (s *Dumpall_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Dumpall_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dumpall_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dumpall_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDumpall_task(s)
	}
}

func (s *Dumpall_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDumpall_task(s)
	}
}

func (p *VerilogParser) Dumpall_task() (localctx IDumpall_taskContext) {
	this := p
	_ = this

	localctx = NewDumpall_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, VerilogParserRULE_dumpall_task)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1040)
		p.Match(VerilogParserDOLLAR_DUMPALL)
	}
	{
		p.SetState(1041)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IDumplimit_taskContext is an interface to support dynamic dispatch.
type IDumplimit_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDumplimit_taskContext differentiates from other interfaces.
	IsDumplimit_taskContext()
}

type Dumplimit_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDumplimit_taskContext() *Dumplimit_taskContext {
	var p = new(Dumplimit_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dumplimit_task
	return p
}

func (*Dumplimit_taskContext) IsDumplimit_taskContext() {}

func NewDumplimit_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dumplimit_taskContext {
	var p = new(Dumplimit_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dumplimit_task

	return p
}

func (s *Dumplimit_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Dumplimit_taskContext) DOLLAR_DUMPLIMIT() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DUMPLIMIT, 0)
}

func (s *Dumplimit_taskContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Dumplimit_taskContext) File_size() IFile_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_sizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_sizeContext)
}

func (s *Dumplimit_taskContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Dumplimit_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Dumplimit_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dumplimit_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dumplimit_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDumplimit_task(s)
	}
}

func (s *Dumplimit_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDumplimit_task(s)
	}
}

func (p *VerilogParser) Dumplimit_task() (localctx IDumplimit_taskContext) {
	this := p
	_ = this

	localctx = NewDumplimit_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, VerilogParserRULE_dumplimit_task)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1043)
		p.Match(VerilogParserDOLLAR_DUMPLIMIT)
	}
	{
		p.SetState(1044)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(1045)
		p.File_size()
	}
	{
		p.SetState(1046)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}
	{
		p.SetState(1047)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IFile_sizeContext is an interface to support dynamic dispatch.
type IFile_sizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_sizeContext differentiates from other interfaces.
	IsFile_sizeContext()
}

type File_sizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_sizeContext() *File_sizeContext {
	var p = new(File_sizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_file_size
	return p
}

func (*File_sizeContext) IsFile_sizeContext() {}

func NewFile_sizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_sizeContext {
	var p = new(File_sizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_file_size

	return p
}

func (s *File_sizeContext) GetParser() antlr.Parser { return s.parser }

func (s *File_sizeContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserDECIMAL_NUMBER, 0)
}

func (s *File_sizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_sizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_sizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFile_size(s)
	}
}

func (s *File_sizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFile_size(s)
	}
}

func (p *VerilogParser) File_size() (localctx IFile_sizeContext) {
	this := p
	_ = this

	localctx = NewFile_sizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, VerilogParserRULE_file_size)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1049)
		p.Match(VerilogParserDECIMAL_NUMBER)
	}

	return localctx
}

// IDumpflush_taskContext is an interface to support dynamic dispatch.
type IDumpflush_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDumpflush_taskContext differentiates from other interfaces.
	IsDumpflush_taskContext()
}

type Dumpflush_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDumpflush_taskContext() *Dumpflush_taskContext {
	var p = new(Dumpflush_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dumpflush_task
	return p
}

func (*Dumpflush_taskContext) IsDumpflush_taskContext() {}

func NewDumpflush_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dumpflush_taskContext {
	var p = new(Dumpflush_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dumpflush_task

	return p
}

func (s *Dumpflush_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Dumpflush_taskContext) DOLLAR_DUMPFLUSH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DUMPFLUSH, 0)
}

func (s *Dumpflush_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Dumpflush_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dumpflush_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dumpflush_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDumpflush_task(s)
	}
}

func (s *Dumpflush_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDumpflush_task(s)
	}
}

func (p *VerilogParser) Dumpflush_task() (localctx IDumpflush_taskContext) {
	this := p
	_ = this

	localctx = NewDumpflush_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, VerilogParserRULE_dumpflush_task)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1051)
		p.Match(VerilogParserDOLLAR_DUMPFLUSH)
	}
	{
		p.SetState(1052)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IDumpports_taskContext is an interface to support dynamic dispatch.
type IDumpports_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDumpports_taskContext differentiates from other interfaces.
	IsDumpports_taskContext()
}

type Dumpports_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDumpports_taskContext() *Dumpports_taskContext {
	var p = new(Dumpports_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dumpports_task
	return p
}

func (*Dumpports_taskContext) IsDumpports_taskContext() {}

func NewDumpports_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dumpports_taskContext {
	var p = new(Dumpports_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dumpports_task

	return p
}

func (s *Dumpports_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Dumpports_taskContext) DOLLAR_DUMPPORTS() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DUMPPORTS, 0)
}

func (s *Dumpports_taskContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Dumpports_taskContext) Scope_list() IScope_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScope_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScope_listContext)
}

func (s *Dumpports_taskContext) COMMA() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, 0)
}

func (s *Dumpports_taskContext) File_pathname() IFile_pathnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_pathnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_pathnameContext)
}

func (s *Dumpports_taskContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Dumpports_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Dumpports_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dumpports_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dumpports_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDumpports_task(s)
	}
}

func (s *Dumpports_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDumpports_task(s)
	}
}

func (p *VerilogParser) Dumpports_task() (localctx IDumpports_taskContext) {
	this := p
	_ = this

	localctx = NewDumpports_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, VerilogParserRULE_dumpports_task)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1054)
		p.Match(VerilogParserDOLLAR_DUMPPORTS)
	}
	{
		p.SetState(1055)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(1056)
		p.Scope_list()
	}
	{
		p.SetState(1057)
		p.Match(VerilogParserCOMMA)
	}
	{
		p.SetState(1058)
		p.File_pathname()
	}
	{
		p.SetState(1059)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}
	{
		p.SetState(1060)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IScope_listContext is an interface to support dynamic dispatch.
type IScope_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScope_listContext differentiates from other interfaces.
	IsScope_listContext()
}

type Scope_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScope_listContext() *Scope_listContext {
	var p = new(Scope_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_scope_list
	return p
}

func (*Scope_listContext) IsScope_listContext() {}

func NewScope_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Scope_listContext {
	var p = new(Scope_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_scope_list

	return p
}

func (s *Scope_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Scope_listContext) AllModule_identifier() []IModule_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem())
	var tst = make([]IModule_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_identifierContext)
		}
	}

	return tst
}

func (s *Scope_listContext) Module_identifier(i int) IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Scope_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Scope_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Scope_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Scope_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Scope_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterScope_list(s)
	}
}

func (s *Scope_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitScope_list(s)
	}
}

func (p *VerilogParser) Scope_list() (localctx IScope_listContext) {
	this := p
	_ = this

	localctx = NewScope_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, VerilogParserRULE_scope_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1062)
		p.Module_identifier()
	}
	p.SetState(1067)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1063)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(1064)
				p.Module_identifier()
			}

		}
		p.SetState(1069)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())
	}

	return localctx
}

// IFile_pathnameContext is an interface to support dynamic dispatch.
type IFile_pathnameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_pathnameContext differentiates from other interfaces.
	IsFile_pathnameContext()
}

type File_pathnameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_pathnameContext() *File_pathnameContext {
	var p = new(File_pathnameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_file_pathname
	return p
}

func (*File_pathnameContext) IsFile_pathnameContext() {}

func NewFile_pathnameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_pathnameContext {
	var p = new(File_pathnameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_file_pathname

	return p
}

func (s *File_pathnameContext) GetParser() antlr.Parser { return s.parser }

func (s *File_pathnameContext) STRING() antlr.TerminalNode {
	return s.GetToken(VerilogParserSTRING, 0)
}

func (s *File_pathnameContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *File_pathnameContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *File_pathnameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_pathnameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_pathnameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFile_pathname(s)
	}
}

func (s *File_pathnameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFile_pathname(s)
	}
}

func (p *VerilogParser) File_pathname() (localctx IFile_pathnameContext) {
	this := p
	_ = this

	localctx = NewFile_pathnameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, VerilogParserRULE_file_pathname)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1073)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1070)
			p.Match(VerilogParserSTRING)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1071)
			p.Variable_identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1072)
			p.expression(0)
		}

	}

	return localctx
}

// IDumpportsoff_taskContext is an interface to support dynamic dispatch.
type IDumpportsoff_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDumpportsoff_taskContext differentiates from other interfaces.
	IsDumpportsoff_taskContext()
}

type Dumpportsoff_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDumpportsoff_taskContext() *Dumpportsoff_taskContext {
	var p = new(Dumpportsoff_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dumpportsoff_task
	return p
}

func (*Dumpportsoff_taskContext) IsDumpportsoff_taskContext() {}

func NewDumpportsoff_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dumpportsoff_taskContext {
	var p = new(Dumpportsoff_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dumpportsoff_task

	return p
}

func (s *Dumpportsoff_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Dumpportsoff_taskContext) DOLLAR_DUMPPORTSOFF() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DUMPPORTSOFF, 0)
}

func (s *Dumpportsoff_taskContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Dumpportsoff_taskContext) File_pathname() IFile_pathnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_pathnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_pathnameContext)
}

func (s *Dumpportsoff_taskContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Dumpportsoff_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Dumpportsoff_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dumpportsoff_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dumpportsoff_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDumpportsoff_task(s)
	}
}

func (s *Dumpportsoff_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDumpportsoff_task(s)
	}
}

func (p *VerilogParser) Dumpportsoff_task() (localctx IDumpportsoff_taskContext) {
	this := p
	_ = this

	localctx = NewDumpportsoff_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, VerilogParserRULE_dumpportsoff_task)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1075)
		p.Match(VerilogParserDOLLAR_DUMPPORTSOFF)
	}
	{
		p.SetState(1076)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(1077)
		p.File_pathname()
	}
	{
		p.SetState(1078)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}
	{
		p.SetState(1079)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IDumpportson_taskContext is an interface to support dynamic dispatch.
type IDumpportson_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDumpportson_taskContext differentiates from other interfaces.
	IsDumpportson_taskContext()
}

type Dumpportson_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDumpportson_taskContext() *Dumpportson_taskContext {
	var p = new(Dumpportson_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dumpportson_task
	return p
}

func (*Dumpportson_taskContext) IsDumpportson_taskContext() {}

func NewDumpportson_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dumpportson_taskContext {
	var p = new(Dumpportson_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dumpportson_task

	return p
}

func (s *Dumpportson_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Dumpportson_taskContext) DOLLAR_DUMPPORTSON() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DUMPPORTSON, 0)
}

func (s *Dumpportson_taskContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Dumpportson_taskContext) File_pathname() IFile_pathnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_pathnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_pathnameContext)
}

func (s *Dumpportson_taskContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Dumpportson_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Dumpportson_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dumpportson_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dumpportson_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDumpportson_task(s)
	}
}

func (s *Dumpportson_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDumpportson_task(s)
	}
}

func (p *VerilogParser) Dumpportson_task() (localctx IDumpportson_taskContext) {
	this := p
	_ = this

	localctx = NewDumpportson_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, VerilogParserRULE_dumpportson_task)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1081)
		p.Match(VerilogParserDOLLAR_DUMPPORTSON)
	}
	{
		p.SetState(1082)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(1083)
		p.File_pathname()
	}
	{
		p.SetState(1084)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}
	{
		p.SetState(1085)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IDumpportsall_taskContext is an interface to support dynamic dispatch.
type IDumpportsall_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDumpportsall_taskContext differentiates from other interfaces.
	IsDumpportsall_taskContext()
}

type Dumpportsall_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDumpportsall_taskContext() *Dumpportsall_taskContext {
	var p = new(Dumpportsall_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dumpportsall_task
	return p
}

func (*Dumpportsall_taskContext) IsDumpportsall_taskContext() {}

func NewDumpportsall_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dumpportsall_taskContext {
	var p = new(Dumpportsall_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dumpportsall_task

	return p
}

func (s *Dumpportsall_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Dumpportsall_taskContext) DOLLAR_DUMPPORTSALL() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DUMPPORTSALL, 0)
}

func (s *Dumpportsall_taskContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Dumpportsall_taskContext) File_pathname() IFile_pathnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_pathnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_pathnameContext)
}

func (s *Dumpportsall_taskContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Dumpportsall_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Dumpportsall_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dumpportsall_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dumpportsall_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDumpportsall_task(s)
	}
}

func (s *Dumpportsall_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDumpportsall_task(s)
	}
}

func (p *VerilogParser) Dumpportsall_task() (localctx IDumpportsall_taskContext) {
	this := p
	_ = this

	localctx = NewDumpportsall_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, VerilogParserRULE_dumpportsall_task)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1087)
		p.Match(VerilogParserDOLLAR_DUMPPORTSALL)
	}
	{
		p.SetState(1088)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(1089)
		p.File_pathname()
	}
	{
		p.SetState(1090)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}
	{
		p.SetState(1091)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IDumpportslimit_taskContext is an interface to support dynamic dispatch.
type IDumpportslimit_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDumpportslimit_taskContext differentiates from other interfaces.
	IsDumpportslimit_taskContext()
}

type Dumpportslimit_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDumpportslimit_taskContext() *Dumpportslimit_taskContext {
	var p = new(Dumpportslimit_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dumpportslimit_task
	return p
}

func (*Dumpportslimit_taskContext) IsDumpportslimit_taskContext() {}

func NewDumpportslimit_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dumpportslimit_taskContext {
	var p = new(Dumpportslimit_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dumpportslimit_task

	return p
}

func (s *Dumpportslimit_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Dumpportslimit_taskContext) DOLLAR_DUMPPORTSLIMIT() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DUMPPORTSLIMIT, 0)
}

func (s *Dumpportslimit_taskContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Dumpportslimit_taskContext) File_size() IFile_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_sizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_sizeContext)
}

func (s *Dumpportslimit_taskContext) COMMA() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, 0)
}

func (s *Dumpportslimit_taskContext) File_pathname() IFile_pathnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_pathnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_pathnameContext)
}

func (s *Dumpportslimit_taskContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Dumpportslimit_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Dumpportslimit_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dumpportslimit_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dumpportslimit_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDumpportslimit_task(s)
	}
}

func (s *Dumpportslimit_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDumpportslimit_task(s)
	}
}

func (p *VerilogParser) Dumpportslimit_task() (localctx IDumpportslimit_taskContext) {
	this := p
	_ = this

	localctx = NewDumpportslimit_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, VerilogParserRULE_dumpportslimit_task)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1093)
		p.Match(VerilogParserDOLLAR_DUMPPORTSLIMIT)
	}
	{
		p.SetState(1094)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(1095)
		p.File_size()
	}
	{
		p.SetState(1096)
		p.Match(VerilogParserCOMMA)
	}
	{
		p.SetState(1097)
		p.File_pathname()
	}
	{
		p.SetState(1098)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}
	{
		p.SetState(1099)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IDumpportsflush_taskContext is an interface to support dynamic dispatch.
type IDumpportsflush_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDumpportsflush_taskContext differentiates from other interfaces.
	IsDumpportsflush_taskContext()
}

type Dumpportsflush_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDumpportsflush_taskContext() *Dumpportsflush_taskContext {
	var p = new(Dumpportsflush_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dumpportsflush_task
	return p
}

func (*Dumpportsflush_taskContext) IsDumpportsflush_taskContext() {}

func NewDumpportsflush_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dumpportsflush_taskContext {
	var p = new(Dumpportsflush_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dumpportsflush_task

	return p
}

func (s *Dumpportsflush_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Dumpportsflush_taskContext) DOLLAR_DUMPPORTSFLUSH() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOLLAR_DUMPPORTSFLUSH, 0)
}

func (s *Dumpportsflush_taskContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Dumpportsflush_taskContext) File_pathname() IFile_pathnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_pathnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_pathnameContext)
}

func (s *Dumpportsflush_taskContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Dumpportsflush_taskContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Dumpportsflush_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dumpportsflush_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dumpportsflush_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDumpportsflush_task(s)
	}
}

func (s *Dumpportsflush_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDumpportsflush_task(s)
	}
}

func (p *VerilogParser) Dumpportsflush_task() (localctx IDumpportsflush_taskContext) {
	this := p
	_ = this

	localctx = NewDumpportsflush_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, VerilogParserRULE_dumpportsflush_task)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1101)
		p.Match(VerilogParserDOLLAR_DUMPPORTSFLUSH)
	}
	{
		p.SetState(1102)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(1103)
		p.File_pathname()
	}
	{
		p.SetState(1104)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}
	{
		p.SetState(1105)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// ILibrary_textContext is an interface to support dynamic dispatch.
type ILibrary_textContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_textContext differentiates from other interfaces.
	IsLibrary_textContext()
}

type Library_textContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_textContext() *Library_textContext {
	var p = new(Library_textContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_library_text
	return p
}

func (*Library_textContext) IsLibrary_textContext() {}

func NewLibrary_textContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_textContext {
	var p = new(Library_textContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_library_text

	return p
}

func (s *Library_textContext) GetParser() antlr.Parser { return s.parser }

func (s *Library_textContext) AllLibrary_description() []ILibrary_descriptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibrary_descriptionContext)(nil)).Elem())
	var tst = make([]ILibrary_descriptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibrary_descriptionContext)
		}
	}

	return tst
}

func (s *Library_textContext) Library_description(i int) ILibrary_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_descriptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibrary_descriptionContext)
}

func (s *Library_textContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_textContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_textContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLibrary_text(s)
	}
}

func (s *Library_textContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLibrary_text(s)
	}
}

func (p *VerilogParser) Library_text() (localctx ILibrary_textContext) {
	this := p
	_ = this

	localctx = NewLibrary_textContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, VerilogParserRULE_library_text)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1110)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCONFIG || _la == VerilogParserINCLUDE || _la == VerilogParserLIBRARY {
		{
			p.SetState(1107)
			p.Library_description()
		}

		p.SetState(1112)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILibrary_descriptionContext is an interface to support dynamic dispatch.
type ILibrary_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_descriptionContext differentiates from other interfaces.
	IsLibrary_descriptionContext()
}

type Library_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_descriptionContext() *Library_descriptionContext {
	var p = new(Library_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_library_description
	return p
}

func (*Library_descriptionContext) IsLibrary_descriptionContext() {}

func NewLibrary_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_descriptionContext {
	var p = new(Library_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_library_description

	return p
}

func (s *Library_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Library_descriptionContext) Library_declaration() ILibrary_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_declarationContext)
}

func (s *Library_descriptionContext) Include_statement() IInclude_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInclude_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInclude_statementContext)
}

func (s *Library_descriptionContext) Config_declaration() IConfig_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfig_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfig_declarationContext)
}

func (s *Library_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLibrary_description(s)
	}
}

func (s *Library_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLibrary_description(s)
	}
}

func (p *VerilogParser) Library_description() (localctx ILibrary_descriptionContext) {
	this := p
	_ = this

	localctx = NewLibrary_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, VerilogParserRULE_library_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1116)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserLIBRARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1113)
			p.Library_declaration()
		}

	case VerilogParserINCLUDE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1114)
			p.Include_statement()
		}

	case VerilogParserCONFIG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1115)
			p.Config_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILibrary_declarationContext is an interface to support dynamic dispatch.
type ILibrary_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_declarationContext differentiates from other interfaces.
	IsLibrary_declarationContext()
}

type Library_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_declarationContext() *Library_declarationContext {
	var p = new(Library_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_library_declaration
	return p
}

func (*Library_declarationContext) IsLibrary_declarationContext() {}

func NewLibrary_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_declarationContext {
	var p = new(Library_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_library_declaration

	return p
}

func (s *Library_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Library_declarationContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(VerilogParserLIBRARY, 0)
}

func (s *Library_declarationContext) Library_identifier() ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Library_declarationContext) AllFILE_PATH_SPEC() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserFILE_PATH_SPEC)
}

func (s *Library_declarationContext) FILE_PATH_SPEC(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserFILE_PATH_SPEC, i)
}

func (s *Library_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Library_declarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Library_declarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Library_declarationContext) MINUS_INCDIR() antlr.TerminalNode {
	return s.GetToken(VerilogParserMINUS_INCDIR, 0)
}

func (s *Library_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLibrary_declaration(s)
	}
}

func (s *Library_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLibrary_declaration(s)
	}
}

func (p *VerilogParser) Library_declaration() (localctx ILibrary_declarationContext) {
	this := p
	_ = this

	localctx = NewLibrary_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, VerilogParserRULE_library_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1118)
		p.Match(VerilogParserLIBRARY)
	}
	{
		p.SetState(1119)
		p.Library_identifier()
	}
	{
		p.SetState(1120)
		p.Match(VerilogParserFILE_PATH_SPEC)
	}
	p.SetState(1125)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(1121)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1122)
			p.Match(VerilogParserFILE_PATH_SPEC)
		}

		p.SetState(1127)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1137)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserMINUS_INCDIR {
		{
			p.SetState(1128)
			p.Match(VerilogParserMINUS_INCDIR)
		}
		{
			p.SetState(1129)
			p.Match(VerilogParserFILE_PATH_SPEC)
		}
		p.SetState(1134)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(1130)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(1131)
				p.Match(VerilogParserFILE_PATH_SPEC)
			}

			p.SetState(1136)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1139)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IInclude_statementContext is an interface to support dynamic dispatch.
type IInclude_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInclude_statementContext differentiates from other interfaces.
	IsInclude_statementContext()
}

type Include_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInclude_statementContext() *Include_statementContext {
	var p = new(Include_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_include_statement
	return p
}

func (*Include_statementContext) IsInclude_statementContext() {}

func NewInclude_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Include_statementContext {
	var p = new(Include_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_include_statement

	return p
}

func (s *Include_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Include_statementContext) INCLUDE() antlr.TerminalNode {
	return s.GetToken(VerilogParserINCLUDE, 0)
}

func (s *Include_statementContext) FILE_PATH_SPEC() antlr.TerminalNode {
	return s.GetToken(VerilogParserFILE_PATH_SPEC, 0)
}

func (s *Include_statementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Include_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Include_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Include_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInclude_statement(s)
	}
}

func (s *Include_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInclude_statement(s)
	}
}

func (p *VerilogParser) Include_statement() (localctx IInclude_statementContext) {
	this := p
	_ = this

	localctx = NewInclude_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, VerilogParserRULE_include_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1141)
		p.Match(VerilogParserINCLUDE)
	}
	{
		p.SetState(1142)
		p.Match(VerilogParserFILE_PATH_SPEC)
	}
	{
		p.SetState(1143)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// ISource_textContext is an interface to support dynamic dispatch.
type ISource_textContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSource_textContext differentiates from other interfaces.
	IsSource_textContext()
}

type Source_textContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySource_textContext() *Source_textContext {
	var p = new(Source_textContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_source_text
	return p
}

func (*Source_textContext) IsSource_textContext() {}

func NewSource_textContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Source_textContext {
	var p = new(Source_textContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_source_text

	return p
}

func (s *Source_textContext) GetParser() antlr.Parser { return s.parser }

func (s *Source_textContext) EOF() antlr.TerminalNode {
	return s.GetToken(VerilogParserEOF, 0)
}

func (s *Source_textContext) AllDescription() []IDescriptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDescriptionContext)(nil)).Elem())
	var tst = make([]IDescriptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDescriptionContext)
		}
	}

	return tst
}

func (s *Source_textContext) Description(i int) IDescriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDescriptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *Source_textContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Source_textContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Source_textContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSource_text(s)
	}
}

func (s *Source_textContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSource_text(s)
	}
}

func (p *VerilogParser) Source_text() (localctx ISource_textContext) {
	this := p
	_ = this

	localctx = NewSource_textContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, VerilogParserRULE_source_text)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1148)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCONFIG || _la == VerilogParserMACROMODULE || _la == VerilogParserMODULE || _la == VerilogParserLEFT_PARENTHESIS {
		{
			p.SetState(1145)
			p.Description()
		}

		p.SetState(1150)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1151)
		p.Match(VerilogParserEOF)
	}

	return localctx
}

// IDescriptionContext is an interface to support dynamic dispatch.
type IDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDescriptionContext differentiates from other interfaces.
	IsDescriptionContext()
}

type DescriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescriptionContext() *DescriptionContext {
	var p = new(DescriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_description
	return p
}

func (*DescriptionContext) IsDescriptionContext() {}

func NewDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescriptionContext {
	var p = new(DescriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_description

	return p
}

func (s *DescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DescriptionContext) Module_declaration() IModule_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_declarationContext)
}

func (s *DescriptionContext) Config_declaration() IConfig_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfig_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfig_declarationContext)
}

func (s *DescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDescription(s)
	}
}

func (s *DescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDescription(s)
	}
}

func (p *VerilogParser) Description() (localctx IDescriptionContext) {
	this := p
	_ = this

	localctx = NewDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, VerilogParserRULE_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1155)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserMACROMODULE, VerilogParserMODULE, VerilogParserLEFT_PARENTHESIS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1153)
			p.Module_declaration()
		}

	case VerilogParserCONFIG:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1154)
			p.Config_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModule_declarationContext is an interface to support dynamic dispatch.
type IModule_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_declarationContext differentiates from other interfaces.
	IsModule_declarationContext()
}

type Module_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_declarationContext() *Module_declarationContext {
	var p = new(Module_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_declaration
	return p
}

func (*Module_declarationContext) IsModule_declarationContext() {}

func NewModule_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_declarationContext {
	var p = new(Module_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_declaration

	return p
}

func (s *Module_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_declarationContext) Module_keyword() IModule_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_keywordContext)
}

func (s *Module_declarationContext) Module_identifier() IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Module_declarationContext) List_of_ports() IList_of_portsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_portsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_portsContext)
}

func (s *Module_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Module_declarationContext) ENDMODULE() antlr.TerminalNode {
	return s.GetToken(VerilogParserENDMODULE, 0)
}

func (s *Module_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_declarationContext) Module_parameter_port_list() IModule_parameter_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_parameter_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_parameter_port_listContext)
}

func (s *Module_declarationContext) AllModule_item() []IModule_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_itemContext)(nil)).Elem())
	var tst = make([]IModule_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_itemContext)
		}
	}

	return tst
}

func (s *Module_declarationContext) Module_item(i int) IModule_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_itemContext)
}

func (s *Module_declarationContext) List_of_port_declarations() IList_of_port_declarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_declarationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_declarationsContext)
}

func (s *Module_declarationContext) AllNon_port_module_item() []INon_port_module_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INon_port_module_itemContext)(nil)).Elem())
	var tst = make([]INon_port_module_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INon_port_module_itemContext)
		}
	}

	return tst
}

func (s *Module_declarationContext) Non_port_module_item(i int) INon_port_module_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_port_module_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INon_port_module_itemContext)
}

func (s *Module_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_declaration(s)
	}
}

func (s *Module_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_declaration(s)
	}
}

func (p *VerilogParser) Module_declaration() (localctx IModule_declarationContext) {
	this := p
	_ = this

	localctx = NewModule_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, VerilogParserRULE_module_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1201)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1160)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1157)
				p.Attribute_instance()
			}

			p.SetState(1162)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1163)
			p.Module_keyword()
		}
		{
			p.SetState(1164)
			p.Module_identifier()
		}
		p.SetState(1166)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(1165)
				p.Module_parameter_port_list()
			}

		}
		{
			p.SetState(1168)
			p.List_of_ports()
		}
		{
			p.SetState(1169)
			p.Match(VerilogParserSEMICOLON)
		}
		p.SetState(1173)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserALWAYS)|(1<<VerilogParserAND)|(1<<VerilogParserASSIGN)|(1<<VerilogParserBUF)|(1<<VerilogParserBUFIF0)|(1<<VerilogParserBUFIF1)|(1<<VerilogParserCMOS)|(1<<VerilogParserDEFAULT)|(1<<VerilogParserDEFPARAM))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(VerilogParserEVENT-32))|(1<<(VerilogParserFOR-32))|(1<<(VerilogParserFUNCTION-32))|(1<<(VerilogParserGENERATE-32))|(1<<(VerilogParserGENVAR-32))|(1<<(VerilogParserIF-32))|(1<<(VerilogParserINITIAL-32))|(1<<(VerilogParserINOUT-32))|(1<<(VerilogParserINPUT-32))|(1<<(VerilogParserINTEGER-32))|(1<<(VerilogParserLOCALPARAM-32))|(1<<(VerilogParserNAND-32))|(1<<(VerilogParserNMOS-32))|(1<<(VerilogParserNOR-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(VerilogParserNOT-64))|(1<<(VerilogParserNOTIF0-64))|(1<<(VerilogParserNOTIF1-64))|(1<<(VerilogParserOR-64))|(1<<(VerilogParserOUTPUT-64))|(1<<(VerilogParserPARAMETER-64))|(1<<(VerilogParserPMOS-64))|(1<<(VerilogParserPULLDOWN-64))|(1<<(VerilogParserPULLUP-64))|(1<<(VerilogParserRCMOS-64))|(1<<(VerilogParserREAL-64))|(1<<(VerilogParserREALTIME-64))|(1<<(VerilogParserREG-64))|(1<<(VerilogParserRNMOS-64))|(1<<(VerilogParserRPMOS-64))|(1<<(VerilogParserRTRAN-64))|(1<<(VerilogParserRTRANIF0-64))|(1<<(VerilogParserRTRANIF1-64))|(1<<(VerilogParserSPECIFY-64))|(1<<(VerilogParserSPECPARAM-64)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(VerilogParserSUPPLY0-98))|(1<<(VerilogParserSUPPLY1-98))|(1<<(VerilogParserTASK-98))|(1<<(VerilogParserTIME-98))|(1<<(VerilogParserTRAN-98))|(1<<(VerilogParserTRANIF0-98))|(1<<(VerilogParserTRANIF1-98))|(1<<(VerilogParserTRI-98))|(1<<(VerilogParserTRI0-98))|(1<<(VerilogParserTRI1-98))|(1<<(VerilogParserTRIAND-98))|(1<<(VerilogParserTRIOR-98))|(1<<(VerilogParserTRIREG-98))|(1<<(VerilogParserWAND-98))|(1<<(VerilogParserWIRE-98))|(1<<(VerilogParserWOR-98))|(1<<(VerilogParserXNOR-98))|(1<<(VerilogParserXOR-98)))) != 0) || (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(VerilogParserDOLLAR_BITSTOREAL-209))|(1<<(VerilogParserDOLLAR_ITOR-209))|(1<<(VerilogParserDOLLAR_SIGNED-209))|(1<<(VerilogParserDOLLAR_REALTOBITS-209))|(1<<(VerilogParserDOLLAR_RTOI-209))|(1<<(VerilogParserDOLLAR_UNSIGNED-209))|(1<<(VerilogParserDOLLAR_RANDOM-209))|(1<<(VerilogParserDOLLAR_DIST_ERLANG-209))|(1<<(VerilogParserDOLLAR_DIST_NORMAL-209))|(1<<(VerilogParserDOLLAR_DIST_T-209))|(1<<(VerilogParserDOLLAR_DIST_CHI_SQUARE-209))|(1<<(VerilogParserDOLLAR_DIST_EXPONENTIAL-209))|(1<<(VerilogParserDOLLAR_DIST_POISSON-209))|(1<<(VerilogParserDOLLAR_DIST_UNIFORM-209))|(1<<(VerilogParserDOLLAR_CLOG2-209))|(1<<(VerilogParserDOLLAR_LN-209))|(1<<(VerilogParserDOLLAR_LOG10-209))|(1<<(VerilogParserDOLLAR_EXP-209))|(1<<(VerilogParserDOLLAR_SQRT-209))|(1<<(VerilogParserDOLLAR_POW-209))|(1<<(VerilogParserDOLLAR_FLOOR-209))|(1<<(VerilogParserDOLLAR_CEIL-209))|(1<<(VerilogParserDOLLAR_SIN-209))|(1<<(VerilogParserDOLLAR_COS-209))|(1<<(VerilogParserDOLLAR_TAN-209))|(1<<(VerilogParserDOLLAR_ASIN-209))|(1<<(VerilogParserDOLLAR_ACOS-209))|(1<<(VerilogParserDOLLAR_ATAN-209))|(1<<(VerilogParserDOLLAR_ATAN2-209))|(1<<(VerilogParserDOLLAR_HYPOT-209)))) != 0) || (((_la-241)&-(0x1f+1)) == 0 && ((1<<uint((_la-241)))&((1<<(VerilogParserDOLLAR_SINH-241))|(1<<(VerilogParserDOLLAR_COSH-241))|(1<<(VerilogParserDOLLAR_TANH-241))|(1<<(VerilogParserDOLLAR_ASINH-241))|(1<<(VerilogParserDOLLAR_ACOSH-241))|(1<<(VerilogParserDOLLAR_ATANH-241)))) != 0) || (((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282))|(1<<(VerilogParserSTRING-282))|(1<<(VerilogParserESCAPED_IDENTIFIER-282))|(1<<(VerilogParserSIMPLE_IDENTIFIER-282))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-282))|(1<<(VerilogParserLEFT_PARENTHESIS-282))|(1<<(VerilogParserLEFT_BRACE-282))|(1<<(VerilogParserPLUS-282))|(1<<(VerilogParserMINUS-282))|(1<<(VerilogParserEXCLAMATION_MARK-282))|(1<<(VerilogParserTILDE-282))|(1<<(VerilogParserAMPERSAND-282))|(1<<(VerilogParserTILDE_AMPERSAND-282))|(1<<(VerilogParserVERTICAL_BAR-282))|(1<<(VerilogParserTILDE_VERTICAL_BAR-282))|(1<<(VerilogParserCARET-282))|(1<<(VerilogParserTILDE_CARET-282))|(1<<(VerilogParserCARET_TILDE-282)))) != 0) {
			{
				p.SetState(1170)
				p.Module_item()
			}

			p.SetState(1175)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1176)
			p.Match(VerilogParserENDMODULE)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1181)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1178)
				p.Attribute_instance()
			}

			p.SetState(1183)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1184)
			p.Module_keyword()
		}
		{
			p.SetState(1185)
			p.Module_identifier()
		}
		p.SetState(1187)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(1186)
				p.Module_parameter_port_list()
			}

		}
		p.SetState(1190)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1189)
				p.List_of_port_declarations()
			}

		}
		{
			p.SetState(1192)
			p.Match(VerilogParserSEMICOLON)
		}
		p.SetState(1196)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserALWAYS)|(1<<VerilogParserAND)|(1<<VerilogParserASSIGN)|(1<<VerilogParserBUF)|(1<<VerilogParserBUFIF0)|(1<<VerilogParserBUFIF1)|(1<<VerilogParserCMOS)|(1<<VerilogParserDEFAULT)|(1<<VerilogParserDEFPARAM))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(VerilogParserEVENT-32))|(1<<(VerilogParserFOR-32))|(1<<(VerilogParserFUNCTION-32))|(1<<(VerilogParserGENERATE-32))|(1<<(VerilogParserGENVAR-32))|(1<<(VerilogParserIF-32))|(1<<(VerilogParserINITIAL-32))|(1<<(VerilogParserINTEGER-32))|(1<<(VerilogParserLOCALPARAM-32))|(1<<(VerilogParserNAND-32))|(1<<(VerilogParserNMOS-32))|(1<<(VerilogParserNOR-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(VerilogParserNOT-64))|(1<<(VerilogParserNOTIF0-64))|(1<<(VerilogParserNOTIF1-64))|(1<<(VerilogParserOR-64))|(1<<(VerilogParserPARAMETER-64))|(1<<(VerilogParserPMOS-64))|(1<<(VerilogParserPULLDOWN-64))|(1<<(VerilogParserPULLUP-64))|(1<<(VerilogParserRCMOS-64))|(1<<(VerilogParserREAL-64))|(1<<(VerilogParserREALTIME-64))|(1<<(VerilogParserREG-64))|(1<<(VerilogParserRNMOS-64))|(1<<(VerilogParserRPMOS-64))|(1<<(VerilogParserRTRAN-64))|(1<<(VerilogParserRTRANIF0-64))|(1<<(VerilogParserRTRANIF1-64))|(1<<(VerilogParserSPECIFY-64))|(1<<(VerilogParserSPECPARAM-64)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(VerilogParserSUPPLY0-98))|(1<<(VerilogParserSUPPLY1-98))|(1<<(VerilogParserTASK-98))|(1<<(VerilogParserTIME-98))|(1<<(VerilogParserTRAN-98))|(1<<(VerilogParserTRANIF0-98))|(1<<(VerilogParserTRANIF1-98))|(1<<(VerilogParserTRI-98))|(1<<(VerilogParserTRI0-98))|(1<<(VerilogParserTRI1-98))|(1<<(VerilogParserTRIAND-98))|(1<<(VerilogParserTRIOR-98))|(1<<(VerilogParserTRIREG-98))|(1<<(VerilogParserWAND-98))|(1<<(VerilogParserWIRE-98))|(1<<(VerilogParserWOR-98))|(1<<(VerilogParserXNOR-98))|(1<<(VerilogParserXOR-98)))) != 0) || (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(VerilogParserDOLLAR_BITSTOREAL-209))|(1<<(VerilogParserDOLLAR_ITOR-209))|(1<<(VerilogParserDOLLAR_SIGNED-209))|(1<<(VerilogParserDOLLAR_REALTOBITS-209))|(1<<(VerilogParserDOLLAR_RTOI-209))|(1<<(VerilogParserDOLLAR_UNSIGNED-209))|(1<<(VerilogParserDOLLAR_RANDOM-209))|(1<<(VerilogParserDOLLAR_DIST_ERLANG-209))|(1<<(VerilogParserDOLLAR_DIST_NORMAL-209))|(1<<(VerilogParserDOLLAR_DIST_T-209))|(1<<(VerilogParserDOLLAR_DIST_CHI_SQUARE-209))|(1<<(VerilogParserDOLLAR_DIST_EXPONENTIAL-209))|(1<<(VerilogParserDOLLAR_DIST_POISSON-209))|(1<<(VerilogParserDOLLAR_DIST_UNIFORM-209))|(1<<(VerilogParserDOLLAR_CLOG2-209))|(1<<(VerilogParserDOLLAR_LN-209))|(1<<(VerilogParserDOLLAR_LOG10-209))|(1<<(VerilogParserDOLLAR_EXP-209))|(1<<(VerilogParserDOLLAR_SQRT-209))|(1<<(VerilogParserDOLLAR_POW-209))|(1<<(VerilogParserDOLLAR_FLOOR-209))|(1<<(VerilogParserDOLLAR_CEIL-209))|(1<<(VerilogParserDOLLAR_SIN-209))|(1<<(VerilogParserDOLLAR_COS-209))|(1<<(VerilogParserDOLLAR_TAN-209))|(1<<(VerilogParserDOLLAR_ASIN-209))|(1<<(VerilogParserDOLLAR_ACOS-209))|(1<<(VerilogParserDOLLAR_ATAN-209))|(1<<(VerilogParserDOLLAR_ATAN2-209))|(1<<(VerilogParserDOLLAR_HYPOT-209)))) != 0) || (((_la-241)&-(0x1f+1)) == 0 && ((1<<uint((_la-241)))&((1<<(VerilogParserDOLLAR_SINH-241))|(1<<(VerilogParserDOLLAR_COSH-241))|(1<<(VerilogParserDOLLAR_TANH-241))|(1<<(VerilogParserDOLLAR_ASINH-241))|(1<<(VerilogParserDOLLAR_ACOSH-241))|(1<<(VerilogParserDOLLAR_ATANH-241)))) != 0) || (((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282))|(1<<(VerilogParserSTRING-282))|(1<<(VerilogParserESCAPED_IDENTIFIER-282))|(1<<(VerilogParserSIMPLE_IDENTIFIER-282))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-282))|(1<<(VerilogParserLEFT_PARENTHESIS-282))|(1<<(VerilogParserLEFT_BRACE-282))|(1<<(VerilogParserPLUS-282))|(1<<(VerilogParserMINUS-282))|(1<<(VerilogParserEXCLAMATION_MARK-282))|(1<<(VerilogParserTILDE-282))|(1<<(VerilogParserAMPERSAND-282))|(1<<(VerilogParserTILDE_AMPERSAND-282))|(1<<(VerilogParserVERTICAL_BAR-282))|(1<<(VerilogParserTILDE_VERTICAL_BAR-282))|(1<<(VerilogParserCARET-282))|(1<<(VerilogParserTILDE_CARET-282))|(1<<(VerilogParserCARET_TILDE-282)))) != 0) {
			{
				p.SetState(1193)
				p.Non_port_module_item()
			}

			p.SetState(1198)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1199)
			p.Match(VerilogParserENDMODULE)
		}

	}

	return localctx
}

// IModule_keywordContext is an interface to support dynamic dispatch.
type IModule_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_keywordContext differentiates from other interfaces.
	IsModule_keywordContext()
}

type Module_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_keywordContext() *Module_keywordContext {
	var p = new(Module_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_keyword
	return p
}

func (*Module_keywordContext) IsModule_keywordContext() {}

func NewModule_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_keywordContext {
	var p = new(Module_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_keyword

	return p
}

func (s *Module_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_keywordContext) MODULE() antlr.TerminalNode {
	return s.GetToken(VerilogParserMODULE, 0)
}

func (s *Module_keywordContext) MACROMODULE() antlr.TerminalNode {
	return s.GetToken(VerilogParserMACROMODULE, 0)
}

func (s *Module_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_keyword(s)
	}
}

func (s *Module_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_keyword(s)
	}
}

func (p *VerilogParser) Module_keyword() (localctx IModule_keywordContext) {
	this := p
	_ = this

	localctx = NewModule_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, VerilogParserRULE_module_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1203)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserMACROMODULE || _la == VerilogParserMODULE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IModule_parameter_port_listContext is an interface to support dynamic dispatch.
type IModule_parameter_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_parameter_port_listContext differentiates from other interfaces.
	IsModule_parameter_port_listContext()
}

type Module_parameter_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_parameter_port_listContext() *Module_parameter_port_listContext {
	var p = new(Module_parameter_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_parameter_port_list
	return p
}

func (*Module_parameter_port_listContext) IsModule_parameter_port_listContext() {}

func NewModule_parameter_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_parameter_port_listContext {
	var p = new(Module_parameter_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_parameter_port_list

	return p
}

func (s *Module_parameter_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_parameter_port_listContext) HASH() antlr.TerminalNode {
	return s.GetToken(VerilogParserHASH, 0)
}

func (s *Module_parameter_port_listContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Module_parameter_port_listContext) AllParameter_declaration() []IParameter_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem())
	var tst = make([]IParameter_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameter_declarationContext)
		}
	}

	return tst
}

func (s *Module_parameter_port_listContext) Parameter_declaration(i int) IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Module_parameter_port_listContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Module_parameter_port_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Module_parameter_port_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Module_parameter_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_parameter_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_parameter_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_parameter_port_list(s)
	}
}

func (s *Module_parameter_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_parameter_port_list(s)
	}
}

func (p *VerilogParser) Module_parameter_port_list() (localctx IModule_parameter_port_listContext) {
	this := p
	_ = this

	localctx = NewModule_parameter_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, VerilogParserRULE_module_parameter_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1205)
		p.Match(VerilogParserHASH)
	}
	{
		p.SetState(1206)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(1207)
		p.Parameter_declaration()
	}
	p.SetState(1212)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(1208)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1209)
			p.Parameter_declaration()
		}

		p.SetState(1214)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1215)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IList_of_portsContext is an interface to support dynamic dispatch.
type IList_of_portsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_portsContext differentiates from other interfaces.
	IsList_of_portsContext()
}

type List_of_portsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_portsContext() *List_of_portsContext {
	var p = new(List_of_portsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_ports
	return p
}

func (*List_of_portsContext) IsList_of_portsContext() {}

func NewList_of_portsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_portsContext {
	var p = new(List_of_portsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_ports

	return p
}

func (s *List_of_portsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_portsContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *List_of_portsContext) AllPort() []IPortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPortContext)(nil)).Elem())
	var tst = make([]IPortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPortContext)
		}
	}

	return tst
}

func (s *List_of_portsContext) Port(i int) IPortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPortContext)
}

func (s *List_of_portsContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *List_of_portsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_portsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_portsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_portsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_portsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_ports(s)
	}
}

func (s *List_of_portsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_ports(s)
	}
}

func (p *VerilogParser) List_of_ports() (localctx IList_of_portsContext) {
	this := p
	_ = this

	localctx = NewList_of_portsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, VerilogParserRULE_list_of_ports)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1217)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(1218)
		p.Port()
	}
	p.SetState(1223)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(1219)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1220)
			p.Port()
		}

		p.SetState(1225)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1226)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IList_of_port_declarationsContext is an interface to support dynamic dispatch.
type IList_of_port_declarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_declarationsContext differentiates from other interfaces.
	IsList_of_port_declarationsContext()
}

type List_of_port_declarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_declarationsContext() *List_of_port_declarationsContext {
	var p = new(List_of_port_declarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_port_declarations
	return p
}

func (*List_of_port_declarationsContext) IsList_of_port_declarationsContext() {}

func NewList_of_port_declarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_declarationsContext {
	var p = new(List_of_port_declarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_port_declarations

	return p
}

func (s *List_of_port_declarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_declarationsContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *List_of_port_declarationsContext) AllPort_declaration() []IPort_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem())
	var tst = make([]IPort_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_declarationContext)
		}
	}

	return tst
}

func (s *List_of_port_declarationsContext) Port_declaration(i int) IPort_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_declarationContext)
}

func (s *List_of_port_declarationsContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *List_of_port_declarationsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_port_declarationsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_port_declarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_declarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_declarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_port_declarations(s)
	}
}

func (s *List_of_port_declarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_port_declarations(s)
	}
}

func (p *VerilogParser) List_of_port_declarations() (localctx IList_of_port_declarationsContext) {
	this := p
	_ = this

	localctx = NewList_of_port_declarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, VerilogParserRULE_list_of_port_declarations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1241)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1228)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1229)
			p.Port_declaration()
		}
		p.SetState(1234)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(1230)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(1231)
				p.Port_declaration()
			}

			p.SetState(1236)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1237)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1239)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1240)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}

	return localctx
}

// IPortContext is an interface to support dynamic dispatch.
type IPortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPortContext differentiates from other interfaces.
	IsPortContext()
}

type PortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPortContext() *PortContext {
	var p = new(PortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port
	return p
}

func (*PortContext) IsPortContext() {}

func NewPortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PortContext {
	var p = new(PortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port

	return p
}

func (s *PortContext) GetParser() antlr.Parser { return s.parser }

func (s *PortContext) Port_expression() IPort_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_expressionContext)
}

func (s *PortContext) DOT() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOT, 0)
}

func (s *PortContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *PortContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *PortContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *PortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPort(s)
	}
}

func (s *PortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPort(s)
	}
}

func (p *VerilogParser) Port() (localctx IPortContext) {
	this := p
	_ = this

	localctx = NewPortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, VerilogParserRULE_port)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1254)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER, VerilogParserRIGHT_PARENTHESIS, VerilogParserLEFT_BRACE, VerilogParserCOMMA:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1244)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-290)&-(0x1f+1)) == 0 && ((1<<uint((_la-290)))&((1<<(VerilogParserESCAPED_IDENTIFIER-290))|(1<<(VerilogParserSIMPLE_IDENTIFIER-290))|(1<<(VerilogParserLEFT_BRACE-290)))) != 0 {
			{
				p.SetState(1243)
				p.Port_expression()
			}

		}

	case VerilogParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1246)
			p.Match(VerilogParserDOT)
		}
		{
			p.SetState(1247)
			p.Port_identifier()
		}
		{
			p.SetState(1248)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		p.SetState(1250)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-290)&-(0x1f+1)) == 0 && ((1<<uint((_la-290)))&((1<<(VerilogParserESCAPED_IDENTIFIER-290))|(1<<(VerilogParserSIMPLE_IDENTIFIER-290))|(1<<(VerilogParserLEFT_BRACE-290)))) != 0 {
			{
				p.SetState(1249)
				p.Port_expression()
			}

		}
		{
			p.SetState(1252)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPort_expressionContext is an interface to support dynamic dispatch.
type IPort_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_expressionContext differentiates from other interfaces.
	IsPort_expressionContext()
}

type Port_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_expressionContext() *Port_expressionContext {
	var p = new(Port_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port_expression
	return p
}

func (*Port_expressionContext) IsPort_expressionContext() {}

func NewPort_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_expressionContext {
	var p = new(Port_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port_expression

	return p
}

func (s *Port_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_expressionContext) AllPort_reference() []IPort_referenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_referenceContext)(nil)).Elem())
	var tst = make([]IPort_referenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_referenceContext)
		}
	}

	return tst
}

func (s *Port_expressionContext) Port_reference(i int) IPort_referenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_referenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_referenceContext)
}

func (s *Port_expressionContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACE, 0)
}

func (s *Port_expressionContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACE, 0)
}

func (s *Port_expressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Port_expressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Port_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPort_expression(s)
	}
}

func (s *Port_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPort_expression(s)
	}
}

func (p *VerilogParser) Port_expression() (localctx IPort_expressionContext) {
	this := p
	_ = this

	localctx = NewPort_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, VerilogParserRULE_port_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1268)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1256)
			p.Port_reference()
		}

	case VerilogParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1257)
			p.Match(VerilogParserLEFT_BRACE)
		}
		{
			p.SetState(1258)
			p.Port_reference()
		}
		p.SetState(1263)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(1259)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(1260)
				p.Port_reference()
			}

			p.SetState(1265)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1266)
			p.Match(VerilogParserRIGHT_BRACE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPort_referenceContext is an interface to support dynamic dispatch.
type IPort_referenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_referenceContext differentiates from other interfaces.
	IsPort_referenceContext()
}

type Port_referenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_referenceContext() *Port_referenceContext {
	var p = new(Port_referenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port_reference
	return p
}

func (*Port_referenceContext) IsPort_referenceContext() {}

func NewPort_referenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_referenceContext {
	var p = new(Port_referenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port_reference

	return p
}

func (s *Port_referenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_referenceContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *Port_referenceContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACKET, 0)
}

func (s *Port_referenceContext) Constant_range_expression() IConstant_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_range_expressionContext)
}

func (s *Port_referenceContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACKET, 0)
}

func (s *Port_referenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_referenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_referenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPort_reference(s)
	}
}

func (s *Port_referenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPort_reference(s)
	}
}

func (p *VerilogParser) Port_reference() (localctx IPort_referenceContext) {
	this := p
	_ = this

	localctx = NewPort_referenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, VerilogParserRULE_port_reference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1270)
		p.Port_identifier()
	}
	p.SetState(1275)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_BRACKET {
		{
			p.SetState(1271)
			p.Match(VerilogParserLEFT_BRACKET)
		}
		{
			p.SetState(1272)
			p.Constant_range_expression()
		}
		{
			p.SetState(1273)
			p.Match(VerilogParserRIGHT_BRACKET)
		}

	}

	return localctx
}

// IPort_declarationContext is an interface to support dynamic dispatch.
type IPort_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_declarationContext differentiates from other interfaces.
	IsPort_declarationContext()
}

type Port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_declarationContext() *Port_declarationContext {
	var p = new(Port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port_declaration
	return p
}

func (*Port_declarationContext) IsPort_declarationContext() {}

func NewPort_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_declarationContext {
	var p = new(Port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port_declaration

	return p
}

func (s *Port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_declarationContext) Inout_declaration() IInout_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_declarationContext)
}

func (s *Port_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Port_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Port_declarationContext) Input_declaration() IInput_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_declarationContext)
}

func (s *Port_declarationContext) Output_declaration() IOutput_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_declarationContext)
}

func (s *Port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPort_declaration(s)
	}
}

func (s *Port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPort_declaration(s)
	}
}

func (p *VerilogParser) Port_declaration() (localctx IPort_declarationContext) {
	this := p
	_ = this

	localctx = NewPort_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, VerilogParserRULE_port_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1298)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1280)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1277)
				p.Attribute_instance()
			}

			p.SetState(1282)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1283)
			p.Inout_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1287)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1284)
				p.Attribute_instance()
			}

			p.SetState(1289)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1290)
			p.Input_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1294)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1291)
				p.Attribute_instance()
			}

			p.SetState(1296)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1297)
			p.Output_declaration()
		}

	}

	return localctx
}

// IModule_itemContext is an interface to support dynamic dispatch.
type IModule_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_itemContext differentiates from other interfaces.
	IsModule_itemContext()
}

type Module_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_itemContext() *Module_itemContext {
	var p = new(Module_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_item
	return p
}

func (*Module_itemContext) IsModule_itemContext() {}

func NewModule_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_itemContext {
	var p = new(Module_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_item

	return p
}

func (s *Module_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_itemContext) Port_declaration() IPort_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_declarationContext)
}

func (s *Module_itemContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Module_itemContext) Non_port_module_item() INon_port_module_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_port_module_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INon_port_module_itemContext)
}

func (s *Module_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_item(s)
	}
}

func (s *Module_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_item(s)
	}
}

func (p *VerilogParser) Module_item() (localctx IModule_itemContext) {
	this := p
	_ = this

	localctx = NewModule_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, VerilogParserRULE_module_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1304)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1300)
			p.Port_declaration()
		}
		{
			p.SetState(1301)
			p.Match(VerilogParserSEMICOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1303)
			p.Non_port_module_item()
		}

	}

	return localctx
}

// IModule_or_generate_itemContext is an interface to support dynamic dispatch.
type IModule_or_generate_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_or_generate_itemContext differentiates from other interfaces.
	IsModule_or_generate_itemContext()
}

type Module_or_generate_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_or_generate_itemContext() *Module_or_generate_itemContext {
	var p = new(Module_or_generate_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_or_generate_item
	return p
}

func (*Module_or_generate_itemContext) IsModule_or_generate_itemContext() {}

func NewModule_or_generate_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_or_generate_itemContext {
	var p = new(Module_or_generate_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_or_generate_item

	return p
}

func (s *Module_or_generate_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_or_generate_itemContext) Module_or_generate_item_declaration() IModule_or_generate_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_item_declarationContext)
}

func (s *Module_or_generate_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_or_generate_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_or_generate_itemContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Module_or_generate_itemContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Module_or_generate_itemContext) Parameter_override() IParameter_overrideContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_overrideContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_overrideContext)
}

func (s *Module_or_generate_itemContext) Continuous_assign() IContinuous_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinuous_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinuous_assignContext)
}

func (s *Module_or_generate_itemContext) Gate_instantiation() IGate_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instantiationContext)
}

func (s *Module_or_generate_itemContext) Module_instantiation() IModule_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_instantiationContext)
}

func (s *Module_or_generate_itemContext) Initial_construct() IInitial_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitial_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitial_constructContext)
}

func (s *Module_or_generate_itemContext) Always_construct() IAlways_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlways_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlways_constructContext)
}

func (s *Module_or_generate_itemContext) Loop_generate_construct() ILoop_generate_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_generate_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_generate_constructContext)
}

func (s *Module_or_generate_itemContext) Conditional_generate_construct() IConditional_generate_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_generate_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_generate_constructContext)
}

func (s *Module_or_generate_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_or_generate_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_or_generate_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_or_generate_item(s)
	}
}

func (s *Module_or_generate_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_or_generate_item(s)
	}
}

func (p *VerilogParser) Module_or_generate_item() (localctx IModule_or_generate_itemContext) {
	this := p
	_ = this

	localctx = NewModule_or_generate_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, VerilogParserRULE_module_or_generate_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1378)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1309)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1306)
				p.Attribute_instance()
			}

			p.SetState(1311)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1312)
			p.Module_or_generate_item_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1316)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1313)
				p.Attribute_instance()
			}

			p.SetState(1318)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1319)
			p.Local_parameter_declaration()
		}
		{
			p.SetState(1320)
			p.Match(VerilogParserSEMICOLON)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1325)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1322)
				p.Attribute_instance()
			}

			p.SetState(1327)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1328)
			p.Parameter_override()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1332)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1329)
				p.Attribute_instance()
			}

			p.SetState(1334)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1335)
			p.Continuous_assign()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1339)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1336)
				p.Attribute_instance()
			}

			p.SetState(1341)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1342)
			p.Gate_instantiation()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1346)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1343)
				p.Attribute_instance()
			}

			p.SetState(1348)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1349)
			p.Module_instantiation()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(1353)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1350)
				p.Attribute_instance()
			}

			p.SetState(1355)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1356)
			p.Initial_construct()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(1360)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1357)
				p.Attribute_instance()
			}

			p.SetState(1362)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1363)
			p.Always_construct()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(1367)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1364)
				p.Attribute_instance()
			}

			p.SetState(1369)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1370)
			p.Loop_generate_construct()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		p.SetState(1374)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1371)
					p.Attribute_instance()
				}

			}
			p.SetState(1376)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())
		}
		{
			p.SetState(1377)
			p.Conditional_generate_construct()
		}

	}

	return localctx
}

// IModule_or_generate_item_declarationContext is an interface to support dynamic dispatch.
type IModule_or_generate_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_or_generate_item_declarationContext differentiates from other interfaces.
	IsModule_or_generate_item_declarationContext()
}

type Module_or_generate_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_or_generate_item_declarationContext() *Module_or_generate_item_declarationContext {
	var p = new(Module_or_generate_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_or_generate_item_declaration
	return p
}

func (*Module_or_generate_item_declarationContext) IsModule_or_generate_item_declarationContext() {}

func NewModule_or_generate_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_or_generate_item_declarationContext {
	var p = new(Module_or_generate_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_or_generate_item_declaration

	return p
}

func (s *Module_or_generate_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_or_generate_item_declarationContext) Net_declaration() INet_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Reg_declaration() IReg_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReg_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReg_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Integer_declaration() IInteger_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Real_declaration() IReal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Time_declaration() ITime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Realtime_declaration() IRealtime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRealtime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRealtime_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Event_declaration() IEvent_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Genvar_declaration() IGenvar_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Task_declaration() ITask_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Function_declaration() IFunction_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_or_generate_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_or_generate_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_or_generate_item_declaration(s)
	}
}

func (s *Module_or_generate_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_or_generate_item_declaration(s)
	}
}

func (p *VerilogParser) Module_or_generate_item_declaration() (localctx IModule_or_generate_item_declarationContext) {
	this := p
	_ = this

	localctx = NewModule_or_generate_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, VerilogParserRULE_module_or_generate_item_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1390)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserSUPPLY0, VerilogParserSUPPLY1, VerilogParserTRI, VerilogParserTRI0, VerilogParserTRI1, VerilogParserTRIAND, VerilogParserTRIOR, VerilogParserTRIREG, VerilogParserWAND, VerilogParserWIRE, VerilogParserWOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1380)
			p.Net_declaration()
		}

	case VerilogParserREG:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1381)
			p.Reg_declaration()
		}

	case VerilogParserINTEGER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1382)
			p.Integer_declaration()
		}

	case VerilogParserREAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1383)
			p.Real_declaration()
		}

	case VerilogParserTIME:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1384)
			p.Time_declaration()
		}

	case VerilogParserREALTIME:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1385)
			p.Realtime_declaration()
		}

	case VerilogParserEVENT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1386)
			p.Event_declaration()
		}

	case VerilogParserGENVAR:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1387)
			p.Genvar_declaration()
		}

	case VerilogParserTASK:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1388)
			p.Task_declaration()
		}

	case VerilogParserFUNCTION:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1389)
			p.Function_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INon_port_module_itemContext is an interface to support dynamic dispatch.
type INon_port_module_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_port_module_itemContext differentiates from other interfaces.
	IsNon_port_module_itemContext()
}

type Non_port_module_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_port_module_itemContext() *Non_port_module_itemContext {
	var p = new(Non_port_module_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_non_port_module_item
	return p
}

func (*Non_port_module_itemContext) IsNon_port_module_itemContext() {}

func NewNon_port_module_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_port_module_itemContext {
	var p = new(Non_port_module_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_non_port_module_item

	return p
}

func (s *Non_port_module_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_port_module_itemContext) Module_or_generate_item() IModule_or_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_itemContext)
}

func (s *Non_port_module_itemContext) Generate_region() IGenerate_regionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_regionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_regionContext)
}

func (s *Non_port_module_itemContext) Specify_block() ISpecify_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_blockContext)
}

func (s *Non_port_module_itemContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Non_port_module_itemContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Non_port_module_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Non_port_module_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Non_port_module_itemContext) Specparam_declaration() ISpecparam_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_declarationContext)
}

func (s *Non_port_module_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_port_module_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_port_module_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNon_port_module_item(s)
	}
}

func (s *Non_port_module_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNon_port_module_item(s)
	}
}

func (p *VerilogParser) Non_port_module_item() (localctx INon_port_module_itemContext) {
	this := p
	_ = this

	localctx = NewNon_port_module_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, VerilogParserRULE_non_port_module_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1411)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1392)
			p.Module_or_generate_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1393)
			p.Generate_region()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1394)
			p.Specify_block()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1398)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1395)
				p.Attribute_instance()
			}

			p.SetState(1400)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1401)
			p.Parameter_declaration()
		}
		{
			p.SetState(1402)
			p.Match(VerilogParserSEMICOLON)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1407)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1404)
				p.Attribute_instance()
			}

			p.SetState(1409)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1410)
			p.Specparam_declaration()
		}

	}

	return localctx
}

// IParameter_overrideContext is an interface to support dynamic dispatch.
type IParameter_overrideContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_overrideContext differentiates from other interfaces.
	IsParameter_overrideContext()
}

type Parameter_overrideContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_overrideContext() *Parameter_overrideContext {
	var p = new(Parameter_overrideContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_override
	return p
}

func (*Parameter_overrideContext) IsParameter_overrideContext() {}

func NewParameter_overrideContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_overrideContext {
	var p = new(Parameter_overrideContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_override

	return p
}

func (s *Parameter_overrideContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_overrideContext) DEFPARAM() antlr.TerminalNode {
	return s.GetToken(VerilogParserDEFPARAM, 0)
}

func (s *Parameter_overrideContext) List_of_param_assignments() IList_of_param_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_param_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_param_assignmentsContext)
}

func (s *Parameter_overrideContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Parameter_overrideContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_overrideContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_overrideContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParameter_override(s)
	}
}

func (s *Parameter_overrideContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParameter_override(s)
	}
}

func (p *VerilogParser) Parameter_override() (localctx IParameter_overrideContext) {
	this := p
	_ = this

	localctx = NewParameter_overrideContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, VerilogParserRULE_parameter_override)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1413)
		p.Match(VerilogParserDEFPARAM)
	}
	{
		p.SetState(1414)
		p.List_of_param_assignments()
	}
	{
		p.SetState(1415)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IConfig_declarationContext is an interface to support dynamic dispatch.
type IConfig_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfig_declarationContext differentiates from other interfaces.
	IsConfig_declarationContext()
}

type Config_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfig_declarationContext() *Config_declarationContext {
	var p = new(Config_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_config_declaration
	return p
}

func (*Config_declarationContext) IsConfig_declarationContext() {}

func NewConfig_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Config_declarationContext {
	var p = new(Config_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_config_declaration

	return p
}

func (s *Config_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Config_declarationContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(VerilogParserCONFIG, 0)
}

func (s *Config_declarationContext) Config_identifier() IConfig_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfig_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfig_identifierContext)
}

func (s *Config_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Config_declarationContext) Design_statement() IDesign_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesign_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesign_statementContext)
}

func (s *Config_declarationContext) ENDCONFIG() antlr.TerminalNode {
	return s.GetToken(VerilogParserENDCONFIG, 0)
}

func (s *Config_declarationContext) AllConfig_rule_statement() []IConfig_rule_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConfig_rule_statementContext)(nil)).Elem())
	var tst = make([]IConfig_rule_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConfig_rule_statementContext)
		}
	}

	return tst
}

func (s *Config_declarationContext) Config_rule_statement(i int) IConfig_rule_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfig_rule_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConfig_rule_statementContext)
}

func (s *Config_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Config_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Config_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConfig_declaration(s)
	}
}

func (s *Config_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConfig_declaration(s)
	}
}

func (p *VerilogParser) Config_declaration() (localctx IConfig_declarationContext) {
	this := p
	_ = this

	localctx = NewConfig_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, VerilogParserRULE_config_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1417)
		p.Match(VerilogParserCONFIG)
	}
	{
		p.SetState(1418)
		p.Config_identifier()
	}
	{
		p.SetState(1419)
		p.Match(VerilogParserSEMICOLON)
	}
	{
		p.SetState(1420)
		p.Design_statement()
	}
	p.SetState(1424)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCELL || _la == VerilogParserDEFAULT || _la == VerilogParserINSTANCE {
		{
			p.SetState(1421)
			p.Config_rule_statement()
		}

		p.SetState(1426)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1427)
		p.Match(VerilogParserENDCONFIG)
	}

	return localctx
}

// IDesign_statementContext is an interface to support dynamic dispatch.
type IDesign_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesign_statementContext differentiates from other interfaces.
	IsDesign_statementContext()
}

type Design_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesign_statementContext() *Design_statementContext {
	var p = new(Design_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_design_statement
	return p
}

func (*Design_statementContext) IsDesign_statementContext() {}

func NewDesign_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Design_statementContext {
	var p = new(Design_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_design_statement

	return p
}

func (s *Design_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Design_statementContext) DESIGN() antlr.TerminalNode {
	return s.GetToken(VerilogParserDESIGN, 0)
}

func (s *Design_statementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Design_statementContext) AllCell_identifier() []ICell_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem())
	var tst = make([]ICell_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICell_identifierContext)
		}
	}

	return tst
}

func (s *Design_statementContext) Cell_identifier(i int) ICell_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICell_identifierContext)
}

func (s *Design_statementContext) AllLibrary_identifier() []ILibrary_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem())
	var tst = make([]ILibrary_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibrary_identifierContext)
		}
	}

	return tst
}

func (s *Design_statementContext) Library_identifier(i int) ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Design_statementContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserDOT)
}

func (s *Design_statementContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserDOT, i)
}

func (s *Design_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Design_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Design_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDesign_statement(s)
	}
}

func (s *Design_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDesign_statement(s)
	}
}

func (p *VerilogParser) Design_statement() (localctx IDesign_statementContext) {
	this := p
	_ = this

	localctx = NewDesign_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, VerilogParserRULE_design_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1429)
		p.Match(VerilogParserDESIGN)
	}
	p.SetState(1438)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserESCAPED_IDENTIFIER || _la == VerilogParserSIMPLE_IDENTIFIER {
		p.SetState(1433)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1430)
				p.Library_identifier()
			}
			{
				p.SetState(1431)
				p.Match(VerilogParserDOT)
			}

		}
		{
			p.SetState(1435)
			p.Cell_identifier()
		}

		p.SetState(1440)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1441)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IConfig_rule_statementContext is an interface to support dynamic dispatch.
type IConfig_rule_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfig_rule_statementContext differentiates from other interfaces.
	IsConfig_rule_statementContext()
}

type Config_rule_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfig_rule_statementContext() *Config_rule_statementContext {
	var p = new(Config_rule_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_config_rule_statement
	return p
}

func (*Config_rule_statementContext) IsConfig_rule_statementContext() {}

func NewConfig_rule_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Config_rule_statementContext {
	var p = new(Config_rule_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_config_rule_statement

	return p
}

func (s *Config_rule_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Config_rule_statementContext) Default_clause() IDefault_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_clauseContext)
}

func (s *Config_rule_statementContext) Liblist_clause() ILiblist_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiblist_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiblist_clauseContext)
}

func (s *Config_rule_statementContext) Inst_clause() IInst_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInst_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInst_clauseContext)
}

func (s *Config_rule_statementContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Config_rule_statementContext) Cell_clause() ICell_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICell_clauseContext)
}

func (s *Config_rule_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Config_rule_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Config_rule_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConfig_rule_statement(s)
	}
}

func (s *Config_rule_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConfig_rule_statement(s)
	}
}

func (p *VerilogParser) Config_rule_statement() (localctx IConfig_rule_statementContext) {
	this := p
	_ = this

	localctx = NewConfig_rule_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, VerilogParserRULE_config_rule_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1458)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1443)
			p.Default_clause()
		}
		{
			p.SetState(1444)
			p.Liblist_clause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1446)
			p.Inst_clause()
		}
		{
			p.SetState(1447)
			p.Liblist_clause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1449)
			p.Inst_clause()
		}
		{
			p.SetState(1450)
			p.Use_clause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1452)
			p.Cell_clause()
		}
		{
			p.SetState(1453)
			p.Liblist_clause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1455)
			p.Cell_clause()
		}
		{
			p.SetState(1456)
			p.Use_clause()
		}

	}

	return localctx
}

// IDefault_clauseContext is an interface to support dynamic dispatch.
type IDefault_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefault_clauseContext differentiates from other interfaces.
	IsDefault_clauseContext()
}

type Default_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefault_clauseContext() *Default_clauseContext {
	var p = new(Default_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_default_clause
	return p
}

func (*Default_clauseContext) IsDefault_clauseContext() {}

func NewDefault_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Default_clauseContext {
	var p = new(Default_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_default_clause

	return p
}

func (s *Default_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Default_clauseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(VerilogParserDEFAULT, 0)
}

func (s *Default_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Default_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Default_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDefault_clause(s)
	}
}

func (s *Default_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDefault_clause(s)
	}
}

func (p *VerilogParser) Default_clause() (localctx IDefault_clauseContext) {
	this := p
	_ = this

	localctx = NewDefault_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, VerilogParserRULE_default_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1460)
		p.Match(VerilogParserDEFAULT)
	}

	return localctx
}

// IInst_clauseContext is an interface to support dynamic dispatch.
type IInst_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInst_clauseContext differentiates from other interfaces.
	IsInst_clauseContext()
}

type Inst_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInst_clauseContext() *Inst_clauseContext {
	var p = new(Inst_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inst_clause
	return p
}

func (*Inst_clauseContext) IsInst_clauseContext() {}

func NewInst_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inst_clauseContext {
	var p = new(Inst_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inst_clause

	return p
}

func (s *Inst_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Inst_clauseContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(VerilogParserINSTANCE, 0)
}

func (s *Inst_clauseContext) Inst_name() IInst_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInst_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInst_nameContext)
}

func (s *Inst_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inst_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inst_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInst_clause(s)
	}
}

func (s *Inst_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInst_clause(s)
	}
}

func (p *VerilogParser) Inst_clause() (localctx IInst_clauseContext) {
	this := p
	_ = this

	localctx = NewInst_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, VerilogParserRULE_inst_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1462)
		p.Match(VerilogParserINSTANCE)
	}
	{
		p.SetState(1463)
		p.Inst_name()
	}

	return localctx
}

// IInst_nameContext is an interface to support dynamic dispatch.
type IInst_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInst_nameContext differentiates from other interfaces.
	IsInst_nameContext()
}

type Inst_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInst_nameContext() *Inst_nameContext {
	var p = new(Inst_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inst_name
	return p
}

func (*Inst_nameContext) IsInst_nameContext() {}

func NewInst_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inst_nameContext {
	var p = new(Inst_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inst_name

	return p
}

func (s *Inst_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Inst_nameContext) Topmodule_identifier() ITopmodule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopmodule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopmodule_identifierContext)
}

func (s *Inst_nameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserDOT)
}

func (s *Inst_nameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserDOT, i)
}

func (s *Inst_nameContext) AllInstance_identifier() []IInstance_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstance_identifierContext)(nil)).Elem())
	var tst = make([]IInstance_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstance_identifierContext)
		}
	}

	return tst
}

func (s *Inst_nameContext) Instance_identifier(i int) IInstance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstance_identifierContext)
}

func (s *Inst_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inst_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inst_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInst_name(s)
	}
}

func (s *Inst_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInst_name(s)
	}
}

func (p *VerilogParser) Inst_name() (localctx IInst_nameContext) {
	this := p
	_ = this

	localctx = NewInst_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, VerilogParserRULE_inst_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1465)
		p.Topmodule_identifier()
	}
	p.SetState(1470)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserDOT {
		{
			p.SetState(1466)
			p.Match(VerilogParserDOT)
		}
		{
			p.SetState(1467)
			p.Instance_identifier()
		}

		p.SetState(1472)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICell_clauseContext is an interface to support dynamic dispatch.
type ICell_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCell_clauseContext differentiates from other interfaces.
	IsCell_clauseContext()
}

type Cell_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCell_clauseContext() *Cell_clauseContext {
	var p = new(Cell_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_cell_clause
	return p
}

func (*Cell_clauseContext) IsCell_clauseContext() {}

func NewCell_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cell_clauseContext {
	var p = new(Cell_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_cell_clause

	return p
}

func (s *Cell_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Cell_clauseContext) CELL() antlr.TerminalNode {
	return s.GetToken(VerilogParserCELL, 0)
}

func (s *Cell_clauseContext) Cell_identifier() ICell_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICell_identifierContext)
}

func (s *Cell_clauseContext) Library_identifier() ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Cell_clauseContext) DOT() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOT, 0)
}

func (s *Cell_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cell_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cell_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCell_clause(s)
	}
}

func (s *Cell_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCell_clause(s)
	}
}

func (p *VerilogParser) Cell_clause() (localctx ICell_clauseContext) {
	this := p
	_ = this

	localctx = NewCell_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, VerilogParserRULE_cell_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1473)
		p.Match(VerilogParserCELL)
	}
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1474)
			p.Library_identifier()
		}
		{
			p.SetState(1475)
			p.Match(VerilogParserDOT)
		}

	}
	{
		p.SetState(1479)
		p.Cell_identifier()
	}

	return localctx
}

// ILiblist_clauseContext is an interface to support dynamic dispatch.
type ILiblist_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiblist_clauseContext differentiates from other interfaces.
	IsLiblist_clauseContext()
}

type Liblist_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiblist_clauseContext() *Liblist_clauseContext {
	var p = new(Liblist_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_liblist_clause
	return p
}

func (*Liblist_clauseContext) IsLiblist_clauseContext() {}

func NewLiblist_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Liblist_clauseContext {
	var p = new(Liblist_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_liblist_clause

	return p
}

func (s *Liblist_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Liblist_clauseContext) LIBLIST() antlr.TerminalNode {
	return s.GetToken(VerilogParserLIBLIST, 0)
}

func (s *Liblist_clauseContext) AllLibrary_identifier() []ILibrary_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem())
	var tst = make([]ILibrary_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibrary_identifierContext)
		}
	}

	return tst
}

func (s *Liblist_clauseContext) Library_identifier(i int) ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Liblist_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Liblist_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Liblist_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLiblist_clause(s)
	}
}

func (s *Liblist_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLiblist_clause(s)
	}
}

func (p *VerilogParser) Liblist_clause() (localctx ILiblist_clauseContext) {
	this := p
	_ = this

	localctx = NewLiblist_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, VerilogParserRULE_liblist_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1481)
		p.Match(VerilogParserLIBLIST)
	}
	p.SetState(1485)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserESCAPED_IDENTIFIER || _la == VerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(1482)
			p.Library_identifier()
		}

		p.SetState(1487)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUse_clauseContext is an interface to support dynamic dispatch.
type IUse_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUse_clauseContext differentiates from other interfaces.
	IsUse_clauseContext()
}

type Use_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_clauseContext() *Use_clauseContext {
	var p = new(Use_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_use_clause
	return p
}

func (*Use_clauseContext) IsUse_clauseContext() {}

func NewUse_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_clauseContext {
	var p = new(Use_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_use_clause

	return p
}

func (s *Use_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_clauseContext) USE() antlr.TerminalNode {
	return s.GetToken(VerilogParserUSE, 0)
}

func (s *Use_clauseContext) Cell_identifier() ICell_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICell_identifierContext)
}

func (s *Use_clauseContext) Library_identifier() ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Use_clauseContext) DOT() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOT, 0)
}

func (s *Use_clauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *Use_clauseContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(VerilogParserCONFIG, 0)
}

func (s *Use_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterUse_clause(s)
	}
}

func (s *Use_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitUse_clause(s)
	}
}

func (p *VerilogParser) Use_clause() (localctx IUse_clauseContext) {
	this := p
	_ = this

	localctx = NewUse_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, VerilogParserRULE_use_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1488)
		p.Match(VerilogParserUSE)
	}
	p.SetState(1492)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1489)
			p.Library_identifier()
		}
		{
			p.SetState(1490)
			p.Match(VerilogParserDOT)
		}

	}
	{
		p.SetState(1494)
		p.Cell_identifier()
	}
	p.SetState(1497)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserCOLON {
		{
			p.SetState(1495)
			p.Match(VerilogParserCOLON)
		}
		{
			p.SetState(1496)
			p.Match(VerilogParserCONFIG)
		}

	}

	return localctx
}

// ILocal_parameter_declarationContext is an interface to support dynamic dispatch.
type ILocal_parameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocal_parameter_declarationContext differentiates from other interfaces.
	IsLocal_parameter_declarationContext()
}

type Local_parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocal_parameter_declarationContext() *Local_parameter_declarationContext {
	var p = new(Local_parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_local_parameter_declaration
	return p
}

func (*Local_parameter_declarationContext) IsLocal_parameter_declarationContext() {}

func NewLocal_parameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Local_parameter_declarationContext {
	var p = new(Local_parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_local_parameter_declaration

	return p
}

func (s *Local_parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Local_parameter_declarationContext) LOCALPARAM() antlr.TerminalNode {
	return s.GetToken(VerilogParserLOCALPARAM, 0)
}

func (s *Local_parameter_declarationContext) List_of_param_assignments() IList_of_param_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_param_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_param_assignmentsContext)
}

func (s *Local_parameter_declarationContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(VerilogParserSIGNED, 0)
}

func (s *Local_parameter_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Local_parameter_declarationContext) Parameter_type() IParameter_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_typeContext)
}

func (s *Local_parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Local_parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Local_parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLocal_parameter_declaration(s)
	}
}

func (s *Local_parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLocal_parameter_declaration(s)
	}
}

func (p *VerilogParser) Local_parameter_declaration() (localctx ILocal_parameter_declarationContext) {
	this := p
	_ = this

	localctx = NewLocal_parameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, VerilogParserRULE_local_parameter_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1511)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1499)
			p.Match(VerilogParserLOCALPARAM)
		}
		p.SetState(1501)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(1500)
				p.Match(VerilogParserSIGNED)
			}

		}
		p.SetState(1504)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_BRACKET {
			{
				p.SetState(1503)
				p.Range_()
			}

		}
		{
			p.SetState(1506)
			p.List_of_param_assignments()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1507)
			p.Match(VerilogParserLOCALPARAM)
		}
		{
			p.SetState(1508)
			p.Parameter_type()
		}
		{
			p.SetState(1509)
			p.List_of_param_assignments()
		}

	}

	return localctx
}

// IParameter_declarationContext is an interface to support dynamic dispatch.
type IParameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declarationContext differentiates from other interfaces.
	IsParameter_declarationContext()
}

type Parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declarationContext() *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_declaration
	return p
}

func (*Parameter_declarationContext) IsParameter_declarationContext() {}

func NewParameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_declaration

	return p
}

func (s *Parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declarationContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(VerilogParserPARAMETER, 0)
}

func (s *Parameter_declarationContext) List_of_param_assignments() IList_of_param_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_param_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_param_assignmentsContext)
}

func (s *Parameter_declarationContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(VerilogParserSIGNED, 0)
}

func (s *Parameter_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Parameter_declarationContext) Parameter_type() IParameter_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_typeContext)
}

func (s *Parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParameter_declaration(s)
	}
}

func (s *Parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParameter_declaration(s)
	}
}

func (p *VerilogParser) Parameter_declaration() (localctx IParameter_declarationContext) {
	this := p
	_ = this

	localctx = NewParameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, VerilogParserRULE_parameter_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1525)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1513)
			p.Match(VerilogParserPARAMETER)
		}
		p.SetState(1515)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(1514)
				p.Match(VerilogParserSIGNED)
			}

		}
		p.SetState(1518)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_BRACKET {
			{
				p.SetState(1517)
				p.Range_()
			}

		}
		{
			p.SetState(1520)
			p.List_of_param_assignments()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1521)
			p.Match(VerilogParserPARAMETER)
		}
		{
			p.SetState(1522)
			p.Parameter_type()
		}
		{
			p.SetState(1523)
			p.List_of_param_assignments()
		}

	}

	return localctx
}

// ISpecparam_declarationContext is an interface to support dynamic dispatch.
type ISpecparam_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecparam_declarationContext differentiates from other interfaces.
	IsSpecparam_declarationContext()
}

type Specparam_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecparam_declarationContext() *Specparam_declarationContext {
	var p = new(Specparam_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specparam_declaration
	return p
}

func (*Specparam_declarationContext) IsSpecparam_declarationContext() {}

func NewSpecparam_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specparam_declarationContext {
	var p = new(Specparam_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specparam_declaration

	return p
}

func (s *Specparam_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Specparam_declarationContext) SPECPARAM() antlr.TerminalNode {
	return s.GetToken(VerilogParserSPECPARAM, 0)
}

func (s *Specparam_declarationContext) List_of_specparam_assignments() IList_of_specparam_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_specparam_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_specparam_assignmentsContext)
}

func (s *Specparam_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Specparam_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Specparam_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specparam_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specparam_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecparam_declaration(s)
	}
}

func (s *Specparam_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecparam_declaration(s)
	}
}

func (p *VerilogParser) Specparam_declaration() (localctx ISpecparam_declarationContext) {
	this := p
	_ = this

	localctx = NewSpecparam_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, VerilogParserRULE_specparam_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1527)
		p.Match(VerilogParserSPECPARAM)
	}
	p.SetState(1529)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_BRACKET {
		{
			p.SetState(1528)
			p.Range_()
		}

	}
	{
		p.SetState(1531)
		p.List_of_specparam_assignments()
	}
	{
		p.SetState(1532)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IParameter_typeContext is an interface to support dynamic dispatch.
type IParameter_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_typeContext differentiates from other interfaces.
	IsParameter_typeContext()
}

type Parameter_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_typeContext() *Parameter_typeContext {
	var p = new(Parameter_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_type
	return p
}

func (*Parameter_typeContext) IsParameter_typeContext() {}

func NewParameter_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_typeContext {
	var p = new(Parameter_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_type

	return p
}

func (s *Parameter_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_typeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(VerilogParserINTEGER, 0)
}

func (s *Parameter_typeContext) REAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserREAL, 0)
}

func (s *Parameter_typeContext) REALTIME() antlr.TerminalNode {
	return s.GetToken(VerilogParserREALTIME, 0)
}

func (s *Parameter_typeContext) TIME() antlr.TerminalNode {
	return s.GetToken(VerilogParserTIME, 0)
}

func (s *Parameter_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParameter_type(s)
	}
}

func (s *Parameter_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParameter_type(s)
	}
}

func (p *VerilogParser) Parameter_type() (localctx IParameter_typeContext) {
	this := p
	_ = this

	localctx = NewParameter_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, VerilogParserRULE_parameter_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1534)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-50)&-(0x1f+1)) == 0 && ((1<<uint((_la-50)))&((1<<(VerilogParserINTEGER-50))|(1<<(VerilogParserREAL-50))|(1<<(VerilogParserREALTIME-50)))) != 0) || _la == VerilogParserTIME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IInout_declarationContext is an interface to support dynamic dispatch.
type IInout_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_declarationContext differentiates from other interfaces.
	IsInout_declarationContext()
}

type Inout_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_declarationContext() *Inout_declarationContext {
	var p = new(Inout_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inout_declaration
	return p
}

func (*Inout_declarationContext) IsInout_declarationContext() {}

func NewInout_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_declarationContext {
	var p = new(Inout_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inout_declaration

	return p
}

func (s *Inout_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_declarationContext) INOUT() antlr.TerminalNode {
	return s.GetToken(VerilogParserINOUT, 0)
}

func (s *Inout_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Inout_declarationContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Inout_declarationContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(VerilogParserSIGNED, 0)
}

func (s *Inout_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Inout_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInout_declaration(s)
	}
}

func (s *Inout_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInout_declaration(s)
	}
}

func (p *VerilogParser) Inout_declaration() (localctx IInout_declarationContext) {
	this := p
	_ = this

	localctx = NewInout_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, VerilogParserRULE_inout_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1536)
		p.Match(VerilogParserINOUT)
	}
	p.SetState(1538)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(VerilogParserSUPPLY0-98))|(1<<(VerilogParserSUPPLY1-98))|(1<<(VerilogParserTRI-98))|(1<<(VerilogParserTRI0-98))|(1<<(VerilogParserTRI1-98))|(1<<(VerilogParserTRIAND-98))|(1<<(VerilogParserTRIOR-98))|(1<<(VerilogParserWAND-98))|(1<<(VerilogParserWIRE-98))|(1<<(VerilogParserWOR-98)))) != 0 {
		{
			p.SetState(1537)
			p.Net_type()
		}

	}
	p.SetState(1541)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserSIGNED {
		{
			p.SetState(1540)
			p.Match(VerilogParserSIGNED)
		}

	}
	p.SetState(1544)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_BRACKET {
		{
			p.SetState(1543)
			p.Range_()
		}

	}
	{
		p.SetState(1546)
		p.List_of_port_identifiers()
	}

	return localctx
}

// IInput_declarationContext is an interface to support dynamic dispatch.
type IInput_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_declarationContext differentiates from other interfaces.
	IsInput_declarationContext()
}

type Input_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_declarationContext() *Input_declarationContext {
	var p = new(Input_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_input_declaration
	return p
}

func (*Input_declarationContext) IsInput_declarationContext() {}

func NewInput_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_declarationContext {
	var p = new(Input_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_input_declaration

	return p
}

func (s *Input_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_declarationContext) INPUT() antlr.TerminalNode {
	return s.GetToken(VerilogParserINPUT, 0)
}

func (s *Input_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Input_declarationContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Input_declarationContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(VerilogParserSIGNED, 0)
}

func (s *Input_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Input_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInput_declaration(s)
	}
}

func (s *Input_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInput_declaration(s)
	}
}

func (p *VerilogParser) Input_declaration() (localctx IInput_declarationContext) {
	this := p
	_ = this

	localctx = NewInput_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, VerilogParserRULE_input_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1548)
		p.Match(VerilogParserINPUT)
	}
	p.SetState(1550)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(VerilogParserSUPPLY0-98))|(1<<(VerilogParserSUPPLY1-98))|(1<<(VerilogParserTRI-98))|(1<<(VerilogParserTRI0-98))|(1<<(VerilogParserTRI1-98))|(1<<(VerilogParserTRIAND-98))|(1<<(VerilogParserTRIOR-98))|(1<<(VerilogParserWAND-98))|(1<<(VerilogParserWIRE-98))|(1<<(VerilogParserWOR-98)))) != 0 {
		{
			p.SetState(1549)
			p.Net_type()
		}

	}
	p.SetState(1553)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserSIGNED {
		{
			p.SetState(1552)
			p.Match(VerilogParserSIGNED)
		}

	}
	p.SetState(1556)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_BRACKET {
		{
			p.SetState(1555)
			p.Range_()
		}

	}
	{
		p.SetState(1558)
		p.List_of_port_identifiers()
	}

	return localctx
}

// IOutput_declarationContext is an interface to support dynamic dispatch.
type IOutput_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_declarationContext differentiates from other interfaces.
	IsOutput_declarationContext()
}

type Output_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_declarationContext() *Output_declarationContext {
	var p = new(Output_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_declaration
	return p
}

func (*Output_declarationContext) IsOutput_declarationContext() {}

func NewOutput_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_declarationContext {
	var p = new(Output_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_declaration

	return p
}

func (s *Output_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_declarationContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(VerilogParserOUTPUT, 0)
}

func (s *Output_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Output_declarationContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Output_declarationContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(VerilogParserSIGNED, 0)
}

func (s *Output_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Output_declarationContext) REG() antlr.TerminalNode {
	return s.GetToken(VerilogParserREG, 0)
}

func (s *Output_declarationContext) List_of_variable_port_identifiers() IList_of_variable_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_port_identifiersContext)
}

func (s *Output_declarationContext) Output_variable_type() IOutput_variable_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_variable_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_variable_typeContext)
}

func (s *Output_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterOutput_declaration(s)
	}
}

func (s *Output_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitOutput_declaration(s)
	}
}

func (p *VerilogParser) Output_declaration() (localctx IOutput_declarationContext) {
	this := p
	_ = this

	localctx = NewOutput_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, VerilogParserRULE_output_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1584)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1560)
			p.Match(VerilogParserOUTPUT)
		}
		p.SetState(1562)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(VerilogParserSUPPLY0-98))|(1<<(VerilogParserSUPPLY1-98))|(1<<(VerilogParserTRI-98))|(1<<(VerilogParserTRI0-98))|(1<<(VerilogParserTRI1-98))|(1<<(VerilogParserTRIAND-98))|(1<<(VerilogParserTRIOR-98))|(1<<(VerilogParserWAND-98))|(1<<(VerilogParserWIRE-98))|(1<<(VerilogParserWOR-98)))) != 0 {
			{
				p.SetState(1561)
				p.Net_type()
			}

		}
		p.SetState(1565)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(1564)
				p.Match(VerilogParserSIGNED)
			}

		}
		p.SetState(1568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_BRACKET {
			{
				p.SetState(1567)
				p.Range_()
			}

		}
		{
			p.SetState(1570)
			p.List_of_port_identifiers()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1571)
			p.Match(VerilogParserOUTPUT)
		}
		{
			p.SetState(1572)
			p.Match(VerilogParserREG)
		}
		p.SetState(1574)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(1573)
				p.Match(VerilogParserSIGNED)
			}

		}
		p.SetState(1577)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_BRACKET {
			{
				p.SetState(1576)
				p.Range_()
			}

		}
		{
			p.SetState(1579)
			p.List_of_variable_port_identifiers()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1580)
			p.Match(VerilogParserOUTPUT)
		}
		{
			p.SetState(1581)
			p.Output_variable_type()
		}
		{
			p.SetState(1582)
			p.List_of_variable_port_identifiers()
		}

	}

	return localctx
}

// IEvent_declarationContext is an interface to support dynamic dispatch.
type IEvent_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_declarationContext differentiates from other interfaces.
	IsEvent_declarationContext()
}

type Event_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_declarationContext() *Event_declarationContext {
	var p = new(Event_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_declaration
	return p
}

func (*Event_declarationContext) IsEvent_declarationContext() {}

func NewEvent_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_declarationContext {
	var p = new(Event_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_declaration

	return p
}

func (s *Event_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_declarationContext) EVENT() antlr.TerminalNode {
	return s.GetToken(VerilogParserEVENT, 0)
}

func (s *Event_declarationContext) List_of_event_identifiers() IList_of_event_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_event_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_event_identifiersContext)
}

func (s *Event_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Event_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEvent_declaration(s)
	}
}

func (s *Event_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEvent_declaration(s)
	}
}

func (p *VerilogParser) Event_declaration() (localctx IEvent_declarationContext) {
	this := p
	_ = this

	localctx = NewEvent_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, VerilogParserRULE_event_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1586)
		p.Match(VerilogParserEVENT)
	}
	{
		p.SetState(1587)
		p.List_of_event_identifiers()
	}
	{
		p.SetState(1588)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IInteger_declarationContext is an interface to support dynamic dispatch.
type IInteger_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInteger_declarationContext differentiates from other interfaces.
	IsInteger_declarationContext()
}

type Integer_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_declarationContext() *Integer_declarationContext {
	var p = new(Integer_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_integer_declaration
	return p
}

func (*Integer_declarationContext) IsInteger_declarationContext() {}

func NewInteger_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_declarationContext {
	var p = new(Integer_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_integer_declaration

	return p
}

func (s *Integer_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_declarationContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(VerilogParserINTEGER, 0)
}

func (s *Integer_declarationContext) List_of_variable_identifiers() IList_of_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_identifiersContext)
}

func (s *Integer_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Integer_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInteger_declaration(s)
	}
}

func (s *Integer_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInteger_declaration(s)
	}
}

func (p *VerilogParser) Integer_declaration() (localctx IInteger_declarationContext) {
	this := p
	_ = this

	localctx = NewInteger_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, VerilogParserRULE_integer_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1590)
		p.Match(VerilogParserINTEGER)
	}
	{
		p.SetState(1591)
		p.List_of_variable_identifiers()
	}
	{
		p.SetState(1592)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// INet_declarationContext is an interface to support dynamic dispatch.
type INet_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_declarationContext differentiates from other interfaces.
	IsNet_declarationContext()
}

type Net_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_declarationContext() *Net_declarationContext {
	var p = new(Net_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_declaration
	return p
}

func (*Net_declarationContext) IsNet_declarationContext() {}

func NewNet_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_declarationContext {
	var p = new(Net_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_declaration

	return p
}

func (s *Net_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_declarationContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Net_declarationContext) List_of_net_identifiers() IList_of_net_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_net_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_net_identifiersContext)
}

func (s *Net_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Net_declarationContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(VerilogParserSIGNED, 0)
}

func (s *Net_declarationContext) Delay3() IDelay3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay3Context)
}

func (s *Net_declarationContext) List_of_net_decl_assignments() IList_of_net_decl_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_net_decl_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_net_decl_assignmentsContext)
}

func (s *Net_declarationContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Net_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Net_declarationContext) VECTORED() antlr.TerminalNode {
	return s.GetToken(VerilogParserVECTORED, 0)
}

func (s *Net_declarationContext) SCALARED() antlr.TerminalNode {
	return s.GetToken(VerilogParserSCALARED, 0)
}

func (s *Net_declarationContext) TRIREG() antlr.TerminalNode {
	return s.GetToken(VerilogParserTRIREG, 0)
}

func (s *Net_declarationContext) Charge_strength() ICharge_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharge_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharge_strengthContext)
}

func (s *Net_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNet_declaration(s)
	}
}

func (s *Net_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNet_declaration(s)
	}
}

func (p *VerilogParser) Net_declaration() (localctx INet_declarationContext) {
	this := p
	_ = this

	localctx = NewNet_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, VerilogParserRULE_net_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1708)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1594)
			p.Net_type()
		}
		p.SetState(1596)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(1595)
				p.Match(VerilogParserSIGNED)
			}

		}
		p.SetState(1599)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(1598)
				p.Delay3()
			}

		}
		{
			p.SetState(1601)
			p.List_of_net_identifiers()
		}
		{
			p.SetState(1602)
			p.Match(VerilogParserSEMICOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1604)
			p.Net_type()
		}
		p.SetState(1606)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1605)
				p.Drive_strength()
			}

		}
		p.SetState(1609)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(1608)
				p.Match(VerilogParserSIGNED)
			}

		}
		p.SetState(1612)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(1611)
				p.Delay3()
			}

		}
		{
			p.SetState(1614)
			p.List_of_net_decl_assignments()
		}
		{
			p.SetState(1615)
			p.Match(VerilogParserSEMICOLON)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1617)
			p.Net_type()
		}
		p.SetState(1619)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSCALARED || _la == VerilogParserVECTORED {
			{
				p.SetState(1618)
				_la = p.GetTokenStream().LA(1)

				if !(_la == VerilogParserSCALARED || _la == VerilogParserVECTORED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1622)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(1621)
				p.Match(VerilogParserSIGNED)
			}

		}
		{
			p.SetState(1624)
			p.Range_()
		}
		p.SetState(1626)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(1625)
				p.Delay3()
			}

		}
		{
			p.SetState(1628)
			p.List_of_net_identifiers()
		}
		{
			p.SetState(1629)
			p.Match(VerilogParserSEMICOLON)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1631)
			p.Net_type()
		}
		p.SetState(1633)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1632)
				p.Drive_strength()
			}

		}
		p.SetState(1636)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSCALARED || _la == VerilogParserVECTORED {
			{
				p.SetState(1635)
				_la = p.GetTokenStream().LA(1)

				if !(_la == VerilogParserSCALARED || _la == VerilogParserVECTORED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1639)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(1638)
				p.Match(VerilogParserSIGNED)
			}

		}
		{
			p.SetState(1641)
			p.Range_()
		}
		p.SetState(1643)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(1642)
				p.Delay3()
			}

		}
		{
			p.SetState(1645)
			p.List_of_net_decl_assignments()
		}
		{
			p.SetState(1646)
			p.Match(VerilogParserSEMICOLON)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1648)
			p.Match(VerilogParserTRIREG)
		}
		p.SetState(1650)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1649)
				p.Charge_strength()
			}

		}
		p.SetState(1653)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(1652)
				p.Match(VerilogParserSIGNED)
			}

		}
		p.SetState(1656)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(1655)
				p.Delay3()
			}

		}
		{
			p.SetState(1658)
			p.List_of_net_identifiers()
		}
		{
			p.SetState(1659)
			p.Match(VerilogParserSEMICOLON)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1661)
			p.Match(VerilogParserTRIREG)
		}
		p.SetState(1663)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1662)
				p.Drive_strength()
			}

		}
		p.SetState(1666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(1665)
				p.Match(VerilogParserSIGNED)
			}

		}
		p.SetState(1669)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(1668)
				p.Delay3()
			}

		}
		{
			p.SetState(1671)
			p.List_of_net_decl_assignments()
		}
		{
			p.SetState(1672)
			p.Match(VerilogParserSEMICOLON)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1674)
			p.Match(VerilogParserTRIREG)
		}
		p.SetState(1676)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1675)
				p.Charge_strength()
			}

		}
		p.SetState(1679)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSCALARED || _la == VerilogParserVECTORED {
			{
				p.SetState(1678)
				_la = p.GetTokenStream().LA(1)

				if !(_la == VerilogParserSCALARED || _la == VerilogParserVECTORED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1682)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(1681)
				p.Match(VerilogParserSIGNED)
			}

		}
		{
			p.SetState(1684)
			p.Range_()
		}
		p.SetState(1686)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(1685)
				p.Delay3()
			}

		}
		{
			p.SetState(1688)
			p.List_of_net_identifiers()
		}
		{
			p.SetState(1689)
			p.Match(VerilogParserSEMICOLON)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1691)
			p.Match(VerilogParserTRIREG)
		}
		p.SetState(1693)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(1692)
				p.Drive_strength()
			}

		}
		p.SetState(1696)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSCALARED || _la == VerilogParserVECTORED {
			{
				p.SetState(1695)
				_la = p.GetTokenStream().LA(1)

				if !(_la == VerilogParserSCALARED || _la == VerilogParserVECTORED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1699)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(1698)
				p.Match(VerilogParserSIGNED)
			}

		}
		{
			p.SetState(1701)
			p.Range_()
		}
		p.SetState(1703)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(1702)
				p.Delay3()
			}

		}
		{
			p.SetState(1705)
			p.List_of_net_decl_assignments()
		}
		{
			p.SetState(1706)
			p.Match(VerilogParserSEMICOLON)
		}

	}

	return localctx
}

// IReal_declarationContext is an interface to support dynamic dispatch.
type IReal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReal_declarationContext differentiates from other interfaces.
	IsReal_declarationContext()
}

type Real_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_declarationContext() *Real_declarationContext {
	var p = new(Real_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_real_declaration
	return p
}

func (*Real_declarationContext) IsReal_declarationContext() {}

func NewReal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_declarationContext {
	var p = new(Real_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_real_declaration

	return p
}

func (s *Real_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_declarationContext) REAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserREAL, 0)
}

func (s *Real_declarationContext) List_of_real_identifiers() IList_of_real_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_real_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_real_identifiersContext)
}

func (s *Real_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Real_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterReal_declaration(s)
	}
}

func (s *Real_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitReal_declaration(s)
	}
}

func (p *VerilogParser) Real_declaration() (localctx IReal_declarationContext) {
	this := p
	_ = this

	localctx = NewReal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, VerilogParserRULE_real_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1710)
		p.Match(VerilogParserREAL)
	}
	{
		p.SetState(1711)
		p.List_of_real_identifiers()
	}
	{
		p.SetState(1712)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IRealtime_declarationContext is an interface to support dynamic dispatch.
type IRealtime_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRealtime_declarationContext differentiates from other interfaces.
	IsRealtime_declarationContext()
}

type Realtime_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRealtime_declarationContext() *Realtime_declarationContext {
	var p = new(Realtime_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_realtime_declaration
	return p
}

func (*Realtime_declarationContext) IsRealtime_declarationContext() {}

func NewRealtime_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Realtime_declarationContext {
	var p = new(Realtime_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_realtime_declaration

	return p
}

func (s *Realtime_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Realtime_declarationContext) REALTIME() antlr.TerminalNode {
	return s.GetToken(VerilogParserREALTIME, 0)
}

func (s *Realtime_declarationContext) List_of_real_identifiers() IList_of_real_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_real_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_real_identifiersContext)
}

func (s *Realtime_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Realtime_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Realtime_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Realtime_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterRealtime_declaration(s)
	}
}

func (s *Realtime_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitRealtime_declaration(s)
	}
}

func (p *VerilogParser) Realtime_declaration() (localctx IRealtime_declarationContext) {
	this := p
	_ = this

	localctx = NewRealtime_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, VerilogParserRULE_realtime_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1714)
		p.Match(VerilogParserREALTIME)
	}
	{
		p.SetState(1715)
		p.List_of_real_identifiers()
	}
	{
		p.SetState(1716)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IReg_declarationContext is an interface to support dynamic dispatch.
type IReg_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReg_declarationContext differentiates from other interfaces.
	IsReg_declarationContext()
}

type Reg_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReg_declarationContext() *Reg_declarationContext {
	var p = new(Reg_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_reg_declaration
	return p
}

func (*Reg_declarationContext) IsReg_declarationContext() {}

func NewReg_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reg_declarationContext {
	var p = new(Reg_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_reg_declaration

	return p
}

func (s *Reg_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Reg_declarationContext) REG() antlr.TerminalNode {
	return s.GetToken(VerilogParserREG, 0)
}

func (s *Reg_declarationContext) List_of_variable_identifiers() IList_of_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_identifiersContext)
}

func (s *Reg_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Reg_declarationContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(VerilogParserSIGNED, 0)
}

func (s *Reg_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Reg_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reg_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reg_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterReg_declaration(s)
	}
}

func (s *Reg_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitReg_declaration(s)
	}
}

func (p *VerilogParser) Reg_declaration() (localctx IReg_declarationContext) {
	this := p
	_ = this

	localctx = NewReg_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, VerilogParserRULE_reg_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1718)
		p.Match(VerilogParserREG)
	}
	p.SetState(1720)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserSIGNED {
		{
			p.SetState(1719)
			p.Match(VerilogParserSIGNED)
		}

	}
	p.SetState(1723)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_BRACKET {
		{
			p.SetState(1722)
			p.Range_()
		}

	}
	{
		p.SetState(1725)
		p.List_of_variable_identifiers()
	}
	{
		p.SetState(1726)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// ITime_declarationContext is an interface to support dynamic dispatch.
type ITime_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTime_declarationContext differentiates from other interfaces.
	IsTime_declarationContext()
}

type Time_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTime_declarationContext() *Time_declarationContext {
	var p = new(Time_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_time_declaration
	return p
}

func (*Time_declarationContext) IsTime_declarationContext() {}

func NewTime_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Time_declarationContext {
	var p = new(Time_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_time_declaration

	return p
}

func (s *Time_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Time_declarationContext) TIME() antlr.TerminalNode {
	return s.GetToken(VerilogParserTIME, 0)
}

func (s *Time_declarationContext) List_of_variable_identifiers() IList_of_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_identifiersContext)
}

func (s *Time_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Time_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Time_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Time_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTime_declaration(s)
	}
}

func (s *Time_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTime_declaration(s)
	}
}

func (p *VerilogParser) Time_declaration() (localctx ITime_declarationContext) {
	this := p
	_ = this

	localctx = NewTime_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, VerilogParserRULE_time_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1728)
		p.Match(VerilogParserTIME)
	}
	{
		p.SetState(1729)
		p.List_of_variable_identifiers()
	}
	{
		p.SetState(1730)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// INet_typeContext is an interface to support dynamic dispatch.
type INet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_typeContext differentiates from other interfaces.
	IsNet_typeContext()
}

type Net_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_typeContext() *Net_typeContext {
	var p = new(Net_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_type
	return p
}

func (*Net_typeContext) IsNet_typeContext() {}

func NewNet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_typeContext {
	var p = new(Net_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_type

	return p
}

func (s *Net_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_typeContext) SUPPLY0() antlr.TerminalNode {
	return s.GetToken(VerilogParserSUPPLY0, 0)
}

func (s *Net_typeContext) SUPPLY1() antlr.TerminalNode {
	return s.GetToken(VerilogParserSUPPLY1, 0)
}

func (s *Net_typeContext) TRI() antlr.TerminalNode {
	return s.GetToken(VerilogParserTRI, 0)
}

func (s *Net_typeContext) TRIAND() antlr.TerminalNode {
	return s.GetToken(VerilogParserTRIAND, 0)
}

func (s *Net_typeContext) TRIOR() antlr.TerminalNode {
	return s.GetToken(VerilogParserTRIOR, 0)
}

func (s *Net_typeContext) TRI0() antlr.TerminalNode {
	return s.GetToken(VerilogParserTRI0, 0)
}

func (s *Net_typeContext) TRI1() antlr.TerminalNode {
	return s.GetToken(VerilogParserTRI1, 0)
}

func (s *Net_typeContext) WIRE() antlr.TerminalNode {
	return s.GetToken(VerilogParserWIRE, 0)
}

func (s *Net_typeContext) WAND() antlr.TerminalNode {
	return s.GetToken(VerilogParserWAND, 0)
}

func (s *Net_typeContext) WOR() antlr.TerminalNode {
	return s.GetToken(VerilogParserWOR, 0)
}

func (s *Net_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNet_type(s)
	}
}

func (s *Net_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNet_type(s)
	}
}

func (p *VerilogParser) Net_type() (localctx INet_typeContext) {
	this := p
	_ = this

	localctx = NewNet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, VerilogParserRULE_net_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1732)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(VerilogParserSUPPLY0-98))|(1<<(VerilogParserSUPPLY1-98))|(1<<(VerilogParserTRI-98))|(1<<(VerilogParserTRI0-98))|(1<<(VerilogParserTRI1-98))|(1<<(VerilogParserTRIAND-98))|(1<<(VerilogParserTRIOR-98))|(1<<(VerilogParserWAND-98))|(1<<(VerilogParserWIRE-98))|(1<<(VerilogParserWOR-98)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOutput_variable_typeContext is an interface to support dynamic dispatch.
type IOutput_variable_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_variable_typeContext differentiates from other interfaces.
	IsOutput_variable_typeContext()
}

type Output_variable_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_variable_typeContext() *Output_variable_typeContext {
	var p = new(Output_variable_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_variable_type
	return p
}

func (*Output_variable_typeContext) IsOutput_variable_typeContext() {}

func NewOutput_variable_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_variable_typeContext {
	var p = new(Output_variable_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_variable_type

	return p
}

func (s *Output_variable_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_variable_typeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(VerilogParserINTEGER, 0)
}

func (s *Output_variable_typeContext) TIME() antlr.TerminalNode {
	return s.GetToken(VerilogParserTIME, 0)
}

func (s *Output_variable_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_variable_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_variable_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterOutput_variable_type(s)
	}
}

func (s *Output_variable_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitOutput_variable_type(s)
	}
}

func (p *VerilogParser) Output_variable_type() (localctx IOutput_variable_typeContext) {
	this := p
	_ = this

	localctx = NewOutput_variable_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, VerilogParserRULE_output_variable_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1734)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserINTEGER || _la == VerilogParserTIME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReal_typeContext is an interface to support dynamic dispatch.
type IReal_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReal_typeContext differentiates from other interfaces.
	IsReal_typeContext()
}

type Real_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_typeContext() *Real_typeContext {
	var p = new(Real_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_real_type
	return p
}

func (*Real_typeContext) IsReal_typeContext() {}

func NewReal_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_typeContext {
	var p = new(Real_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_real_type

	return p
}

func (s *Real_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_typeContext) Real_identifier() IReal_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_identifierContext)
}

func (s *Real_typeContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *Real_typeContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Real_typeContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Real_typeContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Real_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterReal_type(s)
	}
}

func (s *Real_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitReal_type(s)
	}
}

func (p *VerilogParser) Real_type() (localctx IReal_typeContext) {
	this := p
	_ = this

	localctx = NewReal_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, VerilogParserRULE_real_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1747)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1736)
			p.Real_identifier()
		}
		p.SetState(1740)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_BRACKET {
			{
				p.SetState(1737)
				p.Dimension()
			}

			p.SetState(1742)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1743)
			p.Real_identifier()
		}
		{
			p.SetState(1744)
			p.Match(VerilogParserEQUAL)
		}
		{
			p.SetState(1745)
			p.constant_expression(0)
		}

	}

	return localctx
}

// IVariable_typeContext is an interface to support dynamic dispatch.
type IVariable_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_typeContext differentiates from other interfaces.
	IsVariable_typeContext()
}

type Variable_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_typeContext() *Variable_typeContext {
	var p = new(Variable_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_type
	return p
}

func (*Variable_typeContext) IsVariable_typeContext() {}

func NewVariable_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_typeContext {
	var p = new(Variable_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_type

	return p
}

func (s *Variable_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_typeContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Variable_typeContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *Variable_typeContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Variable_typeContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Variable_typeContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Variable_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterVariable_type(s)
	}
}

func (s *Variable_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitVariable_type(s)
	}
}

func (p *VerilogParser) Variable_type() (localctx IVariable_typeContext) {
	this := p
	_ = this

	localctx = NewVariable_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, VerilogParserRULE_variable_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1760)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1749)
			p.Variable_identifier()
		}
		p.SetState(1753)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_BRACKET {
			{
				p.SetState(1750)
				p.Dimension()
			}

			p.SetState(1755)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1756)
			p.Variable_identifier()
		}
		{
			p.SetState(1757)
			p.Match(VerilogParserEQUAL)
		}
		{
			p.SetState(1758)
			p.constant_expression(0)
		}

	}

	return localctx
}

// IDrive_strengthContext is an interface to support dynamic dispatch.
type IDrive_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrive_strengthContext differentiates from other interfaces.
	IsDrive_strengthContext()
}

type Drive_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrive_strengthContext() *Drive_strengthContext {
	var p = new(Drive_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_drive_strength
	return p
}

func (*Drive_strengthContext) IsDrive_strengthContext() {}

func NewDrive_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drive_strengthContext {
	var p = new(Drive_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_drive_strength

	return p
}

func (s *Drive_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Drive_strengthContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Drive_strengthContext) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Drive_strengthContext) COMMA() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, 0)
}

func (s *Drive_strengthContext) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Drive_strengthContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Drive_strengthContext) HIGHZ1() antlr.TerminalNode {
	return s.GetToken(VerilogParserHIGHZ1, 0)
}

func (s *Drive_strengthContext) HIGHZ0() antlr.TerminalNode {
	return s.GetToken(VerilogParserHIGHZ0, 0)
}

func (s *Drive_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drive_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drive_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDrive_strength(s)
	}
}

func (s *Drive_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDrive_strength(s)
	}
}

func (p *VerilogParser) Drive_strength() (localctx IDrive_strengthContext) {
	this := p
	_ = this

	localctx = NewDrive_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, VerilogParserRULE_drive_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1798)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1762)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1763)
			p.Strength0()
		}
		{
			p.SetState(1764)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1765)
			p.Strength1()
		}
		{
			p.SetState(1766)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1768)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1769)
			p.Strength1()
		}
		{
			p.SetState(1770)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1771)
			p.Strength0()
		}
		{
			p.SetState(1772)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1774)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1775)
			p.Strength0()
		}
		{
			p.SetState(1776)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1777)
			p.Match(VerilogParserHIGHZ1)
		}
		{
			p.SetState(1778)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1780)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1781)
			p.Strength1()
		}
		{
			p.SetState(1782)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1783)
			p.Match(VerilogParserHIGHZ0)
		}
		{
			p.SetState(1784)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1786)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1787)
			p.Match(VerilogParserHIGHZ0)
		}
		{
			p.SetState(1788)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1789)
			p.Strength1()
		}
		{
			p.SetState(1790)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1792)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1793)
			p.Match(VerilogParserHIGHZ1)
		}
		{
			p.SetState(1794)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1795)
			p.Strength0()
		}
		{
			p.SetState(1796)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}

	return localctx
}

// IStrength0Context is an interface to support dynamic dispatch.
type IStrength0Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrength0Context differentiates from other interfaces.
	IsStrength0Context()
}

type Strength0Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrength0Context() *Strength0Context {
	var p = new(Strength0Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_strength0
	return p
}

func (*Strength0Context) IsStrength0Context() {}

func NewStrength0Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Strength0Context {
	var p = new(Strength0Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_strength0

	return p
}

func (s *Strength0Context) GetParser() antlr.Parser { return s.parser }

func (s *Strength0Context) SUPPLY0() antlr.TerminalNode {
	return s.GetToken(VerilogParserSUPPLY0, 0)
}

func (s *Strength0Context) STRONG0() antlr.TerminalNode {
	return s.GetToken(VerilogParserSTRONG0, 0)
}

func (s *Strength0Context) PULL0() antlr.TerminalNode {
	return s.GetToken(VerilogParserPULL0, 0)
}

func (s *Strength0Context) WEAK0() antlr.TerminalNode {
	return s.GetToken(VerilogParserWEAK0, 0)
}

func (s *Strength0Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Strength0Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Strength0Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStrength0(s)
	}
}

func (s *Strength0Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStrength0(s)
	}
}

func (p *VerilogParser) Strength0() (localctx IStrength0Context) {
	this := p
	_ = this

	localctx = NewStrength0Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, VerilogParserRULE_strength0)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1800)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(VerilogParserPULL0-73))|(1<<(VerilogParserSTRONG0-73))|(1<<(VerilogParserSUPPLY0-73)))) != 0) || _la == VerilogParserWEAK0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStrength1Context is an interface to support dynamic dispatch.
type IStrength1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrength1Context differentiates from other interfaces.
	IsStrength1Context()
}

type Strength1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrength1Context() *Strength1Context {
	var p = new(Strength1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_strength1
	return p
}

func (*Strength1Context) IsStrength1Context() {}

func NewStrength1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Strength1Context {
	var p = new(Strength1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_strength1

	return p
}

func (s *Strength1Context) GetParser() antlr.Parser { return s.parser }

func (s *Strength1Context) SUPPLY1() antlr.TerminalNode {
	return s.GetToken(VerilogParserSUPPLY1, 0)
}

func (s *Strength1Context) STRONG1() antlr.TerminalNode {
	return s.GetToken(VerilogParserSTRONG1, 0)
}

func (s *Strength1Context) PULL1() antlr.TerminalNode {
	return s.GetToken(VerilogParserPULL1, 0)
}

func (s *Strength1Context) WEAK1() antlr.TerminalNode {
	return s.GetToken(VerilogParserWEAK1, 0)
}

func (s *Strength1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Strength1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Strength1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStrength1(s)
	}
}

func (s *Strength1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStrength1(s)
	}
}

func (p *VerilogParser) Strength1() (localctx IStrength1Context) {
	this := p
	_ = this

	localctx = NewStrength1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, VerilogParserRULE_strength1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1802)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(VerilogParserPULL1-74))|(1<<(VerilogParserSTRONG1-74))|(1<<(VerilogParserSUPPLY1-74)))) != 0) || _la == VerilogParserWEAK1) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICharge_strengthContext is an interface to support dynamic dispatch.
type ICharge_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharge_strengthContext differentiates from other interfaces.
	IsCharge_strengthContext()
}

type Charge_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharge_strengthContext() *Charge_strengthContext {
	var p = new(Charge_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_charge_strength
	return p
}

func (*Charge_strengthContext) IsCharge_strengthContext() {}

func NewCharge_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Charge_strengthContext {
	var p = new(Charge_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_charge_strength

	return p
}

func (s *Charge_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Charge_strengthContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Charge_strengthContext) SMALL() antlr.TerminalNode {
	return s.GetToken(VerilogParserSMALL, 0)
}

func (s *Charge_strengthContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Charge_strengthContext) MEDIUM() antlr.TerminalNode {
	return s.GetToken(VerilogParserMEDIUM, 0)
}

func (s *Charge_strengthContext) LARGE() antlr.TerminalNode {
	return s.GetToken(VerilogParserLARGE, 0)
}

func (s *Charge_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Charge_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Charge_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCharge_strength(s)
	}
}

func (s *Charge_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCharge_strength(s)
	}
}

func (p *VerilogParser) Charge_strength() (localctx ICharge_strengthContext) {
	this := p
	_ = this

	localctx = NewCharge_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, VerilogParserRULE_charge_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1813)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1804)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1805)
			p.Match(VerilogParserSMALL)
		}
		{
			p.SetState(1806)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1807)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1808)
			p.Match(VerilogParserMEDIUM)
		}
		{
			p.SetState(1809)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1810)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1811)
			p.Match(VerilogParserLARGE)
		}
		{
			p.SetState(1812)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}

	return localctx
}

// IDelay3Context is an interface to support dynamic dispatch.
type IDelay3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay3Context differentiates from other interfaces.
	IsDelay3Context()
}

type Delay3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay3Context() *Delay3Context {
	var p = new(Delay3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay3
	return p
}

func (*Delay3Context) IsDelay3Context() {}

func NewDelay3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay3Context {
	var p = new(Delay3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay3

	return p
}

func (s *Delay3Context) GetParser() antlr.Parser { return s.parser }

func (s *Delay3Context) HASH() antlr.TerminalNode {
	return s.GetToken(VerilogParserHASH, 0)
}

func (s *Delay3Context) Delay_value() IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Delay3Context) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Delay3Context) AllMintypmax_expression() []IMintypmax_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem())
	var tst = make([]IMintypmax_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMintypmax_expressionContext)
		}
	}

	return tst
}

func (s *Delay3Context) Mintypmax_expression(i int) IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Delay3Context) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Delay3Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Delay3Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Delay3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDelay3(s)
	}
}

func (s *Delay3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDelay3(s)
	}
}

func (p *VerilogParser) Delay3() (localctx IDelay3Context) {
	this := p
	_ = this

	localctx = NewDelay3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, VerilogParserRULE_delay3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1830)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1815)
			p.Match(VerilogParserHASH)
		}
		{
			p.SetState(1816)
			p.Delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1817)
			p.Match(VerilogParserHASH)
		}
		{
			p.SetState(1818)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1819)
			p.Mintypmax_expression()
		}
		p.SetState(1826)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserCOMMA {
			{
				p.SetState(1820)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(1821)
				p.Mintypmax_expression()
			}
			p.SetState(1824)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == VerilogParserCOMMA {
				{
					p.SetState(1822)
					p.Match(VerilogParserCOMMA)
				}
				{
					p.SetState(1823)
					p.Mintypmax_expression()
				}

			}

		}
		{
			p.SetState(1828)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}

	return localctx
}

// IDelay2Context is an interface to support dynamic dispatch.
type IDelay2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay2Context differentiates from other interfaces.
	IsDelay2Context()
}

type Delay2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay2Context() *Delay2Context {
	var p = new(Delay2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay2
	return p
}

func (*Delay2Context) IsDelay2Context() {}

func NewDelay2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay2Context {
	var p = new(Delay2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay2

	return p
}

func (s *Delay2Context) GetParser() antlr.Parser { return s.parser }

func (s *Delay2Context) HASH() antlr.TerminalNode {
	return s.GetToken(VerilogParserHASH, 0)
}

func (s *Delay2Context) Delay_value() IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Delay2Context) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Delay2Context) AllMintypmax_expression() []IMintypmax_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem())
	var tst = make([]IMintypmax_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMintypmax_expressionContext)
		}
	}

	return tst
}

func (s *Delay2Context) Mintypmax_expression(i int) IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Delay2Context) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Delay2Context) COMMA() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, 0)
}

func (s *Delay2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDelay2(s)
	}
}

func (s *Delay2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDelay2(s)
	}
}

func (p *VerilogParser) Delay2() (localctx IDelay2Context) {
	this := p
	_ = this

	localctx = NewDelay2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, VerilogParserRULE_delay2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1843)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1832)
			p.Match(VerilogParserHASH)
		}
		{
			p.SetState(1833)
			p.Delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1834)
			p.Match(VerilogParserHASH)
		}
		{
			p.SetState(1835)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1836)
			p.Mintypmax_expression()
		}
		p.SetState(1839)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserCOMMA {
			{
				p.SetState(1837)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(1838)
				p.Mintypmax_expression()
			}

		}
		{
			p.SetState(1841)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}

	return localctx
}

// IDelay_valueContext is an interface to support dynamic dispatch.
type IDelay_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_valueContext differentiates from other interfaces.
	IsDelay_valueContext()
}

type Delay_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_valueContext() *Delay_valueContext {
	var p = new(Delay_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay_value
	return p
}

func (*Delay_valueContext) IsDelay_valueContext() {}

func NewDelay_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_valueContext {
	var p = new(Delay_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay_value

	return p
}

func (s *Delay_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_valueContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserDECIMAL_NUMBER, 0)
}

func (s *Delay_valueContext) REAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserREAL_NUMBER, 0)
}

func (s *Delay_valueContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Delay_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDelay_value(s)
	}
}

func (s *Delay_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDelay_value(s)
	}
}

func (p *VerilogParser) Delay_value() (localctx IDelay_valueContext) {
	this := p
	_ = this

	localctx = NewDelay_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, VerilogParserRULE_delay_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1848)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserDECIMAL_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1845)
			p.Match(VerilogParserDECIMAL_NUMBER)
		}

	case VerilogParserREAL_NUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1846)
			p.Match(VerilogParserREAL_NUMBER)
		}

	case VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1847)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_of_defparam_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_defparam_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_defparam_assignmentsContext differentiates from other interfaces.
	IsList_of_defparam_assignmentsContext()
}

type List_of_defparam_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_defparam_assignmentsContext() *List_of_defparam_assignmentsContext {
	var p = new(List_of_defparam_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_defparam_assignments
	return p
}

func (*List_of_defparam_assignmentsContext) IsList_of_defparam_assignmentsContext() {}

func NewList_of_defparam_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_defparam_assignmentsContext {
	var p = new(List_of_defparam_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_defparam_assignments

	return p
}

func (s *List_of_defparam_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_defparam_assignmentsContext) AllDefparam_assignment() []IDefparam_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDefparam_assignmentContext)(nil)).Elem())
	var tst = make([]IDefparam_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDefparam_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_defparam_assignmentsContext) Defparam_assignment(i int) IDefparam_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefparam_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDefparam_assignmentContext)
}

func (s *List_of_defparam_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_defparam_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_defparam_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_defparam_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_defparam_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_defparam_assignments(s)
	}
}

func (s *List_of_defparam_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_defparam_assignments(s)
	}
}

func (p *VerilogParser) List_of_defparam_assignments() (localctx IList_of_defparam_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_defparam_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, VerilogParserRULE_list_of_defparam_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1850)
		p.Defparam_assignment()
	}
	p.SetState(1855)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(1851)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1852)
			p.Defparam_assignment()
		}

		p.SetState(1857)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_event_identifiersContext is an interface to support dynamic dispatch.
type IList_of_event_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_event_identifiersContext differentiates from other interfaces.
	IsList_of_event_identifiersContext()
}

type List_of_event_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_event_identifiersContext() *List_of_event_identifiersContext {
	var p = new(List_of_event_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_event_identifiers
	return p
}

func (*List_of_event_identifiersContext) IsList_of_event_identifiersContext() {}

func NewList_of_event_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_event_identifiersContext {
	var p = new(List_of_event_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_event_identifiers

	return p
}

func (s *List_of_event_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_event_identifiersContext) AllEvent_identifier() []IEvent_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvent_identifierContext)(nil)).Elem())
	var tst = make([]IEvent_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvent_identifierContext)
		}
	}

	return tst
}

func (s *List_of_event_identifiersContext) Event_identifier(i int) IEvent_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvent_identifierContext)
}

func (s *List_of_event_identifiersContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *List_of_event_identifiersContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *List_of_event_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_event_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_event_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_event_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_event_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_event_identifiers(s)
	}
}

func (s *List_of_event_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_event_identifiers(s)
	}
}

func (p *VerilogParser) List_of_event_identifiers() (localctx IList_of_event_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_event_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, VerilogParserRULE_list_of_event_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1858)
		p.Event_identifier()
	}
	p.SetState(1862)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext())

	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(1859)
				p.Dimension()
			}

		}
		p.SetState(1864)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext())
	}
	p.SetState(1875)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(1865)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1866)
			p.Event_identifier()
		}
		p.SetState(1870)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext())

		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				{
					p.SetState(1867)
					p.Dimension()
				}

			}
			p.SetState(1872)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext())
		}

		p.SetState(1877)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_net_decl_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_net_decl_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_net_decl_assignmentsContext differentiates from other interfaces.
	IsList_of_net_decl_assignmentsContext()
}

type List_of_net_decl_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_net_decl_assignmentsContext() *List_of_net_decl_assignmentsContext {
	var p = new(List_of_net_decl_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_net_decl_assignments
	return p
}

func (*List_of_net_decl_assignmentsContext) IsList_of_net_decl_assignmentsContext() {}

func NewList_of_net_decl_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_net_decl_assignmentsContext {
	var p = new(List_of_net_decl_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_net_decl_assignments

	return p
}

func (s *List_of_net_decl_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_net_decl_assignmentsContext) AllNet_decl_assignment() []INet_decl_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_decl_assignmentContext)(nil)).Elem())
	var tst = make([]INet_decl_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_decl_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_net_decl_assignmentsContext) Net_decl_assignment(i int) INet_decl_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_decl_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_decl_assignmentContext)
}

func (s *List_of_net_decl_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_net_decl_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_net_decl_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_net_decl_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_net_decl_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_net_decl_assignments(s)
	}
}

func (s *List_of_net_decl_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_net_decl_assignments(s)
	}
}

func (p *VerilogParser) List_of_net_decl_assignments() (localctx IList_of_net_decl_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_net_decl_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, VerilogParserRULE_list_of_net_decl_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1878)
		p.Net_decl_assignment()
	}
	p.SetState(1883)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(1879)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1880)
			p.Net_decl_assignment()
		}

		p.SetState(1885)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_net_identifiersContext is an interface to support dynamic dispatch.
type IList_of_net_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_net_identifiersContext differentiates from other interfaces.
	IsList_of_net_identifiersContext()
}

type List_of_net_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_net_identifiersContext() *List_of_net_identifiersContext {
	var p = new(List_of_net_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_net_identifiers
	return p
}

func (*List_of_net_identifiersContext) IsList_of_net_identifiersContext() {}

func NewList_of_net_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_net_identifiersContext {
	var p = new(List_of_net_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_net_identifiers

	return p
}

func (s *List_of_net_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_net_identifiersContext) AllNet_identifier() []INet_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_identifierContext)(nil)).Elem())
	var tst = make([]INet_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_identifierContext)
		}
	}

	return tst
}

func (s *List_of_net_identifiersContext) Net_identifier(i int) INet_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_identifierContext)
}

func (s *List_of_net_identifiersContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *List_of_net_identifiersContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *List_of_net_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_net_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_net_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_net_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_net_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_net_identifiers(s)
	}
}

func (s *List_of_net_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_net_identifiers(s)
	}
}

func (p *VerilogParser) List_of_net_identifiers() (localctx IList_of_net_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_net_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, VerilogParserRULE_list_of_net_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1886)
		p.Net_identifier()
	}
	p.SetState(1890)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())

	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(1887)
				p.Dimension()
			}

		}
		p.SetState(1892)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())
	}
	p.SetState(1903)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(1893)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1894)
			p.Net_identifier()
		}
		p.SetState(1898)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())

		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				{
					p.SetState(1895)
					p.Dimension()
				}

			}
			p.SetState(1900)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())
		}

		p.SetState(1905)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_param_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_param_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_param_assignmentsContext differentiates from other interfaces.
	IsList_of_param_assignmentsContext()
}

type List_of_param_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_param_assignmentsContext() *List_of_param_assignmentsContext {
	var p = new(List_of_param_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_param_assignments
	return p
}

func (*List_of_param_assignmentsContext) IsList_of_param_assignmentsContext() {}

func NewList_of_param_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_param_assignmentsContext {
	var p = new(List_of_param_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_param_assignments

	return p
}

func (s *List_of_param_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_param_assignmentsContext) AllParam_assignment() []IParam_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParam_assignmentContext)(nil)).Elem())
	var tst = make([]IParam_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParam_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_param_assignmentsContext) Param_assignment(i int) IParam_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParam_assignmentContext)
}

func (s *List_of_param_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_param_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_param_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_param_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_param_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_param_assignments(s)
	}
}

func (s *List_of_param_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_param_assignments(s)
	}
}

func (p *VerilogParser) List_of_param_assignments() (localctx IList_of_param_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_param_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, VerilogParserRULE_list_of_param_assignments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1906)
		p.Param_assignment()
	}
	p.SetState(1911)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1907)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(1908)
				p.Param_assignment()
			}

		}
		p.SetState(1913)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext())
	}

	return localctx
}

// IList_of_port_identifiersContext is an interface to support dynamic dispatch.
type IList_of_port_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_identifiersContext differentiates from other interfaces.
	IsList_of_port_identifiersContext()
}

type List_of_port_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_identifiersContext() *List_of_port_identifiersContext {
	var p = new(List_of_port_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_port_identifiers
	return p
}

func (*List_of_port_identifiersContext) IsList_of_port_identifiersContext() {}

func NewList_of_port_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_identifiersContext {
	var p = new(List_of_port_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_port_identifiers

	return p
}

func (s *List_of_port_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_identifiersContext) AllPort_identifier() []IPort_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem())
	var tst = make([]IPort_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_identifierContext)
		}
	}

	return tst
}

func (s *List_of_port_identifiersContext) Port_identifier(i int) IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *List_of_port_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_port_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_port_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_port_identifiers(s)
	}
}

func (s *List_of_port_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_port_identifiers(s)
	}
}

func (p *VerilogParser) List_of_port_identifiers() (localctx IList_of_port_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_port_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, VerilogParserRULE_list_of_port_identifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1914)
		p.Port_identifier()
	}
	p.SetState(1919)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1915)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(1916)
				p.Port_identifier()
			}

		}
		p.SetState(1921)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext())
	}

	return localctx
}

// IList_of_real_identifiersContext is an interface to support dynamic dispatch.
type IList_of_real_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_real_identifiersContext differentiates from other interfaces.
	IsList_of_real_identifiersContext()
}

type List_of_real_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_real_identifiersContext() *List_of_real_identifiersContext {
	var p = new(List_of_real_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_real_identifiers
	return p
}

func (*List_of_real_identifiersContext) IsList_of_real_identifiersContext() {}

func NewList_of_real_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_real_identifiersContext {
	var p = new(List_of_real_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_real_identifiers

	return p
}

func (s *List_of_real_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_real_identifiersContext) AllReal_type() []IReal_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReal_typeContext)(nil)).Elem())
	var tst = make([]IReal_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReal_typeContext)
		}
	}

	return tst
}

func (s *List_of_real_identifiersContext) Real_type(i int) IReal_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReal_typeContext)
}

func (s *List_of_real_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_real_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_real_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_real_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_real_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_real_identifiers(s)
	}
}

func (s *List_of_real_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_real_identifiers(s)
	}
}

func (p *VerilogParser) List_of_real_identifiers() (localctx IList_of_real_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_real_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, VerilogParserRULE_list_of_real_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1922)
		p.Real_type()
	}
	p.SetState(1927)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(1923)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1924)
			p.Real_type()
		}

		p.SetState(1929)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_specparam_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_specparam_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_specparam_assignmentsContext differentiates from other interfaces.
	IsList_of_specparam_assignmentsContext()
}

type List_of_specparam_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_specparam_assignmentsContext() *List_of_specparam_assignmentsContext {
	var p = new(List_of_specparam_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_specparam_assignments
	return p
}

func (*List_of_specparam_assignmentsContext) IsList_of_specparam_assignmentsContext() {}

func NewList_of_specparam_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_specparam_assignmentsContext {
	var p = new(List_of_specparam_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_specparam_assignments

	return p
}

func (s *List_of_specparam_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_specparam_assignmentsContext) AllSpecparam_assignment() []ISpecparam_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecparam_assignmentContext)(nil)).Elem())
	var tst = make([]ISpecparam_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecparam_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_specparam_assignmentsContext) Specparam_assignment(i int) ISpecparam_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_assignmentContext)
}

func (s *List_of_specparam_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_specparam_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_specparam_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_specparam_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_specparam_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_specparam_assignments(s)
	}
}

func (s *List_of_specparam_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_specparam_assignments(s)
	}
}

func (p *VerilogParser) List_of_specparam_assignments() (localctx IList_of_specparam_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_specparam_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, VerilogParserRULE_list_of_specparam_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1930)
		p.Specparam_assignment()
	}
	p.SetState(1935)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(1931)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1932)
			p.Specparam_assignment()
		}

		p.SetState(1937)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_variable_identifiersContext is an interface to support dynamic dispatch.
type IList_of_variable_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_variable_identifiersContext differentiates from other interfaces.
	IsList_of_variable_identifiersContext()
}

type List_of_variable_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_variable_identifiersContext() *List_of_variable_identifiersContext {
	var p = new(List_of_variable_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_variable_identifiers
	return p
}

func (*List_of_variable_identifiersContext) IsList_of_variable_identifiersContext() {}

func NewList_of_variable_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_variable_identifiersContext {
	var p = new(List_of_variable_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_variable_identifiers

	return p
}

func (s *List_of_variable_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_variable_identifiersContext) AllVariable_type() []IVariable_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_typeContext)(nil)).Elem())
	var tst = make([]IVariable_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_typeContext)
		}
	}

	return tst
}

func (s *List_of_variable_identifiersContext) Variable_type(i int) IVariable_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_typeContext)
}

func (s *List_of_variable_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_variable_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_variable_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_variable_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_variable_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_variable_identifiers(s)
	}
}

func (s *List_of_variable_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_variable_identifiers(s)
	}
}

func (p *VerilogParser) List_of_variable_identifiers() (localctx IList_of_variable_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_variable_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, VerilogParserRULE_list_of_variable_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1938)
		p.Variable_type()
	}
	p.SetState(1943)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(1939)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(1940)
			p.Variable_type()
		}

		p.SetState(1945)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_variable_port_identifiersContext is an interface to support dynamic dispatch.
type IList_of_variable_port_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_variable_port_identifiersContext differentiates from other interfaces.
	IsList_of_variable_port_identifiersContext()
}

type List_of_variable_port_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_variable_port_identifiersContext() *List_of_variable_port_identifiersContext {
	var p = new(List_of_variable_port_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_variable_port_identifiers
	return p
}

func (*List_of_variable_port_identifiersContext) IsList_of_variable_port_identifiersContext() {}

func NewList_of_variable_port_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_variable_port_identifiersContext {
	var p = new(List_of_variable_port_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_variable_port_identifiers

	return p
}

func (s *List_of_variable_port_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_variable_port_identifiersContext) AllPort_identifier() []IPort_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem())
	var tst = make([]IPort_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_identifierContext)
		}
	}

	return tst
}

func (s *List_of_variable_port_identifiersContext) Port_identifier(i int) IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *List_of_variable_port_identifiersContext) AllEQUAL() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserEQUAL)
}

func (s *List_of_variable_port_identifiersContext) EQUAL(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, i)
}

func (s *List_of_variable_port_identifiersContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *List_of_variable_port_identifiersContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *List_of_variable_port_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_variable_port_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_variable_port_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_variable_port_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_variable_port_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_variable_port_identifiers(s)
	}
}

func (s *List_of_variable_port_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_variable_port_identifiers(s)
	}
}

func (p *VerilogParser) List_of_variable_port_identifiers() (localctx IList_of_variable_port_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_variable_port_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, VerilogParserRULE_list_of_variable_port_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1946)
		p.Port_identifier()
	}
	p.SetState(1949)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEQUAL {
		{
			p.SetState(1947)
			p.Match(VerilogParserEQUAL)
		}
		{
			p.SetState(1948)
			p.constant_expression(0)
		}

	}
	p.SetState(1959)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1951)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(1952)
				p.Port_identifier()
			}
			p.SetState(1955)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == VerilogParserEQUAL {
				{
					p.SetState(1953)
					p.Match(VerilogParserEQUAL)
				}
				{
					p.SetState(1954)
					p.constant_expression(0)
				}

			}

		}
		p.SetState(1961)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext())
	}

	return localctx
}

// IDefparam_assignmentContext is an interface to support dynamic dispatch.
type IDefparam_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefparam_assignmentContext differentiates from other interfaces.
	IsDefparam_assignmentContext()
}

type Defparam_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefparam_assignmentContext() *Defparam_assignmentContext {
	var p = new(Defparam_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_defparam_assignment
	return p
}

func (*Defparam_assignmentContext) IsDefparam_assignmentContext() {}

func NewDefparam_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Defparam_assignmentContext {
	var p = new(Defparam_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_defparam_assignment

	return p
}

func (s *Defparam_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Defparam_assignmentContext) Hierarchical_parameter_identifier() IHierarchical_parameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_parameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_parameter_identifierContext)
}

func (s *Defparam_assignmentContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Defparam_assignmentContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Defparam_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Defparam_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Defparam_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDefparam_assignment(s)
	}
}

func (s *Defparam_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDefparam_assignment(s)
	}
}

func (p *VerilogParser) Defparam_assignment() (localctx IDefparam_assignmentContext) {
	this := p
	_ = this

	localctx = NewDefparam_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, VerilogParserRULE_defparam_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1962)
		p.Hierarchical_parameter_identifier()
	}
	{
		p.SetState(1963)
		p.Match(VerilogParserEQUAL)
	}
	{
		p.SetState(1964)
		p.Constant_mintypmax_expression()
	}

	return localctx
}

// INet_decl_assignmentContext is an interface to support dynamic dispatch.
type INet_decl_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_decl_assignmentContext differentiates from other interfaces.
	IsNet_decl_assignmentContext()
}

type Net_decl_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_decl_assignmentContext() *Net_decl_assignmentContext {
	var p = new(Net_decl_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_decl_assignment
	return p
}

func (*Net_decl_assignmentContext) IsNet_decl_assignmentContext() {}

func NewNet_decl_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_decl_assignmentContext {
	var p = new(Net_decl_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_decl_assignment

	return p
}

func (s *Net_decl_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_decl_assignmentContext) Net_identifier() INet_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_identifierContext)
}

func (s *Net_decl_assignmentContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Net_decl_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Net_decl_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_decl_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_decl_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNet_decl_assignment(s)
	}
}

func (s *Net_decl_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNet_decl_assignment(s)
	}
}

func (p *VerilogParser) Net_decl_assignment() (localctx INet_decl_assignmentContext) {
	this := p
	_ = this

	localctx = NewNet_decl_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, VerilogParserRULE_net_decl_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1966)
		p.Net_identifier()
	}
	{
		p.SetState(1967)
		p.Match(VerilogParserEQUAL)
	}
	{
		p.SetState(1968)
		p.expression(0)
	}

	return localctx
}

// IParam_assignmentContext is an interface to support dynamic dispatch.
type IParam_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_assignmentContext differentiates from other interfaces.
	IsParam_assignmentContext()
}

type Param_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_assignmentContext() *Param_assignmentContext {
	var p = new(Param_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_param_assignment
	return p
}

func (*Param_assignmentContext) IsParam_assignmentContext() {}

func NewParam_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_assignmentContext {
	var p = new(Param_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_param_assignment

	return p
}

func (s *Param_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_assignmentContext) Parameter_identifier() IParameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_identifierContext)
}

func (s *Param_assignmentContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Param_assignmentContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Param_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParam_assignment(s)
	}
}

func (s *Param_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParam_assignment(s)
	}
}

func (p *VerilogParser) Param_assignment() (localctx IParam_assignmentContext) {
	this := p
	_ = this

	localctx = NewParam_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, VerilogParserRULE_param_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1970)
		p.Parameter_identifier()
	}
	{
		p.SetState(1971)
		p.Match(VerilogParserEQUAL)
	}
	{
		p.SetState(1972)
		p.Constant_mintypmax_expression()
	}

	return localctx
}

// ISpecparam_assignmentContext is an interface to support dynamic dispatch.
type ISpecparam_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecparam_assignmentContext differentiates from other interfaces.
	IsSpecparam_assignmentContext()
}

type Specparam_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecparam_assignmentContext() *Specparam_assignmentContext {
	var p = new(Specparam_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specparam_assignment
	return p
}

func (*Specparam_assignmentContext) IsSpecparam_assignmentContext() {}

func NewSpecparam_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specparam_assignmentContext {
	var p = new(Specparam_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specparam_assignment

	return p
}

func (s *Specparam_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Specparam_assignmentContext) Specparam_identifier() ISpecparam_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_identifierContext)
}

func (s *Specparam_assignmentContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Specparam_assignmentContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Specparam_assignmentContext) Pulse_control_specparam() IPulse_control_specparamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPulse_control_specparamContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPulse_control_specparamContext)
}

func (s *Specparam_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specparam_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specparam_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecparam_assignment(s)
	}
}

func (s *Specparam_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecparam_assignment(s)
	}
}

func (p *VerilogParser) Specparam_assignment() (localctx ISpecparam_assignmentContext) {
	this := p
	_ = this

	localctx = NewSpecparam_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, VerilogParserRULE_specparam_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1979)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1974)
			p.Specparam_identifier()
		}
		{
			p.SetState(1975)
			p.Match(VerilogParserEQUAL)
		}
		{
			p.SetState(1976)
			p.Constant_mintypmax_expression()
		}

	case VerilogParserPATHPULSE_DOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1978)
			p.Pulse_control_specparam()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPulse_control_specparamContext is an interface to support dynamic dispatch.
type IPulse_control_specparamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPulse_control_specparamContext differentiates from other interfaces.
	IsPulse_control_specparamContext()
}

type Pulse_control_specparamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPulse_control_specparamContext() *Pulse_control_specparamContext {
	var p = new(Pulse_control_specparamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pulse_control_specparam
	return p
}

func (*Pulse_control_specparamContext) IsPulse_control_specparamContext() {}

func NewPulse_control_specparamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pulse_control_specparamContext {
	var p = new(Pulse_control_specparamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pulse_control_specparam

	return p
}

func (s *Pulse_control_specparamContext) GetParser() antlr.Parser { return s.parser }

func (s *Pulse_control_specparamContext) PATHPULSE_DOLLAR() antlr.TerminalNode {
	return s.GetToken(VerilogParserPATHPULSE_DOLLAR, 0)
}

func (s *Pulse_control_specparamContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Pulse_control_specparamContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Pulse_control_specparamContext) Reject_limit_value() IReject_limit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReject_limit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReject_limit_valueContext)
}

func (s *Pulse_control_specparamContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Pulse_control_specparamContext) COMMA() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, 0)
}

func (s *Pulse_control_specparamContext) Error_limit_value() IError_limit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IError_limit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IError_limit_valueContext)
}

func (s *Pulse_control_specparamContext) Specify_input_terminal_descriptor() ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *Pulse_control_specparamContext) DOT() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOT, 0)
}

func (s *Pulse_control_specparamContext) Specify_output_terminal_descriptor() ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *Pulse_control_specparamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pulse_control_specparamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pulse_control_specparamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPulse_control_specparam(s)
	}
}

func (s *Pulse_control_specparamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPulse_control_specparam(s)
	}
}

func (p *VerilogParser) Pulse_control_specparam() (localctx IPulse_control_specparamContext) {
	this := p
	_ = this

	localctx = NewPulse_control_specparamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, VerilogParserRULE_pulse_control_specparam)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2004)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1981)
			p.Match(VerilogParserPATHPULSE_DOLLAR)
		}
		{
			p.SetState(1982)
			p.Match(VerilogParserEQUAL)
		}
		{
			p.SetState(1983)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1984)
			p.Reject_limit_value()
		}
		p.SetState(1987)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserCOMMA {
			{
				p.SetState(1985)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(1986)
				p.Error_limit_value()
			}

		}
		{
			p.SetState(1989)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1991)
			p.Match(VerilogParserPATHPULSE_DOLLAR)
		}
		{
			p.SetState(1992)
			p.Specify_input_terminal_descriptor()
		}
		{
			p.SetState(1993)
			p.Match(VerilogParserDOT)
		}
		{
			p.SetState(1994)
			p.Specify_output_terminal_descriptor()
		}
		{
			p.SetState(1995)
			p.Match(VerilogParserEQUAL)
		}
		{
			p.SetState(1996)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(1997)
			p.Reject_limit_value()
		}
		p.SetState(2000)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserCOMMA {
			{
				p.SetState(1998)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(1999)
				p.Error_limit_value()
			}

		}
		{
			p.SetState(2002)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}

	return localctx
}

// IError_limit_valueContext is an interface to support dynamic dispatch.
type IError_limit_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsError_limit_valueContext differentiates from other interfaces.
	IsError_limit_valueContext()
}

type Error_limit_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyError_limit_valueContext() *Error_limit_valueContext {
	var p = new(Error_limit_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_error_limit_value
	return p
}

func (*Error_limit_valueContext) IsError_limit_valueContext() {}

func NewError_limit_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Error_limit_valueContext {
	var p = new(Error_limit_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_error_limit_value

	return p
}

func (s *Error_limit_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Error_limit_valueContext) Limit_value() ILimit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimit_valueContext)
}

func (s *Error_limit_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Error_limit_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Error_limit_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterError_limit_value(s)
	}
}

func (s *Error_limit_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitError_limit_value(s)
	}
}

func (p *VerilogParser) Error_limit_value() (localctx IError_limit_valueContext) {
	this := p
	_ = this

	localctx = NewError_limit_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, VerilogParserRULE_error_limit_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2006)
		p.Limit_value()
	}

	return localctx
}

// IReject_limit_valueContext is an interface to support dynamic dispatch.
type IReject_limit_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReject_limit_valueContext differentiates from other interfaces.
	IsReject_limit_valueContext()
}

type Reject_limit_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReject_limit_valueContext() *Reject_limit_valueContext {
	var p = new(Reject_limit_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_reject_limit_value
	return p
}

func (*Reject_limit_valueContext) IsReject_limit_valueContext() {}

func NewReject_limit_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reject_limit_valueContext {
	var p = new(Reject_limit_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_reject_limit_value

	return p
}

func (s *Reject_limit_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Reject_limit_valueContext) Limit_value() ILimit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimit_valueContext)
}

func (s *Reject_limit_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reject_limit_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reject_limit_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterReject_limit_value(s)
	}
}

func (s *Reject_limit_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitReject_limit_value(s)
	}
}

func (p *VerilogParser) Reject_limit_value() (localctx IReject_limit_valueContext) {
	this := p
	_ = this

	localctx = NewReject_limit_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, VerilogParserRULE_reject_limit_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2008)
		p.Limit_value()
	}

	return localctx
}

// ILimit_valueContext is an interface to support dynamic dispatch.
type ILimit_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimit_valueContext differentiates from other interfaces.
	IsLimit_valueContext()
}

type Limit_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimit_valueContext() *Limit_valueContext {
	var p = new(Limit_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_limit_value
	return p
}

func (*Limit_valueContext) IsLimit_valueContext() {}

func NewLimit_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Limit_valueContext {
	var p = new(Limit_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_limit_value

	return p
}

func (s *Limit_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Limit_valueContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Limit_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Limit_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Limit_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLimit_value(s)
	}
}

func (s *Limit_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLimit_value(s)
	}
}

func (p *VerilogParser) Limit_value() (localctx ILimit_valueContext) {
	this := p
	_ = this

	localctx = NewLimit_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, VerilogParserRULE_limit_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2010)
		p.Constant_mintypmax_expression()
	}

	return localctx
}

// IDimensionContext is an interface to support dynamic dispatch.
type IDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimensionContext differentiates from other interfaces.
	IsDimensionContext()
}

type DimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimensionContext() *DimensionContext {
	var p = new(DimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dimension
	return p
}

func (*DimensionContext) IsDimensionContext() {}

func NewDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimensionContext {
	var p = new(DimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dimension

	return p
}

func (s *DimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *DimensionContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACKET, 0)
}

func (s *DimensionContext) AllDimension_constant_expression() []IDimension_constant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimension_constant_expressionContext)(nil)).Elem())
	var tst = make([]IDimension_constant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimension_constant_expressionContext)
		}
	}

	return tst
}

func (s *DimensionContext) Dimension_constant_expression(i int) IDimension_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_constant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimension_constant_expressionContext)
}

func (s *DimensionContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *DimensionContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACKET, 0)
}

func (s *DimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDimension(s)
	}
}

func (s *DimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDimension(s)
	}
}

func (p *VerilogParser) Dimension() (localctx IDimensionContext) {
	this := p
	_ = this

	localctx = NewDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, VerilogParserRULE_dimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2012)
		p.Match(VerilogParserLEFT_BRACKET)
	}
	{
		p.SetState(2013)
		p.Dimension_constant_expression()
	}
	{
		p.SetState(2014)
		p.Match(VerilogParserCOLON)
	}
	{
		p.SetState(2015)
		p.Dimension_constant_expression()
	}
	{
		p.SetState(2016)
		p.Match(VerilogParserRIGHT_BRACKET)
	}

	return localctx
}

// IRange_Context is an interface to support dynamic dispatch.
type IRange_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_Context differentiates from other interfaces.
	IsRange_Context()
}

type Range_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_Context() *Range_Context {
	var p = new(Range_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_range_
	return p
}

func (*Range_Context) IsRange_Context() {}

func NewRange_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_Context {
	var p = new(Range_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_range_

	return p
}

func (s *Range_Context) GetParser() antlr.Parser { return s.parser }

func (s *Range_Context) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACKET, 0)
}

func (s *Range_Context) Msb_constant_expression() IMsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMsb_constant_expressionContext)
}

func (s *Range_Context) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *Range_Context) Lsb_constant_expression() ILsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILsb_constant_expressionContext)
}

func (s *Range_Context) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACKET, 0)
}

func (s *Range_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterRange_(s)
	}
}

func (s *Range_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitRange_(s)
	}
}

func (p *VerilogParser) Range_() (localctx IRange_Context) {
	this := p
	_ = this

	localctx = NewRange_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, VerilogParserRULE_range_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2018)
		p.Match(VerilogParserLEFT_BRACKET)
	}
	{
		p.SetState(2019)
		p.Msb_constant_expression()
	}
	{
		p.SetState(2020)
		p.Match(VerilogParserCOLON)
	}
	{
		p.SetState(2021)
		p.Lsb_constant_expression()
	}
	{
		p.SetState(2022)
		p.Match(VerilogParserRIGHT_BRACKET)
	}

	return localctx
}

// IFunction_declarationContext is an interface to support dynamic dispatch.
type IFunction_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_declarationContext differentiates from other interfaces.
	IsFunction_declarationContext()
}

type Function_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_declarationContext() *Function_declarationContext {
	var p = new(Function_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_declaration
	return p
}

func (*Function_declarationContext) IsFunction_declarationContext() {}

func NewFunction_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_declarationContext {
	var p = new(Function_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_declaration

	return p
}

func (s *Function_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_declarationContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(VerilogParserFUNCTION, 0)
}

func (s *Function_declarationContext) Function_identifier() IFunction_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_identifierContext)
}

func (s *Function_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Function_declarationContext) AllFunction_item_declaration() []IFunction_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_item_declarationContext)(nil)).Elem())
	var tst = make([]IFunction_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_item_declarationContext)
		}
	}

	return tst
}

func (s *Function_declarationContext) Function_item_declaration(i int) IFunction_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_item_declarationContext)
}

func (s *Function_declarationContext) Function_statement() IFunction_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_statementContext)
}

func (s *Function_declarationContext) ENDFUNCTION() antlr.TerminalNode {
	return s.GetToken(VerilogParserENDFUNCTION, 0)
}

func (s *Function_declarationContext) AUTOMATIC() antlr.TerminalNode {
	return s.GetToken(VerilogParserAUTOMATIC, 0)
}

func (s *Function_declarationContext) Function_range_or_type() IFunction_range_or_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_range_or_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_range_or_typeContext)
}

func (s *Function_declarationContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Function_declarationContext) Function_port_list() IFunction_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_port_listContext)
}

func (s *Function_declarationContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Function_declarationContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Function_declarationContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Function_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_declaration(s)
	}
}

func (s *Function_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_declaration(s)
	}
}

func (p *VerilogParser) Function_declaration() (localctx IFunction_declarationContext) {
	this := p
	_ = this

	localctx = NewFunction_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, VerilogParserRULE_function_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2064)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2024)
			p.Match(VerilogParserFUNCTION)
		}
		p.SetState(2026)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserAUTOMATIC {
			{
				p.SetState(2025)
				p.Match(VerilogParserAUTOMATIC)
			}

		}
		p.SetState(2029)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-50)&-(0x1f+1)) == 0 && ((1<<uint((_la-50)))&((1<<(VerilogParserINTEGER-50))|(1<<(VerilogParserREAL-50))|(1<<(VerilogParserREALTIME-50)))) != 0) || _la == VerilogParserSIGNED || _la == VerilogParserTIME || _la == VerilogParserLEFT_BRACKET {
			{
				p.SetState(2028)
				p.Function_range_or_type()
			}

		}
		{
			p.SetState(2031)
			p.Function_identifier()
		}
		{
			p.SetState(2032)
			p.Match(VerilogParserSEMICOLON)
		}
		{
			p.SetState(2033)
			p.Function_item_declaration()
		}
		p.SetState(2037)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2034)
					p.Function_item_declaration()
				}

			}
			p.SetState(2039)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext())
		}
		{
			p.SetState(2040)
			p.Function_statement()
		}
		{
			p.SetState(2041)
			p.Match(VerilogParserENDFUNCTION)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2043)
			p.Match(VerilogParserFUNCTION)
		}
		p.SetState(2045)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserAUTOMATIC {
			{
				p.SetState(2044)
				p.Match(VerilogParserAUTOMATIC)
			}

		}
		p.SetState(2048)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-50)&-(0x1f+1)) == 0 && ((1<<uint((_la-50)))&((1<<(VerilogParserINTEGER-50))|(1<<(VerilogParserREAL-50))|(1<<(VerilogParserREALTIME-50)))) != 0) || _la == VerilogParserSIGNED || _la == VerilogParserTIME || _la == VerilogParserLEFT_BRACKET {
			{
				p.SetState(2047)
				p.Function_range_or_type()
			}

		}
		{
			p.SetState(2050)
			p.Function_identifier()
		}
		{
			p.SetState(2051)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(2052)
			p.Function_port_list()
		}
		{
			p.SetState(2053)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(2054)
			p.Match(VerilogParserSEMICOLON)
		}
		p.SetState(2058)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2055)
					p.Block_item_declaration()
				}

			}
			p.SetState(2060)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext())
		}
		{
			p.SetState(2061)
			p.Function_statement()
		}
		{
			p.SetState(2062)
			p.Match(VerilogParserENDFUNCTION)
		}

	}

	return localctx
}

// IFunction_item_declarationContext is an interface to support dynamic dispatch.
type IFunction_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_item_declarationContext differentiates from other interfaces.
	IsFunction_item_declarationContext()
}

type Function_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_item_declarationContext() *Function_item_declarationContext {
	var p = new(Function_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_item_declaration
	return p
}

func (*Function_item_declarationContext) IsFunction_item_declarationContext() {}

func NewFunction_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_item_declarationContext {
	var p = new(Function_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_item_declaration

	return p
}

func (s *Function_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_item_declarationContext) Block_item_declaration() IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Function_item_declarationContext) Tf_input_declaration() ITf_input_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_input_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_input_declarationContext)
}

func (s *Function_item_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Function_item_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Function_item_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Function_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_item_declaration(s)
	}
}

func (s *Function_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_item_declaration(s)
	}
}

func (p *VerilogParser) Function_item_declaration() (localctx IFunction_item_declarationContext) {
	this := p
	_ = this

	localctx = NewFunction_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, VerilogParserRULE_function_item_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2076)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2066)
			p.Block_item_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2070)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2067)
				p.Attribute_instance()
			}

			p.SetState(2072)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2073)
			p.Tf_input_declaration()
		}
		{
			p.SetState(2074)
			p.Match(VerilogParserSEMICOLON)
		}

	}

	return localctx
}

// IFunction_port_listContext is an interface to support dynamic dispatch.
type IFunction_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_port_listContext differentiates from other interfaces.
	IsFunction_port_listContext()
}

type Function_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_port_listContext() *Function_port_listContext {
	var p = new(Function_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_port_list
	return p
}

func (*Function_port_listContext) IsFunction_port_listContext() {}

func NewFunction_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_port_listContext {
	var p = new(Function_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_port_list

	return p
}

func (s *Function_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_port_listContext) AllTf_input_declaration() []ITf_input_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITf_input_declarationContext)(nil)).Elem())
	var tst = make([]ITf_input_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITf_input_declarationContext)
		}
	}

	return tst
}

func (s *Function_port_listContext) Tf_input_declaration(i int) ITf_input_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_input_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITf_input_declarationContext)
}

func (s *Function_port_listContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Function_port_listContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Function_port_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Function_port_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Function_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_port_list(s)
	}
}

func (s *Function_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_port_list(s)
	}
}

func (p *VerilogParser) Function_port_list() (localctx IFunction_port_listContext) {
	this := p
	_ = this

	localctx = NewFunction_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, VerilogParserRULE_function_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2081)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserLEFT_PARENTHESIS {
		{
			p.SetState(2078)
			p.Attribute_instance()
		}

		p.SetState(2083)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2084)
		p.Tf_input_declaration()
	}
	p.SetState(2095)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(2085)
			p.Match(VerilogParserCOMMA)
		}
		p.SetState(2089)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2086)
				p.Attribute_instance()
			}

			p.SetState(2091)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2092)
			p.Tf_input_declaration()
		}

		p.SetState(2097)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFunction_range_or_typeContext is an interface to support dynamic dispatch.
type IFunction_range_or_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_range_or_typeContext differentiates from other interfaces.
	IsFunction_range_or_typeContext()
}

type Function_range_or_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_range_or_typeContext() *Function_range_or_typeContext {
	var p = new(Function_range_or_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_range_or_type
	return p
}

func (*Function_range_or_typeContext) IsFunction_range_or_typeContext() {}

func NewFunction_range_or_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_range_or_typeContext {
	var p = new(Function_range_or_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_range_or_type

	return p
}

func (s *Function_range_or_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_range_or_typeContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Function_range_or_typeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(VerilogParserSIGNED, 0)
}

func (s *Function_range_or_typeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(VerilogParserINTEGER, 0)
}

func (s *Function_range_or_typeContext) REAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserREAL, 0)
}

func (s *Function_range_or_typeContext) REALTIME() antlr.TerminalNode {
	return s.GetToken(VerilogParserREALTIME, 0)
}

func (s *Function_range_or_typeContext) TIME() antlr.TerminalNode {
	return s.GetToken(VerilogParserTIME, 0)
}

func (s *Function_range_or_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_range_or_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_range_or_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_range_or_type(s)
	}
}

func (s *Function_range_or_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_range_or_type(s)
	}
}

func (p *VerilogParser) Function_range_or_type() (localctx IFunction_range_or_typeContext) {
	this := p
	_ = this

	localctx = NewFunction_range_or_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, VerilogParserRULE_function_range_or_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2106)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserSIGNED, VerilogParserLEFT_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2099)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(2098)
				p.Match(VerilogParserSIGNED)
			}

		}
		{
			p.SetState(2101)
			p.Range_()
		}

	case VerilogParserINTEGER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2102)
			p.Match(VerilogParserINTEGER)
		}

	case VerilogParserREAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2103)
			p.Match(VerilogParserREAL)
		}

	case VerilogParserREALTIME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2104)
			p.Match(VerilogParserREALTIME)
		}

	case VerilogParserTIME:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2105)
			p.Match(VerilogParserTIME)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITask_declarationContext is an interface to support dynamic dispatch.
type ITask_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_declarationContext differentiates from other interfaces.
	IsTask_declarationContext()
}

type Task_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_declarationContext() *Task_declarationContext {
	var p = new(Task_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_declaration
	return p
}

func (*Task_declarationContext) IsTask_declarationContext() {}

func NewTask_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_declarationContext {
	var p = new(Task_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_declaration

	return p
}

func (s *Task_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_declarationContext) TASK() antlr.TerminalNode {
	return s.GetToken(VerilogParserTASK, 0)
}

func (s *Task_declarationContext) Task_identifier() ITask_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_identifierContext)
}

func (s *Task_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Task_declarationContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Task_declarationContext) ENDTASK() antlr.TerminalNode {
	return s.GetToken(VerilogParserENDTASK, 0)
}

func (s *Task_declarationContext) AUTOMATIC() antlr.TerminalNode {
	return s.GetToken(VerilogParserAUTOMATIC, 0)
}

func (s *Task_declarationContext) AllTask_item_declaration() []ITask_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITask_item_declarationContext)(nil)).Elem())
	var tst = make([]ITask_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITask_item_declarationContext)
		}
	}

	return tst
}

func (s *Task_declarationContext) Task_item_declaration(i int) ITask_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITask_item_declarationContext)
}

func (s *Task_declarationContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Task_declarationContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Task_declarationContext) Task_port_list() ITask_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_port_listContext)
}

func (s *Task_declarationContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Task_declarationContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Task_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTask_declaration(s)
	}
}

func (s *Task_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTask_declaration(s)
	}
}

func (p *VerilogParser) Task_declaration() (localctx ITask_declarationContext) {
	this := p
	_ = this

	localctx = NewTask_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, VerilogParserRULE_task_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2143)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2108)
			p.Match(VerilogParserTASK)
		}
		p.SetState(2110)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserAUTOMATIC {
			{
				p.SetState(2109)
				p.Match(VerilogParserAUTOMATIC)
			}

		}
		{
			p.SetState(2112)
			p.Task_identifier()
		}
		{
			p.SetState(2113)
			p.Match(VerilogParserSEMICOLON)
		}
		p.SetState(2117)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2114)
					p.Task_item_declaration()
				}

			}
			p.SetState(2119)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext())
		}
		{
			p.SetState(2120)
			p.Statement_or_null()
		}
		{
			p.SetState(2121)
			p.Match(VerilogParserENDTASK)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2123)
			p.Match(VerilogParserTASK)
		}
		p.SetState(2125)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserAUTOMATIC {
			{
				p.SetState(2124)
				p.Match(VerilogParserAUTOMATIC)
			}

		}
		{
			p.SetState(2127)
			p.Task_identifier()
		}
		{
			p.SetState(2128)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		p.SetState(2130)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-47)&-(0x1f+1)) == 0 && ((1<<uint((_la-47)))&((1<<(VerilogParserINOUT-47))|(1<<(VerilogParserINPUT-47))|(1<<(VerilogParserOUTPUT-47)))) != 0) || _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2129)
				p.Task_port_list()
			}

		}
		{
			p.SetState(2132)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(2133)
			p.Match(VerilogParserSEMICOLON)
		}
		p.SetState(2137)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 183, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2134)
					p.Block_item_declaration()
				}

			}
			p.SetState(2139)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 183, p.GetParserRuleContext())
		}
		{
			p.SetState(2140)
			p.Statement_or_null()
		}
		{
			p.SetState(2141)
			p.Match(VerilogParserENDTASK)
		}

	}

	return localctx
}

// ITask_item_declarationContext is an interface to support dynamic dispatch.
type ITask_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_item_declarationContext differentiates from other interfaces.
	IsTask_item_declarationContext()
}

type Task_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_item_declarationContext() *Task_item_declarationContext {
	var p = new(Task_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_item_declaration
	return p
}

func (*Task_item_declarationContext) IsTask_item_declarationContext() {}

func NewTask_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_item_declarationContext {
	var p = new(Task_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_item_declaration

	return p
}

func (s *Task_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_item_declarationContext) Block_item_declaration() IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Task_item_declarationContext) Tf_input_declaration() ITf_input_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_input_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_input_declarationContext)
}

func (s *Task_item_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Task_item_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Task_item_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Task_item_declarationContext) Tf_output_declaration() ITf_output_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_output_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_output_declarationContext)
}

func (s *Task_item_declarationContext) Tf_inout_declaration() ITf_inout_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_inout_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_inout_declarationContext)
}

func (s *Task_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTask_item_declaration(s)
	}
}

func (s *Task_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTask_item_declaration(s)
	}
}

func (p *VerilogParser) Task_item_declaration() (localctx ITask_item_declarationContext) {
	this := p
	_ = this

	localctx = NewTask_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, VerilogParserRULE_task_item_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2173)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 188, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2145)
			p.Block_item_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2149)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2146)
				p.Attribute_instance()
			}

			p.SetState(2151)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2152)
			p.Tf_input_declaration()
		}
		{
			p.SetState(2153)
			p.Match(VerilogParserSEMICOLON)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(2158)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2155)
				p.Attribute_instance()
			}

			p.SetState(2160)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2161)
			p.Tf_output_declaration()
		}
		{
			p.SetState(2162)
			p.Match(VerilogParserSEMICOLON)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(2167)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2164)
				p.Attribute_instance()
			}

			p.SetState(2169)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2170)
			p.Tf_inout_declaration()
		}
		{
			p.SetState(2171)
			p.Match(VerilogParserSEMICOLON)
		}

	}

	return localctx
}

// ITask_port_listContext is an interface to support dynamic dispatch.
type ITask_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_port_listContext differentiates from other interfaces.
	IsTask_port_listContext()
}

type Task_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_port_listContext() *Task_port_listContext {
	var p = new(Task_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_port_list
	return p
}

func (*Task_port_listContext) IsTask_port_listContext() {}

func NewTask_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_port_listContext {
	var p = new(Task_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_port_list

	return p
}

func (s *Task_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_port_listContext) AllTask_port_item() []ITask_port_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITask_port_itemContext)(nil)).Elem())
	var tst = make([]ITask_port_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITask_port_itemContext)
		}
	}

	return tst
}

func (s *Task_port_listContext) Task_port_item(i int) ITask_port_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_port_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITask_port_itemContext)
}

func (s *Task_port_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Task_port_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Task_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTask_port_list(s)
	}
}

func (s *Task_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTask_port_list(s)
	}
}

func (p *VerilogParser) Task_port_list() (localctx ITask_port_listContext) {
	this := p
	_ = this

	localctx = NewTask_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, VerilogParserRULE_task_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2175)
		p.Task_port_item()
	}
	p.SetState(2180)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(2176)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(2177)
			p.Task_port_item()
		}

		p.SetState(2182)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITask_port_itemContext is an interface to support dynamic dispatch.
type ITask_port_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_port_itemContext differentiates from other interfaces.
	IsTask_port_itemContext()
}

type Task_port_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_port_itemContext() *Task_port_itemContext {
	var p = new(Task_port_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_port_item
	return p
}

func (*Task_port_itemContext) IsTask_port_itemContext() {}

func NewTask_port_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_port_itemContext {
	var p = new(Task_port_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_port_item

	return p
}

func (s *Task_port_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_port_itemContext) Tf_input_declaration() ITf_input_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_input_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_input_declarationContext)
}

func (s *Task_port_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Task_port_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Task_port_itemContext) Tf_output_declaration() ITf_output_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_output_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_output_declarationContext)
}

func (s *Task_port_itemContext) Tf_inout_declaration() ITf_inout_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_inout_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_inout_declarationContext)
}

func (s *Task_port_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_port_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_port_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTask_port_item(s)
	}
}

func (s *Task_port_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTask_port_item(s)
	}
}

func (p *VerilogParser) Task_port_item() (localctx ITask_port_itemContext) {
	this := p
	_ = this

	localctx = NewTask_port_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, VerilogParserRULE_task_port_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2204)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2186)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2183)
				p.Attribute_instance()
			}

			p.SetState(2188)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2189)
			p.Tf_input_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2193)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2190)
				p.Attribute_instance()
			}

			p.SetState(2195)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2196)
			p.Tf_output_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(2200)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2197)
				p.Attribute_instance()
			}

			p.SetState(2202)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2203)
			p.Tf_inout_declaration()
		}

	}

	return localctx
}

// ITf_input_declarationContext is an interface to support dynamic dispatch.
type ITf_input_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_input_declarationContext differentiates from other interfaces.
	IsTf_input_declarationContext()
}

type Tf_input_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_input_declarationContext() *Tf_input_declarationContext {
	var p = new(Tf_input_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tf_input_declaration
	return p
}

func (*Tf_input_declarationContext) IsTf_input_declarationContext() {}

func NewTf_input_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_input_declarationContext {
	var p = new(Tf_input_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tf_input_declaration

	return p
}

func (s *Tf_input_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_input_declarationContext) INPUT() antlr.TerminalNode {
	return s.GetToken(VerilogParserINPUT, 0)
}

func (s *Tf_input_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Tf_input_declarationContext) REG() antlr.TerminalNode {
	return s.GetToken(VerilogParserREG, 0)
}

func (s *Tf_input_declarationContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(VerilogParserSIGNED, 0)
}

func (s *Tf_input_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Tf_input_declarationContext) Task_port_type() ITask_port_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_port_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_port_typeContext)
}

func (s *Tf_input_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_input_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_input_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTf_input_declaration(s)
	}
}

func (s *Tf_input_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTf_input_declaration(s)
	}
}

func (p *VerilogParser) Tf_input_declaration() (localctx ITf_input_declarationContext) {
	this := p
	_ = this

	localctx = NewTf_input_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, VerilogParserRULE_tf_input_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2221)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 197, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2206)
			p.Match(VerilogParserINPUT)
		}
		p.SetState(2208)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserREG {
			{
				p.SetState(2207)
				p.Match(VerilogParserREG)
			}

		}
		p.SetState(2211)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(2210)
				p.Match(VerilogParserSIGNED)
			}

		}
		p.SetState(2214)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_BRACKET {
			{
				p.SetState(2213)
				p.Range_()
			}

		}
		{
			p.SetState(2216)
			p.List_of_port_identifiers()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2217)
			p.Match(VerilogParserINPUT)
		}
		{
			p.SetState(2218)
			p.Task_port_type()
		}
		{
			p.SetState(2219)
			p.List_of_port_identifiers()
		}

	}

	return localctx
}

// ITf_output_declarationContext is an interface to support dynamic dispatch.
type ITf_output_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_output_declarationContext differentiates from other interfaces.
	IsTf_output_declarationContext()
}

type Tf_output_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_output_declarationContext() *Tf_output_declarationContext {
	var p = new(Tf_output_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tf_output_declaration
	return p
}

func (*Tf_output_declarationContext) IsTf_output_declarationContext() {}

func NewTf_output_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_output_declarationContext {
	var p = new(Tf_output_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tf_output_declaration

	return p
}

func (s *Tf_output_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_output_declarationContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(VerilogParserOUTPUT, 0)
}

func (s *Tf_output_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Tf_output_declarationContext) REG() antlr.TerminalNode {
	return s.GetToken(VerilogParserREG, 0)
}

func (s *Tf_output_declarationContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(VerilogParserSIGNED, 0)
}

func (s *Tf_output_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Tf_output_declarationContext) Task_port_type() ITask_port_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_port_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_port_typeContext)
}

func (s *Tf_output_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_output_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_output_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTf_output_declaration(s)
	}
}

func (s *Tf_output_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTf_output_declaration(s)
	}
}

func (p *VerilogParser) Tf_output_declaration() (localctx ITf_output_declarationContext) {
	this := p
	_ = this

	localctx = NewTf_output_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, VerilogParserRULE_tf_output_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2238)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2223)
			p.Match(VerilogParserOUTPUT)
		}
		p.SetState(2225)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserREG {
			{
				p.SetState(2224)
				p.Match(VerilogParserREG)
			}

		}
		p.SetState(2228)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(2227)
				p.Match(VerilogParserSIGNED)
			}

		}
		p.SetState(2231)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_BRACKET {
			{
				p.SetState(2230)
				p.Range_()
			}

		}
		{
			p.SetState(2233)
			p.List_of_port_identifiers()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2234)
			p.Match(VerilogParserOUTPUT)
		}
		{
			p.SetState(2235)
			p.Task_port_type()
		}
		{
			p.SetState(2236)
			p.List_of_port_identifiers()
		}

	}

	return localctx
}

// ITf_inout_declarationContext is an interface to support dynamic dispatch.
type ITf_inout_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_inout_declarationContext differentiates from other interfaces.
	IsTf_inout_declarationContext()
}

type Tf_inout_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_inout_declarationContext() *Tf_inout_declarationContext {
	var p = new(Tf_inout_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tf_inout_declaration
	return p
}

func (*Tf_inout_declarationContext) IsTf_inout_declarationContext() {}

func NewTf_inout_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_inout_declarationContext {
	var p = new(Tf_inout_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tf_inout_declaration

	return p
}

func (s *Tf_inout_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_inout_declarationContext) INOUT() antlr.TerminalNode {
	return s.GetToken(VerilogParserINOUT, 0)
}

func (s *Tf_inout_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Tf_inout_declarationContext) REG() antlr.TerminalNode {
	return s.GetToken(VerilogParserREG, 0)
}

func (s *Tf_inout_declarationContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(VerilogParserSIGNED, 0)
}

func (s *Tf_inout_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Tf_inout_declarationContext) Task_port_type() ITask_port_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_port_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_port_typeContext)
}

func (s *Tf_inout_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_inout_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_inout_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTf_inout_declaration(s)
	}
}

func (s *Tf_inout_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTf_inout_declaration(s)
	}
}

func (p *VerilogParser) Tf_inout_declaration() (localctx ITf_inout_declarationContext) {
	this := p
	_ = this

	localctx = NewTf_inout_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, VerilogParserRULE_tf_inout_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2255)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2240)
			p.Match(VerilogParserINOUT)
		}
		p.SetState(2242)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserREG {
			{
				p.SetState(2241)
				p.Match(VerilogParserREG)
			}

		}
		p.SetState(2245)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(2244)
				p.Match(VerilogParserSIGNED)
			}

		}
		p.SetState(2248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_BRACKET {
			{
				p.SetState(2247)
				p.Range_()
			}

		}
		{
			p.SetState(2250)
			p.List_of_port_identifiers()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2251)
			p.Match(VerilogParserINOUT)
		}
		{
			p.SetState(2252)
			p.Task_port_type()
		}
		{
			p.SetState(2253)
			p.List_of_port_identifiers()
		}

	}

	return localctx
}

// ITask_port_typeContext is an interface to support dynamic dispatch.
type ITask_port_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_port_typeContext differentiates from other interfaces.
	IsTask_port_typeContext()
}

type Task_port_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_port_typeContext() *Task_port_typeContext {
	var p = new(Task_port_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_port_type
	return p
}

func (*Task_port_typeContext) IsTask_port_typeContext() {}

func NewTask_port_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_port_typeContext {
	var p = new(Task_port_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_port_type

	return p
}

func (s *Task_port_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_port_typeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(VerilogParserINTEGER, 0)
}

func (s *Task_port_typeContext) REAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserREAL, 0)
}

func (s *Task_port_typeContext) REALTIME() antlr.TerminalNode {
	return s.GetToken(VerilogParserREALTIME, 0)
}

func (s *Task_port_typeContext) TIME() antlr.TerminalNode {
	return s.GetToken(VerilogParserTIME, 0)
}

func (s *Task_port_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_port_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_port_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTask_port_type(s)
	}
}

func (s *Task_port_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTask_port_type(s)
	}
}

func (p *VerilogParser) Task_port_type() (localctx ITask_port_typeContext) {
	this := p
	_ = this

	localctx = NewTask_port_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, VerilogParserRULE_task_port_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2257)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-50)&-(0x1f+1)) == 0 && ((1<<uint((_la-50)))&((1<<(VerilogParserINTEGER-50))|(1<<(VerilogParserREAL-50))|(1<<(VerilogParserREALTIME-50)))) != 0) || _la == VerilogParserTIME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBlock_item_declarationContext is an interface to support dynamic dispatch.
type IBlock_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_item_declarationContext differentiates from other interfaces.
	IsBlock_item_declarationContext()
}

type Block_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_item_declarationContext() *Block_item_declarationContext {
	var p = new(Block_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_block_item_declaration
	return p
}

func (*Block_item_declarationContext) IsBlock_item_declarationContext() {}

func NewBlock_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_item_declarationContext {
	var p = new(Block_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_block_item_declaration

	return p
}

func (s *Block_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_item_declarationContext) REG() antlr.TerminalNode {
	return s.GetToken(VerilogParserREG, 0)
}

func (s *Block_item_declarationContext) List_of_block_variable_identifiers() IList_of_block_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_block_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_block_variable_identifiersContext)
}

func (s *Block_item_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Block_item_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Block_item_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Block_item_declarationContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(VerilogParserSIGNED, 0)
}

func (s *Block_item_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Block_item_declarationContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(VerilogParserINTEGER, 0)
}

func (s *Block_item_declarationContext) TIME() antlr.TerminalNode {
	return s.GetToken(VerilogParserTIME, 0)
}

func (s *Block_item_declarationContext) REAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserREAL, 0)
}

func (s *Block_item_declarationContext) List_of_block_real_identifiers() IList_of_block_real_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_block_real_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_block_real_identifiersContext)
}

func (s *Block_item_declarationContext) REALTIME() antlr.TerminalNode {
	return s.GetToken(VerilogParserREALTIME, 0)
}

func (s *Block_item_declarationContext) Event_declaration() IEvent_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_declarationContext)
}

func (s *Block_item_declarationContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Block_item_declarationContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Block_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBlock_item_declaration(s)
	}
}

func (s *Block_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBlock_item_declaration(s)
	}
}

func (p *VerilogParser) Block_item_declaration() (localctx IBlock_item_declarationContext) {
	this := p
	_ = this

	localctx = NewBlock_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, VerilogParserRULE_block_item_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2340)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2259)
				p.Attribute_instance()
			}

			p.SetState(2264)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2265)
			p.Match(VerilogParserREG)
		}
		p.SetState(2267)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSIGNED {
			{
				p.SetState(2266)
				p.Match(VerilogParserSIGNED)
			}

		}
		p.SetState(2270)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_BRACKET {
			{
				p.SetState(2269)
				p.Range_()
			}

		}
		{
			p.SetState(2272)
			p.List_of_block_variable_identifiers()
		}
		{
			p.SetState(2273)
			p.Match(VerilogParserSEMICOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2278)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2275)
				p.Attribute_instance()
			}

			p.SetState(2280)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2281)
			p.Match(VerilogParserINTEGER)
		}
		{
			p.SetState(2282)
			p.List_of_block_variable_identifiers()
		}
		{
			p.SetState(2283)
			p.Match(VerilogParserSEMICOLON)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(2288)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2285)
				p.Attribute_instance()
			}

			p.SetState(2290)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2291)
			p.Match(VerilogParserTIME)
		}
		{
			p.SetState(2292)
			p.List_of_block_variable_identifiers()
		}
		{
			p.SetState(2293)
			p.Match(VerilogParserSEMICOLON)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(2298)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2295)
				p.Attribute_instance()
			}

			p.SetState(2300)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2301)
			p.Match(VerilogParserREAL)
		}
		{
			p.SetState(2302)
			p.List_of_block_real_identifiers()
		}
		{
			p.SetState(2303)
			p.Match(VerilogParserSEMICOLON)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(2308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2305)
				p.Attribute_instance()
			}

			p.SetState(2310)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2311)
			p.Match(VerilogParserREALTIME)
		}
		{
			p.SetState(2312)
			p.List_of_block_real_identifiers()
		}
		{
			p.SetState(2313)
			p.Match(VerilogParserSEMICOLON)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(2318)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2315)
				p.Attribute_instance()
			}

			p.SetState(2320)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2321)
			p.Event_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(2325)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2322)
				p.Attribute_instance()
			}

			p.SetState(2327)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2328)
			p.Local_parameter_declaration()
		}
		{
			p.SetState(2329)
			p.Match(VerilogParserSEMICOLON)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(2334)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2331)
				p.Attribute_instance()
			}

			p.SetState(2336)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2337)
			p.Parameter_declaration()
		}
		{
			p.SetState(2338)
			p.Match(VerilogParserSEMICOLON)
		}

	}

	return localctx
}

// IList_of_block_variable_identifiersContext is an interface to support dynamic dispatch.
type IList_of_block_variable_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_block_variable_identifiersContext differentiates from other interfaces.
	IsList_of_block_variable_identifiersContext()
}

type List_of_block_variable_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_block_variable_identifiersContext() *List_of_block_variable_identifiersContext {
	var p = new(List_of_block_variable_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_block_variable_identifiers
	return p
}

func (*List_of_block_variable_identifiersContext) IsList_of_block_variable_identifiersContext() {}

func NewList_of_block_variable_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_block_variable_identifiersContext {
	var p = new(List_of_block_variable_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_block_variable_identifiers

	return p
}

func (s *List_of_block_variable_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_block_variable_identifiersContext) AllBlock_variable_type() []IBlock_variable_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_variable_typeContext)(nil)).Elem())
	var tst = make([]IBlock_variable_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_variable_typeContext)
		}
	}

	return tst
}

func (s *List_of_block_variable_identifiersContext) Block_variable_type(i int) IBlock_variable_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_variable_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_variable_typeContext)
}

func (s *List_of_block_variable_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_block_variable_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_block_variable_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_block_variable_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_block_variable_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_block_variable_identifiers(s)
	}
}

func (s *List_of_block_variable_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_block_variable_identifiers(s)
	}
}

func (p *VerilogParser) List_of_block_variable_identifiers() (localctx IList_of_block_variable_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_block_variable_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, VerilogParserRULE_list_of_block_variable_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2342)
		p.Block_variable_type()
	}
	p.SetState(2347)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(2343)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(2344)
			p.Block_variable_type()
		}

		p.SetState(2349)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_block_real_identifiersContext is an interface to support dynamic dispatch.
type IList_of_block_real_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_block_real_identifiersContext differentiates from other interfaces.
	IsList_of_block_real_identifiersContext()
}

type List_of_block_real_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_block_real_identifiersContext() *List_of_block_real_identifiersContext {
	var p = new(List_of_block_real_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_block_real_identifiers
	return p
}

func (*List_of_block_real_identifiersContext) IsList_of_block_real_identifiersContext() {}

func NewList_of_block_real_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_block_real_identifiersContext {
	var p = new(List_of_block_real_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_block_real_identifiers

	return p
}

func (s *List_of_block_real_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_block_real_identifiersContext) AllBlock_real_type() []IBlock_real_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_real_typeContext)(nil)).Elem())
	var tst = make([]IBlock_real_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_real_typeContext)
		}
	}

	return tst
}

func (s *List_of_block_real_identifiersContext) Block_real_type(i int) IBlock_real_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_real_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_real_typeContext)
}

func (s *List_of_block_real_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_block_real_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_block_real_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_block_real_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_block_real_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_block_real_identifiers(s)
	}
}

func (s *List_of_block_real_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_block_real_identifiers(s)
	}
}

func (p *VerilogParser) List_of_block_real_identifiers() (localctx IList_of_block_real_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_block_real_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, VerilogParserRULE_list_of_block_real_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2350)
		p.Block_real_type()
	}
	p.SetState(2355)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(2351)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(2352)
			p.Block_real_type()
		}

		p.SetState(2357)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBlock_variable_typeContext is an interface to support dynamic dispatch.
type IBlock_variable_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_variable_typeContext differentiates from other interfaces.
	IsBlock_variable_typeContext()
}

type Block_variable_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_variable_typeContext() *Block_variable_typeContext {
	var p = new(Block_variable_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_block_variable_type
	return p
}

func (*Block_variable_typeContext) IsBlock_variable_typeContext() {}

func NewBlock_variable_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_variable_typeContext {
	var p = new(Block_variable_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_block_variable_type

	return p
}

func (s *Block_variable_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_variable_typeContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Block_variable_typeContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *Block_variable_typeContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Block_variable_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_variable_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_variable_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBlock_variable_type(s)
	}
}

func (s *Block_variable_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBlock_variable_type(s)
	}
}

func (p *VerilogParser) Block_variable_type() (localctx IBlock_variable_typeContext) {
	this := p
	_ = this

	localctx = NewBlock_variable_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, VerilogParserRULE_block_variable_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2358)
		p.Variable_identifier()
	}
	p.SetState(2362)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserLEFT_BRACKET {
		{
			p.SetState(2359)
			p.Dimension()
		}

		p.SetState(2364)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBlock_real_typeContext is an interface to support dynamic dispatch.
type IBlock_real_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_real_typeContext differentiates from other interfaces.
	IsBlock_real_typeContext()
}

type Block_real_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_real_typeContext() *Block_real_typeContext {
	var p = new(Block_real_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_block_real_type
	return p
}

func (*Block_real_typeContext) IsBlock_real_typeContext() {}

func NewBlock_real_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_real_typeContext {
	var p = new(Block_real_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_block_real_type

	return p
}

func (s *Block_real_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_real_typeContext) Real_identifier() IReal_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_identifierContext)
}

func (s *Block_real_typeContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *Block_real_typeContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Block_real_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_real_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_real_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBlock_real_type(s)
	}
}

func (s *Block_real_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBlock_real_type(s)
	}
}

func (p *VerilogParser) Block_real_type() (localctx IBlock_real_typeContext) {
	this := p
	_ = this

	localctx = NewBlock_real_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, VerilogParserRULE_block_real_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2365)
		p.Real_identifier()
	}
	p.SetState(2369)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserLEFT_BRACKET {
		{
			p.SetState(2366)
			p.Dimension()
		}

		p.SetState(2371)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGate_instantiationContext is an interface to support dynamic dispatch.
type IGate_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGate_instantiationContext differentiates from other interfaces.
	IsGate_instantiationContext()
}

type Gate_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGate_instantiationContext() *Gate_instantiationContext {
	var p = new(Gate_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_gate_instantiation
	return p
}

func (*Gate_instantiationContext) IsGate_instantiationContext() {}

func NewGate_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Gate_instantiationContext {
	var p = new(Gate_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_gate_instantiation

	return p
}

func (s *Gate_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Gate_instantiationContext) Cmos_switchtype() ICmos_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmos_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmos_switchtypeContext)
}

func (s *Gate_instantiationContext) AllCmos_switch_instance() []ICmos_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICmos_switch_instanceContext)(nil)).Elem())
	var tst = make([]ICmos_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICmos_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Cmos_switch_instance(i int) ICmos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmos_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICmos_switch_instanceContext)
}

func (s *Gate_instantiationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Gate_instantiationContext) Delay3() IDelay3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay3Context)
}

func (s *Gate_instantiationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Gate_instantiationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Gate_instantiationContext) Enable_gatetype() IEnable_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_gatetypeContext)
}

func (s *Gate_instantiationContext) AllEnable_gate_instance() []IEnable_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnable_gate_instanceContext)(nil)).Elem())
	var tst = make([]IEnable_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnable_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Enable_gate_instance(i int) IEnable_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnable_gate_instanceContext)
}

func (s *Gate_instantiationContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Gate_instantiationContext) Mos_switchtype() IMos_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMos_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMos_switchtypeContext)
}

func (s *Gate_instantiationContext) AllMos_switch_instance() []IMos_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMos_switch_instanceContext)(nil)).Elem())
	var tst = make([]IMos_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMos_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Mos_switch_instance(i int) IMos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMos_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMos_switch_instanceContext)
}

func (s *Gate_instantiationContext) N_input_gatetype() IN_input_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_input_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_input_gatetypeContext)
}

func (s *Gate_instantiationContext) AllN_input_gate_instance() []IN_input_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IN_input_gate_instanceContext)(nil)).Elem())
	var tst = make([]IN_input_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IN_input_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) N_input_gate_instance(i int) IN_input_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_input_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IN_input_gate_instanceContext)
}

func (s *Gate_instantiationContext) Delay2() IDelay2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay2Context)
}

func (s *Gate_instantiationContext) N_output_gatetype() IN_output_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_output_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_output_gatetypeContext)
}

func (s *Gate_instantiationContext) AllN_output_gate_instance() []IN_output_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IN_output_gate_instanceContext)(nil)).Elem())
	var tst = make([]IN_output_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IN_output_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) N_output_gate_instance(i int) IN_output_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_output_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IN_output_gate_instanceContext)
}

func (s *Gate_instantiationContext) Pass_en_switchtype() IPass_en_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_en_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_en_switchtypeContext)
}

func (s *Gate_instantiationContext) AllPass_enable_switch_instance() []IPass_enable_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPass_enable_switch_instanceContext)(nil)).Elem())
	var tst = make([]IPass_enable_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPass_enable_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Pass_enable_switch_instance(i int) IPass_enable_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_enable_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPass_enable_switch_instanceContext)
}

func (s *Gate_instantiationContext) Pass_switchtype() IPass_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_switchtypeContext)
}

func (s *Gate_instantiationContext) AllPass_switch_instance() []IPass_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPass_switch_instanceContext)(nil)).Elem())
	var tst = make([]IPass_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPass_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Pass_switch_instance(i int) IPass_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPass_switch_instanceContext)
}

func (s *Gate_instantiationContext) PULLDOWN() antlr.TerminalNode {
	return s.GetToken(VerilogParserPULLDOWN, 0)
}

func (s *Gate_instantiationContext) AllPull_gate_instance() []IPull_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPull_gate_instanceContext)(nil)).Elem())
	var tst = make([]IPull_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPull_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Pull_gate_instance(i int) IPull_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPull_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPull_gate_instanceContext)
}

func (s *Gate_instantiationContext) Pulldown_strength() IPulldown_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPulldown_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPulldown_strengthContext)
}

func (s *Gate_instantiationContext) PULLUP() antlr.TerminalNode {
	return s.GetToken(VerilogParserPULLUP, 0)
}

func (s *Gate_instantiationContext) Pullup_strength() IPullup_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPullup_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPullup_strengthContext)
}

func (s *Gate_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Gate_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Gate_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGate_instantiation(s)
	}
}

func (s *Gate_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGate_instantiation(s)
	}
}

func (p *VerilogParser) Gate_instantiation() (localctx IGate_instantiationContext) {
	this := p
	_ = this

	localctx = NewGate_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, VerilogParserRULE_gate_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2504)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserCMOS, VerilogParserRCMOS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2372)
			p.Cmos_switchtype()
		}
		p.SetState(2374)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(2373)
				p.Delay3()
			}

		}
		{
			p.SetState(2376)
			p.Cmos_switch_instance()
		}
		p.SetState(2381)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(2377)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2378)
				p.Cmos_switch_instance()
			}

			p.SetState(2383)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2384)
			p.Match(VerilogParserSEMICOLON)
		}

	case VerilogParserBUFIF0, VerilogParserBUFIF1, VerilogParserNOTIF0, VerilogParserNOTIF1:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2386)
			p.Enable_gatetype()
		}
		p.SetState(2388)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 223, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2387)
				p.Drive_strength()
			}

		}
		p.SetState(2391)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(2390)
				p.Delay3()
			}

		}
		{
			p.SetState(2393)
			p.Enable_gate_instance()
		}
		p.SetState(2398)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(2394)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2395)
				p.Enable_gate_instance()
			}

			p.SetState(2400)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2401)
			p.Match(VerilogParserSEMICOLON)
		}

	case VerilogParserNMOS, VerilogParserPMOS, VerilogParserRNMOS, VerilogParserRPMOS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2403)
			p.Mos_switchtype()
		}
		p.SetState(2405)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(2404)
				p.Delay3()
			}

		}
		{
			p.SetState(2407)
			p.Mos_switch_instance()
		}
		p.SetState(2412)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(2408)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2409)
				p.Mos_switch_instance()
			}

			p.SetState(2414)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2415)
			p.Match(VerilogParserSEMICOLON)
		}

	case VerilogParserAND, VerilogParserNAND, VerilogParserNOR, VerilogParserOR, VerilogParserXNOR, VerilogParserXOR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2417)
			p.N_input_gatetype()
		}
		p.SetState(2419)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 228, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2418)
				p.Drive_strength()
			}

		}
		p.SetState(2422)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(2421)
				p.Delay2()
			}

		}
		{
			p.SetState(2424)
			p.N_input_gate_instance()
		}
		p.SetState(2429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(2425)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2426)
				p.N_input_gate_instance()
			}

			p.SetState(2431)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2432)
			p.Match(VerilogParserSEMICOLON)
		}

	case VerilogParserBUF, VerilogParserNOT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2434)
			p.N_output_gatetype()
		}
		p.SetState(2436)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 231, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2435)
				p.Drive_strength()
			}

		}
		p.SetState(2439)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(2438)
				p.Delay2()
			}

		}
		{
			p.SetState(2441)
			p.N_output_gate_instance()
		}
		p.SetState(2446)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(2442)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2443)
				p.N_output_gate_instance()
			}

			p.SetState(2448)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2449)
			p.Match(VerilogParserSEMICOLON)
		}

	case VerilogParserRTRANIF0, VerilogParserRTRANIF1, VerilogParserTRANIF0, VerilogParserTRANIF1:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2451)
			p.Pass_en_switchtype()
		}
		p.SetState(2453)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserHASH {
			{
				p.SetState(2452)
				p.Delay2()
			}

		}
		{
			p.SetState(2455)
			p.Pass_enable_switch_instance()
		}
		p.SetState(2460)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(2456)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2457)
				p.Pass_enable_switch_instance()
			}

			p.SetState(2462)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2463)
			p.Match(VerilogParserSEMICOLON)
		}

	case VerilogParserRTRAN, VerilogParserTRAN:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2465)
			p.Pass_switchtype()
		}
		{
			p.SetState(2466)
			p.Pass_switch_instance()
		}
		p.SetState(2471)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(2467)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2468)
				p.Pass_switch_instance()
			}

			p.SetState(2473)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2474)
			p.Match(VerilogParserSEMICOLON)
		}

	case VerilogParserPULLDOWN:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2476)
			p.Match(VerilogParserPULLDOWN)
		}
		p.SetState(2478)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 237, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2477)
				p.Pulldown_strength()
			}

		}
		{
			p.SetState(2480)
			p.Pull_gate_instance()
		}
		p.SetState(2485)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(2481)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2482)
				p.Pull_gate_instance()
			}

			p.SetState(2487)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2488)
			p.Match(VerilogParserSEMICOLON)
		}

	case VerilogParserPULLUP:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2490)
			p.Match(VerilogParserPULLUP)
		}
		p.SetState(2492)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 239, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2491)
				p.Pullup_strength()
			}

		}
		{
			p.SetState(2494)
			p.Pull_gate_instance()
		}
		p.SetState(2499)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(2495)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2496)
				p.Pull_gate_instance()
			}

			p.SetState(2501)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2502)
			p.Match(VerilogParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICmos_switch_instanceContext is an interface to support dynamic dispatch.
type ICmos_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmos_switch_instanceContext differentiates from other interfaces.
	IsCmos_switch_instanceContext()
}

type Cmos_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmos_switch_instanceContext() *Cmos_switch_instanceContext {
	var p = new(Cmos_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_cmos_switch_instance
	return p
}

func (*Cmos_switch_instanceContext) IsCmos_switch_instanceContext() {}

func NewCmos_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmos_switch_instanceContext {
	var p = new(Cmos_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_cmos_switch_instance

	return p
}

func (s *Cmos_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmos_switch_instanceContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Cmos_switch_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Cmos_switch_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Cmos_switch_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Cmos_switch_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Cmos_switch_instanceContext) Ncontrol_terminal() INcontrol_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INcontrol_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INcontrol_terminalContext)
}

func (s *Cmos_switch_instanceContext) Pcontrol_terminal() IPcontrol_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPcontrol_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPcontrol_terminalContext)
}

func (s *Cmos_switch_instanceContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Cmos_switch_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Cmos_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmos_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmos_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCmos_switch_instance(s)
	}
}

func (s *Cmos_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCmos_switch_instance(s)
	}
}

func (p *VerilogParser) Cmos_switch_instance() (localctx ICmos_switch_instanceContext) {
	this := p
	_ = this

	localctx = NewCmos_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, VerilogParserRULE_cmos_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2507)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserESCAPED_IDENTIFIER || _la == VerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(2506)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2509)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(2510)
		p.Output_terminal()
	}
	{
		p.SetState(2511)
		p.Match(VerilogParserCOMMA)
	}
	{
		p.SetState(2512)
		p.Input_terminal()
	}
	{
		p.SetState(2513)
		p.Match(VerilogParserCOMMA)
	}
	{
		p.SetState(2514)
		p.Ncontrol_terminal()
	}
	{
		p.SetState(2515)
		p.Match(VerilogParserCOMMA)
	}
	{
		p.SetState(2516)
		p.Pcontrol_terminal()
	}
	{
		p.SetState(2517)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IEnable_gate_instanceContext is an interface to support dynamic dispatch.
type IEnable_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_gate_instanceContext differentiates from other interfaces.
	IsEnable_gate_instanceContext()
}

type Enable_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_gate_instanceContext() *Enable_gate_instanceContext {
	var p = new(Enable_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_enable_gate_instance
	return p
}

func (*Enable_gate_instanceContext) IsEnable_gate_instanceContext() {}

func NewEnable_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_gate_instanceContext {
	var p = new(Enable_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_enable_gate_instance

	return p
}

func (s *Enable_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_gate_instanceContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Enable_gate_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Enable_gate_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Enable_gate_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Enable_gate_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Enable_gate_instanceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Enable_gate_instanceContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Enable_gate_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Enable_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEnable_gate_instance(s)
	}
}

func (s *Enable_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEnable_gate_instance(s)
	}
}

func (p *VerilogParser) Enable_gate_instance() (localctx IEnable_gate_instanceContext) {
	this := p
	_ = this

	localctx = NewEnable_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, VerilogParserRULE_enable_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2520)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserESCAPED_IDENTIFIER || _la == VerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(2519)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2522)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(2523)
		p.Output_terminal()
	}
	{
		p.SetState(2524)
		p.Match(VerilogParserCOMMA)
	}
	{
		p.SetState(2525)
		p.Input_terminal()
	}
	{
		p.SetState(2526)
		p.Match(VerilogParserCOMMA)
	}
	{
		p.SetState(2527)
		p.Enable_terminal()
	}
	{
		p.SetState(2528)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IMos_switch_instanceContext is an interface to support dynamic dispatch.
type IMos_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMos_switch_instanceContext differentiates from other interfaces.
	IsMos_switch_instanceContext()
}

type Mos_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMos_switch_instanceContext() *Mos_switch_instanceContext {
	var p = new(Mos_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_mos_switch_instance
	return p
}

func (*Mos_switch_instanceContext) IsMos_switch_instanceContext() {}

func NewMos_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mos_switch_instanceContext {
	var p = new(Mos_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_mos_switch_instance

	return p
}

func (s *Mos_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Mos_switch_instanceContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Mos_switch_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Mos_switch_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Mos_switch_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Mos_switch_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Mos_switch_instanceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Mos_switch_instanceContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Mos_switch_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Mos_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mos_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mos_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMos_switch_instance(s)
	}
}

func (s *Mos_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMos_switch_instance(s)
	}
}

func (p *VerilogParser) Mos_switch_instance() (localctx IMos_switch_instanceContext) {
	this := p
	_ = this

	localctx = NewMos_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, VerilogParserRULE_mos_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2531)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserESCAPED_IDENTIFIER || _la == VerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(2530)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2533)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(2534)
		p.Output_terminal()
	}
	{
		p.SetState(2535)
		p.Match(VerilogParserCOMMA)
	}
	{
		p.SetState(2536)
		p.Input_terminal()
	}
	{
		p.SetState(2537)
		p.Match(VerilogParserCOMMA)
	}
	{
		p.SetState(2538)
		p.Enable_terminal()
	}
	{
		p.SetState(2539)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IN_input_gate_instanceContext is an interface to support dynamic dispatch.
type IN_input_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_input_gate_instanceContext differentiates from other interfaces.
	IsN_input_gate_instanceContext()
}

type N_input_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_input_gate_instanceContext() *N_input_gate_instanceContext {
	var p = new(N_input_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_n_input_gate_instance
	return p
}

func (*N_input_gate_instanceContext) IsN_input_gate_instanceContext() {}

func NewN_input_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_input_gate_instanceContext {
	var p = new(N_input_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_n_input_gate_instance

	return p
}

func (s *N_input_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *N_input_gate_instanceContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *N_input_gate_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *N_input_gate_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *N_input_gate_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *N_input_gate_instanceContext) AllInput_terminal() []IInput_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem())
	var tst = make([]IInput_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInput_terminalContext)
		}
	}

	return tst
}

func (s *N_input_gate_instanceContext) Input_terminal(i int) IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *N_input_gate_instanceContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *N_input_gate_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *N_input_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_input_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_input_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterN_input_gate_instance(s)
	}
}

func (s *N_input_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitN_input_gate_instance(s)
	}
}

func (p *VerilogParser) N_input_gate_instance() (localctx IN_input_gate_instanceContext) {
	this := p
	_ = this

	localctx = NewN_input_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, VerilogParserRULE_n_input_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2542)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserESCAPED_IDENTIFIER || _la == VerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(2541)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2544)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(2545)
		p.Output_terminal()
	}
	{
		p.SetState(2546)
		p.Match(VerilogParserCOMMA)
	}
	{
		p.SetState(2547)
		p.Input_terminal()
	}
	p.SetState(2552)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(2548)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(2549)
			p.Input_terminal()
		}

		p.SetState(2554)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2555)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IN_output_gate_instanceContext is an interface to support dynamic dispatch.
type IN_output_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_output_gate_instanceContext differentiates from other interfaces.
	IsN_output_gate_instanceContext()
}

type N_output_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_output_gate_instanceContext() *N_output_gate_instanceContext {
	var p = new(N_output_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_n_output_gate_instance
	return p
}

func (*N_output_gate_instanceContext) IsN_output_gate_instanceContext() {}

func NewN_output_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_output_gate_instanceContext {
	var p = new(N_output_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_n_output_gate_instance

	return p
}

func (s *N_output_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *N_output_gate_instanceContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *N_output_gate_instanceContext) AllOutput_terminal() []IOutput_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem())
	var tst = make([]IOutput_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOutput_terminalContext)
		}
	}

	return tst
}

func (s *N_output_gate_instanceContext) Output_terminal(i int) IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *N_output_gate_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *N_output_gate_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *N_output_gate_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *N_output_gate_instanceContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *N_output_gate_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *N_output_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_output_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_output_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterN_output_gate_instance(s)
	}
}

func (s *N_output_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitN_output_gate_instance(s)
	}
}

func (p *VerilogParser) N_output_gate_instance() (localctx IN_output_gate_instanceContext) {
	this := p
	_ = this

	localctx = NewN_output_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, VerilogParserRULE_n_output_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2558)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserESCAPED_IDENTIFIER || _la == VerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(2557)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2560)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(2561)
		p.Output_terminal()
	}
	p.SetState(2566)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 248, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2562)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2563)
				p.Output_terminal()
			}

		}
		p.SetState(2568)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 248, p.GetParserRuleContext())
	}
	{
		p.SetState(2569)
		p.Match(VerilogParserCOMMA)
	}
	{
		p.SetState(2570)
		p.Input_terminal()
	}
	{
		p.SetState(2571)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IPass_switch_instanceContext is an interface to support dynamic dispatch.
type IPass_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_switch_instanceContext differentiates from other interfaces.
	IsPass_switch_instanceContext()
}

type Pass_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_switch_instanceContext() *Pass_switch_instanceContext {
	var p = new(Pass_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pass_switch_instance
	return p
}

func (*Pass_switch_instanceContext) IsPass_switch_instanceContext() {}

func NewPass_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_switch_instanceContext {
	var p = new(Pass_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pass_switch_instance

	return p
}

func (s *Pass_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_switch_instanceContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Pass_switch_instanceContext) AllInout_terminal() []IInout_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem())
	var tst = make([]IInout_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInout_terminalContext)
		}
	}

	return tst
}

func (s *Pass_switch_instanceContext) Inout_terminal(i int) IInout_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInout_terminalContext)
}

func (s *Pass_switch_instanceContext) COMMA() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, 0)
}

func (s *Pass_switch_instanceContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Pass_switch_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Pass_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPass_switch_instance(s)
	}
}

func (s *Pass_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPass_switch_instance(s)
	}
}

func (p *VerilogParser) Pass_switch_instance() (localctx IPass_switch_instanceContext) {
	this := p
	_ = this

	localctx = NewPass_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, VerilogParserRULE_pass_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2574)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserESCAPED_IDENTIFIER || _la == VerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(2573)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2576)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(2577)
		p.Inout_terminal()
	}
	{
		p.SetState(2578)
		p.Match(VerilogParserCOMMA)
	}
	{
		p.SetState(2579)
		p.Inout_terminal()
	}
	{
		p.SetState(2580)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IPass_enable_switch_instanceContext is an interface to support dynamic dispatch.
type IPass_enable_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_enable_switch_instanceContext differentiates from other interfaces.
	IsPass_enable_switch_instanceContext()
}

type Pass_enable_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_enable_switch_instanceContext() *Pass_enable_switch_instanceContext {
	var p = new(Pass_enable_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pass_enable_switch_instance
	return p
}

func (*Pass_enable_switch_instanceContext) IsPass_enable_switch_instanceContext() {}

func NewPass_enable_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_enable_switch_instanceContext {
	var p = new(Pass_enable_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pass_enable_switch_instance

	return p
}

func (s *Pass_enable_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_enable_switch_instanceContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Pass_enable_switch_instanceContext) AllInout_terminal() []IInout_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem())
	var tst = make([]IInout_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInout_terminalContext)
		}
	}

	return tst
}

func (s *Pass_enable_switch_instanceContext) Inout_terminal(i int) IInout_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInout_terminalContext)
}

func (s *Pass_enable_switch_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Pass_enable_switch_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Pass_enable_switch_instanceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Pass_enable_switch_instanceContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Pass_enable_switch_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Pass_enable_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_enable_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_enable_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPass_enable_switch_instance(s)
	}
}

func (s *Pass_enable_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPass_enable_switch_instance(s)
	}
}

func (p *VerilogParser) Pass_enable_switch_instance() (localctx IPass_enable_switch_instanceContext) {
	this := p
	_ = this

	localctx = NewPass_enable_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, VerilogParserRULE_pass_enable_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2583)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserESCAPED_IDENTIFIER || _la == VerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(2582)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2585)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(2586)
		p.Inout_terminal()
	}
	{
		p.SetState(2587)
		p.Match(VerilogParserCOMMA)
	}
	{
		p.SetState(2588)
		p.Inout_terminal()
	}
	{
		p.SetState(2589)
		p.Match(VerilogParserCOMMA)
	}
	{
		p.SetState(2590)
		p.Enable_terminal()
	}
	{
		p.SetState(2591)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IPull_gate_instanceContext is an interface to support dynamic dispatch.
type IPull_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPull_gate_instanceContext differentiates from other interfaces.
	IsPull_gate_instanceContext()
}

type Pull_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPull_gate_instanceContext() *Pull_gate_instanceContext {
	var p = new(Pull_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pull_gate_instance
	return p
}

func (*Pull_gate_instanceContext) IsPull_gate_instanceContext() {}

func NewPull_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pull_gate_instanceContext {
	var p = new(Pull_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pull_gate_instance

	return p
}

func (s *Pull_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pull_gate_instanceContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Pull_gate_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Pull_gate_instanceContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Pull_gate_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Pull_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pull_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pull_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPull_gate_instance(s)
	}
}

func (s *Pull_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPull_gate_instance(s)
	}
}

func (p *VerilogParser) Pull_gate_instance() (localctx IPull_gate_instanceContext) {
	this := p
	_ = this

	localctx = NewPull_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, VerilogParserRULE_pull_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2594)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserESCAPED_IDENTIFIER || _la == VerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(2593)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2596)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(2597)
		p.Output_terminal()
	}
	{
		p.SetState(2598)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IName_of_gate_instanceContext is an interface to support dynamic dispatch.
type IName_of_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_of_gate_instanceContext differentiates from other interfaces.
	IsName_of_gate_instanceContext()
}

type Name_of_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_of_gate_instanceContext() *Name_of_gate_instanceContext {
	var p = new(Name_of_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_name_of_gate_instance
	return p
}

func (*Name_of_gate_instanceContext) IsName_of_gate_instanceContext() {}

func NewName_of_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_of_gate_instanceContext {
	var p = new(Name_of_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_name_of_gate_instance

	return p
}

func (s *Name_of_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_of_gate_instanceContext) Gate_instance_identifier() IGate_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instance_identifierContext)
}

func (s *Name_of_gate_instanceContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Name_of_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_of_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_of_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterName_of_gate_instance(s)
	}
}

func (s *Name_of_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitName_of_gate_instance(s)
	}
}

func (p *VerilogParser) Name_of_gate_instance() (localctx IName_of_gate_instanceContext) {
	this := p
	_ = this

	localctx = NewName_of_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, VerilogParserRULE_name_of_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2600)
		p.Gate_instance_identifier()
	}
	p.SetState(2602)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_BRACKET {
		{
			p.SetState(2601)
			p.Range_()
		}

	}

	return localctx
}

// IPulldown_strengthContext is an interface to support dynamic dispatch.
type IPulldown_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPulldown_strengthContext differentiates from other interfaces.
	IsPulldown_strengthContext()
}

type Pulldown_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPulldown_strengthContext() *Pulldown_strengthContext {
	var p = new(Pulldown_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pulldown_strength
	return p
}

func (*Pulldown_strengthContext) IsPulldown_strengthContext() {}

func NewPulldown_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pulldown_strengthContext {
	var p = new(Pulldown_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pulldown_strength

	return p
}

func (s *Pulldown_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Pulldown_strengthContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Pulldown_strengthContext) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Pulldown_strengthContext) COMMA() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, 0)
}

func (s *Pulldown_strengthContext) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Pulldown_strengthContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Pulldown_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pulldown_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pulldown_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPulldown_strength(s)
	}
}

func (s *Pulldown_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPulldown_strength(s)
	}
}

func (p *VerilogParser) Pulldown_strength() (localctx IPulldown_strengthContext) {
	this := p
	_ = this

	localctx = NewPulldown_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, VerilogParserRULE_pulldown_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2620)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 253, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2604)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(2605)
			p.Strength0()
		}
		{
			p.SetState(2606)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(2607)
			p.Strength1()
		}
		{
			p.SetState(2608)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2610)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(2611)
			p.Strength1()
		}
		{
			p.SetState(2612)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(2613)
			p.Strength0()
		}
		{
			p.SetState(2614)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2616)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(2617)
			p.Strength0()
		}
		{
			p.SetState(2618)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}

	return localctx
}

// IPullup_strengthContext is an interface to support dynamic dispatch.
type IPullup_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPullup_strengthContext differentiates from other interfaces.
	IsPullup_strengthContext()
}

type Pullup_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPullup_strengthContext() *Pullup_strengthContext {
	var p = new(Pullup_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pullup_strength
	return p
}

func (*Pullup_strengthContext) IsPullup_strengthContext() {}

func NewPullup_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pullup_strengthContext {
	var p = new(Pullup_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pullup_strength

	return p
}

func (s *Pullup_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Pullup_strengthContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Pullup_strengthContext) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Pullup_strengthContext) COMMA() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, 0)
}

func (s *Pullup_strengthContext) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Pullup_strengthContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Pullup_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pullup_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pullup_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPullup_strength(s)
	}
}

func (s *Pullup_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPullup_strength(s)
	}
}

func (p *VerilogParser) Pullup_strength() (localctx IPullup_strengthContext) {
	this := p
	_ = this

	localctx = NewPullup_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, VerilogParserRULE_pullup_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2638)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 254, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2622)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(2623)
			p.Strength0()
		}
		{
			p.SetState(2624)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(2625)
			p.Strength1()
		}
		{
			p.SetState(2626)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2628)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(2629)
			p.Strength1()
		}
		{
			p.SetState(2630)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(2631)
			p.Strength0()
		}
		{
			p.SetState(2632)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2634)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(2635)
			p.Strength1()
		}
		{
			p.SetState(2636)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}

	return localctx
}

// IEnable_terminalContext is an interface to support dynamic dispatch.
type IEnable_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_terminalContext differentiates from other interfaces.
	IsEnable_terminalContext()
}

type Enable_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_terminalContext() *Enable_terminalContext {
	var p = new(Enable_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_enable_terminal
	return p
}

func (*Enable_terminalContext) IsEnable_terminalContext() {}

func NewEnable_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_terminalContext {
	var p = new(Enable_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_enable_terminal

	return p
}

func (s *Enable_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Enable_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEnable_terminal(s)
	}
}

func (s *Enable_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEnable_terminal(s)
	}
}

func (p *VerilogParser) Enable_terminal() (localctx IEnable_terminalContext) {
	this := p
	_ = this

	localctx = NewEnable_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, VerilogParserRULE_enable_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2640)
		p.expression(0)
	}

	return localctx
}

// IInout_terminalContext is an interface to support dynamic dispatch.
type IInout_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_terminalContext differentiates from other interfaces.
	IsInout_terminalContext()
}

type Inout_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_terminalContext() *Inout_terminalContext {
	var p = new(Inout_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inout_terminal
	return p
}

func (*Inout_terminalContext) IsInout_terminalContext() {}

func NewInout_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_terminalContext {
	var p = new(Inout_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inout_terminal

	return p
}

func (s *Inout_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_terminalContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Inout_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInout_terminal(s)
	}
}

func (s *Inout_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInout_terminal(s)
	}
}

func (p *VerilogParser) Inout_terminal() (localctx IInout_terminalContext) {
	this := p
	_ = this

	localctx = NewInout_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, VerilogParserRULE_inout_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2642)
		p.Net_lvalue()
	}

	return localctx
}

// IInput_terminalContext is an interface to support dynamic dispatch.
type IInput_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_terminalContext differentiates from other interfaces.
	IsInput_terminalContext()
}

type Input_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_terminalContext() *Input_terminalContext {
	var p = new(Input_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_input_terminal
	return p
}

func (*Input_terminalContext) IsInput_terminalContext() {}

func NewInput_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_terminalContext {
	var p = new(Input_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_input_terminal

	return p
}

func (s *Input_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Input_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInput_terminal(s)
	}
}

func (s *Input_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInput_terminal(s)
	}
}

func (p *VerilogParser) Input_terminal() (localctx IInput_terminalContext) {
	this := p
	_ = this

	localctx = NewInput_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, VerilogParserRULE_input_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2644)
		p.expression(0)
	}

	return localctx
}

// INcontrol_terminalContext is an interface to support dynamic dispatch.
type INcontrol_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNcontrol_terminalContext differentiates from other interfaces.
	IsNcontrol_terminalContext()
}

type Ncontrol_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNcontrol_terminalContext() *Ncontrol_terminalContext {
	var p = new(Ncontrol_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_ncontrol_terminal
	return p
}

func (*Ncontrol_terminalContext) IsNcontrol_terminalContext() {}

func NewNcontrol_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ncontrol_terminalContext {
	var p = new(Ncontrol_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_ncontrol_terminal

	return p
}

func (s *Ncontrol_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Ncontrol_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ncontrol_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ncontrol_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ncontrol_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNcontrol_terminal(s)
	}
}

func (s *Ncontrol_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNcontrol_terminal(s)
	}
}

func (p *VerilogParser) Ncontrol_terminal() (localctx INcontrol_terminalContext) {
	this := p
	_ = this

	localctx = NewNcontrol_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, VerilogParserRULE_ncontrol_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2646)
		p.expression(0)
	}

	return localctx
}

// IOutput_terminalContext is an interface to support dynamic dispatch.
type IOutput_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_terminalContext differentiates from other interfaces.
	IsOutput_terminalContext()
}

type Output_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_terminalContext() *Output_terminalContext {
	var p = new(Output_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_terminal
	return p
}

func (*Output_terminalContext) IsOutput_terminalContext() {}

func NewOutput_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_terminalContext {
	var p = new(Output_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_terminal

	return p
}

func (s *Output_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_terminalContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Output_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterOutput_terminal(s)
	}
}

func (s *Output_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitOutput_terminal(s)
	}
}

func (p *VerilogParser) Output_terminal() (localctx IOutput_terminalContext) {
	this := p
	_ = this

	localctx = NewOutput_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, VerilogParserRULE_output_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2648)
		p.Net_lvalue()
	}

	return localctx
}

// IPcontrol_terminalContext is an interface to support dynamic dispatch.
type IPcontrol_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPcontrol_terminalContext differentiates from other interfaces.
	IsPcontrol_terminalContext()
}

type Pcontrol_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPcontrol_terminalContext() *Pcontrol_terminalContext {
	var p = new(Pcontrol_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pcontrol_terminal
	return p
}

func (*Pcontrol_terminalContext) IsPcontrol_terminalContext() {}

func NewPcontrol_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pcontrol_terminalContext {
	var p = new(Pcontrol_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pcontrol_terminal

	return p
}

func (s *Pcontrol_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Pcontrol_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Pcontrol_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pcontrol_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pcontrol_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPcontrol_terminal(s)
	}
}

func (s *Pcontrol_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPcontrol_terminal(s)
	}
}

func (p *VerilogParser) Pcontrol_terminal() (localctx IPcontrol_terminalContext) {
	this := p
	_ = this

	localctx = NewPcontrol_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, VerilogParserRULE_pcontrol_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2650)
		p.expression(0)
	}

	return localctx
}

// ICmos_switchtypeContext is an interface to support dynamic dispatch.
type ICmos_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmos_switchtypeContext differentiates from other interfaces.
	IsCmos_switchtypeContext()
}

type Cmos_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmos_switchtypeContext() *Cmos_switchtypeContext {
	var p = new(Cmos_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_cmos_switchtype
	return p
}

func (*Cmos_switchtypeContext) IsCmos_switchtypeContext() {}

func NewCmos_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmos_switchtypeContext {
	var p = new(Cmos_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_cmos_switchtype

	return p
}

func (s *Cmos_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmos_switchtypeContext) CMOS() antlr.TerminalNode {
	return s.GetToken(VerilogParserCMOS, 0)
}

func (s *Cmos_switchtypeContext) RCMOS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRCMOS, 0)
}

func (s *Cmos_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmos_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmos_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCmos_switchtype(s)
	}
}

func (s *Cmos_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCmos_switchtype(s)
	}
}

func (p *VerilogParser) Cmos_switchtype() (localctx ICmos_switchtypeContext) {
	this := p
	_ = this

	localctx = NewCmos_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, VerilogParserRULE_cmos_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2652)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserCMOS || _la == VerilogParserRCMOS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IEnable_gatetypeContext is an interface to support dynamic dispatch.
type IEnable_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_gatetypeContext differentiates from other interfaces.
	IsEnable_gatetypeContext()
}

type Enable_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_gatetypeContext() *Enable_gatetypeContext {
	var p = new(Enable_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_enable_gatetype
	return p
}

func (*Enable_gatetypeContext) IsEnable_gatetypeContext() {}

func NewEnable_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_gatetypeContext {
	var p = new(Enable_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_enable_gatetype

	return p
}

func (s *Enable_gatetypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_gatetypeContext) BUFIF0() antlr.TerminalNode {
	return s.GetToken(VerilogParserBUFIF0, 0)
}

func (s *Enable_gatetypeContext) BUFIF1() antlr.TerminalNode {
	return s.GetToken(VerilogParserBUFIF1, 0)
}

func (s *Enable_gatetypeContext) NOTIF0() antlr.TerminalNode {
	return s.GetToken(VerilogParserNOTIF0, 0)
}

func (s *Enable_gatetypeContext) NOTIF1() antlr.TerminalNode {
	return s.GetToken(VerilogParserNOTIF1, 0)
}

func (s *Enable_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEnable_gatetype(s)
	}
}

func (s *Enable_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEnable_gatetype(s)
	}
}

func (p *VerilogParser) Enable_gatetype() (localctx IEnable_gatetypeContext) {
	this := p
	_ = this

	localctx = NewEnable_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, VerilogParserRULE_enable_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2654)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserBUFIF0 || _la == VerilogParserBUFIF1 || _la == VerilogParserNOTIF0 || _la == VerilogParserNOTIF1) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMos_switchtypeContext is an interface to support dynamic dispatch.
type IMos_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMos_switchtypeContext differentiates from other interfaces.
	IsMos_switchtypeContext()
}

type Mos_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMos_switchtypeContext() *Mos_switchtypeContext {
	var p = new(Mos_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_mos_switchtype
	return p
}

func (*Mos_switchtypeContext) IsMos_switchtypeContext() {}

func NewMos_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mos_switchtypeContext {
	var p = new(Mos_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_mos_switchtype

	return p
}

func (s *Mos_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Mos_switchtypeContext) NMOS() antlr.TerminalNode {
	return s.GetToken(VerilogParserNMOS, 0)
}

func (s *Mos_switchtypeContext) PMOS() antlr.TerminalNode {
	return s.GetToken(VerilogParserPMOS, 0)
}

func (s *Mos_switchtypeContext) RNMOS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRNMOS, 0)
}

func (s *Mos_switchtypeContext) RPMOS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRPMOS, 0)
}

func (s *Mos_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mos_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mos_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMos_switchtype(s)
	}
}

func (s *Mos_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMos_switchtype(s)
	}
}

func (p *VerilogParser) Mos_switchtype() (localctx IMos_switchtypeContext) {
	this := p
	_ = this

	localctx = NewMos_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, VerilogParserRULE_mos_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2656)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(VerilogParserNMOS-61))|(1<<(VerilogParserPMOS-61))|(1<<(VerilogParserRNMOS-61))|(1<<(VerilogParserRPMOS-61)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IN_input_gatetypeContext is an interface to support dynamic dispatch.
type IN_input_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_input_gatetypeContext differentiates from other interfaces.
	IsN_input_gatetypeContext()
}

type N_input_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_input_gatetypeContext() *N_input_gatetypeContext {
	var p = new(N_input_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_n_input_gatetype
	return p
}

func (*N_input_gatetypeContext) IsN_input_gatetypeContext() {}

func NewN_input_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_input_gatetypeContext {
	var p = new(N_input_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_n_input_gatetype

	return p
}

func (s *N_input_gatetypeContext) GetParser() antlr.Parser { return s.parser }

func (s *N_input_gatetypeContext) AND() antlr.TerminalNode {
	return s.GetToken(VerilogParserAND, 0)
}

func (s *N_input_gatetypeContext) NAND() antlr.TerminalNode {
	return s.GetToken(VerilogParserNAND, 0)
}

func (s *N_input_gatetypeContext) OR() antlr.TerminalNode {
	return s.GetToken(VerilogParserOR, 0)
}

func (s *N_input_gatetypeContext) NOR() antlr.TerminalNode {
	return s.GetToken(VerilogParserNOR, 0)
}

func (s *N_input_gatetypeContext) XOR() antlr.TerminalNode {
	return s.GetToken(VerilogParserXOR, 0)
}

func (s *N_input_gatetypeContext) XNOR() antlr.TerminalNode {
	return s.GetToken(VerilogParserXNOR, 0)
}

func (s *N_input_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_input_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_input_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterN_input_gatetype(s)
	}
}

func (s *N_input_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitN_input_gatetype(s)
	}
}

func (p *VerilogParser) N_input_gatetype() (localctx IN_input_gatetypeContext) {
	this := p
	_ = this

	localctx = NewN_input_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, VerilogParserRULE_n_input_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2658)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserAND || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(VerilogParserNAND-59))|(1<<(VerilogParserNOR-59))|(1<<(VerilogParserOR-59)))) != 0) || _la == VerilogParserXNOR || _la == VerilogParserXOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IN_output_gatetypeContext is an interface to support dynamic dispatch.
type IN_output_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_output_gatetypeContext differentiates from other interfaces.
	IsN_output_gatetypeContext()
}

type N_output_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_output_gatetypeContext() *N_output_gatetypeContext {
	var p = new(N_output_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_n_output_gatetype
	return p
}

func (*N_output_gatetypeContext) IsN_output_gatetypeContext() {}

func NewN_output_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_output_gatetypeContext {
	var p = new(N_output_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_n_output_gatetype

	return p
}

func (s *N_output_gatetypeContext) GetParser() antlr.Parser { return s.parser }

func (s *N_output_gatetypeContext) BUF() antlr.TerminalNode {
	return s.GetToken(VerilogParserBUF, 0)
}

func (s *N_output_gatetypeContext) NOT() antlr.TerminalNode {
	return s.GetToken(VerilogParserNOT, 0)
}

func (s *N_output_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_output_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_output_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterN_output_gatetype(s)
	}
}

func (s *N_output_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitN_output_gatetype(s)
	}
}

func (p *VerilogParser) N_output_gatetype() (localctx IN_output_gatetypeContext) {
	this := p
	_ = this

	localctx = NewN_output_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, VerilogParserRULE_n_output_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2660)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserBUF || _la == VerilogParserNOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPass_en_switchtypeContext is an interface to support dynamic dispatch.
type IPass_en_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_en_switchtypeContext differentiates from other interfaces.
	IsPass_en_switchtypeContext()
}

type Pass_en_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_en_switchtypeContext() *Pass_en_switchtypeContext {
	var p = new(Pass_en_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pass_en_switchtype
	return p
}

func (*Pass_en_switchtypeContext) IsPass_en_switchtypeContext() {}

func NewPass_en_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_en_switchtypeContext {
	var p = new(Pass_en_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pass_en_switchtype

	return p
}

func (s *Pass_en_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_en_switchtypeContext) TRANIF0() antlr.TerminalNode {
	return s.GetToken(VerilogParserTRANIF0, 0)
}

func (s *Pass_en_switchtypeContext) TRANIF1() antlr.TerminalNode {
	return s.GetToken(VerilogParserTRANIF1, 0)
}

func (s *Pass_en_switchtypeContext) RTRANIF1() antlr.TerminalNode {
	return s.GetToken(VerilogParserRTRANIF1, 0)
}

func (s *Pass_en_switchtypeContext) RTRANIF0() antlr.TerminalNode {
	return s.GetToken(VerilogParserRTRANIF0, 0)
}

func (s *Pass_en_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_en_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_en_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPass_en_switchtype(s)
	}
}

func (s *Pass_en_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPass_en_switchtype(s)
	}
}

func (p *VerilogParser) Pass_en_switchtype() (localctx IPass_en_switchtypeContext) {
	this := p
	_ = this

	localctx = NewPass_en_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, VerilogParserRULE_pass_en_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2662)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(VerilogParserRTRANIF0-88))|(1<<(VerilogParserRTRANIF1-88))|(1<<(VerilogParserTRANIF0-88))|(1<<(VerilogParserTRANIF1-88)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPass_switchtypeContext is an interface to support dynamic dispatch.
type IPass_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_switchtypeContext differentiates from other interfaces.
	IsPass_switchtypeContext()
}

type Pass_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_switchtypeContext() *Pass_switchtypeContext {
	var p = new(Pass_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pass_switchtype
	return p
}

func (*Pass_switchtypeContext) IsPass_switchtypeContext() {}

func NewPass_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_switchtypeContext {
	var p = new(Pass_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pass_switchtype

	return p
}

func (s *Pass_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_switchtypeContext) TRAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserTRAN, 0)
}

func (s *Pass_switchtypeContext) RTRAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserRTRAN, 0)
}

func (s *Pass_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPass_switchtype(s)
	}
}

func (s *Pass_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPass_switchtype(s)
	}
}

func (p *VerilogParser) Pass_switchtype() (localctx IPass_switchtypeContext) {
	this := p
	_ = this

	localctx = NewPass_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, VerilogParserRULE_pass_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2664)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserRTRAN || _la == VerilogParserTRAN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IModule_instantiationContext is an interface to support dynamic dispatch.
type IModule_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_instantiationContext differentiates from other interfaces.
	IsModule_instantiationContext()
}

type Module_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_instantiationContext() *Module_instantiationContext {
	var p = new(Module_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_instantiation
	return p
}

func (*Module_instantiationContext) IsModule_instantiationContext() {}

func NewModule_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_instantiationContext {
	var p = new(Module_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_instantiation

	return p
}

func (s *Module_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_instantiationContext) Module_identifier() IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Module_instantiationContext) AllModule_instance() []IModule_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_instanceContext)(nil)).Elem())
	var tst = make([]IModule_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_instanceContext)
		}
	}

	return tst
}

func (s *Module_instantiationContext) Module_instance(i int) IModule_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_instanceContext)
}

func (s *Module_instantiationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Module_instantiationContext) Parameter_value_assignment() IParameter_value_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_value_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_value_assignmentContext)
}

func (s *Module_instantiationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Module_instantiationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Module_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_instantiation(s)
	}
}

func (s *Module_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_instantiation(s)
	}
}

func (p *VerilogParser) Module_instantiation() (localctx IModule_instantiationContext) {
	this := p
	_ = this

	localctx = NewModule_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, VerilogParserRULE_module_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2666)
		p.Module_identifier()
	}
	p.SetState(2668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserHASH {
		{
			p.SetState(2667)
			p.Parameter_value_assignment()
		}

	}
	{
		p.SetState(2670)
		p.Module_instance()
	}
	p.SetState(2675)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(2671)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(2672)
			p.Module_instance()
		}

		p.SetState(2677)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2678)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IParameter_value_assignmentContext is an interface to support dynamic dispatch.
type IParameter_value_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_value_assignmentContext differentiates from other interfaces.
	IsParameter_value_assignmentContext()
}

type Parameter_value_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_value_assignmentContext() *Parameter_value_assignmentContext {
	var p = new(Parameter_value_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_value_assignment
	return p
}

func (*Parameter_value_assignmentContext) IsParameter_value_assignmentContext() {}

func NewParameter_value_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_value_assignmentContext {
	var p = new(Parameter_value_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_value_assignment

	return p
}

func (s *Parameter_value_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_value_assignmentContext) HASH() antlr.TerminalNode {
	return s.GetToken(VerilogParserHASH, 0)
}

func (s *Parameter_value_assignmentContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Parameter_value_assignmentContext) List_of_parameter_assignments() IList_of_parameter_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_parameter_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_parameter_assignmentsContext)
}

func (s *Parameter_value_assignmentContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Parameter_value_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_value_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_value_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParameter_value_assignment(s)
	}
}

func (s *Parameter_value_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParameter_value_assignment(s)
	}
}

func (p *VerilogParser) Parameter_value_assignment() (localctx IParameter_value_assignmentContext) {
	this := p
	_ = this

	localctx = NewParameter_value_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, VerilogParserRULE_parameter_value_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2680)
		p.Match(VerilogParserHASH)
	}
	{
		p.SetState(2681)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(2682)
		p.List_of_parameter_assignments()
	}
	{
		p.SetState(2683)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IList_of_parameter_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_parameter_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_parameter_assignmentsContext differentiates from other interfaces.
	IsList_of_parameter_assignmentsContext()
}

type List_of_parameter_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_parameter_assignmentsContext() *List_of_parameter_assignmentsContext {
	var p = new(List_of_parameter_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_parameter_assignments
	return p
}

func (*List_of_parameter_assignmentsContext) IsList_of_parameter_assignmentsContext() {}

func NewList_of_parameter_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_parameter_assignmentsContext {
	var p = new(List_of_parameter_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_parameter_assignments

	return p
}

func (s *List_of_parameter_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_parameter_assignmentsContext) AllOrdered_parameter_assignment() []IOrdered_parameter_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrdered_parameter_assignmentContext)(nil)).Elem())
	var tst = make([]IOrdered_parameter_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrdered_parameter_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_parameter_assignmentsContext) Ordered_parameter_assignment(i int) IOrdered_parameter_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrdered_parameter_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrdered_parameter_assignmentContext)
}

func (s *List_of_parameter_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_parameter_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_parameter_assignmentsContext) AllNamed_parameter_assignment() []INamed_parameter_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamed_parameter_assignmentContext)(nil)).Elem())
	var tst = make([]INamed_parameter_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamed_parameter_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_parameter_assignmentsContext) Named_parameter_assignment(i int) INamed_parameter_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_parameter_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamed_parameter_assignmentContext)
}

func (s *List_of_parameter_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_parameter_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_parameter_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_parameter_assignments(s)
	}
}

func (s *List_of_parameter_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_parameter_assignments(s)
	}
}

func (p *VerilogParser) List_of_parameter_assignments() (localctx IList_of_parameter_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_parameter_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, VerilogParserRULE_list_of_parameter_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2701)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserDOLLAR_BITSTOREAL, VerilogParserDOLLAR_ITOR, VerilogParserDOLLAR_SIGNED, VerilogParserDOLLAR_REALTOBITS, VerilogParserDOLLAR_RTOI, VerilogParserDOLLAR_UNSIGNED, VerilogParserDOLLAR_RANDOM, VerilogParserDOLLAR_DIST_ERLANG, VerilogParserDOLLAR_DIST_NORMAL, VerilogParserDOLLAR_DIST_T, VerilogParserDOLLAR_DIST_CHI_SQUARE, VerilogParserDOLLAR_DIST_EXPONENTIAL, VerilogParserDOLLAR_DIST_POISSON, VerilogParserDOLLAR_DIST_UNIFORM, VerilogParserDOLLAR_CLOG2, VerilogParserDOLLAR_LN, VerilogParserDOLLAR_LOG10, VerilogParserDOLLAR_EXP, VerilogParserDOLLAR_SQRT, VerilogParserDOLLAR_POW, VerilogParserDOLLAR_FLOOR, VerilogParserDOLLAR_CEIL, VerilogParserDOLLAR_SIN, VerilogParserDOLLAR_COS, VerilogParserDOLLAR_TAN, VerilogParserDOLLAR_ASIN, VerilogParserDOLLAR_ACOS, VerilogParserDOLLAR_ATAN, VerilogParserDOLLAR_ATAN2, VerilogParserDOLLAR_HYPOT, VerilogParserDOLLAR_SINH, VerilogParserDOLLAR_COSH, VerilogParserDOLLAR_TANH, VerilogParserDOLLAR_ASINH, VerilogParserDOLLAR_ACOSH, VerilogParserDOLLAR_ATANH, VerilogParserREAL_NUMBER, VerilogParserDECIMAL_NUMBER, VerilogParserBINARY_NUMBER, VerilogParserOCTAL_NUMBER, VerilogParserHEX_NUMBER, VerilogParserSTRING, VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER, VerilogParserSYSTEM_TF_IDENTIFIER, VerilogParserLEFT_PARENTHESIS, VerilogParserLEFT_BRACE, VerilogParserPLUS, VerilogParserMINUS, VerilogParserEXCLAMATION_MARK, VerilogParserTILDE, VerilogParserAMPERSAND, VerilogParserTILDE_AMPERSAND, VerilogParserVERTICAL_BAR, VerilogParserTILDE_VERTICAL_BAR, VerilogParserCARET, VerilogParserTILDE_CARET, VerilogParserCARET_TILDE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2685)
			p.Ordered_parameter_assignment()
		}
		p.SetState(2690)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(2686)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2687)
				p.Ordered_parameter_assignment()
			}

			p.SetState(2692)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case VerilogParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2693)
			p.Named_parameter_assignment()
		}
		p.SetState(2698)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(2694)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2695)
				p.Named_parameter_assignment()
			}

			p.SetState(2700)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOrdered_parameter_assignmentContext is an interface to support dynamic dispatch.
type IOrdered_parameter_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrdered_parameter_assignmentContext differentiates from other interfaces.
	IsOrdered_parameter_assignmentContext()
}

type Ordered_parameter_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdered_parameter_assignmentContext() *Ordered_parameter_assignmentContext {
	var p = new(Ordered_parameter_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_ordered_parameter_assignment
	return p
}

func (*Ordered_parameter_assignmentContext) IsOrdered_parameter_assignmentContext() {}

func NewOrdered_parameter_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordered_parameter_assignmentContext {
	var p = new(Ordered_parameter_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_ordered_parameter_assignment

	return p
}

func (s *Ordered_parameter_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordered_parameter_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ordered_parameter_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordered_parameter_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ordered_parameter_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterOrdered_parameter_assignment(s)
	}
}

func (s *Ordered_parameter_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitOrdered_parameter_assignment(s)
	}
}

func (p *VerilogParser) Ordered_parameter_assignment() (localctx IOrdered_parameter_assignmentContext) {
	this := p
	_ = this

	localctx = NewOrdered_parameter_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, VerilogParserRULE_ordered_parameter_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2703)
		p.expression(0)
	}

	return localctx
}

// INamed_parameter_assignmentContext is an interface to support dynamic dispatch.
type INamed_parameter_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamed_parameter_assignmentContext differentiates from other interfaces.
	IsNamed_parameter_assignmentContext()
}

type Named_parameter_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_parameter_assignmentContext() *Named_parameter_assignmentContext {
	var p = new(Named_parameter_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_named_parameter_assignment
	return p
}

func (*Named_parameter_assignmentContext) IsNamed_parameter_assignmentContext() {}

func NewNamed_parameter_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_parameter_assignmentContext {
	var p = new(Named_parameter_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_named_parameter_assignment

	return p
}

func (s *Named_parameter_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_parameter_assignmentContext) DOT() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOT, 0)
}

func (s *Named_parameter_assignmentContext) Parameter_identifier() IParameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_identifierContext)
}

func (s *Named_parameter_assignmentContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Named_parameter_assignmentContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Named_parameter_assignmentContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Named_parameter_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_parameter_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_parameter_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNamed_parameter_assignment(s)
	}
}

func (s *Named_parameter_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNamed_parameter_assignment(s)
	}
}

func (p *VerilogParser) Named_parameter_assignment() (localctx INamed_parameter_assignmentContext) {
	this := p
	_ = this

	localctx = NewNamed_parameter_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, VerilogParserRULE_named_parameter_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2705)
		p.Match(VerilogParserDOT)
	}
	{
		p.SetState(2706)
		p.Parameter_identifier()
	}
	{
		p.SetState(2707)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	p.SetState(2709)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(VerilogParserDOLLAR_BITSTOREAL-209))|(1<<(VerilogParserDOLLAR_ITOR-209))|(1<<(VerilogParserDOLLAR_SIGNED-209))|(1<<(VerilogParserDOLLAR_REALTOBITS-209))|(1<<(VerilogParserDOLLAR_RTOI-209))|(1<<(VerilogParserDOLLAR_UNSIGNED-209))|(1<<(VerilogParserDOLLAR_RANDOM-209))|(1<<(VerilogParserDOLLAR_DIST_ERLANG-209))|(1<<(VerilogParserDOLLAR_DIST_NORMAL-209))|(1<<(VerilogParserDOLLAR_DIST_T-209))|(1<<(VerilogParserDOLLAR_DIST_CHI_SQUARE-209))|(1<<(VerilogParserDOLLAR_DIST_EXPONENTIAL-209))|(1<<(VerilogParserDOLLAR_DIST_POISSON-209))|(1<<(VerilogParserDOLLAR_DIST_UNIFORM-209))|(1<<(VerilogParserDOLLAR_CLOG2-209))|(1<<(VerilogParserDOLLAR_LN-209))|(1<<(VerilogParserDOLLAR_LOG10-209))|(1<<(VerilogParserDOLLAR_EXP-209))|(1<<(VerilogParserDOLLAR_SQRT-209))|(1<<(VerilogParserDOLLAR_POW-209))|(1<<(VerilogParserDOLLAR_FLOOR-209))|(1<<(VerilogParserDOLLAR_CEIL-209))|(1<<(VerilogParserDOLLAR_SIN-209))|(1<<(VerilogParserDOLLAR_COS-209))|(1<<(VerilogParserDOLLAR_TAN-209))|(1<<(VerilogParserDOLLAR_ASIN-209))|(1<<(VerilogParserDOLLAR_ACOS-209))|(1<<(VerilogParserDOLLAR_ATAN-209))|(1<<(VerilogParserDOLLAR_ATAN2-209))|(1<<(VerilogParserDOLLAR_HYPOT-209)))) != 0) || (((_la-241)&-(0x1f+1)) == 0 && ((1<<uint((_la-241)))&((1<<(VerilogParserDOLLAR_SINH-241))|(1<<(VerilogParserDOLLAR_COSH-241))|(1<<(VerilogParserDOLLAR_TANH-241))|(1<<(VerilogParserDOLLAR_ASINH-241))|(1<<(VerilogParserDOLLAR_ACOSH-241))|(1<<(VerilogParserDOLLAR_ATANH-241)))) != 0) || (((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282))|(1<<(VerilogParserSTRING-282))|(1<<(VerilogParserESCAPED_IDENTIFIER-282))|(1<<(VerilogParserSIMPLE_IDENTIFIER-282))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-282))|(1<<(VerilogParserLEFT_PARENTHESIS-282))|(1<<(VerilogParserLEFT_BRACE-282))|(1<<(VerilogParserPLUS-282))|(1<<(VerilogParserMINUS-282))|(1<<(VerilogParserEXCLAMATION_MARK-282))|(1<<(VerilogParserTILDE-282))|(1<<(VerilogParserAMPERSAND-282))|(1<<(VerilogParserTILDE_AMPERSAND-282))|(1<<(VerilogParserVERTICAL_BAR-282))|(1<<(VerilogParserTILDE_VERTICAL_BAR-282))|(1<<(VerilogParserCARET-282))|(1<<(VerilogParserTILDE_CARET-282))|(1<<(VerilogParserCARET_TILDE-282)))) != 0) {
		{
			p.SetState(2708)
			p.Mintypmax_expression()
		}

	}
	{
		p.SetState(2711)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IModule_instanceContext is an interface to support dynamic dispatch.
type IModule_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_instanceContext differentiates from other interfaces.
	IsModule_instanceContext()
}

type Module_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_instanceContext() *Module_instanceContext {
	var p = new(Module_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_instance
	return p
}

func (*Module_instanceContext) IsModule_instanceContext() {}

func NewModule_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_instanceContext {
	var p = new(Module_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_instance

	return p
}

func (s *Module_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_instanceContext) Name_of_module_instance() IName_of_module_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_module_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_module_instanceContext)
}

func (s *Module_instanceContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Module_instanceContext) List_of_port_connections() IList_of_port_connectionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_connectionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_connectionsContext)
}

func (s *Module_instanceContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Module_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_instance(s)
	}
}

func (s *Module_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_instance(s)
	}
}

func (p *VerilogParser) Module_instance() (localctx IModule_instanceContext) {
	this := p
	_ = this

	localctx = NewModule_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, VerilogParserRULE_module_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2713)
		p.Name_of_module_instance()
	}
	{
		p.SetState(2714)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(2715)
		p.List_of_port_connections()
	}
	{
		p.SetState(2716)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IName_of_module_instanceContext is an interface to support dynamic dispatch.
type IName_of_module_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_of_module_instanceContext differentiates from other interfaces.
	IsName_of_module_instanceContext()
}

type Name_of_module_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_of_module_instanceContext() *Name_of_module_instanceContext {
	var p = new(Name_of_module_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_name_of_module_instance
	return p
}

func (*Name_of_module_instanceContext) IsName_of_module_instanceContext() {}

func NewName_of_module_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_of_module_instanceContext {
	var p = new(Name_of_module_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_name_of_module_instance

	return p
}

func (s *Name_of_module_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_of_module_instanceContext) Module_instance_identifier() IModule_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_instance_identifierContext)
}

func (s *Name_of_module_instanceContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Name_of_module_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_of_module_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_of_module_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterName_of_module_instance(s)
	}
}

func (s *Name_of_module_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitName_of_module_instance(s)
	}
}

func (p *VerilogParser) Name_of_module_instance() (localctx IName_of_module_instanceContext) {
	this := p
	_ = this

	localctx = NewName_of_module_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, VerilogParserRULE_name_of_module_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2718)
		p.Module_instance_identifier()
	}
	p.SetState(2720)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_BRACKET {
		{
			p.SetState(2719)
			p.Range_()
		}

	}

	return localctx
}

// IList_of_port_connectionsContext is an interface to support dynamic dispatch.
type IList_of_port_connectionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_connectionsContext differentiates from other interfaces.
	IsList_of_port_connectionsContext()
}

type List_of_port_connectionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_connectionsContext() *List_of_port_connectionsContext {
	var p = new(List_of_port_connectionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_port_connections
	return p
}

func (*List_of_port_connectionsContext) IsList_of_port_connectionsContext() {}

func NewList_of_port_connectionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_connectionsContext {
	var p = new(List_of_port_connectionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_port_connections

	return p
}

func (s *List_of_port_connectionsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_connectionsContext) AllOrdered_port_connection() []IOrdered_port_connectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrdered_port_connectionContext)(nil)).Elem())
	var tst = make([]IOrdered_port_connectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrdered_port_connectionContext)
		}
	}

	return tst
}

func (s *List_of_port_connectionsContext) Ordered_port_connection(i int) IOrdered_port_connectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrdered_port_connectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrdered_port_connectionContext)
}

func (s *List_of_port_connectionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_port_connectionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_port_connectionsContext) AllNamed_port_connection() []INamed_port_connectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamed_port_connectionContext)(nil)).Elem())
	var tst = make([]INamed_port_connectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamed_port_connectionContext)
		}
	}

	return tst
}

func (s *List_of_port_connectionsContext) Named_port_connection(i int) INamed_port_connectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_port_connectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamed_port_connectionContext)
}

func (s *List_of_port_connectionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_connectionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_connectionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_port_connections(s)
	}
}

func (s *List_of_port_connectionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_port_connections(s)
	}
}

func (p *VerilogParser) List_of_port_connections() (localctx IList_of_port_connectionsContext) {
	this := p
	_ = this

	localctx = NewList_of_port_connectionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, VerilogParserRULE_list_of_port_connections)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2738)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 264, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2722)
			p.Ordered_port_connection()
		}
		p.SetState(2727)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(2723)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2724)
				p.Ordered_port_connection()
			}

			p.SetState(2729)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2730)
			p.Named_port_connection()
		}
		p.SetState(2735)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(2731)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2732)
				p.Named_port_connection()
			}

			p.SetState(2737)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IOrdered_port_connectionContext is an interface to support dynamic dispatch.
type IOrdered_port_connectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrdered_port_connectionContext differentiates from other interfaces.
	IsOrdered_port_connectionContext()
}

type Ordered_port_connectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdered_port_connectionContext() *Ordered_port_connectionContext {
	var p = new(Ordered_port_connectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_ordered_port_connection
	return p
}

func (*Ordered_port_connectionContext) IsOrdered_port_connectionContext() {}

func NewOrdered_port_connectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordered_port_connectionContext {
	var p = new(Ordered_port_connectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_ordered_port_connection

	return p
}

func (s *Ordered_port_connectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordered_port_connectionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Ordered_port_connectionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Ordered_port_connectionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ordered_port_connectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordered_port_connectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ordered_port_connectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterOrdered_port_connection(s)
	}
}

func (s *Ordered_port_connectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitOrdered_port_connection(s)
	}
}

func (p *VerilogParser) Ordered_port_connection() (localctx IOrdered_port_connectionContext) {
	this := p
	_ = this

	localctx = NewOrdered_port_connectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, VerilogParserRULE_ordered_port_connection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2743)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 265, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2740)
				p.Attribute_instance()
			}

		}
		p.SetState(2745)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 265, p.GetParserRuleContext())
	}
	p.SetState(2747)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(VerilogParserDOLLAR_BITSTOREAL-209))|(1<<(VerilogParserDOLLAR_ITOR-209))|(1<<(VerilogParserDOLLAR_SIGNED-209))|(1<<(VerilogParserDOLLAR_REALTOBITS-209))|(1<<(VerilogParserDOLLAR_RTOI-209))|(1<<(VerilogParserDOLLAR_UNSIGNED-209))|(1<<(VerilogParserDOLLAR_RANDOM-209))|(1<<(VerilogParserDOLLAR_DIST_ERLANG-209))|(1<<(VerilogParserDOLLAR_DIST_NORMAL-209))|(1<<(VerilogParserDOLLAR_DIST_T-209))|(1<<(VerilogParserDOLLAR_DIST_CHI_SQUARE-209))|(1<<(VerilogParserDOLLAR_DIST_EXPONENTIAL-209))|(1<<(VerilogParserDOLLAR_DIST_POISSON-209))|(1<<(VerilogParserDOLLAR_DIST_UNIFORM-209))|(1<<(VerilogParserDOLLAR_CLOG2-209))|(1<<(VerilogParserDOLLAR_LN-209))|(1<<(VerilogParserDOLLAR_LOG10-209))|(1<<(VerilogParserDOLLAR_EXP-209))|(1<<(VerilogParserDOLLAR_SQRT-209))|(1<<(VerilogParserDOLLAR_POW-209))|(1<<(VerilogParserDOLLAR_FLOOR-209))|(1<<(VerilogParserDOLLAR_CEIL-209))|(1<<(VerilogParserDOLLAR_SIN-209))|(1<<(VerilogParserDOLLAR_COS-209))|(1<<(VerilogParserDOLLAR_TAN-209))|(1<<(VerilogParserDOLLAR_ASIN-209))|(1<<(VerilogParserDOLLAR_ACOS-209))|(1<<(VerilogParserDOLLAR_ATAN-209))|(1<<(VerilogParserDOLLAR_ATAN2-209))|(1<<(VerilogParserDOLLAR_HYPOT-209)))) != 0) || (((_la-241)&-(0x1f+1)) == 0 && ((1<<uint((_la-241)))&((1<<(VerilogParserDOLLAR_SINH-241))|(1<<(VerilogParserDOLLAR_COSH-241))|(1<<(VerilogParserDOLLAR_TANH-241))|(1<<(VerilogParserDOLLAR_ASINH-241))|(1<<(VerilogParserDOLLAR_ACOSH-241))|(1<<(VerilogParserDOLLAR_ATANH-241)))) != 0) || (((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282))|(1<<(VerilogParserSTRING-282))|(1<<(VerilogParserESCAPED_IDENTIFIER-282))|(1<<(VerilogParserSIMPLE_IDENTIFIER-282))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-282))|(1<<(VerilogParserLEFT_PARENTHESIS-282))|(1<<(VerilogParserLEFT_BRACE-282))|(1<<(VerilogParserPLUS-282))|(1<<(VerilogParserMINUS-282))|(1<<(VerilogParserEXCLAMATION_MARK-282))|(1<<(VerilogParserTILDE-282))|(1<<(VerilogParserAMPERSAND-282))|(1<<(VerilogParserTILDE_AMPERSAND-282))|(1<<(VerilogParserVERTICAL_BAR-282))|(1<<(VerilogParserTILDE_VERTICAL_BAR-282))|(1<<(VerilogParserCARET-282))|(1<<(VerilogParserTILDE_CARET-282))|(1<<(VerilogParserCARET_TILDE-282)))) != 0) {
		{
			p.SetState(2746)
			p.expression(0)
		}

	}

	return localctx
}

// INamed_port_connectionContext is an interface to support dynamic dispatch.
type INamed_port_connectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamed_port_connectionContext differentiates from other interfaces.
	IsNamed_port_connectionContext()
}

type Named_port_connectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_port_connectionContext() *Named_port_connectionContext {
	var p = new(Named_port_connectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_named_port_connection
	return p
}

func (*Named_port_connectionContext) IsNamed_port_connectionContext() {}

func NewNamed_port_connectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_port_connectionContext {
	var p = new(Named_port_connectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_named_port_connection

	return p
}

func (s *Named_port_connectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_port_connectionContext) DOT() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOT, 0)
}

func (s *Named_port_connectionContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *Named_port_connectionContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Named_port_connectionContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Named_port_connectionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Named_port_connectionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Named_port_connectionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Named_port_connectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_port_connectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_port_connectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNamed_port_connection(s)
	}
}

func (s *Named_port_connectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNamed_port_connection(s)
	}
}

func (p *VerilogParser) Named_port_connection() (localctx INamed_port_connectionContext) {
	this := p
	_ = this

	localctx = NewNamed_port_connectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, VerilogParserRULE_named_port_connection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2752)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserLEFT_PARENTHESIS {
		{
			p.SetState(2749)
			p.Attribute_instance()
		}

		p.SetState(2754)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2755)
		p.Match(VerilogParserDOT)
	}
	{
		p.SetState(2756)
		p.Port_identifier()
	}
	{
		p.SetState(2757)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	p.SetState(2759)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(VerilogParserDOLLAR_BITSTOREAL-209))|(1<<(VerilogParserDOLLAR_ITOR-209))|(1<<(VerilogParserDOLLAR_SIGNED-209))|(1<<(VerilogParserDOLLAR_REALTOBITS-209))|(1<<(VerilogParserDOLLAR_RTOI-209))|(1<<(VerilogParserDOLLAR_UNSIGNED-209))|(1<<(VerilogParserDOLLAR_RANDOM-209))|(1<<(VerilogParserDOLLAR_DIST_ERLANG-209))|(1<<(VerilogParserDOLLAR_DIST_NORMAL-209))|(1<<(VerilogParserDOLLAR_DIST_T-209))|(1<<(VerilogParserDOLLAR_DIST_CHI_SQUARE-209))|(1<<(VerilogParserDOLLAR_DIST_EXPONENTIAL-209))|(1<<(VerilogParserDOLLAR_DIST_POISSON-209))|(1<<(VerilogParserDOLLAR_DIST_UNIFORM-209))|(1<<(VerilogParserDOLLAR_CLOG2-209))|(1<<(VerilogParserDOLLAR_LN-209))|(1<<(VerilogParserDOLLAR_LOG10-209))|(1<<(VerilogParserDOLLAR_EXP-209))|(1<<(VerilogParserDOLLAR_SQRT-209))|(1<<(VerilogParserDOLLAR_POW-209))|(1<<(VerilogParserDOLLAR_FLOOR-209))|(1<<(VerilogParserDOLLAR_CEIL-209))|(1<<(VerilogParserDOLLAR_SIN-209))|(1<<(VerilogParserDOLLAR_COS-209))|(1<<(VerilogParserDOLLAR_TAN-209))|(1<<(VerilogParserDOLLAR_ASIN-209))|(1<<(VerilogParserDOLLAR_ACOS-209))|(1<<(VerilogParserDOLLAR_ATAN-209))|(1<<(VerilogParserDOLLAR_ATAN2-209))|(1<<(VerilogParserDOLLAR_HYPOT-209)))) != 0) || (((_la-241)&-(0x1f+1)) == 0 && ((1<<uint((_la-241)))&((1<<(VerilogParserDOLLAR_SINH-241))|(1<<(VerilogParserDOLLAR_COSH-241))|(1<<(VerilogParserDOLLAR_TANH-241))|(1<<(VerilogParserDOLLAR_ASINH-241))|(1<<(VerilogParserDOLLAR_ACOSH-241))|(1<<(VerilogParserDOLLAR_ATANH-241)))) != 0) || (((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282))|(1<<(VerilogParserSTRING-282))|(1<<(VerilogParserESCAPED_IDENTIFIER-282))|(1<<(VerilogParserSIMPLE_IDENTIFIER-282))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-282))|(1<<(VerilogParserLEFT_PARENTHESIS-282))|(1<<(VerilogParserLEFT_BRACE-282))|(1<<(VerilogParserPLUS-282))|(1<<(VerilogParserMINUS-282))|(1<<(VerilogParserEXCLAMATION_MARK-282))|(1<<(VerilogParserTILDE-282))|(1<<(VerilogParserAMPERSAND-282))|(1<<(VerilogParserTILDE_AMPERSAND-282))|(1<<(VerilogParserVERTICAL_BAR-282))|(1<<(VerilogParserTILDE_VERTICAL_BAR-282))|(1<<(VerilogParserCARET-282))|(1<<(VerilogParserTILDE_CARET-282))|(1<<(VerilogParserCARET_TILDE-282)))) != 0) {
		{
			p.SetState(2758)
			p.expression(0)
		}

	}
	{
		p.SetState(2761)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IGenerate_regionContext is an interface to support dynamic dispatch.
type IGenerate_regionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_regionContext differentiates from other interfaces.
	IsGenerate_regionContext()
}

type Generate_regionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_regionContext() *Generate_regionContext {
	var p = new(Generate_regionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_region
	return p
}

func (*Generate_regionContext) IsGenerate_regionContext() {}

func NewGenerate_regionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_regionContext {
	var p = new(Generate_regionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_region

	return p
}

func (s *Generate_regionContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_regionContext) GENERATE() antlr.TerminalNode {
	return s.GetToken(VerilogParserGENERATE, 0)
}

func (s *Generate_regionContext) ENDGENERATE() antlr.TerminalNode {
	return s.GetToken(VerilogParserENDGENERATE, 0)
}

func (s *Generate_regionContext) AllModule_or_generate_item() []IModule_or_generate_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_or_generate_itemContext)(nil)).Elem())
	var tst = make([]IModule_or_generate_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_or_generate_itemContext)
		}
	}

	return tst
}

func (s *Generate_regionContext) Module_or_generate_item(i int) IModule_or_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_itemContext)
}

func (s *Generate_regionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_regionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_regionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenerate_region(s)
	}
}

func (s *Generate_regionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenerate_region(s)
	}
}

func (p *VerilogParser) Generate_region() (localctx IGenerate_regionContext) {
	this := p
	_ = this

	localctx = NewGenerate_regionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, VerilogParserRULE_generate_region)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2763)
		p.Match(VerilogParserGENERATE)
	}
	p.SetState(2767)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserALWAYS)|(1<<VerilogParserAND)|(1<<VerilogParserASSIGN)|(1<<VerilogParserBUF)|(1<<VerilogParserBUFIF0)|(1<<VerilogParserBUFIF1)|(1<<VerilogParserCMOS)|(1<<VerilogParserDEFAULT)|(1<<VerilogParserDEFPARAM))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(VerilogParserEVENT-32))|(1<<(VerilogParserFOR-32))|(1<<(VerilogParserFUNCTION-32))|(1<<(VerilogParserGENVAR-32))|(1<<(VerilogParserIF-32))|(1<<(VerilogParserINITIAL-32))|(1<<(VerilogParserINTEGER-32))|(1<<(VerilogParserLOCALPARAM-32))|(1<<(VerilogParserNAND-32))|(1<<(VerilogParserNMOS-32))|(1<<(VerilogParserNOR-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(VerilogParserNOT-64))|(1<<(VerilogParserNOTIF0-64))|(1<<(VerilogParserNOTIF1-64))|(1<<(VerilogParserOR-64))|(1<<(VerilogParserPMOS-64))|(1<<(VerilogParserPULLDOWN-64))|(1<<(VerilogParserPULLUP-64))|(1<<(VerilogParserRCMOS-64))|(1<<(VerilogParserREAL-64))|(1<<(VerilogParserREALTIME-64))|(1<<(VerilogParserREG-64))|(1<<(VerilogParserRNMOS-64))|(1<<(VerilogParserRPMOS-64))|(1<<(VerilogParserRTRAN-64))|(1<<(VerilogParserRTRANIF0-64))|(1<<(VerilogParserRTRANIF1-64)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(VerilogParserSUPPLY0-98))|(1<<(VerilogParserSUPPLY1-98))|(1<<(VerilogParserTASK-98))|(1<<(VerilogParserTIME-98))|(1<<(VerilogParserTRAN-98))|(1<<(VerilogParserTRANIF0-98))|(1<<(VerilogParserTRANIF1-98))|(1<<(VerilogParserTRI-98))|(1<<(VerilogParserTRI0-98))|(1<<(VerilogParserTRI1-98))|(1<<(VerilogParserTRIAND-98))|(1<<(VerilogParserTRIOR-98))|(1<<(VerilogParserTRIREG-98))|(1<<(VerilogParserWAND-98))|(1<<(VerilogParserWIRE-98))|(1<<(VerilogParserWOR-98))|(1<<(VerilogParserXNOR-98))|(1<<(VerilogParserXOR-98)))) != 0) || (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(VerilogParserDOLLAR_BITSTOREAL-209))|(1<<(VerilogParserDOLLAR_ITOR-209))|(1<<(VerilogParserDOLLAR_SIGNED-209))|(1<<(VerilogParserDOLLAR_REALTOBITS-209))|(1<<(VerilogParserDOLLAR_RTOI-209))|(1<<(VerilogParserDOLLAR_UNSIGNED-209))|(1<<(VerilogParserDOLLAR_RANDOM-209))|(1<<(VerilogParserDOLLAR_DIST_ERLANG-209))|(1<<(VerilogParserDOLLAR_DIST_NORMAL-209))|(1<<(VerilogParserDOLLAR_DIST_T-209))|(1<<(VerilogParserDOLLAR_DIST_CHI_SQUARE-209))|(1<<(VerilogParserDOLLAR_DIST_EXPONENTIAL-209))|(1<<(VerilogParserDOLLAR_DIST_POISSON-209))|(1<<(VerilogParserDOLLAR_DIST_UNIFORM-209))|(1<<(VerilogParserDOLLAR_CLOG2-209))|(1<<(VerilogParserDOLLAR_LN-209))|(1<<(VerilogParserDOLLAR_LOG10-209))|(1<<(VerilogParserDOLLAR_EXP-209))|(1<<(VerilogParserDOLLAR_SQRT-209))|(1<<(VerilogParserDOLLAR_POW-209))|(1<<(VerilogParserDOLLAR_FLOOR-209))|(1<<(VerilogParserDOLLAR_CEIL-209))|(1<<(VerilogParserDOLLAR_SIN-209))|(1<<(VerilogParserDOLLAR_COS-209))|(1<<(VerilogParserDOLLAR_TAN-209))|(1<<(VerilogParserDOLLAR_ASIN-209))|(1<<(VerilogParserDOLLAR_ACOS-209))|(1<<(VerilogParserDOLLAR_ATAN-209))|(1<<(VerilogParserDOLLAR_ATAN2-209))|(1<<(VerilogParserDOLLAR_HYPOT-209)))) != 0) || (((_la-241)&-(0x1f+1)) == 0 && ((1<<uint((_la-241)))&((1<<(VerilogParserDOLLAR_SINH-241))|(1<<(VerilogParserDOLLAR_COSH-241))|(1<<(VerilogParserDOLLAR_TANH-241))|(1<<(VerilogParserDOLLAR_ASINH-241))|(1<<(VerilogParserDOLLAR_ACOSH-241))|(1<<(VerilogParserDOLLAR_ATANH-241)))) != 0) || (((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282))|(1<<(VerilogParserSTRING-282))|(1<<(VerilogParserESCAPED_IDENTIFIER-282))|(1<<(VerilogParserSIMPLE_IDENTIFIER-282))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-282))|(1<<(VerilogParserLEFT_PARENTHESIS-282))|(1<<(VerilogParserLEFT_BRACE-282))|(1<<(VerilogParserPLUS-282))|(1<<(VerilogParserMINUS-282))|(1<<(VerilogParserEXCLAMATION_MARK-282))|(1<<(VerilogParserTILDE-282))|(1<<(VerilogParserAMPERSAND-282))|(1<<(VerilogParserTILDE_AMPERSAND-282))|(1<<(VerilogParserVERTICAL_BAR-282))|(1<<(VerilogParserTILDE_VERTICAL_BAR-282))|(1<<(VerilogParserCARET-282))|(1<<(VerilogParserTILDE_CARET-282))|(1<<(VerilogParserCARET_TILDE-282)))) != 0) {
		{
			p.SetState(2764)
			p.Module_or_generate_item()
		}

		p.SetState(2769)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2770)
		p.Match(VerilogParserENDGENERATE)
	}

	return localctx
}

// IGenvar_declarationContext is an interface to support dynamic dispatch.
type IGenvar_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_declarationContext differentiates from other interfaces.
	IsGenvar_declarationContext()
}

type Genvar_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_declarationContext() *Genvar_declarationContext {
	var p = new(Genvar_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_declaration
	return p
}

func (*Genvar_declarationContext) IsGenvar_declarationContext() {}

func NewGenvar_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_declarationContext {
	var p = new(Genvar_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_declaration

	return p
}

func (s *Genvar_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_declarationContext) GENVAR() antlr.TerminalNode {
	return s.GetToken(VerilogParserGENVAR, 0)
}

func (s *Genvar_declarationContext) List_of_genvar_identifiers() IList_of_genvar_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_genvar_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_genvar_identifiersContext)
}

func (s *Genvar_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Genvar_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenvar_declaration(s)
	}
}

func (s *Genvar_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenvar_declaration(s)
	}
}

func (p *VerilogParser) Genvar_declaration() (localctx IGenvar_declarationContext) {
	this := p
	_ = this

	localctx = NewGenvar_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, VerilogParserRULE_genvar_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2772)
		p.Match(VerilogParserGENVAR)
	}
	{
		p.SetState(2773)
		p.List_of_genvar_identifiers()
	}
	{
		p.SetState(2774)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IList_of_genvar_identifiersContext is an interface to support dynamic dispatch.
type IList_of_genvar_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_genvar_identifiersContext differentiates from other interfaces.
	IsList_of_genvar_identifiersContext()
}

type List_of_genvar_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_genvar_identifiersContext() *List_of_genvar_identifiersContext {
	var p = new(List_of_genvar_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_genvar_identifiers
	return p
}

func (*List_of_genvar_identifiersContext) IsList_of_genvar_identifiersContext() {}

func NewList_of_genvar_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_genvar_identifiersContext {
	var p = new(List_of_genvar_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_genvar_identifiers

	return p
}

func (s *List_of_genvar_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_genvar_identifiersContext) AllGenvar_identifier() []IGenvar_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem())
	var tst = make([]IGenvar_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenvar_identifierContext)
		}
	}

	return tst
}

func (s *List_of_genvar_identifiersContext) Genvar_identifier(i int) IGenvar_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenvar_identifierContext)
}

func (s *List_of_genvar_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_genvar_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_genvar_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_genvar_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_genvar_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_genvar_identifiers(s)
	}
}

func (s *List_of_genvar_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_genvar_identifiers(s)
	}
}

func (p *VerilogParser) List_of_genvar_identifiers() (localctx IList_of_genvar_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_genvar_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, VerilogParserRULE_list_of_genvar_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2776)
		p.Genvar_identifier()
	}
	p.SetState(2781)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(2777)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(2778)
			p.Genvar_identifier()
		}

		p.SetState(2783)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILoop_generate_constructContext is an interface to support dynamic dispatch.
type ILoop_generate_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_generate_constructContext differentiates from other interfaces.
	IsLoop_generate_constructContext()
}

type Loop_generate_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_generate_constructContext() *Loop_generate_constructContext {
	var p = new(Loop_generate_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_loop_generate_construct
	return p
}

func (*Loop_generate_constructContext) IsLoop_generate_constructContext() {}

func NewLoop_generate_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_generate_constructContext {
	var p = new(Loop_generate_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_loop_generate_construct

	return p
}

func (s *Loop_generate_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_generate_constructContext) FOR() antlr.TerminalNode {
	return s.GetToken(VerilogParserFOR, 0)
}

func (s *Loop_generate_constructContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Loop_generate_constructContext) Genvar_initialization() IGenvar_initializationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_initializationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_initializationContext)
}

func (s *Loop_generate_constructContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserSEMICOLON)
}

func (s *Loop_generate_constructContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, i)
}

func (s *Loop_generate_constructContext) Genvar_expression() IGenvar_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_expressionContext)
}

func (s *Loop_generate_constructContext) Genvar_iteration() IGenvar_iterationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_iterationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_iterationContext)
}

func (s *Loop_generate_constructContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Loop_generate_constructContext) Generate_block() IGenerate_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_blockContext)
}

func (s *Loop_generate_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_generate_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_generate_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLoop_generate_construct(s)
	}
}

func (s *Loop_generate_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLoop_generate_construct(s)
	}
}

func (p *VerilogParser) Loop_generate_construct() (localctx ILoop_generate_constructContext) {
	this := p
	_ = this

	localctx = NewLoop_generate_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, VerilogParserRULE_loop_generate_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2784)
		p.Match(VerilogParserFOR)
	}
	{
		p.SetState(2785)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(2786)
		p.Genvar_initialization()
	}
	{
		p.SetState(2787)
		p.Match(VerilogParserSEMICOLON)
	}
	{
		p.SetState(2788)
		p.genvar_expression(0)
	}
	{
		p.SetState(2789)
		p.Match(VerilogParserSEMICOLON)
	}
	{
		p.SetState(2790)
		p.Genvar_iteration()
	}
	{
		p.SetState(2791)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}
	{
		p.SetState(2792)
		p.Generate_block()
	}

	return localctx
}

// IGenvar_initializationContext is an interface to support dynamic dispatch.
type IGenvar_initializationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_initializationContext differentiates from other interfaces.
	IsGenvar_initializationContext()
}

type Genvar_initializationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_initializationContext() *Genvar_initializationContext {
	var p = new(Genvar_initializationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_initialization
	return p
}

func (*Genvar_initializationContext) IsGenvar_initializationContext() {}

func NewGenvar_initializationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_initializationContext {
	var p = new(Genvar_initializationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_initialization

	return p
}

func (s *Genvar_initializationContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_initializationContext) Genvar_identifier() IGenvar_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_identifierContext)
}

func (s *Genvar_initializationContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Genvar_initializationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Genvar_initializationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_initializationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_initializationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenvar_initialization(s)
	}
}

func (s *Genvar_initializationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenvar_initialization(s)
	}
}

func (p *VerilogParser) Genvar_initialization() (localctx IGenvar_initializationContext) {
	this := p
	_ = this

	localctx = NewGenvar_initializationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, VerilogParserRULE_genvar_initialization)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2794)
		p.Genvar_identifier()
	}
	{
		p.SetState(2795)
		p.Match(VerilogParserEQUAL)
	}
	{
		p.SetState(2796)
		p.constant_expression(0)
	}

	return localctx
}

// IGenvar_expressionContext is an interface to support dynamic dispatch.
type IGenvar_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_expressionContext differentiates from other interfaces.
	IsGenvar_expressionContext()
}

type Genvar_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_expressionContext() *Genvar_expressionContext {
	var p = new(Genvar_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_expression
	return p
}

func (*Genvar_expressionContext) IsGenvar_expressionContext() {}

func NewGenvar_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_expressionContext {
	var p = new(Genvar_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_expression

	return p
}

func (s *Genvar_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_expressionContext) Genvar_primary() IGenvar_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_primaryContext)
}

func (s *Genvar_expressionContext) Unary_operator() IUnary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *Genvar_expressionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Genvar_expressionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Genvar_expressionContext) AllGenvar_expression() []IGenvar_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenvar_expressionContext)(nil)).Elem())
	var tst = make([]IGenvar_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenvar_expressionContext)
		}
	}

	return tst
}

func (s *Genvar_expressionContext) Genvar_expression(i int) IGenvar_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenvar_expressionContext)
}

func (s *Genvar_expressionContext) Binary_operator() IBinary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinary_operatorContext)
}

func (s *Genvar_expressionContext) QUESTION_MARK() antlr.TerminalNode {
	return s.GetToken(VerilogParserQUESTION_MARK, 0)
}

func (s *Genvar_expressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *Genvar_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenvar_expression(s)
	}
}

func (s *Genvar_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenvar_expression(s)
	}
}

func (p *VerilogParser) Genvar_expression() (localctx IGenvar_expressionContext) {
	return p.genvar_expression(0)
}

func (p *VerilogParser) genvar_expression(_p int) (localctx IGenvar_expressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewGenvar_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IGenvar_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 388
	p.EnterRecursionRule(localctx, 388, VerilogParserRULE_genvar_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2809)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserDOLLAR_BITSTOREAL, VerilogParserDOLLAR_ITOR, VerilogParserDOLLAR_SIGNED, VerilogParserDOLLAR_REALTOBITS, VerilogParserDOLLAR_RTOI, VerilogParserDOLLAR_UNSIGNED, VerilogParserDOLLAR_RANDOM, VerilogParserDOLLAR_DIST_ERLANG, VerilogParserDOLLAR_DIST_NORMAL, VerilogParserDOLLAR_DIST_T, VerilogParserDOLLAR_DIST_CHI_SQUARE, VerilogParserDOLLAR_DIST_EXPONENTIAL, VerilogParserDOLLAR_DIST_POISSON, VerilogParserDOLLAR_DIST_UNIFORM, VerilogParserDOLLAR_CLOG2, VerilogParserDOLLAR_LN, VerilogParserDOLLAR_LOG10, VerilogParserDOLLAR_EXP, VerilogParserDOLLAR_SQRT, VerilogParserDOLLAR_POW, VerilogParserDOLLAR_FLOOR, VerilogParserDOLLAR_CEIL, VerilogParserDOLLAR_SIN, VerilogParserDOLLAR_COS, VerilogParserDOLLAR_TAN, VerilogParserDOLLAR_ASIN, VerilogParserDOLLAR_ACOS, VerilogParserDOLLAR_ATAN, VerilogParserDOLLAR_ATAN2, VerilogParserDOLLAR_HYPOT, VerilogParserDOLLAR_SINH, VerilogParserDOLLAR_COSH, VerilogParserDOLLAR_TANH, VerilogParserDOLLAR_ASINH, VerilogParserDOLLAR_ACOSH, VerilogParserDOLLAR_ATANH, VerilogParserREAL_NUMBER, VerilogParserDECIMAL_NUMBER, VerilogParserBINARY_NUMBER, VerilogParserOCTAL_NUMBER, VerilogParserHEX_NUMBER, VerilogParserSTRING, VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER, VerilogParserSYSTEM_TF_IDENTIFIER, VerilogParserLEFT_PARENTHESIS, VerilogParserLEFT_BRACE:
		{
			p.SetState(2799)
			p.Genvar_primary()
		}

	case VerilogParserPLUS, VerilogParserMINUS, VerilogParserEXCLAMATION_MARK, VerilogParserTILDE, VerilogParserAMPERSAND, VerilogParserTILDE_AMPERSAND, VerilogParserVERTICAL_BAR, VerilogParserTILDE_VERTICAL_BAR, VerilogParserCARET, VerilogParserTILDE_CARET, VerilogParserCARET_TILDE:
		{
			p.SetState(2800)
			p.Unary_operator()
		}
		p.SetState(2804)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 271, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2801)
					p.Attribute_instance()
				}

			}
			p.SetState(2806)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 271, p.GetParserRuleContext())
		}
		{
			p.SetState(2807)
			p.Genvar_primary()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2835)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 276, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2833)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 275, p.GetParserRuleContext()) {
			case 1:
				localctx = NewGenvar_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, VerilogParserRULE_genvar_expression)
				p.SetState(2811)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(2812)
					p.Binary_operator()
				}
				p.SetState(2816)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 273, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(2813)
							p.Attribute_instance()
						}

					}
					p.SetState(2818)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 273, p.GetParserRuleContext())
				}
				{
					p.SetState(2819)
					p.genvar_expression(3)
				}

			case 2:
				localctx = NewGenvar_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, VerilogParserRULE_genvar_expression)
				p.SetState(2821)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(2822)
					p.Match(VerilogParserQUESTION_MARK)
				}
				p.SetState(2826)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 274, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(2823)
							p.Attribute_instance()
						}

					}
					p.SetState(2828)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 274, p.GetParserRuleContext())
				}
				{
					p.SetState(2829)
					p.genvar_expression(0)
				}
				{
					p.SetState(2830)
					p.Match(VerilogParserCOLON)
				}
				{
					p.SetState(2831)
					p.genvar_expression(2)
				}

			}

		}
		p.SetState(2837)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 276, p.GetParserRuleContext())
	}

	return localctx
}

// IGenvar_iterationContext is an interface to support dynamic dispatch.
type IGenvar_iterationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_iterationContext differentiates from other interfaces.
	IsGenvar_iterationContext()
}

type Genvar_iterationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_iterationContext() *Genvar_iterationContext {
	var p = new(Genvar_iterationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_iteration
	return p
}

func (*Genvar_iterationContext) IsGenvar_iterationContext() {}

func NewGenvar_iterationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_iterationContext {
	var p = new(Genvar_iterationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_iteration

	return p
}

func (s *Genvar_iterationContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_iterationContext) Genvar_identifier() IGenvar_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_identifierContext)
}

func (s *Genvar_iterationContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Genvar_iterationContext) Genvar_expression() IGenvar_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_expressionContext)
}

func (s *Genvar_iterationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_iterationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_iterationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenvar_iteration(s)
	}
}

func (s *Genvar_iterationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenvar_iteration(s)
	}
}

func (p *VerilogParser) Genvar_iteration() (localctx IGenvar_iterationContext) {
	this := p
	_ = this

	localctx = NewGenvar_iterationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, VerilogParserRULE_genvar_iteration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2838)
		p.Genvar_identifier()
	}
	{
		p.SetState(2839)
		p.Match(VerilogParserEQUAL)
	}
	{
		p.SetState(2840)
		p.genvar_expression(0)
	}

	return localctx
}

// IGenvar_primaryContext is an interface to support dynamic dispatch.
type IGenvar_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_primaryContext differentiates from other interfaces.
	IsGenvar_primaryContext()
}

type Genvar_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_primaryContext() *Genvar_primaryContext {
	var p = new(Genvar_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_primary
	return p
}

func (*Genvar_primaryContext) IsGenvar_primaryContext() {}

func NewGenvar_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_primaryContext {
	var p = new(Genvar_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_primary

	return p
}

func (s *Genvar_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_primaryContext) Constant_primary() IConstant_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_primaryContext)
}

func (s *Genvar_primaryContext) Genvar_identifier() IGenvar_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_identifierContext)
}

func (s *Genvar_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenvar_primary(s)
	}
}

func (s *Genvar_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenvar_primary(s)
	}
}

func (p *VerilogParser) Genvar_primary() (localctx IGenvar_primaryContext) {
	this := p
	_ = this

	localctx = NewGenvar_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, VerilogParserRULE_genvar_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2844)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 277, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2842)
			p.Constant_primary()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2843)
			p.Genvar_identifier()
		}

	}

	return localctx
}

// IConditional_generate_constructContext is an interface to support dynamic dispatch.
type IConditional_generate_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_generate_constructContext differentiates from other interfaces.
	IsConditional_generate_constructContext()
}

type Conditional_generate_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_generate_constructContext() *Conditional_generate_constructContext {
	var p = new(Conditional_generate_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_conditional_generate_construct
	return p
}

func (*Conditional_generate_constructContext) IsConditional_generate_constructContext() {}

func NewConditional_generate_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_generate_constructContext {
	var p = new(Conditional_generate_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_conditional_generate_construct

	return p
}

func (s *Conditional_generate_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_generate_constructContext) If_generate_construct() IIf_generate_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_generate_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_generate_constructContext)
}

func (s *Conditional_generate_constructContext) Case_generate_construct() ICase_generate_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_generate_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_generate_constructContext)
}

func (s *Conditional_generate_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_generate_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_generate_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConditional_generate_construct(s)
	}
}

func (s *Conditional_generate_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConditional_generate_construct(s)
	}
}

func (p *VerilogParser) Conditional_generate_construct() (localctx IConditional_generate_constructContext) {
	this := p
	_ = this

	localctx = NewConditional_generate_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, VerilogParserRULE_conditional_generate_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2848)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2846)
			p.If_generate_construct()
		}

	case VerilogParserDEFAULT, VerilogParserDOLLAR_BITSTOREAL, VerilogParserDOLLAR_ITOR, VerilogParserDOLLAR_SIGNED, VerilogParserDOLLAR_REALTOBITS, VerilogParserDOLLAR_RTOI, VerilogParserDOLLAR_UNSIGNED, VerilogParserDOLLAR_RANDOM, VerilogParserDOLLAR_DIST_ERLANG, VerilogParserDOLLAR_DIST_NORMAL, VerilogParserDOLLAR_DIST_T, VerilogParserDOLLAR_DIST_CHI_SQUARE, VerilogParserDOLLAR_DIST_EXPONENTIAL, VerilogParserDOLLAR_DIST_POISSON, VerilogParserDOLLAR_DIST_UNIFORM, VerilogParserDOLLAR_CLOG2, VerilogParserDOLLAR_LN, VerilogParserDOLLAR_LOG10, VerilogParserDOLLAR_EXP, VerilogParserDOLLAR_SQRT, VerilogParserDOLLAR_POW, VerilogParserDOLLAR_FLOOR, VerilogParserDOLLAR_CEIL, VerilogParserDOLLAR_SIN, VerilogParserDOLLAR_COS, VerilogParserDOLLAR_TAN, VerilogParserDOLLAR_ASIN, VerilogParserDOLLAR_ACOS, VerilogParserDOLLAR_ATAN, VerilogParserDOLLAR_ATAN2, VerilogParserDOLLAR_HYPOT, VerilogParserDOLLAR_SINH, VerilogParserDOLLAR_COSH, VerilogParserDOLLAR_TANH, VerilogParserDOLLAR_ASINH, VerilogParserDOLLAR_ACOSH, VerilogParserDOLLAR_ATANH, VerilogParserREAL_NUMBER, VerilogParserDECIMAL_NUMBER, VerilogParserBINARY_NUMBER, VerilogParserOCTAL_NUMBER, VerilogParserHEX_NUMBER, VerilogParserSTRING, VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER, VerilogParserSYSTEM_TF_IDENTIFIER, VerilogParserLEFT_PARENTHESIS, VerilogParserLEFT_BRACE, VerilogParserPLUS, VerilogParserMINUS, VerilogParserEXCLAMATION_MARK, VerilogParserTILDE, VerilogParserAMPERSAND, VerilogParserTILDE_AMPERSAND, VerilogParserVERTICAL_BAR, VerilogParserTILDE_VERTICAL_BAR, VerilogParserCARET, VerilogParserTILDE_CARET, VerilogParserCARET_TILDE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2847)
			p.Case_generate_construct()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIf_generate_constructContext is an interface to support dynamic dispatch.
type IIf_generate_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_generate_constructContext differentiates from other interfaces.
	IsIf_generate_constructContext()
}

type If_generate_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_generate_constructContext() *If_generate_constructContext {
	var p = new(If_generate_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_if_generate_construct
	return p
}

func (*If_generate_constructContext) IsIf_generate_constructContext() {}

func NewIf_generate_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_generate_constructContext {
	var p = new(If_generate_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_if_generate_construct

	return p
}

func (s *If_generate_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *If_generate_constructContext) IF() antlr.TerminalNode {
	return s.GetToken(VerilogParserIF, 0)
}

func (s *If_generate_constructContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *If_generate_constructContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *If_generate_constructContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *If_generate_constructContext) AllGenerate_block_or_null() []IGenerate_block_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenerate_block_or_nullContext)(nil)).Elem())
	var tst = make([]IGenerate_block_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenerate_block_or_nullContext)
		}
	}

	return tst
}

func (s *If_generate_constructContext) Generate_block_or_null(i int) IGenerate_block_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_block_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenerate_block_or_nullContext)
}

func (s *If_generate_constructContext) ELSE() antlr.TerminalNode {
	return s.GetToken(VerilogParserELSE, 0)
}

func (s *If_generate_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_generate_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_generate_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterIf_generate_construct(s)
	}
}

func (s *If_generate_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitIf_generate_construct(s)
	}
}

func (p *VerilogParser) If_generate_construct() (localctx IIf_generate_constructContext) {
	this := p
	_ = this

	localctx = NewIf_generate_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, VerilogParserRULE_if_generate_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2850)
		p.Match(VerilogParserIF)
	}
	{
		p.SetState(2851)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(2852)
		p.constant_expression(0)
	}
	{
		p.SetState(2853)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}
	{
		p.SetState(2854)
		p.Generate_block_or_null()
	}
	p.SetState(2857)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 279, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2855)
			p.Match(VerilogParserELSE)
		}
		{
			p.SetState(2856)
			p.Generate_block_or_null()
		}

	}

	return localctx
}

// ICase_generate_constructContext is an interface to support dynamic dispatch.
type ICase_generate_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_generate_constructContext differentiates from other interfaces.
	IsCase_generate_constructContext()
}

type Case_generate_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_generate_constructContext() *Case_generate_constructContext {
	var p = new(Case_generate_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_case_generate_construct
	return p
}

func (*Case_generate_constructContext) IsCase_generate_constructContext() {}

func NewCase_generate_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_generate_constructContext {
	var p = new(Case_generate_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_case_generate_construct

	return p
}

func (s *Case_generate_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_generate_constructContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Case_generate_constructContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Case_generate_constructContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *Case_generate_constructContext) Generate_block_or_null() IGenerate_block_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_block_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_block_or_nullContext)
}

func (s *Case_generate_constructContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Case_generate_constructContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Case_generate_constructContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(VerilogParserDEFAULT, 0)
}

func (s *Case_generate_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_generate_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_generate_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCase_generate_construct(s)
	}
}

func (s *Case_generate_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCase_generate_construct(s)
	}
}

func (p *VerilogParser) Case_generate_construct() (localctx ICase_generate_constructContext) {
	this := p
	_ = this

	localctx = NewCase_generate_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, VerilogParserRULE_case_generate_construct)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2875)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserDOLLAR_BITSTOREAL, VerilogParserDOLLAR_ITOR, VerilogParserDOLLAR_SIGNED, VerilogParserDOLLAR_REALTOBITS, VerilogParserDOLLAR_RTOI, VerilogParserDOLLAR_UNSIGNED, VerilogParserDOLLAR_RANDOM, VerilogParserDOLLAR_DIST_ERLANG, VerilogParserDOLLAR_DIST_NORMAL, VerilogParserDOLLAR_DIST_T, VerilogParserDOLLAR_DIST_CHI_SQUARE, VerilogParserDOLLAR_DIST_EXPONENTIAL, VerilogParserDOLLAR_DIST_POISSON, VerilogParserDOLLAR_DIST_UNIFORM, VerilogParserDOLLAR_CLOG2, VerilogParserDOLLAR_LN, VerilogParserDOLLAR_LOG10, VerilogParserDOLLAR_EXP, VerilogParserDOLLAR_SQRT, VerilogParserDOLLAR_POW, VerilogParserDOLLAR_FLOOR, VerilogParserDOLLAR_CEIL, VerilogParserDOLLAR_SIN, VerilogParserDOLLAR_COS, VerilogParserDOLLAR_TAN, VerilogParserDOLLAR_ASIN, VerilogParserDOLLAR_ACOS, VerilogParserDOLLAR_ATAN, VerilogParserDOLLAR_ATAN2, VerilogParserDOLLAR_HYPOT, VerilogParserDOLLAR_SINH, VerilogParserDOLLAR_COSH, VerilogParserDOLLAR_TANH, VerilogParserDOLLAR_ASINH, VerilogParserDOLLAR_ACOSH, VerilogParserDOLLAR_ATANH, VerilogParserREAL_NUMBER, VerilogParserDECIMAL_NUMBER, VerilogParserBINARY_NUMBER, VerilogParserOCTAL_NUMBER, VerilogParserHEX_NUMBER, VerilogParserSTRING, VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER, VerilogParserSYSTEM_TF_IDENTIFIER, VerilogParserLEFT_PARENTHESIS, VerilogParserLEFT_BRACE, VerilogParserPLUS, VerilogParserMINUS, VerilogParserEXCLAMATION_MARK, VerilogParserTILDE, VerilogParserAMPERSAND, VerilogParserTILDE_AMPERSAND, VerilogParserVERTICAL_BAR, VerilogParserTILDE_VERTICAL_BAR, VerilogParserCARET, VerilogParserTILDE_CARET, VerilogParserCARET_TILDE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2859)
			p.constant_expression(0)
		}
		p.SetState(2864)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(2860)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(2861)
				p.constant_expression(0)
			}

			p.SetState(2866)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2867)
			p.Match(VerilogParserCOLON)
		}
		{
			p.SetState(2868)
			p.Generate_block_or_null()
		}

	case VerilogParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2870)
			p.Match(VerilogParserDEFAULT)
		}
		p.SetState(2872)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserCOLON {
			{
				p.SetState(2871)
				p.Match(VerilogParserCOLON)
			}

		}
		{
			p.SetState(2874)
			p.Generate_block_or_null()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGenerate_blockContext is an interface to support dynamic dispatch.
type IGenerate_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_blockContext differentiates from other interfaces.
	IsGenerate_blockContext()
}

type Generate_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_blockContext() *Generate_blockContext {
	var p = new(Generate_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_block
	return p
}

func (*Generate_blockContext) IsGenerate_blockContext() {}

func NewGenerate_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_blockContext {
	var p = new(Generate_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_block

	return p
}

func (s *Generate_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_blockContext) AllModule_or_generate_item() []IModule_or_generate_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_or_generate_itemContext)(nil)).Elem())
	var tst = make([]IModule_or_generate_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_or_generate_itemContext)
		}
	}

	return tst
}

func (s *Generate_blockContext) Module_or_generate_item(i int) IModule_or_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_itemContext)
}

func (s *Generate_blockContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(VerilogParserBEGIN, 0)
}

func (s *Generate_blockContext) END() antlr.TerminalNode {
	return s.GetToken(VerilogParserEND, 0)
}

func (s *Generate_blockContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *Generate_blockContext) Generate_block_identifier() IGenerate_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_block_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_block_identifierContext)
}

func (s *Generate_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenerate_block(s)
	}
}

func (s *Generate_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenerate_block(s)
	}
}

func (p *VerilogParser) Generate_block() (localctx IGenerate_blockContext) {
	this := p
	_ = this

	localctx = NewGenerate_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, VerilogParserRULE_generate_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2890)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserALWAYS, VerilogParserAND, VerilogParserASSIGN, VerilogParserBUF, VerilogParserBUFIF0, VerilogParserBUFIF1, VerilogParserCMOS, VerilogParserDEFAULT, VerilogParserDEFPARAM, VerilogParserEVENT, VerilogParserFOR, VerilogParserFUNCTION, VerilogParserGENVAR, VerilogParserIF, VerilogParserINITIAL, VerilogParserINTEGER, VerilogParserLOCALPARAM, VerilogParserNAND, VerilogParserNMOS, VerilogParserNOR, VerilogParserNOT, VerilogParserNOTIF0, VerilogParserNOTIF1, VerilogParserOR, VerilogParserPMOS, VerilogParserPULLDOWN, VerilogParserPULLUP, VerilogParserRCMOS, VerilogParserREAL, VerilogParserREALTIME, VerilogParserREG, VerilogParserRNMOS, VerilogParserRPMOS, VerilogParserRTRAN, VerilogParserRTRANIF0, VerilogParserRTRANIF1, VerilogParserSUPPLY0, VerilogParserSUPPLY1, VerilogParserTASK, VerilogParserTIME, VerilogParserTRAN, VerilogParserTRANIF0, VerilogParserTRANIF1, VerilogParserTRI, VerilogParserTRI0, VerilogParserTRI1, VerilogParserTRIAND, VerilogParserTRIOR, VerilogParserTRIREG, VerilogParserWAND, VerilogParserWIRE, VerilogParserWOR, VerilogParserXNOR, VerilogParserXOR, VerilogParserDOLLAR_BITSTOREAL, VerilogParserDOLLAR_ITOR, VerilogParserDOLLAR_SIGNED, VerilogParserDOLLAR_REALTOBITS, VerilogParserDOLLAR_RTOI, VerilogParserDOLLAR_UNSIGNED, VerilogParserDOLLAR_RANDOM, VerilogParserDOLLAR_DIST_ERLANG, VerilogParserDOLLAR_DIST_NORMAL, VerilogParserDOLLAR_DIST_T, VerilogParserDOLLAR_DIST_CHI_SQUARE, VerilogParserDOLLAR_DIST_EXPONENTIAL, VerilogParserDOLLAR_DIST_POISSON, VerilogParserDOLLAR_DIST_UNIFORM, VerilogParserDOLLAR_CLOG2, VerilogParserDOLLAR_LN, VerilogParserDOLLAR_LOG10, VerilogParserDOLLAR_EXP, VerilogParserDOLLAR_SQRT, VerilogParserDOLLAR_POW, VerilogParserDOLLAR_FLOOR, VerilogParserDOLLAR_CEIL, VerilogParserDOLLAR_SIN, VerilogParserDOLLAR_COS, VerilogParserDOLLAR_TAN, VerilogParserDOLLAR_ASIN, VerilogParserDOLLAR_ACOS, VerilogParserDOLLAR_ATAN, VerilogParserDOLLAR_ATAN2, VerilogParserDOLLAR_HYPOT, VerilogParserDOLLAR_SINH, VerilogParserDOLLAR_COSH, VerilogParserDOLLAR_TANH, VerilogParserDOLLAR_ASINH, VerilogParserDOLLAR_ACOSH, VerilogParserDOLLAR_ATANH, VerilogParserREAL_NUMBER, VerilogParserDECIMAL_NUMBER, VerilogParserBINARY_NUMBER, VerilogParserOCTAL_NUMBER, VerilogParserHEX_NUMBER, VerilogParserSTRING, VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER, VerilogParserSYSTEM_TF_IDENTIFIER, VerilogParserLEFT_PARENTHESIS, VerilogParserLEFT_BRACE, VerilogParserPLUS, VerilogParserMINUS, VerilogParserEXCLAMATION_MARK, VerilogParserTILDE, VerilogParserAMPERSAND, VerilogParserTILDE_AMPERSAND, VerilogParserVERTICAL_BAR, VerilogParserTILDE_VERTICAL_BAR, VerilogParserCARET, VerilogParserTILDE_CARET, VerilogParserCARET_TILDE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2877)
			p.Module_or_generate_item()
		}

	case VerilogParserBEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2878)
			p.Match(VerilogParserBEGIN)
		}
		p.SetState(2881)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserCOLON {
			{
				p.SetState(2879)
				p.Match(VerilogParserCOLON)
			}
			{
				p.SetState(2880)
				p.Generate_block_identifier()
			}

		}
		p.SetState(2886)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserALWAYS)|(1<<VerilogParserAND)|(1<<VerilogParserASSIGN)|(1<<VerilogParserBUF)|(1<<VerilogParserBUFIF0)|(1<<VerilogParserBUFIF1)|(1<<VerilogParserCMOS)|(1<<VerilogParserDEFAULT)|(1<<VerilogParserDEFPARAM))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(VerilogParserEVENT-32))|(1<<(VerilogParserFOR-32))|(1<<(VerilogParserFUNCTION-32))|(1<<(VerilogParserGENVAR-32))|(1<<(VerilogParserIF-32))|(1<<(VerilogParserINITIAL-32))|(1<<(VerilogParserINTEGER-32))|(1<<(VerilogParserLOCALPARAM-32))|(1<<(VerilogParserNAND-32))|(1<<(VerilogParserNMOS-32))|(1<<(VerilogParserNOR-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(VerilogParserNOT-64))|(1<<(VerilogParserNOTIF0-64))|(1<<(VerilogParserNOTIF1-64))|(1<<(VerilogParserOR-64))|(1<<(VerilogParserPMOS-64))|(1<<(VerilogParserPULLDOWN-64))|(1<<(VerilogParserPULLUP-64))|(1<<(VerilogParserRCMOS-64))|(1<<(VerilogParserREAL-64))|(1<<(VerilogParserREALTIME-64))|(1<<(VerilogParserREG-64))|(1<<(VerilogParserRNMOS-64))|(1<<(VerilogParserRPMOS-64))|(1<<(VerilogParserRTRAN-64))|(1<<(VerilogParserRTRANIF0-64))|(1<<(VerilogParserRTRANIF1-64)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(VerilogParserSUPPLY0-98))|(1<<(VerilogParserSUPPLY1-98))|(1<<(VerilogParserTASK-98))|(1<<(VerilogParserTIME-98))|(1<<(VerilogParserTRAN-98))|(1<<(VerilogParserTRANIF0-98))|(1<<(VerilogParserTRANIF1-98))|(1<<(VerilogParserTRI-98))|(1<<(VerilogParserTRI0-98))|(1<<(VerilogParserTRI1-98))|(1<<(VerilogParserTRIAND-98))|(1<<(VerilogParserTRIOR-98))|(1<<(VerilogParserTRIREG-98))|(1<<(VerilogParserWAND-98))|(1<<(VerilogParserWIRE-98))|(1<<(VerilogParserWOR-98))|(1<<(VerilogParserXNOR-98))|(1<<(VerilogParserXOR-98)))) != 0) || (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(VerilogParserDOLLAR_BITSTOREAL-209))|(1<<(VerilogParserDOLLAR_ITOR-209))|(1<<(VerilogParserDOLLAR_SIGNED-209))|(1<<(VerilogParserDOLLAR_REALTOBITS-209))|(1<<(VerilogParserDOLLAR_RTOI-209))|(1<<(VerilogParserDOLLAR_UNSIGNED-209))|(1<<(VerilogParserDOLLAR_RANDOM-209))|(1<<(VerilogParserDOLLAR_DIST_ERLANG-209))|(1<<(VerilogParserDOLLAR_DIST_NORMAL-209))|(1<<(VerilogParserDOLLAR_DIST_T-209))|(1<<(VerilogParserDOLLAR_DIST_CHI_SQUARE-209))|(1<<(VerilogParserDOLLAR_DIST_EXPONENTIAL-209))|(1<<(VerilogParserDOLLAR_DIST_POISSON-209))|(1<<(VerilogParserDOLLAR_DIST_UNIFORM-209))|(1<<(VerilogParserDOLLAR_CLOG2-209))|(1<<(VerilogParserDOLLAR_LN-209))|(1<<(VerilogParserDOLLAR_LOG10-209))|(1<<(VerilogParserDOLLAR_EXP-209))|(1<<(VerilogParserDOLLAR_SQRT-209))|(1<<(VerilogParserDOLLAR_POW-209))|(1<<(VerilogParserDOLLAR_FLOOR-209))|(1<<(VerilogParserDOLLAR_CEIL-209))|(1<<(VerilogParserDOLLAR_SIN-209))|(1<<(VerilogParserDOLLAR_COS-209))|(1<<(VerilogParserDOLLAR_TAN-209))|(1<<(VerilogParserDOLLAR_ASIN-209))|(1<<(VerilogParserDOLLAR_ACOS-209))|(1<<(VerilogParserDOLLAR_ATAN-209))|(1<<(VerilogParserDOLLAR_ATAN2-209))|(1<<(VerilogParserDOLLAR_HYPOT-209)))) != 0) || (((_la-241)&-(0x1f+1)) == 0 && ((1<<uint((_la-241)))&((1<<(VerilogParserDOLLAR_SINH-241))|(1<<(VerilogParserDOLLAR_COSH-241))|(1<<(VerilogParserDOLLAR_TANH-241))|(1<<(VerilogParserDOLLAR_ASINH-241))|(1<<(VerilogParserDOLLAR_ACOSH-241))|(1<<(VerilogParserDOLLAR_ATANH-241)))) != 0) || (((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282))|(1<<(VerilogParserSTRING-282))|(1<<(VerilogParserESCAPED_IDENTIFIER-282))|(1<<(VerilogParserSIMPLE_IDENTIFIER-282))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-282))|(1<<(VerilogParserLEFT_PARENTHESIS-282))|(1<<(VerilogParserLEFT_BRACE-282))|(1<<(VerilogParserPLUS-282))|(1<<(VerilogParserMINUS-282))|(1<<(VerilogParserEXCLAMATION_MARK-282))|(1<<(VerilogParserTILDE-282))|(1<<(VerilogParserAMPERSAND-282))|(1<<(VerilogParserTILDE_AMPERSAND-282))|(1<<(VerilogParserVERTICAL_BAR-282))|(1<<(VerilogParserTILDE_VERTICAL_BAR-282))|(1<<(VerilogParserCARET-282))|(1<<(VerilogParserTILDE_CARET-282))|(1<<(VerilogParserCARET_TILDE-282)))) != 0) {
			{
				p.SetState(2883)
				p.Module_or_generate_item()
			}

			p.SetState(2888)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2889)
			p.Match(VerilogParserEND)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGenerate_block_or_nullContext is an interface to support dynamic dispatch.
type IGenerate_block_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_block_or_nullContext differentiates from other interfaces.
	IsGenerate_block_or_nullContext()
}

type Generate_block_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_block_or_nullContext() *Generate_block_or_nullContext {
	var p = new(Generate_block_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_block_or_null
	return p
}

func (*Generate_block_or_nullContext) IsGenerate_block_or_nullContext() {}

func NewGenerate_block_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_block_or_nullContext {
	var p = new(Generate_block_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_block_or_null

	return p
}

func (s *Generate_block_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_block_or_nullContext) Generate_block() IGenerate_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_blockContext)
}

func (s *Generate_block_or_nullContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Generate_block_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_block_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_block_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenerate_block_or_null(s)
	}
}

func (s *Generate_block_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenerate_block_or_null(s)
	}
}

func (p *VerilogParser) Generate_block_or_null() (localctx IGenerate_block_or_nullContext) {
	this := p
	_ = this

	localctx = NewGenerate_block_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, VerilogParserRULE_generate_block_or_null)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2894)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserALWAYS, VerilogParserAND, VerilogParserASSIGN, VerilogParserBEGIN, VerilogParserBUF, VerilogParserBUFIF0, VerilogParserBUFIF1, VerilogParserCMOS, VerilogParserDEFAULT, VerilogParserDEFPARAM, VerilogParserEVENT, VerilogParserFOR, VerilogParserFUNCTION, VerilogParserGENVAR, VerilogParserIF, VerilogParserINITIAL, VerilogParserINTEGER, VerilogParserLOCALPARAM, VerilogParserNAND, VerilogParserNMOS, VerilogParserNOR, VerilogParserNOT, VerilogParserNOTIF0, VerilogParserNOTIF1, VerilogParserOR, VerilogParserPMOS, VerilogParserPULLDOWN, VerilogParserPULLUP, VerilogParserRCMOS, VerilogParserREAL, VerilogParserREALTIME, VerilogParserREG, VerilogParserRNMOS, VerilogParserRPMOS, VerilogParserRTRAN, VerilogParserRTRANIF0, VerilogParserRTRANIF1, VerilogParserSUPPLY0, VerilogParserSUPPLY1, VerilogParserTASK, VerilogParserTIME, VerilogParserTRAN, VerilogParserTRANIF0, VerilogParserTRANIF1, VerilogParserTRI, VerilogParserTRI0, VerilogParserTRI1, VerilogParserTRIAND, VerilogParserTRIOR, VerilogParserTRIREG, VerilogParserWAND, VerilogParserWIRE, VerilogParserWOR, VerilogParserXNOR, VerilogParserXOR, VerilogParserDOLLAR_BITSTOREAL, VerilogParserDOLLAR_ITOR, VerilogParserDOLLAR_SIGNED, VerilogParserDOLLAR_REALTOBITS, VerilogParserDOLLAR_RTOI, VerilogParserDOLLAR_UNSIGNED, VerilogParserDOLLAR_RANDOM, VerilogParserDOLLAR_DIST_ERLANG, VerilogParserDOLLAR_DIST_NORMAL, VerilogParserDOLLAR_DIST_T, VerilogParserDOLLAR_DIST_CHI_SQUARE, VerilogParserDOLLAR_DIST_EXPONENTIAL, VerilogParserDOLLAR_DIST_POISSON, VerilogParserDOLLAR_DIST_UNIFORM, VerilogParserDOLLAR_CLOG2, VerilogParserDOLLAR_LN, VerilogParserDOLLAR_LOG10, VerilogParserDOLLAR_EXP, VerilogParserDOLLAR_SQRT, VerilogParserDOLLAR_POW, VerilogParserDOLLAR_FLOOR, VerilogParserDOLLAR_CEIL, VerilogParserDOLLAR_SIN, VerilogParserDOLLAR_COS, VerilogParserDOLLAR_TAN, VerilogParserDOLLAR_ASIN, VerilogParserDOLLAR_ACOS, VerilogParserDOLLAR_ATAN, VerilogParserDOLLAR_ATAN2, VerilogParserDOLLAR_HYPOT, VerilogParserDOLLAR_SINH, VerilogParserDOLLAR_COSH, VerilogParserDOLLAR_TANH, VerilogParserDOLLAR_ASINH, VerilogParserDOLLAR_ACOSH, VerilogParserDOLLAR_ATANH, VerilogParserREAL_NUMBER, VerilogParserDECIMAL_NUMBER, VerilogParserBINARY_NUMBER, VerilogParserOCTAL_NUMBER, VerilogParserHEX_NUMBER, VerilogParserSTRING, VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER, VerilogParserSYSTEM_TF_IDENTIFIER, VerilogParserLEFT_PARENTHESIS, VerilogParserLEFT_BRACE, VerilogParserPLUS, VerilogParserMINUS, VerilogParserEXCLAMATION_MARK, VerilogParserTILDE, VerilogParserAMPERSAND, VerilogParserTILDE_AMPERSAND, VerilogParserVERTICAL_BAR, VerilogParserTILDE_VERTICAL_BAR, VerilogParserCARET, VerilogParserTILDE_CARET, VerilogParserCARET_TILDE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2892)
			p.Generate_block()
		}

	case VerilogParserSEMICOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2893)
			p.Match(VerilogParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IContinuous_assignContext is an interface to support dynamic dispatch.
type IContinuous_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinuous_assignContext differentiates from other interfaces.
	IsContinuous_assignContext()
}

type Continuous_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinuous_assignContext() *Continuous_assignContext {
	var p = new(Continuous_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_continuous_assign
	return p
}

func (*Continuous_assignContext) IsContinuous_assignContext() {}

func NewContinuous_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continuous_assignContext {
	var p = new(Continuous_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_continuous_assign

	return p
}

func (s *Continuous_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Continuous_assignContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(VerilogParserASSIGN, 0)
}

func (s *Continuous_assignContext) List_of_net_assignments() IList_of_net_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_net_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_net_assignmentsContext)
}

func (s *Continuous_assignContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Continuous_assignContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Continuous_assignContext) Delay3() IDelay3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay3Context)
}

func (s *Continuous_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continuous_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Continuous_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterContinuous_assign(s)
	}
}

func (s *Continuous_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitContinuous_assign(s)
	}
}

func (p *VerilogParser) Continuous_assign() (localctx IContinuous_assignContext) {
	this := p
	_ = this

	localctx = NewContinuous_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, VerilogParserRULE_continuous_assign)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2896)
		p.Match(VerilogParserASSIGN)
	}
	p.SetState(2898)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_PARENTHESIS {
		{
			p.SetState(2897)
			p.Drive_strength()
		}

	}
	p.SetState(2901)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserHASH {
		{
			p.SetState(2900)
			p.Delay3()
		}

	}
	{
		p.SetState(2903)
		p.List_of_net_assignments()
	}
	{
		p.SetState(2904)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IList_of_net_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_net_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_net_assignmentsContext differentiates from other interfaces.
	IsList_of_net_assignmentsContext()
}

type List_of_net_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_net_assignmentsContext() *List_of_net_assignmentsContext {
	var p = new(List_of_net_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_net_assignments
	return p
}

func (*List_of_net_assignmentsContext) IsList_of_net_assignmentsContext() {}

func NewList_of_net_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_net_assignmentsContext {
	var p = new(List_of_net_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_net_assignments

	return p
}

func (s *List_of_net_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_net_assignmentsContext) AllNet_assignment() []INet_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_assignmentContext)(nil)).Elem())
	var tst = make([]INet_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_net_assignmentsContext) Net_assignment(i int) INet_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_assignmentContext)
}

func (s *List_of_net_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_net_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_net_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_net_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_net_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_net_assignments(s)
	}
}

func (s *List_of_net_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_net_assignments(s)
	}
}

func (p *VerilogParser) List_of_net_assignments() (localctx IList_of_net_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_net_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, VerilogParserRULE_list_of_net_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2906)
		p.Net_assignment()
	}
	p.SetState(2911)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(2907)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(2908)
			p.Net_assignment()
		}

		p.SetState(2913)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INet_assignmentContext is an interface to support dynamic dispatch.
type INet_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_assignmentContext differentiates from other interfaces.
	IsNet_assignmentContext()
}

type Net_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_assignmentContext() *Net_assignmentContext {
	var p = new(Net_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_assignment
	return p
}

func (*Net_assignmentContext) IsNet_assignmentContext() {}

func NewNet_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_assignmentContext {
	var p = new(Net_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_assignment

	return p
}

func (s *Net_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_assignmentContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Net_assignmentContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Net_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Net_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNet_assignment(s)
	}
}

func (s *Net_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNet_assignment(s)
	}
}

func (p *VerilogParser) Net_assignment() (localctx INet_assignmentContext) {
	this := p
	_ = this

	localctx = NewNet_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, VerilogParserRULE_net_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2914)
		p.Net_lvalue()
	}
	{
		p.SetState(2915)
		p.Match(VerilogParserEQUAL)
	}
	{
		p.SetState(2916)
		p.expression(0)
	}

	return localctx
}

// IInitial_constructContext is an interface to support dynamic dispatch.
type IInitial_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitial_constructContext differentiates from other interfaces.
	IsInitial_constructContext()
}

type Initial_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitial_constructContext() *Initial_constructContext {
	var p = new(Initial_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_initial_construct
	return p
}

func (*Initial_constructContext) IsInitial_constructContext() {}

func NewInitial_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Initial_constructContext {
	var p = new(Initial_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_initial_construct

	return p
}

func (s *Initial_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Initial_constructContext) INITIAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserINITIAL, 0)
}

func (s *Initial_constructContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Initial_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Initial_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Initial_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInitial_construct(s)
	}
}

func (s *Initial_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInitial_construct(s)
	}
}

func (p *VerilogParser) Initial_construct() (localctx IInitial_constructContext) {
	this := p
	_ = this

	localctx = NewInitial_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, VerilogParserRULE_initial_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2918)
		p.Match(VerilogParserINITIAL)
	}
	{
		p.SetState(2919)
		p.Statement()
	}

	return localctx
}

// IAlways_constructContext is an interface to support dynamic dispatch.
type IAlways_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlways_constructContext differentiates from other interfaces.
	IsAlways_constructContext()
}

type Always_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlways_constructContext() *Always_constructContext {
	var p = new(Always_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_always_construct
	return p
}

func (*Always_constructContext) IsAlways_constructContext() {}

func NewAlways_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Always_constructContext {
	var p = new(Always_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_always_construct

	return p
}

func (s *Always_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Always_constructContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(VerilogParserALWAYS, 0)
}

func (s *Always_constructContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Always_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Always_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Always_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterAlways_construct(s)
	}
}

func (s *Always_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitAlways_construct(s)
	}
}

func (p *VerilogParser) Always_construct() (localctx IAlways_constructContext) {
	this := p
	_ = this

	localctx = NewAlways_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, VerilogParserRULE_always_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2921)
		p.Match(VerilogParserALWAYS)
	}
	{
		p.SetState(2922)
		p.Statement()
	}

	return localctx
}

// IBlocking_assignmentContext is an interface to support dynamic dispatch.
type IBlocking_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlocking_assignmentContext differentiates from other interfaces.
	IsBlocking_assignmentContext()
}

type Blocking_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlocking_assignmentContext() *Blocking_assignmentContext {
	var p = new(Blocking_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_blocking_assignment
	return p
}

func (*Blocking_assignmentContext) IsBlocking_assignmentContext() {}

func NewBlocking_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Blocking_assignmentContext {
	var p = new(Blocking_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_blocking_assignment

	return p
}

func (s *Blocking_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Blocking_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Blocking_assignmentContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Blocking_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Blocking_assignmentContext) Delay_or_event_control() IDelay_or_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_or_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_or_event_controlContext)
}

func (s *Blocking_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Blocking_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Blocking_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBlocking_assignment(s)
	}
}

func (s *Blocking_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBlocking_assignment(s)
	}
}

func (p *VerilogParser) Blocking_assignment() (localctx IBlocking_assignmentContext) {
	this := p
	_ = this

	localctx = NewBlocking_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, VerilogParserRULE_blocking_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2924)
		p.Variable_lvalue()
	}
	{
		p.SetState(2925)
		p.Match(VerilogParserEQUAL)
	}
	p.SetState(2927)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserREPEAT || _la == VerilogParserAT || _la == VerilogParserHASH {
		{
			p.SetState(2926)
			p.Delay_or_event_control()
		}

	}
	{
		p.SetState(2929)
		p.expression(0)
	}

	return localctx
}

// INonblocking_assignmentContext is an interface to support dynamic dispatch.
type INonblocking_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonblocking_assignmentContext differentiates from other interfaces.
	IsNonblocking_assignmentContext()
}

type Nonblocking_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonblocking_assignmentContext() *Nonblocking_assignmentContext {
	var p = new(Nonblocking_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_nonblocking_assignment
	return p
}

func (*Nonblocking_assignmentContext) IsNonblocking_assignmentContext() {}

func NewNonblocking_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nonblocking_assignmentContext {
	var p = new(Nonblocking_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_nonblocking_assignment

	return p
}

func (s *Nonblocking_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Nonblocking_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Nonblocking_assignmentContext) LESS_THAN_EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserLESS_THAN_EQUAL, 0)
}

func (s *Nonblocking_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Nonblocking_assignmentContext) Delay_or_event_control() IDelay_or_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_or_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_or_event_controlContext)
}

func (s *Nonblocking_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nonblocking_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nonblocking_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNonblocking_assignment(s)
	}
}

func (s *Nonblocking_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNonblocking_assignment(s)
	}
}

func (p *VerilogParser) Nonblocking_assignment() (localctx INonblocking_assignmentContext) {
	this := p
	_ = this

	localctx = NewNonblocking_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, VerilogParserRULE_nonblocking_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2931)
		p.Variable_lvalue()
	}
	{
		p.SetState(2932)
		p.Match(VerilogParserLESS_THAN_EQUAL)
	}
	p.SetState(2934)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserREPEAT || _la == VerilogParserAT || _la == VerilogParserHASH {
		{
			p.SetState(2933)
			p.Delay_or_event_control()
		}

	}
	{
		p.SetState(2936)
		p.expression(0)
	}

	return localctx
}

// IProcedural_continuous_assignmentsContext is an interface to support dynamic dispatch.
type IProcedural_continuous_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_continuous_assignmentsContext differentiates from other interfaces.
	IsProcedural_continuous_assignmentsContext()
}

type Procedural_continuous_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_continuous_assignmentsContext() *Procedural_continuous_assignmentsContext {
	var p = new(Procedural_continuous_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_procedural_continuous_assignments
	return p
}

func (*Procedural_continuous_assignmentsContext) IsProcedural_continuous_assignmentsContext() {}

func NewProcedural_continuous_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_continuous_assignmentsContext {
	var p = new(Procedural_continuous_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_procedural_continuous_assignments

	return p
}

func (s *Procedural_continuous_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_continuous_assignmentsContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(VerilogParserASSIGN, 0)
}

func (s *Procedural_continuous_assignmentsContext) Variable_assignment() IVariable_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignmentContext)
}

func (s *Procedural_continuous_assignmentsContext) DEASSIGN() antlr.TerminalNode {
	return s.GetToken(VerilogParserDEASSIGN, 0)
}

func (s *Procedural_continuous_assignmentsContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Procedural_continuous_assignmentsContext) FORCE() antlr.TerminalNode {
	return s.GetToken(VerilogParserFORCE, 0)
}

func (s *Procedural_continuous_assignmentsContext) Net_assignment() INet_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_assignmentContext)
}

func (s *Procedural_continuous_assignmentsContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(VerilogParserRELEASE, 0)
}

func (s *Procedural_continuous_assignmentsContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Procedural_continuous_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_continuous_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_continuous_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterProcedural_continuous_assignments(s)
	}
}

func (s *Procedural_continuous_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitProcedural_continuous_assignments(s)
	}
}

func (p *VerilogParser) Procedural_continuous_assignments() (localctx IProcedural_continuous_assignmentsContext) {
	this := p
	_ = this

	localctx = NewProcedural_continuous_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, VerilogParserRULE_procedural_continuous_assignments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2950)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 292, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2938)
			p.Match(VerilogParserASSIGN)
		}
		{
			p.SetState(2939)
			p.Variable_assignment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2940)
			p.Match(VerilogParserDEASSIGN)
		}
		{
			p.SetState(2941)
			p.Variable_lvalue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2942)
			p.Match(VerilogParserFORCE)
		}
		{
			p.SetState(2943)
			p.Variable_assignment()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2944)
			p.Match(VerilogParserFORCE)
		}
		{
			p.SetState(2945)
			p.Net_assignment()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2946)
			p.Match(VerilogParserRELEASE)
		}
		{
			p.SetState(2947)
			p.Variable_lvalue()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2948)
			p.Match(VerilogParserRELEASE)
		}
		{
			p.SetState(2949)
			p.Net_lvalue()
		}

	}

	return localctx
}

// IVariable_assignmentContext is an interface to support dynamic dispatch.
type IVariable_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_assignmentContext differentiates from other interfaces.
	IsVariable_assignmentContext()
}

type Variable_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_assignmentContext() *Variable_assignmentContext {
	var p = new(Variable_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_assignment
	return p
}

func (*Variable_assignmentContext) IsVariable_assignmentContext() {}

func NewVariable_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_assignmentContext {
	var p = new(Variable_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_assignment

	return p
}

func (s *Variable_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Variable_assignmentContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Variable_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterVariable_assignment(s)
	}
}

func (s *Variable_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitVariable_assignment(s)
	}
}

func (p *VerilogParser) Variable_assignment() (localctx IVariable_assignmentContext) {
	this := p
	_ = this

	localctx = NewVariable_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, VerilogParserRULE_variable_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2952)
		p.Variable_lvalue()
	}
	{
		p.SetState(2953)
		p.Match(VerilogParserEQUAL)
	}
	{
		p.SetState(2954)
		p.expression(0)
	}

	return localctx
}

// IPar_blockContext is an interface to support dynamic dispatch.
type IPar_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPar_blockContext differentiates from other interfaces.
	IsPar_blockContext()
}

type Par_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPar_blockContext() *Par_blockContext {
	var p = new(Par_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_par_block
	return p
}

func (*Par_blockContext) IsPar_blockContext() {}

func NewPar_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Par_blockContext {
	var p = new(Par_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_par_block

	return p
}

func (s *Par_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Par_blockContext) FORK() antlr.TerminalNode {
	return s.GetToken(VerilogParserFORK, 0)
}

func (s *Par_blockContext) JOIN() antlr.TerminalNode {
	return s.GetToken(VerilogParserJOIN, 0)
}

func (s *Par_blockContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *Par_blockContext) Block_identifier() IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Par_blockContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Par_blockContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Par_blockContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Par_blockContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Par_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Par_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Par_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPar_block(s)
	}
}

func (s *Par_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPar_block(s)
	}
}

func (p *VerilogParser) Par_block() (localctx IPar_blockContext) {
	this := p
	_ = this

	localctx = NewPar_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, VerilogParserRULE_par_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2956)
		p.Match(VerilogParserFORK)
	}
	p.SetState(2965)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserCOLON {
		{
			p.SetState(2957)
			p.Match(VerilogParserCOLON)
		}
		{
			p.SetState(2958)
			p.Block_identifier()
		}
		p.SetState(2962)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 293, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2959)
					p.Block_item_declaration()
				}

			}
			p.SetState(2964)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 293, p.GetParserRuleContext())
		}

	}
	p.SetState(2970)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserASSIGN)|(1<<VerilogParserBEGIN)|(1<<VerilogParserCASE)|(1<<VerilogParserCASEX)|(1<<VerilogParserCASEZ)|(1<<VerilogParserDEASSIGN)|(1<<VerilogParserDISABLE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(VerilogParserFOR-33))|(1<<(VerilogParserFORCE-33))|(1<<(VerilogParserFOREVER-33))|(1<<(VerilogParserFORK-33))|(1<<(VerilogParserIF-33)))) != 0) || _la == VerilogParserRELEASE || _la == VerilogParserREPEAT || (((_la-116)&-(0x1f+1)) == 0 && ((1<<uint((_la-116)))&((1<<(VerilogParserWAIT-116))|(1<<(VerilogParserWHILE-116))|(1<<(VerilogParserDOLLAR_DISPLAY-116))|(1<<(VerilogParserDOLLAR_DISPLAYB-116))|(1<<(VerilogParserDOLLAR_DISPLAYH-116))|(1<<(VerilogParserDOLLAR_DISPLAYO-116))|(1<<(VerilogParserDOLLAR_WRITE-116))|(1<<(VerilogParserDOLLAR_WRITEB-116))|(1<<(VerilogParserDOLLAR_WRITEH-116))|(1<<(VerilogParserDOLLAR_WRITEO-116))|(1<<(VerilogParserDOLLAR_STROBE-116))|(1<<(VerilogParserDOLLAR_STROBEB-116))|(1<<(VerilogParserDOLLAR_STROBEH-116))|(1<<(VerilogParserDOLLAR_STROBEO-116))|(1<<(VerilogParserDOLLAR_MONITOR-116))|(1<<(VerilogParserDOLLAR_MONITORB-116))|(1<<(VerilogParserDOLLAR_MONITORH-116))|(1<<(VerilogParserDOLLAR_MONITORO-116))|(1<<(VerilogParserDOLLAR_MONITOROFF-116))|(1<<(VerilogParserDOLLAR_MONITORON-116))|(1<<(VerilogParserDOLLAR_FCLOSE-116))|(1<<(VerilogParserDOLLAR_FDISPLAY-116))|(1<<(VerilogParserDOLLAR_FDISPLAYB-116))|(1<<(VerilogParserDOLLAR_FDISPLAYH-116))|(1<<(VerilogParserDOLLAR_FDISPLAYO-116)))) != 0) || (((_la-148)&-(0x1f+1)) == 0 && ((1<<uint((_la-148)))&((1<<(VerilogParserDOLLAR_FSTROBE-148))|(1<<(VerilogParserDOLLAR_FSTROBEB-148))|(1<<(VerilogParserDOLLAR_FSTROBEH-148))|(1<<(VerilogParserDOLLAR_FSTROBEO-148))|(1<<(VerilogParserDOLLAR_FWRITE-148))|(1<<(VerilogParserDOLLAR_FWRITEB-148))|(1<<(VerilogParserDOLLAR_FWRITEH-148))|(1<<(VerilogParserDOLLAR_FWRITEO-148))|(1<<(VerilogParserDOLLAR_FMONITOR-148))|(1<<(VerilogParserDOLLAR_FMONITORB-148))|(1<<(VerilogParserDOLLAR_FMONITORH-148))|(1<<(VerilogParserDOLLAR_FMONITORO-148))|(1<<(VerilogParserDOLLAR_READMEMB-148)))) != 0) || (((_la-180)&-(0x1f+1)) == 0 && ((1<<uint((_la-180)))&((1<<(VerilogParserDOLLAR_READMEMH-180))|(1<<(VerilogParserDOLLAR_FINISH-180))|(1<<(VerilogParserDOLLAR_STOP-180)))) != 0) || (((_la-247)&-(0x1f+1)) == 0 && ((1<<uint((_la-247)))&((1<<(VerilogParserDOLLAR_DUMPFILE-247))|(1<<(VerilogParserDOLLAR_DUMPVARS-247))|(1<<(VerilogParserDOLLAR_DUMPOFF-247))|(1<<(VerilogParserDOLLAR_DUMPON-247))|(1<<(VerilogParserDOLLAR_DUMPALL-247))|(1<<(VerilogParserDOLLAR_DUMPLIMIT-247))|(1<<(VerilogParserDOLLAR_DUMPFLUSH-247))|(1<<(VerilogParserDOLLAR_DUMPPORTS-247))|(1<<(VerilogParserDOLLAR_DUMPPORTSOFF-247))|(1<<(VerilogParserDOLLAR_DUMPPORTSON-247))|(1<<(VerilogParserDOLLAR_DUMPPORTSALL-247))|(1<<(VerilogParserDOLLAR_DUMPPORTSLIMIT-247))|(1<<(VerilogParserDOLLAR_DUMPPORTSFLUSH-247)))) != 0) || (((_la-290)&-(0x1f+1)) == 0 && ((1<<uint((_la-290)))&((1<<(VerilogParserESCAPED_IDENTIFIER-290))|(1<<(VerilogParserSIMPLE_IDENTIFIER-290))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-290))|(1<<(VerilogParserLEFT_PARENTHESIS-290))|(1<<(VerilogParserLEFT_BRACE-290)))) != 0) || (((_la-335)&-(0x1f+1)) == 0 && ((1<<uint((_la-335)))&((1<<(VerilogParserAT-335))|(1<<(VerilogParserHASH-335))|(1<<(VerilogParserMINUS_GREATER_THAN-335)))) != 0) {
		{
			p.SetState(2967)
			p.Statement()
		}

		p.SetState(2972)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2973)
		p.Match(VerilogParserJOIN)
	}

	return localctx
}

// ISeq_blockContext is an interface to support dynamic dispatch.
type ISeq_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeq_blockContext differentiates from other interfaces.
	IsSeq_blockContext()
}

type Seq_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeq_blockContext() *Seq_blockContext {
	var p = new(Seq_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_seq_block
	return p
}

func (*Seq_blockContext) IsSeq_blockContext() {}

func NewSeq_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Seq_blockContext {
	var p = new(Seq_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_seq_block

	return p
}

func (s *Seq_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Seq_blockContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(VerilogParserBEGIN, 0)
}

func (s *Seq_blockContext) END() antlr.TerminalNode {
	return s.GetToken(VerilogParserEND, 0)
}

func (s *Seq_blockContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *Seq_blockContext) Block_identifier() IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Seq_blockContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Seq_blockContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Seq_blockContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Seq_blockContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Seq_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Seq_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Seq_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSeq_block(s)
	}
}

func (s *Seq_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSeq_block(s)
	}
}

func (p *VerilogParser) Seq_block() (localctx ISeq_blockContext) {
	this := p
	_ = this

	localctx = NewSeq_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, VerilogParserRULE_seq_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2975)
		p.Match(VerilogParserBEGIN)
	}
	p.SetState(2984)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserCOLON {
		{
			p.SetState(2976)
			p.Match(VerilogParserCOLON)
		}
		{
			p.SetState(2977)
			p.Block_identifier()
		}
		p.SetState(2981)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 296, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2978)
					p.Block_item_declaration()
				}

			}
			p.SetState(2983)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 296, p.GetParserRuleContext())
		}

	}
	p.SetState(2989)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserASSIGN)|(1<<VerilogParserBEGIN)|(1<<VerilogParserCASE)|(1<<VerilogParserCASEX)|(1<<VerilogParserCASEZ)|(1<<VerilogParserDEASSIGN)|(1<<VerilogParserDISABLE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(VerilogParserFOR-33))|(1<<(VerilogParserFORCE-33))|(1<<(VerilogParserFOREVER-33))|(1<<(VerilogParserFORK-33))|(1<<(VerilogParserIF-33)))) != 0) || _la == VerilogParserRELEASE || _la == VerilogParserREPEAT || (((_la-116)&-(0x1f+1)) == 0 && ((1<<uint((_la-116)))&((1<<(VerilogParserWAIT-116))|(1<<(VerilogParserWHILE-116))|(1<<(VerilogParserDOLLAR_DISPLAY-116))|(1<<(VerilogParserDOLLAR_DISPLAYB-116))|(1<<(VerilogParserDOLLAR_DISPLAYH-116))|(1<<(VerilogParserDOLLAR_DISPLAYO-116))|(1<<(VerilogParserDOLLAR_WRITE-116))|(1<<(VerilogParserDOLLAR_WRITEB-116))|(1<<(VerilogParserDOLLAR_WRITEH-116))|(1<<(VerilogParserDOLLAR_WRITEO-116))|(1<<(VerilogParserDOLLAR_STROBE-116))|(1<<(VerilogParserDOLLAR_STROBEB-116))|(1<<(VerilogParserDOLLAR_STROBEH-116))|(1<<(VerilogParserDOLLAR_STROBEO-116))|(1<<(VerilogParserDOLLAR_MONITOR-116))|(1<<(VerilogParserDOLLAR_MONITORB-116))|(1<<(VerilogParserDOLLAR_MONITORH-116))|(1<<(VerilogParserDOLLAR_MONITORO-116))|(1<<(VerilogParserDOLLAR_MONITOROFF-116))|(1<<(VerilogParserDOLLAR_MONITORON-116))|(1<<(VerilogParserDOLLAR_FCLOSE-116))|(1<<(VerilogParserDOLLAR_FDISPLAY-116))|(1<<(VerilogParserDOLLAR_FDISPLAYB-116))|(1<<(VerilogParserDOLLAR_FDISPLAYH-116))|(1<<(VerilogParserDOLLAR_FDISPLAYO-116)))) != 0) || (((_la-148)&-(0x1f+1)) == 0 && ((1<<uint((_la-148)))&((1<<(VerilogParserDOLLAR_FSTROBE-148))|(1<<(VerilogParserDOLLAR_FSTROBEB-148))|(1<<(VerilogParserDOLLAR_FSTROBEH-148))|(1<<(VerilogParserDOLLAR_FSTROBEO-148))|(1<<(VerilogParserDOLLAR_FWRITE-148))|(1<<(VerilogParserDOLLAR_FWRITEB-148))|(1<<(VerilogParserDOLLAR_FWRITEH-148))|(1<<(VerilogParserDOLLAR_FWRITEO-148))|(1<<(VerilogParserDOLLAR_FMONITOR-148))|(1<<(VerilogParserDOLLAR_FMONITORB-148))|(1<<(VerilogParserDOLLAR_FMONITORH-148))|(1<<(VerilogParserDOLLAR_FMONITORO-148))|(1<<(VerilogParserDOLLAR_READMEMB-148)))) != 0) || (((_la-180)&-(0x1f+1)) == 0 && ((1<<uint((_la-180)))&((1<<(VerilogParserDOLLAR_READMEMH-180))|(1<<(VerilogParserDOLLAR_FINISH-180))|(1<<(VerilogParserDOLLAR_STOP-180)))) != 0) || (((_la-247)&-(0x1f+1)) == 0 && ((1<<uint((_la-247)))&((1<<(VerilogParserDOLLAR_DUMPFILE-247))|(1<<(VerilogParserDOLLAR_DUMPVARS-247))|(1<<(VerilogParserDOLLAR_DUMPOFF-247))|(1<<(VerilogParserDOLLAR_DUMPON-247))|(1<<(VerilogParserDOLLAR_DUMPALL-247))|(1<<(VerilogParserDOLLAR_DUMPLIMIT-247))|(1<<(VerilogParserDOLLAR_DUMPFLUSH-247))|(1<<(VerilogParserDOLLAR_DUMPPORTS-247))|(1<<(VerilogParserDOLLAR_DUMPPORTSOFF-247))|(1<<(VerilogParserDOLLAR_DUMPPORTSON-247))|(1<<(VerilogParserDOLLAR_DUMPPORTSALL-247))|(1<<(VerilogParserDOLLAR_DUMPPORTSLIMIT-247))|(1<<(VerilogParserDOLLAR_DUMPPORTSFLUSH-247)))) != 0) || (((_la-290)&-(0x1f+1)) == 0 && ((1<<uint((_la-290)))&((1<<(VerilogParserESCAPED_IDENTIFIER-290))|(1<<(VerilogParserSIMPLE_IDENTIFIER-290))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-290))|(1<<(VerilogParserLEFT_PARENTHESIS-290))|(1<<(VerilogParserLEFT_BRACE-290)))) != 0) || (((_la-335)&-(0x1f+1)) == 0 && ((1<<uint((_la-335)))&((1<<(VerilogParserAT-335))|(1<<(VerilogParserHASH-335))|(1<<(VerilogParserMINUS_GREATER_THAN-335)))) != 0) {
		{
			p.SetState(2986)
			p.Statement()
		}

		p.SetState(2991)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2992)
		p.Match(VerilogParserEND)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Blocking_assignment() IBlocking_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlocking_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlocking_assignmentContext)
}

func (s *StatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *StatementContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *StatementContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *StatementContext) Case_statement() ICase_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_statementContext)
}

func (s *StatementContext) Conditional_statement() IConditional_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_statementContext)
}

func (s *StatementContext) Disable_statement() IDisable_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisable_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisable_statementContext)
}

func (s *StatementContext) Event_trigger() IEvent_triggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_triggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_triggerContext)
}

func (s *StatementContext) Loop_statement() ILoop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_statementContext)
}

func (s *StatementContext) Nonblocking_assignment() INonblocking_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonblocking_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonblocking_assignmentContext)
}

func (s *StatementContext) Par_block() IPar_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPar_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPar_blockContext)
}

func (s *StatementContext) Procedural_continuous_assignments() IProcedural_continuous_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_continuous_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_continuous_assignmentsContext)
}

func (s *StatementContext) Procedural_timing_control_statement() IProcedural_timing_control_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_timing_control_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_timing_control_statementContext)
}

func (s *StatementContext) Seq_block() ISeq_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_blockContext)
}

func (s *StatementContext) System_task_enable() ISystem_task_enableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_task_enableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_task_enableContext)
}

func (s *StatementContext) Task_enable() ITask_enableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_enableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_enableContext)
}

func (s *StatementContext) Wait_statement() IWait_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWait_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWait_statementContext)
}

func (s *StatementContext) Display_tasks() IDisplay_tasksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplay_tasksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisplay_tasksContext)
}

func (s *StatementContext) Strobe_tasks() IStrobe_tasksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrobe_tasksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrobe_tasksContext)
}

func (s *StatementContext) Monitor_tasks() IMonitor_tasksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMonitor_tasksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMonitor_tasksContext)
}

func (s *StatementContext) File_open_function() IFile_open_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_open_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_open_functionContext)
}

func (s *StatementContext) File_close_task() IFile_close_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_close_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_close_taskContext)
}

func (s *StatementContext) File_output_tasks() IFile_output_tasksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_output_tasksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_output_tasksContext)
}

func (s *StatementContext) Load_memory_tasks() ILoad_memory_tasksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoad_memory_tasksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoad_memory_tasksContext)
}

func (s *StatementContext) Finish_task() IFinish_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinish_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinish_taskContext)
}

func (s *StatementContext) Stop_task() IStop_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStop_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStop_taskContext)
}

func (s *StatementContext) Dumpall_task() IDumpall_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDumpall_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDumpall_taskContext)
}

func (s *StatementContext) Dumpfile_task() IDumpfile_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDumpfile_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDumpfile_taskContext)
}

func (s *StatementContext) Dumpflush_task() IDumpflush_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDumpflush_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDumpflush_taskContext)
}

func (s *StatementContext) Dumplimit_task() IDumplimit_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDumplimit_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDumplimit_taskContext)
}

func (s *StatementContext) Dumpoff_task() IDumpoff_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDumpoff_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDumpoff_taskContext)
}

func (s *StatementContext) Dumpon_task() IDumpon_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDumpon_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDumpon_taskContext)
}

func (s *StatementContext) Dumpports_task() IDumpports_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDumpports_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDumpports_taskContext)
}

func (s *StatementContext) Dumpportsall_task() IDumpportsall_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDumpportsall_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDumpportsall_taskContext)
}

func (s *StatementContext) Dumpportsflush_task() IDumpportsflush_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDumpportsflush_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDumpportsflush_taskContext)
}

func (s *StatementContext) Dumpportslimit_task() IDumpportslimit_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDumpportslimit_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDumpportslimit_taskContext)
}

func (s *StatementContext) Dumpportsoff_task() IDumpportsoff_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDumpportsoff_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDumpportsoff_taskContext)
}

func (s *StatementContext) Dumpportson_task() IDumpportson_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDumpportson_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDumpportson_taskContext)
}

func (s *StatementContext) Dumpvars_task() IDumpvars_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDumpvars_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDumpvars_taskContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *VerilogParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, VerilogParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3120)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 313, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2997)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(2994)
				p.Attribute_instance()
			}

			p.SetState(2999)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3000)
			p.Blocking_assignment()
		}
		{
			p.SetState(3001)
			p.Match(VerilogParserSEMICOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3006)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(3003)
				p.Attribute_instance()
			}

			p.SetState(3008)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3009)
			p.Case_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(3013)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(3010)
				p.Attribute_instance()
			}

			p.SetState(3015)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3016)
			p.Conditional_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(3020)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(3017)
				p.Attribute_instance()
			}

			p.SetState(3022)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3023)
			p.Disable_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(3027)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(3024)
				p.Attribute_instance()
			}

			p.SetState(3029)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3030)
			p.Event_trigger()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(3034)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(3031)
				p.Attribute_instance()
			}

			p.SetState(3036)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3037)
			p.Loop_statement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(3041)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(3038)
				p.Attribute_instance()
			}

			p.SetState(3043)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3044)
			p.Nonblocking_assignment()
		}
		{
			p.SetState(3045)
			p.Match(VerilogParserSEMICOLON)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(3050)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(3047)
				p.Attribute_instance()
			}

			p.SetState(3052)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3053)
			p.Par_block()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(3057)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(3054)
				p.Attribute_instance()
			}

			p.SetState(3059)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3060)
			p.Procedural_continuous_assignments()
		}
		{
			p.SetState(3061)
			p.Match(VerilogParserSEMICOLON)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		p.SetState(3066)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(3063)
				p.Attribute_instance()
			}

			p.SetState(3068)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3069)
			p.Procedural_timing_control_statement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		p.SetState(3073)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(3070)
				p.Attribute_instance()
			}

			p.SetState(3075)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3076)
			p.Seq_block()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		p.SetState(3080)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(3077)
				p.Attribute_instance()
			}

			p.SetState(3082)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3083)
			p.System_task_enable()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		p.SetState(3087)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(3084)
				p.Attribute_instance()
			}

			p.SetState(3089)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3090)
			p.Task_enable()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		p.SetState(3094)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(3091)
				p.Attribute_instance()
			}

			p.SetState(3096)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3097)
			p.Wait_statement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3098)
			p.Display_tasks()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3099)
			p.Strobe_tasks()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3100)
			p.Monitor_tasks()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3101)
			p.File_open_function()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(3102)
			p.File_close_task()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(3103)
			p.File_output_tasks()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(3104)
			p.Load_memory_tasks()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(3105)
			p.Finish_task()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(3106)
			p.Stop_task()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(3107)
			p.Dumpall_task()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(3108)
			p.Dumpfile_task()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(3109)
			p.Dumpflush_task()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(3110)
			p.Dumplimit_task()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(3111)
			p.Dumpoff_task()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(3112)
			p.Dumpon_task()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(3113)
			p.Dumpports_task()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(3114)
			p.Dumpportsall_task()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(3115)
			p.Dumpportsflush_task()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(3116)
			p.Dumpportslimit_task()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(3117)
			p.Dumpportsoff_task()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(3118)
			p.Dumpportson_task()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(3119)
			p.Dumpvars_task()
		}

	}

	return localctx
}

// IStatement_or_nullContext is an interface to support dynamic dispatch.
type IStatement_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_or_nullContext differentiates from other interfaces.
	IsStatement_or_nullContext()
}

type Statement_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_or_nullContext() *Statement_or_nullContext {
	var p = new(Statement_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_statement_or_null
	return p
}

func (*Statement_or_nullContext) IsStatement_or_nullContext() {}

func NewStatement_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_or_nullContext {
	var p = new(Statement_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_statement_or_null

	return p
}

func (s *Statement_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_or_nullContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Statement_or_nullContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Statement_or_nullContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Statement_or_nullContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Statement_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Statement_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStatement_or_null(s)
	}
}

func (s *Statement_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStatement_or_null(s)
	}
}

func (p *VerilogParser) Statement_or_null() (localctx IStatement_or_nullContext) {
	this := p
	_ = this

	localctx = NewStatement_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, VerilogParserRULE_statement_or_null)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3130)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 315, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3122)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3126)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLEFT_PARENTHESIS {
			{
				p.SetState(3123)
				p.Attribute_instance()
			}

			p.SetState(3128)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3129)
			p.Match(VerilogParserSEMICOLON)
		}

	}

	return localctx
}

// IFunction_statementContext is an interface to support dynamic dispatch.
type IFunction_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_statementContext differentiates from other interfaces.
	IsFunction_statementContext()
}

type Function_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_statementContext() *Function_statementContext {
	var p = new(Function_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_statement
	return p
}

func (*Function_statementContext) IsFunction_statementContext() {}

func NewFunction_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_statementContext {
	var p = new(Function_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_statement

	return p
}

func (s *Function_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Function_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_statement(s)
	}
}

func (s *Function_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_statement(s)
	}
}

func (p *VerilogParser) Function_statement() (localctx IFunction_statementContext) {
	this := p
	_ = this

	localctx = NewFunction_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, VerilogParserRULE_function_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3132)
		p.Statement()
	}

	return localctx
}

// IDelay_controlContext is an interface to support dynamic dispatch.
type IDelay_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_controlContext differentiates from other interfaces.
	IsDelay_controlContext()
}

type Delay_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_controlContext() *Delay_controlContext {
	var p = new(Delay_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay_control
	return p
}

func (*Delay_controlContext) IsDelay_controlContext() {}

func NewDelay_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_controlContext {
	var p = new(Delay_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay_control

	return p
}

func (s *Delay_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_controlContext) HASH() antlr.TerminalNode {
	return s.GetToken(VerilogParserHASH, 0)
}

func (s *Delay_controlContext) Delay_value() IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Delay_controlContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Delay_controlContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Delay_controlContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Delay_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDelay_control(s)
	}
}

func (s *Delay_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDelay_control(s)
	}
}

func (p *VerilogParser) Delay_control() (localctx IDelay_controlContext) {
	this := p
	_ = this

	localctx = NewDelay_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, VerilogParserRULE_delay_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3141)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 316, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3134)
			p.Match(VerilogParserHASH)
		}
		{
			p.SetState(3135)
			p.Delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3136)
			p.Match(VerilogParserHASH)
		}
		{
			p.SetState(3137)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3138)
			p.Mintypmax_expression()
		}
		{
			p.SetState(3139)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}

	return localctx
}

// IDelay_or_event_controlContext is an interface to support dynamic dispatch.
type IDelay_or_event_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_or_event_controlContext differentiates from other interfaces.
	IsDelay_or_event_controlContext()
}

type Delay_or_event_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_or_event_controlContext() *Delay_or_event_controlContext {
	var p = new(Delay_or_event_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay_or_event_control
	return p
}

func (*Delay_or_event_controlContext) IsDelay_or_event_controlContext() {}

func NewDelay_or_event_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_or_event_controlContext {
	var p = new(Delay_or_event_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay_or_event_control

	return p
}

func (s *Delay_or_event_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_or_event_controlContext) Delay_control() IDelay_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_controlContext)
}

func (s *Delay_or_event_controlContext) Event_control() IEvent_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_controlContext)
}

func (s *Delay_or_event_controlContext) REPEAT() antlr.TerminalNode {
	return s.GetToken(VerilogParserREPEAT, 0)
}

func (s *Delay_or_event_controlContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Delay_or_event_controlContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Delay_or_event_controlContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Delay_or_event_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_or_event_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_or_event_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDelay_or_event_control(s)
	}
}

func (s *Delay_or_event_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDelay_or_event_control(s)
	}
}

func (p *VerilogParser) Delay_or_event_control() (localctx IDelay_or_event_controlContext) {
	this := p
	_ = this

	localctx = NewDelay_or_event_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, VerilogParserRULE_delay_or_event_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3151)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserHASH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3143)
			p.Delay_control()
		}

	case VerilogParserAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3144)
			p.Event_control()
		}

	case VerilogParserREPEAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3145)
			p.Match(VerilogParserREPEAT)
		}
		{
			p.SetState(3146)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3147)
			p.expression(0)
		}
		{
			p.SetState(3148)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(3149)
			p.Event_control()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDisable_statementContext is an interface to support dynamic dispatch.
type IDisable_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisable_statementContext differentiates from other interfaces.
	IsDisable_statementContext()
}

type Disable_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisable_statementContext() *Disable_statementContext {
	var p = new(Disable_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_disable_statement
	return p
}

func (*Disable_statementContext) IsDisable_statementContext() {}

func NewDisable_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Disable_statementContext {
	var p = new(Disable_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_disable_statement

	return p
}

func (s *Disable_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Disable_statementContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(VerilogParserDISABLE, 0)
}

func (s *Disable_statementContext) Hierarchical_task_identifier() IHierarchical_task_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_task_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_task_identifierContext)
}

func (s *Disable_statementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Disable_statementContext) Hierarchical_block_identifier() IHierarchical_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_block_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_block_identifierContext)
}

func (s *Disable_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Disable_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Disable_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDisable_statement(s)
	}
}

func (s *Disable_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDisable_statement(s)
	}
}

func (p *VerilogParser) Disable_statement() (localctx IDisable_statementContext) {
	this := p
	_ = this

	localctx = NewDisable_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, VerilogParserRULE_disable_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3161)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 318, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3153)
			p.Match(VerilogParserDISABLE)
		}
		{
			p.SetState(3154)
			p.Hierarchical_task_identifier()
		}
		{
			p.SetState(3155)
			p.Match(VerilogParserSEMICOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3157)
			p.Match(VerilogParserDISABLE)
		}
		{
			p.SetState(3158)
			p.Hierarchical_block_identifier()
		}
		{
			p.SetState(3159)
			p.Match(VerilogParserSEMICOLON)
		}

	}

	return localctx
}

// IEvent_controlContext is an interface to support dynamic dispatch.
type IEvent_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_controlContext differentiates from other interfaces.
	IsEvent_controlContext()
}

type Event_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_controlContext() *Event_controlContext {
	var p = new(Event_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_control
	return p
}

func (*Event_controlContext) IsEvent_controlContext() {}

func NewEvent_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_controlContext {
	var p = new(Event_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_control

	return p
}

func (s *Event_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_controlContext) AT() antlr.TerminalNode {
	return s.GetToken(VerilogParserAT, 0)
}

func (s *Event_controlContext) Hierarchical_event_identifier() IHierarchical_event_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_event_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_event_identifierContext)
}

func (s *Event_controlContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Event_controlContext) Event_expression() IEvent_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_expressionContext)
}

func (s *Event_controlContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Event_controlContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(VerilogParserASTERISK, 0)
}

func (s *Event_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEvent_control(s)
	}
}

func (s *Event_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEvent_control(s)
	}
}

func (p *VerilogParser) Event_control() (localctx IEvent_controlContext) {
	this := p
	_ = this

	localctx = NewEvent_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, VerilogParserRULE_event_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3176)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 319, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3163)
			p.Match(VerilogParserAT)
		}
		{
			p.SetState(3164)
			p.Hierarchical_event_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3165)
			p.Match(VerilogParserAT)
		}
		{
			p.SetState(3166)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3167)
			p.event_expression(0)
		}
		{
			p.SetState(3168)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3170)
			p.Match(VerilogParserAT)
		}
		{
			p.SetState(3171)
			p.Match(VerilogParserASTERISK)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3172)
			p.Match(VerilogParserAT)
		}
		{
			p.SetState(3173)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3174)
			p.Match(VerilogParserASTERISK)
		}
		{
			p.SetState(3175)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}

	return localctx
}

// IEvent_triggerContext is an interface to support dynamic dispatch.
type IEvent_triggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_triggerContext differentiates from other interfaces.
	IsEvent_triggerContext()
}

type Event_triggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_triggerContext() *Event_triggerContext {
	var p = new(Event_triggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_trigger
	return p
}

func (*Event_triggerContext) IsEvent_triggerContext() {}

func NewEvent_triggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_triggerContext {
	var p = new(Event_triggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_trigger

	return p
}

func (s *Event_triggerContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_triggerContext) MINUS_GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserMINUS_GREATER_THAN, 0)
}

func (s *Event_triggerContext) Hierarchical_event_identifier() IHierarchical_event_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_event_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_event_identifierContext)
}

func (s *Event_triggerContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Event_triggerContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Event_triggerContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Event_triggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_triggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_triggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEvent_trigger(s)
	}
}

func (s *Event_triggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEvent_trigger(s)
	}
}

func (p *VerilogParser) Event_trigger() (localctx IEvent_triggerContext) {
	this := p
	_ = this

	localctx = NewEvent_triggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, VerilogParserRULE_event_trigger)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3178)
		p.Match(VerilogParserMINUS_GREATER_THAN)
	}
	{
		p.SetState(3179)
		p.Hierarchical_event_identifier()
	}
	p.SetState(3183)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(VerilogParserDOLLAR_BITSTOREAL-209))|(1<<(VerilogParserDOLLAR_ITOR-209))|(1<<(VerilogParserDOLLAR_SIGNED-209))|(1<<(VerilogParserDOLLAR_REALTOBITS-209))|(1<<(VerilogParserDOLLAR_RTOI-209))|(1<<(VerilogParserDOLLAR_UNSIGNED-209))|(1<<(VerilogParserDOLLAR_RANDOM-209))|(1<<(VerilogParserDOLLAR_DIST_ERLANG-209))|(1<<(VerilogParserDOLLAR_DIST_NORMAL-209))|(1<<(VerilogParserDOLLAR_DIST_T-209))|(1<<(VerilogParserDOLLAR_DIST_CHI_SQUARE-209))|(1<<(VerilogParserDOLLAR_DIST_EXPONENTIAL-209))|(1<<(VerilogParserDOLLAR_DIST_POISSON-209))|(1<<(VerilogParserDOLLAR_DIST_UNIFORM-209))|(1<<(VerilogParserDOLLAR_CLOG2-209))|(1<<(VerilogParserDOLLAR_LN-209))|(1<<(VerilogParserDOLLAR_LOG10-209))|(1<<(VerilogParserDOLLAR_EXP-209))|(1<<(VerilogParserDOLLAR_SQRT-209))|(1<<(VerilogParserDOLLAR_POW-209))|(1<<(VerilogParserDOLLAR_FLOOR-209))|(1<<(VerilogParserDOLLAR_CEIL-209))|(1<<(VerilogParserDOLLAR_SIN-209))|(1<<(VerilogParserDOLLAR_COS-209))|(1<<(VerilogParserDOLLAR_TAN-209))|(1<<(VerilogParserDOLLAR_ASIN-209))|(1<<(VerilogParserDOLLAR_ACOS-209))|(1<<(VerilogParserDOLLAR_ATAN-209))|(1<<(VerilogParserDOLLAR_ATAN2-209))|(1<<(VerilogParserDOLLAR_HYPOT-209)))) != 0) || (((_la-241)&-(0x1f+1)) == 0 && ((1<<uint((_la-241)))&((1<<(VerilogParserDOLLAR_SINH-241))|(1<<(VerilogParserDOLLAR_COSH-241))|(1<<(VerilogParserDOLLAR_TANH-241))|(1<<(VerilogParserDOLLAR_ASINH-241))|(1<<(VerilogParserDOLLAR_ACOSH-241))|(1<<(VerilogParserDOLLAR_ATANH-241)))) != 0) || (((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282))|(1<<(VerilogParserSTRING-282))|(1<<(VerilogParserESCAPED_IDENTIFIER-282))|(1<<(VerilogParserSIMPLE_IDENTIFIER-282))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-282))|(1<<(VerilogParserLEFT_PARENTHESIS-282))|(1<<(VerilogParserLEFT_BRACE-282))|(1<<(VerilogParserPLUS-282))|(1<<(VerilogParserMINUS-282))|(1<<(VerilogParserEXCLAMATION_MARK-282))|(1<<(VerilogParserTILDE-282))|(1<<(VerilogParserAMPERSAND-282))|(1<<(VerilogParserTILDE_AMPERSAND-282))|(1<<(VerilogParserVERTICAL_BAR-282))|(1<<(VerilogParserTILDE_VERTICAL_BAR-282))|(1<<(VerilogParserCARET-282))|(1<<(VerilogParserTILDE_CARET-282))|(1<<(VerilogParserCARET_TILDE-282)))) != 0) {
		{
			p.SetState(3180)
			p.expression(0)
		}

		p.SetState(3185)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3186)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// IEvent_expressionContext is an interface to support dynamic dispatch.
type IEvent_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_expressionContext differentiates from other interfaces.
	IsEvent_expressionContext()
}

type Event_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_expressionContext() *Event_expressionContext {
	var p = new(Event_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_expression
	return p
}

func (*Event_expressionContext) IsEvent_expressionContext() {}

func NewEvent_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_expressionContext {
	var p = new(Event_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_expression

	return p
}

func (s *Event_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Event_expressionContext) POSEDGE() antlr.TerminalNode {
	return s.GetToken(VerilogParserPOSEDGE, 0)
}

func (s *Event_expressionContext) NEGEDGE() antlr.TerminalNode {
	return s.GetToken(VerilogParserNEGEDGE, 0)
}

func (s *Event_expressionContext) AllEvent_expression() []IEvent_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvent_expressionContext)(nil)).Elem())
	var tst = make([]IEvent_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvent_expressionContext)
		}
	}

	return tst
}

func (s *Event_expressionContext) Event_expression(i int) IEvent_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvent_expressionContext)
}

func (s *Event_expressionContext) OR() antlr.TerminalNode {
	return s.GetToken(VerilogParserOR, 0)
}

func (s *Event_expressionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, 0)
}

func (s *Event_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEvent_expression(s)
	}
}

func (s *Event_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEvent_expression(s)
	}
}

func (p *VerilogParser) Event_expression() (localctx IEvent_expressionContext) {
	return p.event_expression(0)
}

func (p *VerilogParser) event_expression(_p int) (localctx IEvent_expressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewEvent_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IEvent_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 442
	p.EnterRecursionRule(localctx, 442, VerilogParserRULE_event_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3194)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserDOLLAR_BITSTOREAL, VerilogParserDOLLAR_ITOR, VerilogParserDOLLAR_SIGNED, VerilogParserDOLLAR_REALTOBITS, VerilogParserDOLLAR_RTOI, VerilogParserDOLLAR_UNSIGNED, VerilogParserDOLLAR_RANDOM, VerilogParserDOLLAR_DIST_ERLANG, VerilogParserDOLLAR_DIST_NORMAL, VerilogParserDOLLAR_DIST_T, VerilogParserDOLLAR_DIST_CHI_SQUARE, VerilogParserDOLLAR_DIST_EXPONENTIAL, VerilogParserDOLLAR_DIST_POISSON, VerilogParserDOLLAR_DIST_UNIFORM, VerilogParserDOLLAR_CLOG2, VerilogParserDOLLAR_LN, VerilogParserDOLLAR_LOG10, VerilogParserDOLLAR_EXP, VerilogParserDOLLAR_SQRT, VerilogParserDOLLAR_POW, VerilogParserDOLLAR_FLOOR, VerilogParserDOLLAR_CEIL, VerilogParserDOLLAR_SIN, VerilogParserDOLLAR_COS, VerilogParserDOLLAR_TAN, VerilogParserDOLLAR_ASIN, VerilogParserDOLLAR_ACOS, VerilogParserDOLLAR_ATAN, VerilogParserDOLLAR_ATAN2, VerilogParserDOLLAR_HYPOT, VerilogParserDOLLAR_SINH, VerilogParserDOLLAR_COSH, VerilogParserDOLLAR_TANH, VerilogParserDOLLAR_ASINH, VerilogParserDOLLAR_ACOSH, VerilogParserDOLLAR_ATANH, VerilogParserREAL_NUMBER, VerilogParserDECIMAL_NUMBER, VerilogParserBINARY_NUMBER, VerilogParserOCTAL_NUMBER, VerilogParserHEX_NUMBER, VerilogParserSTRING, VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER, VerilogParserSYSTEM_TF_IDENTIFIER, VerilogParserLEFT_PARENTHESIS, VerilogParserLEFT_BRACE, VerilogParserPLUS, VerilogParserMINUS, VerilogParserEXCLAMATION_MARK, VerilogParserTILDE, VerilogParserAMPERSAND, VerilogParserTILDE_AMPERSAND, VerilogParserVERTICAL_BAR, VerilogParserTILDE_VERTICAL_BAR, VerilogParserCARET, VerilogParserTILDE_CARET, VerilogParserCARET_TILDE:
		{
			p.SetState(3189)
			p.expression(0)
		}

	case VerilogParserPOSEDGE:
		{
			p.SetState(3190)
			p.Match(VerilogParserPOSEDGE)
		}
		{
			p.SetState(3191)
			p.expression(0)
		}

	case VerilogParserNEGEDGE:
		{
			p.SetState(3192)
			p.Match(VerilogParserNEGEDGE)
		}
		{
			p.SetState(3193)
			p.expression(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3204)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 323, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3202)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 322, p.GetParserRuleContext()) {
			case 1:
				localctx = NewEvent_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, VerilogParserRULE_event_expression)
				p.SetState(3196)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(3197)
					p.Match(VerilogParserOR)
				}
				{
					p.SetState(3198)
					p.event_expression(3)
				}

			case 2:
				localctx = NewEvent_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, VerilogParserRULE_event_expression)
				p.SetState(3199)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(3200)
					p.Match(VerilogParserCOMMA)
				}
				{
					p.SetState(3201)
					p.event_expression(2)
				}

			}

		}
		p.SetState(3206)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 323, p.GetParserRuleContext())
	}

	return localctx
}

// IEvent_primaryContext is an interface to support dynamic dispatch.
type IEvent_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_primaryContext differentiates from other interfaces.
	IsEvent_primaryContext()
}

type Event_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_primaryContext() *Event_primaryContext {
	var p = new(Event_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_primary
	return p
}

func (*Event_primaryContext) IsEvent_primaryContext() {}

func NewEvent_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_primaryContext {
	var p = new(Event_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_primary

	return p
}

func (s *Event_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_primaryContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Event_primaryContext) POSEDGE() antlr.TerminalNode {
	return s.GetToken(VerilogParserPOSEDGE, 0)
}

func (s *Event_primaryContext) NEGEDGE() antlr.TerminalNode {
	return s.GetToken(VerilogParserNEGEDGE, 0)
}

func (s *Event_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEvent_primary(s)
	}
}

func (s *Event_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEvent_primary(s)
	}
}

func (p *VerilogParser) Event_primary() (localctx IEvent_primaryContext) {
	this := p
	_ = this

	localctx = NewEvent_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, VerilogParserRULE_event_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3212)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserDOLLAR_BITSTOREAL, VerilogParserDOLLAR_ITOR, VerilogParserDOLLAR_SIGNED, VerilogParserDOLLAR_REALTOBITS, VerilogParserDOLLAR_RTOI, VerilogParserDOLLAR_UNSIGNED, VerilogParserDOLLAR_RANDOM, VerilogParserDOLLAR_DIST_ERLANG, VerilogParserDOLLAR_DIST_NORMAL, VerilogParserDOLLAR_DIST_T, VerilogParserDOLLAR_DIST_CHI_SQUARE, VerilogParserDOLLAR_DIST_EXPONENTIAL, VerilogParserDOLLAR_DIST_POISSON, VerilogParserDOLLAR_DIST_UNIFORM, VerilogParserDOLLAR_CLOG2, VerilogParserDOLLAR_LN, VerilogParserDOLLAR_LOG10, VerilogParserDOLLAR_EXP, VerilogParserDOLLAR_SQRT, VerilogParserDOLLAR_POW, VerilogParserDOLLAR_FLOOR, VerilogParserDOLLAR_CEIL, VerilogParserDOLLAR_SIN, VerilogParserDOLLAR_COS, VerilogParserDOLLAR_TAN, VerilogParserDOLLAR_ASIN, VerilogParserDOLLAR_ACOS, VerilogParserDOLLAR_ATAN, VerilogParserDOLLAR_ATAN2, VerilogParserDOLLAR_HYPOT, VerilogParserDOLLAR_SINH, VerilogParserDOLLAR_COSH, VerilogParserDOLLAR_TANH, VerilogParserDOLLAR_ASINH, VerilogParserDOLLAR_ACOSH, VerilogParserDOLLAR_ATANH, VerilogParserREAL_NUMBER, VerilogParserDECIMAL_NUMBER, VerilogParserBINARY_NUMBER, VerilogParserOCTAL_NUMBER, VerilogParserHEX_NUMBER, VerilogParserSTRING, VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER, VerilogParserSYSTEM_TF_IDENTIFIER, VerilogParserLEFT_PARENTHESIS, VerilogParserLEFT_BRACE, VerilogParserPLUS, VerilogParserMINUS, VerilogParserEXCLAMATION_MARK, VerilogParserTILDE, VerilogParserAMPERSAND, VerilogParserTILDE_AMPERSAND, VerilogParserVERTICAL_BAR, VerilogParserTILDE_VERTICAL_BAR, VerilogParserCARET, VerilogParserTILDE_CARET, VerilogParserCARET_TILDE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3207)
			p.expression(0)
		}

	case VerilogParserPOSEDGE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3208)
			p.Match(VerilogParserPOSEDGE)
		}
		{
			p.SetState(3209)
			p.expression(0)
		}

	case VerilogParserNEGEDGE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3210)
			p.Match(VerilogParserNEGEDGE)
		}
		{
			p.SetState(3211)
			p.expression(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedural_timing_controlContext is an interface to support dynamic dispatch.
type IProcedural_timing_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_timing_controlContext differentiates from other interfaces.
	IsProcedural_timing_controlContext()
}

type Procedural_timing_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_timing_controlContext() *Procedural_timing_controlContext {
	var p = new(Procedural_timing_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_procedural_timing_control
	return p
}

func (*Procedural_timing_controlContext) IsProcedural_timing_controlContext() {}

func NewProcedural_timing_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_timing_controlContext {
	var p = new(Procedural_timing_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_procedural_timing_control

	return p
}

func (s *Procedural_timing_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_timing_controlContext) Delay_control() IDelay_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_controlContext)
}

func (s *Procedural_timing_controlContext) Event_control() IEvent_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_controlContext)
}

func (s *Procedural_timing_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_timing_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_timing_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterProcedural_timing_control(s)
	}
}

func (s *Procedural_timing_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitProcedural_timing_control(s)
	}
}

func (p *VerilogParser) Procedural_timing_control() (localctx IProcedural_timing_controlContext) {
	this := p
	_ = this

	localctx = NewProcedural_timing_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, VerilogParserRULE_procedural_timing_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3216)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserHASH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3214)
			p.Delay_control()
		}

	case VerilogParserAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3215)
			p.Event_control()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedural_timing_control_statementContext is an interface to support dynamic dispatch.
type IProcedural_timing_control_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_timing_control_statementContext differentiates from other interfaces.
	IsProcedural_timing_control_statementContext()
}

type Procedural_timing_control_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_timing_control_statementContext() *Procedural_timing_control_statementContext {
	var p = new(Procedural_timing_control_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_procedural_timing_control_statement
	return p
}

func (*Procedural_timing_control_statementContext) IsProcedural_timing_control_statementContext() {}

func NewProcedural_timing_control_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_timing_control_statementContext {
	var p = new(Procedural_timing_control_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_procedural_timing_control_statement

	return p
}

func (s *Procedural_timing_control_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_timing_control_statementContext) Procedural_timing_control() IProcedural_timing_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_timing_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_timing_controlContext)
}

func (s *Procedural_timing_control_statementContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Procedural_timing_control_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_timing_control_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_timing_control_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterProcedural_timing_control_statement(s)
	}
}

func (s *Procedural_timing_control_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitProcedural_timing_control_statement(s)
	}
}

func (p *VerilogParser) Procedural_timing_control_statement() (localctx IProcedural_timing_control_statementContext) {
	this := p
	_ = this

	localctx = NewProcedural_timing_control_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, VerilogParserRULE_procedural_timing_control_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3218)
		p.Procedural_timing_control()
	}
	{
		p.SetState(3219)
		p.Statement_or_null()
	}

	return localctx
}

// IWait_statementContext is an interface to support dynamic dispatch.
type IWait_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWait_statementContext differentiates from other interfaces.
	IsWait_statementContext()
}

type Wait_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWait_statementContext() *Wait_statementContext {
	var p = new(Wait_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_wait_statement
	return p
}

func (*Wait_statementContext) IsWait_statementContext() {}

func NewWait_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Wait_statementContext {
	var p = new(Wait_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_wait_statement

	return p
}

func (s *Wait_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Wait_statementContext) WAIT() antlr.TerminalNode {
	return s.GetToken(VerilogParserWAIT, 0)
}

func (s *Wait_statementContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Wait_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Wait_statementContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Wait_statementContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Wait_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wait_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Wait_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterWait_statement(s)
	}
}

func (s *Wait_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitWait_statement(s)
	}
}

func (p *VerilogParser) Wait_statement() (localctx IWait_statementContext) {
	this := p
	_ = this

	localctx = NewWait_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, VerilogParserRULE_wait_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3221)
		p.Match(VerilogParserWAIT)
	}
	{
		p.SetState(3222)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(3223)
		p.expression(0)
	}
	{
		p.SetState(3224)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}
	{
		p.SetState(3225)
		p.Statement_or_null()
	}

	return localctx
}

// IConditional_statementContext is an interface to support dynamic dispatch.
type IConditional_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_statementContext differentiates from other interfaces.
	IsConditional_statementContext()
}

type Conditional_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_statementContext() *Conditional_statementContext {
	var p = new(Conditional_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_conditional_statement
	return p
}

func (*Conditional_statementContext) IsConditional_statementContext() {}

func NewConditional_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_statementContext {
	var p = new(Conditional_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_conditional_statement

	return p
}

func (s *Conditional_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_statementContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserIF)
}

func (s *Conditional_statementContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserIF, i)
}

func (s *Conditional_statementContext) AllLEFT_PARENTHESIS() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLEFT_PARENTHESIS)
}

func (s *Conditional_statementContext) LEFT_PARENTHESIS(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, i)
}

func (s *Conditional_statementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Conditional_statementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Conditional_statementContext) AllRIGHT_PARENTHESIS() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRIGHT_PARENTHESIS)
}

func (s *Conditional_statementContext) RIGHT_PARENTHESIS(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, i)
}

func (s *Conditional_statementContext) AllStatement_or_null() []IStatement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem())
	var tst = make([]IStatement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_or_nullContext)
		}
	}

	return tst
}

func (s *Conditional_statementContext) Statement_or_null(i int) IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Conditional_statementContext) AllELSE() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserELSE)
}

func (s *Conditional_statementContext) ELSE(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserELSE, i)
}

func (s *Conditional_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConditional_statement(s)
	}
}

func (s *Conditional_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConditional_statement(s)
	}
}

func (p *VerilogParser) Conditional_statement() (localctx IConditional_statementContext) {
	this := p
	_ = this

	localctx = NewConditional_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, VerilogParserRULE_conditional_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3227)
		p.Match(VerilogParserIF)
	}
	{
		p.SetState(3228)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(3229)
		p.expression(0)
	}
	{
		p.SetState(3230)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}
	{
		p.SetState(3231)
		p.Statement_or_null()
	}
	p.SetState(3241)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 326, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3232)
				p.Match(VerilogParserELSE)
			}
			{
				p.SetState(3233)
				p.Match(VerilogParserIF)
			}
			{
				p.SetState(3234)
				p.Match(VerilogParserLEFT_PARENTHESIS)
			}
			{
				p.SetState(3235)
				p.expression(0)
			}
			{
				p.SetState(3236)
				p.Match(VerilogParserRIGHT_PARENTHESIS)
			}
			{
				p.SetState(3237)
				p.Statement_or_null()
			}

		}
		p.SetState(3243)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 326, p.GetParserRuleContext())
	}
	p.SetState(3246)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 327, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3244)
			p.Match(VerilogParserELSE)
		}
		{
			p.SetState(3245)
			p.Statement_or_null()
		}

	}

	return localctx
}

// ICase_statementContext is an interface to support dynamic dispatch.
type ICase_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_statementContext differentiates from other interfaces.
	IsCase_statementContext()
}

type Case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_statementContext() *Case_statementContext {
	var p = new(Case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_case_statement
	return p
}

func (*Case_statementContext) IsCase_statementContext() {}

func NewCase_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_statementContext {
	var p = new(Case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_case_statement

	return p
}

func (s *Case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_statementContext) CASE() antlr.TerminalNode {
	return s.GetToken(VerilogParserCASE, 0)
}

func (s *Case_statementContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Case_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_statementContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Case_statementContext) AllCase_item() []ICase_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_itemContext)(nil)).Elem())
	var tst = make([]ICase_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_itemContext)
		}
	}

	return tst
}

func (s *Case_statementContext) Case_item(i int) ICase_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_itemContext)
}

func (s *Case_statementContext) ENDCASE() antlr.TerminalNode {
	return s.GetToken(VerilogParserENDCASE, 0)
}

func (s *Case_statementContext) CASEZ() antlr.TerminalNode {
	return s.GetToken(VerilogParserCASEZ, 0)
}

func (s *Case_statementContext) CASEX() antlr.TerminalNode {
	return s.GetToken(VerilogParserCASEX, 0)
}

func (s *Case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCase_statement(s)
	}
}

func (s *Case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCase_statement(s)
	}
}

func (p *VerilogParser) Case_statement() (localctx ICase_statementContext) {
	this := p
	_ = this

	localctx = NewCase_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, VerilogParserRULE_case_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3287)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3248)
			p.Match(VerilogParserCASE)
		}
		{
			p.SetState(3249)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3250)
			p.expression(0)
		}
		{
			p.SetState(3251)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(3252)
			p.Case_item()
		}
		p.SetState(3256)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserDEFAULT || (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(VerilogParserDOLLAR_BITSTOREAL-209))|(1<<(VerilogParserDOLLAR_ITOR-209))|(1<<(VerilogParserDOLLAR_SIGNED-209))|(1<<(VerilogParserDOLLAR_REALTOBITS-209))|(1<<(VerilogParserDOLLAR_RTOI-209))|(1<<(VerilogParserDOLLAR_UNSIGNED-209))|(1<<(VerilogParserDOLLAR_RANDOM-209))|(1<<(VerilogParserDOLLAR_DIST_ERLANG-209))|(1<<(VerilogParserDOLLAR_DIST_NORMAL-209))|(1<<(VerilogParserDOLLAR_DIST_T-209))|(1<<(VerilogParserDOLLAR_DIST_CHI_SQUARE-209))|(1<<(VerilogParserDOLLAR_DIST_EXPONENTIAL-209))|(1<<(VerilogParserDOLLAR_DIST_POISSON-209))|(1<<(VerilogParserDOLLAR_DIST_UNIFORM-209))|(1<<(VerilogParserDOLLAR_CLOG2-209))|(1<<(VerilogParserDOLLAR_LN-209))|(1<<(VerilogParserDOLLAR_LOG10-209))|(1<<(VerilogParserDOLLAR_EXP-209))|(1<<(VerilogParserDOLLAR_SQRT-209))|(1<<(VerilogParserDOLLAR_POW-209))|(1<<(VerilogParserDOLLAR_FLOOR-209))|(1<<(VerilogParserDOLLAR_CEIL-209))|(1<<(VerilogParserDOLLAR_SIN-209))|(1<<(VerilogParserDOLLAR_COS-209))|(1<<(VerilogParserDOLLAR_TAN-209))|(1<<(VerilogParserDOLLAR_ASIN-209))|(1<<(VerilogParserDOLLAR_ACOS-209))|(1<<(VerilogParserDOLLAR_ATAN-209))|(1<<(VerilogParserDOLLAR_ATAN2-209))|(1<<(VerilogParserDOLLAR_HYPOT-209)))) != 0) || (((_la-241)&-(0x1f+1)) == 0 && ((1<<uint((_la-241)))&((1<<(VerilogParserDOLLAR_SINH-241))|(1<<(VerilogParserDOLLAR_COSH-241))|(1<<(VerilogParserDOLLAR_TANH-241))|(1<<(VerilogParserDOLLAR_ASINH-241))|(1<<(VerilogParserDOLLAR_ACOSH-241))|(1<<(VerilogParserDOLLAR_ATANH-241)))) != 0) || (((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282))|(1<<(VerilogParserSTRING-282))|(1<<(VerilogParserESCAPED_IDENTIFIER-282))|(1<<(VerilogParserSIMPLE_IDENTIFIER-282))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-282))|(1<<(VerilogParserLEFT_PARENTHESIS-282))|(1<<(VerilogParserLEFT_BRACE-282))|(1<<(VerilogParserPLUS-282))|(1<<(VerilogParserMINUS-282))|(1<<(VerilogParserEXCLAMATION_MARK-282))|(1<<(VerilogParserTILDE-282))|(1<<(VerilogParserAMPERSAND-282))|(1<<(VerilogParserTILDE_AMPERSAND-282))|(1<<(VerilogParserVERTICAL_BAR-282))|(1<<(VerilogParserTILDE_VERTICAL_BAR-282))|(1<<(VerilogParserCARET-282))|(1<<(VerilogParserTILDE_CARET-282))|(1<<(VerilogParserCARET_TILDE-282)))) != 0) {
			{
				p.SetState(3253)
				p.Case_item()
			}

			p.SetState(3258)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3259)
			p.Match(VerilogParserENDCASE)
		}

	case VerilogParserCASEZ:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3261)
			p.Match(VerilogParserCASEZ)
		}
		{
			p.SetState(3262)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3263)
			p.expression(0)
		}
		{
			p.SetState(3264)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(3265)
			p.Case_item()
		}
		p.SetState(3269)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserDEFAULT || (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(VerilogParserDOLLAR_BITSTOREAL-209))|(1<<(VerilogParserDOLLAR_ITOR-209))|(1<<(VerilogParserDOLLAR_SIGNED-209))|(1<<(VerilogParserDOLLAR_REALTOBITS-209))|(1<<(VerilogParserDOLLAR_RTOI-209))|(1<<(VerilogParserDOLLAR_UNSIGNED-209))|(1<<(VerilogParserDOLLAR_RANDOM-209))|(1<<(VerilogParserDOLLAR_DIST_ERLANG-209))|(1<<(VerilogParserDOLLAR_DIST_NORMAL-209))|(1<<(VerilogParserDOLLAR_DIST_T-209))|(1<<(VerilogParserDOLLAR_DIST_CHI_SQUARE-209))|(1<<(VerilogParserDOLLAR_DIST_EXPONENTIAL-209))|(1<<(VerilogParserDOLLAR_DIST_POISSON-209))|(1<<(VerilogParserDOLLAR_DIST_UNIFORM-209))|(1<<(VerilogParserDOLLAR_CLOG2-209))|(1<<(VerilogParserDOLLAR_LN-209))|(1<<(VerilogParserDOLLAR_LOG10-209))|(1<<(VerilogParserDOLLAR_EXP-209))|(1<<(VerilogParserDOLLAR_SQRT-209))|(1<<(VerilogParserDOLLAR_POW-209))|(1<<(VerilogParserDOLLAR_FLOOR-209))|(1<<(VerilogParserDOLLAR_CEIL-209))|(1<<(VerilogParserDOLLAR_SIN-209))|(1<<(VerilogParserDOLLAR_COS-209))|(1<<(VerilogParserDOLLAR_TAN-209))|(1<<(VerilogParserDOLLAR_ASIN-209))|(1<<(VerilogParserDOLLAR_ACOS-209))|(1<<(VerilogParserDOLLAR_ATAN-209))|(1<<(VerilogParserDOLLAR_ATAN2-209))|(1<<(VerilogParserDOLLAR_HYPOT-209)))) != 0) || (((_la-241)&-(0x1f+1)) == 0 && ((1<<uint((_la-241)))&((1<<(VerilogParserDOLLAR_SINH-241))|(1<<(VerilogParserDOLLAR_COSH-241))|(1<<(VerilogParserDOLLAR_TANH-241))|(1<<(VerilogParserDOLLAR_ASINH-241))|(1<<(VerilogParserDOLLAR_ACOSH-241))|(1<<(VerilogParserDOLLAR_ATANH-241)))) != 0) || (((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282))|(1<<(VerilogParserSTRING-282))|(1<<(VerilogParserESCAPED_IDENTIFIER-282))|(1<<(VerilogParserSIMPLE_IDENTIFIER-282))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-282))|(1<<(VerilogParserLEFT_PARENTHESIS-282))|(1<<(VerilogParserLEFT_BRACE-282))|(1<<(VerilogParserPLUS-282))|(1<<(VerilogParserMINUS-282))|(1<<(VerilogParserEXCLAMATION_MARK-282))|(1<<(VerilogParserTILDE-282))|(1<<(VerilogParserAMPERSAND-282))|(1<<(VerilogParserTILDE_AMPERSAND-282))|(1<<(VerilogParserVERTICAL_BAR-282))|(1<<(VerilogParserTILDE_VERTICAL_BAR-282))|(1<<(VerilogParserCARET-282))|(1<<(VerilogParserTILDE_CARET-282))|(1<<(VerilogParserCARET_TILDE-282)))) != 0) {
			{
				p.SetState(3266)
				p.Case_item()
			}

			p.SetState(3271)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3272)
			p.Match(VerilogParserENDCASE)
		}

	case VerilogParserCASEX:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3274)
			p.Match(VerilogParserCASEX)
		}
		{
			p.SetState(3275)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3276)
			p.expression(0)
		}
		{
			p.SetState(3277)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(3278)
			p.Case_item()
		}
		p.SetState(3282)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserDEFAULT || (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(VerilogParserDOLLAR_BITSTOREAL-209))|(1<<(VerilogParserDOLLAR_ITOR-209))|(1<<(VerilogParserDOLLAR_SIGNED-209))|(1<<(VerilogParserDOLLAR_REALTOBITS-209))|(1<<(VerilogParserDOLLAR_RTOI-209))|(1<<(VerilogParserDOLLAR_UNSIGNED-209))|(1<<(VerilogParserDOLLAR_RANDOM-209))|(1<<(VerilogParserDOLLAR_DIST_ERLANG-209))|(1<<(VerilogParserDOLLAR_DIST_NORMAL-209))|(1<<(VerilogParserDOLLAR_DIST_T-209))|(1<<(VerilogParserDOLLAR_DIST_CHI_SQUARE-209))|(1<<(VerilogParserDOLLAR_DIST_EXPONENTIAL-209))|(1<<(VerilogParserDOLLAR_DIST_POISSON-209))|(1<<(VerilogParserDOLLAR_DIST_UNIFORM-209))|(1<<(VerilogParserDOLLAR_CLOG2-209))|(1<<(VerilogParserDOLLAR_LN-209))|(1<<(VerilogParserDOLLAR_LOG10-209))|(1<<(VerilogParserDOLLAR_EXP-209))|(1<<(VerilogParserDOLLAR_SQRT-209))|(1<<(VerilogParserDOLLAR_POW-209))|(1<<(VerilogParserDOLLAR_FLOOR-209))|(1<<(VerilogParserDOLLAR_CEIL-209))|(1<<(VerilogParserDOLLAR_SIN-209))|(1<<(VerilogParserDOLLAR_COS-209))|(1<<(VerilogParserDOLLAR_TAN-209))|(1<<(VerilogParserDOLLAR_ASIN-209))|(1<<(VerilogParserDOLLAR_ACOS-209))|(1<<(VerilogParserDOLLAR_ATAN-209))|(1<<(VerilogParserDOLLAR_ATAN2-209))|(1<<(VerilogParserDOLLAR_HYPOT-209)))) != 0) || (((_la-241)&-(0x1f+1)) == 0 && ((1<<uint((_la-241)))&((1<<(VerilogParserDOLLAR_SINH-241))|(1<<(VerilogParserDOLLAR_COSH-241))|(1<<(VerilogParserDOLLAR_TANH-241))|(1<<(VerilogParserDOLLAR_ASINH-241))|(1<<(VerilogParserDOLLAR_ACOSH-241))|(1<<(VerilogParserDOLLAR_ATANH-241)))) != 0) || (((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282))|(1<<(VerilogParserSTRING-282))|(1<<(VerilogParserESCAPED_IDENTIFIER-282))|(1<<(VerilogParserSIMPLE_IDENTIFIER-282))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-282))|(1<<(VerilogParserLEFT_PARENTHESIS-282))|(1<<(VerilogParserLEFT_BRACE-282))|(1<<(VerilogParserPLUS-282))|(1<<(VerilogParserMINUS-282))|(1<<(VerilogParserEXCLAMATION_MARK-282))|(1<<(VerilogParserTILDE-282))|(1<<(VerilogParserAMPERSAND-282))|(1<<(VerilogParserTILDE_AMPERSAND-282))|(1<<(VerilogParserVERTICAL_BAR-282))|(1<<(VerilogParserTILDE_VERTICAL_BAR-282))|(1<<(VerilogParserCARET-282))|(1<<(VerilogParserTILDE_CARET-282))|(1<<(VerilogParserCARET_TILDE-282)))) != 0) {
			{
				p.SetState(3279)
				p.Case_item()
			}

			p.SetState(3284)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3285)
			p.Match(VerilogParserENDCASE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICase_itemContext is an interface to support dynamic dispatch.
type ICase_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_itemContext differentiates from other interfaces.
	IsCase_itemContext()
}

type Case_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_itemContext() *Case_itemContext {
	var p = new(Case_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_case_item
	return p
}

func (*Case_itemContext) IsCase_itemContext() {}

func NewCase_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_itemContext {
	var p = new(Case_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_case_item

	return p
}

func (s *Case_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_itemContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Case_itemContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_itemContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *Case_itemContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Case_itemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Case_itemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Case_itemContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(VerilogParserDEFAULT, 0)
}

func (s *Case_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCase_item(s)
	}
}

func (s *Case_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCase_item(s)
	}
}

func (p *VerilogParser) Case_item() (localctx ICase_itemContext) {
	this := p
	_ = this

	localctx = NewCase_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, VerilogParserRULE_case_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3305)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserDOLLAR_BITSTOREAL, VerilogParserDOLLAR_ITOR, VerilogParserDOLLAR_SIGNED, VerilogParserDOLLAR_REALTOBITS, VerilogParserDOLLAR_RTOI, VerilogParserDOLLAR_UNSIGNED, VerilogParserDOLLAR_RANDOM, VerilogParserDOLLAR_DIST_ERLANG, VerilogParserDOLLAR_DIST_NORMAL, VerilogParserDOLLAR_DIST_T, VerilogParserDOLLAR_DIST_CHI_SQUARE, VerilogParserDOLLAR_DIST_EXPONENTIAL, VerilogParserDOLLAR_DIST_POISSON, VerilogParserDOLLAR_DIST_UNIFORM, VerilogParserDOLLAR_CLOG2, VerilogParserDOLLAR_LN, VerilogParserDOLLAR_LOG10, VerilogParserDOLLAR_EXP, VerilogParserDOLLAR_SQRT, VerilogParserDOLLAR_POW, VerilogParserDOLLAR_FLOOR, VerilogParserDOLLAR_CEIL, VerilogParserDOLLAR_SIN, VerilogParserDOLLAR_COS, VerilogParserDOLLAR_TAN, VerilogParserDOLLAR_ASIN, VerilogParserDOLLAR_ACOS, VerilogParserDOLLAR_ATAN, VerilogParserDOLLAR_ATAN2, VerilogParserDOLLAR_HYPOT, VerilogParserDOLLAR_SINH, VerilogParserDOLLAR_COSH, VerilogParserDOLLAR_TANH, VerilogParserDOLLAR_ASINH, VerilogParserDOLLAR_ACOSH, VerilogParserDOLLAR_ATANH, VerilogParserREAL_NUMBER, VerilogParserDECIMAL_NUMBER, VerilogParserBINARY_NUMBER, VerilogParserOCTAL_NUMBER, VerilogParserHEX_NUMBER, VerilogParserSTRING, VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER, VerilogParserSYSTEM_TF_IDENTIFIER, VerilogParserLEFT_PARENTHESIS, VerilogParserLEFT_BRACE, VerilogParserPLUS, VerilogParserMINUS, VerilogParserEXCLAMATION_MARK, VerilogParserTILDE, VerilogParserAMPERSAND, VerilogParserTILDE_AMPERSAND, VerilogParserVERTICAL_BAR, VerilogParserTILDE_VERTICAL_BAR, VerilogParserCARET, VerilogParserTILDE_CARET, VerilogParserCARET_TILDE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3289)
			p.expression(0)
		}
		p.SetState(3294)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(3290)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(3291)
				p.expression(0)
			}

			p.SetState(3296)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3297)
			p.Match(VerilogParserCOLON)
		}
		{
			p.SetState(3298)
			p.Statement_or_null()
		}

	case VerilogParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3300)
			p.Match(VerilogParserDEFAULT)
		}
		p.SetState(3302)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserCOLON {
			{
				p.SetState(3301)
				p.Match(VerilogParserCOLON)
			}

		}
		{
			p.SetState(3304)
			p.Statement_or_null()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILoop_statementContext is an interface to support dynamic dispatch.
type ILoop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_statementContext differentiates from other interfaces.
	IsLoop_statementContext()
}

type Loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_statementContext() *Loop_statementContext {
	var p = new(Loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_loop_statement
	return p
}

func (*Loop_statementContext) IsLoop_statementContext() {}

func NewLoop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_statementContext {
	var p = new(Loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_loop_statement

	return p
}

func (s *Loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_statementContext) FOREVER() antlr.TerminalNode {
	return s.GetToken(VerilogParserFOREVER, 0)
}

func (s *Loop_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Loop_statementContext) REPEAT() antlr.TerminalNode {
	return s.GetToken(VerilogParserREPEAT, 0)
}

func (s *Loop_statementContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Loop_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Loop_statementContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Loop_statementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(VerilogParserWHILE, 0)
}

func (s *Loop_statementContext) FOR() antlr.TerminalNode {
	return s.GetToken(VerilogParserFOR, 0)
}

func (s *Loop_statementContext) AllVariable_assignment() []IVariable_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem())
	var tst = make([]IVariable_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_assignmentContext)
		}
	}

	return tst
}

func (s *Loop_statementContext) Variable_assignment(i int) IVariable_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignmentContext)
}

func (s *Loop_statementContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserSEMICOLON)
}

func (s *Loop_statementContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, i)
}

func (s *Loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLoop_statement(s)
	}
}

func (s *Loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLoop_statement(s)
	}
}

func (p *VerilogParser) Loop_statement() (localctx ILoop_statementContext) {
	this := p
	_ = this

	localctx = NewLoop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, VerilogParserRULE_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3331)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserFOREVER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3307)
			p.Match(VerilogParserFOREVER)
		}
		{
			p.SetState(3308)
			p.Statement()
		}

	case VerilogParserREPEAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3309)
			p.Match(VerilogParserREPEAT)
		}
		{
			p.SetState(3310)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3311)
			p.expression(0)
		}
		{
			p.SetState(3312)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(3313)
			p.Statement()
		}

	case VerilogParserWHILE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3315)
			p.Match(VerilogParserWHILE)
		}
		{
			p.SetState(3316)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3317)
			p.expression(0)
		}
		{
			p.SetState(3318)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(3319)
			p.Statement()
		}

	case VerilogParserFOR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3321)
			p.Match(VerilogParserFOR)
		}
		{
			p.SetState(3322)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3323)
			p.Variable_assignment()
		}
		{
			p.SetState(3324)
			p.Match(VerilogParserSEMICOLON)
		}
		{
			p.SetState(3325)
			p.expression(0)
		}
		{
			p.SetState(3326)
			p.Match(VerilogParserSEMICOLON)
		}
		{
			p.SetState(3327)
			p.Variable_assignment()
		}
		{
			p.SetState(3328)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(3329)
			p.Statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISystem_task_enableContext is an interface to support dynamic dispatch.
type ISystem_task_enableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_task_enableContext differentiates from other interfaces.
	IsSystem_task_enableContext()
}

type System_task_enableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_task_enableContext() *System_task_enableContext {
	var p = new(System_task_enableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_system_task_enable
	return p
}

func (*System_task_enableContext) IsSystem_task_enableContext() {}

func NewSystem_task_enableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_task_enableContext {
	var p = new(System_task_enableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_system_task_enable

	return p
}

func (s *System_task_enableContext) GetParser() antlr.Parser { return s.parser }

func (s *System_task_enableContext) System_task_identifier() ISystem_task_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_task_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_task_identifierContext)
}

func (s *System_task_enableContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *System_task_enableContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *System_task_enableContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *System_task_enableContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *System_task_enableContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *System_task_enableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *System_task_enableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *System_task_enableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_task_enableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_task_enableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSystem_task_enable(s)
	}
}

func (s *System_task_enableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSystem_task_enable(s)
	}
}

func (p *VerilogParser) System_task_enable() (localctx ISystem_task_enableContext) {
	this := p
	_ = this

	localctx = NewSystem_task_enableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, VerilogParserRULE_system_task_enable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3333)
		p.System_task_identifier()
	}
	p.SetState(3348)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_PARENTHESIS {
		{
			p.SetState(3334)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		p.SetState(3336)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(VerilogParserDOLLAR_BITSTOREAL-209))|(1<<(VerilogParserDOLLAR_ITOR-209))|(1<<(VerilogParserDOLLAR_SIGNED-209))|(1<<(VerilogParserDOLLAR_REALTOBITS-209))|(1<<(VerilogParserDOLLAR_RTOI-209))|(1<<(VerilogParserDOLLAR_UNSIGNED-209))|(1<<(VerilogParserDOLLAR_RANDOM-209))|(1<<(VerilogParserDOLLAR_DIST_ERLANG-209))|(1<<(VerilogParserDOLLAR_DIST_NORMAL-209))|(1<<(VerilogParserDOLLAR_DIST_T-209))|(1<<(VerilogParserDOLLAR_DIST_CHI_SQUARE-209))|(1<<(VerilogParserDOLLAR_DIST_EXPONENTIAL-209))|(1<<(VerilogParserDOLLAR_DIST_POISSON-209))|(1<<(VerilogParserDOLLAR_DIST_UNIFORM-209))|(1<<(VerilogParserDOLLAR_CLOG2-209))|(1<<(VerilogParserDOLLAR_LN-209))|(1<<(VerilogParserDOLLAR_LOG10-209))|(1<<(VerilogParserDOLLAR_EXP-209))|(1<<(VerilogParserDOLLAR_SQRT-209))|(1<<(VerilogParserDOLLAR_POW-209))|(1<<(VerilogParserDOLLAR_FLOOR-209))|(1<<(VerilogParserDOLLAR_CEIL-209))|(1<<(VerilogParserDOLLAR_SIN-209))|(1<<(VerilogParserDOLLAR_COS-209))|(1<<(VerilogParserDOLLAR_TAN-209))|(1<<(VerilogParserDOLLAR_ASIN-209))|(1<<(VerilogParserDOLLAR_ACOS-209))|(1<<(VerilogParserDOLLAR_ATAN-209))|(1<<(VerilogParserDOLLAR_ATAN2-209))|(1<<(VerilogParserDOLLAR_HYPOT-209)))) != 0) || (((_la-241)&-(0x1f+1)) == 0 && ((1<<uint((_la-241)))&((1<<(VerilogParserDOLLAR_SINH-241))|(1<<(VerilogParserDOLLAR_COSH-241))|(1<<(VerilogParserDOLLAR_TANH-241))|(1<<(VerilogParserDOLLAR_ASINH-241))|(1<<(VerilogParserDOLLAR_ACOSH-241))|(1<<(VerilogParserDOLLAR_ATANH-241)))) != 0) || (((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282))|(1<<(VerilogParserSTRING-282))|(1<<(VerilogParserESCAPED_IDENTIFIER-282))|(1<<(VerilogParserSIMPLE_IDENTIFIER-282))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-282))|(1<<(VerilogParserLEFT_PARENTHESIS-282))|(1<<(VerilogParserLEFT_BRACE-282))|(1<<(VerilogParserPLUS-282))|(1<<(VerilogParserMINUS-282))|(1<<(VerilogParserEXCLAMATION_MARK-282))|(1<<(VerilogParserTILDE-282))|(1<<(VerilogParserAMPERSAND-282))|(1<<(VerilogParserTILDE_AMPERSAND-282))|(1<<(VerilogParserVERTICAL_BAR-282))|(1<<(VerilogParserTILDE_VERTICAL_BAR-282))|(1<<(VerilogParserCARET-282))|(1<<(VerilogParserTILDE_CARET-282))|(1<<(VerilogParserCARET_TILDE-282)))) != 0) {
			{
				p.SetState(3335)
				p.expression(0)
			}

		}
		p.SetState(3344)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(3338)
				p.Match(VerilogParserCOMMA)
			}
			p.SetState(3340)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(VerilogParserDOLLAR_BITSTOREAL-209))|(1<<(VerilogParserDOLLAR_ITOR-209))|(1<<(VerilogParserDOLLAR_SIGNED-209))|(1<<(VerilogParserDOLLAR_REALTOBITS-209))|(1<<(VerilogParserDOLLAR_RTOI-209))|(1<<(VerilogParserDOLLAR_UNSIGNED-209))|(1<<(VerilogParserDOLLAR_RANDOM-209))|(1<<(VerilogParserDOLLAR_DIST_ERLANG-209))|(1<<(VerilogParserDOLLAR_DIST_NORMAL-209))|(1<<(VerilogParserDOLLAR_DIST_T-209))|(1<<(VerilogParserDOLLAR_DIST_CHI_SQUARE-209))|(1<<(VerilogParserDOLLAR_DIST_EXPONENTIAL-209))|(1<<(VerilogParserDOLLAR_DIST_POISSON-209))|(1<<(VerilogParserDOLLAR_DIST_UNIFORM-209))|(1<<(VerilogParserDOLLAR_CLOG2-209))|(1<<(VerilogParserDOLLAR_LN-209))|(1<<(VerilogParserDOLLAR_LOG10-209))|(1<<(VerilogParserDOLLAR_EXP-209))|(1<<(VerilogParserDOLLAR_SQRT-209))|(1<<(VerilogParserDOLLAR_POW-209))|(1<<(VerilogParserDOLLAR_FLOOR-209))|(1<<(VerilogParserDOLLAR_CEIL-209))|(1<<(VerilogParserDOLLAR_SIN-209))|(1<<(VerilogParserDOLLAR_COS-209))|(1<<(VerilogParserDOLLAR_TAN-209))|(1<<(VerilogParserDOLLAR_ASIN-209))|(1<<(VerilogParserDOLLAR_ACOS-209))|(1<<(VerilogParserDOLLAR_ATAN-209))|(1<<(VerilogParserDOLLAR_ATAN2-209))|(1<<(VerilogParserDOLLAR_HYPOT-209)))) != 0) || (((_la-241)&-(0x1f+1)) == 0 && ((1<<uint((_la-241)))&((1<<(VerilogParserDOLLAR_SINH-241))|(1<<(VerilogParserDOLLAR_COSH-241))|(1<<(VerilogParserDOLLAR_TANH-241))|(1<<(VerilogParserDOLLAR_ASINH-241))|(1<<(VerilogParserDOLLAR_ACOSH-241))|(1<<(VerilogParserDOLLAR_ATANH-241)))) != 0) || (((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282))|(1<<(VerilogParserSTRING-282))|(1<<(VerilogParserESCAPED_IDENTIFIER-282))|(1<<(VerilogParserSIMPLE_IDENTIFIER-282))|(1<<(VerilogParserSYSTEM_TF_IDENTIFIER-282))|(1<<(VerilogParserLEFT_PARENTHESIS-282))|(1<<(VerilogParserLEFT_BRACE-282))|(1<<(VerilogParserPLUS-282))|(1<<(VerilogParserMINUS-282))|(1<<(VerilogParserEXCLAMATION_MARK-282))|(1<<(VerilogParserTILDE-282))|(1<<(VerilogParserAMPERSAND-282))|(1<<(VerilogParserTILDE_AMPERSAND-282))|(1<<(VerilogParserVERTICAL_BAR-282))|(1<<(VerilogParserTILDE_VERTICAL_BAR-282))|(1<<(VerilogParserCARET-282))|(1<<(VerilogParserTILDE_CARET-282))|(1<<(VerilogParserCARET_TILDE-282)))) != 0) {
				{
					p.SetState(3339)
					p.expression(0)
				}

			}

			p.SetState(3346)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3347)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}
	{
		p.SetState(3350)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// ITask_enableContext is an interface to support dynamic dispatch.
type ITask_enableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_enableContext differentiates from other interfaces.
	IsTask_enableContext()
}

type Task_enableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_enableContext() *Task_enableContext {
	var p = new(Task_enableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_enable
	return p
}

func (*Task_enableContext) IsTask_enableContext() {}

func NewTask_enableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_enableContext {
	var p = new(Task_enableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_enable

	return p
}

func (s *Task_enableContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_enableContext) Hierarchical_task_identifier() IHierarchical_task_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_task_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_task_identifierContext)
}

func (s *Task_enableContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Task_enableContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Task_enableContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Task_enableContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Task_enableContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Task_enableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Task_enableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Task_enableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_enableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_enableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTask_enable(s)
	}
}

func (s *Task_enableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTask_enable(s)
	}
}

func (p *VerilogParser) Task_enable() (localctx ITask_enableContext) {
	this := p
	_ = this

	localctx = NewTask_enableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, VerilogParserRULE_task_enable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3352)
		p.Hierarchical_task_identifier()
	}
	p.SetState(3364)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_PARENTHESIS {
		{
			p.SetState(3353)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3354)
			p.expression(0)
		}
		p.SetState(3359)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(3355)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(3356)
				p.expression(0)
			}

			p.SetState(3361)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3362)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}
	{
		p.SetState(3366)
		p.Match(VerilogParserSEMICOLON)
	}

	return localctx
}

// ISpecify_blockContext is an interface to support dynamic dispatch.
type ISpecify_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_blockContext differentiates from other interfaces.
	IsSpecify_blockContext()
}

type Specify_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_blockContext() *Specify_blockContext {
	var p = new(Specify_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specify_block
	return p
}

func (*Specify_blockContext) IsSpecify_blockContext() {}

func NewSpecify_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_blockContext {
	var p = new(Specify_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specify_block

	return p
}

func (s *Specify_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_blockContext) SPECIFY() antlr.TerminalNode {
	return s.GetToken(VerilogParserSPECIFY, 0)
}

func (s *Specify_blockContext) ENDSPECIFY() antlr.TerminalNode {
	return s.GetToken(VerilogParserENDSPECIFY, 0)
}

func (s *Specify_blockContext) AllSpecify_item() []ISpecify_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecify_itemContext)(nil)).Elem())
	var tst = make([]ISpecify_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecify_itemContext)
		}
	}

	return tst
}

func (s *Specify_blockContext) Specify_item(i int) ISpecify_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecify_itemContext)
}

func (s *Specify_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecify_block(s)
	}
}

func (s *Specify_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecify_block(s)
	}
}

func (p *VerilogParser) Specify_block() (localctx ISpecify_blockContext) {
	this := p
	_ = this

	localctx = NewSpecify_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, VerilogParserRULE_specify_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3368)
		p.Match(VerilogParserSPECIFY)
	}
	p.SetState(3372)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(VerilogParserIF-42))|(1<<(VerilogParserIFNONE-42))|(1<<(VerilogParserNOSHOWCANCELLED-42)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(VerilogParserPULSESTYLE_ONEVENT-77))|(1<<(VerilogParserPULSESTYLE_ONDETECT-77))|(1<<(VerilogParserSHOWCANCELLED-77))|(1<<(VerilogParserSPECPARAM-77)))) != 0) || _la == VerilogParserLEFT_PARENTHESIS {
		{
			p.SetState(3369)
			p.Specify_item()
		}

		p.SetState(3374)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3375)
		p.Match(VerilogParserENDSPECIFY)
	}

	return localctx
}

// ISpecify_itemContext is an interface to support dynamic dispatch.
type ISpecify_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_itemContext differentiates from other interfaces.
	IsSpecify_itemContext()
}

type Specify_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_itemContext() *Specify_itemContext {
	var p = new(Specify_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specify_item
	return p
}

func (*Specify_itemContext) IsSpecify_itemContext() {}

func NewSpecify_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_itemContext {
	var p = new(Specify_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specify_item

	return p
}

func (s *Specify_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_itemContext) Specparam_declaration() ISpecparam_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_declarationContext)
}

func (s *Specify_itemContext) Pulsestyle_declaration() IPulsestyle_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPulsestyle_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPulsestyle_declarationContext)
}

func (s *Specify_itemContext) Showcancelled_declaration() IShowcancelled_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShowcancelled_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShowcancelled_declarationContext)
}

func (s *Specify_itemContext) Path_declaration() IPath_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_declarationContext)
}

func (s *Specify_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecify_item(s)
	}
}

func (s *Specify_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecify_item(s)
	}
}

func (p *VerilogParser) Specify_item() (localctx ISpecify_itemContext) {
	this := p
	_ = this

	localctx = NewSpecify_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, VerilogParserRULE_specify_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3381)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserSPECPARAM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3377)
			p.Specparam_declaration()
		}

	case VerilogParserPULSESTYLE_ONEVENT, VerilogParserPULSESTYLE_ONDETECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3378)
			p.Pulsestyle_declaration()
		}

	case VerilogParserNOSHOWCANCELLED, VerilogParserSHOWCANCELLED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3379)
			p.Showcancelled_declaration()
		}

	case VerilogParserIF, VerilogParserIFNONE, VerilogParserLEFT_PARENTHESIS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3380)
			p.Path_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPulsestyle_declarationContext is an interface to support dynamic dispatch.
type IPulsestyle_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPulsestyle_declarationContext differentiates from other interfaces.
	IsPulsestyle_declarationContext()
}

type Pulsestyle_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPulsestyle_declarationContext() *Pulsestyle_declarationContext {
	var p = new(Pulsestyle_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pulsestyle_declaration
	return p
}

func (*Pulsestyle_declarationContext) IsPulsestyle_declarationContext() {}

func NewPulsestyle_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pulsestyle_declarationContext {
	var p = new(Pulsestyle_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pulsestyle_declaration

	return p
}

func (s *Pulsestyle_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Pulsestyle_declarationContext) PULSESTYLE_ONEVENT() antlr.TerminalNode {
	return s.GetToken(VerilogParserPULSESTYLE_ONEVENT, 0)
}

func (s *Pulsestyle_declarationContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Pulsestyle_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Pulsestyle_declarationContext) PULSESTYLE_ONDETECT() antlr.TerminalNode {
	return s.GetToken(VerilogParserPULSESTYLE_ONDETECT, 0)
}

func (s *Pulsestyle_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pulsestyle_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pulsestyle_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPulsestyle_declaration(s)
	}
}

func (s *Pulsestyle_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPulsestyle_declaration(s)
	}
}

func (p *VerilogParser) Pulsestyle_declaration() (localctx IPulsestyle_declarationContext) {
	this := p
	_ = this

	localctx = NewPulsestyle_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, VerilogParserRULE_pulsestyle_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3391)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserPULSESTYLE_ONEVENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3383)
			p.Match(VerilogParserPULSESTYLE_ONEVENT)
		}
		{
			p.SetState(3384)
			p.List_of_path_outputs()
		}
		{
			p.SetState(3385)
			p.Match(VerilogParserSEMICOLON)
		}

	case VerilogParserPULSESTYLE_ONDETECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3387)
			p.Match(VerilogParserPULSESTYLE_ONDETECT)
		}
		{
			p.SetState(3388)
			p.List_of_path_outputs()
		}
		{
			p.SetState(3389)
			p.Match(VerilogParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IShowcancelled_declarationContext is an interface to support dynamic dispatch.
type IShowcancelled_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShowcancelled_declarationContext differentiates from other interfaces.
	IsShowcancelled_declarationContext()
}

type Showcancelled_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowcancelled_declarationContext() *Showcancelled_declarationContext {
	var p = new(Showcancelled_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_showcancelled_declaration
	return p
}

func (*Showcancelled_declarationContext) IsShowcancelled_declarationContext() {}

func NewShowcancelled_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Showcancelled_declarationContext {
	var p = new(Showcancelled_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_showcancelled_declaration

	return p
}

func (s *Showcancelled_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Showcancelled_declarationContext) SHOWCANCELLED() antlr.TerminalNode {
	return s.GetToken(VerilogParserSHOWCANCELLED, 0)
}

func (s *Showcancelled_declarationContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Showcancelled_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Showcancelled_declarationContext) NOSHOWCANCELLED() antlr.TerminalNode {
	return s.GetToken(VerilogParserNOSHOWCANCELLED, 0)
}

func (s *Showcancelled_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Showcancelled_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Showcancelled_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterShowcancelled_declaration(s)
	}
}

func (s *Showcancelled_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitShowcancelled_declaration(s)
	}
}

func (p *VerilogParser) Showcancelled_declaration() (localctx IShowcancelled_declarationContext) {
	this := p
	_ = this

	localctx = NewShowcancelled_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, VerilogParserRULE_showcancelled_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3401)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserSHOWCANCELLED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3393)
			p.Match(VerilogParserSHOWCANCELLED)
		}
		{
			p.SetState(3394)
			p.List_of_path_outputs()
		}
		{
			p.SetState(3395)
			p.Match(VerilogParserSEMICOLON)
		}

	case VerilogParserNOSHOWCANCELLED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3397)
			p.Match(VerilogParserNOSHOWCANCELLED)
		}
		{
			p.SetState(3398)
			p.List_of_path_outputs()
		}
		{
			p.SetState(3399)
			p.Match(VerilogParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPath_declarationContext is an interface to support dynamic dispatch.
type IPath_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPath_declarationContext differentiates from other interfaces.
	IsPath_declarationContext()
}

type Path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_declarationContext() *Path_declarationContext {
	var p = new(Path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_path_declaration
	return p
}

func (*Path_declarationContext) IsPath_declarationContext() {}

func NewPath_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_declarationContext {
	var p = new(Path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_path_declaration

	return p
}

func (s *Path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_declarationContext) Simple_path_declaration() ISimple_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_path_declarationContext)
}

func (s *Path_declarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserSEMICOLON, 0)
}

func (s *Path_declarationContext) Edge_sensitive_path_declaration() IEdge_sensitive_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_sensitive_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_sensitive_path_declarationContext)
}

func (s *Path_declarationContext) State_dependent_path_declaration() IState_dependent_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_dependent_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_dependent_path_declarationContext)
}

func (s *Path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPath_declaration(s)
	}
}

func (s *Path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPath_declaration(s)
	}
}

func (p *VerilogParser) Path_declaration() (localctx IPath_declarationContext) {
	this := p
	_ = this

	localctx = NewPath_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, VerilogParserRULE_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3412)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 346, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3403)
			p.Simple_path_declaration()
		}
		{
			p.SetState(3404)
			p.Match(VerilogParserSEMICOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3406)
			p.Edge_sensitive_path_declaration()
		}
		{
			p.SetState(3407)
			p.Match(VerilogParserSEMICOLON)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3409)
			p.State_dependent_path_declaration()
		}
		{
			p.SetState(3410)
			p.Match(VerilogParserSEMICOLON)
		}

	}

	return localctx
}

// ISimple_path_declarationContext is an interface to support dynamic dispatch.
type ISimple_path_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_path_declarationContext differentiates from other interfaces.
	IsSimple_path_declarationContext()
}

type Simple_path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_path_declarationContext() *Simple_path_declarationContext {
	var p = new(Simple_path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_simple_path_declaration
	return p
}

func (*Simple_path_declarationContext) IsSimple_path_declarationContext() {}

func NewSimple_path_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_path_declarationContext {
	var p = new(Simple_path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_simple_path_declaration

	return p
}

func (s *Simple_path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_path_declarationContext) Parallel_path_description() IParallel_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParallel_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParallel_path_descriptionContext)
}

func (s *Simple_path_declarationContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Simple_path_declarationContext) Path_delay_value() IPath_delay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_valueContext)
}

func (s *Simple_path_declarationContext) Full_path_description() IFull_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_path_descriptionContext)
}

func (s *Simple_path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSimple_path_declaration(s)
	}
}

func (s *Simple_path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSimple_path_declaration(s)
	}
}

func (p *VerilogParser) Simple_path_declaration() (localctx ISimple_path_declarationContext) {
	this := p
	_ = this

	localctx = NewSimple_path_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, VerilogParserRULE_simple_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3422)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 347, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3414)
			p.Parallel_path_description()
		}
		{
			p.SetState(3415)
			p.Match(VerilogParserEQUAL)
		}
		{
			p.SetState(3416)
			p.Path_delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3418)
			p.Full_path_description()
		}
		{
			p.SetState(3419)
			p.Match(VerilogParserEQUAL)
		}
		{
			p.SetState(3420)
			p.Path_delay_value()
		}

	}

	return localctx
}

// IParallel_path_descriptionContext is an interface to support dynamic dispatch.
type IParallel_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParallel_path_descriptionContext differentiates from other interfaces.
	IsParallel_path_descriptionContext()
}

type Parallel_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParallel_path_descriptionContext() *Parallel_path_descriptionContext {
	var p = new(Parallel_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parallel_path_description
	return p
}

func (*Parallel_path_descriptionContext) IsParallel_path_descriptionContext() {}

func NewParallel_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parallel_path_descriptionContext {
	var p = new(Parallel_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parallel_path_description

	return p
}

func (s *Parallel_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Parallel_path_descriptionContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Parallel_path_descriptionContext) Specify_input_terminal_descriptor() ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *Parallel_path_descriptionContext) EQUAL_GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL_GREATER_THAN, 0)
}

func (s *Parallel_path_descriptionContext) Specify_output_terminal_descriptor() ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *Parallel_path_descriptionContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Parallel_path_descriptionContext) Polarity_operator() IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Parallel_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parallel_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parallel_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParallel_path_description(s)
	}
}

func (s *Parallel_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParallel_path_description(s)
	}
}

func (p *VerilogParser) Parallel_path_description() (localctx IParallel_path_descriptionContext) {
	this := p
	_ = this

	localctx = NewParallel_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, VerilogParserRULE_parallel_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3424)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(3425)
		p.Specify_input_terminal_descriptor()
	}
	p.SetState(3427)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserPLUS || _la == VerilogParserMINUS {
		{
			p.SetState(3426)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(3429)
		p.Match(VerilogParserEQUAL_GREATER_THAN)
	}
	{
		p.SetState(3430)
		p.Specify_output_terminal_descriptor()
	}
	{
		p.SetState(3431)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IFull_path_descriptionContext is an interface to support dynamic dispatch.
type IFull_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFull_path_descriptionContext differentiates from other interfaces.
	IsFull_path_descriptionContext()
}

type Full_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFull_path_descriptionContext() *Full_path_descriptionContext {
	var p = new(Full_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_full_path_description
	return p
}

func (*Full_path_descriptionContext) IsFull_path_descriptionContext() {}

func NewFull_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Full_path_descriptionContext {
	var p = new(Full_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_full_path_description

	return p
}

func (s *Full_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Full_path_descriptionContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Full_path_descriptionContext) List_of_path_inputs() IList_of_path_inputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_inputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_inputsContext)
}

func (s *Full_path_descriptionContext) ASTERISK_GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserASTERISK_GREATER_THAN, 0)
}

func (s *Full_path_descriptionContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Full_path_descriptionContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Full_path_descriptionContext) Polarity_operator() IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Full_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Full_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Full_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFull_path_description(s)
	}
}

func (s *Full_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFull_path_description(s)
	}
}

func (p *VerilogParser) Full_path_description() (localctx IFull_path_descriptionContext) {
	this := p
	_ = this

	localctx = NewFull_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, VerilogParserRULE_full_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3433)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(3434)
		p.List_of_path_inputs()
	}
	p.SetState(3436)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserPLUS || _la == VerilogParserMINUS {
		{
			p.SetState(3435)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(3438)
		p.Match(VerilogParserASTERISK_GREATER_THAN)
	}
	{
		p.SetState(3439)
		p.List_of_path_outputs()
	}
	{
		p.SetState(3440)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IList_of_path_inputsContext is an interface to support dynamic dispatch.
type IList_of_path_inputsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_path_inputsContext differentiates from other interfaces.
	IsList_of_path_inputsContext()
}

type List_of_path_inputsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_path_inputsContext() *List_of_path_inputsContext {
	var p = new(List_of_path_inputsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_path_inputs
	return p
}

func (*List_of_path_inputsContext) IsList_of_path_inputsContext() {}

func NewList_of_path_inputsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_path_inputsContext {
	var p = new(List_of_path_inputsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_path_inputs

	return p
}

func (s *List_of_path_inputsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_path_inputsContext) AllSpecify_input_terminal_descriptor() []ISpecify_input_terminal_descriptorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem())
	var tst = make([]ISpecify_input_terminal_descriptorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecify_input_terminal_descriptorContext)
		}
	}

	return tst
}

func (s *List_of_path_inputsContext) Specify_input_terminal_descriptor(i int) ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *List_of_path_inputsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_path_inputsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_path_inputsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_path_inputsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_path_inputsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_path_inputs(s)
	}
}

func (s *List_of_path_inputsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_path_inputs(s)
	}
}

func (p *VerilogParser) List_of_path_inputs() (localctx IList_of_path_inputsContext) {
	this := p
	_ = this

	localctx = NewList_of_path_inputsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, VerilogParserRULE_list_of_path_inputs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3442)
		p.Specify_input_terminal_descriptor()
	}
	p.SetState(3447)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(3443)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3444)
			p.Specify_input_terminal_descriptor()
		}

		p.SetState(3449)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_path_outputsContext is an interface to support dynamic dispatch.
type IList_of_path_outputsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_path_outputsContext differentiates from other interfaces.
	IsList_of_path_outputsContext()
}

type List_of_path_outputsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_path_outputsContext() *List_of_path_outputsContext {
	var p = new(List_of_path_outputsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_path_outputs
	return p
}

func (*List_of_path_outputsContext) IsList_of_path_outputsContext() {}

func NewList_of_path_outputsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_path_outputsContext {
	var p = new(List_of_path_outputsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_path_outputs

	return p
}

func (s *List_of_path_outputsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_path_outputsContext) AllSpecify_output_terminal_descriptor() []ISpecify_output_terminal_descriptorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem())
	var tst = make([]ISpecify_output_terminal_descriptorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecify_output_terminal_descriptorContext)
		}
	}

	return tst
}

func (s *List_of_path_outputsContext) Specify_output_terminal_descriptor(i int) ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *List_of_path_outputsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_path_outputsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_path_outputsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_path_outputsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_path_outputsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_path_outputs(s)
	}
}

func (s *List_of_path_outputsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_path_outputs(s)
	}
}

func (p *VerilogParser) List_of_path_outputs() (localctx IList_of_path_outputsContext) {
	this := p
	_ = this

	localctx = NewList_of_path_outputsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, VerilogParserRULE_list_of_path_outputs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3450)
		p.Specify_output_terminal_descriptor()
	}
	p.SetState(3455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(3451)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3452)
			p.Specify_output_terminal_descriptor()
		}

		p.SetState(3457)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISpecify_input_terminal_descriptorContext is an interface to support dynamic dispatch.
type ISpecify_input_terminal_descriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_input_terminal_descriptorContext differentiates from other interfaces.
	IsSpecify_input_terminal_descriptorContext()
}

type Specify_input_terminal_descriptorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_input_terminal_descriptorContext() *Specify_input_terminal_descriptorContext {
	var p = new(Specify_input_terminal_descriptorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specify_input_terminal_descriptor
	return p
}

func (*Specify_input_terminal_descriptorContext) IsSpecify_input_terminal_descriptorContext() {}

func NewSpecify_input_terminal_descriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_input_terminal_descriptorContext {
	var p = new(Specify_input_terminal_descriptorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specify_input_terminal_descriptor

	return p
}

func (s *Specify_input_terminal_descriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_input_terminal_descriptorContext) Input_identifier() IInput_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_identifierContext)
}

func (s *Specify_input_terminal_descriptorContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACKET, 0)
}

func (s *Specify_input_terminal_descriptorContext) Constant_range_expression() IConstant_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_range_expressionContext)
}

func (s *Specify_input_terminal_descriptorContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACKET, 0)
}

func (s *Specify_input_terminal_descriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_input_terminal_descriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_input_terminal_descriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecify_input_terminal_descriptor(s)
	}
}

func (s *Specify_input_terminal_descriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecify_input_terminal_descriptor(s)
	}
}

func (p *VerilogParser) Specify_input_terminal_descriptor() (localctx ISpecify_input_terminal_descriptorContext) {
	this := p
	_ = this

	localctx = NewSpecify_input_terminal_descriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, VerilogParserRULE_specify_input_terminal_descriptor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3458)
		p.Input_identifier()
	}
	p.SetState(3463)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_BRACKET {
		{
			p.SetState(3459)
			p.Match(VerilogParserLEFT_BRACKET)
		}
		{
			p.SetState(3460)
			p.Constant_range_expression()
		}
		{
			p.SetState(3461)
			p.Match(VerilogParserRIGHT_BRACKET)
		}

	}

	return localctx
}

// ISpecify_output_terminal_descriptorContext is an interface to support dynamic dispatch.
type ISpecify_output_terminal_descriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_output_terminal_descriptorContext differentiates from other interfaces.
	IsSpecify_output_terminal_descriptorContext()
}

type Specify_output_terminal_descriptorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_output_terminal_descriptorContext() *Specify_output_terminal_descriptorContext {
	var p = new(Specify_output_terminal_descriptorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specify_output_terminal_descriptor
	return p
}

func (*Specify_output_terminal_descriptorContext) IsSpecify_output_terminal_descriptorContext() {}

func NewSpecify_output_terminal_descriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_output_terminal_descriptorContext {
	var p = new(Specify_output_terminal_descriptorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specify_output_terminal_descriptor

	return p
}

func (s *Specify_output_terminal_descriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_output_terminal_descriptorContext) Output_identifier() IOutput_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_identifierContext)
}

func (s *Specify_output_terminal_descriptorContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACKET, 0)
}

func (s *Specify_output_terminal_descriptorContext) Constant_range_expression() IConstant_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_range_expressionContext)
}

func (s *Specify_output_terminal_descriptorContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACKET, 0)
}

func (s *Specify_output_terminal_descriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_output_terminal_descriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_output_terminal_descriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecify_output_terminal_descriptor(s)
	}
}

func (s *Specify_output_terminal_descriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecify_output_terminal_descriptor(s)
	}
}

func (p *VerilogParser) Specify_output_terminal_descriptor() (localctx ISpecify_output_terminal_descriptorContext) {
	this := p
	_ = this

	localctx = NewSpecify_output_terminal_descriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, VerilogParserRULE_specify_output_terminal_descriptor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3465)
		p.Output_identifier()
	}
	p.SetState(3470)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLEFT_BRACKET {
		{
			p.SetState(3466)
			p.Match(VerilogParserLEFT_BRACKET)
		}
		{
			p.SetState(3467)
			p.Constant_range_expression()
		}
		{
			p.SetState(3468)
			p.Match(VerilogParserRIGHT_BRACKET)
		}

	}

	return localctx
}

// IInput_identifierContext is an interface to support dynamic dispatch.
type IInput_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_identifierContext differentiates from other interfaces.
	IsInput_identifierContext()
}

type Input_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_identifierContext() *Input_identifierContext {
	var p = new(Input_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_input_identifier
	return p
}

func (*Input_identifierContext) IsInput_identifierContext() {}

func NewInput_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_identifierContext {
	var p = new(Input_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_input_identifier

	return p
}

func (s *Input_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_identifierContext) Input_port_identifier() IInput_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_port_identifierContext)
}

func (s *Input_identifierContext) Inout_port_identifier() IInout_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_port_identifierContext)
}

func (s *Input_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInput_identifier(s)
	}
}

func (s *Input_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInput_identifier(s)
	}
}

func (p *VerilogParser) Input_identifier() (localctx IInput_identifierContext) {
	this := p
	_ = this

	localctx = NewInput_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, VerilogParserRULE_input_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3474)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 354, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3472)
			p.Input_port_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3473)
			p.Inout_port_identifier()
		}

	}

	return localctx
}

// IOutput_identifierContext is an interface to support dynamic dispatch.
type IOutput_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_identifierContext differentiates from other interfaces.
	IsOutput_identifierContext()
}

type Output_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_identifierContext() *Output_identifierContext {
	var p = new(Output_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_identifier
	return p
}

func (*Output_identifierContext) IsOutput_identifierContext() {}

func NewOutput_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_identifierContext {
	var p = new(Output_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_identifier

	return p
}

func (s *Output_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_identifierContext) Output_port_identifier() IOutput_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_port_identifierContext)
}

func (s *Output_identifierContext) Inout_port_identifier() IInout_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_port_identifierContext)
}

func (s *Output_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterOutput_identifier(s)
	}
}

func (s *Output_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitOutput_identifier(s)
	}
}

func (p *VerilogParser) Output_identifier() (localctx IOutput_identifierContext) {
	this := p
	_ = this

	localctx = NewOutput_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, VerilogParserRULE_output_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3478)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 355, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3476)
			p.Output_port_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3477)
			p.Inout_port_identifier()
		}

	}

	return localctx
}

// IPath_delay_valueContext is an interface to support dynamic dispatch.
type IPath_delay_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPath_delay_valueContext differentiates from other interfaces.
	IsPath_delay_valueContext()
}

type Path_delay_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_delay_valueContext() *Path_delay_valueContext {
	var p = new(Path_delay_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_path_delay_value
	return p
}

func (*Path_delay_valueContext) IsPath_delay_valueContext() {}

func NewPath_delay_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_delay_valueContext {
	var p = new(Path_delay_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_path_delay_value

	return p
}

func (s *Path_delay_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_delay_valueContext) List_of_path_delay_expressions() IList_of_path_delay_expressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_delay_expressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_delay_expressionsContext)
}

func (s *Path_delay_valueContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Path_delay_valueContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Path_delay_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_delay_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Path_delay_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPath_delay_value(s)
	}
}

func (s *Path_delay_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPath_delay_value(s)
	}
}

func (p *VerilogParser) Path_delay_value() (localctx IPath_delay_valueContext) {
	this := p
	_ = this

	localctx = NewPath_delay_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, VerilogParserRULE_path_delay_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3485)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 356, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3480)
			p.List_of_path_delay_expressions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3481)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3482)
			p.List_of_path_delay_expressions()
		}
		{
			p.SetState(3483)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}

	return localctx
}

// IList_of_path_delay_expressionsContext is an interface to support dynamic dispatch.
type IList_of_path_delay_expressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_path_delay_expressionsContext differentiates from other interfaces.
	IsList_of_path_delay_expressionsContext()
}

type List_of_path_delay_expressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_path_delay_expressionsContext() *List_of_path_delay_expressionsContext {
	var p = new(List_of_path_delay_expressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_path_delay_expressions
	return p
}

func (*List_of_path_delay_expressionsContext) IsList_of_path_delay_expressionsContext() {}

func NewList_of_path_delay_expressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_path_delay_expressionsContext {
	var p = new(List_of_path_delay_expressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_path_delay_expressions

	return p
}

func (s *List_of_path_delay_expressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_path_delay_expressionsContext) T_path_delay_expression() IT_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Trise_path_delay_expression() ITrise_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrise_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrise_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *List_of_path_delay_expressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *List_of_path_delay_expressionsContext) Tfall_path_delay_expression() ITfall_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITfall_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITfall_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tz_path_delay_expression() ITz_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITz_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITz_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T01_path_delay_expression() IT01_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT01_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT01_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T10_path_delay_expression() IT10_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT10_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT10_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T0z_path_delay_expression() IT0z_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT0z_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT0z_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tz1_path_delay_expression() ITz1_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITz1_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITz1_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T1z_path_delay_expression() IT1z_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT1z_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT1z_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tz0_path_delay_expression() ITz0_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITz0_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITz0_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T0x_path_delay_expression() IT0x_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT0x_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT0x_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tx1_path_delay_expression() ITx1_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITx1_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITx1_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T1x_path_delay_expression() IT1x_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT1x_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT1x_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tx0_path_delay_expression() ITx0_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITx0_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITx0_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Txz_path_delay_expression() ITxz_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITxz_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITxz_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tzx_path_delay_expression() ITzx_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITzx_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITzx_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_path_delay_expressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_path_delay_expressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_path_delay_expressions(s)
	}
}

func (s *List_of_path_delay_expressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_path_delay_expressions(s)
	}
}

func (p *VerilogParser) List_of_path_delay_expressions() (localctx IList_of_path_delay_expressionsContext) {
	this := p
	_ = this

	localctx = NewList_of_path_delay_expressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, VerilogParserRULE_list_of_path_delay_expressions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3534)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 357, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3487)
			p.T_path_delay_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3488)
			p.Trise_path_delay_expression()
		}
		{
			p.SetState(3489)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3490)
			p.Tfall_path_delay_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3492)
			p.Trise_path_delay_expression()
		}
		{
			p.SetState(3493)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3494)
			p.Tfall_path_delay_expression()
		}
		{
			p.SetState(3495)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3496)
			p.Tz_path_delay_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3498)
			p.T01_path_delay_expression()
		}
		{
			p.SetState(3499)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3500)
			p.T10_path_delay_expression()
		}
		{
			p.SetState(3501)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3502)
			p.T0z_path_delay_expression()
		}
		{
			p.SetState(3503)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3504)
			p.Tz1_path_delay_expression()
		}
		{
			p.SetState(3505)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3506)
			p.T1z_path_delay_expression()
		}
		{
			p.SetState(3507)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3508)
			p.Tz0_path_delay_expression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3510)
			p.T01_path_delay_expression()
		}
		{
			p.SetState(3511)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3512)
			p.T10_path_delay_expression()
		}
		{
			p.SetState(3513)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3514)
			p.T0z_path_delay_expression()
		}
		{
			p.SetState(3515)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3516)
			p.Tz1_path_delay_expression()
		}
		{
			p.SetState(3517)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3518)
			p.T1z_path_delay_expression()
		}
		{
			p.SetState(3519)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3520)
			p.Tz0_path_delay_expression()
		}
		{
			p.SetState(3521)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3522)
			p.T0x_path_delay_expression()
		}
		{
			p.SetState(3523)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3524)
			p.Tx1_path_delay_expression()
		}
		{
			p.SetState(3525)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3526)
			p.T1x_path_delay_expression()
		}
		{
			p.SetState(3527)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3528)
			p.Tx0_path_delay_expression()
		}
		{
			p.SetState(3529)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3530)
			p.Txz_path_delay_expression()
		}
		{
			p.SetState(3531)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3532)
			p.Tzx_path_delay_expression()
		}

	}

	return localctx
}

// IT_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT_path_delay_expressionContext differentiates from other interfaces.
	IsT_path_delay_expressionContext()
}

type T_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT_path_delay_expressionContext() *T_path_delay_expressionContext {
	var p = new(T_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t_path_delay_expression
	return p
}

func (*T_path_delay_expressionContext) IsT_path_delay_expressionContext() {}

func NewT_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T_path_delay_expressionContext {
	var p = new(T_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t_path_delay_expression

	return p
}

func (s *T_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterT_path_delay_expression(s)
	}
}

func (s *T_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitT_path_delay_expression(s)
	}
}

func (p *VerilogParser) T_path_delay_expression() (localctx IT_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewT_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, VerilogParserRULE_t_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3536)
		p.Path_delay_expression()
	}

	return localctx
}

// ITrise_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITrise_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrise_path_delay_expressionContext differentiates from other interfaces.
	IsTrise_path_delay_expressionContext()
}

type Trise_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrise_path_delay_expressionContext() *Trise_path_delay_expressionContext {
	var p = new(Trise_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_trise_path_delay_expression
	return p
}

func (*Trise_path_delay_expressionContext) IsTrise_path_delay_expressionContext() {}

func NewTrise_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trise_path_delay_expressionContext {
	var p = new(Trise_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_trise_path_delay_expression

	return p
}

func (s *Trise_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Trise_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Trise_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trise_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trise_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTrise_path_delay_expression(s)
	}
}

func (s *Trise_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTrise_path_delay_expression(s)
	}
}

func (p *VerilogParser) Trise_path_delay_expression() (localctx ITrise_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTrise_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, VerilogParserRULE_trise_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3538)
		p.Path_delay_expression()
	}

	return localctx
}

// ITfall_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITfall_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTfall_path_delay_expressionContext differentiates from other interfaces.
	IsTfall_path_delay_expressionContext()
}

type Tfall_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTfall_path_delay_expressionContext() *Tfall_path_delay_expressionContext {
	var p = new(Tfall_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tfall_path_delay_expression
	return p
}

func (*Tfall_path_delay_expressionContext) IsTfall_path_delay_expressionContext() {}

func NewTfall_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tfall_path_delay_expressionContext {
	var p = new(Tfall_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tfall_path_delay_expression

	return p
}

func (s *Tfall_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tfall_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tfall_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tfall_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tfall_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTfall_path_delay_expression(s)
	}
}

func (s *Tfall_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTfall_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tfall_path_delay_expression() (localctx ITfall_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTfall_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, VerilogParserRULE_tfall_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3540)
		p.Path_delay_expression()
	}

	return localctx
}

// ITz_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITz_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTz_path_delay_expressionContext differentiates from other interfaces.
	IsTz_path_delay_expressionContext()
}

type Tz_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTz_path_delay_expressionContext() *Tz_path_delay_expressionContext {
	var p = new(Tz_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tz_path_delay_expression
	return p
}

func (*Tz_path_delay_expressionContext) IsTz_path_delay_expressionContext() {}

func NewTz_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tz_path_delay_expressionContext {
	var p = new(Tz_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tz_path_delay_expression

	return p
}

func (s *Tz_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tz_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tz_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tz_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tz_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTz_path_delay_expression(s)
	}
}

func (s *Tz_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTz_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tz_path_delay_expression() (localctx ITz_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTz_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, VerilogParserRULE_tz_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3542)
		p.Path_delay_expression()
	}

	return localctx
}

// IT01_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT01_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT01_path_delay_expressionContext differentiates from other interfaces.
	IsT01_path_delay_expressionContext()
}

type T01_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT01_path_delay_expressionContext() *T01_path_delay_expressionContext {
	var p = new(T01_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t01_path_delay_expression
	return p
}

func (*T01_path_delay_expressionContext) IsT01_path_delay_expressionContext() {}

func NewT01_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T01_path_delay_expressionContext {
	var p = new(T01_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t01_path_delay_expression

	return p
}

func (s *T01_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T01_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T01_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T01_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T01_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterT01_path_delay_expression(s)
	}
}

func (s *T01_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitT01_path_delay_expression(s)
	}
}

func (p *VerilogParser) T01_path_delay_expression() (localctx IT01_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewT01_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, VerilogParserRULE_t01_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3544)
		p.Path_delay_expression()
	}

	return localctx
}

// IT10_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT10_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT10_path_delay_expressionContext differentiates from other interfaces.
	IsT10_path_delay_expressionContext()
}

type T10_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT10_path_delay_expressionContext() *T10_path_delay_expressionContext {
	var p = new(T10_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t10_path_delay_expression
	return p
}

func (*T10_path_delay_expressionContext) IsT10_path_delay_expressionContext() {}

func NewT10_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T10_path_delay_expressionContext {
	var p = new(T10_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t10_path_delay_expression

	return p
}

func (s *T10_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T10_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T10_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T10_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T10_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterT10_path_delay_expression(s)
	}
}

func (s *T10_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitT10_path_delay_expression(s)
	}
}

func (p *VerilogParser) T10_path_delay_expression() (localctx IT10_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewT10_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, VerilogParserRULE_t10_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3546)
		p.Path_delay_expression()
	}

	return localctx
}

// IT0z_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT0z_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT0z_path_delay_expressionContext differentiates from other interfaces.
	IsT0z_path_delay_expressionContext()
}

type T0z_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT0z_path_delay_expressionContext() *T0z_path_delay_expressionContext {
	var p = new(T0z_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t0z_path_delay_expression
	return p
}

func (*T0z_path_delay_expressionContext) IsT0z_path_delay_expressionContext() {}

func NewT0z_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T0z_path_delay_expressionContext {
	var p = new(T0z_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t0z_path_delay_expression

	return p
}

func (s *T0z_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T0z_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T0z_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T0z_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T0z_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterT0z_path_delay_expression(s)
	}
}

func (s *T0z_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitT0z_path_delay_expression(s)
	}
}

func (p *VerilogParser) T0z_path_delay_expression() (localctx IT0z_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewT0z_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, VerilogParserRULE_t0z_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3548)
		p.Path_delay_expression()
	}

	return localctx
}

// ITz1_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITz1_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTz1_path_delay_expressionContext differentiates from other interfaces.
	IsTz1_path_delay_expressionContext()
}

type Tz1_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTz1_path_delay_expressionContext() *Tz1_path_delay_expressionContext {
	var p = new(Tz1_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tz1_path_delay_expression
	return p
}

func (*Tz1_path_delay_expressionContext) IsTz1_path_delay_expressionContext() {}

func NewTz1_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tz1_path_delay_expressionContext {
	var p = new(Tz1_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tz1_path_delay_expression

	return p
}

func (s *Tz1_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tz1_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tz1_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tz1_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tz1_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTz1_path_delay_expression(s)
	}
}

func (s *Tz1_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTz1_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tz1_path_delay_expression() (localctx ITz1_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTz1_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, VerilogParserRULE_tz1_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3550)
		p.Path_delay_expression()
	}

	return localctx
}

// IT1z_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT1z_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT1z_path_delay_expressionContext differentiates from other interfaces.
	IsT1z_path_delay_expressionContext()
}

type T1z_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT1z_path_delay_expressionContext() *T1z_path_delay_expressionContext {
	var p = new(T1z_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t1z_path_delay_expression
	return p
}

func (*T1z_path_delay_expressionContext) IsT1z_path_delay_expressionContext() {}

func NewT1z_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T1z_path_delay_expressionContext {
	var p = new(T1z_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t1z_path_delay_expression

	return p
}

func (s *T1z_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T1z_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T1z_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T1z_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T1z_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterT1z_path_delay_expression(s)
	}
}

func (s *T1z_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitT1z_path_delay_expression(s)
	}
}

func (p *VerilogParser) T1z_path_delay_expression() (localctx IT1z_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewT1z_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, VerilogParserRULE_t1z_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3552)
		p.Path_delay_expression()
	}

	return localctx
}

// ITz0_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITz0_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTz0_path_delay_expressionContext differentiates from other interfaces.
	IsTz0_path_delay_expressionContext()
}

type Tz0_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTz0_path_delay_expressionContext() *Tz0_path_delay_expressionContext {
	var p = new(Tz0_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tz0_path_delay_expression
	return p
}

func (*Tz0_path_delay_expressionContext) IsTz0_path_delay_expressionContext() {}

func NewTz0_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tz0_path_delay_expressionContext {
	var p = new(Tz0_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tz0_path_delay_expression

	return p
}

func (s *Tz0_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tz0_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tz0_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tz0_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tz0_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTz0_path_delay_expression(s)
	}
}

func (s *Tz0_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTz0_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tz0_path_delay_expression() (localctx ITz0_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTz0_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, VerilogParserRULE_tz0_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3554)
		p.Path_delay_expression()
	}

	return localctx
}

// IT0x_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT0x_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT0x_path_delay_expressionContext differentiates from other interfaces.
	IsT0x_path_delay_expressionContext()
}

type T0x_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT0x_path_delay_expressionContext() *T0x_path_delay_expressionContext {
	var p = new(T0x_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t0x_path_delay_expression
	return p
}

func (*T0x_path_delay_expressionContext) IsT0x_path_delay_expressionContext() {}

func NewT0x_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T0x_path_delay_expressionContext {
	var p = new(T0x_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t0x_path_delay_expression

	return p
}

func (s *T0x_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T0x_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T0x_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T0x_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T0x_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterT0x_path_delay_expression(s)
	}
}

func (s *T0x_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitT0x_path_delay_expression(s)
	}
}

func (p *VerilogParser) T0x_path_delay_expression() (localctx IT0x_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewT0x_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, VerilogParserRULE_t0x_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3556)
		p.Path_delay_expression()
	}

	return localctx
}

// ITx1_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITx1_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTx1_path_delay_expressionContext differentiates from other interfaces.
	IsTx1_path_delay_expressionContext()
}

type Tx1_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTx1_path_delay_expressionContext() *Tx1_path_delay_expressionContext {
	var p = new(Tx1_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tx1_path_delay_expression
	return p
}

func (*Tx1_path_delay_expressionContext) IsTx1_path_delay_expressionContext() {}

func NewTx1_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tx1_path_delay_expressionContext {
	var p = new(Tx1_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tx1_path_delay_expression

	return p
}

func (s *Tx1_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tx1_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tx1_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tx1_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tx1_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTx1_path_delay_expression(s)
	}
}

func (s *Tx1_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTx1_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tx1_path_delay_expression() (localctx ITx1_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTx1_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, VerilogParserRULE_tx1_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3558)
		p.Path_delay_expression()
	}

	return localctx
}

// IT1x_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT1x_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT1x_path_delay_expressionContext differentiates from other interfaces.
	IsT1x_path_delay_expressionContext()
}

type T1x_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT1x_path_delay_expressionContext() *T1x_path_delay_expressionContext {
	var p = new(T1x_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t1x_path_delay_expression
	return p
}

func (*T1x_path_delay_expressionContext) IsT1x_path_delay_expressionContext() {}

func NewT1x_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T1x_path_delay_expressionContext {
	var p = new(T1x_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t1x_path_delay_expression

	return p
}

func (s *T1x_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T1x_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T1x_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T1x_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T1x_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterT1x_path_delay_expression(s)
	}
}

func (s *T1x_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitT1x_path_delay_expression(s)
	}
}

func (p *VerilogParser) T1x_path_delay_expression() (localctx IT1x_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewT1x_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, VerilogParserRULE_t1x_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3560)
		p.Path_delay_expression()
	}

	return localctx
}

// ITx0_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITx0_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTx0_path_delay_expressionContext differentiates from other interfaces.
	IsTx0_path_delay_expressionContext()
}

type Tx0_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTx0_path_delay_expressionContext() *Tx0_path_delay_expressionContext {
	var p = new(Tx0_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tx0_path_delay_expression
	return p
}

func (*Tx0_path_delay_expressionContext) IsTx0_path_delay_expressionContext() {}

func NewTx0_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tx0_path_delay_expressionContext {
	var p = new(Tx0_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tx0_path_delay_expression

	return p
}

func (s *Tx0_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tx0_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tx0_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tx0_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tx0_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTx0_path_delay_expression(s)
	}
}

func (s *Tx0_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTx0_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tx0_path_delay_expression() (localctx ITx0_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTx0_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, VerilogParserRULE_tx0_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3562)
		p.Path_delay_expression()
	}

	return localctx
}

// ITxz_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITxz_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTxz_path_delay_expressionContext differentiates from other interfaces.
	IsTxz_path_delay_expressionContext()
}

type Txz_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTxz_path_delay_expressionContext() *Txz_path_delay_expressionContext {
	var p = new(Txz_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_txz_path_delay_expression
	return p
}

func (*Txz_path_delay_expressionContext) IsTxz_path_delay_expressionContext() {}

func NewTxz_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Txz_path_delay_expressionContext {
	var p = new(Txz_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_txz_path_delay_expression

	return p
}

func (s *Txz_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Txz_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Txz_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Txz_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Txz_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTxz_path_delay_expression(s)
	}
}

func (s *Txz_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTxz_path_delay_expression(s)
	}
}

func (p *VerilogParser) Txz_path_delay_expression() (localctx ITxz_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTxz_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, VerilogParserRULE_txz_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3564)
		p.Path_delay_expression()
	}

	return localctx
}

// ITzx_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITzx_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTzx_path_delay_expressionContext differentiates from other interfaces.
	IsTzx_path_delay_expressionContext()
}

type Tzx_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTzx_path_delay_expressionContext() *Tzx_path_delay_expressionContext {
	var p = new(Tzx_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tzx_path_delay_expression
	return p
}

func (*Tzx_path_delay_expressionContext) IsTzx_path_delay_expressionContext() {}

func NewTzx_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tzx_path_delay_expressionContext {
	var p = new(Tzx_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tzx_path_delay_expression

	return p
}

func (s *Tzx_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tzx_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tzx_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tzx_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tzx_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTzx_path_delay_expression(s)
	}
}

func (s *Tzx_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTzx_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tzx_path_delay_expression() (localctx ITzx_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTzx_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, VerilogParserRULE_tzx_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3566)
		p.Path_delay_expression()
	}

	return localctx
}

// IPath_delay_expressionContext is an interface to support dynamic dispatch.
type IPath_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPath_delay_expressionContext differentiates from other interfaces.
	IsPath_delay_expressionContext()
}

type Path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_delay_expressionContext() *Path_delay_expressionContext {
	var p = new(Path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_path_delay_expression
	return p
}

func (*Path_delay_expressionContext) IsPath_delay_expressionContext() {}

func NewPath_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_delay_expressionContext {
	var p = new(Path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_path_delay_expression

	return p
}

func (s *Path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_delay_expressionContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPath_delay_expression(s)
	}
}

func (s *Path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPath_delay_expression(s)
	}
}

func (p *VerilogParser) Path_delay_expression() (localctx IPath_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewPath_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, VerilogParserRULE_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3568)
		p.Constant_mintypmax_expression()
	}

	return localctx
}

// IEdge_sensitive_path_declarationContext is an interface to support dynamic dispatch.
type IEdge_sensitive_path_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEdge_sensitive_path_declarationContext differentiates from other interfaces.
	IsEdge_sensitive_path_declarationContext()
}

type Edge_sensitive_path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdge_sensitive_path_declarationContext() *Edge_sensitive_path_declarationContext {
	var p = new(Edge_sensitive_path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_edge_sensitive_path_declaration
	return p
}

func (*Edge_sensitive_path_declarationContext) IsEdge_sensitive_path_declarationContext() {}

func NewEdge_sensitive_path_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Edge_sensitive_path_declarationContext {
	var p = new(Edge_sensitive_path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_edge_sensitive_path_declaration

	return p
}

func (s *Edge_sensitive_path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Edge_sensitive_path_declarationContext) Parallel_edge_sensitive_path_description() IParallel_edge_sensitive_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParallel_edge_sensitive_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParallel_edge_sensitive_path_descriptionContext)
}

func (s *Edge_sensitive_path_declarationContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Edge_sensitive_path_declarationContext) Path_delay_value() IPath_delay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_valueContext)
}

func (s *Edge_sensitive_path_declarationContext) Full_edge_sensitive_path_description() IFull_edge_sensitive_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_edge_sensitive_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_edge_sensitive_path_descriptionContext)
}

func (s *Edge_sensitive_path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Edge_sensitive_path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Edge_sensitive_path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEdge_sensitive_path_declaration(s)
	}
}

func (s *Edge_sensitive_path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEdge_sensitive_path_declaration(s)
	}
}

func (p *VerilogParser) Edge_sensitive_path_declaration() (localctx IEdge_sensitive_path_declarationContext) {
	this := p
	_ = this

	localctx = NewEdge_sensitive_path_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, VerilogParserRULE_edge_sensitive_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3578)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 358, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3570)
			p.Parallel_edge_sensitive_path_description()
		}
		{
			p.SetState(3571)
			p.Match(VerilogParserEQUAL)
		}
		{
			p.SetState(3572)
			p.Path_delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3574)
			p.Full_edge_sensitive_path_description()
		}
		{
			p.SetState(3575)
			p.Match(VerilogParserEQUAL)
		}
		{
			p.SetState(3576)
			p.Path_delay_value()
		}

	}

	return localctx
}

// IParallel_edge_sensitive_path_descriptionContext is an interface to support dynamic dispatch.
type IParallel_edge_sensitive_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParallel_edge_sensitive_path_descriptionContext differentiates from other interfaces.
	IsParallel_edge_sensitive_path_descriptionContext()
}

type Parallel_edge_sensitive_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParallel_edge_sensitive_path_descriptionContext() *Parallel_edge_sensitive_path_descriptionContext {
	var p = new(Parallel_edge_sensitive_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parallel_edge_sensitive_path_description
	return p
}

func (*Parallel_edge_sensitive_path_descriptionContext) IsParallel_edge_sensitive_path_descriptionContext() {
}

func NewParallel_edge_sensitive_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parallel_edge_sensitive_path_descriptionContext {
	var p = new(Parallel_edge_sensitive_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parallel_edge_sensitive_path_description

	return p
}

func (s *Parallel_edge_sensitive_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Parallel_edge_sensitive_path_descriptionContext) AllLEFT_PARENTHESIS() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLEFT_PARENTHESIS)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) LEFT_PARENTHESIS(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, i)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Specify_input_terminal_descriptor() ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) EQUAL_GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL_GREATER_THAN, 0)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Specify_output_terminal_descriptor() ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Data_source_expression() IData_source_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_source_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_source_expressionContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) AllRIGHT_PARENTHESIS() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRIGHT_PARENTHESIS)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) RIGHT_PARENTHESIS(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, i)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Edge_identifier() IEdge_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_identifierContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Polarity_operator() IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parallel_edge_sensitive_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParallel_edge_sensitive_path_description(s)
	}
}

func (s *Parallel_edge_sensitive_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParallel_edge_sensitive_path_description(s)
	}
}

func (p *VerilogParser) Parallel_edge_sensitive_path_description() (localctx IParallel_edge_sensitive_path_descriptionContext) {
	this := p
	_ = this

	localctx = NewParallel_edge_sensitive_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, VerilogParserRULE_parallel_edge_sensitive_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3580)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	p.SetState(3582)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserNEGEDGE || _la == VerilogParserPOSEDGE {
		{
			p.SetState(3581)
			p.Edge_identifier()
		}

	}
	{
		p.SetState(3584)
		p.Specify_input_terminal_descriptor()
	}
	{
		p.SetState(3585)
		p.Match(VerilogParserEQUAL_GREATER_THAN)
	}
	{
		p.SetState(3586)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(3587)
		p.Specify_output_terminal_descriptor()
	}
	p.SetState(3589)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserPLUS || _la == VerilogParserMINUS {
		{
			p.SetState(3588)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(3591)
		p.Match(VerilogParserCOLON)
	}
	{
		p.SetState(3592)
		p.Data_source_expression()
	}
	{
		p.SetState(3593)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}
	{
		p.SetState(3594)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IFull_edge_sensitive_path_descriptionContext is an interface to support dynamic dispatch.
type IFull_edge_sensitive_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFull_edge_sensitive_path_descriptionContext differentiates from other interfaces.
	IsFull_edge_sensitive_path_descriptionContext()
}

type Full_edge_sensitive_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFull_edge_sensitive_path_descriptionContext() *Full_edge_sensitive_path_descriptionContext {
	var p = new(Full_edge_sensitive_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_full_edge_sensitive_path_description
	return p
}

func (*Full_edge_sensitive_path_descriptionContext) IsFull_edge_sensitive_path_descriptionContext() {}

func NewFull_edge_sensitive_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Full_edge_sensitive_path_descriptionContext {
	var p = new(Full_edge_sensitive_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_full_edge_sensitive_path_description

	return p
}

func (s *Full_edge_sensitive_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Full_edge_sensitive_path_descriptionContext) AllLEFT_PARENTHESIS() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLEFT_PARENTHESIS)
}

func (s *Full_edge_sensitive_path_descriptionContext) LEFT_PARENTHESIS(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, i)
}

func (s *Full_edge_sensitive_path_descriptionContext) List_of_path_inputs() IList_of_path_inputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_inputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_inputsContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) ASTERISK_GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserASTERISK_GREATER_THAN, 0)
}

func (s *Full_edge_sensitive_path_descriptionContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *Full_edge_sensitive_path_descriptionContext) Data_source_expression() IData_source_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_source_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_source_expressionContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) AllRIGHT_PARENTHESIS() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRIGHT_PARENTHESIS)
}

func (s *Full_edge_sensitive_path_descriptionContext) RIGHT_PARENTHESIS(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, i)
}

func (s *Full_edge_sensitive_path_descriptionContext) Edge_identifier() IEdge_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_identifierContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) Polarity_operator() IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Full_edge_sensitive_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Full_edge_sensitive_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFull_edge_sensitive_path_description(s)
	}
}

func (s *Full_edge_sensitive_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFull_edge_sensitive_path_description(s)
	}
}

func (p *VerilogParser) Full_edge_sensitive_path_description() (localctx IFull_edge_sensitive_path_descriptionContext) {
	this := p
	_ = this

	localctx = NewFull_edge_sensitive_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, VerilogParserRULE_full_edge_sensitive_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3596)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	p.SetState(3598)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserNEGEDGE || _la == VerilogParserPOSEDGE {
		{
			p.SetState(3597)
			p.Edge_identifier()
		}

	}
	{
		p.SetState(3600)
		p.List_of_path_inputs()
	}
	{
		p.SetState(3601)
		p.Match(VerilogParserASTERISK_GREATER_THAN)
	}
	{
		p.SetState(3602)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(3603)
		p.List_of_path_outputs()
	}
	p.SetState(3605)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserPLUS || _la == VerilogParserMINUS {
		{
			p.SetState(3604)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(3607)
		p.Match(VerilogParserCOLON)
	}
	{
		p.SetState(3608)
		p.Data_source_expression()
	}
	{
		p.SetState(3609)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}
	{
		p.SetState(3610)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IData_source_expressionContext is an interface to support dynamic dispatch.
type IData_source_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsData_source_expressionContext differentiates from other interfaces.
	IsData_source_expressionContext()
}

type Data_source_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_source_expressionContext() *Data_source_expressionContext {
	var p = new(Data_source_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_data_source_expression
	return p
}

func (*Data_source_expressionContext) IsData_source_expressionContext() {}

func NewData_source_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_source_expressionContext {
	var p = new(Data_source_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_data_source_expression

	return p
}

func (s *Data_source_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_source_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Data_source_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_source_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_source_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterData_source_expression(s)
	}
}

func (s *Data_source_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitData_source_expression(s)
	}
}

func (p *VerilogParser) Data_source_expression() (localctx IData_source_expressionContext) {
	this := p
	_ = this

	localctx = NewData_source_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, VerilogParserRULE_data_source_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3612)
		p.expression(0)
	}

	return localctx
}

// IEdge_identifierContext is an interface to support dynamic dispatch.
type IEdge_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEdge_identifierContext differentiates from other interfaces.
	IsEdge_identifierContext()
}

type Edge_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdge_identifierContext() *Edge_identifierContext {
	var p = new(Edge_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_edge_identifier
	return p
}

func (*Edge_identifierContext) IsEdge_identifierContext() {}

func NewEdge_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Edge_identifierContext {
	var p = new(Edge_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_edge_identifier

	return p
}

func (s *Edge_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Edge_identifierContext) POSEDGE() antlr.TerminalNode {
	return s.GetToken(VerilogParserPOSEDGE, 0)
}

func (s *Edge_identifierContext) NEGEDGE() antlr.TerminalNode {
	return s.GetToken(VerilogParserNEGEDGE, 0)
}

func (s *Edge_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Edge_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Edge_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEdge_identifier(s)
	}
}

func (s *Edge_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEdge_identifier(s)
	}
}

func (p *VerilogParser) Edge_identifier() (localctx IEdge_identifierContext) {
	this := p
	_ = this

	localctx = NewEdge_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, VerilogParserRULE_edge_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3614)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserNEGEDGE || _la == VerilogParserPOSEDGE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IState_dependent_path_declarationContext is an interface to support dynamic dispatch.
type IState_dependent_path_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsState_dependent_path_declarationContext differentiates from other interfaces.
	IsState_dependent_path_declarationContext()
}

type State_dependent_path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyState_dependent_path_declarationContext() *State_dependent_path_declarationContext {
	var p = new(State_dependent_path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_state_dependent_path_declaration
	return p
}

func (*State_dependent_path_declarationContext) IsState_dependent_path_declarationContext() {}

func NewState_dependent_path_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *State_dependent_path_declarationContext {
	var p = new(State_dependent_path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_state_dependent_path_declaration

	return p
}

func (s *State_dependent_path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *State_dependent_path_declarationContext) IF() antlr.TerminalNode {
	return s.GetToken(VerilogParserIF, 0)
}

func (s *State_dependent_path_declarationContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *State_dependent_path_declarationContext) Module_path_expression() IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *State_dependent_path_declarationContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *State_dependent_path_declarationContext) Simple_path_declaration() ISimple_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_path_declarationContext)
}

func (s *State_dependent_path_declarationContext) Edge_sensitive_path_declaration() IEdge_sensitive_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_sensitive_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_sensitive_path_declarationContext)
}

func (s *State_dependent_path_declarationContext) IFNONE() antlr.TerminalNode {
	return s.GetToken(VerilogParserIFNONE, 0)
}

func (s *State_dependent_path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *State_dependent_path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *State_dependent_path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterState_dependent_path_declaration(s)
	}
}

func (s *State_dependent_path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitState_dependent_path_declaration(s)
	}
}

func (p *VerilogParser) State_dependent_path_declaration() (localctx IState_dependent_path_declarationContext) {
	this := p
	_ = this

	localctx = NewState_dependent_path_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, VerilogParserRULE_state_dependent_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3630)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 363, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3616)
			p.Match(VerilogParserIF)
		}
		{
			p.SetState(3617)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3618)
			p.module_path_expression(0)
		}
		{
			p.SetState(3619)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(3620)
			p.Simple_path_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3622)
			p.Match(VerilogParserIF)
		}
		{
			p.SetState(3623)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3624)
			p.module_path_expression(0)
		}
		{
			p.SetState(3625)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}
		{
			p.SetState(3626)
			p.Edge_sensitive_path_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3628)
			p.Match(VerilogParserIFNONE)
		}
		{
			p.SetState(3629)
			p.Simple_path_declaration()
		}

	}

	return localctx
}

// IPolarity_operatorContext is an interface to support dynamic dispatch.
type IPolarity_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPolarity_operatorContext differentiates from other interfaces.
	IsPolarity_operatorContext()
}

type Polarity_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPolarity_operatorContext() *Polarity_operatorContext {
	var p = new(Polarity_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_polarity_operator
	return p
}

func (*Polarity_operatorContext) IsPolarity_operatorContext() {}

func NewPolarity_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Polarity_operatorContext {
	var p = new(Polarity_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_polarity_operator

	return p
}

func (s *Polarity_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Polarity_operatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(VerilogParserPLUS, 0)
}

func (s *Polarity_operatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(VerilogParserMINUS, 0)
}

func (s *Polarity_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Polarity_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Polarity_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPolarity_operator(s)
	}
}

func (s *Polarity_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPolarity_operator(s)
	}
}

func (p *VerilogParser) Polarity_operator() (localctx IPolarity_operatorContext) {
	this := p
	_ = this

	localctx = NewPolarity_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, VerilogParserRULE_polarity_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3632)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserPLUS || _la == VerilogParserMINUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IConcatenationContext is an interface to support dynamic dispatch.
type IConcatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcatenationContext differentiates from other interfaces.
	IsConcatenationContext()
}

type ConcatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcatenationContext() *ConcatenationContext {
	var p = new(ConcatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_concatenation
	return p
}

func (*ConcatenationContext) IsConcatenationContext() {}

func NewConcatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConcatenationContext {
	var p = new(ConcatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_concatenation

	return p
}

func (s *ConcatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConcatenationContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACE, 0)
}

func (s *ConcatenationContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ConcatenationContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConcatenationContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACE, 0)
}

func (s *ConcatenationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *ConcatenationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

func (p *VerilogParser) Concatenation() (localctx IConcatenationContext) {
	this := p
	_ = this

	localctx = NewConcatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, VerilogParserRULE_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3634)
		p.Match(VerilogParserLEFT_BRACE)
	}
	{
		p.SetState(3635)
		p.expression(0)
	}
	p.SetState(3640)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(3636)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3637)
			p.expression(0)
		}

		p.SetState(3642)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3643)
		p.Match(VerilogParserRIGHT_BRACE)
	}

	return localctx
}

// IConstant_concatenationContext is an interface to support dynamic dispatch.
type IConstant_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_concatenationContext differentiates from other interfaces.
	IsConstant_concatenationContext()
}

type Constant_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_concatenationContext() *Constant_concatenationContext {
	var p = new(Constant_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_concatenation
	return p
}

func (*Constant_concatenationContext) IsConstant_concatenationContext() {}

func NewConstant_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_concatenationContext {
	var p = new(Constant_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_concatenation

	return p
}

func (s *Constant_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_concatenationContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACE, 0)
}

func (s *Constant_concatenationContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_concatenationContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_concatenationContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACE, 0)
}

func (s *Constant_concatenationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Constant_concatenationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Constant_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_concatenation(s)
	}
}

func (s *Constant_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_concatenation(s)
	}
}

func (p *VerilogParser) Constant_concatenation() (localctx IConstant_concatenationContext) {
	this := p
	_ = this

	localctx = NewConstant_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, VerilogParserRULE_constant_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3645)
		p.Match(VerilogParserLEFT_BRACE)
	}
	{
		p.SetState(3646)
		p.constant_expression(0)
	}
	p.SetState(3651)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(3647)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3648)
			p.constant_expression(0)
		}

		p.SetState(3653)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3654)
		p.Match(VerilogParserRIGHT_BRACE)
	}

	return localctx
}

// IConstant_multiple_concatenationContext is an interface to support dynamic dispatch.
type IConstant_multiple_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_multiple_concatenationContext differentiates from other interfaces.
	IsConstant_multiple_concatenationContext()
}

type Constant_multiple_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_multiple_concatenationContext() *Constant_multiple_concatenationContext {
	var p = new(Constant_multiple_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_multiple_concatenation
	return p
}

func (*Constant_multiple_concatenationContext) IsConstant_multiple_concatenationContext() {}

func NewConstant_multiple_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_multiple_concatenationContext {
	var p = new(Constant_multiple_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_multiple_concatenation

	return p
}

func (s *Constant_multiple_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_multiple_concatenationContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACE, 0)
}

func (s *Constant_multiple_concatenationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_multiple_concatenationContext) Constant_concatenation() IConstant_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_concatenationContext)
}

func (s *Constant_multiple_concatenationContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACE, 0)
}

func (s *Constant_multiple_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_multiple_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_multiple_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_multiple_concatenation(s)
	}
}

func (s *Constant_multiple_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_multiple_concatenation(s)
	}
}

func (p *VerilogParser) Constant_multiple_concatenation() (localctx IConstant_multiple_concatenationContext) {
	this := p
	_ = this

	localctx = NewConstant_multiple_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, VerilogParserRULE_constant_multiple_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3656)
		p.Match(VerilogParserLEFT_BRACE)
	}
	{
		p.SetState(3657)
		p.constant_expression(0)
	}
	{
		p.SetState(3658)
		p.Constant_concatenation()
	}
	{
		p.SetState(3659)
		p.Match(VerilogParserRIGHT_BRACE)
	}

	return localctx
}

// IModule_path_concatenationContext is an interface to support dynamic dispatch.
type IModule_path_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_concatenationContext differentiates from other interfaces.
	IsModule_path_concatenationContext()
}

type Module_path_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_concatenationContext() *Module_path_concatenationContext {
	var p = new(Module_path_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_concatenation
	return p
}

func (*Module_path_concatenationContext) IsModule_path_concatenationContext() {}

func NewModule_path_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_concatenationContext {
	var p = new(Module_path_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_concatenation

	return p
}

func (s *Module_path_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_concatenationContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACE, 0)
}

func (s *Module_path_concatenationContext) AllModule_path_expression() []IModule_path_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem())
	var tst = make([]IModule_path_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_path_expressionContext)
		}
	}

	return tst
}

func (s *Module_path_concatenationContext) Module_path_expression(i int) IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *Module_path_concatenationContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACE, 0)
}

func (s *Module_path_concatenationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Module_path_concatenationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Module_path_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_path_concatenation(s)
	}
}

func (s *Module_path_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_path_concatenation(s)
	}
}

func (p *VerilogParser) Module_path_concatenation() (localctx IModule_path_concatenationContext) {
	this := p
	_ = this

	localctx = NewModule_path_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, VerilogParserRULE_module_path_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3661)
		p.Match(VerilogParserLEFT_BRACE)
	}
	{
		p.SetState(3662)
		p.module_path_expression(0)
	}
	p.SetState(3667)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(3663)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3664)
			p.module_path_expression(0)
		}

		p.SetState(3669)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3670)
		p.Match(VerilogParserRIGHT_BRACE)
	}

	return localctx
}

// IModule_path_multiple_concatenationContext is an interface to support dynamic dispatch.
type IModule_path_multiple_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_multiple_concatenationContext differentiates from other interfaces.
	IsModule_path_multiple_concatenationContext()
}

type Module_path_multiple_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_multiple_concatenationContext() *Module_path_multiple_concatenationContext {
	var p = new(Module_path_multiple_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_multiple_concatenation
	return p
}

func (*Module_path_multiple_concatenationContext) IsModule_path_multiple_concatenationContext() {}

func NewModule_path_multiple_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_multiple_concatenationContext {
	var p = new(Module_path_multiple_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_multiple_concatenation

	return p
}

func (s *Module_path_multiple_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_multiple_concatenationContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACE, 0)
}

func (s *Module_path_multiple_concatenationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Module_path_multiple_concatenationContext) Module_path_concatenation() IModule_path_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_concatenationContext)
}

func (s *Module_path_multiple_concatenationContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACE, 0)
}

func (s *Module_path_multiple_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_multiple_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_multiple_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_path_multiple_concatenation(s)
	}
}

func (s *Module_path_multiple_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_path_multiple_concatenation(s)
	}
}

func (p *VerilogParser) Module_path_multiple_concatenation() (localctx IModule_path_multiple_concatenationContext) {
	this := p
	_ = this

	localctx = NewModule_path_multiple_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, VerilogParserRULE_module_path_multiple_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3672)
		p.Match(VerilogParserLEFT_BRACE)
	}
	{
		p.SetState(3673)
		p.constant_expression(0)
	}
	{
		p.SetState(3674)
		p.Module_path_concatenation()
	}
	{
		p.SetState(3675)
		p.Match(VerilogParserRIGHT_BRACE)
	}

	return localctx
}

// IMultiple_concatenationContext is an interface to support dynamic dispatch.
type IMultiple_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiple_concatenationContext differentiates from other interfaces.
	IsMultiple_concatenationContext()
}

type Multiple_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiple_concatenationContext() *Multiple_concatenationContext {
	var p = new(Multiple_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_multiple_concatenation
	return p
}

func (*Multiple_concatenationContext) IsMultiple_concatenationContext() {}

func NewMultiple_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multiple_concatenationContext {
	var p = new(Multiple_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_multiple_concatenation

	return p
}

func (s *Multiple_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Multiple_concatenationContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACE, 0)
}

func (s *Multiple_concatenationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Multiple_concatenationContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Multiple_concatenationContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACE, 0)
}

func (s *Multiple_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multiple_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multiple_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMultiple_concatenation(s)
	}
}

func (s *Multiple_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMultiple_concatenation(s)
	}
}

func (p *VerilogParser) Multiple_concatenation() (localctx IMultiple_concatenationContext) {
	this := p
	_ = this

	localctx = NewMultiple_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, VerilogParserRULE_multiple_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3677)
		p.Match(VerilogParserLEFT_BRACE)
	}
	{
		p.SetState(3678)
		p.constant_expression(0)
	}
	{
		p.SetState(3679)
		p.Concatenation()
	}
	{
		p.SetState(3680)
		p.Match(VerilogParserRIGHT_BRACE)
	}

	return localctx
}

// IConstant_function_callContext is an interface to support dynamic dispatch.
type IConstant_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_function_callContext differentiates from other interfaces.
	IsConstant_function_callContext()
}

type Constant_function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_function_callContext() *Constant_function_callContext {
	var p = new(Constant_function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_function_call
	return p
}

func (*Constant_function_callContext) IsConstant_function_callContext() {}

func NewConstant_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_function_callContext {
	var p = new(Constant_function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_function_call

	return p
}

func (s *Constant_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_function_callContext) Function_identifier() IFunction_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_identifierContext)
}

func (s *Constant_function_callContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Constant_function_callContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_function_callContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_function_callContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Constant_function_callContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Constant_function_callContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Constant_function_callContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Constant_function_callContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Constant_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_function_call(s)
	}
}

func (s *Constant_function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_function_call(s)
	}
}

func (p *VerilogParser) Constant_function_call() (localctx IConstant_function_callContext) {
	this := p
	_ = this

	localctx = NewConstant_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, VerilogParserRULE_constant_function_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3682)
		p.Function_identifier()
	}
	p.SetState(3686)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 367, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3683)
				p.Attribute_instance()
			}

		}
		p.SetState(3688)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 367, p.GetParserRuleContext())
	}
	{
		p.SetState(3689)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(3690)
		p.constant_expression(0)
	}
	p.SetState(3695)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(3691)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3692)
			p.constant_expression(0)
		}

		p.SetState(3697)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3698)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IConstant_system_function_callContext is an interface to support dynamic dispatch.
type IConstant_system_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_system_function_callContext differentiates from other interfaces.
	IsConstant_system_function_callContext()
}

type Constant_system_function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_system_function_callContext() *Constant_system_function_callContext {
	var p = new(Constant_system_function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_system_function_call
	return p
}

func (*Constant_system_function_callContext) IsConstant_system_function_callContext() {}

func NewConstant_system_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_system_function_callContext {
	var p = new(Constant_system_function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_system_function_call

	return p
}

func (s *Constant_system_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_system_function_callContext) System_function_identifier() ISystem_function_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_function_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_function_identifierContext)
}

func (s *Constant_system_function_callContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Constant_system_function_callContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_system_function_callContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_system_function_callContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Constant_system_function_callContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Constant_system_function_callContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Constant_system_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_system_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_system_function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_system_function_call(s)
	}
}

func (s *Constant_system_function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_system_function_call(s)
	}
}

func (p *VerilogParser) Constant_system_function_call() (localctx IConstant_system_function_callContext) {
	this := p
	_ = this

	localctx = NewConstant_system_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, VerilogParserRULE_constant_system_function_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3700)
		p.System_function_identifier()
	}
	{
		p.SetState(3701)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(3702)
		p.constant_expression(0)
	}
	p.SetState(3707)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(3703)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3704)
			p.constant_expression(0)
		}

		p.SetState(3709)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3710)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IFunction_callContext is an interface to support dynamic dispatch.
type IFunction_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_callContext differentiates from other interfaces.
	IsFunction_callContext()
}

type Function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_callContext() *Function_callContext {
	var p = new(Function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_call
	return p
}

func (*Function_callContext) IsFunction_callContext() {}

func NewFunction_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_callContext {
	var p = new(Function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_call

	return p
}

func (s *Function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_callContext) Hierarchical_function_identifier() IHierarchical_function_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_function_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_function_identifierContext)
}

func (s *Function_callContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Function_callContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Function_callContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_callContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Function_callContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Function_callContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Function_callContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Function_callContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_call(s)
	}
}

func (s *Function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_call(s)
	}
}

func (p *VerilogParser) Function_call() (localctx IFunction_callContext) {
	this := p
	_ = this

	localctx = NewFunction_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, VerilogParserRULE_function_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3712)
		p.Hierarchical_function_identifier()
	}
	p.SetState(3716)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 370, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3713)
				p.Attribute_instance()
			}

		}
		p.SetState(3718)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 370, p.GetParserRuleContext())
	}
	{
		p.SetState(3719)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(3720)
		p.expression(0)
	}
	p.SetState(3725)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(3721)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(3722)
			p.expression(0)
		}

		p.SetState(3727)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3728)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// ISystem_function_callContext is an interface to support dynamic dispatch.
type ISystem_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_function_callContext differentiates from other interfaces.
	IsSystem_function_callContext()
}

type System_function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_function_callContext() *System_function_callContext {
	var p = new(System_function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_system_function_call
	return p
}

func (*System_function_callContext) IsSystem_function_callContext() {}

func NewSystem_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_function_callContext {
	var p = new(System_function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_system_function_call

	return p
}

func (s *System_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *System_function_callContext) System_function_identifier() ISystem_function_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_function_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_function_identifierContext)
}

func (s *System_function_callContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *System_function_callContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *System_function_callContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *System_function_callContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *System_function_callContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *System_function_callContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *System_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSystem_function_call(s)
	}
}

func (s *System_function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSystem_function_call(s)
	}
}

func (p *VerilogParser) System_function_call() (localctx ISystem_function_callContext) {
	this := p
	_ = this

	localctx = NewSystem_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, VerilogParserRULE_system_function_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3730)
		p.System_function_identifier()
	}
	p.SetState(3742)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 373, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3731)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3732)
			p.expression(0)
		}
		p.SetState(3737)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(3733)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(3734)
				p.expression(0)
			}

			p.SetState(3739)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3740)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}

	return localctx
}

// IBase_expressionContext is an interface to support dynamic dispatch.
type IBase_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_expressionContext differentiates from other interfaces.
	IsBase_expressionContext()
}

type Base_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_expressionContext() *Base_expressionContext {
	var p = new(Base_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_base_expression
	return p
}

func (*Base_expressionContext) IsBase_expressionContext() {}

func NewBase_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_expressionContext {
	var p = new(Base_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_base_expression

	return p
}

func (s *Base_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Base_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBase_expression(s)
	}
}

func (s *Base_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBase_expression(s)
	}
}

func (p *VerilogParser) Base_expression() (localctx IBase_expressionContext) {
	this := p
	_ = this

	localctx = NewBase_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, VerilogParserRULE_base_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3744)
		p.expression(0)
	}

	return localctx
}

// IConstant_base_expressionContext is an interface to support dynamic dispatch.
type IConstant_base_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_base_expressionContext differentiates from other interfaces.
	IsConstant_base_expressionContext()
}

type Constant_base_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_base_expressionContext() *Constant_base_expressionContext {
	var p = new(Constant_base_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_base_expression
	return p
}

func (*Constant_base_expressionContext) IsConstant_base_expressionContext() {}

func NewConstant_base_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_base_expressionContext {
	var p = new(Constant_base_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_base_expression

	return p
}

func (s *Constant_base_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_base_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_base_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_base_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_base_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_base_expression(s)
	}
}

func (s *Constant_base_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_base_expression(s)
	}
}

func (p *VerilogParser) Constant_base_expression() (localctx IConstant_base_expressionContext) {
	this := p
	_ = this

	localctx = NewConstant_base_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, VerilogParserRULE_constant_base_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3746)
		p.constant_expression(0)
	}

	return localctx
}

// IConstant_expressionContext is an interface to support dynamic dispatch.
type IConstant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_expressionContext differentiates from other interfaces.
	IsConstant_expressionContext()
}

type Constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_expressionContext() *Constant_expressionContext {
	var p = new(Constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_expression
	return p
}

func (*Constant_expressionContext) IsConstant_expressionContext() {}

func NewConstant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_expressionContext {
	var p = new(Constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_expression

	return p
}

func (s *Constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_expressionContext) Constant_primary() IConstant_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_primaryContext)
}

func (s *Constant_expressionContext) Unary_operator() IUnary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *Constant_expressionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Constant_expressionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Constant_expressionContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_expressionContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_expressionContext) Binary_operator() IBinary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinary_operatorContext)
}

func (s *Constant_expressionContext) QUESTION_MARK() antlr.TerminalNode {
	return s.GetToken(VerilogParserQUESTION_MARK, 0)
}

func (s *Constant_expressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *Constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_expression(s)
	}
}

func (s *Constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_expression(s)
	}
}

func (p *VerilogParser) Constant_expression() (localctx IConstant_expressionContext) {
	return p.constant_expression(0)
}

func (p *VerilogParser) constant_expression(_p int) (localctx IConstant_expressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewConstant_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IConstant_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 568
	p.EnterRecursionRule(localctx, 568, VerilogParserRULE_constant_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3759)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserDOLLAR_BITSTOREAL, VerilogParserDOLLAR_ITOR, VerilogParserDOLLAR_SIGNED, VerilogParserDOLLAR_REALTOBITS, VerilogParserDOLLAR_RTOI, VerilogParserDOLLAR_UNSIGNED, VerilogParserDOLLAR_RANDOM, VerilogParserDOLLAR_DIST_ERLANG, VerilogParserDOLLAR_DIST_NORMAL, VerilogParserDOLLAR_DIST_T, VerilogParserDOLLAR_DIST_CHI_SQUARE, VerilogParserDOLLAR_DIST_EXPONENTIAL, VerilogParserDOLLAR_DIST_POISSON, VerilogParserDOLLAR_DIST_UNIFORM, VerilogParserDOLLAR_CLOG2, VerilogParserDOLLAR_LN, VerilogParserDOLLAR_LOG10, VerilogParserDOLLAR_EXP, VerilogParserDOLLAR_SQRT, VerilogParserDOLLAR_POW, VerilogParserDOLLAR_FLOOR, VerilogParserDOLLAR_CEIL, VerilogParserDOLLAR_SIN, VerilogParserDOLLAR_COS, VerilogParserDOLLAR_TAN, VerilogParserDOLLAR_ASIN, VerilogParserDOLLAR_ACOS, VerilogParserDOLLAR_ATAN, VerilogParserDOLLAR_ATAN2, VerilogParserDOLLAR_HYPOT, VerilogParserDOLLAR_SINH, VerilogParserDOLLAR_COSH, VerilogParserDOLLAR_TANH, VerilogParserDOLLAR_ASINH, VerilogParserDOLLAR_ACOSH, VerilogParserDOLLAR_ATANH, VerilogParserREAL_NUMBER, VerilogParserDECIMAL_NUMBER, VerilogParserBINARY_NUMBER, VerilogParserOCTAL_NUMBER, VerilogParserHEX_NUMBER, VerilogParserSTRING, VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER, VerilogParserSYSTEM_TF_IDENTIFIER, VerilogParserLEFT_PARENTHESIS, VerilogParserLEFT_BRACE:
		{
			p.SetState(3749)
			p.Constant_primary()
		}

	case VerilogParserPLUS, VerilogParserMINUS, VerilogParserEXCLAMATION_MARK, VerilogParserTILDE, VerilogParserAMPERSAND, VerilogParserTILDE_AMPERSAND, VerilogParserVERTICAL_BAR, VerilogParserTILDE_VERTICAL_BAR, VerilogParserCARET, VerilogParserTILDE_CARET, VerilogParserCARET_TILDE:
		{
			p.SetState(3750)
			p.Unary_operator()
		}
		p.SetState(3754)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 374, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3751)
					p.Attribute_instance()
				}

			}
			p.SetState(3756)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 374, p.GetParserRuleContext())
		}
		{
			p.SetState(3757)
			p.Constant_primary()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3785)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 379, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3783)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 378, p.GetParserRuleContext()) {
			case 1:
				localctx = NewConstant_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, VerilogParserRULE_constant_expression)
				p.SetState(3761)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(3762)
					p.Binary_operator()
				}
				p.SetState(3766)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 376, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3763)
							p.Attribute_instance()
						}

					}
					p.SetState(3768)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 376, p.GetParserRuleContext())
				}
				{
					p.SetState(3769)
					p.constant_expression(3)
				}

			case 2:
				localctx = NewConstant_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, VerilogParserRULE_constant_expression)
				p.SetState(3771)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(3772)
					p.Match(VerilogParserQUESTION_MARK)
				}
				p.SetState(3776)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 377, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3773)
							p.Attribute_instance()
						}

					}
					p.SetState(3778)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 377, p.GetParserRuleContext())
				}
				{
					p.SetState(3779)
					p.constant_expression(0)
				}
				{
					p.SetState(3780)
					p.Match(VerilogParserCOLON)
				}
				{
					p.SetState(3781)
					p.constant_expression(2)
				}

			}

		}
		p.SetState(3787)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 379, p.GetParserRuleContext())
	}

	return localctx
}

// IConstant_mintypmax_expressionContext is an interface to support dynamic dispatch.
type IConstant_mintypmax_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_mintypmax_expressionContext differentiates from other interfaces.
	IsConstant_mintypmax_expressionContext()
}

type Constant_mintypmax_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_mintypmax_expressionContext() *Constant_mintypmax_expressionContext {
	var p = new(Constant_mintypmax_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_mintypmax_expression
	return p
}

func (*Constant_mintypmax_expressionContext) IsConstant_mintypmax_expressionContext() {}

func NewConstant_mintypmax_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_mintypmax_expressionContext {
	var p = new(Constant_mintypmax_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_mintypmax_expression

	return p
}

func (s *Constant_mintypmax_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_mintypmax_expressionContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_mintypmax_expressionContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_mintypmax_expressionContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOLON)
}

func (s *Constant_mintypmax_expressionContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, i)
}

func (s *Constant_mintypmax_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_mintypmax_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_mintypmax_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_mintypmax_expression(s)
	}
}

func (s *Constant_mintypmax_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_mintypmax_expression(s)
	}
}

func (p *VerilogParser) Constant_mintypmax_expression() (localctx IConstant_mintypmax_expressionContext) {
	this := p
	_ = this

	localctx = NewConstant_mintypmax_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, VerilogParserRULE_constant_mintypmax_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3795)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 380, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3788)
			p.constant_expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3789)
			p.constant_expression(0)
		}
		{
			p.SetState(3790)
			p.Match(VerilogParserCOLON)
		}
		{
			p.SetState(3791)
			p.constant_expression(0)
		}
		{
			p.SetState(3792)
			p.Match(VerilogParserCOLON)
		}
		{
			p.SetState(3793)
			p.constant_expression(0)
		}

	}

	return localctx
}

// IConstant_range_expressionContext is an interface to support dynamic dispatch.
type IConstant_range_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_range_expressionContext differentiates from other interfaces.
	IsConstant_range_expressionContext()
}

type Constant_range_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_range_expressionContext() *Constant_range_expressionContext {
	var p = new(Constant_range_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_range_expression
	return p
}

func (*Constant_range_expressionContext) IsConstant_range_expressionContext() {}

func NewConstant_range_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_range_expressionContext {
	var p = new(Constant_range_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_range_expression

	return p
}

func (s *Constant_range_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_range_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_range_expressionContext) Msb_constant_expression() IMsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMsb_constant_expressionContext)
}

func (s *Constant_range_expressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *Constant_range_expressionContext) Lsb_constant_expression() ILsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILsb_constant_expressionContext)
}

func (s *Constant_range_expressionContext) Constant_base_expression() IConstant_base_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_base_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_base_expressionContext)
}

func (s *Constant_range_expressionContext) PLUS_COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserPLUS_COLON, 0)
}

func (s *Constant_range_expressionContext) Width_constant_expression() IWidth_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWidth_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWidth_constant_expressionContext)
}

func (s *Constant_range_expressionContext) MINUS_COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserMINUS_COLON, 0)
}

func (s *Constant_range_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_range_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_range_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_range_expression(s)
	}
}

func (s *Constant_range_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_range_expression(s)
	}
}

func (p *VerilogParser) Constant_range_expression() (localctx IConstant_range_expressionContext) {
	this := p
	_ = this

	localctx = NewConstant_range_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, VerilogParserRULE_constant_range_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3810)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 381, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3797)
			p.constant_expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3798)
			p.Msb_constant_expression()
		}
		{
			p.SetState(3799)
			p.Match(VerilogParserCOLON)
		}
		{
			p.SetState(3800)
			p.Lsb_constant_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3802)
			p.Constant_base_expression()
		}
		{
			p.SetState(3803)
			p.Match(VerilogParserPLUS_COLON)
		}
		{
			p.SetState(3804)
			p.Width_constant_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3806)
			p.Constant_base_expression()
		}
		{
			p.SetState(3807)
			p.Match(VerilogParserMINUS_COLON)
		}
		{
			p.SetState(3808)
			p.Width_constant_expression()
		}

	}

	return localctx
}

// IDimension_constant_expressionContext is an interface to support dynamic dispatch.
type IDimension_constant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimension_constant_expressionContext differentiates from other interfaces.
	IsDimension_constant_expressionContext()
}

type Dimension_constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimension_constant_expressionContext() *Dimension_constant_expressionContext {
	var p = new(Dimension_constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dimension_constant_expression
	return p
}

func (*Dimension_constant_expressionContext) IsDimension_constant_expressionContext() {}

func NewDimension_constant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dimension_constant_expressionContext {
	var p = new(Dimension_constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dimension_constant_expression

	return p
}

func (s *Dimension_constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Dimension_constant_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Dimension_constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dimension_constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dimension_constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDimension_constant_expression(s)
	}
}

func (s *Dimension_constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDimension_constant_expression(s)
	}
}

func (p *VerilogParser) Dimension_constant_expression() (localctx IDimension_constant_expressionContext) {
	this := p
	_ = this

	localctx = NewDimension_constant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, VerilogParserRULE_dimension_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3812)
		p.constant_expression(0)
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *ExpressionContext) Unary_operator() IUnary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *ExpressionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) Binary_operator() IBinary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinary_operatorContext)
}

func (s *ExpressionContext) QUESTION_MARK() antlr.TerminalNode {
	return s.GetToken(VerilogParserQUESTION_MARK, 0)
}

func (s *ExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *VerilogParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *VerilogParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 576
	p.EnterRecursionRule(localctx, 576, VerilogParserRULE_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3825)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserDOLLAR_BITSTOREAL, VerilogParserDOLLAR_ITOR, VerilogParserDOLLAR_SIGNED, VerilogParserDOLLAR_REALTOBITS, VerilogParserDOLLAR_RTOI, VerilogParserDOLLAR_UNSIGNED, VerilogParserDOLLAR_RANDOM, VerilogParserDOLLAR_DIST_ERLANG, VerilogParserDOLLAR_DIST_NORMAL, VerilogParserDOLLAR_DIST_T, VerilogParserDOLLAR_DIST_CHI_SQUARE, VerilogParserDOLLAR_DIST_EXPONENTIAL, VerilogParserDOLLAR_DIST_POISSON, VerilogParserDOLLAR_DIST_UNIFORM, VerilogParserDOLLAR_CLOG2, VerilogParserDOLLAR_LN, VerilogParserDOLLAR_LOG10, VerilogParserDOLLAR_EXP, VerilogParserDOLLAR_SQRT, VerilogParserDOLLAR_POW, VerilogParserDOLLAR_FLOOR, VerilogParserDOLLAR_CEIL, VerilogParserDOLLAR_SIN, VerilogParserDOLLAR_COS, VerilogParserDOLLAR_TAN, VerilogParserDOLLAR_ASIN, VerilogParserDOLLAR_ACOS, VerilogParserDOLLAR_ATAN, VerilogParserDOLLAR_ATAN2, VerilogParserDOLLAR_HYPOT, VerilogParserDOLLAR_SINH, VerilogParserDOLLAR_COSH, VerilogParserDOLLAR_TANH, VerilogParserDOLLAR_ASINH, VerilogParserDOLLAR_ACOSH, VerilogParserDOLLAR_ATANH, VerilogParserREAL_NUMBER, VerilogParserDECIMAL_NUMBER, VerilogParserBINARY_NUMBER, VerilogParserOCTAL_NUMBER, VerilogParserHEX_NUMBER, VerilogParserSTRING, VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER, VerilogParserSYSTEM_TF_IDENTIFIER, VerilogParserLEFT_PARENTHESIS, VerilogParserLEFT_BRACE:
		{
			p.SetState(3815)
			p.Primary()
		}

	case VerilogParserPLUS, VerilogParserMINUS, VerilogParserEXCLAMATION_MARK, VerilogParserTILDE, VerilogParserAMPERSAND, VerilogParserTILDE_AMPERSAND, VerilogParserVERTICAL_BAR, VerilogParserTILDE_VERTICAL_BAR, VerilogParserCARET, VerilogParserTILDE_CARET, VerilogParserCARET_TILDE:
		{
			p.SetState(3816)
			p.Unary_operator()
		}
		p.SetState(3820)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 382, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3817)
					p.Attribute_instance()
				}

			}
			p.SetState(3822)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 382, p.GetParserRuleContext())
		}
		{
			p.SetState(3823)
			p.Primary()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3851)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 387, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3849)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 386, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, VerilogParserRULE_expression)
				p.SetState(3827)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(3828)
					p.Binary_operator()
				}
				p.SetState(3832)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 384, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3829)
							p.Attribute_instance()
						}

					}
					p.SetState(3834)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 384, p.GetParserRuleContext())
				}
				{
					p.SetState(3835)
					p.expression(3)
				}

			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, VerilogParserRULE_expression)
				p.SetState(3837)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(3838)
					p.Match(VerilogParserQUESTION_MARK)
				}
				p.SetState(3842)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 385, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3839)
							p.Attribute_instance()
						}

					}
					p.SetState(3844)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 385, p.GetParserRuleContext())
				}
				{
					p.SetState(3845)
					p.expression(0)
				}
				{
					p.SetState(3846)
					p.Match(VerilogParserCOLON)
				}
				{
					p.SetState(3847)
					p.expression(2)
				}

			}

		}
		p.SetState(3853)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 387, p.GetParserRuleContext())
	}

	return localctx
}

// ILsb_constant_expressionContext is an interface to support dynamic dispatch.
type ILsb_constant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLsb_constant_expressionContext differentiates from other interfaces.
	IsLsb_constant_expressionContext()
}

type Lsb_constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLsb_constant_expressionContext() *Lsb_constant_expressionContext {
	var p = new(Lsb_constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_lsb_constant_expression
	return p
}

func (*Lsb_constant_expressionContext) IsLsb_constant_expressionContext() {}

func NewLsb_constant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lsb_constant_expressionContext {
	var p = new(Lsb_constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_lsb_constant_expression

	return p
}

func (s *Lsb_constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Lsb_constant_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Lsb_constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lsb_constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lsb_constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLsb_constant_expression(s)
	}
}

func (s *Lsb_constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLsb_constant_expression(s)
	}
}

func (p *VerilogParser) Lsb_constant_expression() (localctx ILsb_constant_expressionContext) {
	this := p
	_ = this

	localctx = NewLsb_constant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, VerilogParserRULE_lsb_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3854)
		p.constant_expression(0)
	}

	return localctx
}

// IMintypmax_expressionContext is an interface to support dynamic dispatch.
type IMintypmax_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMintypmax_expressionContext differentiates from other interfaces.
	IsMintypmax_expressionContext()
}

type Mintypmax_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMintypmax_expressionContext() *Mintypmax_expressionContext {
	var p = new(Mintypmax_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_mintypmax_expression
	return p
}

func (*Mintypmax_expressionContext) IsMintypmax_expressionContext() {}

func NewMintypmax_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mintypmax_expressionContext {
	var p = new(Mintypmax_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_mintypmax_expression

	return p
}

func (s *Mintypmax_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Mintypmax_expressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Mintypmax_expressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Mintypmax_expressionContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOLON)
}

func (s *Mintypmax_expressionContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, i)
}

func (s *Mintypmax_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mintypmax_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mintypmax_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMintypmax_expression(s)
	}
}

func (s *Mintypmax_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMintypmax_expression(s)
	}
}

func (p *VerilogParser) Mintypmax_expression() (localctx IMintypmax_expressionContext) {
	this := p
	_ = this

	localctx = NewMintypmax_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, VerilogParserRULE_mintypmax_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3863)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 388, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3856)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3857)
			p.expression(0)
		}
		{
			p.SetState(3858)
			p.Match(VerilogParserCOLON)
		}
		{
			p.SetState(3859)
			p.expression(0)
		}
		{
			p.SetState(3860)
			p.Match(VerilogParserCOLON)
		}
		{
			p.SetState(3861)
			p.expression(0)
		}

	}

	return localctx
}

// IModule_path_expressionContext is an interface to support dynamic dispatch.
type IModule_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_expressionContext differentiates from other interfaces.
	IsModule_path_expressionContext()
}

type Module_path_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_expressionContext() *Module_path_expressionContext {
	var p = new(Module_path_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_expression
	return p
}

func (*Module_path_expressionContext) IsModule_path_expressionContext() {}

func NewModule_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_expressionContext {
	var p = new(Module_path_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_expression

	return p
}

func (s *Module_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_expressionContext) Module_path_primary() IModule_path_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_primaryContext)
}

func (s *Module_path_expressionContext) Unary_module_path_operator() IUnary_module_path_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_module_path_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_module_path_operatorContext)
}

func (s *Module_path_expressionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_path_expressionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_path_expressionContext) AllModule_path_expression() []IModule_path_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem())
	var tst = make([]IModule_path_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_path_expressionContext)
		}
	}

	return tst
}

func (s *Module_path_expressionContext) Module_path_expression(i int) IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *Module_path_expressionContext) Binary_module_path_operator() IBinary_module_path_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_module_path_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinary_module_path_operatorContext)
}

func (s *Module_path_expressionContext) QUESTION_MARK() antlr.TerminalNode {
	return s.GetToken(VerilogParserQUESTION_MARK, 0)
}

func (s *Module_path_expressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *Module_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_path_expression(s)
	}
}

func (s *Module_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_path_expression(s)
	}
}

func (p *VerilogParser) Module_path_expression() (localctx IModule_path_expressionContext) {
	return p.module_path_expression(0)
}

func (p *VerilogParser) module_path_expression(_p int) (localctx IModule_path_expressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewModule_path_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IModule_path_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 582
	p.EnterRecursionRule(localctx, 582, VerilogParserRULE_module_path_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3876)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserREAL_NUMBER, VerilogParserDECIMAL_NUMBER, VerilogParserBINARY_NUMBER, VerilogParserOCTAL_NUMBER, VerilogParserHEX_NUMBER, VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER, VerilogParserSYSTEM_TF_IDENTIFIER, VerilogParserLEFT_PARENTHESIS, VerilogParserLEFT_BRACE:
		{
			p.SetState(3866)
			p.Module_path_primary()
		}

	case VerilogParserEXCLAMATION_MARK, VerilogParserTILDE, VerilogParserAMPERSAND, VerilogParserTILDE_AMPERSAND, VerilogParserVERTICAL_BAR, VerilogParserTILDE_VERTICAL_BAR, VerilogParserCARET, VerilogParserTILDE_CARET, VerilogParserCARET_TILDE:
		{
			p.SetState(3867)
			p.Unary_module_path_operator()
		}
		p.SetState(3871)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 389, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3868)
					p.Attribute_instance()
				}

			}
			p.SetState(3873)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 389, p.GetParserRuleContext())
		}
		{
			p.SetState(3874)
			p.Module_path_primary()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3902)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 394, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3900)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 393, p.GetParserRuleContext()) {
			case 1:
				localctx = NewModule_path_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, VerilogParserRULE_module_path_expression)
				p.SetState(3878)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(3879)
					p.Binary_module_path_operator()
				}
				p.SetState(3883)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 391, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3880)
							p.Attribute_instance()
						}

					}
					p.SetState(3885)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 391, p.GetParserRuleContext())
				}
				{
					p.SetState(3886)
					p.module_path_expression(3)
				}

			case 2:
				localctx = NewModule_path_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, VerilogParserRULE_module_path_expression)
				p.SetState(3888)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(3889)
					p.Match(VerilogParserQUESTION_MARK)
				}
				p.SetState(3893)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 392, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3890)
							p.Attribute_instance()
						}

					}
					p.SetState(3895)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 392, p.GetParserRuleContext())
				}
				{
					p.SetState(3896)
					p.module_path_expression(0)
				}
				{
					p.SetState(3897)
					p.Match(VerilogParserCOLON)
				}
				{
					p.SetState(3898)
					p.module_path_expression(2)
				}

			}

		}
		p.SetState(3904)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 394, p.GetParserRuleContext())
	}

	return localctx
}

// IModule_path_mintypmax_expressionContext is an interface to support dynamic dispatch.
type IModule_path_mintypmax_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_mintypmax_expressionContext differentiates from other interfaces.
	IsModule_path_mintypmax_expressionContext()
}

type Module_path_mintypmax_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_mintypmax_expressionContext() *Module_path_mintypmax_expressionContext {
	var p = new(Module_path_mintypmax_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_mintypmax_expression
	return p
}

func (*Module_path_mintypmax_expressionContext) IsModule_path_mintypmax_expressionContext() {}

func NewModule_path_mintypmax_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_mintypmax_expressionContext {
	var p = new(Module_path_mintypmax_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_mintypmax_expression

	return p
}

func (s *Module_path_mintypmax_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_mintypmax_expressionContext) AllModule_path_expression() []IModule_path_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem())
	var tst = make([]IModule_path_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_path_expressionContext)
		}
	}

	return tst
}

func (s *Module_path_mintypmax_expressionContext) Module_path_expression(i int) IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *Module_path_mintypmax_expressionContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOLON)
}

func (s *Module_path_mintypmax_expressionContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, i)
}

func (s *Module_path_mintypmax_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_mintypmax_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_mintypmax_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_path_mintypmax_expression(s)
	}
}

func (s *Module_path_mintypmax_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_path_mintypmax_expression(s)
	}
}

func (p *VerilogParser) Module_path_mintypmax_expression() (localctx IModule_path_mintypmax_expressionContext) {
	this := p
	_ = this

	localctx = NewModule_path_mintypmax_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, VerilogParserRULE_module_path_mintypmax_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3912)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 395, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3905)
			p.module_path_expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3906)
			p.module_path_expression(0)
		}
		{
			p.SetState(3907)
			p.Match(VerilogParserCOLON)
		}
		{
			p.SetState(3908)
			p.module_path_expression(0)
		}
		{
			p.SetState(3909)
			p.Match(VerilogParserCOLON)
		}
		{
			p.SetState(3910)
			p.module_path_expression(0)
		}

	}

	return localctx
}

// IMsb_constant_expressionContext is an interface to support dynamic dispatch.
type IMsb_constant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMsb_constant_expressionContext differentiates from other interfaces.
	IsMsb_constant_expressionContext()
}

type Msb_constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMsb_constant_expressionContext() *Msb_constant_expressionContext {
	var p = new(Msb_constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_msb_constant_expression
	return p
}

func (*Msb_constant_expressionContext) IsMsb_constant_expressionContext() {}

func NewMsb_constant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Msb_constant_expressionContext {
	var p = new(Msb_constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_msb_constant_expression

	return p
}

func (s *Msb_constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Msb_constant_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Msb_constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Msb_constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Msb_constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMsb_constant_expression(s)
	}
}

func (s *Msb_constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMsb_constant_expression(s)
	}
}

func (p *VerilogParser) Msb_constant_expression() (localctx IMsb_constant_expressionContext) {
	this := p
	_ = this

	localctx = NewMsb_constant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, VerilogParserRULE_msb_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3914)
		p.constant_expression(0)
	}

	return localctx
}

// IRange_expressionContext is an interface to support dynamic dispatch.
type IRange_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_expressionContext differentiates from other interfaces.
	IsRange_expressionContext()
}

type Range_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_expressionContext() *Range_expressionContext {
	var p = new(Range_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_range_expression
	return p
}

func (*Range_expressionContext) IsRange_expressionContext() {}

func NewRange_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_expressionContext {
	var p = new(Range_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_range_expression

	return p
}

func (s *Range_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Range_expressionContext) Msb_constant_expression() IMsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMsb_constant_expressionContext)
}

func (s *Range_expressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserCOLON, 0)
}

func (s *Range_expressionContext) Lsb_constant_expression() ILsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILsb_constant_expressionContext)
}

func (s *Range_expressionContext) Base_expression() IBase_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_expressionContext)
}

func (s *Range_expressionContext) PLUS_COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserPLUS_COLON, 0)
}

func (s *Range_expressionContext) Width_constant_expression() IWidth_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWidth_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWidth_constant_expressionContext)
}

func (s *Range_expressionContext) MINUS_COLON() antlr.TerminalNode {
	return s.GetToken(VerilogParserMINUS_COLON, 0)
}

func (s *Range_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterRange_expression(s)
	}
}

func (s *Range_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitRange_expression(s)
	}
}

func (p *VerilogParser) Range_expression() (localctx IRange_expressionContext) {
	this := p
	_ = this

	localctx = NewRange_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, VerilogParserRULE_range_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3929)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 396, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3916)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3917)
			p.Msb_constant_expression()
		}
		{
			p.SetState(3918)
			p.Match(VerilogParserCOLON)
		}
		{
			p.SetState(3919)
			p.Lsb_constant_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3921)
			p.Base_expression()
		}
		{
			p.SetState(3922)
			p.Match(VerilogParserPLUS_COLON)
		}
		{
			p.SetState(3923)
			p.Width_constant_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3925)
			p.Base_expression()
		}
		{
			p.SetState(3926)
			p.Match(VerilogParserMINUS_COLON)
		}
		{
			p.SetState(3927)
			p.Width_constant_expression()
		}

	}

	return localctx
}

// IWidth_constant_expressionContext is an interface to support dynamic dispatch.
type IWidth_constant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWidth_constant_expressionContext differentiates from other interfaces.
	IsWidth_constant_expressionContext()
}

type Width_constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWidth_constant_expressionContext() *Width_constant_expressionContext {
	var p = new(Width_constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_width_constant_expression
	return p
}

func (*Width_constant_expressionContext) IsWidth_constant_expressionContext() {}

func NewWidth_constant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Width_constant_expressionContext {
	var p = new(Width_constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_width_constant_expression

	return p
}

func (s *Width_constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Width_constant_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Width_constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Width_constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Width_constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterWidth_constant_expression(s)
	}
}

func (s *Width_constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitWidth_constant_expression(s)
	}
}

func (p *VerilogParser) Width_constant_expression() (localctx IWidth_constant_expressionContext) {
	this := p
	_ = this

	localctx = NewWidth_constant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, VerilogParserRULE_width_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3931)
		p.constant_expression(0)
	}

	return localctx
}

// IConstant_primaryContext is an interface to support dynamic dispatch.
type IConstant_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_primaryContext differentiates from other interfaces.
	IsConstant_primaryContext()
}

type Constant_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_primaryContext() *Constant_primaryContext {
	var p = new(Constant_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_primary
	return p
}

func (*Constant_primaryContext) IsConstant_primaryContext() {}

func NewConstant_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_primaryContext {
	var p = new(Constant_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_primary

	return p
}

func (s *Constant_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_primaryContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Constant_primaryContext) Parameter_identifier() IParameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_identifierContext)
}

func (s *Constant_primaryContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACKET, 0)
}

func (s *Constant_primaryContext) Constant_range_expression() IConstant_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_range_expressionContext)
}

func (s *Constant_primaryContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACKET, 0)
}

func (s *Constant_primaryContext) Specparam_identifier() ISpecparam_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_identifierContext)
}

func (s *Constant_primaryContext) Constant_concatenation() IConstant_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_concatenationContext)
}

func (s *Constant_primaryContext) Constant_multiple_concatenation() IConstant_multiple_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_multiple_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_multiple_concatenationContext)
}

func (s *Constant_primaryContext) Constant_function_call() IConstant_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_function_callContext)
}

func (s *Constant_primaryContext) Constant_system_function_call() IConstant_system_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_system_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_system_function_callContext)
}

func (s *Constant_primaryContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Constant_primaryContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Constant_primaryContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Constant_primaryContext) STRING() antlr.TerminalNode {
	return s.GetToken(VerilogParserSTRING, 0)
}

func (s *Constant_primaryContext) Conversion_functions() IConversion_functionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConversion_functionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConversion_functionsContext)
}

func (s *Constant_primaryContext) Random_function() IRandom_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRandom_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRandom_functionContext)
}

func (s *Constant_primaryContext) Dist_functions() IDist_functionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDist_functionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDist_functionsContext)
}

func (s *Constant_primaryContext) Math_functions() IMath_functionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMath_functionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMath_functionsContext)
}

func (s *Constant_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_primary(s)
	}
}

func (s *Constant_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_primary(s)
	}
}

func (p *VerilogParser) Constant_primary() (localctx IConstant_primaryContext) {
	this := p
	_ = this

	localctx = NewConstant_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, VerilogParserRULE_constant_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3961)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 399, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3933)
			p.Number()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3934)
			p.Parameter_identifier()
		}
		p.SetState(3939)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 397, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3935)
				p.Match(VerilogParserLEFT_BRACKET)
			}
			{
				p.SetState(3936)
				p.Constant_range_expression()
			}
			{
				p.SetState(3937)
				p.Match(VerilogParserRIGHT_BRACKET)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3941)
			p.Specparam_identifier()
		}
		p.SetState(3946)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 398, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3942)
				p.Match(VerilogParserLEFT_BRACKET)
			}
			{
				p.SetState(3943)
				p.Constant_range_expression()
			}
			{
				p.SetState(3944)
				p.Match(VerilogParserRIGHT_BRACKET)
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3948)
			p.Constant_concatenation()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3949)
			p.Constant_multiple_concatenation()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3950)
			p.Constant_function_call()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3951)
			p.Constant_system_function_call()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3952)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3953)
			p.Constant_mintypmax_expression()
		}
		{
			p.SetState(3954)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3956)
			p.Match(VerilogParserSTRING)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3957)
			p.Conversion_functions()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3958)
			p.Random_function()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3959)
			p.Dist_functions()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3960)
			p.Math_functions()
		}

	}

	return localctx
}

// IModule_path_primaryContext is an interface to support dynamic dispatch.
type IModule_path_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_primaryContext differentiates from other interfaces.
	IsModule_path_primaryContext()
}

type Module_path_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_primaryContext() *Module_path_primaryContext {
	var p = new(Module_path_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_primary
	return p
}

func (*Module_path_primaryContext) IsModule_path_primaryContext() {}

func NewModule_path_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_primaryContext {
	var p = new(Module_path_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_primary

	return p
}

func (s *Module_path_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_primaryContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Module_path_primaryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Module_path_primaryContext) Module_path_concatenation() IModule_path_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_concatenationContext)
}

func (s *Module_path_primaryContext) Module_path_multiple_concatenation() IModule_path_multiple_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_multiple_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_multiple_concatenationContext)
}

func (s *Module_path_primaryContext) Function_call() IFunction_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *Module_path_primaryContext) System_function_call() ISystem_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_function_callContext)
}

func (s *Module_path_primaryContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Module_path_primaryContext) Module_path_mintypmax_expression() IModule_path_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_mintypmax_expressionContext)
}

func (s *Module_path_primaryContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Module_path_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_path_primary(s)
	}
}

func (s *Module_path_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_path_primary(s)
	}
}

func (p *VerilogParser) Module_path_primary() (localctx IModule_path_primaryContext) {
	this := p
	_ = this

	localctx = NewModule_path_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, VerilogParserRULE_module_path_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3973)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 400, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3963)
			p.Number()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3964)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3965)
			p.Module_path_concatenation()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3966)
			p.Module_path_multiple_concatenation()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3967)
			p.Function_call()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3968)
			p.System_function_call()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3969)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3970)
			p.Module_path_mintypmax_expression()
		}
		{
			p.SetState(3971)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *PrimaryContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *PrimaryContext) AllLEFT_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLEFT_BRACKET)
}

func (s *PrimaryContext) LEFT_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACKET, i)
}

func (s *PrimaryContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *PrimaryContext) AllRIGHT_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRIGHT_BRACKET)
}

func (s *PrimaryContext) RIGHT_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACKET, i)
}

func (s *PrimaryContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *PrimaryContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *PrimaryContext) Multiple_concatenation() IMultiple_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiple_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiple_concatenationContext)
}

func (s *PrimaryContext) Function_call() IFunction_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *PrimaryContext) System_function_call() ISystem_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_function_callContext)
}

func (s *PrimaryContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *PrimaryContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *PrimaryContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *PrimaryContext) STRING() antlr.TerminalNode {
	return s.GetToken(VerilogParserSTRING, 0)
}

func (s *PrimaryContext) Conversion_functions() IConversion_functionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConversion_functionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConversion_functionsContext)
}

func (s *PrimaryContext) Random_function() IRandom_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRandom_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRandom_functionContext)
}

func (s *PrimaryContext) Dist_functions() IDist_functionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDist_functionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDist_functionsContext)
}

func (s *PrimaryContext) Math_functions() IMath_functionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMath_functionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMath_functionsContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (p *VerilogParser) Primary() (localctx IPrimaryContext) {
	this := p
	_ = this

	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, VerilogParserRULE_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(4005)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 403, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3975)
			p.Number()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3976)
			p.Hierarchical_identifier()
		}
		p.SetState(3990)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 402, p.GetParserRuleContext()) == 1 {
			p.SetState(3983)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 401, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(3977)
						p.Match(VerilogParserLEFT_BRACKET)
					}
					{
						p.SetState(3978)
						p.expression(0)
					}
					{
						p.SetState(3979)
						p.Match(VerilogParserRIGHT_BRACKET)
					}

				}
				p.SetState(3985)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 401, p.GetParserRuleContext())
			}
			{
				p.SetState(3986)
				p.Match(VerilogParserLEFT_BRACKET)
			}
			{
				p.SetState(3987)
				p.Range_expression()
			}
			{
				p.SetState(3988)
				p.Match(VerilogParserRIGHT_BRACKET)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3992)
			p.Concatenation()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3993)
			p.Multiple_concatenation()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3994)
			p.Function_call()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3995)
			p.System_function_call()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3996)
			p.Match(VerilogParserLEFT_PARENTHESIS)
		}
		{
			p.SetState(3997)
			p.Mintypmax_expression()
		}
		{
			p.SetState(3998)
			p.Match(VerilogParserRIGHT_PARENTHESIS)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4000)
			p.Match(VerilogParserSTRING)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4001)
			p.Conversion_functions()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4002)
			p.Random_function()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4003)
			p.Dist_functions()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4004)
			p.Math_functions()
		}

	}

	return localctx
}

// INet_lvalueContext is an interface to support dynamic dispatch.
type INet_lvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_lvalueContext differentiates from other interfaces.
	IsNet_lvalueContext()
}

type Net_lvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_lvalueContext() *Net_lvalueContext {
	var p = new(Net_lvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_lvalue
	return p
}

func (*Net_lvalueContext) IsNet_lvalueContext() {}

func NewNet_lvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_lvalueContext {
	var p = new(Net_lvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_lvalue

	return p
}

func (s *Net_lvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_lvalueContext) Hierarchical_net_identifier() IHierarchical_net_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_net_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_net_identifierContext)
}

func (s *Net_lvalueContext) AllLEFT_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLEFT_BRACKET)
}

func (s *Net_lvalueContext) LEFT_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACKET, i)
}

func (s *Net_lvalueContext) Constant_range_expression() IConstant_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_range_expressionContext)
}

func (s *Net_lvalueContext) AllRIGHT_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRIGHT_BRACKET)
}

func (s *Net_lvalueContext) RIGHT_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACKET, i)
}

func (s *Net_lvalueContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Net_lvalueContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Net_lvalueContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACE, 0)
}

func (s *Net_lvalueContext) AllNet_lvalue() []INet_lvalueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem())
	var tst = make([]INet_lvalueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_lvalueContext)
		}
	}

	return tst
}

func (s *Net_lvalueContext) Net_lvalue(i int) INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Net_lvalueContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACE, 0)
}

func (s *Net_lvalueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Net_lvalueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Net_lvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_lvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_lvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNet_lvalue(s)
	}
}

func (s *Net_lvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNet_lvalue(s)
	}
}

func (p *VerilogParser) Net_lvalue() (localctx INet_lvalueContext) {
	this := p
	_ = this

	localctx = NewNet_lvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, VerilogParserRULE_net_lvalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(4034)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4007)
			p.Hierarchical_net_identifier()
		}
		p.SetState(4021)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_BRACKET {
			p.SetState(4014)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 404, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(4008)
						p.Match(VerilogParserLEFT_BRACKET)
					}
					{
						p.SetState(4009)
						p.constant_expression(0)
					}
					{
						p.SetState(4010)
						p.Match(VerilogParserRIGHT_BRACKET)
					}

				}
				p.SetState(4016)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 404, p.GetParserRuleContext())
			}
			{
				p.SetState(4017)
				p.Match(VerilogParserLEFT_BRACKET)
			}
			{
				p.SetState(4018)
				p.Constant_range_expression()
			}
			{
				p.SetState(4019)
				p.Match(VerilogParserRIGHT_BRACKET)
			}

		}

	case VerilogParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4023)
			p.Match(VerilogParserLEFT_BRACE)
		}
		{
			p.SetState(4024)
			p.Net_lvalue()
		}
		p.SetState(4029)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(4025)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(4026)
				p.Net_lvalue()
			}

			p.SetState(4031)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4032)
			p.Match(VerilogParserRIGHT_BRACE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariable_lvalueContext is an interface to support dynamic dispatch.
type IVariable_lvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_lvalueContext differentiates from other interfaces.
	IsVariable_lvalueContext()
}

type Variable_lvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_lvalueContext() *Variable_lvalueContext {
	var p = new(Variable_lvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_lvalue
	return p
}

func (*Variable_lvalueContext) IsVariable_lvalueContext() {}

func NewVariable_lvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_lvalueContext {
	var p = new(Variable_lvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_lvalue

	return p
}

func (s *Variable_lvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_lvalueContext) Hierarchical_variable_identifier() IHierarchical_variable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_variable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_variable_identifierContext)
}

func (s *Variable_lvalueContext) AllLEFT_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLEFT_BRACKET)
}

func (s *Variable_lvalueContext) LEFT_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACKET, i)
}

func (s *Variable_lvalueContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *Variable_lvalueContext) AllRIGHT_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRIGHT_BRACKET)
}

func (s *Variable_lvalueContext) RIGHT_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACKET, i)
}

func (s *Variable_lvalueContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Variable_lvalueContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_lvalueContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACE, 0)
}

func (s *Variable_lvalueContext) AllVariable_lvalue() []IVariable_lvalueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem())
	var tst = make([]IVariable_lvalueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_lvalueContext)
		}
	}

	return tst
}

func (s *Variable_lvalueContext) Variable_lvalue(i int) IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Variable_lvalueContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACE, 0)
}

func (s *Variable_lvalueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Variable_lvalueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Variable_lvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_lvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_lvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterVariable_lvalue(s)
	}
}

func (s *Variable_lvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitVariable_lvalue(s)
	}
}

func (p *VerilogParser) Variable_lvalue() (localctx IVariable_lvalueContext) {
	this := p
	_ = this

	localctx = NewVariable_lvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, VerilogParserRULE_variable_lvalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(4063)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserESCAPED_IDENTIFIER, VerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4036)
			p.Hierarchical_variable_identifier()
		}
		p.SetState(4050)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLEFT_BRACKET {
			p.SetState(4043)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 408, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(4037)
						p.Match(VerilogParserLEFT_BRACKET)
					}
					{
						p.SetState(4038)
						p.expression(0)
					}
					{
						p.SetState(4039)
						p.Match(VerilogParserRIGHT_BRACKET)
					}

				}
				p.SetState(4045)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 408, p.GetParserRuleContext())
			}
			{
				p.SetState(4046)
				p.Match(VerilogParserLEFT_BRACKET)
			}
			{
				p.SetState(4047)
				p.Range_expression()
			}
			{
				p.SetState(4048)
				p.Match(VerilogParserRIGHT_BRACKET)
			}

		}

	case VerilogParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4052)
			p.Match(VerilogParserLEFT_BRACE)
		}
		{
			p.SetState(4053)
			p.Variable_lvalue()
		}
		p.SetState(4058)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserCOMMA {
			{
				p.SetState(4054)
				p.Match(VerilogParserCOMMA)
			}
			{
				p.SetState(4055)
				p.Variable_lvalue()
			}

			p.SetState(4060)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4061)
			p.Match(VerilogParserRIGHT_BRACE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnary_operatorContext is an interface to support dynamic dispatch.
type IUnary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_operatorContext differentiates from other interfaces.
	IsUnary_operatorContext()
}

type Unary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_operatorContext() *Unary_operatorContext {
	var p = new(Unary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_unary_operator
	return p
}

func (*Unary_operatorContext) IsUnary_operatorContext() {}

func NewUnary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_operatorContext {
	var p = new(Unary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_unary_operator

	return p
}

func (s *Unary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_operatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(VerilogParserPLUS, 0)
}

func (s *Unary_operatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(VerilogParserMINUS, 0)
}

func (s *Unary_operatorContext) EXCLAMATION_MARK() antlr.TerminalNode {
	return s.GetToken(VerilogParserEXCLAMATION_MARK, 0)
}

func (s *Unary_operatorContext) TILDE() antlr.TerminalNode {
	return s.GetToken(VerilogParserTILDE, 0)
}

func (s *Unary_operatorContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(VerilogParserAMPERSAND, 0)
}

func (s *Unary_operatorContext) TILDE_AMPERSAND() antlr.TerminalNode {
	return s.GetToken(VerilogParserTILDE_AMPERSAND, 0)
}

func (s *Unary_operatorContext) VERTICAL_BAR() antlr.TerminalNode {
	return s.GetToken(VerilogParserVERTICAL_BAR, 0)
}

func (s *Unary_operatorContext) TILDE_VERTICAL_BAR() antlr.TerminalNode {
	return s.GetToken(VerilogParserTILDE_VERTICAL_BAR, 0)
}

func (s *Unary_operatorContext) CARET() antlr.TerminalNode {
	return s.GetToken(VerilogParserCARET, 0)
}

func (s *Unary_operatorContext) TILDE_CARET() antlr.TerminalNode {
	return s.GetToken(VerilogParserTILDE_CARET, 0)
}

func (s *Unary_operatorContext) CARET_TILDE() antlr.TerminalNode {
	return s.GetToken(VerilogParserCARET_TILDE, 0)
}

func (s *Unary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterUnary_operator(s)
	}
}

func (s *Unary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitUnary_operator(s)
	}
}

func (p *VerilogParser) Unary_operator() (localctx IUnary_operatorContext) {
	this := p
	_ = this

	localctx = NewUnary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, VerilogParserRULE_unary_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4065)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-300)&-(0x1f+1)) == 0 && ((1<<uint((_la-300)))&((1<<(VerilogParserPLUS-300))|(1<<(VerilogParserMINUS-300))|(1<<(VerilogParserEXCLAMATION_MARK-300))|(1<<(VerilogParserTILDE-300))|(1<<(VerilogParserAMPERSAND-300))|(1<<(VerilogParserTILDE_AMPERSAND-300))|(1<<(VerilogParserVERTICAL_BAR-300))|(1<<(VerilogParserTILDE_VERTICAL_BAR-300))|(1<<(VerilogParserCARET-300))|(1<<(VerilogParserTILDE_CARET-300))|(1<<(VerilogParserCARET_TILDE-300)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBinary_operatorContext is an interface to support dynamic dispatch.
type IBinary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinary_operatorContext differentiates from other interfaces.
	IsBinary_operatorContext()
}

type Binary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinary_operatorContext() *Binary_operatorContext {
	var p = new(Binary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_binary_operator
	return p
}

func (*Binary_operatorContext) IsBinary_operatorContext() {}

func NewBinary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Binary_operatorContext {
	var p = new(Binary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_binary_operator

	return p
}

func (s *Binary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Binary_operatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(VerilogParserPLUS, 0)
}

func (s *Binary_operatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(VerilogParserMINUS, 0)
}

func (s *Binary_operatorContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(VerilogParserASTERISK, 0)
}

func (s *Binary_operatorContext) SLASH() antlr.TerminalNode {
	return s.GetToken(VerilogParserSLASH, 0)
}

func (s *Binary_operatorContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(VerilogParserPERCENT, 0)
}

func (s *Binary_operatorContext) DOUBLE_EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOUBLE_EQUAL, 0)
}

func (s *Binary_operatorContext) EXCLAMATION_MARK_EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEXCLAMATION_MARK_EQUAL, 0)
}

func (s *Binary_operatorContext) TRIPLE_EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserTRIPLE_EQUAL, 0)
}

func (s *Binary_operatorContext) EXCLAMATION_MARK_DOUBLE_EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEXCLAMATION_MARK_DOUBLE_EQUAL, 0)
}

func (s *Binary_operatorContext) DOUBLE_AMPERSAND() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOUBLE_AMPERSAND, 0)
}

func (s *Binary_operatorContext) DOUBLE_VERTICAL_BAR() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOUBLE_VERTICAL_BAR, 0)
}

func (s *Binary_operatorContext) DOUBLE_ASTERISK() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOUBLE_ASTERISK, 0)
}

func (s *Binary_operatorContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserLESS_THAN, 0)
}

func (s *Binary_operatorContext) LESS_THAN_EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserLESS_THAN_EQUAL, 0)
}

func (s *Binary_operatorContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserGREATER_THAN, 0)
}

func (s *Binary_operatorContext) GREATER_THAN_EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserGREATER_THAN_EQUAL, 0)
}

func (s *Binary_operatorContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(VerilogParserAMPERSAND, 0)
}

func (s *Binary_operatorContext) VERTICAL_BAR() antlr.TerminalNode {
	return s.GetToken(VerilogParserVERTICAL_BAR, 0)
}

func (s *Binary_operatorContext) CARET() antlr.TerminalNode {
	return s.GetToken(VerilogParserCARET, 0)
}

func (s *Binary_operatorContext) CARET_TILDE() antlr.TerminalNode {
	return s.GetToken(VerilogParserCARET_TILDE, 0)
}

func (s *Binary_operatorContext) TILDE_CARET() antlr.TerminalNode {
	return s.GetToken(VerilogParserTILDE_CARET, 0)
}

func (s *Binary_operatorContext) DOUBLE_GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOUBLE_GREATER_THAN, 0)
}

func (s *Binary_operatorContext) DOUBLE_LESS_THAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOUBLE_LESS_THAN, 0)
}

func (s *Binary_operatorContext) TRIPLE_GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserTRIPLE_GREATER_THAN, 0)
}

func (s *Binary_operatorContext) TRIPLE_LESS_THAN() antlr.TerminalNode {
	return s.GetToken(VerilogParserTRIPLE_LESS_THAN, 0)
}

func (s *Binary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Binary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBinary_operator(s)
	}
}

func (s *Binary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBinary_operator(s)
	}
}

func (p *VerilogParser) Binary_operator() (localctx IBinary_operatorContext) {
	this := p
	_ = this

	localctx = NewBinary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, VerilogParserRULE_binary_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4067)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-300)&-(0x1f+1)) == 0 && ((1<<uint((_la-300)))&((1<<(VerilogParserPLUS-300))|(1<<(VerilogParserMINUS-300))|(1<<(VerilogParserAMPERSAND-300))|(1<<(VerilogParserVERTICAL_BAR-300))|(1<<(VerilogParserCARET-300))|(1<<(VerilogParserTILDE_CARET-300))|(1<<(VerilogParserCARET_TILDE-300))|(1<<(VerilogParserASTERISK-300))|(1<<(VerilogParserPERCENT-300))|(1<<(VerilogParserDOUBLE_EQUAL-300))|(1<<(VerilogParserEXCLAMATION_MARK_EQUAL-300))|(1<<(VerilogParserTRIPLE_EQUAL-300))|(1<<(VerilogParserEXCLAMATION_MARK_DOUBLE_EQUAL-300))|(1<<(VerilogParserDOUBLE_AMPERSAND-300))|(1<<(VerilogParserDOUBLE_VERTICAL_BAR-300))|(1<<(VerilogParserDOUBLE_ASTERISK-300))|(1<<(VerilogParserLESS_THAN-300))|(1<<(VerilogParserLESS_THAN_EQUAL-300))|(1<<(VerilogParserGREATER_THAN-300))|(1<<(VerilogParserGREATER_THAN_EQUAL-300))|(1<<(VerilogParserDOUBLE_GREATER_THAN-300))|(1<<(VerilogParserDOUBLE_LESS_THAN-300))|(1<<(VerilogParserTRIPLE_GREATER_THAN-300))|(1<<(VerilogParserTRIPLE_LESS_THAN-300)))) != 0) || _la == VerilogParserSLASH) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUnary_module_path_operatorContext is an interface to support dynamic dispatch.
type IUnary_module_path_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_module_path_operatorContext differentiates from other interfaces.
	IsUnary_module_path_operatorContext()
}

type Unary_module_path_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_module_path_operatorContext() *Unary_module_path_operatorContext {
	var p = new(Unary_module_path_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_unary_module_path_operator
	return p
}

func (*Unary_module_path_operatorContext) IsUnary_module_path_operatorContext() {}

func NewUnary_module_path_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_module_path_operatorContext {
	var p = new(Unary_module_path_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_unary_module_path_operator

	return p
}

func (s *Unary_module_path_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_module_path_operatorContext) EXCLAMATION_MARK() antlr.TerminalNode {
	return s.GetToken(VerilogParserEXCLAMATION_MARK, 0)
}

func (s *Unary_module_path_operatorContext) TILDE() antlr.TerminalNode {
	return s.GetToken(VerilogParserTILDE, 0)
}

func (s *Unary_module_path_operatorContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(VerilogParserAMPERSAND, 0)
}

func (s *Unary_module_path_operatorContext) TILDE_AMPERSAND() antlr.TerminalNode {
	return s.GetToken(VerilogParserTILDE_AMPERSAND, 0)
}

func (s *Unary_module_path_operatorContext) VERTICAL_BAR() antlr.TerminalNode {
	return s.GetToken(VerilogParserVERTICAL_BAR, 0)
}

func (s *Unary_module_path_operatorContext) TILDE_VERTICAL_BAR() antlr.TerminalNode {
	return s.GetToken(VerilogParserTILDE_VERTICAL_BAR, 0)
}

func (s *Unary_module_path_operatorContext) CARET() antlr.TerminalNode {
	return s.GetToken(VerilogParserCARET, 0)
}

func (s *Unary_module_path_operatorContext) TILDE_CARET() antlr.TerminalNode {
	return s.GetToken(VerilogParserTILDE_CARET, 0)
}

func (s *Unary_module_path_operatorContext) CARET_TILDE() antlr.TerminalNode {
	return s.GetToken(VerilogParserCARET_TILDE, 0)
}

func (s *Unary_module_path_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_module_path_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_module_path_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterUnary_module_path_operator(s)
	}
}

func (s *Unary_module_path_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitUnary_module_path_operator(s)
	}
}

func (p *VerilogParser) Unary_module_path_operator() (localctx IUnary_module_path_operatorContext) {
	this := p
	_ = this

	localctx = NewUnary_module_path_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, VerilogParserRULE_unary_module_path_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4069)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-302)&-(0x1f+1)) == 0 && ((1<<uint((_la-302)))&((1<<(VerilogParserEXCLAMATION_MARK-302))|(1<<(VerilogParserTILDE-302))|(1<<(VerilogParserAMPERSAND-302))|(1<<(VerilogParserTILDE_AMPERSAND-302))|(1<<(VerilogParserVERTICAL_BAR-302))|(1<<(VerilogParserTILDE_VERTICAL_BAR-302))|(1<<(VerilogParserCARET-302))|(1<<(VerilogParserTILDE_CARET-302))|(1<<(VerilogParserCARET_TILDE-302)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBinary_module_path_operatorContext is an interface to support dynamic dispatch.
type IBinary_module_path_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinary_module_path_operatorContext differentiates from other interfaces.
	IsBinary_module_path_operatorContext()
}

type Binary_module_path_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinary_module_path_operatorContext() *Binary_module_path_operatorContext {
	var p = new(Binary_module_path_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_binary_module_path_operator
	return p
}

func (*Binary_module_path_operatorContext) IsBinary_module_path_operatorContext() {}

func NewBinary_module_path_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Binary_module_path_operatorContext {
	var p = new(Binary_module_path_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_binary_module_path_operator

	return p
}

func (s *Binary_module_path_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Binary_module_path_operatorContext) DOUBLE_EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOUBLE_EQUAL, 0)
}

func (s *Binary_module_path_operatorContext) EXCLAMATION_MARK_EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEXCLAMATION_MARK_EQUAL, 0)
}

func (s *Binary_module_path_operatorContext) DOUBLE_AMPERSAND() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOUBLE_AMPERSAND, 0)
}

func (s *Binary_module_path_operatorContext) DOUBLE_VERTICAL_BAR() antlr.TerminalNode {
	return s.GetToken(VerilogParserDOUBLE_VERTICAL_BAR, 0)
}

func (s *Binary_module_path_operatorContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(VerilogParserAMPERSAND, 0)
}

func (s *Binary_module_path_operatorContext) VERTICAL_BAR() antlr.TerminalNode {
	return s.GetToken(VerilogParserVERTICAL_BAR, 0)
}

func (s *Binary_module_path_operatorContext) CARET() antlr.TerminalNode {
	return s.GetToken(VerilogParserCARET, 0)
}

func (s *Binary_module_path_operatorContext) TILDE_CARET() antlr.TerminalNode {
	return s.GetToken(VerilogParserTILDE_CARET, 0)
}

func (s *Binary_module_path_operatorContext) CARET_TILDE() antlr.TerminalNode {
	return s.GetToken(VerilogParserCARET_TILDE, 0)
}

func (s *Binary_module_path_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binary_module_path_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Binary_module_path_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBinary_module_path_operator(s)
	}
}

func (s *Binary_module_path_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBinary_module_path_operator(s)
	}
}

func (p *VerilogParser) Binary_module_path_operator() (localctx IBinary_module_path_operatorContext) {
	this := p
	_ = this

	localctx = NewBinary_module_path_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, VerilogParserRULE_binary_module_path_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4071)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-304)&-(0x1f+1)) == 0 && ((1<<uint((_la-304)))&((1<<(VerilogParserAMPERSAND-304))|(1<<(VerilogParserVERTICAL_BAR-304))|(1<<(VerilogParserCARET-304))|(1<<(VerilogParserTILDE_CARET-304))|(1<<(VerilogParserCARET_TILDE-304))|(1<<(VerilogParserDOUBLE_EQUAL-304))|(1<<(VerilogParserEXCLAMATION_MARK_EQUAL-304))|(1<<(VerilogParserDOUBLE_AMPERSAND-304))|(1<<(VerilogParserDOUBLE_VERTICAL_BAR-304)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserDECIMAL_NUMBER, 0)
}

func (s *NumberContext) OCTAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserOCTAL_NUMBER, 0)
}

func (s *NumberContext) BINARY_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserBINARY_NUMBER, 0)
}

func (s *NumberContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserHEX_NUMBER, 0)
}

func (s *NumberContext) REAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(VerilogParserREAL_NUMBER, 0)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (p *VerilogParser) Number() (localctx INumberContext) {
	this := p
	_ = this

	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, VerilogParserRULE_number)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4073)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-282)&-(0x1f+1)) == 0 && ((1<<uint((_la-282)))&((1<<(VerilogParserREAL_NUMBER-282))|(1<<(VerilogParserDECIMAL_NUMBER-282))|(1<<(VerilogParserBINARY_NUMBER-282))|(1<<(VerilogParserOCTAL_NUMBER-282))|(1<<(VerilogParserHEX_NUMBER-282)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAttribute_instanceContext is an interface to support dynamic dispatch.
type IAttribute_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_instanceContext differentiates from other interfaces.
	IsAttribute_instanceContext()
}

type Attribute_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_instanceContext() *Attribute_instanceContext {
	var p = new(Attribute_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_attribute_instance
	return p
}

func (*Attribute_instanceContext) IsAttribute_instanceContext() {}

func NewAttribute_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_instanceContext {
	var p = new(Attribute_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_attribute_instance

	return p
}

func (s *Attribute_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_instanceContext) LEFT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_PARENTHESIS, 0)
}

func (s *Attribute_instanceContext) AllASTERISK() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserASTERISK)
}

func (s *Attribute_instanceContext) ASTERISK(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserASTERISK, i)
}

func (s *Attribute_instanceContext) AllAttr_spec() []IAttr_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttr_specContext)(nil)).Elem())
	var tst = make([]IAttr_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttr_specContext)
		}
	}

	return tst
}

func (s *Attribute_instanceContext) Attr_spec(i int) IAttr_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttr_specContext)
}

func (s *Attribute_instanceContext) RIGHT_PARENTHESIS() antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_PARENTHESIS, 0)
}

func (s *Attribute_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserCOMMA)
}

func (s *Attribute_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserCOMMA, i)
}

func (s *Attribute_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterAttribute_instance(s)
	}
}

func (s *Attribute_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitAttribute_instance(s)
	}
}

func (p *VerilogParser) Attribute_instance() (localctx IAttribute_instanceContext) {
	this := p
	_ = this

	localctx = NewAttribute_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, VerilogParserRULE_attribute_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4075)
		p.Match(VerilogParserLEFT_PARENTHESIS)
	}
	{
		p.SetState(4076)
		p.Match(VerilogParserASTERISK)
	}
	{
		p.SetState(4077)
		p.Attr_spec()
	}
	p.SetState(4082)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserCOMMA {
		{
			p.SetState(4078)
			p.Match(VerilogParserCOMMA)
		}
		{
			p.SetState(4079)
			p.Attr_spec()
		}

		p.SetState(4084)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4085)
		p.Match(VerilogParserASTERISK)
	}
	{
		p.SetState(4086)
		p.Match(VerilogParserRIGHT_PARENTHESIS)
	}

	return localctx
}

// IAttr_specContext is an interface to support dynamic dispatch.
type IAttr_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_specContext differentiates from other interfaces.
	IsAttr_specContext()
}

type Attr_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_specContext() *Attr_specContext {
	var p = new(Attr_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_attr_spec
	return p
}

func (*Attr_specContext) IsAttr_specContext() {}

func NewAttr_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_specContext {
	var p = new(Attr_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_attr_spec

	return p
}

func (s *Attr_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_specContext) Attr_name() IAttr_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_nameContext)
}

func (s *Attr_specContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(VerilogParserEQUAL, 0)
}

func (s *Attr_specContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Attr_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterAttr_spec(s)
	}
}

func (s *Attr_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitAttr_spec(s)
	}
}

func (p *VerilogParser) Attr_spec() (localctx IAttr_specContext) {
	this := p
	_ = this

	localctx = NewAttr_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, VerilogParserRULE_attr_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4088)
		p.Attr_name()
	}
	p.SetState(4091)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEQUAL {
		{
			p.SetState(4089)
			p.Match(VerilogParserEQUAL)
		}
		{
			p.SetState(4090)
			p.constant_expression(0)
		}

	}

	return localctx
}

// IAttr_nameContext is an interface to support dynamic dispatch.
type IAttr_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_nameContext differentiates from other interfaces.
	IsAttr_nameContext()
}

type Attr_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_nameContext() *Attr_nameContext {
	var p = new(Attr_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_attr_name
	return p
}

func (*Attr_nameContext) IsAttr_nameContext() {}

func NewAttr_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_nameContext {
	var p = new(Attr_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_attr_name

	return p
}

func (s *Attr_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Attr_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterAttr_name(s)
	}
}

func (s *Attr_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitAttr_name(s)
	}
}

func (p *VerilogParser) Attr_name() (localctx IAttr_nameContext) {
	this := p
	_ = this

	localctx = NewAttr_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, VerilogParserRULE_attr_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4093)
		p.Identifier()
	}

	return localctx
}

// IBlock_identifierContext is an interface to support dynamic dispatch.
type IBlock_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_identifierContext differentiates from other interfaces.
	IsBlock_identifierContext()
}

type Block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_identifierContext() *Block_identifierContext {
	var p = new(Block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_block_identifier
	return p
}

func (*Block_identifierContext) IsBlock_identifierContext() {}

func NewBlock_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_identifierContext {
	var p = new(Block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_block_identifier

	return p
}

func (s *Block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBlock_identifier(s)
	}
}

func (s *Block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBlock_identifier(s)
	}
}

func (p *VerilogParser) Block_identifier() (localctx IBlock_identifierContext) {
	this := p
	_ = this

	localctx = NewBlock_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, VerilogParserRULE_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4095)
		p.Identifier()
	}

	return localctx
}

// ICell_identifierContext is an interface to support dynamic dispatch.
type ICell_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCell_identifierContext differentiates from other interfaces.
	IsCell_identifierContext()
}

type Cell_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCell_identifierContext() *Cell_identifierContext {
	var p = new(Cell_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_cell_identifier
	return p
}

func (*Cell_identifierContext) IsCell_identifierContext() {}

func NewCell_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cell_identifierContext {
	var p = new(Cell_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_cell_identifier

	return p
}

func (s *Cell_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Cell_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Cell_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cell_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cell_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCell_identifier(s)
	}
}

func (s *Cell_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCell_identifier(s)
	}
}

func (p *VerilogParser) Cell_identifier() (localctx ICell_identifierContext) {
	this := p
	_ = this

	localctx = NewCell_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, VerilogParserRULE_cell_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4097)
		p.Identifier()
	}

	return localctx
}

// IConfig_identifierContext is an interface to support dynamic dispatch.
type IConfig_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfig_identifierContext differentiates from other interfaces.
	IsConfig_identifierContext()
}

type Config_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfig_identifierContext() *Config_identifierContext {
	var p = new(Config_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_config_identifier
	return p
}

func (*Config_identifierContext) IsConfig_identifierContext() {}

func NewConfig_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Config_identifierContext {
	var p = new(Config_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_config_identifier

	return p
}

func (s *Config_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Config_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Config_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Config_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Config_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConfig_identifier(s)
	}
}

func (s *Config_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConfig_identifier(s)
	}
}

func (p *VerilogParser) Config_identifier() (localctx IConfig_identifierContext) {
	this := p
	_ = this

	localctx = NewConfig_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, VerilogParserRULE_config_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4099)
		p.Identifier()
	}

	return localctx
}

// IEvent_identifierContext is an interface to support dynamic dispatch.
type IEvent_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_identifierContext differentiates from other interfaces.
	IsEvent_identifierContext()
}

type Event_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_identifierContext() *Event_identifierContext {
	var p = new(Event_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_identifier
	return p
}

func (*Event_identifierContext) IsEvent_identifierContext() {}

func NewEvent_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_identifierContext {
	var p = new(Event_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_identifier

	return p
}

func (s *Event_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Event_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEvent_identifier(s)
	}
}

func (s *Event_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEvent_identifier(s)
	}
}

func (p *VerilogParser) Event_identifier() (localctx IEvent_identifierContext) {
	this := p
	_ = this

	localctx = NewEvent_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, VerilogParserRULE_event_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4101)
		p.Identifier()
	}

	return localctx
}

// IFunction_identifierContext is an interface to support dynamic dispatch.
type IFunction_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_identifierContext differentiates from other interfaces.
	IsFunction_identifierContext()
}

type Function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_identifierContext() *Function_identifierContext {
	var p = new(Function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_identifier
	return p
}

func (*Function_identifierContext) IsFunction_identifierContext() {}

func NewFunction_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_identifierContext {
	var p = new(Function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_identifier

	return p
}

func (s *Function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_identifier(s)
	}
}

func (s *Function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_identifier(s)
	}
}

func (p *VerilogParser) Function_identifier() (localctx IFunction_identifierContext) {
	this := p
	_ = this

	localctx = NewFunction_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, VerilogParserRULE_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4103)
		p.Identifier()
	}

	return localctx
}

// IGate_instance_identifierContext is an interface to support dynamic dispatch.
type IGate_instance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGate_instance_identifierContext differentiates from other interfaces.
	IsGate_instance_identifierContext()
}

type Gate_instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGate_instance_identifierContext() *Gate_instance_identifierContext {
	var p = new(Gate_instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_gate_instance_identifier
	return p
}

func (*Gate_instance_identifierContext) IsGate_instance_identifierContext() {}

func NewGate_instance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Gate_instance_identifierContext {
	var p = new(Gate_instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_gate_instance_identifier

	return p
}

func (s *Gate_instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Gate_instance_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Gate_instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Gate_instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Gate_instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGate_instance_identifier(s)
	}
}

func (s *Gate_instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGate_instance_identifier(s)
	}
}

func (p *VerilogParser) Gate_instance_identifier() (localctx IGate_instance_identifierContext) {
	this := p
	_ = this

	localctx = NewGate_instance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, VerilogParserRULE_gate_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4105)
		p.Identifier()
	}

	return localctx
}

// IGenerate_block_identifierContext is an interface to support dynamic dispatch.
type IGenerate_block_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_block_identifierContext differentiates from other interfaces.
	IsGenerate_block_identifierContext()
}

type Generate_block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_block_identifierContext() *Generate_block_identifierContext {
	var p = new(Generate_block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_block_identifier
	return p
}

func (*Generate_block_identifierContext) IsGenerate_block_identifierContext() {}

func NewGenerate_block_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_block_identifierContext {
	var p = new(Generate_block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_block_identifier

	return p
}

func (s *Generate_block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_block_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Generate_block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenerate_block_identifier(s)
	}
}

func (s *Generate_block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenerate_block_identifier(s)
	}
}

func (p *VerilogParser) Generate_block_identifier() (localctx IGenerate_block_identifierContext) {
	this := p
	_ = this

	localctx = NewGenerate_block_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, VerilogParserRULE_generate_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4107)
		p.Identifier()
	}

	return localctx
}

// IGenvar_identifierContext is an interface to support dynamic dispatch.
type IGenvar_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_identifierContext differentiates from other interfaces.
	IsGenvar_identifierContext()
}

type Genvar_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_identifierContext() *Genvar_identifierContext {
	var p = new(Genvar_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_identifier
	return p
}

func (*Genvar_identifierContext) IsGenvar_identifierContext() {}

func NewGenvar_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_identifierContext {
	var p = new(Genvar_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_identifier

	return p
}

func (s *Genvar_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Genvar_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenvar_identifier(s)
	}
}

func (s *Genvar_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenvar_identifier(s)
	}
}

func (p *VerilogParser) Genvar_identifier() (localctx IGenvar_identifierContext) {
	this := p
	_ = this

	localctx = NewGenvar_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, VerilogParserRULE_genvar_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4109)
		p.Identifier()
	}

	return localctx
}

// IHierarchical_block_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_block_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_block_identifierContext differentiates from other interfaces.
	IsHierarchical_block_identifierContext()
}

type Hierarchical_block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_block_identifierContext() *Hierarchical_block_identifierContext {
	var p = new(Hierarchical_block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_block_identifier
	return p
}

func (*Hierarchical_block_identifierContext) IsHierarchical_block_identifierContext() {}

func NewHierarchical_block_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_block_identifierContext {
	var p = new(Hierarchical_block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_block_identifier

	return p
}

func (s *Hierarchical_block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_block_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_block_identifier(s)
	}
}

func (s *Hierarchical_block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_block_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_block_identifier() (localctx IHierarchical_block_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_block_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, VerilogParserRULE_hierarchical_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4111)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_event_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_event_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_event_identifierContext differentiates from other interfaces.
	IsHierarchical_event_identifierContext()
}

type Hierarchical_event_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_event_identifierContext() *Hierarchical_event_identifierContext {
	var p = new(Hierarchical_event_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_event_identifier
	return p
}

func (*Hierarchical_event_identifierContext) IsHierarchical_event_identifierContext() {}

func NewHierarchical_event_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_event_identifierContext {
	var p = new(Hierarchical_event_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_event_identifier

	return p
}

func (s *Hierarchical_event_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_event_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_event_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_event_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_event_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_event_identifier(s)
	}
}

func (s *Hierarchical_event_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_event_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_event_identifier() (localctx IHierarchical_event_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_event_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, VerilogParserRULE_hierarchical_event_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4113)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_function_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_function_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_function_identifierContext differentiates from other interfaces.
	IsHierarchical_function_identifierContext()
}

type Hierarchical_function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_function_identifierContext() *Hierarchical_function_identifierContext {
	var p = new(Hierarchical_function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_function_identifier
	return p
}

func (*Hierarchical_function_identifierContext) IsHierarchical_function_identifierContext() {}

func NewHierarchical_function_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_function_identifierContext {
	var p = new(Hierarchical_function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_function_identifier

	return p
}

func (s *Hierarchical_function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_function_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_function_identifier(s)
	}
}

func (s *Hierarchical_function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_function_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_function_identifier() (localctx IHierarchical_function_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_function_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, VerilogParserRULE_hierarchical_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4115)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_identifierContext differentiates from other interfaces.
	IsHierarchical_identifierContext()
}

type Hierarchical_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_identifierContext() *Hierarchical_identifierContext {
	var p = new(Hierarchical_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_identifier
	return p
}

func (*Hierarchical_identifierContext) IsHierarchical_identifierContext() {}

func NewHierarchical_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_identifierContext {
	var p = new(Hierarchical_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_identifier

	return p
}

func (s *Hierarchical_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_identifierContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Hierarchical_identifierContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Hierarchical_identifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserDOT)
}

func (s *Hierarchical_identifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserDOT, i)
}

func (s *Hierarchical_identifierContext) AllLEFT_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLEFT_BRACKET)
}

func (s *Hierarchical_identifierContext) LEFT_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLEFT_BRACKET, i)
}

func (s *Hierarchical_identifierContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Hierarchical_identifierContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Hierarchical_identifierContext) AllRIGHT_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRIGHT_BRACKET)
}

func (s *Hierarchical_identifierContext) RIGHT_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRIGHT_BRACKET, i)
}

func (s *Hierarchical_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_identifier(s)
	}
}

func (s *Hierarchical_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_identifier() (localctx IHierarchical_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, VerilogParserRULE_hierarchical_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4128)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 415, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4117)
				p.Identifier()
			}
			p.SetState(4122)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == VerilogParserLEFT_BRACKET {
				{
					p.SetState(4118)
					p.Match(VerilogParserLEFT_BRACKET)
				}
				{
					p.SetState(4119)
					p.constant_expression(0)
				}
				{
					p.SetState(4120)
					p.Match(VerilogParserRIGHT_BRACKET)
				}

			}
			{
				p.SetState(4124)
				p.Match(VerilogParserDOT)
			}

		}
		p.SetState(4130)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 415, p.GetParserRuleContext())
	}
	{
		p.SetState(4131)
		p.Identifier()
	}

	return localctx
}

// IHierarchical_net_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_net_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_net_identifierContext differentiates from other interfaces.
	IsHierarchical_net_identifierContext()
}

type Hierarchical_net_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_net_identifierContext() *Hierarchical_net_identifierContext {
	var p = new(Hierarchical_net_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_net_identifier
	return p
}

func (*Hierarchical_net_identifierContext) IsHierarchical_net_identifierContext() {}

func NewHierarchical_net_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_net_identifierContext {
	var p = new(Hierarchical_net_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_net_identifier

	return p
}

func (s *Hierarchical_net_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_net_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_net_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_net_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_net_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_net_identifier(s)
	}
}

func (s *Hierarchical_net_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_net_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_net_identifier() (localctx IHierarchical_net_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_net_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, VerilogParserRULE_hierarchical_net_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4133)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_parameter_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_parameter_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_parameter_identifierContext differentiates from other interfaces.
	IsHierarchical_parameter_identifierContext()
}

type Hierarchical_parameter_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_parameter_identifierContext() *Hierarchical_parameter_identifierContext {
	var p = new(Hierarchical_parameter_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_parameter_identifier
	return p
}

func (*Hierarchical_parameter_identifierContext) IsHierarchical_parameter_identifierContext() {}

func NewHierarchical_parameter_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_parameter_identifierContext {
	var p = new(Hierarchical_parameter_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_parameter_identifier

	return p
}

func (s *Hierarchical_parameter_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_parameter_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_parameter_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_parameter_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_parameter_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_parameter_identifier(s)
	}
}

func (s *Hierarchical_parameter_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_parameter_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_parameter_identifier() (localctx IHierarchical_parameter_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_parameter_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, VerilogParserRULE_hierarchical_parameter_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4135)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_variable_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_variable_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_variable_identifierContext differentiates from other interfaces.
	IsHierarchical_variable_identifierContext()
}

type Hierarchical_variable_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_variable_identifierContext() *Hierarchical_variable_identifierContext {
	var p = new(Hierarchical_variable_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_variable_identifier
	return p
}

func (*Hierarchical_variable_identifierContext) IsHierarchical_variable_identifierContext() {}

func NewHierarchical_variable_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_variable_identifierContext {
	var p = new(Hierarchical_variable_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_variable_identifier

	return p
}

func (s *Hierarchical_variable_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_variable_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_variable_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_variable_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_variable_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_variable_identifier(s)
	}
}

func (s *Hierarchical_variable_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_variable_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_variable_identifier() (localctx IHierarchical_variable_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_variable_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, VerilogParserRULE_hierarchical_variable_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4137)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_task_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_task_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_task_identifierContext differentiates from other interfaces.
	IsHierarchical_task_identifierContext()
}

type Hierarchical_task_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_task_identifierContext() *Hierarchical_task_identifierContext {
	var p = new(Hierarchical_task_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_task_identifier
	return p
}

func (*Hierarchical_task_identifierContext) IsHierarchical_task_identifierContext() {}

func NewHierarchical_task_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_task_identifierContext {
	var p = new(Hierarchical_task_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_task_identifier

	return p
}

func (s *Hierarchical_task_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_task_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_task_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_task_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_task_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_task_identifier(s)
	}
}

func (s *Hierarchical_task_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_task_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_task_identifier() (localctx IHierarchical_task_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_task_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, VerilogParserRULE_hierarchical_task_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4139)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) SIMPLE_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(VerilogParserSIMPLE_IDENTIFIER, 0)
}

func (s *IdentifierContext) ESCAPED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(VerilogParserESCAPED_IDENTIFIER, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *VerilogParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, VerilogParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4141)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserESCAPED_IDENTIFIER || _la == VerilogParserSIMPLE_IDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IInout_port_identifierContext is an interface to support dynamic dispatch.
type IInout_port_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_port_identifierContext differentiates from other interfaces.
	IsInout_port_identifierContext()
}

type Inout_port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_port_identifierContext() *Inout_port_identifierContext {
	var p = new(Inout_port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inout_port_identifier
	return p
}

func (*Inout_port_identifierContext) IsInout_port_identifierContext() {}

func NewInout_port_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_port_identifierContext {
	var p = new(Inout_port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inout_port_identifier

	return p
}

func (s *Inout_port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Inout_port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInout_port_identifier(s)
	}
}

func (s *Inout_port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInout_port_identifier(s)
	}
}

func (p *VerilogParser) Inout_port_identifier() (localctx IInout_port_identifierContext) {
	this := p
	_ = this

	localctx = NewInout_port_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, VerilogParserRULE_inout_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4143)
		p.Identifier()
	}

	return localctx
}

// IInput_port_identifierContext is an interface to support dynamic dispatch.
type IInput_port_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_port_identifierContext differentiates from other interfaces.
	IsInput_port_identifierContext()
}

type Input_port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_port_identifierContext() *Input_port_identifierContext {
	var p = new(Input_port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_input_port_identifier
	return p
}

func (*Input_port_identifierContext) IsInput_port_identifierContext() {}

func NewInput_port_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_port_identifierContext {
	var p = new(Input_port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_input_port_identifier

	return p
}

func (s *Input_port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Input_port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInput_port_identifier(s)
	}
}

func (s *Input_port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInput_port_identifier(s)
	}
}

func (p *VerilogParser) Input_port_identifier() (localctx IInput_port_identifierContext) {
	this := p
	_ = this

	localctx = NewInput_port_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, VerilogParserRULE_input_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4145)
		p.Identifier()
	}

	return localctx
}

// IInstance_identifierContext is an interface to support dynamic dispatch.
type IInstance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstance_identifierContext differentiates from other interfaces.
	IsInstance_identifierContext()
}

type Instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstance_identifierContext() *Instance_identifierContext {
	var p = new(Instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_instance_identifier
	return p
}

func (*Instance_identifierContext) IsInstance_identifierContext() {}

func NewInstance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instance_identifierContext {
	var p = new(Instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_instance_identifier

	return p
}

func (s *Instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Instance_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInstance_identifier(s)
	}
}

func (s *Instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInstance_identifier(s)
	}
}

func (p *VerilogParser) Instance_identifier() (localctx IInstance_identifierContext) {
	this := p
	_ = this

	localctx = NewInstance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, VerilogParserRULE_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4147)
		p.Identifier()
	}

	return localctx
}

// ILibrary_identifierContext is an interface to support dynamic dispatch.
type ILibrary_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_identifierContext differentiates from other interfaces.
	IsLibrary_identifierContext()
}

type Library_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_identifierContext() *Library_identifierContext {
	var p = new(Library_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_library_identifier
	return p
}

func (*Library_identifierContext) IsLibrary_identifierContext() {}

func NewLibrary_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_identifierContext {
	var p = new(Library_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_library_identifier

	return p
}

func (s *Library_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Library_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Library_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLibrary_identifier(s)
	}
}

func (s *Library_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLibrary_identifier(s)
	}
}

func (p *VerilogParser) Library_identifier() (localctx ILibrary_identifierContext) {
	this := p
	_ = this

	localctx = NewLibrary_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, VerilogParserRULE_library_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4149)
		p.Identifier()
	}

	return localctx
}

// IModule_identifierContext is an interface to support dynamic dispatch.
type IModule_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_identifierContext differentiates from other interfaces.
	IsModule_identifierContext()
}

type Module_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_identifierContext() *Module_identifierContext {
	var p = new(Module_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_identifier
	return p
}

func (*Module_identifierContext) IsModule_identifierContext() {}

func NewModule_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_identifierContext {
	var p = new(Module_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_identifier

	return p
}

func (s *Module_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Module_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_identifier(s)
	}
}

func (s *Module_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_identifier(s)
	}
}

func (p *VerilogParser) Module_identifier() (localctx IModule_identifierContext) {
	this := p
	_ = this

	localctx = NewModule_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, VerilogParserRULE_module_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4151)
		p.Identifier()
	}

	return localctx
}

// IModule_instance_identifierContext is an interface to support dynamic dispatch.
type IModule_instance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_instance_identifierContext differentiates from other interfaces.
	IsModule_instance_identifierContext()
}

type Module_instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_instance_identifierContext() *Module_instance_identifierContext {
	var p = new(Module_instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_instance_identifier
	return p
}

func (*Module_instance_identifierContext) IsModule_instance_identifierContext() {}

func NewModule_instance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_instance_identifierContext {
	var p = new(Module_instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_instance_identifier

	return p
}

func (s *Module_instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_instance_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Module_instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_instance_identifier(s)
	}
}

func (s *Module_instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_instance_identifier(s)
	}
}

func (p *VerilogParser) Module_instance_identifier() (localctx IModule_instance_identifierContext) {
	this := p
	_ = this

	localctx = NewModule_instance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, VerilogParserRULE_module_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4153)
		p.Identifier()
	}

	return localctx
}

// INet_identifierContext is an interface to support dynamic dispatch.
type INet_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_identifierContext differentiates from other interfaces.
	IsNet_identifierContext()
}

type Net_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_identifierContext() *Net_identifierContext {
	var p = new(Net_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_identifier
	return p
}

func (*Net_identifierContext) IsNet_identifierContext() {}

func NewNet_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_identifierContext {
	var p = new(Net_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_identifier

	return p
}

func (s *Net_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Net_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNet_identifier(s)
	}
}

func (s *Net_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNet_identifier(s)
	}
}

func (p *VerilogParser) Net_identifier() (localctx INet_identifierContext) {
	this := p
	_ = this

	localctx = NewNet_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, VerilogParserRULE_net_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4155)
		p.Identifier()
	}

	return localctx
}

// IOutput_port_identifierContext is an interface to support dynamic dispatch.
type IOutput_port_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_port_identifierContext differentiates from other interfaces.
	IsOutput_port_identifierContext()
}

type Output_port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_port_identifierContext() *Output_port_identifierContext {
	var p = new(Output_port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_port_identifier
	return p
}

func (*Output_port_identifierContext) IsOutput_port_identifierContext() {}

func NewOutput_port_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_port_identifierContext {
	var p = new(Output_port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_port_identifier

	return p
}

func (s *Output_port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Output_port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterOutput_port_identifier(s)
	}
}

func (s *Output_port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitOutput_port_identifier(s)
	}
}

func (p *VerilogParser) Output_port_identifier() (localctx IOutput_port_identifierContext) {
	this := p
	_ = this

	localctx = NewOutput_port_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, VerilogParserRULE_output_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4157)
		p.Identifier()
	}

	return localctx
}

// IParameter_identifierContext is an interface to support dynamic dispatch.
type IParameter_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_identifierContext differentiates from other interfaces.
	IsParameter_identifierContext()
}

type Parameter_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_identifierContext() *Parameter_identifierContext {
	var p = new(Parameter_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_identifier
	return p
}

func (*Parameter_identifierContext) IsParameter_identifierContext() {}

func NewParameter_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_identifierContext {
	var p = new(Parameter_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_identifier

	return p
}

func (s *Parameter_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Parameter_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParameter_identifier(s)
	}
}

func (s *Parameter_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParameter_identifier(s)
	}
}

func (p *VerilogParser) Parameter_identifier() (localctx IParameter_identifierContext) {
	this := p
	_ = this

	localctx = NewParameter_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, VerilogParserRULE_parameter_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4159)
		p.Identifier()
	}

	return localctx
}

// IPort_identifierContext is an interface to support dynamic dispatch.
type IPort_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_identifierContext differentiates from other interfaces.
	IsPort_identifierContext()
}

type Port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_identifierContext() *Port_identifierContext {
	var p = new(Port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port_identifier
	return p
}

func (*Port_identifierContext) IsPort_identifierContext() {}

func NewPort_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_identifierContext {
	var p = new(Port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port_identifier

	return p
}

func (s *Port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPort_identifier(s)
	}
}

func (s *Port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPort_identifier(s)
	}
}

func (p *VerilogParser) Port_identifier() (localctx IPort_identifierContext) {
	this := p
	_ = this

	localctx = NewPort_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, VerilogParserRULE_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4161)
		p.Identifier()
	}

	return localctx
}

// IReal_identifierContext is an interface to support dynamic dispatch.
type IReal_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReal_identifierContext differentiates from other interfaces.
	IsReal_identifierContext()
}

type Real_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_identifierContext() *Real_identifierContext {
	var p = new(Real_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_real_identifier
	return p
}

func (*Real_identifierContext) IsReal_identifierContext() {}

func NewReal_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_identifierContext {
	var p = new(Real_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_real_identifier

	return p
}

func (s *Real_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Real_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterReal_identifier(s)
	}
}

func (s *Real_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitReal_identifier(s)
	}
}

func (p *VerilogParser) Real_identifier() (localctx IReal_identifierContext) {
	this := p
	_ = this

	localctx = NewReal_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, VerilogParserRULE_real_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4163)
		p.Identifier()
	}

	return localctx
}

// ISpecparam_identifierContext is an interface to support dynamic dispatch.
type ISpecparam_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecparam_identifierContext differentiates from other interfaces.
	IsSpecparam_identifierContext()
}

type Specparam_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecparam_identifierContext() *Specparam_identifierContext {
	var p = new(Specparam_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specparam_identifier
	return p
}

func (*Specparam_identifierContext) IsSpecparam_identifierContext() {}

func NewSpecparam_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specparam_identifierContext {
	var p = new(Specparam_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specparam_identifier

	return p
}

func (s *Specparam_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Specparam_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Specparam_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specparam_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specparam_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecparam_identifier(s)
	}
}

func (s *Specparam_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecparam_identifier(s)
	}
}

func (p *VerilogParser) Specparam_identifier() (localctx ISpecparam_identifierContext) {
	this := p
	_ = this

	localctx = NewSpecparam_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, VerilogParserRULE_specparam_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4165)
		p.Identifier()
	}

	return localctx
}

// ISystem_function_identifierContext is an interface to support dynamic dispatch.
type ISystem_function_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_function_identifierContext differentiates from other interfaces.
	IsSystem_function_identifierContext()
}

type System_function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_function_identifierContext() *System_function_identifierContext {
	var p = new(System_function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_system_function_identifier
	return p
}

func (*System_function_identifierContext) IsSystem_function_identifierContext() {}

func NewSystem_function_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_function_identifierContext {
	var p = new(System_function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_system_function_identifier

	return p
}

func (s *System_function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *System_function_identifierContext) SYSTEM_TF_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(VerilogParserSYSTEM_TF_IDENTIFIER, 0)
}

func (s *System_function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSystem_function_identifier(s)
	}
}

func (s *System_function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSystem_function_identifier(s)
	}
}

func (p *VerilogParser) System_function_identifier() (localctx ISystem_function_identifierContext) {
	this := p
	_ = this

	localctx = NewSystem_function_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, VerilogParserRULE_system_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4167)
		p.Match(VerilogParserSYSTEM_TF_IDENTIFIER)
	}

	return localctx
}

// ISystem_task_identifierContext is an interface to support dynamic dispatch.
type ISystem_task_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_task_identifierContext differentiates from other interfaces.
	IsSystem_task_identifierContext()
}

type System_task_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_task_identifierContext() *System_task_identifierContext {
	var p = new(System_task_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_system_task_identifier
	return p
}

func (*System_task_identifierContext) IsSystem_task_identifierContext() {}

func NewSystem_task_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_task_identifierContext {
	var p = new(System_task_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_system_task_identifier

	return p
}

func (s *System_task_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *System_task_identifierContext) SYSTEM_TF_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(VerilogParserSYSTEM_TF_IDENTIFIER, 0)
}

func (s *System_task_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_task_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_task_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSystem_task_identifier(s)
	}
}

func (s *System_task_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSystem_task_identifier(s)
	}
}

func (p *VerilogParser) System_task_identifier() (localctx ISystem_task_identifierContext) {
	this := p
	_ = this

	localctx = NewSystem_task_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, VerilogParserRULE_system_task_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4169)
		p.Match(VerilogParserSYSTEM_TF_IDENTIFIER)
	}

	return localctx
}

// ITask_identifierContext is an interface to support dynamic dispatch.
type ITask_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_identifierContext differentiates from other interfaces.
	IsTask_identifierContext()
}

type Task_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_identifierContext() *Task_identifierContext {
	var p = new(Task_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_identifier
	return p
}

func (*Task_identifierContext) IsTask_identifierContext() {}

func NewTask_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_identifierContext {
	var p = new(Task_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_identifier

	return p
}

func (s *Task_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Task_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTask_identifier(s)
	}
}

func (s *Task_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTask_identifier(s)
	}
}

func (p *VerilogParser) Task_identifier() (localctx ITask_identifierContext) {
	this := p
	_ = this

	localctx = NewTask_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, VerilogParserRULE_task_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4171)
		p.Identifier()
	}

	return localctx
}

// ITerminal_identifierContext is an interface to support dynamic dispatch.
type ITerminal_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTerminal_identifierContext differentiates from other interfaces.
	IsTerminal_identifierContext()
}

type Terminal_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminal_identifierContext() *Terminal_identifierContext {
	var p = new(Terminal_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_terminal_identifier
	return p
}

func (*Terminal_identifierContext) IsTerminal_identifierContext() {}

func NewTerminal_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Terminal_identifierContext {
	var p = new(Terminal_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_terminal_identifier

	return p
}

func (s *Terminal_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Terminal_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Terminal_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Terminal_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Terminal_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTerminal_identifier(s)
	}
}

func (s *Terminal_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTerminal_identifier(s)
	}
}

func (p *VerilogParser) Terminal_identifier() (localctx ITerminal_identifierContext) {
	this := p
	_ = this

	localctx = NewTerminal_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, VerilogParserRULE_terminal_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4173)
		p.Identifier()
	}

	return localctx
}

// ITopmodule_identifierContext is an interface to support dynamic dispatch.
type ITopmodule_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopmodule_identifierContext differentiates from other interfaces.
	IsTopmodule_identifierContext()
}

type Topmodule_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopmodule_identifierContext() *Topmodule_identifierContext {
	var p = new(Topmodule_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_topmodule_identifier
	return p
}

func (*Topmodule_identifierContext) IsTopmodule_identifierContext() {}

func NewTopmodule_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topmodule_identifierContext {
	var p = new(Topmodule_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_topmodule_identifier

	return p
}

func (s *Topmodule_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Topmodule_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Topmodule_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topmodule_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topmodule_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTopmodule_identifier(s)
	}
}

func (s *Topmodule_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTopmodule_identifier(s)
	}
}

func (p *VerilogParser) Topmodule_identifier() (localctx ITopmodule_identifierContext) {
	this := p
	_ = this

	localctx = NewTopmodule_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, VerilogParserRULE_topmodule_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4175)
		p.Identifier()
	}

	return localctx
}

// IUdp_identifierContext is an interface to support dynamic dispatch.
type IUdp_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUdp_identifierContext differentiates from other interfaces.
	IsUdp_identifierContext()
}

type Udp_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUdp_identifierContext() *Udp_identifierContext {
	var p = new(Udp_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_udp_identifier
	return p
}

func (*Udp_identifierContext) IsUdp_identifierContext() {}

func NewUdp_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Udp_identifierContext {
	var p = new(Udp_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_udp_identifier

	return p
}

func (s *Udp_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Udp_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Udp_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Udp_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Udp_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterUdp_identifier(s)
	}
}

func (s *Udp_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitUdp_identifier(s)
	}
}

func (p *VerilogParser) Udp_identifier() (localctx IUdp_identifierContext) {
	this := p
	_ = this

	localctx = NewUdp_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, VerilogParserRULE_udp_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4177)
		p.Identifier()
	}

	return localctx
}

// IUdp_instance_identifierContext is an interface to support dynamic dispatch.
type IUdp_instance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUdp_instance_identifierContext differentiates from other interfaces.
	IsUdp_instance_identifierContext()
}

type Udp_instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUdp_instance_identifierContext() *Udp_instance_identifierContext {
	var p = new(Udp_instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_udp_instance_identifier
	return p
}

func (*Udp_instance_identifierContext) IsUdp_instance_identifierContext() {}

func NewUdp_instance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Udp_instance_identifierContext {
	var p = new(Udp_instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_udp_instance_identifier

	return p
}

func (s *Udp_instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Udp_instance_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Udp_instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Udp_instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Udp_instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterUdp_instance_identifier(s)
	}
}

func (s *Udp_instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitUdp_instance_identifier(s)
	}
}

func (p *VerilogParser) Udp_instance_identifier() (localctx IUdp_instance_identifierContext) {
	this := p
	_ = this

	localctx = NewUdp_instance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, VerilogParserRULE_udp_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4179)
		p.Identifier()
	}

	return localctx
}

// IVariable_identifierContext is an interface to support dynamic dispatch.
type IVariable_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_identifierContext differentiates from other interfaces.
	IsVariable_identifierContext()
}

type Variable_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_identifierContext() *Variable_identifierContext {
	var p = new(Variable_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_identifier
	return p
}

func (*Variable_identifierContext) IsVariable_identifierContext() {}

func NewVariable_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_identifierContext {
	var p = new(Variable_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_identifier

	return p
}

func (s *Variable_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Variable_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterVariable_identifier(s)
	}
}

func (s *Variable_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitVariable_identifier(s)
	}
}

func (p *VerilogParser) Variable_identifier() (localctx IVariable_identifierContext) {
	this := p
	_ = this

	localctx = NewVariable_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, VerilogParserRULE_variable_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4181)
		p.Identifier()
	}

	return localctx
}

func (p *VerilogParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 194:
		var t *Genvar_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Genvar_expressionContext)
		}
		return p.Genvar_expression_Sempred(t, predIndex)

	case 221:
		var t *Event_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Event_expressionContext)
		}
		return p.Event_expression_Sempred(t, predIndex)

	case 284:
		var t *Constant_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Constant_expressionContext)
		}
		return p.Constant_expression_Sempred(t, predIndex)

	case 288:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 291:
		var t *Module_path_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Module_path_expressionContext)
		}
		return p.Module_path_expression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *VerilogParser) Genvar_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *VerilogParser) Event_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *VerilogParser) Constant_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *VerilogParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *VerilogParser) Module_path_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
