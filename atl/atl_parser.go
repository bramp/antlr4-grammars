// Code generated from ATL.g4 by ANTLR 4.9.3. DO NOT EDIT.

package atl // ATL
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 89, 1023,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 3, 2, 3, 2, 3, 2, 5, 2, 192, 10,
	2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 203, 10,
	3, 12, 3, 14, 3, 206, 11, 3, 3, 3, 7, 3, 209, 10, 3, 12, 3, 14, 3, 212,
	11, 3, 3, 4, 3, 4, 3, 4, 7, 4, 217, 10, 4, 12, 4, 14, 4, 220, 11, 4, 3,
	5, 3, 5, 3, 5, 7, 5, 225, 10, 5, 12, 5, 14, 5, 228, 11, 5, 3, 6, 3, 6,
	3, 7, 3, 7, 3, 7, 3, 7, 7, 7, 236, 10, 7, 12, 7, 14, 7, 239, 11, 7, 3,
	7, 7, 7, 242, 10, 7, 12, 7, 14, 7, 245, 11, 7, 3, 8, 3, 8, 3, 8, 3, 8,
	3, 8, 3, 8, 7, 8, 253, 10, 8, 12, 8, 14, 8, 256, 11, 8, 3, 8, 7, 8, 259,
	10, 8, 12, 8, 14, 8, 262, 11, 8, 3, 9, 3, 9, 3, 9, 3, 9, 3, 10, 3, 10,
	5, 10, 270, 10, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 12, 5, 12, 277, 10,
	12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 13, 3, 13, 3, 13, 3, 14, 3, 14, 5, 14,
	288, 10, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 7, 15, 295, 10, 15, 12,
	15, 14, 15, 298, 11, 15, 5, 15, 300, 10, 15, 3, 15, 3, 15, 3, 15, 3, 15,
	3, 15, 3, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 17, 3, 17, 3, 17, 3, 17, 3,
	17, 3, 17, 3, 18, 3, 18, 5, 18, 320, 10, 18, 3, 19, 3, 19, 5, 19, 324,
	10, 19, 3, 20, 5, 20, 327, 10, 20, 3, 20, 3, 20, 5, 20, 331, 10, 20, 3,
	20, 5, 20, 334, 10, 20, 3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 340, 10, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 7, 20, 347, 10, 20, 12, 20, 14, 20,
	350, 11, 20, 3, 20, 5, 20, 353, 10, 20, 3, 20, 5, 20, 356, 10, 20, 3, 20,
	5, 20, 359, 10, 20, 3, 20, 3, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3,
	21, 3, 21, 3, 22, 5, 22, 371, 10, 22, 3, 22, 5, 22, 374, 10, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 7, 22, 382, 10, 22, 12, 22, 14, 22,
	385, 11, 22, 5, 22, 387, 10, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 7,
	22, 394, 10, 22, 12, 22, 14, 22, 397, 11, 22, 3, 22, 5, 22, 400, 10, 22,
	3, 22, 5, 22, 403, 10, 22, 3, 22, 5, 22, 406, 10, 22, 3, 22, 3, 22, 3,
	23, 3, 23, 3, 23, 3, 23, 7, 23, 414, 10, 23, 12, 23, 14, 23, 417, 11, 23,
	3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 423, 10, 23, 3, 24, 3, 24, 3, 25, 3,
	25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 7, 25, 434, 10, 25, 12, 25, 14,
	25, 437, 11, 25, 5, 25, 439, 10, 25, 3, 26, 3, 26, 3, 26, 3, 26, 7, 26,
	445, 10, 26, 12, 26, 14, 26, 448, 11, 26, 3, 27, 3, 27, 5, 27, 452, 10,
	27, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 459, 10, 28, 3, 28, 3, 28,
	5, 28, 463, 10, 28, 3, 28, 3, 28, 3, 28, 3, 28, 7, 28, 469, 10, 28, 12,
	28, 14, 28, 472, 11, 28, 5, 28, 474, 10, 28, 3, 28, 5, 28, 477, 10, 28,
	3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 5, 29, 491, 10, 29, 3, 29, 3, 29, 3, 29, 3, 29, 7, 29, 497,
	10, 29, 12, 29, 14, 29, 500, 11, 29, 5, 29, 502, 10, 29, 3, 29, 5, 29,
	505, 10, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 31, 3, 31, 3, 31, 7, 31, 514,
	10, 31, 12, 31, 14, 31, 517, 11, 31, 3, 31, 3, 31, 3, 32, 3, 32, 3, 32,
	3, 32, 5, 32, 525, 10, 32, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 34, 3,
	34, 3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 7, 35, 542,
	10, 35, 12, 35, 14, 35, 545, 11, 35, 3, 35, 5, 35, 548, 10, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 7, 35, 554, 10, 35, 12, 35, 14, 35, 557, 11, 35, 3,
	35, 5, 35, 560, 10, 35, 5, 35, 562, 10, 35, 3, 36, 3, 36, 3, 36, 3, 36,
	3, 36, 3, 36, 3, 36, 3, 36, 7, 36, 572, 10, 36, 12, 36, 14, 36, 575, 11,
	36, 3, 36, 3, 36, 3, 37, 3, 37, 3, 37, 3, 37, 3, 38, 3, 38, 3, 38, 3, 38,
	3, 39, 3, 39, 5, 39, 589, 10, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 7,
	40, 596, 10, 40, 12, 40, 14, 40, 599, 11, 40, 3, 40, 3, 40, 3, 40, 3, 40,
	3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 7, 41, 610, 10, 41, 12, 41, 14, 41,
	613, 11, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3,
	42, 3, 42, 3, 42, 7, 42, 626, 10, 42, 12, 42, 14, 42, 629, 11, 42, 5, 42,
	631, 10, 42, 3, 42, 3, 42, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 7, 43, 640,
	10, 43, 12, 43, 14, 43, 643, 11, 43, 5, 43, 645, 10, 43, 3, 43, 3, 43,
	3, 44, 3, 44, 3, 45, 3, 45, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 5, 47, 658,
	10, 47, 3, 48, 3, 48, 5, 48, 662, 10, 48, 3, 49, 3, 49, 3, 50, 3, 50, 3,
	51, 3, 51, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53,
	3, 53, 3, 54, 3, 54, 3, 55, 3, 55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3,
	57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 58, 3, 58, 3, 58, 3, 59, 3, 59,
	3, 59, 3, 59, 5, 59, 702, 10, 59, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 7,
	60, 709, 10, 60, 12, 60, 14, 60, 712, 11, 60, 5, 60, 714, 10, 60, 3, 60,
	3, 60, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 7, 61, 723, 10, 61, 12, 61, 14,
	61, 726, 11, 61, 5, 61, 728, 10, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3, 62,
	3, 62, 3, 62, 7, 62, 737, 10, 62, 12, 62, 14, 62, 740, 11, 62, 5, 62, 742,
	10, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 7, 63, 751, 10,
	63, 12, 63, 14, 63, 754, 11, 63, 5, 63, 756, 10, 63, 3, 63, 3, 63, 3, 64,
	3, 64, 3, 64, 3, 64, 3, 64, 7, 64, 765, 10, 64, 12, 64, 14, 64, 768, 11,
	64, 5, 64, 770, 10, 64, 3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65,
	3, 65, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 7, 66, 785, 10, 66, 12, 66, 14,
	66, 788, 11, 66, 5, 66, 790, 10, 66, 3, 66, 3, 66, 3, 67, 3, 67, 3, 67,
	5, 67, 797, 10, 67, 3, 67, 3, 67, 3, 67, 3, 68, 3, 68, 3, 68, 3, 68, 3,
	68, 3, 68, 3, 68, 5, 68, 809, 10, 68, 3, 69, 3, 69, 3, 70, 3, 70, 3, 70,
	3, 70, 3, 70, 7, 70, 818, 10, 70, 12, 70, 14, 70, 821, 11, 70, 5, 70, 823,
	10, 70, 3, 70, 3, 70, 3, 71, 3, 71, 3, 71, 3, 71, 3, 72, 3, 72, 3, 72,
	3, 72, 3, 72, 3, 72, 3, 72, 3, 73, 3, 73, 3, 73, 5, 73, 841, 10, 73, 3,
	74, 3, 74, 5, 74, 845, 10, 74, 3, 75, 3, 75, 3, 76, 3, 76, 3, 77, 3, 77,
	3, 78, 3, 78, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 5, 79, 860, 10, 79, 3,
	80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 82,
	3, 82, 3, 82, 3, 82, 3, 82, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 84, 3,
	84, 3, 84, 3, 84, 5, 84, 886, 10, 84, 3, 84, 3, 84, 3, 84, 3, 84, 5, 84,
	892, 10, 84, 7, 84, 894, 10, 84, 12, 84, 14, 84, 897, 11, 84, 3, 85, 3,
	85, 3, 85, 3, 85, 3, 85, 5, 85, 904, 10, 85, 3, 86, 3, 86, 3, 86, 3, 86,
	3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 7, 86, 915, 10, 86, 12, 86, 14, 86,
	918, 11, 86, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 7, 87, 925, 10, 87, 12,
	87, 14, 87, 928, 11, 87, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88,
	3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 7, 88, 943, 10, 88, 12, 88, 14,
	88, 946, 11, 88, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89,
	3, 89, 7, 89, 957, 10, 89, 12, 89, 14, 89, 960, 11, 89, 3, 90, 5, 90, 963,
	10, 90, 3, 90, 5, 90, 966, 10, 90, 3, 90, 5, 90, 969, 10, 90, 3, 90, 3,
	90, 3, 90, 3, 90, 5, 90, 975, 10, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90,
	7, 90, 982, 10, 90, 12, 90, 14, 90, 985, 11, 90, 3, 90, 5, 90, 988, 10,
	90, 3, 90, 5, 90, 991, 10, 90, 3, 90, 5, 90, 994, 10, 90, 3, 90, 3, 90,
	3, 91, 3, 91, 3, 92, 3, 92, 3, 93, 3, 93, 3, 93, 3, 93, 3, 93, 3, 94, 3,
	94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94,
	3, 94, 3, 94, 5, 94, 1021, 10, 94, 3, 94, 2, 2, 95, 2, 4, 6, 8, 10, 12,
	14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
	50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84,
	86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
	118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146,
	148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176,
	178, 180, 182, 184, 186, 2, 5, 4, 2, 83, 83, 86, 86, 3, 2, 7, 8, 3, 2,
	43, 44, 2, 1069, 2, 191, 3, 2, 2, 2, 4, 193, 3, 2, 2, 2, 6, 213, 3, 2,
	2, 2, 8, 221, 3, 2, 2, 2, 10, 229, 3, 2, 2, 2, 12, 231, 3, 2, 2, 2, 14,
	246, 3, 2, 2, 2, 16, 263, 3, 2, 2, 2, 18, 269, 3, 2, 2, 2, 20, 271, 3,
	2, 2, 2, 22, 276, 3, 2, 2, 2, 24, 282, 3, 2, 2, 2, 26, 287, 3, 2, 2, 2,
	28, 289, 3, 2, 2, 2, 30, 307, 3, 2, 2, 2, 32, 311, 3, 2, 2, 2, 34, 319,
	3, 2, 2, 2, 36, 323, 3, 2, 2, 2, 38, 326, 3, 2, 2, 2, 40, 362, 3, 2, 2,
	2, 42, 370, 3, 2, 2, 2, 44, 409, 3, 2, 2, 2, 46, 424, 3, 2, 2, 2, 48, 426,
	3, 2, 2, 2, 50, 440, 3, 2, 2, 2, 52, 451, 3, 2, 2, 2, 54, 453, 3, 2, 2,
	2, 56, 478, 3, 2, 2, 2, 58, 506, 3, 2, 2, 2, 60, 510, 3, 2, 2, 2, 62, 524,
	3, 2, 2, 2, 64, 526, 3, 2, 2, 2, 66, 531, 3, 2, 2, 2, 68, 534, 3, 2, 2,
	2, 70, 563, 3, 2, 2, 2, 72, 578, 3, 2, 2, 2, 74, 582, 3, 2, 2, 2, 76, 588,
	3, 2, 2, 2, 78, 590, 3, 2, 2, 2, 80, 604, 3, 2, 2, 2, 82, 620, 3, 2, 2,
	2, 84, 634, 3, 2, 2, 2, 86, 648, 3, 2, 2, 2, 88, 650, 3, 2, 2, 2, 90, 652,
	3, 2, 2, 2, 92, 657, 3, 2, 2, 2, 94, 661, 3, 2, 2, 2, 96, 663, 3, 2, 2,
	2, 98, 665, 3, 2, 2, 2, 100, 667, 3, 2, 2, 2, 102, 669, 3, 2, 2, 2, 104,
	671, 3, 2, 2, 2, 106, 679, 3, 2, 2, 2, 108, 681, 3, 2, 2, 2, 110, 683,
	3, 2, 2, 2, 112, 688, 3, 2, 2, 2, 114, 694, 3, 2, 2, 2, 116, 701, 3, 2,
	2, 2, 118, 703, 3, 2, 2, 2, 120, 717, 3, 2, 2, 2, 122, 731, 3, 2, 2, 2,
	124, 745, 3, 2, 2, 2, 126, 759, 3, 2, 2, 2, 128, 773, 3, 2, 2, 2, 130,
	779, 3, 2, 2, 2, 132, 793, 3, 2, 2, 2, 134, 808, 3, 2, 2, 2, 136, 810,
	3, 2, 2, 2, 138, 812, 3, 2, 2, 2, 140, 826, 3, 2, 2, 2, 142, 830, 3, 2,
	2, 2, 144, 840, 3, 2, 2, 2, 146, 844, 3, 2, 2, 2, 148, 846, 3, 2, 2, 2,
	150, 848, 3, 2, 2, 2, 152, 850, 3, 2, 2, 2, 154, 852, 3, 2, 2, 2, 156,
	859, 3, 2, 2, 2, 158, 861, 3, 2, 2, 2, 160, 866, 3, 2, 2, 2, 162, 871,
	3, 2, 2, 2, 164, 876, 3, 2, 2, 2, 166, 881, 3, 2, 2, 2, 168, 903, 3, 2,
	2, 2, 170, 905, 3, 2, 2, 2, 172, 919, 3, 2, 2, 2, 174, 929, 3, 2, 2, 2,
	176, 947, 3, 2, 2, 2, 178, 962, 3, 2, 2, 2, 180, 997, 3, 2, 2, 2, 182,
	999, 3, 2, 2, 2, 184, 1001, 3, 2, 2, 2, 186, 1020, 3, 2, 2, 2, 188, 192,
	5, 4, 3, 2, 189, 192, 5, 12, 7, 2, 190, 192, 5, 14, 8, 2, 191, 188, 3,
	2, 2, 2, 191, 189, 3, 2, 2, 2, 191, 190, 3, 2, 2, 2, 192, 3, 3, 2, 2, 2,
	193, 194, 7, 3, 2, 2, 194, 195, 9, 2, 2, 2, 195, 196, 7, 4, 2, 2, 196,
	197, 7, 5, 2, 2, 197, 198, 5, 6, 4, 2, 198, 199, 5, 10, 6, 2, 199, 200,
	5, 8, 5, 2, 200, 204, 7, 4, 2, 2, 201, 203, 5, 16, 9, 2, 202, 201, 3, 2,
	2, 2, 203, 206, 3, 2, 2, 2, 204, 202, 3, 2, 2, 2, 204, 205, 3, 2, 2, 2,
	205, 210, 3, 2, 2, 2, 206, 204, 3, 2, 2, 2, 207, 209, 5, 18, 10, 2, 208,
	207, 3, 2, 2, 2, 209, 212, 3, 2, 2, 2, 210, 208, 3, 2, 2, 2, 210, 211,
	3, 2, 2, 2, 211, 5, 3, 2, 2, 2, 212, 210, 3, 2, 2, 2, 213, 218, 5, 72,
	37, 2, 214, 215, 7, 6, 2, 2, 215, 217, 5, 72, 37, 2, 216, 214, 3, 2, 2,
	2, 217, 220, 3, 2, 2, 2, 218, 216, 3, 2, 2, 2, 218, 219, 3, 2, 2, 2, 219,
	7, 3, 2, 2, 2, 220, 218, 3, 2, 2, 2, 221, 226, 5, 72, 37, 2, 222, 223,
	7, 6, 2, 2, 223, 225, 5, 72, 37, 2, 224, 222, 3, 2, 2, 2, 225, 228, 3,
	2, 2, 2, 226, 224, 3, 2, 2, 2, 226, 227, 3, 2, 2, 2, 227, 9, 3, 2, 2, 2,
	228, 226, 3, 2, 2, 2, 229, 230, 9, 3, 2, 2, 230, 11, 3, 2, 2, 2, 231, 232,
	7, 9, 2, 2, 232, 233, 9, 2, 2, 2, 233, 237, 7, 4, 2, 2, 234, 236, 5, 16,
	9, 2, 235, 234, 3, 2, 2, 2, 236, 239, 3, 2, 2, 2, 237, 235, 3, 2, 2, 2,
	237, 238, 3, 2, 2, 2, 238, 243, 3, 2, 2, 2, 239, 237, 3, 2, 2, 2, 240,
	242, 5, 20, 11, 2, 241, 240, 3, 2, 2, 2, 242, 245, 3, 2, 2, 2, 243, 241,
	3, 2, 2, 2, 243, 244, 3, 2, 2, 2, 244, 13, 3, 2, 2, 2, 245, 243, 3, 2,
	2, 2, 246, 247, 7, 10, 2, 2, 247, 248, 9, 2, 2, 2, 248, 249, 7, 11, 2,
	2, 249, 250, 5, 76, 39, 2, 250, 254, 7, 4, 2, 2, 251, 253, 5, 16, 9, 2,
	252, 251, 3, 2, 2, 2, 253, 256, 3, 2, 2, 2, 254, 252, 3, 2, 2, 2, 254,
	255, 3, 2, 2, 2, 255, 260, 3, 2, 2, 2, 256, 254, 3, 2, 2, 2, 257, 259,
	5, 20, 11, 2, 258, 257, 3, 2, 2, 2, 259, 262, 3, 2, 2, 2, 260, 258, 3,
	2, 2, 2, 260, 261, 3, 2, 2, 2, 261, 15, 3, 2, 2, 2, 262, 260, 3, 2, 2,
	2, 263, 264, 7, 12, 2, 2, 264, 265, 7, 83, 2, 2, 265, 266, 7, 4, 2, 2,
	266, 17, 3, 2, 2, 2, 267, 270, 5, 20, 11, 2, 268, 270, 5, 34, 18, 2, 269,
	267, 3, 2, 2, 2, 269, 268, 3, 2, 2, 2, 270, 19, 3, 2, 2, 2, 271, 272, 7,
	13, 2, 2, 272, 273, 5, 22, 12, 2, 273, 274, 7, 4, 2, 2, 274, 21, 3, 2,
	2, 2, 275, 277, 5, 24, 13, 2, 276, 275, 3, 2, 2, 2, 276, 277, 3, 2, 2,
	2, 277, 278, 3, 2, 2, 2, 278, 279, 7, 14, 2, 2, 279, 280, 7, 15, 2, 2,
	280, 281, 5, 26, 14, 2, 281, 23, 3, 2, 2, 2, 282, 283, 7, 16, 2, 2, 283,
	284, 5, 134, 68, 2, 284, 25, 3, 2, 2, 2, 285, 288, 5, 28, 15, 2, 286, 288,
	5, 32, 17, 2, 287, 285, 3, 2, 2, 2, 287, 286, 3, 2, 2, 2, 288, 27, 3, 2,
	2, 2, 289, 290, 7, 86, 2, 2, 290, 299, 7, 17, 2, 2, 291, 296, 5, 30, 16,
	2, 292, 293, 7, 6, 2, 2, 293, 295, 5, 30, 16, 2, 294, 292, 3, 2, 2, 2,
	295, 298, 3, 2, 2, 2, 296, 294, 3, 2, 2, 2, 296, 297, 3, 2, 2, 2, 297,
	300, 3, 2, 2, 2, 298, 296, 3, 2, 2, 2, 299, 291, 3, 2, 2, 2, 299, 300,
	3, 2, 2, 2, 300, 301, 3, 2, 2, 2, 301, 302, 7, 18, 2, 2, 302, 303, 7, 15,
	2, 2, 303, 304, 5, 134, 68, 2, 304, 305, 7, 11, 2, 2, 305, 306, 5, 76,
	39, 2, 306, 29, 3, 2, 2, 2, 307, 308, 7, 86, 2, 2, 308, 309, 7, 15, 2,
	2, 309, 310, 5, 134, 68, 2, 310, 31, 3, 2, 2, 2, 311, 312, 7, 86, 2, 2,
	312, 313, 7, 15, 2, 2, 313, 314, 5, 134, 68, 2, 314, 315, 7, 11, 2, 2,
	315, 316, 5, 76, 39, 2, 316, 33, 3, 2, 2, 2, 317, 320, 5, 42, 22, 2, 318,
	320, 5, 36, 19, 2, 319, 317, 3, 2, 2, 2, 319, 318, 3, 2, 2, 2, 320, 35,
	3, 2, 2, 2, 321, 324, 5, 38, 20, 2, 322, 324, 5, 178, 90, 2, 323, 321,
	3, 2, 2, 2, 323, 322, 3, 2, 2, 2, 324, 37, 3, 2, 2, 2, 325, 327, 7, 19,
	2, 2, 326, 325, 3, 2, 2, 2, 326, 327, 3, 2, 2, 2, 327, 328, 3, 2, 2, 2,
	328, 330, 7, 20, 2, 2, 329, 331, 7, 21, 2, 2, 330, 329, 3, 2, 2, 2, 330,
	331, 3, 2, 2, 2, 331, 333, 3, 2, 2, 2, 332, 334, 7, 7, 2, 2, 333, 332,
	3, 2, 2, 2, 333, 334, 3, 2, 2, 2, 334, 335, 3, 2, 2, 2, 335, 336, 7, 22,
	2, 2, 336, 339, 7, 86, 2, 2, 337, 338, 7, 23, 2, 2, 338, 340, 7, 86, 2,
	2, 339, 337, 3, 2, 2, 2, 339, 340, 3, 2, 2, 2, 340, 341, 3, 2, 2, 2, 341,
	342, 7, 24, 2, 2, 342, 352, 5, 44, 23, 2, 343, 344, 7, 25, 2, 2, 344, 348,
	7, 24, 2, 2, 345, 347, 5, 40, 21, 2, 346, 345, 3, 2, 2, 2, 347, 350, 3,
	2, 2, 2, 348, 346, 3, 2, 2, 2, 348, 349, 3, 2, 2, 2, 349, 351, 3, 2, 2,
	2, 350, 348, 3, 2, 2, 2, 351, 353, 7, 26, 2, 2, 352, 343, 3, 2, 2, 2, 352,
	353, 3, 2, 2, 2, 353, 355, 3, 2, 2, 2, 354, 356, 5, 50, 26, 2, 355, 354,
	3, 2, 2, 2, 355, 356, 3, 2, 2, 2, 356, 358, 3, 2, 2, 2, 357, 359, 5, 60,
	31, 2, 358, 357, 3, 2, 2, 2, 358, 359, 3, 2, 2, 2, 359, 360, 3, 2, 2, 2,
	360, 361, 7, 26, 2, 2, 361, 39, 3, 2, 2, 2, 362, 363, 7, 86, 2, 2, 363,
	364, 7, 15, 2, 2, 364, 365, 5, 134, 68, 2, 365, 366, 7, 11, 2, 2, 366,
	367, 5, 76, 39, 2, 367, 368, 7, 4, 2, 2, 368, 41, 3, 2, 2, 2, 369, 371,
	7, 27, 2, 2, 370, 369, 3, 2, 2, 2, 370, 371, 3, 2, 2, 2, 371, 373, 3, 2,
	2, 2, 372, 374, 7, 28, 2, 2, 373, 372, 3, 2, 2, 2, 373, 374, 3, 2, 2, 2,
	374, 375, 3, 2, 2, 2, 375, 376, 7, 22, 2, 2, 376, 377, 7, 86, 2, 2, 377,
	386, 7, 17, 2, 2, 378, 383, 5, 30, 16, 2, 379, 380, 7, 6, 2, 2, 380, 382,
	5, 30, 16, 2, 381, 379, 3, 2, 2, 2, 382, 385, 3, 2, 2, 2, 383, 381, 3,
	2, 2, 2, 383, 384, 3, 2, 2, 2, 384, 387, 3, 2, 2, 2, 385, 383, 3, 2, 2,
	2, 386, 378, 3, 2, 2, 2, 386, 387, 3, 2, 2, 2, 387, 388, 3, 2, 2, 2, 388,
	389, 7, 18, 2, 2, 389, 399, 7, 24, 2, 2, 390, 391, 7, 25, 2, 2, 391, 395,
	7, 24, 2, 2, 392, 394, 5, 40, 21, 2, 393, 392, 3, 2, 2, 2, 394, 397, 3,
	2, 2, 2, 395, 393, 3, 2, 2, 2, 395, 396, 3, 2, 2, 2, 396, 398, 3, 2, 2,
	2, 397, 395, 3, 2, 2, 2, 398, 400, 7, 26, 2, 2, 399, 390, 3, 2, 2, 2, 399,
	400, 3, 2, 2, 2, 400, 402, 3, 2, 2, 2, 401, 403, 5, 50, 26, 2, 402, 401,
	3, 2, 2, 2, 402, 403, 3, 2, 2, 2, 403, 405, 3, 2, 2, 2, 404, 406, 5, 60,
	31, 2, 405, 404, 3, 2, 2, 2, 405, 406, 3, 2, 2, 2, 406, 407, 3, 2, 2, 2,
	407, 408, 7, 26, 2, 2, 408, 43, 3, 2, 2, 2, 409, 410, 7, 8, 2, 2, 410,
	415, 5, 46, 24, 2, 411, 412, 7, 6, 2, 2, 412, 414, 5, 46, 24, 2, 413, 411,
	3, 2, 2, 2, 414, 417, 3, 2, 2, 2, 415, 413, 3, 2, 2, 2, 415, 416, 3, 2,
	2, 2, 416, 422, 3, 2, 2, 2, 417, 415, 3, 2, 2, 2, 418, 419, 7, 17, 2, 2,
	419, 420, 5, 76, 39, 2, 420, 421, 7, 18, 2, 2, 421, 423, 3, 2, 2, 2, 422,
	418, 3, 2, 2, 2, 422, 423, 3, 2, 2, 2, 423, 45, 3, 2, 2, 2, 424, 425, 5,
	48, 25, 2, 425, 47, 3, 2, 2, 2, 426, 427, 7, 86, 2, 2, 427, 428, 7, 15,
	2, 2, 428, 438, 5, 134, 68, 2, 429, 430, 7, 29, 2, 2, 430, 435, 7, 86,
	2, 2, 431, 432, 7, 6, 2, 2, 432, 434, 7, 86, 2, 2, 433, 431, 3, 2, 2, 2,
	434, 437, 3, 2, 2, 2, 435, 433, 3, 2, 2, 2, 435, 436, 3, 2, 2, 2, 436,
	439, 3, 2, 2, 2, 437, 435, 3, 2, 2, 2, 438, 429, 3, 2, 2, 2, 438, 439,
	3, 2, 2, 2, 439, 49, 3, 2, 2, 2, 440, 441, 7, 30, 2, 2, 441, 446, 5, 52,
	27, 2, 442, 443, 7, 6, 2, 2, 443, 445, 5, 52, 27, 2, 444, 442, 3, 2, 2,
	2, 445, 448, 3, 2, 2, 2, 446, 444, 3, 2, 2, 2, 446, 447, 3, 2, 2, 2, 447,
	51, 3, 2, 2, 2, 448, 446, 3, 2, 2, 2, 449, 452, 5, 54, 28, 2, 450, 452,
	5, 56, 29, 2, 451, 449, 3, 2, 2, 2, 451, 450, 3, 2, 2, 2, 452, 53, 3, 2,
	2, 2, 453, 454, 7, 86, 2, 2, 454, 455, 7, 15, 2, 2, 455, 458, 5, 134, 68,
	2, 456, 457, 7, 29, 2, 2, 457, 459, 7, 86, 2, 2, 458, 456, 3, 2, 2, 2,
	458, 459, 3, 2, 2, 2, 459, 462, 3, 2, 2, 2, 460, 461, 7, 31, 2, 2, 461,
	463, 7, 86, 2, 2, 462, 460, 3, 2, 2, 2, 462, 463, 3, 2, 2, 2, 463, 476,
	3, 2, 2, 2, 464, 473, 7, 17, 2, 2, 465, 470, 5, 58, 30, 2, 466, 467, 7,
	6, 2, 2, 467, 469, 5, 58, 30, 2, 468, 466, 3, 2, 2, 2, 469, 472, 3, 2,
	2, 2, 470, 468, 3, 2, 2, 2, 470, 471, 3, 2, 2, 2, 471, 474, 3, 2, 2, 2,
	472, 470, 3, 2, 2, 2, 473, 465, 3, 2, 2, 2, 473, 474, 3, 2, 2, 2, 474,
	475, 3, 2, 2, 2, 475, 477, 7, 18, 2, 2, 476, 464, 3, 2, 2, 2, 476, 477,
	3, 2, 2, 2, 477, 55, 3, 2, 2, 2, 478, 479, 7, 86, 2, 2, 479, 480, 7, 15,
	2, 2, 480, 481, 7, 32, 2, 2, 481, 482, 5, 134, 68, 2, 482, 483, 7, 33,
	2, 2, 483, 484, 7, 17, 2, 2, 484, 485, 5, 88, 45, 2, 485, 486, 7, 29, 2,
	2, 486, 487, 5, 76, 39, 2, 487, 490, 7, 18, 2, 2, 488, 489, 7, 31, 2, 2,
	489, 491, 7, 86, 2, 2, 490, 488, 3, 2, 2, 2, 490, 491, 3, 2, 2, 2, 491,
	504, 3, 2, 2, 2, 492, 501, 7, 17, 2, 2, 493, 498, 5, 58, 30, 2, 494, 495,
	7, 6, 2, 2, 495, 497, 5, 58, 30, 2, 496, 494, 3, 2, 2, 2, 497, 500, 3,
	2, 2, 2, 498, 496, 3, 2, 2, 2, 498, 499, 3, 2, 2, 2, 499, 502, 3, 2, 2,
	2, 500, 498, 3, 2, 2, 2, 501, 493, 3, 2, 2, 2, 501, 502, 3, 2, 2, 2, 502,
	503, 3, 2, 2, 2, 503, 505, 7, 18, 2, 2, 504, 492, 3, 2, 2, 2, 504, 505,
	3, 2, 2, 2, 505, 57, 3, 2, 2, 2, 506, 507, 7, 86, 2, 2, 507, 508, 7, 34,
	2, 2, 508, 509, 5, 76, 39, 2, 509, 59, 3, 2, 2, 2, 510, 511, 7, 35, 2,
	2, 511, 515, 7, 24, 2, 2, 512, 514, 5, 62, 32, 2, 513, 512, 3, 2, 2, 2,
	514, 517, 3, 2, 2, 2, 515, 513, 3, 2, 2, 2, 515, 516, 3, 2, 2, 2, 516,
	518, 3, 2, 2, 2, 517, 515, 3, 2, 2, 2, 518, 519, 7, 26, 2, 2, 519, 61,
	3, 2, 2, 2, 520, 525, 5, 68, 35, 2, 521, 525, 5, 66, 34, 2, 522, 525, 5,
	64, 33, 2, 523, 525, 5, 70, 36, 2, 524, 520, 3, 2, 2, 2, 524, 521, 3, 2,
	2, 2, 524, 522, 3, 2, 2, 2, 524, 523, 3, 2, 2, 2, 525, 63, 3, 2, 2, 2,
	526, 527, 5, 76, 39, 2, 527, 528, 7, 34, 2, 2, 528, 529, 5, 76, 39, 2,
	529, 530, 7, 4, 2, 2, 530, 65, 3, 2, 2, 2, 531, 532, 5, 76, 39, 2, 532,
	533, 7, 4, 2, 2, 533, 67, 3, 2, 2, 2, 534, 535, 7, 36, 2, 2, 535, 536,
	7, 17, 2, 2, 536, 537, 5, 76, 39, 2, 537, 547, 7, 18, 2, 2, 538, 548, 5,
	62, 32, 2, 539, 543, 7, 24, 2, 2, 540, 542, 5, 62, 32, 2, 541, 540, 3,
	2, 2, 2, 542, 545, 3, 2, 2, 2, 543, 541, 3, 2, 2, 2, 543, 544, 3, 2, 2,
	2, 544, 546, 3, 2, 2, 2, 545, 543, 3, 2, 2, 2, 546, 548, 7, 26, 2, 2, 547,
	538, 3, 2, 2, 2, 547, 539, 3, 2, 2, 2, 548, 561, 3, 2, 2, 2, 549, 559,
	7, 37, 2, 2, 550, 560, 5, 62, 32, 2, 551, 555, 7, 24, 2, 2, 552, 554, 5,
	62, 32, 2, 553, 552, 3, 2, 2, 2, 554, 557, 3, 2, 2, 2, 555, 553, 3, 2,
	2, 2, 555, 556, 3, 2, 2, 2, 556, 558, 3, 2, 2, 2, 557, 555, 3, 2, 2, 2,
	558, 560, 7, 26, 2, 2, 559, 550, 3, 2, 2, 2, 559, 551, 3, 2, 2, 2, 560,
	562, 3, 2, 2, 2, 561, 549, 3, 2, 2, 2, 561, 562, 3, 2, 2, 2, 562, 69, 3,
	2, 2, 2, 563, 564, 7, 38, 2, 2, 564, 565, 7, 17, 2, 2, 565, 566, 5, 88,
	45, 2, 566, 567, 7, 29, 2, 2, 567, 568, 5, 76, 39, 2, 568, 569, 7, 18,
	2, 2, 569, 573, 7, 24, 2, 2, 570, 572, 5, 62, 32, 2, 571, 570, 3, 2, 2,
	2, 572, 575, 3, 2, 2, 2, 573, 571, 3, 2, 2, 2, 573, 574, 3, 2, 2, 2, 574,
	576, 3, 2, 2, 2, 575, 573, 3, 2, 2, 2, 576, 577, 7, 26, 2, 2, 577, 71,
	3, 2, 2, 2, 578, 579, 7, 86, 2, 2, 579, 580, 7, 15, 2, 2, 580, 581, 7,
	86, 2, 2, 581, 73, 3, 2, 2, 2, 582, 583, 7, 86, 2, 2, 583, 584, 7, 39,
	2, 2, 584, 585, 9, 2, 2, 2, 585, 75, 3, 2, 2, 2, 586, 589, 5, 176, 89,
	2, 587, 589, 5, 110, 56, 2, 588, 586, 3, 2, 2, 2, 588, 587, 3, 2, 2, 2,
	589, 77, 3, 2, 2, 2, 590, 591, 7, 86, 2, 2, 591, 592, 7, 17, 2, 2, 592,
	597, 5, 88, 45, 2, 593, 594, 7, 6, 2, 2, 594, 596, 5, 88, 45, 2, 595, 593,
	3, 2, 2, 2, 596, 599, 3, 2, 2, 2, 597, 595, 3, 2, 2, 2, 597, 598, 3, 2,
	2, 2, 598, 600, 3, 2, 2, 2, 599, 597, 3, 2, 2, 2, 600, 601, 7, 40, 2, 2,
	601, 602, 5, 76, 39, 2, 602, 603, 7, 18, 2, 2, 603, 79, 3, 2, 2, 2, 604,
	605, 7, 41, 2, 2, 605, 606, 7, 17, 2, 2, 606, 611, 5, 88, 45, 2, 607, 608,
	7, 6, 2, 2, 608, 610, 5, 88, 45, 2, 609, 607, 3, 2, 2, 2, 610, 613, 3,
	2, 2, 2, 611, 609, 3, 2, 2, 2, 611, 612, 3, 2, 2, 2, 612, 614, 3, 2, 2,
	2, 613, 611, 3, 2, 2, 2, 614, 615, 7, 4, 2, 2, 615, 616, 5, 112, 57, 2,
	616, 617, 7, 40, 2, 2, 617, 618, 5, 76, 39, 2, 618, 619, 7, 18, 2, 2, 619,
	81, 3, 2, 2, 2, 620, 621, 7, 86, 2, 2, 621, 630, 7, 17, 2, 2, 622, 627,
	5, 76, 39, 2, 623, 624, 7, 6, 2, 2, 624, 626, 5, 76, 39, 2, 625, 623, 3,
	2, 2, 2, 626, 629, 3, 2, 2, 2, 627, 625, 3, 2, 2, 2, 627, 628, 3, 2, 2,
	2, 628, 631, 3, 2, 2, 2, 629, 627, 3, 2, 2, 2, 630, 622, 3, 2, 2, 2, 630,
	631, 3, 2, 2, 2, 631, 632, 3, 2, 2, 2, 632, 633, 7, 18, 2, 2, 633, 83,
	3, 2, 2, 2, 634, 635, 7, 86, 2, 2, 635, 644, 7, 17, 2, 2, 636, 641, 5,
	76, 39, 2, 637, 638, 7, 6, 2, 2, 638, 640, 5, 76, 39, 2, 639, 637, 3, 2,
	2, 2, 640, 643, 3, 2, 2, 2, 641, 639, 3, 2, 2, 2, 641, 642, 3, 2, 2, 2,
	642, 645, 3, 2, 2, 2, 643, 641, 3, 2, 2, 2, 644, 636, 3, 2, 2, 2, 644,
	645, 3, 2, 2, 2, 645, 646, 3, 2, 2, 2, 646, 647, 7, 18, 2, 2, 647, 85,
	3, 2, 2, 2, 648, 649, 7, 86, 2, 2, 649, 87, 3, 2, 2, 2, 650, 651, 7, 86,
	2, 2, 651, 89, 3, 2, 2, 2, 652, 653, 7, 42, 2, 2, 653, 91, 3, 2, 2, 2,
	654, 658, 5, 94, 48, 2, 655, 658, 5, 96, 49, 2, 656, 658, 5, 102, 52, 2,
	657, 654, 3, 2, 2, 2, 657, 655, 3, 2, 2, 2, 657, 656, 3, 2, 2, 2, 658,
	93, 3, 2, 2, 2, 659, 662, 5, 98, 50, 2, 660, 662, 5, 100, 51, 2, 661, 659,
	3, 2, 2, 2, 661, 660, 3, 2, 2, 2, 662, 95, 3, 2, 2, 2, 663, 664, 9, 4,
	2, 2, 664, 97, 3, 2, 2, 2, 665, 666, 7, 84, 2, 2, 666, 99, 3, 2, 2, 2,
	667, 668, 7, 85, 2, 2, 668, 101, 3, 2, 2, 2, 669, 670, 7, 83, 2, 2, 670,
	103, 3, 2, 2, 2, 671, 672, 7, 36, 2, 2, 672, 673, 5, 76, 39, 2, 673, 674,
	7, 45, 2, 2, 674, 675, 5, 76, 39, 2, 675, 676, 7, 37, 2, 2, 676, 677, 5,
	76, 39, 2, 677, 678, 7, 46, 2, 2, 678, 105, 3, 2, 2, 2, 679, 680, 7, 86,
	2, 2, 680, 107, 3, 2, 2, 2, 681, 682, 7, 47, 2, 2, 682, 109, 3, 2, 2, 2,
	683, 684, 7, 48, 2, 2, 684, 685, 5, 112, 57, 2, 685, 686, 7, 29, 2, 2,
	686, 687, 5, 76, 39, 2, 687, 111, 3, 2, 2, 2, 688, 689, 7, 86, 2, 2, 689,
	690, 7, 15, 2, 2, 690, 691, 5, 134, 68, 2, 691, 692, 7, 11, 2, 2, 692,
	693, 5, 76, 39, 2, 693, 113, 3, 2, 2, 2, 694, 695, 7, 49, 2, 2, 695, 696,
	7, 86, 2, 2, 696, 115, 3, 2, 2, 2, 697, 702, 5, 118, 60, 2, 698, 702, 5,
	120, 61, 2, 699, 702, 5, 122, 62, 2, 700, 702, 5, 124, 63, 2, 701, 697,
	3, 2, 2, 2, 701, 698, 3, 2, 2, 2, 701, 699, 3, 2, 2, 2, 701, 700, 3, 2,
	2, 2, 702, 117, 3, 2, 2, 2, 703, 704, 7, 50, 2, 2, 704, 713, 7, 24, 2,
	2, 705, 710, 5, 76, 39, 2, 706, 707, 7, 6, 2, 2, 707, 709, 5, 76, 39, 2,
	708, 706, 3, 2, 2, 2, 709, 712, 3, 2, 2, 2, 710, 708, 3, 2, 2, 2, 710,
	711, 3, 2, 2, 2, 711, 714, 3, 2, 2, 2, 712, 710, 3, 2, 2, 2, 713, 705,
	3, 2, 2, 2, 713, 714, 3, 2, 2, 2, 714, 715, 3, 2, 2, 2, 715, 716, 7, 26,
	2, 2, 716, 119, 3, 2, 2, 2, 717, 718, 7, 51, 2, 2, 718, 727, 7, 24, 2,
	2, 719, 724, 5, 76, 39, 2, 720, 721, 7, 6, 2, 2, 721, 723, 5, 76, 39, 2,
	722, 720, 3, 2, 2, 2, 723, 726, 3, 2, 2, 2, 724, 722, 3, 2, 2, 2, 724,
	725, 3, 2, 2, 2, 725, 728, 3, 2, 2, 2, 726, 724, 3, 2, 2, 2, 727, 719,
	3, 2, 2, 2, 727, 728, 3, 2, 2, 2, 728, 729, 3, 2, 2, 2, 729, 730, 7, 26,
	2, 2, 730, 121, 3, 2, 2, 2, 731, 732, 7, 52, 2, 2, 732, 741, 7, 24, 2,
	2, 733, 738, 5, 76, 39, 2, 734, 735, 7, 6, 2, 2, 735, 737, 5, 76, 39, 2,
	736, 734, 3, 2, 2, 2, 737, 740, 3, 2, 2, 2, 738, 736, 3, 2, 2, 2, 738,
	739, 3, 2, 2, 2, 739, 742, 3, 2, 2, 2, 740, 738, 3, 2, 2, 2, 741, 733,
	3, 2, 2, 2, 741, 742, 3, 2, 2, 2, 742, 743, 3, 2, 2, 2, 743, 744, 7, 26,
	2, 2, 744, 123, 3, 2, 2, 2, 745, 746, 7, 53, 2, 2, 746, 755, 7, 24, 2,
	2, 747, 752, 5, 76, 39, 2, 748, 749, 7, 6, 2, 2, 749, 751, 5, 76, 39, 2,
	750, 748, 3, 2, 2, 2, 751, 754, 3, 2, 2, 2, 752, 750, 3, 2, 2, 2, 752,
	753, 3, 2, 2, 2, 753, 756, 3, 2, 2, 2, 754, 752, 3, 2, 2, 2, 755, 747,
	3, 2, 2, 2, 755, 756, 3, 2, 2, 2, 756, 757, 3, 2, 2, 2, 757, 758, 7, 26,
	2, 2, 758, 125, 3, 2, 2, 2, 759, 760, 7, 54, 2, 2, 760, 769, 7, 24, 2,
	2, 761, 766, 5, 128, 65, 2, 762, 763, 7, 6, 2, 2, 763, 765, 5, 128, 65,
	2, 764, 762, 3, 2, 2, 2, 765, 768, 3, 2, 2, 2, 766, 764, 3, 2, 2, 2, 766,
	767, 3, 2, 2, 2, 767, 770, 3, 2, 2, 2, 768, 766, 3, 2, 2, 2, 769, 761,
	3, 2, 2, 2, 769, 770, 3, 2, 2, 2, 770, 771, 3, 2, 2, 2, 771, 772, 7, 26,
	2, 2, 772, 127, 3, 2, 2, 2, 773, 774, 7, 17, 2, 2, 774, 775, 5, 76, 39,
	2, 775, 776, 7, 6, 2, 2, 776, 777, 5, 76, 39, 2, 777, 778, 7, 18, 2, 2,
	778, 129, 3, 2, 2, 2, 779, 780, 7, 55, 2, 2, 780, 789, 7, 24, 2, 2, 781,
	786, 5, 132, 67, 2, 782, 783, 7, 6, 2, 2, 783, 785, 5, 132, 67, 2, 784,
	782, 3, 2, 2, 2, 785, 788, 3, 2, 2, 2, 786, 784, 3, 2, 2, 2, 786, 787,
	3, 2, 2, 2, 787, 790, 3, 2, 2, 2, 788, 786, 3, 2, 2, 2, 789, 781, 3, 2,
	2, 2, 789, 790, 3, 2, 2, 2, 790, 791, 3, 2, 2, 2, 791, 792, 7, 26, 2, 2,
	792, 131, 3, 2, 2, 2, 793, 796, 7, 86, 2, 2, 794, 795, 7, 15, 2, 2, 795,
	797, 5, 134, 68, 2, 796, 794, 3, 2, 2, 2, 796, 797, 3, 2, 2, 2, 797, 798,
	3, 2, 2, 2, 798, 799, 7, 11, 2, 2, 799, 800, 5, 76, 39, 2, 800, 133, 3,
	2, 2, 2, 801, 809, 5, 74, 38, 2, 802, 809, 5, 136, 69, 2, 803, 809, 5,
	138, 70, 2, 804, 809, 5, 142, 72, 2, 805, 809, 5, 144, 73, 2, 806, 809,
	5, 156, 79, 2, 807, 809, 5, 180, 91, 2, 808, 801, 3, 2, 2, 2, 808, 802,
	3, 2, 2, 2, 808, 803, 3, 2, 2, 2, 808, 804, 3, 2, 2, 2, 808, 805, 3, 2,
	2, 2, 808, 806, 3, 2, 2, 2, 808, 807, 3, 2, 2, 2, 809, 135, 3, 2, 2, 2,
	810, 811, 5, 182, 92, 2, 811, 137, 3, 2, 2, 2, 812, 813, 7, 56, 2, 2, 813,
	822, 7, 17, 2, 2, 814, 819, 5, 140, 71, 2, 815, 816, 7, 6, 2, 2, 816, 818,
	5, 140, 71, 2, 817, 815, 3, 2, 2, 2, 818, 821, 3, 2, 2, 2, 819, 817, 3,
	2, 2, 2, 819, 820, 3, 2, 2, 2, 820, 823, 3, 2, 2, 2, 821, 819, 3, 2, 2,
	2, 822, 814, 3, 2, 2, 2, 822, 823, 3, 2, 2, 2, 823, 824, 3, 2, 2, 2, 824,
	825, 7, 18, 2, 2, 825, 139, 3, 2, 2, 2, 826, 827, 7, 86, 2, 2, 827, 828,
	7, 15, 2, 2, 828, 829, 5, 134, 68, 2, 829, 141, 3, 2, 2, 2, 830, 831, 7,
	54, 2, 2, 831, 832, 7, 17, 2, 2, 832, 833, 5, 134, 68, 2, 833, 834, 7,
	6, 2, 2, 834, 835, 5, 134, 68, 2, 835, 836, 7, 18, 2, 2, 836, 143, 3, 2,
	2, 2, 837, 841, 5, 146, 74, 2, 838, 841, 5, 152, 77, 2, 839, 841, 5, 154,
	78, 2, 840, 837, 3, 2, 2, 2, 840, 838, 3, 2, 2, 2, 840, 839, 3, 2, 2, 2,
	841, 145, 3, 2, 2, 2, 842, 845, 5, 148, 75, 2, 843, 845, 5, 150, 76, 2,
	844, 842, 3, 2, 2, 2, 844, 843, 3, 2, 2, 2, 845, 147, 3, 2, 2, 2, 846,
	847, 7, 57, 2, 2, 847, 149, 3, 2, 2, 2, 848, 849, 7, 58, 2, 2, 849, 151,
	3, 2, 2, 2, 850, 851, 7, 59, 2, 2, 851, 153, 3, 2, 2, 2, 852, 853, 7, 60,
	2, 2, 853, 155, 3, 2, 2, 2, 854, 860, 5, 158, 80, 2, 855, 860, 5, 160,
	81, 2, 856, 860, 5, 162, 82, 2, 857, 860, 5, 164, 83, 2, 858, 860, 5, 184,
	93, 2, 859, 854, 3, 2, 2, 2, 859, 855, 3, 2, 2, 2, 859, 856, 3, 2, 2, 2,
	859, 857, 3, 2, 2, 2, 859, 858, 3, 2, 2, 2, 860, 157, 3, 2, 2, 2, 861,
	862, 7, 50, 2, 2, 862, 863, 7, 17, 2, 2, 863, 864, 5, 134, 68, 2, 864,
	865, 7, 18, 2, 2, 865, 159, 3, 2, 2, 2, 866, 867, 7, 51, 2, 2, 867, 868,
	7, 17, 2, 2, 868, 869, 5, 134, 68, 2, 869, 870, 7, 18, 2, 2, 870, 161,
	3, 2, 2, 2, 871, 872, 7, 52, 2, 2, 872, 873, 7, 17, 2, 2, 873, 874, 5,
	134, 68, 2, 874, 875, 7, 18, 2, 2, 875, 163, 3, 2, 2, 2, 876, 877, 7, 53,
	2, 2, 877, 878, 7, 17, 2, 2, 878, 879, 5, 134, 68, 2, 879, 880, 7, 18,
	2, 2, 880, 165, 3, 2, 2, 2, 881, 895, 5, 186, 94, 2, 882, 885, 7, 61, 2,
	2, 883, 886, 5, 84, 43, 2, 884, 886, 5, 86, 44, 2, 885, 883, 3, 2, 2, 2,
	885, 884, 3, 2, 2, 2, 886, 894, 3, 2, 2, 2, 887, 891, 7, 62, 2, 2, 888,
	892, 5, 78, 40, 2, 889, 892, 5, 80, 41, 2, 890, 892, 5, 82, 42, 2, 891,
	888, 3, 2, 2, 2, 891, 889, 3, 2, 2, 2, 891, 890, 3, 2, 2, 2, 892, 894,
	3, 2, 2, 2, 893, 882, 3, 2, 2, 2, 893, 887, 3, 2, 2, 2, 894, 897, 3, 2,
	2, 2, 895, 893, 3, 2, 2, 2, 895, 896, 3, 2, 2, 2, 896, 167, 3, 2, 2, 2,
	897, 895, 3, 2, 2, 2, 898, 899, 7, 63, 2, 2, 899, 904, 5, 166, 84, 2, 900,
	901, 7, 64, 2, 2, 901, 904, 5, 166, 84, 2, 902, 904, 5, 166, 84, 2, 903,
	898, 3, 2, 2, 2, 903, 900, 3, 2, 2, 2, 903, 902, 3, 2, 2, 2, 904, 169,
	3, 2, 2, 2, 905, 916, 5, 168, 85, 2, 906, 907, 7, 65, 2, 2, 907, 915, 5,
	168, 85, 2, 908, 909, 7, 66, 2, 2, 909, 915, 5, 168, 85, 2, 910, 911, 7,
	67, 2, 2, 911, 915, 5, 168, 85, 2, 912, 913, 7, 68, 2, 2, 913, 915, 5,
	168, 85, 2, 914, 906, 3, 2, 2, 2, 914, 908, 3, 2, 2, 2, 914, 910, 3, 2,
	2, 2, 914, 912, 3, 2, 2, 2, 915, 918, 3, 2, 2, 2, 916, 914, 3, 2, 2, 2,
	916, 917, 3, 2, 2, 2, 917, 171, 3, 2, 2, 2, 918, 916, 3, 2, 2, 2, 919,
	926, 5, 170, 86, 2, 920, 921, 7, 69, 2, 2, 921, 925, 5, 170, 86, 2, 922,
	923, 7, 64, 2, 2, 923, 925, 5, 170, 86, 2, 924, 920, 3, 2, 2, 2, 924, 922,
	3, 2, 2, 2, 925, 928, 3, 2, 2, 2, 926, 924, 3, 2, 2, 2, 926, 927, 3, 2,
	2, 2, 927, 173, 3, 2, 2, 2, 928, 926, 3, 2, 2, 2, 929, 944, 5, 172, 87,
	2, 930, 931, 7, 11, 2, 2, 931, 943, 5, 172, 87, 2, 932, 933, 7, 70, 2,
	2, 933, 943, 5, 172, 87, 2, 934, 935, 7, 71, 2, 2, 935, 943, 5, 172, 87,
	2, 936, 937, 7, 72, 2, 2, 937, 943, 5, 172, 87, 2, 938, 939, 7, 73, 2,
	2, 939, 943, 5, 172, 87, 2, 940, 941, 7, 74, 2, 2, 941, 943, 5, 172, 87,
	2, 942, 930, 3, 2, 2, 2, 942, 932, 3, 2, 2, 2, 942, 934, 3, 2, 2, 2, 942,
	936, 3, 2, 2, 2, 942, 938, 3, 2, 2, 2, 942, 940, 3, 2, 2, 2, 943, 946,
	3, 2, 2, 2, 944, 942, 3, 2, 2, 2, 944, 945, 3, 2, 2, 2, 945, 175, 3, 2,
	2, 2, 946, 944, 3, 2, 2, 2, 947, 958, 5, 174, 88, 2, 948, 949, 7, 75, 2,
	2, 949, 957, 5, 174, 88, 2, 950, 951, 7, 76, 2, 2, 951, 957, 5, 174, 88,
	2, 952, 953, 7, 77, 2, 2, 953, 957, 5, 174, 88, 2, 954, 955, 7, 78, 2,
	2, 955, 957, 5, 174, 88, 2, 956, 948, 3, 2, 2, 2, 956, 950, 3, 2, 2, 2,
	956, 952, 3, 2, 2, 2, 956, 954, 3, 2, 2, 2, 957, 960, 3, 2, 2, 2, 958,
	956, 3, 2, 2, 2, 958, 959, 3, 2, 2, 2, 959, 177, 3, 2, 2, 2, 960, 958,
	3, 2, 2, 2, 961, 963, 7, 79, 2, 2, 962, 961, 3, 2, 2, 2, 962, 963, 3, 2,
	2, 2, 963, 965, 3, 2, 2, 2, 964, 966, 7, 21, 2, 2, 965, 964, 3, 2, 2, 2,
	965, 966, 3, 2, 2, 2, 966, 968, 3, 2, 2, 2, 967, 969, 7, 7, 2, 2, 968,
	967, 3, 2, 2, 2, 968, 969, 3, 2, 2, 2, 969, 970, 3, 2, 2, 2, 970, 971,
	7, 22, 2, 2, 971, 974, 7, 86, 2, 2, 972, 973, 7, 23, 2, 2, 973, 975, 7,
	86, 2, 2, 974, 972, 3, 2, 2, 2, 974, 975, 3, 2, 2, 2, 975, 976, 3, 2, 2,
	2, 976, 977, 7, 24, 2, 2, 977, 987, 5, 44, 23, 2, 978, 979, 7, 25, 2, 2,
	979, 983, 7, 24, 2, 2, 980, 982, 5, 40, 21, 2, 981, 980, 3, 2, 2, 2, 982,
	985, 3, 2, 2, 2, 983, 981, 3, 2, 2, 2, 983, 984, 3, 2, 2, 2, 984, 986,
	3, 2, 2, 2, 985, 983, 3, 2, 2, 2, 986, 988, 7, 26, 2, 2, 987, 978, 3, 2,
	2, 2, 987, 988, 3, 2, 2, 2, 988, 990, 3, 2, 2, 2, 989, 991, 5, 50, 26,
	2, 990, 989, 3, 2, 2, 2, 990, 991, 3, 2, 2, 2, 991, 993, 3, 2, 2, 2, 992,
	994, 5, 60, 31, 2, 993, 992, 3, 2, 2, 2, 993, 994, 3, 2, 2, 2, 994, 995,
	3, 2, 2, 2, 995, 996, 7, 26, 2, 2, 996, 179, 3, 2, 2, 2, 997, 998, 7, 80,
	2, 2, 998, 181, 3, 2, 2, 2, 999, 1000, 7, 81, 2, 2, 1000, 183, 3, 2, 2,
	2, 1001, 1002, 7, 82, 2, 2, 1002, 1003, 7, 17, 2, 2, 1003, 1004, 5, 134,
	68, 2, 1004, 1005, 7, 18, 2, 2, 1005, 185, 3, 2, 2, 2, 1006, 1021, 5, 106,
	54, 2, 1007, 1021, 5, 90, 46, 2, 1008, 1021, 5, 92, 47, 2, 1009, 1021,
	5, 104, 53, 2, 1010, 1021, 5, 108, 55, 2, 1011, 1021, 5, 114, 58, 2, 1012,
	1021, 5, 116, 59, 2, 1013, 1021, 5, 126, 64, 2, 1014, 1021, 5, 130, 66,
	2, 1015, 1021, 5, 134, 68, 2, 1016, 1017, 7, 17, 2, 2, 1017, 1018, 5, 76,
	39, 2, 1018, 1019, 7, 18, 2, 2, 1019, 1021, 3, 2, 2, 2, 1020, 1006, 3,
	2, 2, 2, 1020, 1007, 3, 2, 2, 2, 1020, 1008, 3, 2, 2, 2, 1020, 1009, 3,
	2, 2, 2, 1020, 1010, 3, 2, 2, 2, 1020, 1011, 3, 2, 2, 2, 1020, 1012, 3,
	2, 2, 2, 1020, 1013, 3, 2, 2, 2, 1020, 1014, 3, 2, 2, 2, 1020, 1015, 3,
	2, 2, 2, 1020, 1016, 3, 2, 2, 2, 1021, 187, 3, 2, 2, 2, 108, 191, 204,
	210, 218, 226, 237, 243, 254, 260, 269, 276, 287, 296, 299, 319, 323, 326,
	330, 333, 339, 348, 352, 355, 358, 370, 373, 383, 386, 395, 399, 402, 405,
	415, 422, 435, 438, 446, 451, 458, 462, 470, 473, 476, 490, 498, 501, 504,
	515, 524, 543, 547, 555, 559, 561, 573, 588, 597, 611, 627, 630, 641, 644,
	657, 661, 701, 710, 713, 724, 727, 738, 741, 752, 755, 766, 769, 786, 789,
	796, 808, 819, 822, 840, 844, 859, 885, 891, 893, 895, 903, 914, 916, 924,
	926, 942, 944, 956, 958, 962, 965, 968, 974, 983, 987, 990, 993, 1020,
}
var literalNames = []string{
	"", "'module'", "';'", "'create'", "','", "'refining'", "'from'", "'library'",
	"'query'", "'='", "'uses'", "'helper'", "'def'", "':'", "'context'", "'('",
	"')'", "'unique'", "'lazy'", "'abstract'", "'rule'", "'extends'", "'{'",
	"'using'", "'}'", "'entrypoint'", "'endpoint'", "'in'", "'to'", "'mapsTo'",
	"'distinct'", "'foreach'", "'<-'", "'do'", "'if'", "'else'", "'for'", "'!'",
	"'|'", "'iterate'", "'OclUndefined'", "'true'", "'false'", "'then'", "'endif'",
	"'super'", "'let'", "'#'", "'Bag'", "'Set'", "'OrderedSet'", "'Sequence'",
	"'Map'", "'Tuple'", "'TupleType'", "'Integer'", "'Real'", "'Boolean'",
	"'String'", "'.'", "'->'", "'not'", "'-'", "'*'", "'/'", "'div'", "'mod'",
	"'+'", "'>'", "'<'", "'>='", "'<='", "'<>'", "'and'", "'or'", "'xor'",
	"'implies'", "'nodefault'", "'OclType'", "'OclAny'", "'Collection'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "STRING", "INTEGER", "FLOAT", "IDENTIFIER",
	"WS", "COMMENT", "LINE_COMMENT",
}

var ruleNames = []string{
	"unit", "module", "targetModelPattern", "sourceModelPattern", "transformationMode",
	"library_", "query", "libraryRef", "moduleElement", "helper", "oclFeatureDefinition",
	"oclContextDefinition", "oclFeature", "operation", "parameter", "attribute",
	"arule", "matchedRule", "lazyMatchedRule", "ruleVariableDeclaration", "calledRule",
	"inPattern", "inPatternElement", "simpleInPatternElement", "outPattern",
	"outPatternElement", "simpleOutPatternElement", "forEachOutPatternElement",
	"binding", "actionBlock", "statement", "bindingStat", "expressionStat",
	"ifStat", "forStat", "oclModel", "oclModelElement", "oclExpression", "iteratorExp",
	"iterateExp", "collectionOperationCallExp", "operationCallExp", "navigationOrAttributeCallExp",
	"iterator", "oclUndefinedExp", "primitiveExp", "numericExp", "booleanExp",
	"integerExp", "realExp", "stringExp", "ifExp", "variableExp", "superExp",
	"letExp", "variableDeclaration", "enumLiteralExp", "collectionExp", "bagExp",
	"setExp", "orderedSetExp", "sequenceExp", "mapExp", "mapElement", "tupleExp",
	"tuplePart", "oclType", "oclAnyType", "tupleType", "tupleTypeAttribute",
	"mapType", "primitive", "numericType", "integerType", "realType", "booleanType",
	"stringType", "collectionType", "bagType", "setType", "orderedSetType",
	"sequenceType", "priority_0", "priority_1", "priority_2", "priority_3",
	"priority_4", "priority_5", "matchedRule_abstractContents", "oclType_abstractContents",
	"oclAnyType_abstractContents", "collectionType_abstractContents", "primary_oclExpression",
}

type ATLParser struct {
	*antlr.BaseParser
}

// NewATLParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *ATLParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewATLParser(input antlr.TokenStream) *ATLParser {
	this := new(ATLParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ATL.g4"

	return this
}

// ATLParser tokens.
const (
	ATLParserEOF          = antlr.TokenEOF
	ATLParserT__0         = 1
	ATLParserT__1         = 2
	ATLParserT__2         = 3
	ATLParserT__3         = 4
	ATLParserT__4         = 5
	ATLParserT__5         = 6
	ATLParserT__6         = 7
	ATLParserT__7         = 8
	ATLParserT__8         = 9
	ATLParserT__9         = 10
	ATLParserT__10        = 11
	ATLParserT__11        = 12
	ATLParserT__12        = 13
	ATLParserT__13        = 14
	ATLParserT__14        = 15
	ATLParserT__15        = 16
	ATLParserT__16        = 17
	ATLParserT__17        = 18
	ATLParserT__18        = 19
	ATLParserT__19        = 20
	ATLParserT__20        = 21
	ATLParserT__21        = 22
	ATLParserT__22        = 23
	ATLParserT__23        = 24
	ATLParserT__24        = 25
	ATLParserT__25        = 26
	ATLParserT__26        = 27
	ATLParserT__27        = 28
	ATLParserT__28        = 29
	ATLParserT__29        = 30
	ATLParserT__30        = 31
	ATLParserT__31        = 32
	ATLParserT__32        = 33
	ATLParserT__33        = 34
	ATLParserT__34        = 35
	ATLParserT__35        = 36
	ATLParserT__36        = 37
	ATLParserT__37        = 38
	ATLParserT__38        = 39
	ATLParserT__39        = 40
	ATLParserT__40        = 41
	ATLParserT__41        = 42
	ATLParserT__42        = 43
	ATLParserT__43        = 44
	ATLParserT__44        = 45
	ATLParserT__45        = 46
	ATLParserT__46        = 47
	ATLParserT__47        = 48
	ATLParserT__48        = 49
	ATLParserT__49        = 50
	ATLParserT__50        = 51
	ATLParserT__51        = 52
	ATLParserT__52        = 53
	ATLParserT__53        = 54
	ATLParserT__54        = 55
	ATLParserT__55        = 56
	ATLParserT__56        = 57
	ATLParserT__57        = 58
	ATLParserT__58        = 59
	ATLParserT__59        = 60
	ATLParserT__60        = 61
	ATLParserT__61        = 62
	ATLParserT__62        = 63
	ATLParserT__63        = 64
	ATLParserT__64        = 65
	ATLParserT__65        = 66
	ATLParserT__66        = 67
	ATLParserT__67        = 68
	ATLParserT__68        = 69
	ATLParserT__69        = 70
	ATLParserT__70        = 71
	ATLParserT__71        = 72
	ATLParserT__72        = 73
	ATLParserT__73        = 74
	ATLParserT__74        = 75
	ATLParserT__75        = 76
	ATLParserT__76        = 77
	ATLParserT__77        = 78
	ATLParserT__78        = 79
	ATLParserT__79        = 80
	ATLParserSTRING       = 81
	ATLParserINTEGER      = 82
	ATLParserFLOAT        = 83
	ATLParserIDENTIFIER   = 84
	ATLParserWS           = 85
	ATLParserCOMMENT      = 86
	ATLParserLINE_COMMENT = 87
)

// ATLParser rules.
const (
	ATLParserRULE_unit                            = 0
	ATLParserRULE_module                          = 1
	ATLParserRULE_targetModelPattern              = 2
	ATLParserRULE_sourceModelPattern              = 3
	ATLParserRULE_transformationMode              = 4
	ATLParserRULE_library_                        = 5
	ATLParserRULE_query                           = 6
	ATLParserRULE_libraryRef                      = 7
	ATLParserRULE_moduleElement                   = 8
	ATLParserRULE_helper                          = 9
	ATLParserRULE_oclFeatureDefinition            = 10
	ATLParserRULE_oclContextDefinition            = 11
	ATLParserRULE_oclFeature                      = 12
	ATLParserRULE_operation                       = 13
	ATLParserRULE_parameter                       = 14
	ATLParserRULE_attribute                       = 15
	ATLParserRULE_arule                           = 16
	ATLParserRULE_matchedRule                     = 17
	ATLParserRULE_lazyMatchedRule                 = 18
	ATLParserRULE_ruleVariableDeclaration         = 19
	ATLParserRULE_calledRule                      = 20
	ATLParserRULE_inPattern                       = 21
	ATLParserRULE_inPatternElement                = 22
	ATLParserRULE_simpleInPatternElement          = 23
	ATLParserRULE_outPattern                      = 24
	ATLParserRULE_outPatternElement               = 25
	ATLParserRULE_simpleOutPatternElement         = 26
	ATLParserRULE_forEachOutPatternElement        = 27
	ATLParserRULE_binding                         = 28
	ATLParserRULE_actionBlock                     = 29
	ATLParserRULE_statement                       = 30
	ATLParserRULE_bindingStat                     = 31
	ATLParserRULE_expressionStat                  = 32
	ATLParserRULE_ifStat                          = 33
	ATLParserRULE_forStat                         = 34
	ATLParserRULE_oclModel                        = 35
	ATLParserRULE_oclModelElement                 = 36
	ATLParserRULE_oclExpression                   = 37
	ATLParserRULE_iteratorExp                     = 38
	ATLParserRULE_iterateExp                      = 39
	ATLParserRULE_collectionOperationCallExp      = 40
	ATLParserRULE_operationCallExp                = 41
	ATLParserRULE_navigationOrAttributeCallExp    = 42
	ATLParserRULE_iterator                        = 43
	ATLParserRULE_oclUndefinedExp                 = 44
	ATLParserRULE_primitiveExp                    = 45
	ATLParserRULE_numericExp                      = 46
	ATLParserRULE_booleanExp                      = 47
	ATLParserRULE_integerExp                      = 48
	ATLParserRULE_realExp                         = 49
	ATLParserRULE_stringExp                       = 50
	ATLParserRULE_ifExp                           = 51
	ATLParserRULE_variableExp                     = 52
	ATLParserRULE_superExp                        = 53
	ATLParserRULE_letExp                          = 54
	ATLParserRULE_variableDeclaration             = 55
	ATLParserRULE_enumLiteralExp                  = 56
	ATLParserRULE_collectionExp                   = 57
	ATLParserRULE_bagExp                          = 58
	ATLParserRULE_setExp                          = 59
	ATLParserRULE_orderedSetExp                   = 60
	ATLParserRULE_sequenceExp                     = 61
	ATLParserRULE_mapExp                          = 62
	ATLParserRULE_mapElement                      = 63
	ATLParserRULE_tupleExp                        = 64
	ATLParserRULE_tuplePart                       = 65
	ATLParserRULE_oclType                         = 66
	ATLParserRULE_oclAnyType                      = 67
	ATLParserRULE_tupleType                       = 68
	ATLParserRULE_tupleTypeAttribute              = 69
	ATLParserRULE_mapType                         = 70
	ATLParserRULE_primitive                       = 71
	ATLParserRULE_numericType                     = 72
	ATLParserRULE_integerType                     = 73
	ATLParserRULE_realType                        = 74
	ATLParserRULE_booleanType                     = 75
	ATLParserRULE_stringType                      = 76
	ATLParserRULE_collectionType                  = 77
	ATLParserRULE_bagType                         = 78
	ATLParserRULE_setType                         = 79
	ATLParserRULE_orderedSetType                  = 80
	ATLParserRULE_sequenceType                    = 81
	ATLParserRULE_priority_0                      = 82
	ATLParserRULE_priority_1                      = 83
	ATLParserRULE_priority_2                      = 84
	ATLParserRULE_priority_3                      = 85
	ATLParserRULE_priority_4                      = 86
	ATLParserRULE_priority_5                      = 87
	ATLParserRULE_matchedRule_abstractContents    = 88
	ATLParserRULE_oclType_abstractContents        = 89
	ATLParserRULE_oclAnyType_abstractContents     = 90
	ATLParserRULE_collectionType_abstractContents = 91
	ATLParserRULE_primary_oclExpression           = 92
)

// IUnitContext is an interface to support dynamic dispatch.
type IUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnitContext differentiates from other interfaces.
	IsUnitContext()
}

type UnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitContext() *UnitContext {
	var p = new(UnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_unit
	return p
}

func (*UnitContext) IsUnitContext() {}

func NewUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitContext {
	var p = new(UnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_unit

	return p
}

func (s *UnitContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitContext) Module() IModuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleContext)
}

func (s *UnitContext) Library_() ILibrary_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_Context)
}

func (s *UnitContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *UnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterUnit(s)
	}
}

func (s *UnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitUnit(s)
	}
}

func (p *ATLParser) Unit() (localctx IUnitContext) {
	this := p
	_ = this

	localctx = NewUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ATLParserRULE_unit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(189)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ATLParserT__0:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(186)
			p.Module()
		}

	case ATLParserT__6:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(187)
			p.Library_()
		}

	case ATLParserT__7:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(188)
			p.Query()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModuleContext is an interface to support dynamic dispatch.
type IModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleContext differentiates from other interfaces.
	IsModuleContext()
}

type ModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleContext() *ModuleContext {
	var p = new(ModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_module
	return p
}

func (*ModuleContext) IsModuleContext() {}

func NewModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleContext {
	var p = new(ModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_module

	return p
}

func (s *ModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleContext) TargetModelPattern() ITargetModelPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetModelPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetModelPatternContext)
}

func (s *ModuleContext) TransformationMode() ITransformationModeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransformationModeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransformationModeContext)
}

func (s *ModuleContext) SourceModelPattern() ISourceModelPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceModelPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceModelPatternContext)
}

func (s *ModuleContext) STRING() antlr.TerminalNode {
	return s.GetToken(ATLParserSTRING, 0)
}

func (s *ModuleContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *ModuleContext) AllLibraryRef() []ILibraryRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibraryRefContext)(nil)).Elem())
	var tst = make([]ILibraryRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibraryRefContext)
		}
	}

	return tst
}

func (s *ModuleContext) LibraryRef(i int) ILibraryRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibraryRefContext)
}

func (s *ModuleContext) AllModuleElement() []IModuleElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleElementContext)(nil)).Elem())
	var tst = make([]IModuleElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleElementContext)
		}
	}

	return tst
}

func (s *ModuleContext) ModuleElement(i int) IModuleElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleElementContext)
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterModule(s)
	}
}

func (s *ModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitModule(s)
	}
}

func (p *ATLParser) Module() (localctx IModuleContext) {
	this := p
	_ = this

	localctx = NewModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ATLParserRULE_module)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(191)
		p.Match(ATLParserT__0)
	}
	{
		p.SetState(192)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ATLParserSTRING || _la == ATLParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(193)
		p.Match(ATLParserT__1)
	}
	{
		p.SetState(194)
		p.Match(ATLParserT__2)
	}
	{
		p.SetState(195)
		p.TargetModelPattern()
	}
	{
		p.SetState(196)
		p.TransformationMode()
	}
	{
		p.SetState(197)
		p.SourceModelPattern()
	}
	{
		p.SetState(198)
		p.Match(ATLParserT__1)
	}
	p.SetState(202)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__9 {
		{
			p.SetState(199)
			p.LibraryRef()
		}

		p.SetState(204)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(208)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ATLParserT__4)|(1<<ATLParserT__10)|(1<<ATLParserT__16)|(1<<ATLParserT__17)|(1<<ATLParserT__18)|(1<<ATLParserT__19)|(1<<ATLParserT__24)|(1<<ATLParserT__25))) != 0) || _la == ATLParserT__76 {
		{
			p.SetState(205)
			p.ModuleElement()
		}

		p.SetState(210)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITargetModelPatternContext is an interface to support dynamic dispatch.
type ITargetModelPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTargetModelPatternContext differentiates from other interfaces.
	IsTargetModelPatternContext()
}

type TargetModelPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetModelPatternContext() *TargetModelPatternContext {
	var p = new(TargetModelPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_targetModelPattern
	return p
}

func (*TargetModelPatternContext) IsTargetModelPatternContext() {}

func NewTargetModelPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetModelPatternContext {
	var p = new(TargetModelPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_targetModelPattern

	return p
}

func (s *TargetModelPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetModelPatternContext) AllOclModel() []IOclModelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOclModelContext)(nil)).Elem())
	var tst = make([]IOclModelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOclModelContext)
		}
	}

	return tst
}

func (s *TargetModelPatternContext) OclModel(i int) IOclModelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclModelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOclModelContext)
}

func (s *TargetModelPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetModelPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetModelPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterTargetModelPattern(s)
	}
}

func (s *TargetModelPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitTargetModelPattern(s)
	}
}

func (p *ATLParser) TargetModelPattern() (localctx ITargetModelPatternContext) {
	this := p
	_ = this

	localctx = NewTargetModelPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ATLParserRULE_targetModelPattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(211)
		p.OclModel()
	}
	p.SetState(216)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__3 {
		{
			p.SetState(212)
			p.Match(ATLParserT__3)
		}
		{
			p.SetState(213)
			p.OclModel()
		}

		p.SetState(218)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISourceModelPatternContext is an interface to support dynamic dispatch.
type ISourceModelPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceModelPatternContext differentiates from other interfaces.
	IsSourceModelPatternContext()
}

type SourceModelPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceModelPatternContext() *SourceModelPatternContext {
	var p = new(SourceModelPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_sourceModelPattern
	return p
}

func (*SourceModelPatternContext) IsSourceModelPatternContext() {}

func NewSourceModelPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceModelPatternContext {
	var p = new(SourceModelPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_sourceModelPattern

	return p
}

func (s *SourceModelPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceModelPatternContext) AllOclModel() []IOclModelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOclModelContext)(nil)).Elem())
	var tst = make([]IOclModelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOclModelContext)
		}
	}

	return tst
}

func (s *SourceModelPatternContext) OclModel(i int) IOclModelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclModelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOclModelContext)
}

func (s *SourceModelPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceModelPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceModelPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterSourceModelPattern(s)
	}
}

func (s *SourceModelPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitSourceModelPattern(s)
	}
}

func (p *ATLParser) SourceModelPattern() (localctx ISourceModelPatternContext) {
	this := p
	_ = this

	localctx = NewSourceModelPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ATLParserRULE_sourceModelPattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(219)
		p.OclModel()
	}
	p.SetState(224)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__3 {
		{
			p.SetState(220)
			p.Match(ATLParserT__3)
		}
		{
			p.SetState(221)
			p.OclModel()
		}

		p.SetState(226)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITransformationModeContext is an interface to support dynamic dispatch.
type ITransformationModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransformationModeContext differentiates from other interfaces.
	IsTransformationModeContext()
}

type TransformationModeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransformationModeContext() *TransformationModeContext {
	var p = new(TransformationModeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_transformationMode
	return p
}

func (*TransformationModeContext) IsTransformationModeContext() {}

func NewTransformationModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransformationModeContext {
	var p = new(TransformationModeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_transformationMode

	return p
}

func (s *TransformationModeContext) GetParser() antlr.Parser { return s.parser }
func (s *TransformationModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransformationModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransformationModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterTransformationMode(s)
	}
}

func (s *TransformationModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitTransformationMode(s)
	}
}

func (p *ATLParser) TransformationMode() (localctx ITransformationModeContext) {
	this := p
	_ = this

	localctx = NewTransformationModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ATLParserRULE_transformationMode)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(227)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ATLParserT__4 || _la == ATLParserT__5) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILibrary_Context is an interface to support dynamic dispatch.
type ILibrary_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_Context differentiates from other interfaces.
	IsLibrary_Context()
}

type Library_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_Context() *Library_Context {
	var p = new(Library_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_library_
	return p
}

func (*Library_Context) IsLibrary_Context() {}

func NewLibrary_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_Context {
	var p = new(Library_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_library_

	return p
}

func (s *Library_Context) GetParser() antlr.Parser { return s.parser }

func (s *Library_Context) STRING() antlr.TerminalNode {
	return s.GetToken(ATLParserSTRING, 0)
}

func (s *Library_Context) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *Library_Context) AllLibraryRef() []ILibraryRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibraryRefContext)(nil)).Elem())
	var tst = make([]ILibraryRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibraryRefContext)
		}
	}

	return tst
}

func (s *Library_Context) LibraryRef(i int) ILibraryRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibraryRefContext)
}

func (s *Library_Context) AllHelper() []IHelperContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHelperContext)(nil)).Elem())
	var tst = make([]IHelperContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHelperContext)
		}
	}

	return tst
}

func (s *Library_Context) Helper(i int) IHelperContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHelperContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHelperContext)
}

func (s *Library_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterLibrary_(s)
	}
}

func (s *Library_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitLibrary_(s)
	}
}

func (p *ATLParser) Library_() (localctx ILibrary_Context) {
	this := p
	_ = this

	localctx = NewLibrary_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ATLParserRULE_library_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(229)
		p.Match(ATLParserT__6)
	}
	{
		p.SetState(230)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ATLParserSTRING || _la == ATLParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(231)
		p.Match(ATLParserT__1)
	}
	p.SetState(235)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__9 {
		{
			p.SetState(232)
			p.LibraryRef()
		}

		p.SetState(237)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(241)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__10 {
		{
			p.SetState(238)
			p.Helper()
		}

		p.SetState(243)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *QueryContext) STRING() antlr.TerminalNode {
	return s.GetToken(ATLParserSTRING, 0)
}

func (s *QueryContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *QueryContext) AllLibraryRef() []ILibraryRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibraryRefContext)(nil)).Elem())
	var tst = make([]ILibraryRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibraryRefContext)
		}
	}

	return tst
}

func (s *QueryContext) LibraryRef(i int) ILibraryRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibraryRefContext)
}

func (s *QueryContext) AllHelper() []IHelperContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHelperContext)(nil)).Elem())
	var tst = make([]IHelperContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHelperContext)
		}
	}

	return tst
}

func (s *QueryContext) Helper(i int) IHelperContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHelperContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHelperContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *ATLParser) Query() (localctx IQueryContext) {
	this := p
	_ = this

	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ATLParserRULE_query)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(244)
		p.Match(ATLParserT__7)
	}
	{
		p.SetState(245)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ATLParserSTRING || _la == ATLParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(246)
		p.Match(ATLParserT__8)
	}
	{
		p.SetState(247)
		p.OclExpression()
	}
	{
		p.SetState(248)
		p.Match(ATLParserT__1)
	}
	p.SetState(252)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__9 {
		{
			p.SetState(249)
			p.LibraryRef()
		}

		p.SetState(254)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(258)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__10 {
		{
			p.SetState(255)
			p.Helper()
		}

		p.SetState(260)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILibraryRefContext is an interface to support dynamic dispatch.
type ILibraryRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryRefContext differentiates from other interfaces.
	IsLibraryRefContext()
}

type LibraryRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryRefContext() *LibraryRefContext {
	var p = new(LibraryRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_libraryRef
	return p
}

func (*LibraryRefContext) IsLibraryRefContext() {}

func NewLibraryRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryRefContext {
	var p = new(LibraryRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_libraryRef

	return p
}

func (s *LibraryRefContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryRefContext) STRING() antlr.TerminalNode {
	return s.GetToken(ATLParserSTRING, 0)
}

func (s *LibraryRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterLibraryRef(s)
	}
}

func (s *LibraryRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitLibraryRef(s)
	}
}

func (p *ATLParser) LibraryRef() (localctx ILibraryRefContext) {
	this := p
	_ = this

	localctx = NewLibraryRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ATLParserRULE_libraryRef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(261)
		p.Match(ATLParserT__9)
	}
	{
		p.SetState(262)
		p.Match(ATLParserSTRING)
	}
	{
		p.SetState(263)
		p.Match(ATLParserT__1)
	}

	return localctx
}

// IModuleElementContext is an interface to support dynamic dispatch.
type IModuleElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleElementContext differentiates from other interfaces.
	IsModuleElementContext()
}

type ModuleElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleElementContext() *ModuleElementContext {
	var p = new(ModuleElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_moduleElement
	return p
}

func (*ModuleElementContext) IsModuleElementContext() {}

func NewModuleElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleElementContext {
	var p = new(ModuleElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_moduleElement

	return p
}

func (s *ModuleElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleElementContext) Helper() IHelperContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHelperContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHelperContext)
}

func (s *ModuleElementContext) Arule() IAruleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAruleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAruleContext)
}

func (s *ModuleElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterModuleElement(s)
	}
}

func (s *ModuleElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitModuleElement(s)
	}
}

func (p *ATLParser) ModuleElement() (localctx IModuleElementContext) {
	this := p
	_ = this

	localctx = NewModuleElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ATLParserRULE_moduleElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(267)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ATLParserT__10:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(265)
			p.Helper()
		}

	case ATLParserT__4, ATLParserT__16, ATLParserT__17, ATLParserT__18, ATLParserT__19, ATLParserT__24, ATLParserT__25, ATLParserT__76:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(266)
			p.Arule()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHelperContext is an interface to support dynamic dispatch.
type IHelperContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHelperContext differentiates from other interfaces.
	IsHelperContext()
}

type HelperContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperContext() *HelperContext {
	var p = new(HelperContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_helper
	return p
}

func (*HelperContext) IsHelperContext() {}

func NewHelperContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperContext {
	var p = new(HelperContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_helper

	return p
}

func (s *HelperContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperContext) OclFeatureDefinition() IOclFeatureDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclFeatureDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclFeatureDefinitionContext)
}

func (s *HelperContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterHelper(s)
	}
}

func (s *HelperContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitHelper(s)
	}
}

func (p *ATLParser) Helper() (localctx IHelperContext) {
	this := p
	_ = this

	localctx = NewHelperContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ATLParserRULE_helper)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(269)
		p.Match(ATLParserT__10)
	}
	{
		p.SetState(270)
		p.OclFeatureDefinition()
	}
	{
		p.SetState(271)
		p.Match(ATLParserT__1)
	}

	return localctx
}

// IOclFeatureDefinitionContext is an interface to support dynamic dispatch.
type IOclFeatureDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOclFeatureDefinitionContext differentiates from other interfaces.
	IsOclFeatureDefinitionContext()
}

type OclFeatureDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOclFeatureDefinitionContext() *OclFeatureDefinitionContext {
	var p = new(OclFeatureDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_oclFeatureDefinition
	return p
}

func (*OclFeatureDefinitionContext) IsOclFeatureDefinitionContext() {}

func NewOclFeatureDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OclFeatureDefinitionContext {
	var p = new(OclFeatureDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_oclFeatureDefinition

	return p
}

func (s *OclFeatureDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *OclFeatureDefinitionContext) OclFeature() IOclFeatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclFeatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclFeatureContext)
}

func (s *OclFeatureDefinitionContext) OclContextDefinition() IOclContextDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclContextDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclContextDefinitionContext)
}

func (s *OclFeatureDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OclFeatureDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OclFeatureDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOclFeatureDefinition(s)
	}
}

func (s *OclFeatureDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOclFeatureDefinition(s)
	}
}

func (p *ATLParser) OclFeatureDefinition() (localctx IOclFeatureDefinitionContext) {
	this := p
	_ = this

	localctx = NewOclFeatureDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ATLParserRULE_oclFeatureDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(274)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__13 {
		{
			p.SetState(273)
			p.OclContextDefinition()
		}

	}
	{
		p.SetState(276)
		p.Match(ATLParserT__11)
	}
	{
		p.SetState(277)
		p.Match(ATLParserT__12)
	}
	{
		p.SetState(278)
		p.OclFeature()
	}

	return localctx
}

// IOclContextDefinitionContext is an interface to support dynamic dispatch.
type IOclContextDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOclContextDefinitionContext differentiates from other interfaces.
	IsOclContextDefinitionContext()
}

type OclContextDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOclContextDefinitionContext() *OclContextDefinitionContext {
	var p = new(OclContextDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_oclContextDefinition
	return p
}

func (*OclContextDefinitionContext) IsOclContextDefinitionContext() {}

func NewOclContextDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OclContextDefinitionContext {
	var p = new(OclContextDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_oclContextDefinition

	return p
}

func (s *OclContextDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *OclContextDefinitionContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *OclContextDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OclContextDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OclContextDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOclContextDefinition(s)
	}
}

func (s *OclContextDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOclContextDefinition(s)
	}
}

func (p *ATLParser) OclContextDefinition() (localctx IOclContextDefinitionContext) {
	this := p
	_ = this

	localctx = NewOclContextDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ATLParserRULE_oclContextDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(280)
		p.Match(ATLParserT__13)
	}
	{
		p.SetState(281)
		p.OclType()
	}

	return localctx
}

// IOclFeatureContext is an interface to support dynamic dispatch.
type IOclFeatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOclFeatureContext differentiates from other interfaces.
	IsOclFeatureContext()
}

type OclFeatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOclFeatureContext() *OclFeatureContext {
	var p = new(OclFeatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_oclFeature
	return p
}

func (*OclFeatureContext) IsOclFeatureContext() {}

func NewOclFeatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OclFeatureContext {
	var p = new(OclFeatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_oclFeature

	return p
}

func (s *OclFeatureContext) GetParser() antlr.Parser { return s.parser }

func (s *OclFeatureContext) Operation() IOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperationContext)
}

func (s *OclFeatureContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *OclFeatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OclFeatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OclFeatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOclFeature(s)
	}
}

func (s *OclFeatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOclFeature(s)
	}
}

func (p *ATLParser) OclFeature() (localctx IOclFeatureContext) {
	this := p
	_ = this

	localctx = NewOclFeatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ATLParserRULE_oclFeature)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(285)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(283)
			p.Operation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(284)
			p.Attribute()
		}

	}

	return localctx
}

// IOperationContext is an interface to support dynamic dispatch.
type IOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperationContext differentiates from other interfaces.
	IsOperationContext()
}

type OperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperationContext() *OperationContext {
	var p = new(OperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_operation
	return p
}

func (*OperationContext) IsOperationContext() {}

func NewOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperationContext {
	var p = new(OperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_operation

	return p
}

func (s *OperationContext) GetParser() antlr.Parser { return s.parser }

func (s *OperationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *OperationContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *OperationContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *OperationContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *OperationContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *OperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOperation(s)
	}
}

func (s *OperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOperation(s)
	}
}

func (p *ATLParser) Operation() (localctx IOperationContext) {
	this := p
	_ = this

	localctx = NewOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ATLParserRULE_operation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(287)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(288)
		p.Match(ATLParserT__14)
	}
	p.SetState(297)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserIDENTIFIER {
		{
			p.SetState(289)
			p.Parameter()
		}
		p.SetState(294)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserT__3 {
			{
				p.SetState(290)
				p.Match(ATLParserT__3)
			}
			{
				p.SetState(291)
				p.Parameter()
			}

			p.SetState(296)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(299)
		p.Match(ATLParserT__15)
	}
	{
		p.SetState(300)
		p.Match(ATLParserT__12)
	}
	{
		p.SetState(301)
		p.OclType()
	}
	{
		p.SetState(302)
		p.Match(ATLParserT__8)
	}
	{
		p.SetState(303)
		p.OclExpression()
	}

	return localctx
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *ParameterContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (p *ATLParser) Parameter() (localctx IParameterContext) {
	this := p
	_ = this

	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ATLParserRULE_parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(305)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(306)
		p.Match(ATLParserT__12)
	}
	{
		p.SetState(307)
		p.OclType()
	}

	return localctx
}

// IAttributeContext is an interface to support dynamic dispatch.
type IAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeContext differentiates from other interfaces.
	IsAttributeContext()
}

type AttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeContext() *AttributeContext {
	var p = new(AttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_attribute
	return p
}

func (*AttributeContext) IsAttributeContext() {}

func NewAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeContext {
	var p = new(AttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_attribute

	return p
}

func (s *AttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *AttributeContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *AttributeContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *AttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterAttribute(s)
	}
}

func (s *AttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitAttribute(s)
	}
}

func (p *ATLParser) Attribute() (localctx IAttributeContext) {
	this := p
	_ = this

	localctx = NewAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ATLParserRULE_attribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(309)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(310)
		p.Match(ATLParserT__12)
	}
	{
		p.SetState(311)
		p.OclType()
	}
	{
		p.SetState(312)
		p.Match(ATLParserT__8)
	}
	{
		p.SetState(313)
		p.OclExpression()
	}

	return localctx
}

// IAruleContext is an interface to support dynamic dispatch.
type IAruleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAruleContext differentiates from other interfaces.
	IsAruleContext()
}

type AruleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAruleContext() *AruleContext {
	var p = new(AruleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_arule
	return p
}

func (*AruleContext) IsAruleContext() {}

func NewAruleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AruleContext {
	var p = new(AruleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_arule

	return p
}

func (s *AruleContext) GetParser() antlr.Parser { return s.parser }

func (s *AruleContext) CalledRule() ICalledRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICalledRuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICalledRuleContext)
}

func (s *AruleContext) MatchedRule() IMatchedRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMatchedRuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMatchedRuleContext)
}

func (s *AruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AruleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterArule(s)
	}
}

func (s *AruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitArule(s)
	}
}

func (p *ATLParser) Arule() (localctx IAruleContext) {
	this := p
	_ = this

	localctx = NewAruleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ATLParserRULE_arule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(317)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(315)
			p.CalledRule()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(316)
			p.MatchedRule()
		}

	}

	return localctx
}

// IMatchedRuleContext is an interface to support dynamic dispatch.
type IMatchedRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatchedRuleContext differentiates from other interfaces.
	IsMatchedRuleContext()
}

type MatchedRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchedRuleContext() *MatchedRuleContext {
	var p = new(MatchedRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_matchedRule
	return p
}

func (*MatchedRuleContext) IsMatchedRuleContext() {}

func NewMatchedRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchedRuleContext {
	var p = new(MatchedRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_matchedRule

	return p
}

func (s *MatchedRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchedRuleContext) LazyMatchedRule() ILazyMatchedRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILazyMatchedRuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILazyMatchedRuleContext)
}

func (s *MatchedRuleContext) MatchedRule_abstractContents() IMatchedRule_abstractContentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMatchedRule_abstractContentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMatchedRule_abstractContentsContext)
}

func (s *MatchedRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchedRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchedRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterMatchedRule(s)
	}
}

func (s *MatchedRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitMatchedRule(s)
	}
}

func (p *ATLParser) MatchedRule() (localctx IMatchedRuleContext) {
	this := p
	_ = this

	localctx = NewMatchedRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ATLParserRULE_matchedRule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(321)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ATLParserT__16, ATLParserT__17:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(319)
			p.LazyMatchedRule()
		}

	case ATLParserT__4, ATLParserT__18, ATLParserT__19, ATLParserT__76:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(320)
			p.MatchedRule_abstractContents()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILazyMatchedRuleContext is an interface to support dynamic dispatch.
type ILazyMatchedRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLazyMatchedRuleContext differentiates from other interfaces.
	IsLazyMatchedRuleContext()
}

type LazyMatchedRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLazyMatchedRuleContext() *LazyMatchedRuleContext {
	var p = new(LazyMatchedRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_lazyMatchedRule
	return p
}

func (*LazyMatchedRuleContext) IsLazyMatchedRuleContext() {}

func NewLazyMatchedRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LazyMatchedRuleContext {
	var p = new(LazyMatchedRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_lazyMatchedRule

	return p
}

func (s *LazyMatchedRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *LazyMatchedRuleContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ATLParserIDENTIFIER)
}

func (s *LazyMatchedRuleContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, i)
}

func (s *LazyMatchedRuleContext) InPattern() IInPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInPatternContext)
}

func (s *LazyMatchedRuleContext) OutPattern() IOutPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutPatternContext)
}

func (s *LazyMatchedRuleContext) ActionBlock() IActionBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActionBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActionBlockContext)
}

func (s *LazyMatchedRuleContext) AllRuleVariableDeclaration() []IRuleVariableDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRuleVariableDeclarationContext)(nil)).Elem())
	var tst = make([]IRuleVariableDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRuleVariableDeclarationContext)
		}
	}

	return tst
}

func (s *LazyMatchedRuleContext) RuleVariableDeclaration(i int) IRuleVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRuleVariableDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRuleVariableDeclarationContext)
}

func (s *LazyMatchedRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LazyMatchedRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LazyMatchedRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterLazyMatchedRule(s)
	}
}

func (s *LazyMatchedRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitLazyMatchedRule(s)
	}
}

func (p *ATLParser) LazyMatchedRule() (localctx ILazyMatchedRuleContext) {
	this := p
	_ = this

	localctx = NewLazyMatchedRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ATLParserRULE_lazyMatchedRule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__16 {
		{
			p.SetState(323)
			p.Match(ATLParserT__16)
		}

	}
	{
		p.SetState(326)
		p.Match(ATLParserT__17)
	}
	p.SetState(328)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__18 {
		{
			p.SetState(327)
			p.Match(ATLParserT__18)
		}

	}
	p.SetState(331)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__4 {
		{
			p.SetState(330)
			p.Match(ATLParserT__4)
		}

	}
	{
		p.SetState(333)
		p.Match(ATLParserT__19)
	}
	{
		p.SetState(334)
		p.Match(ATLParserIDENTIFIER)
	}
	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__20 {
		{
			p.SetState(335)
			p.Match(ATLParserT__20)
		}
		{
			p.SetState(336)
			p.Match(ATLParserIDENTIFIER)
		}

	}
	{
		p.SetState(339)
		p.Match(ATLParserT__21)
	}
	{
		p.SetState(340)
		p.InPattern()
	}
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__22 {
		{
			p.SetState(341)
			p.Match(ATLParserT__22)
		}
		{
			p.SetState(342)
			p.Match(ATLParserT__21)
		}
		p.SetState(346)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserIDENTIFIER {
			{
				p.SetState(343)
				p.RuleVariableDeclaration()
			}

			p.SetState(348)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(349)
			p.Match(ATLParserT__23)
		}

	}
	p.SetState(353)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__27 {
		{
			p.SetState(352)
			p.OutPattern()
		}

	}
	p.SetState(356)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__32 {
		{
			p.SetState(355)
			p.ActionBlock()
		}

	}
	{
		p.SetState(358)
		p.Match(ATLParserT__23)
	}

	return localctx
}

// IRuleVariableDeclarationContext is an interface to support dynamic dispatch.
type IRuleVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleVariableDeclarationContext differentiates from other interfaces.
	IsRuleVariableDeclarationContext()
}

type RuleVariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleVariableDeclarationContext() *RuleVariableDeclarationContext {
	var p = new(RuleVariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_ruleVariableDeclaration
	return p
}

func (*RuleVariableDeclarationContext) IsRuleVariableDeclarationContext() {}

func NewRuleVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleVariableDeclarationContext {
	var p = new(RuleVariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_ruleVariableDeclaration

	return p
}

func (s *RuleVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleVariableDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *RuleVariableDeclarationContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *RuleVariableDeclarationContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *RuleVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterRuleVariableDeclaration(s)
	}
}

func (s *RuleVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitRuleVariableDeclaration(s)
	}
}

func (p *ATLParser) RuleVariableDeclaration() (localctx IRuleVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewRuleVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ATLParserRULE_ruleVariableDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(360)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(361)
		p.Match(ATLParserT__12)
	}
	{
		p.SetState(362)
		p.OclType()
	}
	{
		p.SetState(363)
		p.Match(ATLParserT__8)
	}
	{
		p.SetState(364)
		p.OclExpression()
	}
	{
		p.SetState(365)
		p.Match(ATLParserT__1)
	}

	return localctx
}

// ICalledRuleContext is an interface to support dynamic dispatch.
type ICalledRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCalledRuleContext differentiates from other interfaces.
	IsCalledRuleContext()
}

type CalledRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCalledRuleContext() *CalledRuleContext {
	var p = new(CalledRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_calledRule
	return p
}

func (*CalledRuleContext) IsCalledRuleContext() {}

func NewCalledRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CalledRuleContext {
	var p = new(CalledRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_calledRule

	return p
}

func (s *CalledRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *CalledRuleContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *CalledRuleContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *CalledRuleContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *CalledRuleContext) OutPattern() IOutPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutPatternContext)
}

func (s *CalledRuleContext) ActionBlock() IActionBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActionBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActionBlockContext)
}

func (s *CalledRuleContext) AllRuleVariableDeclaration() []IRuleVariableDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRuleVariableDeclarationContext)(nil)).Elem())
	var tst = make([]IRuleVariableDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRuleVariableDeclarationContext)
		}
	}

	return tst
}

func (s *CalledRuleContext) RuleVariableDeclaration(i int) IRuleVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRuleVariableDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRuleVariableDeclarationContext)
}

func (s *CalledRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CalledRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CalledRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterCalledRule(s)
	}
}

func (s *CalledRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitCalledRule(s)
	}
}

func (p *ATLParser) CalledRule() (localctx ICalledRuleContext) {
	this := p
	_ = this

	localctx = NewCalledRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ATLParserRULE_calledRule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__24 {
		{
			p.SetState(367)
			p.Match(ATLParserT__24)
		}

	}
	p.SetState(371)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__25 {
		{
			p.SetState(370)
			p.Match(ATLParserT__25)
		}

	}
	{
		p.SetState(373)
		p.Match(ATLParserT__19)
	}
	{
		p.SetState(374)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(375)
		p.Match(ATLParserT__14)
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserIDENTIFIER {
		{
			p.SetState(376)
			p.Parameter()
		}
		p.SetState(381)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserT__3 {
			{
				p.SetState(377)
				p.Match(ATLParserT__3)
			}
			{
				p.SetState(378)
				p.Parameter()
			}

			p.SetState(383)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(386)
		p.Match(ATLParserT__15)
	}
	{
		p.SetState(387)
		p.Match(ATLParserT__21)
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__22 {
		{
			p.SetState(388)
			p.Match(ATLParserT__22)
		}
		{
			p.SetState(389)
			p.Match(ATLParserT__21)
		}
		p.SetState(393)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserIDENTIFIER {
			{
				p.SetState(390)
				p.RuleVariableDeclaration()
			}

			p.SetState(395)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(396)
			p.Match(ATLParserT__23)
		}

	}
	p.SetState(400)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__27 {
		{
			p.SetState(399)
			p.OutPattern()
		}

	}
	p.SetState(403)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__32 {
		{
			p.SetState(402)
			p.ActionBlock()
		}

	}
	{
		p.SetState(405)
		p.Match(ATLParserT__23)
	}

	return localctx
}

// IInPatternContext is an interface to support dynamic dispatch.
type IInPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInPatternContext differentiates from other interfaces.
	IsInPatternContext()
}

type InPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInPatternContext() *InPatternContext {
	var p = new(InPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_inPattern
	return p
}

func (*InPatternContext) IsInPatternContext() {}

func NewInPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InPatternContext {
	var p = new(InPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_inPattern

	return p
}

func (s *InPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *InPatternContext) AllInPatternElement() []IInPatternElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInPatternElementContext)(nil)).Elem())
	var tst = make([]IInPatternElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInPatternElementContext)
		}
	}

	return tst
}

func (s *InPatternContext) InPatternElement(i int) IInPatternElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInPatternElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInPatternElementContext)
}

func (s *InPatternContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *InPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterInPattern(s)
	}
}

func (s *InPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitInPattern(s)
	}
}

func (p *ATLParser) InPattern() (localctx IInPatternContext) {
	this := p
	_ = this

	localctx = NewInPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ATLParserRULE_inPattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(407)
		p.Match(ATLParserT__5)
	}
	{
		p.SetState(408)
		p.InPatternElement()
	}
	p.SetState(413)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__3 {
		{
			p.SetState(409)
			p.Match(ATLParserT__3)
		}
		{
			p.SetState(410)
			p.InPatternElement()
		}

		p.SetState(415)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__14 {
		{
			p.SetState(416)
			p.Match(ATLParserT__14)
		}
		{
			p.SetState(417)
			p.OclExpression()
		}
		{
			p.SetState(418)
			p.Match(ATLParserT__15)
		}

	}

	return localctx
}

// IInPatternElementContext is an interface to support dynamic dispatch.
type IInPatternElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInPatternElementContext differentiates from other interfaces.
	IsInPatternElementContext()
}

type InPatternElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInPatternElementContext() *InPatternElementContext {
	var p = new(InPatternElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_inPatternElement
	return p
}

func (*InPatternElementContext) IsInPatternElementContext() {}

func NewInPatternElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InPatternElementContext {
	var p = new(InPatternElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_inPatternElement

	return p
}

func (s *InPatternElementContext) GetParser() antlr.Parser { return s.parser }

func (s *InPatternElementContext) SimpleInPatternElement() ISimpleInPatternElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleInPatternElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleInPatternElementContext)
}

func (s *InPatternElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InPatternElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InPatternElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterInPatternElement(s)
	}
}

func (s *InPatternElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitInPatternElement(s)
	}
}

func (p *ATLParser) InPatternElement() (localctx IInPatternElementContext) {
	this := p
	_ = this

	localctx = NewInPatternElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ATLParserRULE_inPatternElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(422)
		p.SimpleInPatternElement()
	}

	return localctx
}

// ISimpleInPatternElementContext is an interface to support dynamic dispatch.
type ISimpleInPatternElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleInPatternElementContext differentiates from other interfaces.
	IsSimpleInPatternElementContext()
}

type SimpleInPatternElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleInPatternElementContext() *SimpleInPatternElementContext {
	var p = new(SimpleInPatternElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_simpleInPatternElement
	return p
}

func (*SimpleInPatternElementContext) IsSimpleInPatternElementContext() {}

func NewSimpleInPatternElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleInPatternElementContext {
	var p = new(SimpleInPatternElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_simpleInPatternElement

	return p
}

func (s *SimpleInPatternElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleInPatternElementContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ATLParserIDENTIFIER)
}

func (s *SimpleInPatternElementContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, i)
}

func (s *SimpleInPatternElementContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *SimpleInPatternElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleInPatternElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleInPatternElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterSimpleInPatternElement(s)
	}
}

func (s *SimpleInPatternElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitSimpleInPatternElement(s)
	}
}

func (p *ATLParser) SimpleInPatternElement() (localctx ISimpleInPatternElementContext) {
	this := p
	_ = this

	localctx = NewSimpleInPatternElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ATLParserRULE_simpleInPatternElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(425)
		p.Match(ATLParserT__12)
	}
	{
		p.SetState(426)
		p.OclType()
	}
	p.SetState(436)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__26 {
		{
			p.SetState(427)
			p.Match(ATLParserT__26)
		}
		{
			p.SetState(428)
			p.Match(ATLParserIDENTIFIER)
		}
		p.SetState(433)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(429)
					p.Match(ATLParserT__3)
				}
				{
					p.SetState(430)
					p.Match(ATLParserIDENTIFIER)
				}

			}
			p.SetState(435)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IOutPatternContext is an interface to support dynamic dispatch.
type IOutPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutPatternContext differentiates from other interfaces.
	IsOutPatternContext()
}

type OutPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutPatternContext() *OutPatternContext {
	var p = new(OutPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_outPattern
	return p
}

func (*OutPatternContext) IsOutPatternContext() {}

func NewOutPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutPatternContext {
	var p = new(OutPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_outPattern

	return p
}

func (s *OutPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *OutPatternContext) AllOutPatternElement() []IOutPatternElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOutPatternElementContext)(nil)).Elem())
	var tst = make([]IOutPatternElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOutPatternElementContext)
		}
	}

	return tst
}

func (s *OutPatternContext) OutPatternElement(i int) IOutPatternElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutPatternElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOutPatternElementContext)
}

func (s *OutPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOutPattern(s)
	}
}

func (s *OutPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOutPattern(s)
	}
}

func (p *ATLParser) OutPattern() (localctx IOutPatternContext) {
	this := p
	_ = this

	localctx = NewOutPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ATLParserRULE_outPattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(438)
		p.Match(ATLParserT__27)
	}
	{
		p.SetState(439)
		p.OutPatternElement()
	}
	p.SetState(444)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__3 {
		{
			p.SetState(440)
			p.Match(ATLParserT__3)
		}
		{
			p.SetState(441)
			p.OutPatternElement()
		}

		p.SetState(446)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOutPatternElementContext is an interface to support dynamic dispatch.
type IOutPatternElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutPatternElementContext differentiates from other interfaces.
	IsOutPatternElementContext()
}

type OutPatternElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutPatternElementContext() *OutPatternElementContext {
	var p = new(OutPatternElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_outPatternElement
	return p
}

func (*OutPatternElementContext) IsOutPatternElementContext() {}

func NewOutPatternElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutPatternElementContext {
	var p = new(OutPatternElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_outPatternElement

	return p
}

func (s *OutPatternElementContext) GetParser() antlr.Parser { return s.parser }

func (s *OutPatternElementContext) SimpleOutPatternElement() ISimpleOutPatternElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleOutPatternElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleOutPatternElementContext)
}

func (s *OutPatternElementContext) ForEachOutPatternElement() IForEachOutPatternElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForEachOutPatternElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForEachOutPatternElementContext)
}

func (s *OutPatternElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutPatternElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutPatternElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOutPatternElement(s)
	}
}

func (s *OutPatternElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOutPatternElement(s)
	}
}

func (p *ATLParser) OutPatternElement() (localctx IOutPatternElementContext) {
	this := p
	_ = this

	localctx = NewOutPatternElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ATLParserRULE_outPatternElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(449)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(447)
			p.SimpleOutPatternElement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(448)
			p.ForEachOutPatternElement()
		}

	}

	return localctx
}

// ISimpleOutPatternElementContext is an interface to support dynamic dispatch.
type ISimpleOutPatternElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleOutPatternElementContext differentiates from other interfaces.
	IsSimpleOutPatternElementContext()
}

type SimpleOutPatternElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleOutPatternElementContext() *SimpleOutPatternElementContext {
	var p = new(SimpleOutPatternElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_simpleOutPatternElement
	return p
}

func (*SimpleOutPatternElementContext) IsSimpleOutPatternElementContext() {}

func NewSimpleOutPatternElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleOutPatternElementContext {
	var p = new(SimpleOutPatternElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_simpleOutPatternElement

	return p
}

func (s *SimpleOutPatternElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleOutPatternElementContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ATLParserIDENTIFIER)
}

func (s *SimpleOutPatternElementContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, i)
}

func (s *SimpleOutPatternElementContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *SimpleOutPatternElementContext) AllBinding() []IBindingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBindingContext)(nil)).Elem())
	var tst = make([]IBindingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBindingContext)
		}
	}

	return tst
}

func (s *SimpleOutPatternElementContext) Binding(i int) IBindingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBindingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBindingContext)
}

func (s *SimpleOutPatternElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleOutPatternElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleOutPatternElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterSimpleOutPatternElement(s)
	}
}

func (s *SimpleOutPatternElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitSimpleOutPatternElement(s)
	}
}

func (p *ATLParser) SimpleOutPatternElement() (localctx ISimpleOutPatternElementContext) {
	this := p
	_ = this

	localctx = NewSimpleOutPatternElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ATLParserRULE_simpleOutPatternElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(452)
		p.Match(ATLParserT__12)
	}
	{
		p.SetState(453)
		p.OclType()
	}
	p.SetState(456)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__26 {
		{
			p.SetState(454)
			p.Match(ATLParserT__26)
		}
		{
			p.SetState(455)
			p.Match(ATLParserIDENTIFIER)
		}

	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__28 {
		{
			p.SetState(458)
			p.Match(ATLParserT__28)
		}
		{
			p.SetState(459)
			p.Match(ATLParserIDENTIFIER)
		}

	}
	p.SetState(474)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__14 {
		{
			p.SetState(462)
			p.Match(ATLParserT__14)
		}
		p.SetState(471)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ATLParserIDENTIFIER {
			{
				p.SetState(463)
				p.Binding()
			}
			p.SetState(468)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == ATLParserT__3 {
				{
					p.SetState(464)
					p.Match(ATLParserT__3)
				}
				{
					p.SetState(465)
					p.Binding()
				}

				p.SetState(470)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(473)
			p.Match(ATLParserT__15)
		}

	}

	return localctx
}

// IForEachOutPatternElementContext is an interface to support dynamic dispatch.
type IForEachOutPatternElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForEachOutPatternElementContext differentiates from other interfaces.
	IsForEachOutPatternElementContext()
}

type ForEachOutPatternElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForEachOutPatternElementContext() *ForEachOutPatternElementContext {
	var p = new(ForEachOutPatternElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_forEachOutPatternElement
	return p
}

func (*ForEachOutPatternElementContext) IsForEachOutPatternElementContext() {}

func NewForEachOutPatternElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForEachOutPatternElementContext {
	var p = new(ForEachOutPatternElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_forEachOutPatternElement

	return p
}

func (s *ForEachOutPatternElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForEachOutPatternElementContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ATLParserIDENTIFIER)
}

func (s *ForEachOutPatternElementContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, i)
}

func (s *ForEachOutPatternElementContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *ForEachOutPatternElementContext) Iterator() IIteratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIteratorContext)
}

func (s *ForEachOutPatternElementContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *ForEachOutPatternElementContext) AllBinding() []IBindingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBindingContext)(nil)).Elem())
	var tst = make([]IBindingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBindingContext)
		}
	}

	return tst
}

func (s *ForEachOutPatternElementContext) Binding(i int) IBindingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBindingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBindingContext)
}

func (s *ForEachOutPatternElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForEachOutPatternElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForEachOutPatternElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterForEachOutPatternElement(s)
	}
}

func (s *ForEachOutPatternElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitForEachOutPatternElement(s)
	}
}

func (p *ATLParser) ForEachOutPatternElement() (localctx IForEachOutPatternElementContext) {
	this := p
	_ = this

	localctx = NewForEachOutPatternElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ATLParserRULE_forEachOutPatternElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(476)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(477)
		p.Match(ATLParserT__12)
	}
	{
		p.SetState(478)
		p.Match(ATLParserT__29)
	}
	{
		p.SetState(479)
		p.OclType()
	}
	{
		p.SetState(480)
		p.Match(ATLParserT__30)
	}
	{
		p.SetState(481)
		p.Match(ATLParserT__14)
	}
	{
		p.SetState(482)
		p.Iterator()
	}
	{
		p.SetState(483)
		p.Match(ATLParserT__26)
	}
	{
		p.SetState(484)
		p.OclExpression()
	}
	{
		p.SetState(485)
		p.Match(ATLParserT__15)
	}
	p.SetState(488)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__28 {
		{
			p.SetState(486)
			p.Match(ATLParserT__28)
		}
		{
			p.SetState(487)
			p.Match(ATLParserIDENTIFIER)
		}

	}
	p.SetState(502)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__14 {
		{
			p.SetState(490)
			p.Match(ATLParserT__14)
		}
		p.SetState(499)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ATLParserIDENTIFIER {
			{
				p.SetState(491)
				p.Binding()
			}
			p.SetState(496)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == ATLParserT__3 {
				{
					p.SetState(492)
					p.Match(ATLParserT__3)
				}
				{
					p.SetState(493)
					p.Binding()
				}

				p.SetState(498)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(501)
			p.Match(ATLParserT__15)
		}

	}

	return localctx
}

// IBindingContext is an interface to support dynamic dispatch.
type IBindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBindingContext differentiates from other interfaces.
	IsBindingContext()
}

type BindingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingContext() *BindingContext {
	var p = new(BindingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_binding
	return p
}

func (*BindingContext) IsBindingContext() {}

func NewBindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingContext {
	var p = new(BindingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_binding

	return p
}

func (s *BindingContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *BindingContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *BindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterBinding(s)
	}
}

func (s *BindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitBinding(s)
	}
}

func (p *ATLParser) Binding() (localctx IBindingContext) {
	this := p
	_ = this

	localctx = NewBindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ATLParserRULE_binding)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(504)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(505)
		p.Match(ATLParserT__31)
	}
	{
		p.SetState(506)
		p.OclExpression()
	}

	return localctx
}

// IActionBlockContext is an interface to support dynamic dispatch.
type IActionBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActionBlockContext differentiates from other interfaces.
	IsActionBlockContext()
}

type ActionBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActionBlockContext() *ActionBlockContext {
	var p = new(ActionBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_actionBlock
	return p
}

func (*ActionBlockContext) IsActionBlockContext() {}

func NewActionBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActionBlockContext {
	var p = new(ActionBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_actionBlock

	return p
}

func (s *ActionBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ActionBlockContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *ActionBlockContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ActionBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActionBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActionBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterActionBlock(s)
	}
}

func (s *ActionBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitActionBlock(s)
	}
}

func (p *ATLParser) ActionBlock() (localctx IActionBlockContext) {
	this := p
	_ = this

	localctx = NewActionBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ATLParserRULE_actionBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(508)
		p.Match(ATLParserT__32)
	}
	{
		p.SetState(509)
		p.Match(ATLParserT__21)
	}
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__14 || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(ATLParserT__33-34))|(1<<(ATLParserT__35-34))|(1<<(ATLParserT__39-34))|(1<<(ATLParserT__40-34))|(1<<(ATLParserT__41-34))|(1<<(ATLParserT__44-34))|(1<<(ATLParserT__45-34))|(1<<(ATLParserT__46-34))|(1<<(ATLParserT__47-34))|(1<<(ATLParserT__48-34))|(1<<(ATLParserT__49-34))|(1<<(ATLParserT__50-34))|(1<<(ATLParserT__51-34))|(1<<(ATLParserT__52-34))|(1<<(ATLParserT__53-34))|(1<<(ATLParserT__54-34))|(1<<(ATLParserT__55-34))|(1<<(ATLParserT__56-34))|(1<<(ATLParserT__57-34))|(1<<(ATLParserT__60-34))|(1<<(ATLParserT__61-34)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(ATLParserT__77-78))|(1<<(ATLParserT__78-78))|(1<<(ATLParserT__79-78))|(1<<(ATLParserSTRING-78))|(1<<(ATLParserINTEGER-78))|(1<<(ATLParserFLOAT-78))|(1<<(ATLParserIDENTIFIER-78)))) != 0) {
		{
			p.SetState(510)
			p.Statement()
		}

		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(516)
		p.Match(ATLParserT__23)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) IfStat() IIfStatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfStatContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfStatContext)
}

func (s *StatementContext) ExpressionStat() IExpressionStatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionStatContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionStatContext)
}

func (s *StatementContext) BindingStat() IBindingStatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBindingStatContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBindingStatContext)
}

func (s *StatementContext) ForStat() IForStatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForStatContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForStatContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *ATLParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ATLParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(522)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(518)
			p.IfStat()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(519)
			p.ExpressionStat()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(520)
			p.BindingStat()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(521)
			p.ForStat()
		}

	}

	return localctx
}

// IBindingStatContext is an interface to support dynamic dispatch.
type IBindingStatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBindingStatContext differentiates from other interfaces.
	IsBindingStatContext()
}

type BindingStatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingStatContext() *BindingStatContext {
	var p = new(BindingStatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_bindingStat
	return p
}

func (*BindingStatContext) IsBindingStatContext() {}

func NewBindingStatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingStatContext {
	var p = new(BindingStatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_bindingStat

	return p
}

func (s *BindingStatContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingStatContext) AllOclExpression() []IOclExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem())
	var tst = make([]IOclExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOclExpressionContext)
		}
	}

	return tst
}

func (s *BindingStatContext) OclExpression(i int) IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *BindingStatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingStatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingStatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterBindingStat(s)
	}
}

func (s *BindingStatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitBindingStat(s)
	}
}

func (p *ATLParser) BindingStat() (localctx IBindingStatContext) {
	this := p
	_ = this

	localctx = NewBindingStatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ATLParserRULE_bindingStat)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(524)
		p.OclExpression()
	}
	{
		p.SetState(525)
		p.Match(ATLParserT__31)
	}
	{
		p.SetState(526)
		p.OclExpression()
	}
	{
		p.SetState(527)
		p.Match(ATLParserT__1)
	}

	return localctx
}

// IExpressionStatContext is an interface to support dynamic dispatch.
type IExpressionStatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatContext differentiates from other interfaces.
	IsExpressionStatContext()
}

type ExpressionStatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatContext() *ExpressionStatContext {
	var p = new(ExpressionStatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_expressionStat
	return p
}

func (*ExpressionStatContext) IsExpressionStatContext() {}

func NewExpressionStatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatContext {
	var p = new(ExpressionStatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_expressionStat

	return p
}

func (s *ExpressionStatContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *ExpressionStatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterExpressionStat(s)
	}
}

func (s *ExpressionStatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitExpressionStat(s)
	}
}

func (p *ATLParser) ExpressionStat() (localctx IExpressionStatContext) {
	this := p
	_ = this

	localctx = NewExpressionStatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ATLParserRULE_expressionStat)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(529)
		p.OclExpression()
	}
	{
		p.SetState(530)
		p.Match(ATLParserT__1)
	}

	return localctx
}

// IIfStatContext is an interface to support dynamic dispatch.
type IIfStatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfStatContext differentiates from other interfaces.
	IsIfStatContext()
}

type IfStatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatContext() *IfStatContext {
	var p = new(IfStatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_ifStat
	return p
}

func (*IfStatContext) IsIfStatContext() {}

func NewIfStatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatContext {
	var p = new(IfStatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_ifStat

	return p
}

func (s *IfStatContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *IfStatContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *IfStatContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterIfStat(s)
	}
}

func (s *IfStatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitIfStat(s)
	}
}

func (p *ATLParser) IfStat() (localctx IIfStatContext) {
	this := p
	_ = this

	localctx = NewIfStatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ATLParserRULE_ifStat)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(532)
		p.Match(ATLParserT__33)
	}
	{
		p.SetState(533)
		p.Match(ATLParserT__14)
	}
	{
		p.SetState(534)
		p.OclExpression()
	}
	{
		p.SetState(535)
		p.Match(ATLParserT__15)
	}
	p.SetState(545)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ATLParserT__14, ATLParserT__33, ATLParserT__35, ATLParserT__39, ATLParserT__40, ATLParserT__41, ATLParserT__44, ATLParserT__45, ATLParserT__46, ATLParserT__47, ATLParserT__48, ATLParserT__49, ATLParserT__50, ATLParserT__51, ATLParserT__52, ATLParserT__53, ATLParserT__54, ATLParserT__55, ATLParserT__56, ATLParserT__57, ATLParserT__60, ATLParserT__61, ATLParserT__77, ATLParserT__78, ATLParserT__79, ATLParserSTRING, ATLParserINTEGER, ATLParserFLOAT, ATLParserIDENTIFIER:
		{
			p.SetState(536)
			p.Statement()
		}

	case ATLParserT__21:
		{
			p.SetState(537)
			p.Match(ATLParserT__21)
		}
		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserT__14 || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(ATLParserT__33-34))|(1<<(ATLParserT__35-34))|(1<<(ATLParserT__39-34))|(1<<(ATLParserT__40-34))|(1<<(ATLParserT__41-34))|(1<<(ATLParserT__44-34))|(1<<(ATLParserT__45-34))|(1<<(ATLParserT__46-34))|(1<<(ATLParserT__47-34))|(1<<(ATLParserT__48-34))|(1<<(ATLParserT__49-34))|(1<<(ATLParserT__50-34))|(1<<(ATLParserT__51-34))|(1<<(ATLParserT__52-34))|(1<<(ATLParserT__53-34))|(1<<(ATLParserT__54-34))|(1<<(ATLParserT__55-34))|(1<<(ATLParserT__56-34))|(1<<(ATLParserT__57-34))|(1<<(ATLParserT__60-34))|(1<<(ATLParserT__61-34)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(ATLParserT__77-78))|(1<<(ATLParserT__78-78))|(1<<(ATLParserT__79-78))|(1<<(ATLParserSTRING-78))|(1<<(ATLParserINTEGER-78))|(1<<(ATLParserFLOAT-78))|(1<<(ATLParserIDENTIFIER-78)))) != 0) {
			{
				p.SetState(538)
				p.Statement()
			}

			p.SetState(543)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(544)
			p.Match(ATLParserT__23)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(559)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(547)
			p.Match(ATLParserT__34)
		}
		p.SetState(557)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ATLParserT__14, ATLParserT__33, ATLParserT__35, ATLParserT__39, ATLParserT__40, ATLParserT__41, ATLParserT__44, ATLParserT__45, ATLParserT__46, ATLParserT__47, ATLParserT__48, ATLParserT__49, ATLParserT__50, ATLParserT__51, ATLParserT__52, ATLParserT__53, ATLParserT__54, ATLParserT__55, ATLParserT__56, ATLParserT__57, ATLParserT__60, ATLParserT__61, ATLParserT__77, ATLParserT__78, ATLParserT__79, ATLParserSTRING, ATLParserINTEGER, ATLParserFLOAT, ATLParserIDENTIFIER:
			{
				p.SetState(548)
				p.Statement()
			}

		case ATLParserT__21:
			{
				p.SetState(549)
				p.Match(ATLParserT__21)
			}
			p.SetState(553)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == ATLParserT__14 || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(ATLParserT__33-34))|(1<<(ATLParserT__35-34))|(1<<(ATLParserT__39-34))|(1<<(ATLParserT__40-34))|(1<<(ATLParserT__41-34))|(1<<(ATLParserT__44-34))|(1<<(ATLParserT__45-34))|(1<<(ATLParserT__46-34))|(1<<(ATLParserT__47-34))|(1<<(ATLParserT__48-34))|(1<<(ATLParserT__49-34))|(1<<(ATLParserT__50-34))|(1<<(ATLParserT__51-34))|(1<<(ATLParserT__52-34))|(1<<(ATLParserT__53-34))|(1<<(ATLParserT__54-34))|(1<<(ATLParserT__55-34))|(1<<(ATLParserT__56-34))|(1<<(ATLParserT__57-34))|(1<<(ATLParserT__60-34))|(1<<(ATLParserT__61-34)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(ATLParserT__77-78))|(1<<(ATLParserT__78-78))|(1<<(ATLParserT__79-78))|(1<<(ATLParserSTRING-78))|(1<<(ATLParserINTEGER-78))|(1<<(ATLParserFLOAT-78))|(1<<(ATLParserIDENTIFIER-78)))) != 0) {
				{
					p.SetState(550)
					p.Statement()
				}

				p.SetState(555)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(556)
				p.Match(ATLParserT__23)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IForStatContext is an interface to support dynamic dispatch.
type IForStatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForStatContext differentiates from other interfaces.
	IsForStatContext()
}

type ForStatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatContext() *ForStatContext {
	var p = new(ForStatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_forStat
	return p
}

func (*ForStatContext) IsForStatContext() {}

func NewForStatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatContext {
	var p = new(ForStatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_forStat

	return p
}

func (s *ForStatContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatContext) Iterator() IIteratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIteratorContext)
}

func (s *ForStatContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *ForStatContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *ForStatContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterForStat(s)
	}
}

func (s *ForStatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitForStat(s)
	}
}

func (p *ATLParser) ForStat() (localctx IForStatContext) {
	this := p
	_ = this

	localctx = NewForStatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ATLParserRULE_forStat)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(561)
		p.Match(ATLParserT__35)
	}
	{
		p.SetState(562)
		p.Match(ATLParserT__14)
	}
	{
		p.SetState(563)
		p.Iterator()
	}
	{
		p.SetState(564)
		p.Match(ATLParserT__26)
	}
	{
		p.SetState(565)
		p.OclExpression()
	}
	{
		p.SetState(566)
		p.Match(ATLParserT__15)
	}
	{
		p.SetState(567)
		p.Match(ATLParserT__21)
	}
	p.SetState(571)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__14 || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(ATLParserT__33-34))|(1<<(ATLParserT__35-34))|(1<<(ATLParserT__39-34))|(1<<(ATLParserT__40-34))|(1<<(ATLParserT__41-34))|(1<<(ATLParserT__44-34))|(1<<(ATLParserT__45-34))|(1<<(ATLParserT__46-34))|(1<<(ATLParserT__47-34))|(1<<(ATLParserT__48-34))|(1<<(ATLParserT__49-34))|(1<<(ATLParserT__50-34))|(1<<(ATLParserT__51-34))|(1<<(ATLParserT__52-34))|(1<<(ATLParserT__53-34))|(1<<(ATLParserT__54-34))|(1<<(ATLParserT__55-34))|(1<<(ATLParserT__56-34))|(1<<(ATLParserT__57-34))|(1<<(ATLParserT__60-34))|(1<<(ATLParserT__61-34)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(ATLParserT__77-78))|(1<<(ATLParserT__78-78))|(1<<(ATLParserT__79-78))|(1<<(ATLParserSTRING-78))|(1<<(ATLParserINTEGER-78))|(1<<(ATLParserFLOAT-78))|(1<<(ATLParserIDENTIFIER-78)))) != 0) {
		{
			p.SetState(568)
			p.Statement()
		}

		p.SetState(573)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(574)
		p.Match(ATLParserT__23)
	}

	return localctx
}

// IOclModelContext is an interface to support dynamic dispatch.
type IOclModelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOclModelContext differentiates from other interfaces.
	IsOclModelContext()
}

type OclModelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOclModelContext() *OclModelContext {
	var p = new(OclModelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_oclModel
	return p
}

func (*OclModelContext) IsOclModelContext() {}

func NewOclModelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OclModelContext {
	var p = new(OclModelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_oclModel

	return p
}

func (s *OclModelContext) GetParser() antlr.Parser { return s.parser }

func (s *OclModelContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ATLParserIDENTIFIER)
}

func (s *OclModelContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, i)
}

func (s *OclModelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OclModelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OclModelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOclModel(s)
	}
}

func (s *OclModelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOclModel(s)
	}
}

func (p *ATLParser) OclModel() (localctx IOclModelContext) {
	this := p
	_ = this

	localctx = NewOclModelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ATLParserRULE_oclModel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(576)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(577)
		p.Match(ATLParserT__12)
	}
	{
		p.SetState(578)
		p.Match(ATLParserIDENTIFIER)
	}

	return localctx
}

// IOclModelElementContext is an interface to support dynamic dispatch.
type IOclModelElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOclModelElementContext differentiates from other interfaces.
	IsOclModelElementContext()
}

type OclModelElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOclModelElementContext() *OclModelElementContext {
	var p = new(OclModelElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_oclModelElement
	return p
}

func (*OclModelElementContext) IsOclModelElementContext() {}

func NewOclModelElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OclModelElementContext {
	var p = new(OclModelElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_oclModelElement

	return p
}

func (s *OclModelElementContext) GetParser() antlr.Parser { return s.parser }

func (s *OclModelElementContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ATLParserIDENTIFIER)
}

func (s *OclModelElementContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, i)
}

func (s *OclModelElementContext) STRING() antlr.TerminalNode {
	return s.GetToken(ATLParserSTRING, 0)
}

func (s *OclModelElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OclModelElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OclModelElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOclModelElement(s)
	}
}

func (s *OclModelElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOclModelElement(s)
	}
}

func (p *ATLParser) OclModelElement() (localctx IOclModelElementContext) {
	this := p
	_ = this

	localctx = NewOclModelElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ATLParserRULE_oclModelElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(581)
		p.Match(ATLParserT__36)
	}
	{
		p.SetState(582)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ATLParserSTRING || _la == ATLParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOclExpressionContext is an interface to support dynamic dispatch.
type IOclExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOclExpressionContext differentiates from other interfaces.
	IsOclExpressionContext()
}

type OclExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOclExpressionContext() *OclExpressionContext {
	var p = new(OclExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_oclExpression
	return p
}

func (*OclExpressionContext) IsOclExpressionContext() {}

func NewOclExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OclExpressionContext {
	var p = new(OclExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_oclExpression

	return p
}

func (s *OclExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OclExpressionContext) Priority_5() IPriority_5Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPriority_5Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPriority_5Context)
}

func (s *OclExpressionContext) LetExp() ILetExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILetExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILetExpContext)
}

func (s *OclExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OclExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OclExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOclExpression(s)
	}
}

func (s *OclExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOclExpression(s)
	}
}

func (p *ATLParser) OclExpression() (localctx IOclExpressionContext) {
	this := p
	_ = this

	localctx = NewOclExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ATLParserRULE_oclExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(586)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ATLParserT__14, ATLParserT__33, ATLParserT__39, ATLParserT__40, ATLParserT__41, ATLParserT__44, ATLParserT__46, ATLParserT__47, ATLParserT__48, ATLParserT__49, ATLParserT__50, ATLParserT__51, ATLParserT__52, ATLParserT__53, ATLParserT__54, ATLParserT__55, ATLParserT__56, ATLParserT__57, ATLParserT__60, ATLParserT__61, ATLParserT__77, ATLParserT__78, ATLParserT__79, ATLParserSTRING, ATLParserINTEGER, ATLParserFLOAT, ATLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(584)
			p.Priority_5()
		}

	case ATLParserT__45:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(585)
			p.LetExp()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIteratorExpContext is an interface to support dynamic dispatch.
type IIteratorExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIteratorExpContext differentiates from other interfaces.
	IsIteratorExpContext()
}

type IteratorExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIteratorExpContext() *IteratorExpContext {
	var p = new(IteratorExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_iteratorExp
	return p
}

func (*IteratorExpContext) IsIteratorExpContext() {}

func NewIteratorExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IteratorExpContext {
	var p = new(IteratorExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_iteratorExp

	return p
}

func (s *IteratorExpContext) GetParser() antlr.Parser { return s.parser }

func (s *IteratorExpContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *IteratorExpContext) AllIterator() []IIteratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIteratorContext)(nil)).Elem())
	var tst = make([]IIteratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIteratorContext)
		}
	}

	return tst
}

func (s *IteratorExpContext) Iterator(i int) IIteratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIteratorContext)
}

func (s *IteratorExpContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *IteratorExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IteratorExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IteratorExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterIteratorExp(s)
	}
}

func (s *IteratorExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitIteratorExp(s)
	}
}

func (p *ATLParser) IteratorExp() (localctx IIteratorExpContext) {
	this := p
	_ = this

	localctx = NewIteratorExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ATLParserRULE_iteratorExp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(588)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(589)
		p.Match(ATLParserT__14)
	}
	{
		p.SetState(590)
		p.Iterator()
	}
	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__3 {
		{
			p.SetState(591)
			p.Match(ATLParserT__3)
		}
		{
			p.SetState(592)
			p.Iterator()
		}

		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(598)
		p.Match(ATLParserT__37)
	}
	{
		p.SetState(599)
		p.OclExpression()
	}
	{
		p.SetState(600)
		p.Match(ATLParserT__15)
	}

	return localctx
}

// IIterateExpContext is an interface to support dynamic dispatch.
type IIterateExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIterateExpContext differentiates from other interfaces.
	IsIterateExpContext()
}

type IterateExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterateExpContext() *IterateExpContext {
	var p = new(IterateExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_iterateExp
	return p
}

func (*IterateExpContext) IsIterateExpContext() {}

func NewIterateExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterateExpContext {
	var p = new(IterateExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_iterateExp

	return p
}

func (s *IterateExpContext) GetParser() antlr.Parser { return s.parser }

func (s *IterateExpContext) AllIterator() []IIteratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIteratorContext)(nil)).Elem())
	var tst = make([]IIteratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIteratorContext)
		}
	}

	return tst
}

func (s *IterateExpContext) Iterator(i int) IIteratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIteratorContext)
}

func (s *IterateExpContext) VariableDeclaration() IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *IterateExpContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *IterateExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterateExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IterateExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterIterateExp(s)
	}
}

func (s *IterateExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitIterateExp(s)
	}
}

func (p *ATLParser) IterateExp() (localctx IIterateExpContext) {
	this := p
	_ = this

	localctx = NewIterateExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ATLParserRULE_iterateExp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(602)
		p.Match(ATLParserT__38)
	}
	{
		p.SetState(603)
		p.Match(ATLParserT__14)
	}
	{
		p.SetState(604)
		p.Iterator()
	}
	p.SetState(609)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__3 {
		{
			p.SetState(605)
			p.Match(ATLParserT__3)
		}
		{
			p.SetState(606)
			p.Iterator()
		}

		p.SetState(611)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(612)
		p.Match(ATLParserT__1)
	}
	{
		p.SetState(613)
		p.VariableDeclaration()
	}
	{
		p.SetState(614)
		p.Match(ATLParserT__37)
	}
	{
		p.SetState(615)
		p.OclExpression()
	}
	{
		p.SetState(616)
		p.Match(ATLParserT__15)
	}

	return localctx
}

// ICollectionOperationCallExpContext is an interface to support dynamic dispatch.
type ICollectionOperationCallExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollectionOperationCallExpContext differentiates from other interfaces.
	IsCollectionOperationCallExpContext()
}

type CollectionOperationCallExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionOperationCallExpContext() *CollectionOperationCallExpContext {
	var p = new(CollectionOperationCallExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_collectionOperationCallExp
	return p
}

func (*CollectionOperationCallExpContext) IsCollectionOperationCallExpContext() {}

func NewCollectionOperationCallExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionOperationCallExpContext {
	var p = new(CollectionOperationCallExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_collectionOperationCallExp

	return p
}

func (s *CollectionOperationCallExpContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionOperationCallExpContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *CollectionOperationCallExpContext) AllOclExpression() []IOclExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem())
	var tst = make([]IOclExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOclExpressionContext)
		}
	}

	return tst
}

func (s *CollectionOperationCallExpContext) OclExpression(i int) IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *CollectionOperationCallExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionOperationCallExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionOperationCallExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterCollectionOperationCallExp(s)
	}
}

func (s *CollectionOperationCallExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitCollectionOperationCallExp(s)
	}
}

func (p *ATLParser) CollectionOperationCallExp() (localctx ICollectionOperationCallExpContext) {
	this := p
	_ = this

	localctx = NewCollectionOperationCallExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ATLParserRULE_collectionOperationCallExp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(619)
		p.Match(ATLParserT__14)
	}
	p.SetState(628)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__14 || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(ATLParserT__33-34))|(1<<(ATLParserT__39-34))|(1<<(ATLParserT__40-34))|(1<<(ATLParserT__41-34))|(1<<(ATLParserT__44-34))|(1<<(ATLParserT__45-34))|(1<<(ATLParserT__46-34))|(1<<(ATLParserT__47-34))|(1<<(ATLParserT__48-34))|(1<<(ATLParserT__49-34))|(1<<(ATLParserT__50-34))|(1<<(ATLParserT__51-34))|(1<<(ATLParserT__52-34))|(1<<(ATLParserT__53-34))|(1<<(ATLParserT__54-34))|(1<<(ATLParserT__55-34))|(1<<(ATLParserT__56-34))|(1<<(ATLParserT__57-34))|(1<<(ATLParserT__60-34))|(1<<(ATLParserT__61-34)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(ATLParserT__77-78))|(1<<(ATLParserT__78-78))|(1<<(ATLParserT__79-78))|(1<<(ATLParserSTRING-78))|(1<<(ATLParserINTEGER-78))|(1<<(ATLParserFLOAT-78))|(1<<(ATLParserIDENTIFIER-78)))) != 0) {
		{
			p.SetState(620)
			p.OclExpression()
		}
		p.SetState(625)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserT__3 {
			{
				p.SetState(621)
				p.Match(ATLParserT__3)
			}
			{
				p.SetState(622)
				p.OclExpression()
			}

			p.SetState(627)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(630)
		p.Match(ATLParserT__15)
	}

	return localctx
}

// IOperationCallExpContext is an interface to support dynamic dispatch.
type IOperationCallExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperationCallExpContext differentiates from other interfaces.
	IsOperationCallExpContext()
}

type OperationCallExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperationCallExpContext() *OperationCallExpContext {
	var p = new(OperationCallExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_operationCallExp
	return p
}

func (*OperationCallExpContext) IsOperationCallExpContext() {}

func NewOperationCallExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperationCallExpContext {
	var p = new(OperationCallExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_operationCallExp

	return p
}

func (s *OperationCallExpContext) GetParser() antlr.Parser { return s.parser }

func (s *OperationCallExpContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *OperationCallExpContext) AllOclExpression() []IOclExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem())
	var tst = make([]IOclExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOclExpressionContext)
		}
	}

	return tst
}

func (s *OperationCallExpContext) OclExpression(i int) IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *OperationCallExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperationCallExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperationCallExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOperationCallExp(s)
	}
}

func (s *OperationCallExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOperationCallExp(s)
	}
}

func (p *ATLParser) OperationCallExp() (localctx IOperationCallExpContext) {
	this := p
	_ = this

	localctx = NewOperationCallExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ATLParserRULE_operationCallExp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(632)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(633)
		p.Match(ATLParserT__14)
	}
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__14 || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(ATLParserT__33-34))|(1<<(ATLParserT__39-34))|(1<<(ATLParserT__40-34))|(1<<(ATLParserT__41-34))|(1<<(ATLParserT__44-34))|(1<<(ATLParserT__45-34))|(1<<(ATLParserT__46-34))|(1<<(ATLParserT__47-34))|(1<<(ATLParserT__48-34))|(1<<(ATLParserT__49-34))|(1<<(ATLParserT__50-34))|(1<<(ATLParserT__51-34))|(1<<(ATLParserT__52-34))|(1<<(ATLParserT__53-34))|(1<<(ATLParserT__54-34))|(1<<(ATLParserT__55-34))|(1<<(ATLParserT__56-34))|(1<<(ATLParserT__57-34))|(1<<(ATLParserT__60-34))|(1<<(ATLParserT__61-34)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(ATLParserT__77-78))|(1<<(ATLParserT__78-78))|(1<<(ATLParserT__79-78))|(1<<(ATLParserSTRING-78))|(1<<(ATLParserINTEGER-78))|(1<<(ATLParserFLOAT-78))|(1<<(ATLParserIDENTIFIER-78)))) != 0) {
		{
			p.SetState(634)
			p.OclExpression()
		}
		p.SetState(639)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserT__3 {
			{
				p.SetState(635)
				p.Match(ATLParserT__3)
			}
			{
				p.SetState(636)
				p.OclExpression()
			}

			p.SetState(641)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(644)
		p.Match(ATLParserT__15)
	}

	return localctx
}

// INavigationOrAttributeCallExpContext is an interface to support dynamic dispatch.
type INavigationOrAttributeCallExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNavigationOrAttributeCallExpContext differentiates from other interfaces.
	IsNavigationOrAttributeCallExpContext()
}

type NavigationOrAttributeCallExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNavigationOrAttributeCallExpContext() *NavigationOrAttributeCallExpContext {
	var p = new(NavigationOrAttributeCallExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_navigationOrAttributeCallExp
	return p
}

func (*NavigationOrAttributeCallExpContext) IsNavigationOrAttributeCallExpContext() {}

func NewNavigationOrAttributeCallExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NavigationOrAttributeCallExpContext {
	var p = new(NavigationOrAttributeCallExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_navigationOrAttributeCallExp

	return p
}

func (s *NavigationOrAttributeCallExpContext) GetParser() antlr.Parser { return s.parser }

func (s *NavigationOrAttributeCallExpContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *NavigationOrAttributeCallExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NavigationOrAttributeCallExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NavigationOrAttributeCallExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterNavigationOrAttributeCallExp(s)
	}
}

func (s *NavigationOrAttributeCallExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitNavigationOrAttributeCallExp(s)
	}
}

func (p *ATLParser) NavigationOrAttributeCallExp() (localctx INavigationOrAttributeCallExpContext) {
	this := p
	_ = this

	localctx = NewNavigationOrAttributeCallExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ATLParserRULE_navigationOrAttributeCallExp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(646)
		p.Match(ATLParserIDENTIFIER)
	}

	return localctx
}

// IIteratorContext is an interface to support dynamic dispatch.
type IIteratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIteratorContext differentiates from other interfaces.
	IsIteratorContext()
}

type IteratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIteratorContext() *IteratorContext {
	var p = new(IteratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_iterator
	return p
}

func (*IteratorContext) IsIteratorContext() {}

func NewIteratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IteratorContext {
	var p = new(IteratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_iterator

	return p
}

func (s *IteratorContext) GetParser() antlr.Parser { return s.parser }

func (s *IteratorContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *IteratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IteratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IteratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterIterator(s)
	}
}

func (s *IteratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitIterator(s)
	}
}

func (p *ATLParser) Iterator() (localctx IIteratorContext) {
	this := p
	_ = this

	localctx = NewIteratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ATLParserRULE_iterator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(648)
		p.Match(ATLParserIDENTIFIER)
	}

	return localctx
}

// IOclUndefinedExpContext is an interface to support dynamic dispatch.
type IOclUndefinedExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOclUndefinedExpContext differentiates from other interfaces.
	IsOclUndefinedExpContext()
}

type OclUndefinedExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOclUndefinedExpContext() *OclUndefinedExpContext {
	var p = new(OclUndefinedExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_oclUndefinedExp
	return p
}

func (*OclUndefinedExpContext) IsOclUndefinedExpContext() {}

func NewOclUndefinedExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OclUndefinedExpContext {
	var p = new(OclUndefinedExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_oclUndefinedExp

	return p
}

func (s *OclUndefinedExpContext) GetParser() antlr.Parser { return s.parser }
func (s *OclUndefinedExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OclUndefinedExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OclUndefinedExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOclUndefinedExp(s)
	}
}

func (s *OclUndefinedExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOclUndefinedExp(s)
	}
}

func (p *ATLParser) OclUndefinedExp() (localctx IOclUndefinedExpContext) {
	this := p
	_ = this

	localctx = NewOclUndefinedExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ATLParserRULE_oclUndefinedExp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)
		p.Match(ATLParserT__39)
	}

	return localctx
}

// IPrimitiveExpContext is an interface to support dynamic dispatch.
type IPrimitiveExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveExpContext differentiates from other interfaces.
	IsPrimitiveExpContext()
}

type PrimitiveExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveExpContext() *PrimitiveExpContext {
	var p = new(PrimitiveExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_primitiveExp
	return p
}

func (*PrimitiveExpContext) IsPrimitiveExpContext() {}

func NewPrimitiveExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveExpContext {
	var p = new(PrimitiveExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_primitiveExp

	return p
}

func (s *PrimitiveExpContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveExpContext) NumericExp() INumericExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericExpContext)
}

func (s *PrimitiveExpContext) BooleanExp() IBooleanExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpContext)
}

func (s *PrimitiveExpContext) StringExp() IStringExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringExpContext)
}

func (s *PrimitiveExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterPrimitiveExp(s)
	}
}

func (s *PrimitiveExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitPrimitiveExp(s)
	}
}

func (p *ATLParser) PrimitiveExp() (localctx IPrimitiveExpContext) {
	this := p
	_ = this

	localctx = NewPrimitiveExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ATLParserRULE_primitiveExp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(655)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ATLParserINTEGER, ATLParserFLOAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(652)
			p.NumericExp()
		}

	case ATLParserT__40, ATLParserT__41:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(653)
			p.BooleanExp()
		}

	case ATLParserSTRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(654)
			p.StringExp()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumericExpContext is an interface to support dynamic dispatch.
type INumericExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericExpContext differentiates from other interfaces.
	IsNumericExpContext()
}

type NumericExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericExpContext() *NumericExpContext {
	var p = new(NumericExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_numericExp
	return p
}

func (*NumericExpContext) IsNumericExpContext() {}

func NewNumericExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericExpContext {
	var p = new(NumericExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_numericExp

	return p
}

func (s *NumericExpContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericExpContext) IntegerExp() IIntegerExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerExpContext)
}

func (s *NumericExpContext) RealExp() IRealExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRealExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRealExpContext)
}

func (s *NumericExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterNumericExp(s)
	}
}

func (s *NumericExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitNumericExp(s)
	}
}

func (p *ATLParser) NumericExp() (localctx INumericExpContext) {
	this := p
	_ = this

	localctx = NewNumericExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ATLParserRULE_numericExp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(659)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ATLParserINTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(657)
			p.IntegerExp()
		}

	case ATLParserFLOAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(658)
			p.RealExp()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBooleanExpContext is an interface to support dynamic dispatch.
type IBooleanExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanExpContext differentiates from other interfaces.
	IsBooleanExpContext()
}

type BooleanExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpContext() *BooleanExpContext {
	var p = new(BooleanExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_booleanExp
	return p
}

func (*BooleanExpContext) IsBooleanExpContext() {}

func NewBooleanExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpContext {
	var p = new(BooleanExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_booleanExp

	return p
}

func (s *BooleanExpContext) GetParser() antlr.Parser { return s.parser }
func (s *BooleanExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterBooleanExp(s)
	}
}

func (s *BooleanExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitBooleanExp(s)
	}
}

func (p *ATLParser) BooleanExp() (localctx IBooleanExpContext) {
	this := p
	_ = this

	localctx = NewBooleanExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ATLParserRULE_booleanExp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(661)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ATLParserT__40 || _la == ATLParserT__41) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIntegerExpContext is an interface to support dynamic dispatch.
type IIntegerExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerExpContext differentiates from other interfaces.
	IsIntegerExpContext()
}

type IntegerExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerExpContext() *IntegerExpContext {
	var p = new(IntegerExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_integerExp
	return p
}

func (*IntegerExpContext) IsIntegerExpContext() {}

func NewIntegerExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerExpContext {
	var p = new(IntegerExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_integerExp

	return p
}

func (s *IntegerExpContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerExpContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(ATLParserINTEGER, 0)
}

func (s *IntegerExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterIntegerExp(s)
	}
}

func (s *IntegerExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitIntegerExp(s)
	}
}

func (p *ATLParser) IntegerExp() (localctx IIntegerExpContext) {
	this := p
	_ = this

	localctx = NewIntegerExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ATLParserRULE_integerExp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(663)
		p.Match(ATLParserINTEGER)
	}

	return localctx
}

// IRealExpContext is an interface to support dynamic dispatch.
type IRealExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRealExpContext differentiates from other interfaces.
	IsRealExpContext()
}

type RealExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRealExpContext() *RealExpContext {
	var p = new(RealExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_realExp
	return p
}

func (*RealExpContext) IsRealExpContext() {}

func NewRealExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RealExpContext {
	var p = new(RealExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_realExp

	return p
}

func (s *RealExpContext) GetParser() antlr.Parser { return s.parser }

func (s *RealExpContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(ATLParserFLOAT, 0)
}

func (s *RealExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RealExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RealExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterRealExp(s)
	}
}

func (s *RealExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitRealExp(s)
	}
}

func (p *ATLParser) RealExp() (localctx IRealExpContext) {
	this := p
	_ = this

	localctx = NewRealExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ATLParserRULE_realExp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(665)
		p.Match(ATLParserFLOAT)
	}

	return localctx
}

// IStringExpContext is an interface to support dynamic dispatch.
type IStringExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringExpContext differentiates from other interfaces.
	IsStringExpContext()
}

type StringExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringExpContext() *StringExpContext {
	var p = new(StringExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_stringExp
	return p
}

func (*StringExpContext) IsStringExpContext() {}

func NewStringExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringExpContext {
	var p = new(StringExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_stringExp

	return p
}

func (s *StringExpContext) GetParser() antlr.Parser { return s.parser }

func (s *StringExpContext) STRING() antlr.TerminalNode {
	return s.GetToken(ATLParserSTRING, 0)
}

func (s *StringExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterStringExp(s)
	}
}

func (s *StringExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitStringExp(s)
	}
}

func (p *ATLParser) StringExp() (localctx IStringExpContext) {
	this := p
	_ = this

	localctx = NewStringExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ATLParserRULE_stringExp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		p.Match(ATLParserSTRING)
	}

	return localctx
}

// IIfExpContext is an interface to support dynamic dispatch.
type IIfExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfExpContext differentiates from other interfaces.
	IsIfExpContext()
}

type IfExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExpContext() *IfExpContext {
	var p = new(IfExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_ifExp
	return p
}

func (*IfExpContext) IsIfExpContext() {}

func NewIfExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExpContext {
	var p = new(IfExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_ifExp

	return p
}

func (s *IfExpContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExpContext) AllOclExpression() []IOclExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem())
	var tst = make([]IOclExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOclExpressionContext)
		}
	}

	return tst
}

func (s *IfExpContext) OclExpression(i int) IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *IfExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterIfExp(s)
	}
}

func (s *IfExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitIfExp(s)
	}
}

func (p *ATLParser) IfExp() (localctx IIfExpContext) {
	this := p
	_ = this

	localctx = NewIfExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ATLParserRULE_ifExp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(669)
		p.Match(ATLParserT__33)
	}
	{
		p.SetState(670)
		p.OclExpression()
	}
	{
		p.SetState(671)
		p.Match(ATLParserT__42)
	}
	{
		p.SetState(672)
		p.OclExpression()
	}
	{
		p.SetState(673)
		p.Match(ATLParserT__34)
	}
	{
		p.SetState(674)
		p.OclExpression()
	}
	{
		p.SetState(675)
		p.Match(ATLParserT__43)
	}

	return localctx
}

// IVariableExpContext is an interface to support dynamic dispatch.
type IVariableExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableExpContext differentiates from other interfaces.
	IsVariableExpContext()
}

type VariableExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableExpContext() *VariableExpContext {
	var p = new(VariableExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_variableExp
	return p
}

func (*VariableExpContext) IsVariableExpContext() {}

func NewVariableExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableExpContext {
	var p = new(VariableExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_variableExp

	return p
}

func (s *VariableExpContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableExpContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *VariableExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterVariableExp(s)
	}
}

func (s *VariableExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitVariableExp(s)
	}
}

func (p *ATLParser) VariableExp() (localctx IVariableExpContext) {
	this := p
	_ = this

	localctx = NewVariableExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ATLParserRULE_variableExp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(677)
		p.Match(ATLParserIDENTIFIER)
	}

	return localctx
}

// ISuperExpContext is an interface to support dynamic dispatch.
type ISuperExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuperExpContext differentiates from other interfaces.
	IsSuperExpContext()
}

type SuperExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuperExpContext() *SuperExpContext {
	var p = new(SuperExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_superExp
	return p
}

func (*SuperExpContext) IsSuperExpContext() {}

func NewSuperExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuperExpContext {
	var p = new(SuperExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_superExp

	return p
}

func (s *SuperExpContext) GetParser() antlr.Parser { return s.parser }
func (s *SuperExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuperExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterSuperExp(s)
	}
}

func (s *SuperExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitSuperExp(s)
	}
}

func (p *ATLParser) SuperExp() (localctx ISuperExpContext) {
	this := p
	_ = this

	localctx = NewSuperExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ATLParserRULE_superExp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(679)
		p.Match(ATLParserT__44)
	}

	return localctx
}

// ILetExpContext is an interface to support dynamic dispatch.
type ILetExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLetExpContext differentiates from other interfaces.
	IsLetExpContext()
}

type LetExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetExpContext() *LetExpContext {
	var p = new(LetExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_letExp
	return p
}

func (*LetExpContext) IsLetExpContext() {}

func NewLetExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetExpContext {
	var p = new(LetExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_letExp

	return p
}

func (s *LetExpContext) GetParser() antlr.Parser { return s.parser }

func (s *LetExpContext) VariableDeclaration() IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *LetExpContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *LetExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterLetExp(s)
	}
}

func (s *LetExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitLetExp(s)
	}
}

func (p *ATLParser) LetExp() (localctx ILetExpContext) {
	this := p
	_ = this

	localctx = NewLetExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ATLParserRULE_letExp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(681)
		p.Match(ATLParserT__45)
	}
	{
		p.SetState(682)
		p.VariableDeclaration()
	}
	{
		p.SetState(683)
		p.Match(ATLParserT__26)
	}
	{
		p.SetState(684)
		p.OclExpression()
	}

	return localctx
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_variableDeclaration
	return p
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *VariableDeclarationContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *VariableDeclarationContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (p *ATLParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ATLParserRULE_variableDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(687)
		p.Match(ATLParserT__12)
	}
	{
		p.SetState(688)
		p.OclType()
	}
	{
		p.SetState(689)
		p.Match(ATLParserT__8)
	}
	{
		p.SetState(690)
		p.OclExpression()
	}

	return localctx
}

// IEnumLiteralExpContext is an interface to support dynamic dispatch.
type IEnumLiteralExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumLiteralExpContext differentiates from other interfaces.
	IsEnumLiteralExpContext()
}

type EnumLiteralExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumLiteralExpContext() *EnumLiteralExpContext {
	var p = new(EnumLiteralExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_enumLiteralExp
	return p
}

func (*EnumLiteralExpContext) IsEnumLiteralExpContext() {}

func NewEnumLiteralExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumLiteralExpContext {
	var p = new(EnumLiteralExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_enumLiteralExp

	return p
}

func (s *EnumLiteralExpContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumLiteralExpContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *EnumLiteralExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumLiteralExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumLiteralExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterEnumLiteralExp(s)
	}
}

func (s *EnumLiteralExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitEnumLiteralExp(s)
	}
}

func (p *ATLParser) EnumLiteralExp() (localctx IEnumLiteralExpContext) {
	this := p
	_ = this

	localctx = NewEnumLiteralExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ATLParserRULE_enumLiteralExp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(692)
		p.Match(ATLParserT__46)
	}
	{
		p.SetState(693)
		p.Match(ATLParserIDENTIFIER)
	}

	return localctx
}

// ICollectionExpContext is an interface to support dynamic dispatch.
type ICollectionExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollectionExpContext differentiates from other interfaces.
	IsCollectionExpContext()
}

type CollectionExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionExpContext() *CollectionExpContext {
	var p = new(CollectionExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_collectionExp
	return p
}

func (*CollectionExpContext) IsCollectionExpContext() {}

func NewCollectionExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionExpContext {
	var p = new(CollectionExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_collectionExp

	return p
}

func (s *CollectionExpContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionExpContext) BagExp() IBagExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBagExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBagExpContext)
}

func (s *CollectionExpContext) SetExp() ISetExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetExpContext)
}

func (s *CollectionExpContext) OrderedSetExp() IOrderedSetExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderedSetExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderedSetExpContext)
}

func (s *CollectionExpContext) SequenceExp() ISequenceExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceExpContext)
}

func (s *CollectionExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterCollectionExp(s)
	}
}

func (s *CollectionExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitCollectionExp(s)
	}
}

func (p *ATLParser) CollectionExp() (localctx ICollectionExpContext) {
	this := p
	_ = this

	localctx = NewCollectionExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ATLParserRULE_collectionExp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(699)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ATLParserT__47:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(695)
			p.BagExp()
		}

	case ATLParserT__48:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(696)
			p.SetExp()
		}

	case ATLParserT__49:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(697)
			p.OrderedSetExp()
		}

	case ATLParserT__50:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(698)
			p.SequenceExp()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBagExpContext is an interface to support dynamic dispatch.
type IBagExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBagExpContext differentiates from other interfaces.
	IsBagExpContext()
}

type BagExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBagExpContext() *BagExpContext {
	var p = new(BagExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_bagExp
	return p
}

func (*BagExpContext) IsBagExpContext() {}

func NewBagExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BagExpContext {
	var p = new(BagExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_bagExp

	return p
}

func (s *BagExpContext) GetParser() antlr.Parser { return s.parser }

func (s *BagExpContext) AllOclExpression() []IOclExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem())
	var tst = make([]IOclExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOclExpressionContext)
		}
	}

	return tst
}

func (s *BagExpContext) OclExpression(i int) IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *BagExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BagExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BagExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterBagExp(s)
	}
}

func (s *BagExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitBagExp(s)
	}
}

func (p *ATLParser) BagExp() (localctx IBagExpContext) {
	this := p
	_ = this

	localctx = NewBagExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ATLParserRULE_bagExp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(701)
		p.Match(ATLParserT__47)
	}
	{
		p.SetState(702)
		p.Match(ATLParserT__21)
	}
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__14 || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(ATLParserT__33-34))|(1<<(ATLParserT__39-34))|(1<<(ATLParserT__40-34))|(1<<(ATLParserT__41-34))|(1<<(ATLParserT__44-34))|(1<<(ATLParserT__45-34))|(1<<(ATLParserT__46-34))|(1<<(ATLParserT__47-34))|(1<<(ATLParserT__48-34))|(1<<(ATLParserT__49-34))|(1<<(ATLParserT__50-34))|(1<<(ATLParserT__51-34))|(1<<(ATLParserT__52-34))|(1<<(ATLParserT__53-34))|(1<<(ATLParserT__54-34))|(1<<(ATLParserT__55-34))|(1<<(ATLParserT__56-34))|(1<<(ATLParserT__57-34))|(1<<(ATLParserT__60-34))|(1<<(ATLParserT__61-34)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(ATLParserT__77-78))|(1<<(ATLParserT__78-78))|(1<<(ATLParserT__79-78))|(1<<(ATLParserSTRING-78))|(1<<(ATLParserINTEGER-78))|(1<<(ATLParserFLOAT-78))|(1<<(ATLParserIDENTIFIER-78)))) != 0) {
		{
			p.SetState(703)
			p.OclExpression()
		}
		p.SetState(708)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserT__3 {
			{
				p.SetState(704)
				p.Match(ATLParserT__3)
			}
			{
				p.SetState(705)
				p.OclExpression()
			}

			p.SetState(710)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(713)
		p.Match(ATLParserT__23)
	}

	return localctx
}

// ISetExpContext is an interface to support dynamic dispatch.
type ISetExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetExpContext differentiates from other interfaces.
	IsSetExpContext()
}

type SetExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetExpContext() *SetExpContext {
	var p = new(SetExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_setExp
	return p
}

func (*SetExpContext) IsSetExpContext() {}

func NewSetExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetExpContext {
	var p = new(SetExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_setExp

	return p
}

func (s *SetExpContext) GetParser() antlr.Parser { return s.parser }

func (s *SetExpContext) AllOclExpression() []IOclExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem())
	var tst = make([]IOclExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOclExpressionContext)
		}
	}

	return tst
}

func (s *SetExpContext) OclExpression(i int) IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *SetExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterSetExp(s)
	}
}

func (s *SetExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitSetExp(s)
	}
}

func (p *ATLParser) SetExp() (localctx ISetExpContext) {
	this := p
	_ = this

	localctx = NewSetExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ATLParserRULE_setExp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(715)
		p.Match(ATLParserT__48)
	}
	{
		p.SetState(716)
		p.Match(ATLParserT__21)
	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__14 || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(ATLParserT__33-34))|(1<<(ATLParserT__39-34))|(1<<(ATLParserT__40-34))|(1<<(ATLParserT__41-34))|(1<<(ATLParserT__44-34))|(1<<(ATLParserT__45-34))|(1<<(ATLParserT__46-34))|(1<<(ATLParserT__47-34))|(1<<(ATLParserT__48-34))|(1<<(ATLParserT__49-34))|(1<<(ATLParserT__50-34))|(1<<(ATLParserT__51-34))|(1<<(ATLParserT__52-34))|(1<<(ATLParserT__53-34))|(1<<(ATLParserT__54-34))|(1<<(ATLParserT__55-34))|(1<<(ATLParserT__56-34))|(1<<(ATLParserT__57-34))|(1<<(ATLParserT__60-34))|(1<<(ATLParserT__61-34)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(ATLParserT__77-78))|(1<<(ATLParserT__78-78))|(1<<(ATLParserT__79-78))|(1<<(ATLParserSTRING-78))|(1<<(ATLParserINTEGER-78))|(1<<(ATLParserFLOAT-78))|(1<<(ATLParserIDENTIFIER-78)))) != 0) {
		{
			p.SetState(717)
			p.OclExpression()
		}
		p.SetState(722)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserT__3 {
			{
				p.SetState(718)
				p.Match(ATLParserT__3)
			}
			{
				p.SetState(719)
				p.OclExpression()
			}

			p.SetState(724)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(727)
		p.Match(ATLParserT__23)
	}

	return localctx
}

// IOrderedSetExpContext is an interface to support dynamic dispatch.
type IOrderedSetExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderedSetExpContext differentiates from other interfaces.
	IsOrderedSetExpContext()
}

type OrderedSetExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderedSetExpContext() *OrderedSetExpContext {
	var p = new(OrderedSetExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_orderedSetExp
	return p
}

func (*OrderedSetExpContext) IsOrderedSetExpContext() {}

func NewOrderedSetExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderedSetExpContext {
	var p = new(OrderedSetExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_orderedSetExp

	return p
}

func (s *OrderedSetExpContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderedSetExpContext) AllOclExpression() []IOclExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem())
	var tst = make([]IOclExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOclExpressionContext)
		}
	}

	return tst
}

func (s *OrderedSetExpContext) OclExpression(i int) IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *OrderedSetExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderedSetExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderedSetExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOrderedSetExp(s)
	}
}

func (s *OrderedSetExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOrderedSetExp(s)
	}
}

func (p *ATLParser) OrderedSetExp() (localctx IOrderedSetExpContext) {
	this := p
	_ = this

	localctx = NewOrderedSetExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ATLParserRULE_orderedSetExp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		p.Match(ATLParserT__49)
	}
	{
		p.SetState(730)
		p.Match(ATLParserT__21)
	}
	p.SetState(739)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__14 || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(ATLParserT__33-34))|(1<<(ATLParserT__39-34))|(1<<(ATLParserT__40-34))|(1<<(ATLParserT__41-34))|(1<<(ATLParserT__44-34))|(1<<(ATLParserT__45-34))|(1<<(ATLParserT__46-34))|(1<<(ATLParserT__47-34))|(1<<(ATLParserT__48-34))|(1<<(ATLParserT__49-34))|(1<<(ATLParserT__50-34))|(1<<(ATLParserT__51-34))|(1<<(ATLParserT__52-34))|(1<<(ATLParserT__53-34))|(1<<(ATLParserT__54-34))|(1<<(ATLParserT__55-34))|(1<<(ATLParserT__56-34))|(1<<(ATLParserT__57-34))|(1<<(ATLParserT__60-34))|(1<<(ATLParserT__61-34)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(ATLParserT__77-78))|(1<<(ATLParserT__78-78))|(1<<(ATLParserT__79-78))|(1<<(ATLParserSTRING-78))|(1<<(ATLParserINTEGER-78))|(1<<(ATLParserFLOAT-78))|(1<<(ATLParserIDENTIFIER-78)))) != 0) {
		{
			p.SetState(731)
			p.OclExpression()
		}
		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserT__3 {
			{
				p.SetState(732)
				p.Match(ATLParserT__3)
			}
			{
				p.SetState(733)
				p.OclExpression()
			}

			p.SetState(738)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(741)
		p.Match(ATLParserT__23)
	}

	return localctx
}

// ISequenceExpContext is an interface to support dynamic dispatch.
type ISequenceExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequenceExpContext differentiates from other interfaces.
	IsSequenceExpContext()
}

type SequenceExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceExpContext() *SequenceExpContext {
	var p = new(SequenceExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_sequenceExp
	return p
}

func (*SequenceExpContext) IsSequenceExpContext() {}

func NewSequenceExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceExpContext {
	var p = new(SequenceExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_sequenceExp

	return p
}

func (s *SequenceExpContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceExpContext) AllOclExpression() []IOclExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem())
	var tst = make([]IOclExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOclExpressionContext)
		}
	}

	return tst
}

func (s *SequenceExpContext) OclExpression(i int) IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *SequenceExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterSequenceExp(s)
	}
}

func (s *SequenceExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitSequenceExp(s)
	}
}

func (p *ATLParser) SequenceExp() (localctx ISequenceExpContext) {
	this := p
	_ = this

	localctx = NewSequenceExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ATLParserRULE_sequenceExp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(743)
		p.Match(ATLParserT__50)
	}
	{
		p.SetState(744)
		p.Match(ATLParserT__21)
	}
	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__14 || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(ATLParserT__33-34))|(1<<(ATLParserT__39-34))|(1<<(ATLParserT__40-34))|(1<<(ATLParserT__41-34))|(1<<(ATLParserT__44-34))|(1<<(ATLParserT__45-34))|(1<<(ATLParserT__46-34))|(1<<(ATLParserT__47-34))|(1<<(ATLParserT__48-34))|(1<<(ATLParserT__49-34))|(1<<(ATLParserT__50-34))|(1<<(ATLParserT__51-34))|(1<<(ATLParserT__52-34))|(1<<(ATLParserT__53-34))|(1<<(ATLParserT__54-34))|(1<<(ATLParserT__55-34))|(1<<(ATLParserT__56-34))|(1<<(ATLParserT__57-34))|(1<<(ATLParserT__60-34))|(1<<(ATLParserT__61-34)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(ATLParserT__77-78))|(1<<(ATLParserT__78-78))|(1<<(ATLParserT__79-78))|(1<<(ATLParserSTRING-78))|(1<<(ATLParserINTEGER-78))|(1<<(ATLParserFLOAT-78))|(1<<(ATLParserIDENTIFIER-78)))) != 0) {
		{
			p.SetState(745)
			p.OclExpression()
		}
		p.SetState(750)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserT__3 {
			{
				p.SetState(746)
				p.Match(ATLParserT__3)
			}
			{
				p.SetState(747)
				p.OclExpression()
			}

			p.SetState(752)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(755)
		p.Match(ATLParserT__23)
	}

	return localctx
}

// IMapExpContext is an interface to support dynamic dispatch.
type IMapExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapExpContext differentiates from other interfaces.
	IsMapExpContext()
}

type MapExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapExpContext() *MapExpContext {
	var p = new(MapExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_mapExp
	return p
}

func (*MapExpContext) IsMapExpContext() {}

func NewMapExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapExpContext {
	var p = new(MapExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_mapExp

	return p
}

func (s *MapExpContext) GetParser() antlr.Parser { return s.parser }

func (s *MapExpContext) AllMapElement() []IMapElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMapElementContext)(nil)).Elem())
	var tst = make([]IMapElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMapElementContext)
		}
	}

	return tst
}

func (s *MapExpContext) MapElement(i int) IMapElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMapElementContext)
}

func (s *MapExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterMapExp(s)
	}
}

func (s *MapExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitMapExp(s)
	}
}

func (p *ATLParser) MapExp() (localctx IMapExpContext) {
	this := p
	_ = this

	localctx = NewMapExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ATLParserRULE_mapExp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(757)
		p.Match(ATLParserT__51)
	}
	{
		p.SetState(758)
		p.Match(ATLParserT__21)
	}
	p.SetState(767)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__14 {
		{
			p.SetState(759)
			p.MapElement()
		}
		p.SetState(764)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserT__3 {
			{
				p.SetState(760)
				p.Match(ATLParserT__3)
			}
			{
				p.SetState(761)
				p.MapElement()
			}

			p.SetState(766)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(769)
		p.Match(ATLParserT__23)
	}

	return localctx
}

// IMapElementContext is an interface to support dynamic dispatch.
type IMapElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapElementContext differentiates from other interfaces.
	IsMapElementContext()
}

type MapElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapElementContext() *MapElementContext {
	var p = new(MapElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_mapElement
	return p
}

func (*MapElementContext) IsMapElementContext() {}

func NewMapElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapElementContext {
	var p = new(MapElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_mapElement

	return p
}

func (s *MapElementContext) GetParser() antlr.Parser { return s.parser }

func (s *MapElementContext) AllOclExpression() []IOclExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem())
	var tst = make([]IOclExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOclExpressionContext)
		}
	}

	return tst
}

func (s *MapElementContext) OclExpression(i int) IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *MapElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterMapElement(s)
	}
}

func (s *MapElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitMapElement(s)
	}
}

func (p *ATLParser) MapElement() (localctx IMapElementContext) {
	this := p
	_ = this

	localctx = NewMapElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ATLParserRULE_mapElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(771)
		p.Match(ATLParserT__14)
	}
	{
		p.SetState(772)
		p.OclExpression()
	}
	{
		p.SetState(773)
		p.Match(ATLParserT__3)
	}
	{
		p.SetState(774)
		p.OclExpression()
	}
	{
		p.SetState(775)
		p.Match(ATLParserT__15)
	}

	return localctx
}

// ITupleExpContext is an interface to support dynamic dispatch.
type ITupleExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTupleExpContext differentiates from other interfaces.
	IsTupleExpContext()
}

type TupleExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleExpContext() *TupleExpContext {
	var p = new(TupleExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_tupleExp
	return p
}

func (*TupleExpContext) IsTupleExpContext() {}

func NewTupleExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleExpContext {
	var p = new(TupleExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_tupleExp

	return p
}

func (s *TupleExpContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleExpContext) AllTuplePart() []ITuplePartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITuplePartContext)(nil)).Elem())
	var tst = make([]ITuplePartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITuplePartContext)
		}
	}

	return tst
}

func (s *TupleExpContext) TuplePart(i int) ITuplePartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITuplePartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITuplePartContext)
}

func (s *TupleExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterTupleExp(s)
	}
}

func (s *TupleExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitTupleExp(s)
	}
}

func (p *ATLParser) TupleExp() (localctx ITupleExpContext) {
	this := p
	_ = this

	localctx = NewTupleExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ATLParserRULE_tupleExp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(777)
		p.Match(ATLParserT__52)
	}
	{
		p.SetState(778)
		p.Match(ATLParserT__21)
	}
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserIDENTIFIER {
		{
			p.SetState(779)
			p.TuplePart()
		}
		p.SetState(784)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserT__3 {
			{
				p.SetState(780)
				p.Match(ATLParserT__3)
			}
			{
				p.SetState(781)
				p.TuplePart()
			}

			p.SetState(786)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(789)
		p.Match(ATLParserT__23)
	}

	return localctx
}

// ITuplePartContext is an interface to support dynamic dispatch.
type ITuplePartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTuplePartContext differentiates from other interfaces.
	IsTuplePartContext()
}

type TuplePartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTuplePartContext() *TuplePartContext {
	var p = new(TuplePartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_tuplePart
	return p
}

func (*TuplePartContext) IsTuplePartContext() {}

func NewTuplePartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TuplePartContext {
	var p = new(TuplePartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_tuplePart

	return p
}

func (s *TuplePartContext) GetParser() antlr.Parser { return s.parser }

func (s *TuplePartContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *TuplePartContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *TuplePartContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *TuplePartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TuplePartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TuplePartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterTuplePart(s)
	}
}

func (s *TuplePartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitTuplePart(s)
	}
}

func (p *ATLParser) TuplePart() (localctx ITuplePartContext) {
	this := p
	_ = this

	localctx = NewTuplePartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ATLParserRULE_tuplePart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(791)
		p.Match(ATLParserIDENTIFIER)
	}
	p.SetState(794)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__12 {
		{
			p.SetState(792)
			p.Match(ATLParserT__12)
		}
		{
			p.SetState(793)
			p.OclType()
		}

	}
	{
		p.SetState(796)
		p.Match(ATLParserT__8)
	}
	{
		p.SetState(797)
		p.OclExpression()
	}

	return localctx
}

// IOclTypeContext is an interface to support dynamic dispatch.
type IOclTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOclTypeContext differentiates from other interfaces.
	IsOclTypeContext()
}

type OclTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOclTypeContext() *OclTypeContext {
	var p = new(OclTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_oclType
	return p
}

func (*OclTypeContext) IsOclTypeContext() {}

func NewOclTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OclTypeContext {
	var p = new(OclTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_oclType

	return p
}

func (s *OclTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OclTypeContext) OclModelElement() IOclModelElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclModelElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclModelElementContext)
}

func (s *OclTypeContext) OclAnyType() IOclAnyTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclAnyTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclAnyTypeContext)
}

func (s *OclTypeContext) TupleType() ITupleTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITupleTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITupleTypeContext)
}

func (s *OclTypeContext) MapType() IMapTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *OclTypeContext) Primitive() IPrimitiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveContext)
}

func (s *OclTypeContext) CollectionType() ICollectionTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollectionTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollectionTypeContext)
}

func (s *OclTypeContext) OclType_abstractContents() IOclType_abstractContentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclType_abstractContentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclType_abstractContentsContext)
}

func (s *OclTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OclTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OclTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOclType(s)
	}
}

func (s *OclTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOclType(s)
	}
}

func (p *ATLParser) OclType() (localctx IOclTypeContext) {
	this := p
	_ = this

	localctx = NewOclTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ATLParserRULE_oclType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(806)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ATLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(799)
			p.OclModelElement()
		}

	case ATLParserT__78:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(800)
			p.OclAnyType()
		}

	case ATLParserT__53:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(801)
			p.TupleType()
		}

	case ATLParserT__51:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(802)
			p.MapType()
		}

	case ATLParserT__54, ATLParserT__55, ATLParserT__56, ATLParserT__57:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(803)
			p.Primitive()
		}

	case ATLParserT__47, ATLParserT__48, ATLParserT__49, ATLParserT__50, ATLParserT__79:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(804)
			p.CollectionType()
		}

	case ATLParserT__77:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(805)
			p.OclType_abstractContents()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOclAnyTypeContext is an interface to support dynamic dispatch.
type IOclAnyTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOclAnyTypeContext differentiates from other interfaces.
	IsOclAnyTypeContext()
}

type OclAnyTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOclAnyTypeContext() *OclAnyTypeContext {
	var p = new(OclAnyTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_oclAnyType
	return p
}

func (*OclAnyTypeContext) IsOclAnyTypeContext() {}

func NewOclAnyTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OclAnyTypeContext {
	var p = new(OclAnyTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_oclAnyType

	return p
}

func (s *OclAnyTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OclAnyTypeContext) OclAnyType_abstractContents() IOclAnyType_abstractContentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclAnyType_abstractContentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclAnyType_abstractContentsContext)
}

func (s *OclAnyTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OclAnyTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OclAnyTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOclAnyType(s)
	}
}

func (s *OclAnyTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOclAnyType(s)
	}
}

func (p *ATLParser) OclAnyType() (localctx IOclAnyTypeContext) {
	this := p
	_ = this

	localctx = NewOclAnyTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ATLParserRULE_oclAnyType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(808)
		p.OclAnyType_abstractContents()
	}

	return localctx
}

// ITupleTypeContext is an interface to support dynamic dispatch.
type ITupleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTupleTypeContext differentiates from other interfaces.
	IsTupleTypeContext()
}

type TupleTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeContext() *TupleTypeContext {
	var p = new(TupleTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_tupleType
	return p
}

func (*TupleTypeContext) IsTupleTypeContext() {}

func NewTupleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeContext {
	var p = new(TupleTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_tupleType

	return p
}

func (s *TupleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeContext) AllTupleTypeAttribute() []ITupleTypeAttributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITupleTypeAttributeContext)(nil)).Elem())
	var tst = make([]ITupleTypeAttributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITupleTypeAttributeContext)
		}
	}

	return tst
}

func (s *TupleTypeContext) TupleTypeAttribute(i int) ITupleTypeAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITupleTypeAttributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITupleTypeAttributeContext)
}

func (s *TupleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterTupleType(s)
	}
}

func (s *TupleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitTupleType(s)
	}
}

func (p *ATLParser) TupleType() (localctx ITupleTypeContext) {
	this := p
	_ = this

	localctx = NewTupleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ATLParserRULE_tupleType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(810)
		p.Match(ATLParserT__53)
	}
	{
		p.SetState(811)
		p.Match(ATLParserT__14)
	}
	p.SetState(820)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserIDENTIFIER {
		{
			p.SetState(812)
			p.TupleTypeAttribute()
		}
		p.SetState(817)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserT__3 {
			{
				p.SetState(813)
				p.Match(ATLParserT__3)
			}
			{
				p.SetState(814)
				p.TupleTypeAttribute()
			}

			p.SetState(819)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(822)
		p.Match(ATLParserT__15)
	}

	return localctx
}

// ITupleTypeAttributeContext is an interface to support dynamic dispatch.
type ITupleTypeAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTupleTypeAttributeContext differentiates from other interfaces.
	IsTupleTypeAttributeContext()
}

type TupleTypeAttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeAttributeContext() *TupleTypeAttributeContext {
	var p = new(TupleTypeAttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_tupleTypeAttribute
	return p
}

func (*TupleTypeAttributeContext) IsTupleTypeAttributeContext() {}

func NewTupleTypeAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeAttributeContext {
	var p = new(TupleTypeAttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_tupleTypeAttribute

	return p
}

func (s *TupleTypeAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeAttributeContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, 0)
}

func (s *TupleTypeAttributeContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *TupleTypeAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterTupleTypeAttribute(s)
	}
}

func (s *TupleTypeAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitTupleTypeAttribute(s)
	}
}

func (p *ATLParser) TupleTypeAttribute() (localctx ITupleTypeAttributeContext) {
	this := p
	_ = this

	localctx = NewTupleTypeAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ATLParserRULE_tupleTypeAttribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(824)
		p.Match(ATLParserIDENTIFIER)
	}
	{
		p.SetState(825)
		p.Match(ATLParserT__12)
	}
	{
		p.SetState(826)
		p.OclType()
	}

	return localctx
}

// IMapTypeContext is an interface to support dynamic dispatch.
type IMapTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapTypeContext differentiates from other interfaces.
	IsMapTypeContext()
}

type MapTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapTypeContext() *MapTypeContext {
	var p = new(MapTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_mapType
	return p
}

func (*MapTypeContext) IsMapTypeContext() {}

func NewMapTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapTypeContext {
	var p = new(MapTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_mapType

	return p
}

func (s *MapTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MapTypeContext) AllOclType() []IOclTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOclTypeContext)(nil)).Elem())
	var tst = make([]IOclTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOclTypeContext)
		}
	}

	return tst
}

func (s *MapTypeContext) OclType(i int) IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *MapTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterMapType(s)
	}
}

func (s *MapTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitMapType(s)
	}
}

func (p *ATLParser) MapType() (localctx IMapTypeContext) {
	this := p
	_ = this

	localctx = NewMapTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ATLParserRULE_mapType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(828)
		p.Match(ATLParserT__51)
	}
	{
		p.SetState(829)
		p.Match(ATLParserT__14)
	}
	{
		p.SetState(830)
		p.OclType()
	}
	{
		p.SetState(831)
		p.Match(ATLParserT__3)
	}
	{
		p.SetState(832)
		p.OclType()
	}
	{
		p.SetState(833)
		p.Match(ATLParserT__15)
	}

	return localctx
}

// IPrimitiveContext is an interface to support dynamic dispatch.
type IPrimitiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveContext differentiates from other interfaces.
	IsPrimitiveContext()
}

type PrimitiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveContext() *PrimitiveContext {
	var p = new(PrimitiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_primitive
	return p
}

func (*PrimitiveContext) IsPrimitiveContext() {}

func NewPrimitiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveContext {
	var p = new(PrimitiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_primitive

	return p
}

func (s *PrimitiveContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveContext) NumericType() INumericTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericTypeContext)
}

func (s *PrimitiveContext) BooleanType() IBooleanTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanTypeContext)
}

func (s *PrimitiveContext) StringType() IStringTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringTypeContext)
}

func (s *PrimitiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterPrimitive(s)
	}
}

func (s *PrimitiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitPrimitive(s)
	}
}

func (p *ATLParser) Primitive() (localctx IPrimitiveContext) {
	this := p
	_ = this

	localctx = NewPrimitiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ATLParserRULE_primitive)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(838)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ATLParserT__54, ATLParserT__55:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(835)
			p.NumericType()
		}

	case ATLParserT__56:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(836)
			p.BooleanType()
		}

	case ATLParserT__57:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(837)
			p.StringType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumericTypeContext is an interface to support dynamic dispatch.
type INumericTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericTypeContext differentiates from other interfaces.
	IsNumericTypeContext()
}

type NumericTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericTypeContext() *NumericTypeContext {
	var p = new(NumericTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_numericType
	return p
}

func (*NumericTypeContext) IsNumericTypeContext() {}

func NewNumericTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericTypeContext {
	var p = new(NumericTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_numericType

	return p
}

func (s *NumericTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericTypeContext) IntegerType() IIntegerTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerTypeContext)
}

func (s *NumericTypeContext) RealType() IRealTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRealTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRealTypeContext)
}

func (s *NumericTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterNumericType(s)
	}
}

func (s *NumericTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitNumericType(s)
	}
}

func (p *ATLParser) NumericType() (localctx INumericTypeContext) {
	this := p
	_ = this

	localctx = NewNumericTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ATLParserRULE_numericType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(842)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ATLParserT__54:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(840)
			p.IntegerType()
		}

	case ATLParserT__55:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(841)
			p.RealType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIntegerTypeContext is an interface to support dynamic dispatch.
type IIntegerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerTypeContext differentiates from other interfaces.
	IsIntegerTypeContext()
}

type IntegerTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerTypeContext() *IntegerTypeContext {
	var p = new(IntegerTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_integerType
	return p
}

func (*IntegerTypeContext) IsIntegerTypeContext() {}

func NewIntegerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerTypeContext {
	var p = new(IntegerTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_integerType

	return p
}

func (s *IntegerTypeContext) GetParser() antlr.Parser { return s.parser }
func (s *IntegerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterIntegerType(s)
	}
}

func (s *IntegerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitIntegerType(s)
	}
}

func (p *ATLParser) IntegerType() (localctx IIntegerTypeContext) {
	this := p
	_ = this

	localctx = NewIntegerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ATLParserRULE_integerType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(844)
		p.Match(ATLParserT__54)
	}

	return localctx
}

// IRealTypeContext is an interface to support dynamic dispatch.
type IRealTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRealTypeContext differentiates from other interfaces.
	IsRealTypeContext()
}

type RealTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRealTypeContext() *RealTypeContext {
	var p = new(RealTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_realType
	return p
}

func (*RealTypeContext) IsRealTypeContext() {}

func NewRealTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RealTypeContext {
	var p = new(RealTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_realType

	return p
}

func (s *RealTypeContext) GetParser() antlr.Parser { return s.parser }
func (s *RealTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RealTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RealTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterRealType(s)
	}
}

func (s *RealTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitRealType(s)
	}
}

func (p *ATLParser) RealType() (localctx IRealTypeContext) {
	this := p
	_ = this

	localctx = NewRealTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ATLParserRULE_realType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(846)
		p.Match(ATLParserT__55)
	}

	return localctx
}

// IBooleanTypeContext is an interface to support dynamic dispatch.
type IBooleanTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanTypeContext differentiates from other interfaces.
	IsBooleanTypeContext()
}

type BooleanTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanTypeContext() *BooleanTypeContext {
	var p = new(BooleanTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_booleanType
	return p
}

func (*BooleanTypeContext) IsBooleanTypeContext() {}

func NewBooleanTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanTypeContext {
	var p = new(BooleanTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_booleanType

	return p
}

func (s *BooleanTypeContext) GetParser() antlr.Parser { return s.parser }
func (s *BooleanTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterBooleanType(s)
	}
}

func (s *BooleanTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitBooleanType(s)
	}
}

func (p *ATLParser) BooleanType() (localctx IBooleanTypeContext) {
	this := p
	_ = this

	localctx = NewBooleanTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ATLParserRULE_booleanType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(848)
		p.Match(ATLParserT__56)
	}

	return localctx
}

// IStringTypeContext is an interface to support dynamic dispatch.
type IStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringTypeContext differentiates from other interfaces.
	IsStringTypeContext()
}

type StringTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringTypeContext() *StringTypeContext {
	var p = new(StringTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_stringType
	return p
}

func (*StringTypeContext) IsStringTypeContext() {}

func NewStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringTypeContext {
	var p = new(StringTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_stringType

	return p
}

func (s *StringTypeContext) GetParser() antlr.Parser { return s.parser }
func (s *StringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterStringType(s)
	}
}

func (s *StringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitStringType(s)
	}
}

func (p *ATLParser) StringType() (localctx IStringTypeContext) {
	this := p
	_ = this

	localctx = NewStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ATLParserRULE_stringType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.Match(ATLParserT__57)
	}

	return localctx
}

// ICollectionTypeContext is an interface to support dynamic dispatch.
type ICollectionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollectionTypeContext differentiates from other interfaces.
	IsCollectionTypeContext()
}

type CollectionTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionTypeContext() *CollectionTypeContext {
	var p = new(CollectionTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_collectionType
	return p
}

func (*CollectionTypeContext) IsCollectionTypeContext() {}

func NewCollectionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionTypeContext {
	var p = new(CollectionTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_collectionType

	return p
}

func (s *CollectionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionTypeContext) BagType() IBagTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBagTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBagTypeContext)
}

func (s *CollectionTypeContext) SetType() ISetTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetTypeContext)
}

func (s *CollectionTypeContext) OrderedSetType() IOrderedSetTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderedSetTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderedSetTypeContext)
}

func (s *CollectionTypeContext) SequenceType() ISequenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *CollectionTypeContext) CollectionType_abstractContents() ICollectionType_abstractContentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollectionType_abstractContentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollectionType_abstractContentsContext)
}

func (s *CollectionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterCollectionType(s)
	}
}

func (s *CollectionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitCollectionType(s)
	}
}

func (p *ATLParser) CollectionType() (localctx ICollectionTypeContext) {
	this := p
	_ = this

	localctx = NewCollectionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ATLParserRULE_collectionType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(857)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ATLParserT__47:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(852)
			p.BagType()
		}

	case ATLParserT__48:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(853)
			p.SetType()
		}

	case ATLParserT__49:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(854)
			p.OrderedSetType()
		}

	case ATLParserT__50:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(855)
			p.SequenceType()
		}

	case ATLParserT__79:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(856)
			p.CollectionType_abstractContents()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBagTypeContext is an interface to support dynamic dispatch.
type IBagTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBagTypeContext differentiates from other interfaces.
	IsBagTypeContext()
}

type BagTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBagTypeContext() *BagTypeContext {
	var p = new(BagTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_bagType
	return p
}

func (*BagTypeContext) IsBagTypeContext() {}

func NewBagTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BagTypeContext {
	var p = new(BagTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_bagType

	return p
}

func (s *BagTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BagTypeContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *BagTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BagTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BagTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterBagType(s)
	}
}

func (s *BagTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitBagType(s)
	}
}

func (p *ATLParser) BagType() (localctx IBagTypeContext) {
	this := p
	_ = this

	localctx = NewBagTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ATLParserRULE_bagType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(859)
		p.Match(ATLParserT__47)
	}
	{
		p.SetState(860)
		p.Match(ATLParserT__14)
	}
	{
		p.SetState(861)
		p.OclType()
	}
	{
		p.SetState(862)
		p.Match(ATLParserT__15)
	}

	return localctx
}

// ISetTypeContext is an interface to support dynamic dispatch.
type ISetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetTypeContext differentiates from other interfaces.
	IsSetTypeContext()
}

type SetTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetTypeContext() *SetTypeContext {
	var p = new(SetTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_setType
	return p
}

func (*SetTypeContext) IsSetTypeContext() {}

func NewSetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTypeContext {
	var p = new(SetTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_setType

	return p
}

func (s *SetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTypeContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *SetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterSetType(s)
	}
}

func (s *SetTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitSetType(s)
	}
}

func (p *ATLParser) SetType() (localctx ISetTypeContext) {
	this := p
	_ = this

	localctx = NewSetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ATLParserRULE_setType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(864)
		p.Match(ATLParserT__48)
	}
	{
		p.SetState(865)
		p.Match(ATLParserT__14)
	}
	{
		p.SetState(866)
		p.OclType()
	}
	{
		p.SetState(867)
		p.Match(ATLParserT__15)
	}

	return localctx
}

// IOrderedSetTypeContext is an interface to support dynamic dispatch.
type IOrderedSetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderedSetTypeContext differentiates from other interfaces.
	IsOrderedSetTypeContext()
}

type OrderedSetTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderedSetTypeContext() *OrderedSetTypeContext {
	var p = new(OrderedSetTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_orderedSetType
	return p
}

func (*OrderedSetTypeContext) IsOrderedSetTypeContext() {}

func NewOrderedSetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderedSetTypeContext {
	var p = new(OrderedSetTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_orderedSetType

	return p
}

func (s *OrderedSetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderedSetTypeContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *OrderedSetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderedSetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderedSetTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOrderedSetType(s)
	}
}

func (s *OrderedSetTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOrderedSetType(s)
	}
}

func (p *ATLParser) OrderedSetType() (localctx IOrderedSetTypeContext) {
	this := p
	_ = this

	localctx = NewOrderedSetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ATLParserRULE_orderedSetType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(869)
		p.Match(ATLParserT__49)
	}
	{
		p.SetState(870)
		p.Match(ATLParserT__14)
	}
	{
		p.SetState(871)
		p.OclType()
	}
	{
		p.SetState(872)
		p.Match(ATLParserT__15)
	}

	return localctx
}

// ISequenceTypeContext is an interface to support dynamic dispatch.
type ISequenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequenceTypeContext differentiates from other interfaces.
	IsSequenceTypeContext()
}

type SequenceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceTypeContext() *SequenceTypeContext {
	var p = new(SequenceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_sequenceType
	return p
}

func (*SequenceTypeContext) IsSequenceTypeContext() {}

func NewSequenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceTypeContext {
	var p = new(SequenceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_sequenceType

	return p
}

func (s *SequenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceTypeContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *SequenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterSequenceType(s)
	}
}

func (s *SequenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitSequenceType(s)
	}
}

func (p *ATLParser) SequenceType() (localctx ISequenceTypeContext) {
	this := p
	_ = this

	localctx = NewSequenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ATLParserRULE_sequenceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(874)
		p.Match(ATLParserT__50)
	}
	{
		p.SetState(875)
		p.Match(ATLParserT__14)
	}
	{
		p.SetState(876)
		p.OclType()
	}
	{
		p.SetState(877)
		p.Match(ATLParserT__15)
	}

	return localctx
}

// IPriority_0Context is an interface to support dynamic dispatch.
type IPriority_0Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPriority_0Context differentiates from other interfaces.
	IsPriority_0Context()
}

type Priority_0Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPriority_0Context() *Priority_0Context {
	var p = new(Priority_0Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_priority_0
	return p
}

func (*Priority_0Context) IsPriority_0Context() {}

func NewPriority_0Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Priority_0Context {
	var p = new(Priority_0Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_priority_0

	return p
}

func (s *Priority_0Context) GetParser() antlr.Parser { return s.parser }

func (s *Priority_0Context) Primary_oclExpression() IPrimary_oclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_oclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_oclExpressionContext)
}

func (s *Priority_0Context) AllOperationCallExp() []IOperationCallExpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOperationCallExpContext)(nil)).Elem())
	var tst = make([]IOperationCallExpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOperationCallExpContext)
		}
	}

	return tst
}

func (s *Priority_0Context) OperationCallExp(i int) IOperationCallExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperationCallExpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOperationCallExpContext)
}

func (s *Priority_0Context) AllNavigationOrAttributeCallExp() []INavigationOrAttributeCallExpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INavigationOrAttributeCallExpContext)(nil)).Elem())
	var tst = make([]INavigationOrAttributeCallExpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INavigationOrAttributeCallExpContext)
		}
	}

	return tst
}

func (s *Priority_0Context) NavigationOrAttributeCallExp(i int) INavigationOrAttributeCallExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INavigationOrAttributeCallExpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INavigationOrAttributeCallExpContext)
}

func (s *Priority_0Context) AllIteratorExp() []IIteratorExpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIteratorExpContext)(nil)).Elem())
	var tst = make([]IIteratorExpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIteratorExpContext)
		}
	}

	return tst
}

func (s *Priority_0Context) IteratorExp(i int) IIteratorExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteratorExpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIteratorExpContext)
}

func (s *Priority_0Context) AllIterateExp() []IIterateExpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIterateExpContext)(nil)).Elem())
	var tst = make([]IIterateExpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIterateExpContext)
		}
	}

	return tst
}

func (s *Priority_0Context) IterateExp(i int) IIterateExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIterateExpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIterateExpContext)
}

func (s *Priority_0Context) AllCollectionOperationCallExp() []ICollectionOperationCallExpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollectionOperationCallExpContext)(nil)).Elem())
	var tst = make([]ICollectionOperationCallExpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollectionOperationCallExpContext)
		}
	}

	return tst
}

func (s *Priority_0Context) CollectionOperationCallExp(i int) ICollectionOperationCallExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollectionOperationCallExpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollectionOperationCallExpContext)
}

func (s *Priority_0Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Priority_0Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Priority_0Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterPriority_0(s)
	}
}

func (s *Priority_0Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitPriority_0(s)
	}
}

func (p *ATLParser) Priority_0() (localctx IPriority_0Context) {
	this := p
	_ = this

	localctx = NewPriority_0Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ATLParserRULE_priority_0)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(879)
		p.Primary_oclExpression()
	}
	p.SetState(893)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__58 || _la == ATLParserT__59 {
		p.SetState(891)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ATLParserT__58:
			{
				p.SetState(880)
				p.Match(ATLParserT__58)
			}
			p.SetState(883)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(881)
					p.OperationCallExp()
				}

			case 2:
				{
					p.SetState(882)
					p.NavigationOrAttributeCallExp()
				}

			}

		case ATLParserT__59:
			{
				p.SetState(885)
				p.Match(ATLParserT__59)
			}
			p.SetState(889)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(886)
					p.IteratorExp()
				}

			case 2:
				{
					p.SetState(887)
					p.IterateExp()
				}

			case 3:
				{
					p.SetState(888)
					p.CollectionOperationCallExp()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(895)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPriority_1Context is an interface to support dynamic dispatch.
type IPriority_1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPriority_1Context differentiates from other interfaces.
	IsPriority_1Context()
}

type Priority_1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPriority_1Context() *Priority_1Context {
	var p = new(Priority_1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_priority_1
	return p
}

func (*Priority_1Context) IsPriority_1Context() {}

func NewPriority_1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Priority_1Context {
	var p = new(Priority_1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_priority_1

	return p
}

func (s *Priority_1Context) GetParser() antlr.Parser { return s.parser }

func (s *Priority_1Context) Priority_0() IPriority_0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPriority_0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPriority_0Context)
}

func (s *Priority_1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Priority_1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Priority_1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterPriority_1(s)
	}
}

func (s *Priority_1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitPriority_1(s)
	}
}

func (p *ATLParser) Priority_1() (localctx IPriority_1Context) {
	this := p
	_ = this

	localctx = NewPriority_1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ATLParserRULE_priority_1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(901)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ATLParserT__60:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(896)
			p.Match(ATLParserT__60)
		}
		{
			p.SetState(897)
			p.Priority_0()
		}

	case ATLParserT__61:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(898)
			p.Match(ATLParserT__61)
		}
		{
			p.SetState(899)
			p.Priority_0()
		}

	case ATLParserT__14, ATLParserT__33, ATLParserT__39, ATLParserT__40, ATLParserT__41, ATLParserT__44, ATLParserT__46, ATLParserT__47, ATLParserT__48, ATLParserT__49, ATLParserT__50, ATLParserT__51, ATLParserT__52, ATLParserT__53, ATLParserT__54, ATLParserT__55, ATLParserT__56, ATLParserT__57, ATLParserT__77, ATLParserT__78, ATLParserT__79, ATLParserSTRING, ATLParserINTEGER, ATLParserFLOAT, ATLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(900)
			p.Priority_0()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPriority_2Context is an interface to support dynamic dispatch.
type IPriority_2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPriority_2Context differentiates from other interfaces.
	IsPriority_2Context()
}

type Priority_2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPriority_2Context() *Priority_2Context {
	var p = new(Priority_2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_priority_2
	return p
}

func (*Priority_2Context) IsPriority_2Context() {}

func NewPriority_2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Priority_2Context {
	var p = new(Priority_2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_priority_2

	return p
}

func (s *Priority_2Context) GetParser() antlr.Parser { return s.parser }

func (s *Priority_2Context) AllPriority_1() []IPriority_1Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPriority_1Context)(nil)).Elem())
	var tst = make([]IPriority_1Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPriority_1Context)
		}
	}

	return tst
}

func (s *Priority_2Context) Priority_1(i int) IPriority_1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPriority_1Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPriority_1Context)
}

func (s *Priority_2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Priority_2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Priority_2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterPriority_2(s)
	}
}

func (s *Priority_2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitPriority_2(s)
	}
}

func (p *ATLParser) Priority_2() (localctx IPriority_2Context) {
	this := p
	_ = this

	localctx = NewPriority_2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ATLParserRULE_priority_2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(903)
		p.Priority_1()
	}
	p.SetState(914)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-63)&-(0x1f+1)) == 0 && ((1<<uint((_la-63)))&((1<<(ATLParserT__62-63))|(1<<(ATLParserT__63-63))|(1<<(ATLParserT__64-63))|(1<<(ATLParserT__65-63)))) != 0 {
		p.SetState(912)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ATLParserT__62:
			{
				p.SetState(904)
				p.Match(ATLParserT__62)
			}
			{
				p.SetState(905)
				p.Priority_1()
			}

		case ATLParserT__63:
			{
				p.SetState(906)
				p.Match(ATLParserT__63)
			}
			{
				p.SetState(907)
				p.Priority_1()
			}

		case ATLParserT__64:
			{
				p.SetState(908)
				p.Match(ATLParserT__64)
			}
			{
				p.SetState(909)
				p.Priority_1()
			}

		case ATLParserT__65:
			{
				p.SetState(910)
				p.Match(ATLParserT__65)
			}
			{
				p.SetState(911)
				p.Priority_1()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(916)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPriority_3Context is an interface to support dynamic dispatch.
type IPriority_3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPriority_3Context differentiates from other interfaces.
	IsPriority_3Context()
}

type Priority_3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPriority_3Context() *Priority_3Context {
	var p = new(Priority_3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_priority_3
	return p
}

func (*Priority_3Context) IsPriority_3Context() {}

func NewPriority_3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Priority_3Context {
	var p = new(Priority_3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_priority_3

	return p
}

func (s *Priority_3Context) GetParser() antlr.Parser { return s.parser }

func (s *Priority_3Context) AllPriority_2() []IPriority_2Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPriority_2Context)(nil)).Elem())
	var tst = make([]IPriority_2Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPriority_2Context)
		}
	}

	return tst
}

func (s *Priority_3Context) Priority_2(i int) IPriority_2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPriority_2Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPriority_2Context)
}

func (s *Priority_3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Priority_3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Priority_3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterPriority_3(s)
	}
}

func (s *Priority_3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitPriority_3(s)
	}
}

func (p *ATLParser) Priority_3() (localctx IPriority_3Context) {
	this := p
	_ = this

	localctx = NewPriority_3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ATLParserRULE_priority_3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(917)
		p.Priority_2()
	}
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__61 || _la == ATLParserT__66 {
		p.SetState(922)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ATLParserT__66:
			{
				p.SetState(918)
				p.Match(ATLParserT__66)
			}
			{
				p.SetState(919)
				p.Priority_2()
			}

		case ATLParserT__61:
			{
				p.SetState(920)
				p.Match(ATLParserT__61)
			}
			{
				p.SetState(921)
				p.Priority_2()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(926)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPriority_4Context is an interface to support dynamic dispatch.
type IPriority_4Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPriority_4Context differentiates from other interfaces.
	IsPriority_4Context()
}

type Priority_4Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPriority_4Context() *Priority_4Context {
	var p = new(Priority_4Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_priority_4
	return p
}

func (*Priority_4Context) IsPriority_4Context() {}

func NewPriority_4Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Priority_4Context {
	var p = new(Priority_4Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_priority_4

	return p
}

func (s *Priority_4Context) GetParser() antlr.Parser { return s.parser }

func (s *Priority_4Context) AllPriority_3() []IPriority_3Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPriority_3Context)(nil)).Elem())
	var tst = make([]IPriority_3Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPriority_3Context)
		}
	}

	return tst
}

func (s *Priority_4Context) Priority_3(i int) IPriority_3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPriority_3Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPriority_3Context)
}

func (s *Priority_4Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Priority_4Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Priority_4Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterPriority_4(s)
	}
}

func (s *Priority_4Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitPriority_4(s)
	}
}

func (p *ATLParser) Priority_4() (localctx IPriority_4Context) {
	this := p
	_ = this

	localctx = NewPriority_4Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ATLParserRULE_priority_4)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(927)
		p.Priority_3()
	}
	p.SetState(942)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ATLParserT__8 || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(ATLParserT__67-68))|(1<<(ATLParserT__68-68))|(1<<(ATLParserT__69-68))|(1<<(ATLParserT__70-68))|(1<<(ATLParserT__71-68)))) != 0) {
		p.SetState(940)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ATLParserT__8:
			{
				p.SetState(928)
				p.Match(ATLParserT__8)
			}
			{
				p.SetState(929)
				p.Priority_3()
			}

		case ATLParserT__67:
			{
				p.SetState(930)
				p.Match(ATLParserT__67)
			}
			{
				p.SetState(931)
				p.Priority_3()
			}

		case ATLParserT__68:
			{
				p.SetState(932)
				p.Match(ATLParserT__68)
			}
			{
				p.SetState(933)
				p.Priority_3()
			}

		case ATLParserT__69:
			{
				p.SetState(934)
				p.Match(ATLParserT__69)
			}
			{
				p.SetState(935)
				p.Priority_3()
			}

		case ATLParserT__70:
			{
				p.SetState(936)
				p.Match(ATLParserT__70)
			}
			{
				p.SetState(937)
				p.Priority_3()
			}

		case ATLParserT__71:
			{
				p.SetState(938)
				p.Match(ATLParserT__71)
			}
			{
				p.SetState(939)
				p.Priority_3()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(944)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPriority_5Context is an interface to support dynamic dispatch.
type IPriority_5Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPriority_5Context differentiates from other interfaces.
	IsPriority_5Context()
}

type Priority_5Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPriority_5Context() *Priority_5Context {
	var p = new(Priority_5Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_priority_5
	return p
}

func (*Priority_5Context) IsPriority_5Context() {}

func NewPriority_5Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Priority_5Context {
	var p = new(Priority_5Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_priority_5

	return p
}

func (s *Priority_5Context) GetParser() antlr.Parser { return s.parser }

func (s *Priority_5Context) AllPriority_4() []IPriority_4Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPriority_4Context)(nil)).Elem())
	var tst = make([]IPriority_4Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPriority_4Context)
		}
	}

	return tst
}

func (s *Priority_5Context) Priority_4(i int) IPriority_4Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPriority_4Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPriority_4Context)
}

func (s *Priority_5Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Priority_5Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Priority_5Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterPriority_5(s)
	}
}

func (s *Priority_5Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitPriority_5(s)
	}
}

func (p *ATLParser) Priority_5() (localctx IPriority_5Context) {
	this := p
	_ = this

	localctx = NewPriority_5Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ATLParserRULE_priority_5)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(945)
		p.Priority_4()
	}
	p.SetState(956)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(ATLParserT__72-73))|(1<<(ATLParserT__73-73))|(1<<(ATLParserT__74-73))|(1<<(ATLParserT__75-73)))) != 0 {
		p.SetState(954)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ATLParserT__72:
			{
				p.SetState(946)
				p.Match(ATLParserT__72)
			}
			{
				p.SetState(947)
				p.Priority_4()
			}

		case ATLParserT__73:
			{
				p.SetState(948)
				p.Match(ATLParserT__73)
			}
			{
				p.SetState(949)
				p.Priority_4()
			}

		case ATLParserT__74:
			{
				p.SetState(950)
				p.Match(ATLParserT__74)
			}
			{
				p.SetState(951)
				p.Priority_4()
			}

		case ATLParserT__75:
			{
				p.SetState(952)
				p.Match(ATLParserT__75)
			}
			{
				p.SetState(953)
				p.Priority_4()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(958)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMatchedRule_abstractContentsContext is an interface to support dynamic dispatch.
type IMatchedRule_abstractContentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatchedRule_abstractContentsContext differentiates from other interfaces.
	IsMatchedRule_abstractContentsContext()
}

type MatchedRule_abstractContentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchedRule_abstractContentsContext() *MatchedRule_abstractContentsContext {
	var p = new(MatchedRule_abstractContentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_matchedRule_abstractContents
	return p
}

func (*MatchedRule_abstractContentsContext) IsMatchedRule_abstractContentsContext() {}

func NewMatchedRule_abstractContentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchedRule_abstractContentsContext {
	var p = new(MatchedRule_abstractContentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_matchedRule_abstractContents

	return p
}

func (s *MatchedRule_abstractContentsContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchedRule_abstractContentsContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ATLParserIDENTIFIER)
}

func (s *MatchedRule_abstractContentsContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ATLParserIDENTIFIER, i)
}

func (s *MatchedRule_abstractContentsContext) InPattern() IInPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInPatternContext)
}

func (s *MatchedRule_abstractContentsContext) OutPattern() IOutPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutPatternContext)
}

func (s *MatchedRule_abstractContentsContext) ActionBlock() IActionBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActionBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActionBlockContext)
}

func (s *MatchedRule_abstractContentsContext) AllRuleVariableDeclaration() []IRuleVariableDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRuleVariableDeclarationContext)(nil)).Elem())
	var tst = make([]IRuleVariableDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRuleVariableDeclarationContext)
		}
	}

	return tst
}

func (s *MatchedRule_abstractContentsContext) RuleVariableDeclaration(i int) IRuleVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRuleVariableDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRuleVariableDeclarationContext)
}

func (s *MatchedRule_abstractContentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchedRule_abstractContentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchedRule_abstractContentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterMatchedRule_abstractContents(s)
	}
}

func (s *MatchedRule_abstractContentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitMatchedRule_abstractContents(s)
	}
}

func (p *ATLParser) MatchedRule_abstractContents() (localctx IMatchedRule_abstractContentsContext) {
	this := p
	_ = this

	localctx = NewMatchedRule_abstractContentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ATLParserRULE_matchedRule_abstractContents)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(960)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__76 {
		{
			p.SetState(959)
			p.Match(ATLParserT__76)
		}

	}
	p.SetState(963)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__18 {
		{
			p.SetState(962)
			p.Match(ATLParserT__18)
		}

	}
	p.SetState(966)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__4 {
		{
			p.SetState(965)
			p.Match(ATLParserT__4)
		}

	}
	{
		p.SetState(968)
		p.Match(ATLParserT__19)
	}
	{
		p.SetState(969)
		p.Match(ATLParserIDENTIFIER)
	}
	p.SetState(972)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__20 {
		{
			p.SetState(970)
			p.Match(ATLParserT__20)
		}
		{
			p.SetState(971)
			p.Match(ATLParserIDENTIFIER)
		}

	}
	{
		p.SetState(974)
		p.Match(ATLParserT__21)
	}
	{
		p.SetState(975)
		p.InPattern()
	}
	p.SetState(985)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__22 {
		{
			p.SetState(976)
			p.Match(ATLParserT__22)
		}
		{
			p.SetState(977)
			p.Match(ATLParserT__21)
		}
		p.SetState(981)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ATLParserIDENTIFIER {
			{
				p.SetState(978)
				p.RuleVariableDeclaration()
			}

			p.SetState(983)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(984)
			p.Match(ATLParserT__23)
		}

	}
	p.SetState(988)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__27 {
		{
			p.SetState(987)
			p.OutPattern()
		}

	}
	p.SetState(991)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ATLParserT__32 {
		{
			p.SetState(990)
			p.ActionBlock()
		}

	}
	{
		p.SetState(993)
		p.Match(ATLParserT__23)
	}

	return localctx
}

// IOclType_abstractContentsContext is an interface to support dynamic dispatch.
type IOclType_abstractContentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOclType_abstractContentsContext differentiates from other interfaces.
	IsOclType_abstractContentsContext()
}

type OclType_abstractContentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOclType_abstractContentsContext() *OclType_abstractContentsContext {
	var p = new(OclType_abstractContentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_oclType_abstractContents
	return p
}

func (*OclType_abstractContentsContext) IsOclType_abstractContentsContext() {}

func NewOclType_abstractContentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OclType_abstractContentsContext {
	var p = new(OclType_abstractContentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_oclType_abstractContents

	return p
}

func (s *OclType_abstractContentsContext) GetParser() antlr.Parser { return s.parser }
func (s *OclType_abstractContentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OclType_abstractContentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OclType_abstractContentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOclType_abstractContents(s)
	}
}

func (s *OclType_abstractContentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOclType_abstractContents(s)
	}
}

func (p *ATLParser) OclType_abstractContents() (localctx IOclType_abstractContentsContext) {
	this := p
	_ = this

	localctx = NewOclType_abstractContentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ATLParserRULE_oclType_abstractContents)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(995)
		p.Match(ATLParserT__77)
	}

	return localctx
}

// IOclAnyType_abstractContentsContext is an interface to support dynamic dispatch.
type IOclAnyType_abstractContentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOclAnyType_abstractContentsContext differentiates from other interfaces.
	IsOclAnyType_abstractContentsContext()
}

type OclAnyType_abstractContentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOclAnyType_abstractContentsContext() *OclAnyType_abstractContentsContext {
	var p = new(OclAnyType_abstractContentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_oclAnyType_abstractContents
	return p
}

func (*OclAnyType_abstractContentsContext) IsOclAnyType_abstractContentsContext() {}

func NewOclAnyType_abstractContentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OclAnyType_abstractContentsContext {
	var p = new(OclAnyType_abstractContentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_oclAnyType_abstractContents

	return p
}

func (s *OclAnyType_abstractContentsContext) GetParser() antlr.Parser { return s.parser }
func (s *OclAnyType_abstractContentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OclAnyType_abstractContentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OclAnyType_abstractContentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterOclAnyType_abstractContents(s)
	}
}

func (s *OclAnyType_abstractContentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitOclAnyType_abstractContents(s)
	}
}

func (p *ATLParser) OclAnyType_abstractContents() (localctx IOclAnyType_abstractContentsContext) {
	this := p
	_ = this

	localctx = NewOclAnyType_abstractContentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ATLParserRULE_oclAnyType_abstractContents)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(997)
		p.Match(ATLParserT__78)
	}

	return localctx
}

// ICollectionType_abstractContentsContext is an interface to support dynamic dispatch.
type ICollectionType_abstractContentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollectionType_abstractContentsContext differentiates from other interfaces.
	IsCollectionType_abstractContentsContext()
}

type CollectionType_abstractContentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionType_abstractContentsContext() *CollectionType_abstractContentsContext {
	var p = new(CollectionType_abstractContentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_collectionType_abstractContents
	return p
}

func (*CollectionType_abstractContentsContext) IsCollectionType_abstractContentsContext() {}

func NewCollectionType_abstractContentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionType_abstractContentsContext {
	var p = new(CollectionType_abstractContentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_collectionType_abstractContents

	return p
}

func (s *CollectionType_abstractContentsContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionType_abstractContentsContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *CollectionType_abstractContentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionType_abstractContentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionType_abstractContentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterCollectionType_abstractContents(s)
	}
}

func (s *CollectionType_abstractContentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitCollectionType_abstractContents(s)
	}
}

func (p *ATLParser) CollectionType_abstractContents() (localctx ICollectionType_abstractContentsContext) {
	this := p
	_ = this

	localctx = NewCollectionType_abstractContentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ATLParserRULE_collectionType_abstractContents)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(999)
		p.Match(ATLParserT__79)
	}
	{
		p.SetState(1000)
		p.Match(ATLParserT__14)
	}
	{
		p.SetState(1001)
		p.OclType()
	}
	{
		p.SetState(1002)
		p.Match(ATLParserT__15)
	}

	return localctx
}

// IPrimary_oclExpressionContext is an interface to support dynamic dispatch.
type IPrimary_oclExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_oclExpressionContext differentiates from other interfaces.
	IsPrimary_oclExpressionContext()
}

type Primary_oclExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_oclExpressionContext() *Primary_oclExpressionContext {
	var p = new(Primary_oclExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ATLParserRULE_primary_oclExpression
	return p
}

func (*Primary_oclExpressionContext) IsPrimary_oclExpressionContext() {}

func NewPrimary_oclExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_oclExpressionContext {
	var p = new(Primary_oclExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ATLParserRULE_primary_oclExpression

	return p
}

func (s *Primary_oclExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_oclExpressionContext) VariableExp() IVariableExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableExpContext)
}

func (s *Primary_oclExpressionContext) OclUndefinedExp() IOclUndefinedExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclUndefinedExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclUndefinedExpContext)
}

func (s *Primary_oclExpressionContext) PrimitiveExp() IPrimitiveExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveExpContext)
}

func (s *Primary_oclExpressionContext) IfExp() IIfExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExpContext)
}

func (s *Primary_oclExpressionContext) SuperExp() ISuperExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuperExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuperExpContext)
}

func (s *Primary_oclExpressionContext) EnumLiteralExp() IEnumLiteralExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumLiteralExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumLiteralExpContext)
}

func (s *Primary_oclExpressionContext) CollectionExp() ICollectionExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollectionExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollectionExpContext)
}

func (s *Primary_oclExpressionContext) MapExp() IMapExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapExpContext)
}

func (s *Primary_oclExpressionContext) TupleExp() ITupleExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITupleExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITupleExpContext)
}

func (s *Primary_oclExpressionContext) OclType() IOclTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclTypeContext)
}

func (s *Primary_oclExpressionContext) OclExpression() IOclExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOclExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOclExpressionContext)
}

func (s *Primary_oclExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_oclExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_oclExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.EnterPrimary_oclExpression(s)
	}
}

func (s *Primary_oclExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ATLListener); ok {
		listenerT.ExitPrimary_oclExpression(s)
	}
}

func (p *ATLParser) Primary_oclExpression() (localctx IPrimary_oclExpressionContext) {
	this := p
	_ = this

	localctx = NewPrimary_oclExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ATLParserRULE_primary_oclExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1018)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1004)
			p.VariableExp()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1005)
			p.OclUndefinedExp()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1006)
			p.PrimitiveExp()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1007)
			p.IfExp()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1008)
			p.SuperExp()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1009)
			p.EnumLiteralExp()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1010)
			p.CollectionExp()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1011)
			p.MapExp()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1012)
			p.TupleExp()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1013)
			p.OclType()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1014)
			p.Match(ATLParserT__14)
		}
		{
			p.SetState(1015)
			p.OclExpression()
		}
		{
			p.SetState(1016)
			p.Match(ATLParserT__15)
		}

	}

	return localctx
}
