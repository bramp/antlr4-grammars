// Code generated from ObjectiveCParser.g4 by ANTLR 4.9.3. DO NOT EDIT.

package objectivec // ObjectiveCParser
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 224, 1703,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 3, 2, 7, 2, 292, 10, 2,
	12, 2, 14, 2, 295, 11, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 310, 10, 3, 3, 4, 3, 4, 3, 4, 3,
	4, 3, 5, 5, 5, 317, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 323, 10, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 5, 5, 329, 10, 5, 3, 5, 5, 5, 332, 10, 5, 3, 5, 5,
	5, 335, 10, 5, 3, 5, 3, 5, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 343, 10, 6, 3,
	6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 350, 10, 6, 3, 6, 5, 6, 353, 10, 6, 3,
	6, 5, 6, 356, 10, 6, 3, 6, 3, 6, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 364, 10,
	7, 3, 7, 5, 7, 367, 10, 7, 3, 7, 5, 7, 370, 10, 7, 3, 7, 3, 7, 3, 8, 3,
	8, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 380, 10, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3,
	9, 3, 9, 3, 9, 3, 9, 5, 9, 390, 10, 9, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10,
	3, 10, 5, 10, 398, 10, 10, 3, 10, 7, 10, 401, 10, 10, 12, 10, 14, 10, 404,
	11, 10, 3, 10, 3, 10, 3, 11, 3, 11, 7, 11, 410, 10, 11, 12, 11, 14, 11,
	413, 11, 11, 3, 11, 6, 11, 416, 10, 11, 13, 11, 14, 11, 417, 5, 11, 420,
	10, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 13, 3, 13, 3, 13, 3, 13, 7, 13,
	430, 10, 13, 12, 13, 14, 13, 433, 11, 13, 3, 13, 3, 13, 3, 14, 3, 14, 3,
	14, 7, 14, 440, 10, 14, 12, 14, 14, 14, 443, 11, 14, 3, 15, 3, 15, 3, 15,
	3, 15, 3, 15, 5, 15, 450, 10, 15, 3, 15, 5, 15, 453, 10, 15, 3, 15, 5,
	15, 456, 10, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3, 16, 7, 16, 463, 10, 16,
	12, 16, 14, 16, 466, 11, 16, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17,
	3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3,
	17, 3, 17, 3, 17, 3, 17, 5, 17, 488, 10, 17, 3, 18, 3, 18, 3, 18, 3, 18,
	3, 18, 5, 18, 495, 10, 18, 3, 18, 5, 18, 498, 10, 18, 3, 19, 3, 19, 7,
	19, 502, 10, 19, 12, 19, 14, 19, 505, 11, 19, 3, 19, 3, 19, 3, 20, 3, 20,
	7, 20, 511, 10, 20, 12, 20, 14, 20, 514, 11, 20, 3, 20, 6, 20, 517, 10,
	20, 13, 20, 14, 20, 518, 5, 20, 521, 10, 20, 3, 21, 3, 21, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 6, 22, 530, 10, 22, 13, 22, 14, 22, 531, 3, 23, 3,
	23, 3, 23, 3, 24, 3, 24, 3, 24, 3, 25, 5, 25, 541, 10, 25, 3, 25, 3, 25,
	5, 25, 545, 10, 25, 3, 25, 3, 25, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 6,
	26, 554, 10, 26, 13, 26, 14, 26, 555, 3, 27, 3, 27, 3, 27, 3, 28, 3, 28,
	3, 28, 3, 29, 5, 29, 565, 10, 29, 3, 29, 3, 29, 5, 29, 569, 10, 29, 3,
	29, 5, 29, 572, 10, 29, 3, 29, 3, 29, 3, 30, 3, 30, 6, 30, 578, 10, 30,
	13, 30, 14, 30, 579, 3, 30, 3, 30, 5, 30, 584, 10, 30, 5, 30, 586, 10,
	30, 3, 31, 5, 31, 589, 10, 31, 3, 31, 3, 31, 7, 31, 593, 10, 31, 12, 31,
	14, 31, 596, 11, 31, 3, 31, 5, 31, 599, 10, 31, 3, 31, 3, 31, 3, 32, 3,
	32, 5, 32, 605, 10, 32, 3, 33, 3, 33, 3, 33, 3, 33, 3, 34, 3, 34, 3, 34,
	3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 619, 10, 34, 3, 35, 3, 35, 3,
	35, 7, 35, 624, 10, 35, 12, 35, 14, 35, 627, 11, 35, 3, 36, 3, 36, 3, 36,
	5, 36, 632, 10, 36, 3, 37, 5, 37, 635, 10, 37, 3, 37, 3, 37, 5, 37, 639,
	10, 37, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 645, 10, 37, 3, 37, 3, 37, 5,
	37, 649, 10, 37, 3, 38, 3, 38, 3, 38, 3, 38, 7, 38, 655, 10, 38, 12, 38,
	14, 38, 658, 11, 38, 5, 38, 660, 10, 38, 3, 38, 3, 38, 3, 39, 7, 39, 665,
	10, 39, 12, 39, 14, 39, 668, 11, 39, 3, 39, 3, 39, 5, 39, 672, 10, 39,
	3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 7, 40, 679, 10, 40, 12, 40, 14, 40,
	682, 11, 40, 3, 40, 5, 40, 685, 10, 40, 5, 40, 687, 10, 40, 3, 40, 3, 40,
	3, 41, 3, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 699, 10,
	42, 5, 42, 701, 10, 42, 3, 42, 3, 42, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43,
	3, 43, 3, 43, 3, 43, 5, 43, 713, 10, 43, 5, 43, 715, 10, 43, 3, 44, 3,
	44, 3, 44, 5, 44, 720, 10, 44, 3, 44, 3, 44, 7, 44, 724, 10, 44, 12, 44,
	14, 44, 727, 11, 44, 5, 44, 729, 10, 44, 3, 44, 3, 44, 3, 45, 3, 45, 5,
	45, 735, 10, 45, 3, 46, 3, 46, 5, 46, 739, 10, 46, 3, 46, 5, 46, 742, 10,
	46, 3, 46, 5, 46, 745, 10, 46, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 3, 47,
	3, 47, 3, 48, 3, 48, 5, 48, 756, 10, 48, 3, 49, 3, 49, 6, 49, 760, 10,
	49, 13, 49, 14, 49, 761, 5, 49, 764, 10, 49, 3, 50, 5, 50, 767, 10, 50,
	3, 50, 3, 50, 3, 50, 3, 50, 7, 50, 773, 10, 50, 12, 50, 14, 50, 776, 11,
	50, 3, 51, 3, 51, 5, 51, 780, 10, 51, 3, 51, 3, 51, 3, 51, 3, 51, 5, 51,
	786, 10, 51, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 53, 3, 53, 5, 53, 795,
	10, 53, 3, 53, 6, 53, 798, 10, 53, 13, 53, 14, 53, 799, 5, 53, 802, 10,
	53, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55,
	3, 56, 3, 56, 3, 56, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 5,
	57, 824, 10, 57, 3, 58, 3, 58, 3, 58, 7, 58, 829, 10, 58, 12, 58, 14, 58,
	832, 11, 58, 3, 58, 3, 58, 5, 58, 836, 10, 58, 3, 59, 3, 59, 3, 59, 3,
	59, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 61, 3, 61,
	3, 61, 3, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3, 63, 3, 64, 5, 64, 860, 10,
	64, 3, 64, 3, 64, 3, 64, 5, 64, 865, 10, 64, 3, 64, 3, 64, 3, 64, 5, 64,
	870, 10, 64, 3, 65, 3, 65, 5, 65, 874, 10, 65, 3, 66, 3, 66, 5, 66, 878,
	10, 66, 3, 67, 3, 67, 5, 67, 882, 10, 67, 3, 67, 3, 67, 3, 68, 3, 68, 3,
	68, 7, 68, 889, 10, 68, 12, 68, 14, 68, 892, 11, 68, 3, 69, 3, 69, 3, 69,
	3, 69, 5, 69, 898, 10, 69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 5, 70, 905,
	10, 70, 3, 71, 3, 71, 3, 71, 3, 71, 5, 71, 911, 10, 71, 3, 72, 5, 72, 914,
	10, 72, 3, 72, 3, 72, 5, 72, 918, 10, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3,
	72, 3, 73, 5, 73, 926, 10, 73, 3, 73, 5, 73, 929, 10, 73, 3, 73, 3, 73,
	5, 73, 933, 10, 73, 3, 73, 3, 73, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 941,
	10, 74, 3, 74, 3, 74, 3, 75, 5, 75, 946, 10, 75, 3, 75, 3, 75, 3, 75, 3,
	75, 3, 75, 5, 75, 953, 10, 75, 3, 75, 3, 75, 3, 76, 3, 76, 3, 76, 7, 76,
	960, 10, 76, 12, 76, 14, 76, 963, 11, 76, 3, 77, 5, 77, 966, 10, 77, 3,
	77, 3, 77, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 6, 78,
	978, 10, 78, 13, 78, 14, 78, 979, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3,
	79, 7, 79, 988, 10, 79, 12, 79, 14, 79, 991, 11, 79, 3, 79, 3, 79, 3, 79,
	3, 80, 3, 80, 3, 80, 7, 80, 999, 10, 80, 12, 80, 14, 80, 1002, 11, 80,
	3, 81, 3, 81, 3, 81, 5, 81, 1007, 10, 81, 3, 82, 3, 82, 3, 82, 5, 82, 1012,
	10, 82, 3, 82, 3, 82, 6, 82, 1016, 10, 82, 13, 82, 14, 82, 1017, 3, 82,
	3, 82, 5, 82, 1022, 10, 82, 3, 83, 3, 83, 3, 83, 5, 83, 1027, 10, 83, 3,
	83, 3, 83, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 6, 84, 1037, 10, 84,
	13, 84, 14, 84, 1038, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 5, 85,
	1047, 10, 85, 3, 86, 3, 86, 3, 87, 3, 87, 3, 88, 3, 88, 3, 89, 3, 89, 3,
	90, 3, 90, 3, 90, 3, 90, 5, 90, 1061, 10, 90, 3, 91, 3, 91, 3, 92, 3, 92,
	3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3,
	92, 3, 92, 3, 92, 5, 92, 1080, 10, 92, 5, 92, 1082, 10, 92, 3, 93, 3, 93,
	3, 93, 3, 93, 3, 93, 3, 94, 3, 94, 3, 94, 7, 94, 1092, 10, 94, 12, 94,
	14, 94, 1095, 11, 94, 3, 95, 3, 95, 5, 95, 1099, 10, 95, 3, 95, 3, 95,
	5, 95, 1103, 10, 95, 3, 96, 3, 96, 5, 96, 1107, 10, 96, 3, 96, 3, 96, 5,
	96, 1111, 10, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 5, 96, 1118, 10, 96,
	3, 96, 3, 96, 3, 96, 3, 96, 5, 96, 1124, 10, 96, 3, 96, 3, 96, 3, 96, 3,
	96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 5, 96, 1136, 10, 96, 3, 97,
	3, 97, 3, 97, 7, 97, 1141, 10, 97, 12, 97, 14, 97, 1144, 11, 97, 3, 97,
	5, 97, 1147, 10, 97, 3, 98, 3, 98, 3, 98, 5, 98, 1152, 10, 98, 3, 99, 3,
	99, 5, 99, 1156, 10, 99, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 5, 100,
	1163, 10, 100, 3, 100, 7, 100, 1166, 10, 100, 12, 100, 14, 100, 1169, 11,
	100, 3, 100, 3, 100, 3, 100, 5, 100, 1174, 10, 100, 3, 100, 5, 100, 1177,
	10, 100, 3, 100, 3, 100, 5, 100, 1181, 10, 100, 3, 101, 3, 101, 5, 101,
	1185, 10, 101, 3, 101, 3, 101, 3, 102, 3, 102, 3, 102, 5, 102, 1192, 10,
	102, 3, 103, 3, 103, 5, 103, 1196, 10, 103, 3, 103, 5, 103, 1199, 10, 103,
	3, 104, 3, 104, 3, 104, 3, 104, 3, 104, 7, 104, 1206, 10, 104, 12, 104,
	14, 104, 1209, 11, 104, 3, 104, 3, 104, 5, 104, 1213, 10, 104, 3, 105,
	3, 105, 3, 105, 5, 105, 1218, 10, 105, 5, 105, 1220, 10, 105, 3, 105, 3,
	105, 3, 106, 3, 106, 3, 106, 3, 106, 3, 106, 3, 106, 7, 106, 1230, 10,
	106, 12, 106, 14, 106, 1233, 11, 106, 3, 106, 5, 106, 1236, 10, 106, 5,
	106, 1238, 10, 106, 3, 106, 3, 106, 3, 107, 3, 107, 3, 107, 7, 107, 1245,
	10, 107, 12, 107, 14, 107, 1248, 11, 107, 3, 107, 5, 107, 1251, 10, 107,
	3, 108, 3, 108, 5, 108, 1255, 10, 108, 3, 108, 5, 108, 1258, 10, 108, 3,
	109, 3, 109, 5, 109, 1262, 10, 109, 3, 109, 3, 109, 5, 109, 1266, 10, 109,
	3, 109, 3, 109, 6, 109, 1270, 10, 109, 13, 109, 14, 109, 1271, 3, 109,
	3, 109, 5, 109, 1276, 10, 109, 3, 109, 6, 109, 1279, 10, 109, 13, 109,
	14, 109, 1280, 5, 109, 1283, 10, 109, 3, 110, 3, 110, 5, 110, 1287, 10,
	110, 3, 110, 3, 110, 3, 110, 5, 110, 1292, 10, 110, 3, 110, 5, 110, 1295,
	10, 110, 3, 111, 3, 111, 3, 111, 7, 111, 1300, 10, 111, 12, 111, 14, 111,
	1303, 11, 111, 3, 112, 3, 112, 3, 112, 3, 112, 5, 112, 1309, 10, 112, 3,
	113, 5, 113, 1312, 10, 113, 3, 113, 3, 113, 3, 114, 3, 114, 5, 114, 1318,
	10, 114, 3, 114, 3, 114, 5, 114, 1322, 10, 114, 3, 114, 3, 114, 5, 114,
	1326, 10, 114, 3, 114, 3, 114, 5, 114, 1330, 10, 114, 3, 114, 3, 114, 5,
	114, 1334, 10, 114, 3, 114, 3, 114, 5, 114, 1338, 10, 114, 3, 114, 3, 114,
	5, 114, 1342, 10, 114, 3, 114, 3, 114, 5, 114, 1346, 10, 114, 3, 114, 3,
	114, 5, 114, 1350, 10, 114, 3, 114, 3, 114, 5, 114, 1354, 10, 114, 3, 114,
	5, 114, 1357, 10, 114, 3, 115, 3, 115, 3, 115, 3, 115, 3, 116, 3, 116,
	3, 116, 5, 116, 1366, 10, 116, 3, 117, 3, 117, 3, 117, 7, 117, 1371, 10,
	117, 12, 117, 14, 117, 1374, 11, 117, 3, 117, 3, 117, 3, 118, 3, 118, 3,
	118, 3, 118, 3, 118, 3, 118, 3, 118, 5, 118, 1385, 10, 118, 3, 118, 5,
	118, 1388, 10, 118, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3,
	120, 3, 120, 7, 120, 1398, 10, 120, 12, 120, 14, 120, 1401, 11, 120, 3,
	120, 3, 120, 3, 121, 6, 121, 1406, 10, 121, 13, 121, 14, 121, 1407, 3,
	121, 6, 121, 1411, 10, 121, 13, 121, 14, 121, 1412, 3, 122, 3, 122, 3,
	122, 3, 122, 3, 122, 3, 122, 5, 122, 1421, 10, 122, 3, 122, 3, 122, 3,
	122, 3, 122, 5, 122, 1427, 10, 122, 3, 123, 3, 123, 3, 123, 3, 123, 5,
	123, 1433, 10, 123, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3,
	125, 3, 125, 3, 125, 3, 125, 3, 125, 3, 125, 3, 125, 3, 125, 3, 126, 3,
	126, 3, 126, 5, 126, 1452, 10, 126, 3, 126, 3, 126, 5, 126, 1456, 10, 126,
	3, 126, 3, 126, 5, 126, 1460, 10, 126, 3, 126, 3, 126, 3, 126, 3, 127,
	3, 127, 3, 127, 3, 127, 5, 127, 1469, 10, 127, 3, 128, 3, 128, 3, 128,
	3, 128, 3, 128, 5, 128, 1476, 10, 128, 3, 128, 3, 128, 3, 128, 3, 129,
	3, 129, 3, 129, 3, 129, 3, 129, 3, 129, 5, 129, 1487, 10, 129, 5, 129,
	1489, 10, 129, 3, 130, 3, 130, 3, 130, 7, 130, 1494, 10, 130, 12, 130,
	14, 130, 1497, 11, 130, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131,
	3, 131, 3, 131, 3, 131, 3, 131, 5, 131, 1509, 10, 131, 3, 131, 3, 131,
	3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131,
	5, 131, 1522, 10, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131,
	3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131,
	3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131,
	3, 131, 5, 131, 1549, 10, 131, 3, 131, 3, 131, 7, 131, 1553, 10, 131, 12,
	131, 14, 131, 1556, 11, 131, 3, 132, 3, 132, 3, 133, 3, 133, 3, 133, 3,
	133, 3, 133, 3, 133, 3, 133, 5, 133, 1567, 10, 133, 5, 133, 1569, 10, 133,
	3, 134, 3, 134, 3, 134, 5, 134, 1574, 10, 134, 3, 135, 3, 135, 5, 135,
	1578, 10, 135, 3, 136, 3, 136, 3, 136, 3, 136, 3, 136, 3, 136, 3, 136,
	5, 136, 1587, 10, 136, 3, 136, 3, 136, 3, 136, 3, 136, 3, 136, 5, 136,
	1594, 10, 136, 3, 137, 3, 137, 3, 138, 3, 138, 3, 138, 7, 138, 1601, 10,
	138, 12, 138, 14, 138, 1604, 11, 138, 3, 138, 3, 138, 3, 138, 3, 138, 7,
	138, 1610, 10, 138, 12, 138, 14, 138, 1613, 11, 138, 7, 138, 1615, 10,
	138, 12, 138, 14, 138, 1618, 11, 138, 3, 139, 3, 139, 3, 139, 3, 139, 3,
	139, 3, 139, 5, 139, 1626, 10, 139, 3, 139, 3, 139, 3, 139, 3, 139, 6,
	139, 1632, 10, 139, 13, 139, 14, 139, 1633, 3, 139, 3, 139, 5, 139, 1638,
	10, 139, 3, 140, 3, 140, 3, 140, 7, 140, 1643, 10, 140, 12, 140, 14, 140,
	1646, 11, 140, 3, 141, 3, 141, 5, 141, 1650, 10, 141, 3, 142, 3, 142, 3,
	142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3,
	142, 3, 142, 3, 142, 3, 142, 5, 142, 1667, 10, 142, 3, 143, 3, 143, 3,
	143, 3, 143, 5, 143, 1673, 10, 143, 3, 143, 3, 143, 5, 143, 1677, 10, 143,
	3, 143, 3, 143, 3, 143, 3, 143, 3, 143, 3, 143, 3, 143, 3, 143, 5, 143,
	1687, 10, 143, 3, 144, 3, 144, 7, 144, 1691, 10, 144, 12, 144, 14, 144,
	1694, 11, 144, 3, 144, 6, 144, 1697, 10, 144, 13, 144, 14, 144, 1698, 3,
	145, 3, 145, 3, 145, 2, 4, 260, 274, 146, 2, 4, 6, 8, 10, 12, 14, 16, 18,
	20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54,
	56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90,
	92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
	122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
	152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
	182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210,
	212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240,
	242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270,
	272, 274, 276, 278, 280, 282, 284, 286, 288, 2, 23, 4, 2, 72, 72, 77, 77,
	3, 2, 92, 93, 5, 2, 70, 70, 73, 73, 75, 76, 4, 2, 29, 29, 32, 32, 6, 2,
	87, 87, 96, 96, 98, 98, 100, 100, 3, 2, 101, 104, 6, 2, 3, 3, 14, 14, 22,
	22, 28, 28, 6, 2, 19, 19, 88, 91, 95, 95, 105, 105, 5, 2, 44, 45, 48, 49,
	53, 54, 3, 2, 106, 107, 4, 2, 156, 157, 161, 161, 3, 2, 154, 155, 4, 2,
	140, 141, 147, 148, 4, 2, 146, 146, 149, 149, 4, 2, 139, 139, 162, 171,
	3, 2, 152, 153, 5, 2, 142, 143, 154, 156, 158, 158, 3, 2, 136, 137, 3,
	2, 129, 129, 4, 2, 185, 185, 187, 187, 10, 2, 42, 49, 53, 58, 83, 85, 87,
	88, 90, 95, 99, 99, 101, 120, 127, 127, 2, 1888, 2, 293, 3, 2, 2, 2, 4,
	309, 3, 2, 2, 2, 6, 311, 3, 2, 2, 2, 8, 316, 3, 2, 2, 2, 10, 338, 3, 2,
	2, 2, 12, 359, 3, 2, 2, 2, 14, 373, 3, 2, 2, 2, 16, 383, 3, 2, 2, 2, 18,
	391, 3, 2, 2, 2, 20, 419, 3, 2, 2, 2, 22, 421, 3, 2, 2, 2, 24, 425, 3,
	2, 2, 2, 26, 436, 3, 2, 2, 2, 28, 444, 3, 2, 2, 2, 30, 459, 3, 2, 2, 2,
	32, 487, 3, 2, 2, 2, 34, 497, 3, 2, 2, 2, 36, 499, 3, 2, 2, 2, 38, 520,
	3, 2, 2, 2, 40, 522, 3, 2, 2, 2, 42, 529, 3, 2, 2, 2, 44, 533, 3, 2, 2,
	2, 46, 536, 3, 2, 2, 2, 48, 540, 3, 2, 2, 2, 50, 553, 3, 2, 2, 2, 52, 557,
	3, 2, 2, 2, 54, 560, 3, 2, 2, 2, 56, 564, 3, 2, 2, 2, 58, 585, 3, 2, 2,
	2, 60, 588, 3, 2, 2, 2, 62, 604, 3, 2, 2, 2, 64, 606, 3, 2, 2, 2, 66, 618,
	3, 2, 2, 2, 68, 620, 3, 2, 2, 2, 70, 628, 3, 2, 2, 2, 72, 634, 3, 2, 2,
	2, 74, 650, 3, 2, 2, 2, 76, 671, 3, 2, 2, 2, 78, 673, 3, 2, 2, 2, 80, 690,
	3, 2, 2, 2, 82, 694, 3, 2, 2, 2, 84, 714, 3, 2, 2, 2, 86, 716, 3, 2, 2,
	2, 88, 734, 3, 2, 2, 2, 90, 736, 3, 2, 2, 2, 92, 748, 3, 2, 2, 2, 94, 755,
	3, 2, 2, 2, 96, 763, 3, 2, 2, 2, 98, 766, 3, 2, 2, 2, 100, 777, 3, 2, 2,
	2, 102, 787, 3, 2, 2, 2, 104, 801, 3, 2, 2, 2, 106, 803, 3, 2, 2, 2, 108,
	808, 3, 2, 2, 2, 110, 813, 3, 2, 2, 2, 112, 823, 3, 2, 2, 2, 114, 825,
	3, 2, 2, 2, 116, 837, 3, 2, 2, 2, 118, 843, 3, 2, 2, 2, 120, 849, 3, 2,
	2, 2, 122, 852, 3, 2, 2, 2, 124, 855, 3, 2, 2, 2, 126, 859, 3, 2, 2, 2,
	128, 871, 3, 2, 2, 2, 130, 877, 3, 2, 2, 2, 132, 879, 3, 2, 2, 2, 134,
	885, 3, 2, 2, 2, 136, 897, 3, 2, 2, 2, 138, 899, 3, 2, 2, 2, 140, 910,
	3, 2, 2, 2, 142, 913, 3, 2, 2, 2, 144, 925, 3, 2, 2, 2, 146, 940, 3, 2,
	2, 2, 148, 945, 3, 2, 2, 2, 150, 956, 3, 2, 2, 2, 152, 965, 3, 2, 2, 2,
	154, 977, 3, 2, 2, 2, 156, 981, 3, 2, 2, 2, 158, 995, 3, 2, 2, 2, 160,
	1003, 3, 2, 2, 2, 162, 1008, 3, 2, 2, 2, 164, 1023, 3, 2, 2, 2, 166, 1036,
	3, 2, 2, 2, 168, 1046, 3, 2, 2, 2, 170, 1048, 3, 2, 2, 2, 172, 1050, 3,
	2, 2, 2, 174, 1052, 3, 2, 2, 2, 176, 1054, 3, 2, 2, 2, 178, 1060, 3, 2,
	2, 2, 180, 1062, 3, 2, 2, 2, 182, 1081, 3, 2, 2, 2, 184, 1083, 3, 2, 2,
	2, 186, 1088, 3, 2, 2, 2, 188, 1102, 3, 2, 2, 2, 190, 1135, 3, 2, 2, 2,
	192, 1137, 3, 2, 2, 2, 194, 1148, 3, 2, 2, 2, 196, 1155, 3, 2, 2, 2, 198,
	1180, 3, 2, 2, 2, 200, 1182, 3, 2, 2, 2, 202, 1188, 3, 2, 2, 2, 204, 1193,
	3, 2, 2, 2, 206, 1200, 3, 2, 2, 2, 208, 1214, 3, 2, 2, 2, 210, 1223, 3,
	2, 2, 2, 212, 1241, 3, 2, 2, 2, 214, 1257, 3, 2, 2, 2, 216, 1282, 3, 2,
	2, 2, 218, 1294, 3, 2, 2, 2, 220, 1296, 3, 2, 2, 2, 222, 1308, 3, 2, 2,
	2, 224, 1311, 3, 2, 2, 2, 226, 1356, 3, 2, 2, 2, 228, 1358, 3, 2, 2, 2,
	230, 1362, 3, 2, 2, 2, 232, 1367, 3, 2, 2, 2, 234, 1387, 3, 2, 2, 2, 236,
	1389, 3, 2, 2, 2, 238, 1395, 3, 2, 2, 2, 240, 1405, 3, 2, 2, 2, 242, 1426,
	3, 2, 2, 2, 244, 1432, 3, 2, 2, 2, 246, 1434, 3, 2, 2, 2, 248, 1440, 3,
	2, 2, 2, 250, 1448, 3, 2, 2, 2, 252, 1468, 3, 2, 2, 2, 254, 1470, 3, 2,
	2, 2, 256, 1488, 3, 2, 2, 2, 258, 1490, 3, 2, 2, 2, 260, 1508, 3, 2, 2,
	2, 262, 1557, 3, 2, 2, 2, 264, 1568, 3, 2, 2, 2, 266, 1573, 3, 2, 2, 2,
	268, 1577, 3, 2, 2, 2, 270, 1593, 3, 2, 2, 2, 272, 1595, 3, 2, 2, 2, 274,
	1597, 3, 2, 2, 2, 276, 1637, 3, 2, 2, 2, 278, 1639, 3, 2, 2, 2, 280, 1649,
	3, 2, 2, 2, 282, 1666, 3, 2, 2, 2, 284, 1686, 3, 2, 2, 2, 286, 1696, 3,
	2, 2, 2, 288, 1700, 3, 2, 2, 2, 290, 292, 5, 4, 3, 2, 291, 290, 3, 2, 2,
	2, 292, 295, 3, 2, 2, 2, 293, 291, 3, 2, 2, 2, 293, 294, 3, 2, 2, 2, 294,
	296, 3, 2, 2, 2, 295, 293, 3, 2, 2, 2, 296, 297, 7, 2, 2, 3, 297, 3, 3,
	2, 2, 2, 298, 310, 5, 6, 4, 2, 299, 310, 5, 122, 62, 2, 300, 310, 5, 140,
	71, 2, 301, 310, 5, 8, 5, 2, 302, 310, 5, 12, 7, 2, 303, 310, 5, 10, 6,
	2, 304, 310, 5, 14, 8, 2, 305, 310, 5, 18, 10, 2, 306, 310, 5, 22, 12,
	2, 307, 310, 5, 24, 13, 2, 308, 310, 5, 124, 63, 2, 309, 298, 3, 2, 2,
	2, 309, 299, 3, 2, 2, 2, 309, 300, 3, 2, 2, 2, 309, 301, 3, 2, 2, 2, 309,
	302, 3, 2, 2, 2, 309, 303, 3, 2, 2, 2, 309, 304, 3, 2, 2, 2, 309, 305,
	3, 2, 2, 2, 309, 306, 3, 2, 2, 2, 309, 307, 3, 2, 2, 2, 309, 308, 3, 2,
	2, 2, 310, 5, 3, 2, 2, 2, 311, 312, 7, 69, 2, 2, 312, 313, 5, 288, 145,
	2, 313, 314, 7, 134, 2, 2, 314, 7, 3, 2, 2, 2, 315, 317, 7, 120, 2, 2,
	316, 315, 3, 2, 2, 2, 316, 317, 3, 2, 2, 2, 317, 318, 3, 2, 2, 2, 318,
	319, 7, 68, 2, 2, 319, 322, 5, 16, 9, 2, 320, 321, 7, 145, 2, 2, 321, 323,
	5, 288, 145, 2, 322, 320, 3, 2, 2, 2, 322, 323, 3, 2, 2, 2, 323, 328, 3,
	2, 2, 2, 324, 325, 7, 141, 2, 2, 325, 326, 5, 26, 14, 2, 326, 327, 7, 140,
	2, 2, 327, 329, 3, 2, 2, 2, 328, 324, 3, 2, 2, 2, 328, 329, 3, 2, 2, 2,
	329, 331, 3, 2, 2, 2, 330, 332, 5, 36, 19, 2, 331, 330, 3, 2, 2, 2, 331,
	332, 3, 2, 2, 2, 332, 334, 3, 2, 2, 2, 333, 335, 5, 42, 22, 2, 334, 333,
	3, 2, 2, 2, 334, 335, 3, 2, 2, 2, 335, 336, 3, 2, 2, 2, 336, 337, 7, 65,
	2, 2, 337, 9, 3, 2, 2, 2, 338, 339, 7, 68, 2, 2, 339, 340, 5, 16, 9, 2,
	340, 342, 7, 128, 2, 2, 341, 343, 5, 288, 145, 2, 342, 341, 3, 2, 2, 2,
	342, 343, 3, 2, 2, 2, 343, 344, 3, 2, 2, 2, 344, 349, 7, 129, 2, 2, 345,
	346, 7, 141, 2, 2, 346, 347, 5, 26, 14, 2, 347, 348, 7, 140, 2, 2, 348,
	350, 3, 2, 2, 2, 349, 345, 3, 2, 2, 2, 349, 350, 3, 2, 2, 2, 350, 352,
	3, 2, 2, 2, 351, 353, 5, 36, 19, 2, 352, 351, 3, 2, 2, 2, 352, 353, 3,
	2, 2, 2, 353, 355, 3, 2, 2, 2, 354, 356, 5, 42, 22, 2, 355, 354, 3, 2,
	2, 2, 355, 356, 3, 2, 2, 2, 356, 357, 3, 2, 2, 2, 357, 358, 7, 65, 2, 2,
	358, 11, 3, 2, 2, 2, 359, 360, 7, 67, 2, 2, 360, 363, 5, 16, 9, 2, 361,
	362, 7, 145, 2, 2, 362, 364, 5, 288, 145, 2, 363, 361, 3, 2, 2, 2, 363,
	364, 3, 2, 2, 2, 364, 366, 3, 2, 2, 2, 365, 367, 5, 36, 19, 2, 366, 365,
	3, 2, 2, 2, 366, 367, 3, 2, 2, 2, 367, 369, 3, 2, 2, 2, 368, 370, 5, 50,
	26, 2, 369, 368, 3, 2, 2, 2, 369, 370, 3, 2, 2, 2, 370, 371, 3, 2, 2, 2,
	371, 372, 7, 65, 2, 2, 372, 13, 3, 2, 2, 2, 373, 374, 7, 67, 2, 2, 374,
	375, 5, 16, 9, 2, 375, 376, 7, 128, 2, 2, 376, 377, 5, 288, 145, 2, 377,
	379, 7, 129, 2, 2, 378, 380, 5, 50, 26, 2, 379, 378, 3, 2, 2, 2, 379, 380,
	3, 2, 2, 2, 380, 381, 3, 2, 2, 2, 381, 382, 7, 65, 2, 2, 382, 15, 3, 2,
	2, 2, 383, 389, 5, 288, 145, 2, 384, 385, 7, 141, 2, 2, 385, 386, 5, 26,
	14, 2, 386, 387, 7, 140, 2, 2, 387, 390, 3, 2, 2, 2, 388, 390, 5, 74, 38,
	2, 389, 384, 3, 2, 2, 2, 389, 388, 3, 2, 2, 2, 389, 390, 3, 2, 2, 2, 390,
	17, 3, 2, 2, 2, 391, 392, 7, 71, 2, 2, 392, 397, 5, 34, 18, 2, 393, 394,
	7, 141, 2, 2, 394, 395, 5, 26, 14, 2, 395, 396, 7, 140, 2, 2, 396, 398,
	3, 2, 2, 2, 397, 393, 3, 2, 2, 2, 397, 398, 3, 2, 2, 2, 398, 402, 3, 2,
	2, 2, 399, 401, 5, 20, 11, 2, 400, 399, 3, 2, 2, 2, 401, 404, 3, 2, 2,
	2, 402, 400, 3, 2, 2, 2, 402, 403, 3, 2, 2, 2, 403, 405, 3, 2, 2, 2, 404,
	402, 3, 2, 2, 2, 405, 406, 7, 65, 2, 2, 406, 19, 3, 2, 2, 2, 407, 411,
	9, 2, 2, 2, 408, 410, 5, 42, 22, 2, 409, 408, 3, 2, 2, 2, 410, 413, 3,
	2, 2, 2, 411, 409, 3, 2, 2, 2, 411, 412, 3, 2, 2, 2, 412, 420, 3, 2, 2,
	2, 413, 411, 3, 2, 2, 2, 414, 416, 5, 42, 22, 2, 415, 414, 3, 2, 2, 2,
	416, 417, 3, 2, 2, 2, 417, 415, 3, 2, 2, 2, 417, 418, 3, 2, 2, 2, 418,
	420, 3, 2, 2, 2, 419, 407, 3, 2, 2, 2, 419, 415, 3, 2, 2, 2, 420, 21, 3,
	2, 2, 2, 421, 422, 7, 71, 2, 2, 422, 423, 5, 26, 14, 2, 423, 424, 7, 134,
	2, 2, 424, 23, 3, 2, 2, 2, 425, 426, 7, 62, 2, 2, 426, 431, 5, 288, 145,
	2, 427, 428, 7, 135, 2, 2, 428, 430, 5, 288, 145, 2, 429, 427, 3, 2, 2,
	2, 430, 433, 3, 2, 2, 2, 431, 429, 3, 2, 2, 2, 431, 432, 3, 2, 2, 2, 432,
	434, 3, 2, 2, 2, 433, 431, 3, 2, 2, 2, 434, 435, 7, 134, 2, 2, 435, 25,
	3, 2, 2, 2, 436, 441, 5, 34, 18, 2, 437, 438, 7, 135, 2, 2, 438, 440, 5,
	34, 18, 2, 439, 437, 3, 2, 2, 2, 440, 443, 3, 2, 2, 2, 441, 439, 3, 2,
	2, 2, 441, 442, 3, 2, 2, 2, 442, 27, 3, 2, 2, 2, 443, 441, 3, 2, 2, 2,
	444, 449, 7, 74, 2, 2, 445, 446, 7, 128, 2, 2, 446, 447, 5, 30, 16, 2,
	447, 448, 7, 129, 2, 2, 448, 450, 3, 2, 2, 2, 449, 445, 3, 2, 2, 2, 449,
	450, 3, 2, 2, 2, 450, 452, 3, 2, 2, 2, 451, 453, 5, 168, 85, 2, 452, 451,
	3, 2, 2, 2, 452, 453, 3, 2, 2, 2, 453, 455, 3, 2, 2, 2, 454, 456, 7, 119,
	2, 2, 455, 454, 3, 2, 2, 2, 455, 456, 3, 2, 2, 2, 456, 457, 3, 2, 2, 2,
	457, 458, 5, 164, 83, 2, 458, 29, 3, 2, 2, 2, 459, 464, 5, 32, 17, 2, 460,
	461, 7, 135, 2, 2, 461, 463, 5, 32, 17, 2, 462, 460, 3, 2, 2, 2, 463, 466,
	3, 2, 2, 2, 464, 462, 3, 2, 2, 2, 464, 465, 3, 2, 2, 2, 465, 31, 3, 2,
	2, 2, 466, 464, 3, 2, 2, 2, 467, 488, 7, 83, 2, 2, 468, 488, 7, 84, 2,
	2, 469, 488, 7, 112, 2, 2, 470, 488, 7, 115, 2, 2, 471, 488, 7, 85, 2,
	2, 472, 488, 7, 108, 2, 2, 473, 488, 7, 116, 2, 2, 474, 488, 7, 109, 2,
	2, 475, 488, 7, 113, 2, 2, 476, 488, 7, 114, 2, 2, 477, 478, 7, 110, 2,
	2, 478, 479, 7, 139, 2, 2, 479, 488, 5, 288, 145, 2, 480, 481, 7, 111,
	2, 2, 481, 482, 7, 139, 2, 2, 482, 483, 5, 288, 145, 2, 483, 484, 7, 145,
	2, 2, 484, 488, 3, 2, 2, 2, 485, 488, 5, 172, 87, 2, 486, 488, 5, 288,
	145, 2, 487, 467, 3, 2, 2, 2, 487, 468, 3, 2, 2, 2, 487, 469, 3, 2, 2,
	2, 487, 470, 3, 2, 2, 2, 487, 471, 3, 2, 2, 2, 487, 472, 3, 2, 2, 2, 487,
	473, 3, 2, 2, 2, 487, 474, 3, 2, 2, 2, 487, 475, 3, 2, 2, 2, 487, 476,
	3, 2, 2, 2, 487, 477, 3, 2, 2, 2, 487, 480, 3, 2, 2, 2, 487, 485, 3, 2,
	2, 2, 487, 486, 3, 2, 2, 2, 488, 33, 3, 2, 2, 2, 489, 490, 7, 141, 2, 2,
	490, 491, 5, 26, 14, 2, 491, 492, 7, 140, 2, 2, 492, 498, 3, 2, 2, 2, 493,
	495, 9, 3, 2, 2, 494, 493, 3, 2, 2, 2, 494, 495, 3, 2, 2, 2, 495, 496,
	3, 2, 2, 2, 496, 498, 5, 288, 145, 2, 497, 489, 3, 2, 2, 2, 497, 494, 3,
	2, 2, 2, 498, 35, 3, 2, 2, 2, 499, 503, 7, 130, 2, 2, 500, 502, 5, 38,
	20, 2, 501, 500, 3, 2, 2, 2, 502, 505, 3, 2, 2, 2, 503, 501, 3, 2, 2, 2,
	503, 504, 3, 2, 2, 2, 504, 506, 3, 2, 2, 2, 505, 503, 3, 2, 2, 2, 506,
	507, 7, 131, 2, 2, 507, 37, 3, 2, 2, 2, 508, 512, 5, 40, 21, 2, 509, 511,
	5, 164, 83, 2, 510, 509, 3, 2, 2, 2, 511, 514, 3, 2, 2, 2, 512, 510, 3,
	2, 2, 2, 512, 513, 3, 2, 2, 2, 513, 521, 3, 2, 2, 2, 514, 512, 3, 2, 2,
	2, 515, 517, 5, 164, 83, 2, 516, 515, 3, 2, 2, 2, 517, 518, 3, 2, 2, 2,
	518, 516, 3, 2, 2, 2, 518, 519, 3, 2, 2, 2, 519, 521, 3, 2, 2, 2, 520,
	508, 3, 2, 2, 2, 520, 516, 3, 2, 2, 2, 521, 39, 3, 2, 2, 2, 522, 523, 9,
	4, 2, 2, 523, 41, 3, 2, 2, 2, 524, 530, 5, 140, 71, 2, 525, 530, 5, 44,
	23, 2, 526, 530, 5, 46, 24, 2, 527, 530, 5, 28, 15, 2, 528, 530, 5, 122,
	62, 2, 529, 524, 3, 2, 2, 2, 529, 525, 3, 2, 2, 2, 529, 526, 3, 2, 2, 2,
	529, 527, 3, 2, 2, 2, 529, 528, 3, 2, 2, 2, 530, 531, 3, 2, 2, 2, 531,
	529, 3, 2, 2, 2, 531, 532, 3, 2, 2, 2, 532, 43, 3, 2, 2, 2, 533, 534, 7,
	154, 2, 2, 534, 535, 5, 48, 25, 2, 535, 45, 3, 2, 2, 2, 536, 537, 7, 155,
	2, 2, 537, 538, 5, 48, 25, 2, 538, 47, 3, 2, 2, 2, 539, 541, 5, 64, 33,
	2, 540, 539, 3, 2, 2, 2, 540, 541, 3, 2, 2, 2, 541, 542, 3, 2, 2, 2, 542,
	544, 5, 58, 30, 2, 543, 545, 5, 206, 104, 2, 544, 543, 3, 2, 2, 2, 544,
	545, 3, 2, 2, 2, 545, 546, 3, 2, 2, 2, 546, 547, 7, 134, 2, 2, 547, 49,
	3, 2, 2, 2, 548, 554, 5, 124, 63, 2, 549, 554, 5, 140, 71, 2, 550, 554,
	5, 52, 27, 2, 551, 554, 5, 54, 28, 2, 552, 554, 5, 66, 34, 2, 553, 548,
	3, 2, 2, 2, 553, 549, 3, 2, 2, 2, 553, 550, 3, 2, 2, 2, 553, 551, 3, 2,
	2, 2, 553, 552, 3, 2, 2, 2, 554, 555, 3, 2, 2, 2, 555, 553, 3, 2, 2, 2,
	555, 556, 3, 2, 2, 2, 556, 51, 3, 2, 2, 2, 557, 558, 7, 154, 2, 2, 558,
	559, 5, 56, 29, 2, 559, 53, 3, 2, 2, 2, 560, 561, 7, 155, 2, 2, 561, 562,
	5, 56, 29, 2, 562, 55, 3, 2, 2, 2, 563, 565, 5, 64, 33, 2, 564, 563, 3,
	2, 2, 2, 564, 565, 3, 2, 2, 2, 565, 566, 3, 2, 2, 2, 566, 568, 5, 58, 30,
	2, 567, 569, 5, 158, 80, 2, 568, 567, 3, 2, 2, 2, 568, 569, 3, 2, 2, 2,
	569, 571, 3, 2, 2, 2, 570, 572, 7, 134, 2, 2, 571, 570, 3, 2, 2, 2, 571,
	572, 3, 2, 2, 2, 572, 573, 3, 2, 2, 2, 573, 574, 5, 232, 117, 2, 574, 57,
	3, 2, 2, 2, 575, 586, 5, 62, 32, 2, 576, 578, 5, 60, 31, 2, 577, 576, 3,
	2, 2, 2, 578, 579, 3, 2, 2, 2, 579, 577, 3, 2, 2, 2, 579, 580, 3, 2, 2,
	2, 580, 583, 3, 2, 2, 2, 581, 582, 7, 135, 2, 2, 582, 584, 7, 172, 2, 2,
	583, 581, 3, 2, 2, 2, 583, 584, 3, 2, 2, 2, 584, 586, 3, 2, 2, 2, 585,
	575, 3, 2, 2, 2, 585, 577, 3, 2, 2, 2, 586, 59, 3, 2, 2, 2, 587, 589, 5,
	62, 32, 2, 588, 587, 3, 2, 2, 2, 588, 589, 3, 2, 2, 2, 589, 590, 3, 2,
	2, 2, 590, 594, 7, 145, 2, 2, 591, 593, 5, 64, 33, 2, 592, 591, 3, 2, 2,
	2, 593, 596, 3, 2, 2, 2, 594, 592, 3, 2, 2, 2, 594, 595, 3, 2, 2, 2, 595,
	598, 3, 2, 2, 2, 596, 594, 3, 2, 2, 2, 597, 599, 5, 170, 86, 2, 598, 597,
	3, 2, 2, 2, 598, 599, 3, 2, 2, 2, 599, 600, 3, 2, 2, 2, 600, 601, 5, 288,
	145, 2, 601, 61, 3, 2, 2, 2, 602, 605, 5, 288, 145, 2, 603, 605, 7, 24,
	2, 2, 604, 602, 3, 2, 2, 2, 604, 603, 3, 2, 2, 2, 605, 63, 3, 2, 2, 2,
	606, 607, 7, 128, 2, 2, 607, 608, 5, 214, 108, 2, 608, 609, 7, 129, 2,
	2, 609, 65, 3, 2, 2, 2, 610, 611, 7, 80, 2, 2, 611, 612, 5, 68, 35, 2,
	612, 613, 7, 134, 2, 2, 613, 619, 3, 2, 2, 2, 614, 615, 7, 63, 2, 2, 615,
	616, 5, 68, 35, 2, 616, 617, 7, 134, 2, 2, 617, 619, 3, 2, 2, 2, 618, 610,
	3, 2, 2, 2, 618, 614, 3, 2, 2, 2, 619, 67, 3, 2, 2, 2, 620, 625, 5, 70,
	36, 2, 621, 622, 7, 135, 2, 2, 622, 624, 5, 70, 36, 2, 623, 621, 3, 2,
	2, 2, 624, 627, 3, 2, 2, 2, 625, 623, 3, 2, 2, 2, 625, 626, 3, 2, 2, 2,
	626, 69, 3, 2, 2, 2, 627, 625, 3, 2, 2, 2, 628, 631, 5, 288, 145, 2, 629,
	630, 7, 139, 2, 2, 630, 632, 5, 288, 145, 2, 631, 629, 3, 2, 2, 2, 631,
	632, 3, 2, 2, 2, 632, 71, 3, 2, 2, 2, 633, 635, 5, 172, 87, 2, 634, 633,
	3, 2, 2, 2, 634, 635, 3, 2, 2, 2, 635, 636, 3, 2, 2, 2, 636, 638, 5, 182,
	92, 2, 637, 639, 5, 172, 87, 2, 638, 637, 3, 2, 2, 2, 638, 639, 3, 2, 2,
	2, 639, 640, 3, 2, 2, 2, 640, 641, 7, 128, 2, 2, 641, 644, 7, 160, 2, 2,
	642, 645, 5, 172, 87, 2, 643, 645, 5, 182, 92, 2, 644, 642, 3, 2, 2, 2,
	644, 643, 3, 2, 2, 2, 644, 645, 3, 2, 2, 2, 645, 646, 3, 2, 2, 2, 646,
	648, 7, 129, 2, 2, 647, 649, 5, 86, 44, 2, 648, 647, 3, 2, 2, 2, 648, 649,
	3, 2, 2, 2, 649, 73, 3, 2, 2, 2, 650, 659, 7, 141, 2, 2, 651, 656, 5, 76,
	39, 2, 652, 653, 7, 135, 2, 2, 653, 655, 5, 76, 39, 2, 654, 652, 3, 2,
	2, 2, 655, 658, 3, 2, 2, 2, 656, 654, 3, 2, 2, 2, 656, 657, 3, 2, 2, 2,
	657, 660, 3, 2, 2, 2, 658, 656, 3, 2, 2, 2, 659, 651, 3, 2, 2, 2, 659,
	660, 3, 2, 2, 2, 660, 661, 3, 2, 2, 2, 661, 662, 7, 140, 2, 2, 662, 75,
	3, 2, 2, 2, 663, 665, 5, 176, 89, 2, 664, 663, 3, 2, 2, 2, 665, 668, 3,
	2, 2, 2, 666, 664, 3, 2, 2, 2, 666, 667, 3, 2, 2, 2, 667, 669, 3, 2, 2,
	2, 668, 666, 3, 2, 2, 2, 669, 672, 5, 182, 92, 2, 670, 672, 5, 214, 108,
	2, 671, 666, 3, 2, 2, 2, 671, 670, 3, 2, 2, 2, 672, 77, 3, 2, 2, 2, 673,
	674, 7, 138, 2, 2, 674, 686, 7, 130, 2, 2, 675, 680, 5, 80, 41, 2, 676,
	677, 7, 135, 2, 2, 677, 679, 5, 80, 41, 2, 678, 676, 3, 2, 2, 2, 679, 682,
	3, 2, 2, 2, 680, 678, 3, 2, 2, 2, 680, 681, 3, 2, 2, 2, 681, 684, 3, 2,
	2, 2, 682, 680, 3, 2, 2, 2, 683, 685, 7, 135, 2, 2, 684, 683, 3, 2, 2,
	2, 684, 685, 3, 2, 2, 2, 685, 687, 3, 2, 2, 2, 686, 675, 3, 2, 2, 2, 686,
	687, 3, 2, 2, 2, 687, 688, 3, 2, 2, 2, 688, 689, 7, 131, 2, 2, 689, 79,
	3, 2, 2, 2, 690, 691, 5, 264, 133, 2, 691, 692, 7, 145, 2, 2, 692, 693,
	5, 260, 131, 2, 693, 81, 3, 2, 2, 2, 694, 695, 7, 138, 2, 2, 695, 700,
	7, 132, 2, 2, 696, 698, 5, 258, 130, 2, 697, 699, 7, 135, 2, 2, 698, 697,
	3, 2, 2, 2, 698, 699, 3, 2, 2, 2, 699, 701, 3, 2, 2, 2, 700, 696, 3, 2,
	2, 2, 700, 701, 3, 2, 2, 2, 701, 702, 3, 2, 2, 2, 702, 703, 7, 133, 2,
	2, 703, 83, 3, 2, 2, 2, 704, 705, 7, 138, 2, 2, 705, 706, 7, 128, 2, 2,
	706, 707, 5, 260, 131, 2, 707, 708, 7, 129, 2, 2, 708, 715, 3, 2, 2, 2,
	709, 712, 7, 138, 2, 2, 710, 713, 5, 284, 143, 2, 711, 713, 5, 288, 145,
	2, 712, 710, 3, 2, 2, 2, 712, 711, 3, 2, 2, 2, 713, 715, 3, 2, 2, 2, 714,
	704, 3, 2, 2, 2, 714, 709, 3, 2, 2, 2, 715, 85, 3, 2, 2, 2, 716, 728, 7,
	128, 2, 2, 717, 720, 5, 88, 45, 2, 718, 720, 7, 34, 2, 2, 719, 717, 3,
	2, 2, 2, 719, 718, 3, 2, 2, 2, 720, 725, 3, 2, 2, 2, 721, 722, 7, 135,
	2, 2, 722, 724, 5, 88, 45, 2, 723, 721, 3, 2, 2, 2, 724, 727, 3, 2, 2,
	2, 725, 723, 3, 2, 2, 2, 725, 726, 3, 2, 2, 2, 726, 729, 3, 2, 2, 2, 727,
	725, 3, 2, 2, 2, 728, 719, 3, 2, 2, 2, 728, 729, 3, 2, 2, 2, 729, 730,
	3, 2, 2, 2, 730, 731, 7, 129, 2, 2, 731, 87, 3, 2, 2, 2, 732, 735, 5, 110,
	56, 2, 733, 735, 5, 214, 108, 2, 734, 732, 3, 2, 2, 2, 734, 733, 3, 2,
	2, 2, 735, 89, 3, 2, 2, 2, 736, 738, 7, 160, 2, 2, 737, 739, 5, 182, 92,
	2, 738, 737, 3, 2, 2, 2, 738, 739, 3, 2, 2, 2, 739, 741, 3, 2, 2, 2, 740,
	742, 5, 172, 87, 2, 741, 740, 3, 2, 2, 2, 741, 742, 3, 2, 2, 2, 742, 744,
	3, 2, 2, 2, 743, 745, 5, 86, 44, 2, 744, 743, 3, 2, 2, 2, 744, 745, 3,
	2, 2, 2, 745, 746, 3, 2, 2, 2, 746, 747, 5, 232, 117, 2, 747, 91, 3, 2,
	2, 2, 748, 749, 7, 132, 2, 2, 749, 750, 5, 94, 48, 2, 750, 751, 5, 96,
	49, 2, 751, 752, 7, 133, 2, 2, 752, 93, 3, 2, 2, 2, 753, 756, 5, 260, 131,
	2, 754, 756, 5, 182, 92, 2, 755, 753, 3, 2, 2, 2, 755, 754, 3, 2, 2, 2,
	756, 95, 3, 2, 2, 2, 757, 764, 5, 62, 32, 2, 758, 760, 5, 98, 50, 2, 759,
	758, 3, 2, 2, 2, 760, 761, 3, 2, 2, 2, 761, 759, 3, 2, 2, 2, 761, 762,
	3, 2, 2, 2, 762, 764, 3, 2, 2, 2, 763, 757, 3, 2, 2, 2, 763, 759, 3, 2,
	2, 2, 764, 97, 3, 2, 2, 2, 765, 767, 5, 62, 32, 2, 766, 765, 3, 2, 2, 2,
	766, 767, 3, 2, 2, 2, 767, 768, 3, 2, 2, 2, 768, 769, 7, 145, 2, 2, 769,
	774, 5, 100, 51, 2, 770, 771, 7, 135, 2, 2, 771, 773, 5, 100, 51, 2, 772,
	770, 3, 2, 2, 2, 773, 776, 3, 2, 2, 2, 774, 772, 3, 2, 2, 2, 774, 775,
	3, 2, 2, 2, 775, 99, 3, 2, 2, 2, 776, 774, 3, 2, 2, 2, 777, 779, 5, 258,
	130, 2, 778, 780, 5, 172, 87, 2, 779, 778, 3, 2, 2, 2, 779, 780, 3, 2,
	2, 2, 780, 785, 3, 2, 2, 2, 781, 782, 7, 130, 2, 2, 782, 783, 5, 212, 107,
	2, 783, 784, 7, 131, 2, 2, 784, 786, 3, 2, 2, 2, 785, 781, 3, 2, 2, 2,
	785, 786, 3, 2, 2, 2, 786, 101, 3, 2, 2, 2, 787, 788, 7, 78, 2, 2, 788,
	789, 7, 128, 2, 2, 789, 790, 5, 104, 53, 2, 790, 791, 7, 129, 2, 2, 791,
	103, 3, 2, 2, 2, 792, 802, 5, 62, 32, 2, 793, 795, 5, 62, 32, 2, 794, 793,
	3, 2, 2, 2, 794, 795, 3, 2, 2, 2, 795, 796, 3, 2, 2, 2, 796, 798, 7, 145,
	2, 2, 797, 794, 3, 2, 2, 2, 798, 799, 3, 2, 2, 2, 799, 797, 3, 2, 2, 2,
	799, 800, 3, 2, 2, 2, 800, 802, 3, 2, 2, 2, 801, 792, 3, 2, 2, 2, 801,
	797, 3, 2, 2, 2, 802, 105, 3, 2, 2, 2, 803, 804, 7, 71, 2, 2, 804, 805,
	7, 128, 2, 2, 805, 806, 5, 34, 18, 2, 806, 807, 7, 129, 2, 2, 807, 107,
	3, 2, 2, 2, 808, 809, 7, 64, 2, 2, 809, 810, 7, 128, 2, 2, 810, 811, 5,
	214, 108, 2, 811, 812, 7, 129, 2, 2, 812, 109, 3, 2, 2, 2, 813, 814, 5,
	154, 78, 2, 814, 815, 5, 224, 113, 2, 815, 111, 3, 2, 2, 2, 816, 817, 7,
	81, 2, 2, 817, 818, 7, 128, 2, 2, 818, 819, 5, 288, 145, 2, 819, 820, 7,
	129, 2, 2, 820, 824, 3, 2, 2, 2, 821, 822, 7, 81, 2, 2, 822, 824, 5, 260,
	131, 2, 823, 816, 3, 2, 2, 2, 823, 821, 3, 2, 2, 2, 824, 113, 3, 2, 2,
	2, 825, 826, 7, 82, 2, 2, 826, 830, 5, 232, 117, 2, 827, 829, 5, 116, 59,
	2, 828, 827, 3, 2, 2, 2, 829, 832, 3, 2, 2, 2, 830, 828, 3, 2, 2, 2, 830,
	831, 3, 2, 2, 2, 831, 835, 3, 2, 2, 2, 832, 830, 3, 2, 2, 2, 833, 834,
	7, 66, 2, 2, 834, 836, 5, 232, 117, 2, 835, 833, 3, 2, 2, 2, 835, 836,
	3, 2, 2, 2, 836, 115, 3, 2, 2, 2, 837, 838, 7, 61, 2, 2, 838, 839, 7, 128,
	2, 2, 839, 840, 5, 110, 56, 2, 840, 841, 7, 129, 2, 2, 841, 842, 5, 232,
	117, 2, 842, 117, 3, 2, 2, 2, 843, 844, 7, 79, 2, 2, 844, 845, 7, 128,
	2, 2, 845, 846, 5, 260, 131, 2, 846, 847, 7, 129, 2, 2, 847, 848, 5, 232,
	117, 2, 848, 119, 3, 2, 2, 2, 849, 850, 7, 60, 2, 2, 850, 851, 5, 232,
	117, 2, 851, 121, 3, 2, 2, 2, 852, 853, 5, 126, 64, 2, 853, 854, 7, 134,
	2, 2, 854, 123, 3, 2, 2, 2, 855, 856, 5, 126, 64, 2, 856, 857, 5, 232,
	117, 2, 857, 125, 3, 2, 2, 2, 858, 860, 5, 154, 78, 2, 859, 858, 3, 2,
	2, 2, 859, 860, 3, 2, 2, 2, 860, 861, 3, 2, 2, 2, 861, 862, 5, 288, 145,
	2, 862, 864, 7, 128, 2, 2, 863, 865, 5, 202, 102, 2, 864, 863, 3, 2, 2,
	2, 864, 865, 3, 2, 2, 2, 865, 866, 3, 2, 2, 2, 866, 867, 7, 129, 2, 2,
	867, 869, 3, 2, 2, 2, 868, 870, 5, 156, 79, 2, 869, 868, 3, 2, 2, 2, 869,
	870, 3, 2, 2, 2, 870, 127, 3, 2, 2, 2, 871, 873, 5, 130, 66, 2, 872, 874,
	5, 132, 67, 2, 873, 872, 3, 2, 2, 2, 873, 874, 3, 2, 2, 2, 874, 129, 3,
	2, 2, 2, 875, 878, 7, 7, 2, 2, 876, 878, 5, 288, 145, 2, 877, 875, 3, 2,
	2, 2, 877, 876, 3, 2, 2, 2, 878, 131, 3, 2, 2, 2, 879, 881, 7, 128, 2,
	2, 880, 882, 5, 134, 68, 2, 881, 880, 3, 2, 2, 2, 881, 882, 3, 2, 2, 2,
	882, 883, 3, 2, 2, 2, 883, 884, 7, 129, 2, 2, 884, 133, 3, 2, 2, 2, 885,
	890, 5, 136, 69, 2, 886, 887, 7, 135, 2, 2, 887, 889, 5, 136, 69, 2, 888,
	886, 3, 2, 2, 2, 889, 892, 3, 2, 2, 2, 890, 888, 3, 2, 2, 2, 890, 891,
	3, 2, 2, 2, 891, 135, 3, 2, 2, 2, 892, 890, 3, 2, 2, 2, 893, 898, 5, 128,
	65, 2, 894, 898, 5, 284, 143, 2, 895, 898, 5, 286, 144, 2, 896, 898, 5,
	138, 70, 2, 897, 893, 3, 2, 2, 2, 897, 894, 3, 2, 2, 2, 897, 895, 3, 2,
	2, 2, 897, 896, 3, 2, 2, 2, 898, 137, 3, 2, 2, 2, 899, 900, 5, 130, 66,
	2, 900, 904, 7, 139, 2, 2, 901, 905, 5, 284, 143, 2, 902, 905, 5, 130,
	66, 2, 903, 905, 5, 286, 144, 2, 904, 901, 3, 2, 2, 2, 904, 902, 3, 2,
	2, 2, 904, 903, 3, 2, 2, 2, 905, 139, 3, 2, 2, 2, 906, 911, 5, 142, 72,
	2, 907, 911, 5, 144, 73, 2, 908, 911, 5, 146, 74, 2, 909, 911, 5, 148,
	75, 2, 910, 906, 3, 2, 2, 2, 910, 907, 3, 2, 2, 2, 910, 908, 3, 2, 2, 2,
	910, 909, 3, 2, 2, 2, 911, 141, 3, 2, 2, 2, 912, 914, 5, 156, 79, 2, 913,
	912, 3, 2, 2, 2, 913, 914, 3, 2, 2, 2, 914, 915, 3, 2, 2, 2, 915, 917,
	5, 288, 145, 2, 916, 918, 5, 156, 79, 2, 917, 916, 3, 2, 2, 2, 917, 918,
	3, 2, 2, 2, 918, 919, 3, 2, 2, 2, 919, 920, 7, 128, 2, 2, 920, 921, 5,
	198, 100, 2, 921, 922, 7, 129, 2, 2, 922, 923, 7, 134, 2, 2, 923, 143,
	3, 2, 2, 2, 924, 926, 5, 156, 79, 2, 925, 924, 3, 2, 2, 2, 925, 926, 3,
	2, 2, 2, 926, 928, 3, 2, 2, 2, 927, 929, 7, 31, 2, 2, 928, 927, 3, 2, 2,
	2, 928, 929, 3, 2, 2, 2, 929, 930, 3, 2, 2, 2, 930, 932, 5, 190, 96, 2,
	931, 933, 5, 288, 145, 2, 932, 931, 3, 2, 2, 2, 932, 933, 3, 2, 2, 2, 933,
	934, 3, 2, 2, 2, 934, 935, 7, 134, 2, 2, 935, 145, 3, 2, 2, 2, 936, 937,
	5, 154, 78, 2, 937, 938, 5, 158, 80, 2, 938, 941, 3, 2, 2, 2, 939, 941,
	5, 154, 78, 2, 940, 936, 3, 2, 2, 2, 940, 939, 3, 2, 2, 2, 941, 942, 3,
	2, 2, 2, 942, 943, 7, 134, 2, 2, 943, 147, 3, 2, 2, 2, 944, 946, 5, 156,
	79, 2, 945, 944, 3, 2, 2, 2, 945, 946, 3, 2, 2, 2, 946, 947, 3, 2, 2, 2,
	947, 952, 7, 31, 2, 2, 948, 949, 5, 154, 78, 2, 949, 950, 5, 150, 76, 2,
	950, 953, 3, 2, 2, 2, 951, 953, 5, 154, 78, 2, 952, 948, 3, 2, 2, 2, 952,
	951, 3, 2, 2, 2, 953, 954, 3, 2, 2, 2, 954, 955, 7, 134, 2, 2, 955, 149,
	3, 2, 2, 2, 956, 961, 5, 152, 77, 2, 957, 958, 7, 135, 2, 2, 958, 960,
	5, 152, 77, 2, 959, 957, 3, 2, 2, 2, 960, 963, 3, 2, 2, 2, 961, 959, 3,
	2, 2, 2, 961, 962, 3, 2, 2, 2, 962, 151, 3, 2, 2, 2, 963, 961, 3, 2, 2,
	2, 964, 966, 5, 204, 103, 2, 965, 964, 3, 2, 2, 2, 965, 966, 3, 2, 2, 2,
	966, 967, 3, 2, 2, 2, 967, 968, 5, 198, 100, 2, 968, 153, 3, 2, 2, 2, 969,
	978, 5, 174, 88, 2, 970, 978, 5, 156, 79, 2, 971, 978, 5, 170, 86, 2, 972,
	978, 5, 172, 87, 2, 973, 978, 5, 168, 85, 2, 974, 978, 5, 176, 89, 2, 975,
	978, 5, 178, 90, 2, 976, 978, 5, 182, 92, 2, 977, 969, 3, 2, 2, 2, 977,
	970, 3, 2, 2, 2, 977, 971, 3, 2, 2, 2, 977, 972, 3, 2, 2, 2, 977, 973,
	3, 2, 2, 2, 977, 974, 3, 2, 2, 2, 977, 975, 3, 2, 2, 2, 977, 976, 3, 2,
	2, 2, 978, 979, 3, 2, 2, 2, 979, 977, 3, 2, 2, 2, 979, 980, 3, 2, 2, 2,
	980, 155, 3, 2, 2, 2, 981, 982, 7, 86, 2, 2, 982, 983, 7, 128, 2, 2, 983,
	984, 7, 128, 2, 2, 984, 989, 5, 128, 65, 2, 985, 986, 7, 135, 2, 2, 986,
	988, 5, 128, 65, 2, 987, 985, 3, 2, 2, 2, 988, 991, 3, 2, 2, 2, 989, 987,
	3, 2, 2, 2, 989, 990, 3, 2, 2, 2, 990, 992, 3, 2, 2, 2, 991, 989, 3, 2,
	2, 2, 992, 993, 7, 129, 2, 2, 993, 994, 7, 129, 2, 2, 994, 157, 3, 2, 2,
	2, 995, 1000, 5, 160, 81, 2, 996, 997, 7, 135, 2, 2, 997, 999, 5, 160,
	81, 2, 998, 996, 3, 2, 2, 2, 999, 1002, 3, 2, 2, 2, 1000, 998, 3, 2, 2,
	2, 1000, 1001, 3, 2, 2, 2, 1001, 159, 3, 2, 2, 2, 1002, 1000, 3, 2, 2,
	2, 1003, 1006, 5, 224, 113, 2, 1004, 1005, 7, 139, 2, 2, 1005, 1007, 5,
	266, 134, 2, 1006, 1004, 3, 2, 2, 2, 1006, 1007, 3, 2, 2, 2, 1007, 161,
	3, 2, 2, 2, 1008, 1021, 9, 5, 2, 2, 1009, 1022, 5, 288, 145, 2, 1010, 1012,
	5, 288, 145, 2, 1011, 1010, 3, 2, 2, 2, 1011, 1012, 3, 2, 2, 2, 1012, 1013,
	3, 2, 2, 2, 1013, 1015, 7, 130, 2, 2, 1014, 1016, 5, 164, 83, 2, 1015,
	1014, 3, 2, 2, 2, 1016, 1017, 3, 2, 2, 2, 1017, 1015, 3, 2, 2, 2, 1017,
	1018, 3, 2, 2, 2, 1018, 1019, 3, 2, 2, 2, 1019, 1020, 7, 131, 2, 2, 1020,
	1022, 3, 2, 2, 2, 1021, 1009, 3, 2, 2, 2, 1021, 1011, 3, 2, 2, 2, 1022,
	163, 3, 2, 2, 2, 1023, 1024, 5, 166, 84, 2, 1024, 1026, 5, 186, 94, 2,
	1025, 1027, 5, 206, 104, 2, 1026, 1025, 3, 2, 2, 2, 1026, 1027, 3, 2, 2,
	2, 1027, 1028, 3, 2, 2, 2, 1028, 1029, 7, 134, 2, 2, 1029, 165, 3, 2, 2,
	2, 1030, 1037, 5, 170, 86, 2, 1031, 1037, 5, 172, 87, 2, 1032, 1037, 5,
	168, 85, 2, 1033, 1037, 5, 176, 89, 2, 1034, 1037, 5, 178, 90, 2, 1035,
	1037, 5, 182, 92, 2, 1036, 1030, 3, 2, 2, 2, 1036, 1031, 3, 2, 2, 2, 1036,
	1032, 3, 2, 2, 2, 1036, 1033, 3, 2, 2, 2, 1036, 1034, 3, 2, 2, 2, 1036,
	1035, 3, 2, 2, 2, 1037, 1038, 3, 2, 2, 2, 1038, 1036, 3, 2, 2, 2, 1038,
	1039, 3, 2, 2, 2, 1039, 167, 3, 2, 2, 2, 1040, 1041, 7, 118, 2, 2, 1041,
	1042, 7, 128, 2, 2, 1042, 1043, 5, 288, 145, 2, 1043, 1044, 7, 129, 2,
	2, 1044, 1047, 3, 2, 2, 2, 1045, 1047, 7, 117, 2, 2, 1046, 1040, 3, 2,
	2, 2, 1046, 1045, 3, 2, 2, 2, 1047, 169, 3, 2, 2, 2, 1048, 1049, 9, 6,
	2, 2, 1049, 171, 3, 2, 2, 2, 1050, 1051, 9, 7, 2, 2, 1051, 173, 3, 2, 2,
	2, 1052, 1053, 9, 8, 2, 2, 1053, 175, 3, 2, 2, 2, 1054, 1055, 9, 9, 2,
	2, 1055, 177, 3, 2, 2, 2, 1056, 1061, 7, 7, 2, 2, 1057, 1061, 7, 35, 2,
	2, 1058, 1061, 7, 23, 2, 2, 1059, 1061, 5, 180, 91, 2, 1060, 1056, 3, 2,
	2, 2, 1060, 1057, 3, 2, 2, 2, 1060, 1058, 3, 2, 2, 2, 1060, 1059, 3, 2,
	2, 2, 1061, 179, 3, 2, 2, 2, 1062, 1063, 9, 10, 2, 2, 1063, 181, 3, 2,
	2, 2, 1064, 1082, 7, 34, 2, 2, 1065, 1082, 7, 6, 2, 2, 1066, 1082, 7, 25,
	2, 2, 1067, 1082, 7, 20, 2, 2, 1068, 1082, 7, 21, 2, 2, 1069, 1082, 7,
	15, 2, 2, 1070, 1082, 7, 11, 2, 2, 1071, 1082, 7, 26, 2, 2, 1072, 1082,
	7, 33, 2, 2, 1073, 1082, 5, 184, 93, 2, 1074, 1082, 5, 16, 9, 2, 1075,
	1082, 5, 162, 82, 2, 1076, 1082, 5, 190, 96, 2, 1077, 1079, 5, 288, 145,
	2, 1078, 1080, 5, 204, 103, 2, 1079, 1078, 3, 2, 2, 2, 1079, 1080, 3, 2,
	2, 2, 1080, 1082, 3, 2, 2, 2, 1081, 1064, 3, 2, 2, 2, 1081, 1065, 3, 2,
	2, 2, 1081, 1066, 3, 2, 2, 2, 1081, 1067, 3, 2, 2, 2, 1081, 1068, 3, 2,
	2, 2, 1081, 1069, 3, 2, 2, 2, 1081, 1070, 3, 2, 2, 2, 1081, 1071, 3, 2,
	2, 2, 1081, 1072, 3, 2, 2, 2, 1081, 1073, 3, 2, 2, 2, 1081, 1074, 3, 2,
	2, 2, 1081, 1075, 3, 2, 2, 2, 1081, 1076, 3, 2, 2, 2, 1081, 1077, 3, 2,
	2, 2, 1082, 183, 3, 2, 2, 2, 1083, 1084, 7, 97, 2, 2, 1084, 1085, 7, 128,
	2, 2, 1085, 1086, 5, 260, 131, 2, 1086, 1087, 7, 129, 2, 2, 1087, 185,
	3, 2, 2, 2, 1088, 1093, 5, 188, 95, 2, 1089, 1090, 7, 135, 2, 2, 1090,
	1092, 5, 188, 95, 2, 1091, 1089, 3, 2, 2, 2, 1092, 1095, 3, 2, 2, 2, 1093,
	1091, 3, 2, 2, 2, 1093, 1094, 3, 2, 2, 2, 1094, 187, 3, 2, 2, 2, 1095,
	1093, 3, 2, 2, 2, 1096, 1103, 5, 224, 113, 2, 1097, 1099, 5, 224, 113,
	2, 1098, 1097, 3, 2, 2, 2, 1098, 1099, 3, 2, 2, 2, 1099, 1100, 3, 2, 2,
	2, 1100, 1101, 7, 145, 2, 2, 1101, 1103, 5, 284, 143, 2, 1102, 1096, 3,
	2, 2, 2, 1102, 1098, 3, 2, 2, 2, 1103, 189, 3, 2, 2, 2, 1104, 1110, 7,
	13, 2, 2, 1105, 1107, 5, 288, 145, 2, 1106, 1105, 3, 2, 2, 2, 1106, 1107,
	3, 2, 2, 2, 1107, 1108, 3, 2, 2, 2, 1108, 1109, 7, 145, 2, 2, 1109, 1111,
	5, 214, 108, 2, 1110, 1106, 3, 2, 2, 2, 1110, 1111, 3, 2, 2, 2, 1111, 1123,
	3, 2, 2, 2, 1112, 1117, 5, 288, 145, 2, 1113, 1114, 7, 130, 2, 2, 1114,
	1115, 5, 192, 97, 2, 1115, 1116, 7, 131, 2, 2, 1116, 1118, 3, 2, 2, 2,
	1117, 1113, 3, 2, 2, 2, 1117, 1118, 3, 2, 2, 2, 1118, 1124, 3, 2, 2, 2,
	1119, 1120, 7, 130, 2, 2, 1120, 1121, 5, 192, 97, 2, 1121, 1122, 7, 131,
	2, 2, 1122, 1124, 3, 2, 2, 2, 1123, 1112, 3, 2, 2, 2, 1123, 1119, 3, 2,
	2, 2, 1124, 1136, 3, 2, 2, 2, 1125, 1126, 9, 11, 2, 2, 1126, 1127, 7, 128,
	2, 2, 1127, 1128, 5, 214, 108, 2, 1128, 1129, 7, 135, 2, 2, 1129, 1130,
	5, 288, 145, 2, 1130, 1131, 7, 129, 2, 2, 1131, 1132, 7, 130, 2, 2, 1132,
	1133, 5, 192, 97, 2, 1133, 1134, 7, 131, 2, 2, 1134, 1136, 3, 2, 2, 2,
	1135, 1104, 3, 2, 2, 2, 1135, 1125, 3, 2, 2, 2, 1136, 191, 3, 2, 2, 2,
	1137, 1142, 5, 194, 98, 2, 1138, 1139, 7, 135, 2, 2, 1139, 1141, 5, 194,
	98, 2, 1140, 1138, 3, 2, 2, 2, 1141, 1144, 3, 2, 2, 2, 1142, 1140, 3, 2,
	2, 2, 1142, 1143, 3, 2, 2, 2, 1143, 1146, 3, 2, 2, 2, 1144, 1142, 3, 2,
	2, 2, 1145, 1147, 7, 135, 2, 2, 1146, 1145, 3, 2, 2, 2, 1146, 1147, 3,
	2, 2, 2, 1147, 193, 3, 2, 2, 2, 1148, 1151, 5, 196, 99, 2, 1149, 1150,
	7, 139, 2, 2, 1150, 1152, 5, 260, 131, 2, 1151, 1149, 3, 2, 2, 2, 1151,
	1152, 3, 2, 2, 2, 1152, 195, 3, 2, 2, 2, 1153, 1156, 5, 288, 145, 2, 1154,
	1156, 7, 9, 2, 2, 1155, 1153, 3, 2, 2, 2, 1155, 1154, 3, 2, 2, 2, 1156,
	197, 3, 2, 2, 2, 1157, 1163, 5, 288, 145, 2, 1158, 1159, 7, 128, 2, 2,
	1159, 1160, 5, 224, 113, 2, 1160, 1161, 7, 129, 2, 2, 1161, 1163, 3, 2,
	2, 2, 1162, 1157, 3, 2, 2, 2, 1162, 1158, 3, 2, 2, 2, 1163, 1167, 3, 2,
	2, 2, 1164, 1166, 5, 200, 101, 2, 1165, 1164, 3, 2, 2, 2, 1166, 1169, 3,
	2, 2, 2, 1167, 1165, 3, 2, 2, 2, 1167, 1168, 3, 2, 2, 2, 1168, 1181, 3,
	2, 2, 2, 1169, 1167, 3, 2, 2, 2, 1170, 1171, 7, 128, 2, 2, 1171, 1173,
	7, 160, 2, 2, 1172, 1174, 5, 172, 87, 2, 1173, 1172, 3, 2, 2, 2, 1173,
	1174, 3, 2, 2, 2, 1174, 1176, 3, 2, 2, 2, 1175, 1177, 5, 288, 145, 2, 1176,
	1175, 3, 2, 2, 2, 1176, 1177, 3, 2, 2, 2, 1177, 1178, 3, 2, 2, 2, 1178,
	1179, 7, 129, 2, 2, 1179, 1181, 5, 86, 44, 2, 1180, 1162, 3, 2, 2, 2, 1180,
	1170, 3, 2, 2, 2, 1181, 199, 3, 2, 2, 2, 1182, 1184, 7, 132, 2, 2, 1183,
	1185, 5, 268, 135, 2, 1184, 1183, 3, 2, 2, 2, 1184, 1185, 3, 2, 2, 2, 1185,
	1186, 3, 2, 2, 2, 1186, 1187, 7, 133, 2, 2, 1187, 201, 3, 2, 2, 2, 1188,
	1191, 5, 220, 111, 2, 1189, 1190, 7, 135, 2, 2, 1190, 1192, 7, 172, 2,
	2, 1191, 1189, 3, 2, 2, 2, 1191, 1192, 3, 2, 2, 2, 1192, 203, 3, 2, 2,
	2, 1193, 1195, 7, 156, 2, 2, 1194, 1196, 5, 154, 78, 2, 1195, 1194, 3,
	2, 2, 2, 1195, 1196, 3, 2, 2, 2, 1196, 1198, 3, 2, 2, 2, 1197, 1199, 5,
	204, 103, 2, 1198, 1197, 3, 2, 2, 2, 1198, 1199, 3, 2, 2, 2, 1199, 205,
	3, 2, 2, 2, 1200, 1212, 5, 288, 145, 2, 1201, 1202, 7, 128, 2, 2, 1202,
	1207, 5, 282, 142, 2, 1203, 1204, 7, 135, 2, 2, 1204, 1206, 5, 282, 142,
	2, 1205, 1203, 3, 2, 2, 2, 1206, 1209, 3, 2, 2, 2, 1207, 1205, 3, 2, 2,
	2, 1207, 1208, 3, 2, 2, 2, 1208, 1210, 3, 2, 2, 2, 1209, 1207, 3, 2, 2,
	2, 1210, 1211, 7, 129, 2, 2, 1211, 1213, 3, 2, 2, 2, 1212, 1201, 3, 2,
	2, 2, 1212, 1213, 3, 2, 2, 2, 1213, 207, 3, 2, 2, 2, 1214, 1219, 7, 130,
	2, 2, 1215, 1217, 5, 258, 130, 2, 1216, 1218, 7, 135, 2, 2, 1217, 1216,
	3, 2, 2, 2, 1217, 1218, 3, 2, 2, 2, 1218, 1220, 3, 2, 2, 2, 1219, 1215,
	3, 2, 2, 2, 1219, 1220, 3, 2, 2, 2, 1220, 1221, 3, 2, 2, 2, 1221, 1222,
	7, 131, 2, 2, 1222, 209, 3, 2, 2, 2, 1223, 1237, 7, 130, 2, 2, 1224, 1225,
	7, 136, 2, 2, 1225, 1231, 5, 260, 131, 2, 1226, 1227, 7, 135, 2, 2, 1227,
	1228, 7, 136, 2, 2, 1228, 1230, 5, 260, 131, 2, 1229, 1226, 3, 2, 2, 2,
	1230, 1233, 3, 2, 2, 2, 1231, 1229, 3, 2, 2, 2, 1231, 1232, 3, 2, 2, 2,
	1232, 1235, 3, 2, 2, 2, 1233, 1231, 3, 2, 2, 2, 1234, 1236, 7, 135, 2,
	2, 1235, 1234, 3, 2, 2, 2, 1235, 1236, 3, 2, 2, 2, 1236, 1238, 3, 2, 2,
	2, 1237, 1224, 3, 2, 2, 2, 1237, 1238, 3, 2, 2, 2, 1238, 1239, 3, 2, 2,
	2, 1239, 1240, 7, 131, 2, 2, 1240, 211, 3, 2, 2, 2, 1241, 1246, 5, 266,
	134, 2, 1242, 1243, 7, 135, 2, 2, 1243, 1245, 5, 266, 134, 2, 1244, 1242,
	3, 2, 2, 2, 1245, 1248, 3, 2, 2, 2, 1246, 1244, 3, 2, 2, 2, 1246, 1247,
	3, 2, 2, 2, 1247, 1250, 3, 2, 2, 2, 1248, 1246, 3, 2, 2, 2, 1249, 1251,
	7, 135, 2, 2, 1250, 1249, 3, 2, 2, 2, 1250, 1251, 3, 2, 2, 2, 1251, 213,
	3, 2, 2, 2, 1252, 1254, 5, 166, 84, 2, 1253, 1255, 5, 216, 109, 2, 1254,
	1253, 3, 2, 2, 2, 1254, 1255, 3, 2, 2, 2, 1255, 1258, 3, 2, 2, 2, 1256,
	1258, 5, 72, 37, 2, 1257, 1252, 3, 2, 2, 2, 1257, 1256, 3, 2, 2, 2, 1258,
	215, 3, 2, 2, 2, 1259, 1261, 5, 204, 103, 2, 1260, 1262, 5, 216, 109, 2,
	1261, 1260, 3, 2, 2, 2, 1261, 1262, 3, 2, 2, 2, 1262, 1283, 3, 2, 2, 2,
	1263, 1265, 7, 128, 2, 2, 1264, 1266, 5, 216, 109, 2, 1265, 1264, 3, 2,
	2, 2, 1265, 1266, 3, 2, 2, 2, 1266, 1267, 3, 2, 2, 2, 1267, 1269, 7, 129,
	2, 2, 1268, 1270, 5, 218, 110, 2, 1269, 1268, 3, 2, 2, 2, 1270, 1271, 3,
	2, 2, 2, 1271, 1269, 3, 2, 2, 2, 1271, 1272, 3, 2, 2, 2, 1272, 1283, 3,
	2, 2, 2, 1273, 1275, 7, 132, 2, 2, 1274, 1276, 5, 268, 135, 2, 1275, 1274,
	3, 2, 2, 2, 1275, 1276, 3, 2, 2, 2, 1276, 1277, 3, 2, 2, 2, 1277, 1279,
	7, 133, 2, 2, 1278, 1273, 3, 2, 2, 2, 1279, 1280, 3, 2, 2, 2, 1280, 1278,
	3, 2, 2, 2, 1280, 1281, 3, 2, 2, 2, 1281, 1283, 3, 2, 2, 2, 1282, 1259,
	3, 2, 2, 2, 1282, 1263, 3, 2, 2, 2, 1282, 1278, 3, 2, 2, 2, 1283, 217,
	3, 2, 2, 2, 1284, 1286, 7, 132, 2, 2, 1285, 1287, 5, 268, 135, 2, 1286,
	1285, 3, 2, 2, 2, 1286, 1287, 3, 2, 2, 2, 1287, 1288, 3, 2, 2, 2, 1288,
	1295, 7, 133, 2, 2, 1289, 1291, 7, 128, 2, 2, 1290, 1292, 5, 220, 111,
	2, 1291, 1290, 3, 2, 2, 2, 1291, 1292, 3, 2, 2, 2, 1292, 1293, 3, 2, 2,
	2, 1293, 1295, 7, 129, 2, 2, 1294, 1284, 3, 2, 2, 2, 1294, 1289, 3, 2,
	2, 2, 1295, 219, 3, 2, 2, 2, 1296, 1301, 5, 222, 112, 2, 1297, 1298, 7,
	135, 2, 2, 1298, 1300, 5, 222, 112, 2, 1299, 1297, 3, 2, 2, 2, 1300, 1303,
	3, 2, 2, 2, 1301, 1299, 3, 2, 2, 2, 1301, 1302, 3, 2, 2, 2, 1302, 221,
	3, 2, 2, 2, 1303, 1301, 3, 2, 2, 2, 1304, 1305, 5, 154, 78, 2, 1305, 1306,
	5, 224, 113, 2, 1306, 1309, 3, 2, 2, 2, 1307, 1309, 7, 34, 2, 2, 1308,
	1304, 3, 2, 2, 2, 1308, 1307, 3, 2, 2, 2, 1309, 223, 3, 2, 2, 2, 1310,
	1312, 5, 204, 103, 2, 1311, 1310, 3, 2, 2, 2, 1311, 1312, 3, 2, 2, 2, 1312,
	1313, 3, 2, 2, 2, 1313, 1314, 5, 198, 100, 2, 1314, 225, 3, 2, 2, 2, 1315,
	1317, 5, 228, 115, 2, 1316, 1318, 7, 134, 2, 2, 1317, 1316, 3, 2, 2, 2,
	1317, 1318, 3, 2, 2, 2, 1318, 1357, 3, 2, 2, 2, 1319, 1321, 5, 232, 117,
	2, 1320, 1322, 7, 134, 2, 2, 1321, 1320, 3, 2, 2, 2, 1321, 1322, 3, 2,
	2, 2, 1322, 1357, 3, 2, 2, 2, 1323, 1325, 5, 234, 118, 2, 1324, 1326, 7,
	134, 2, 2, 1325, 1324, 3, 2, 2, 2, 1325, 1326, 3, 2, 2, 2, 1326, 1357,
	3, 2, 2, 2, 1327, 1329, 5, 244, 123, 2, 1328, 1330, 7, 134, 2, 2, 1329,
	1328, 3, 2, 2, 2, 1329, 1330, 3, 2, 2, 2, 1330, 1357, 3, 2, 2, 2, 1331,
	1333, 5, 256, 129, 2, 1332, 1334, 7, 134, 2, 2, 1333, 1332, 3, 2, 2, 2,
	1333, 1334, 3, 2, 2, 2, 1334, 1357, 3, 2, 2, 2, 1335, 1337, 5, 118, 60,
	2, 1336, 1338, 7, 134, 2, 2, 1337, 1336, 3, 2, 2, 2, 1337, 1338, 3, 2,
	2, 2, 1338, 1357, 3, 2, 2, 2, 1339, 1341, 5, 120, 61, 2, 1340, 1342, 7,
	134, 2, 2, 1341, 1340, 3, 2, 2, 2, 1341, 1342, 3, 2, 2, 2, 1342, 1357,
	3, 2, 2, 2, 1343, 1345, 5, 112, 57, 2, 1344, 1346, 7, 134, 2, 2, 1345,
	1344, 3, 2, 2, 2, 1345, 1346, 3, 2, 2, 2, 1346, 1357, 3, 2, 2, 2, 1347,
	1349, 5, 114, 58, 2, 1348, 1350, 7, 134, 2, 2, 1349, 1348, 3, 2, 2, 2,
	1349, 1350, 3, 2, 2, 2, 1350, 1357, 3, 2, 2, 2, 1351, 1353, 5, 258, 130,
	2, 1352, 1354, 7, 134, 2, 2, 1353, 1352, 3, 2, 2, 2, 1353, 1354, 3, 2,
	2, 2, 1354, 1357, 3, 2, 2, 2, 1355, 1357, 7, 134, 2, 2, 1356, 1315, 3,
	2, 2, 2, 1356, 1319, 3, 2, 2, 2, 1356, 1323, 3, 2, 2, 2, 1356, 1327, 3,
	2, 2, 2, 1356, 1331, 3, 2, 2, 2, 1356, 1335, 3, 2, 2, 2, 1356, 1339, 3,
	2, 2, 2, 1356, 1343, 3, 2, 2, 2, 1356, 1347, 3, 2, 2, 2, 1356, 1351, 3,
	2, 2, 2, 1356, 1355, 3, 2, 2, 2, 1357, 227, 3, 2, 2, 2, 1358, 1359, 5,
	288, 145, 2, 1359, 1360, 7, 145, 2, 2, 1360, 1361, 5, 226, 114, 2, 1361,
	229, 3, 2, 2, 2, 1362, 1365, 5, 268, 135, 2, 1363, 1364, 7, 172, 2, 2,
	1364, 1366, 5, 268, 135, 2, 1365, 1363, 3, 2, 2, 2, 1365, 1366, 3, 2, 2,
	2, 1366, 231, 3, 2, 2, 2, 1367, 1372, 7, 130, 2, 2, 1368, 1371, 5, 140,
	71, 2, 1369, 1371, 5, 226, 114, 2, 1370, 1368, 3, 2, 2, 2, 1370, 1369,
	3, 2, 2, 2, 1371, 1374, 3, 2, 2, 2, 1372, 1370, 3, 2, 2, 2, 1372, 1373,
	3, 2, 2, 2, 1373, 1375, 3, 2, 2, 2, 1374, 1372, 3, 2, 2, 2, 1375, 1376,
	7, 131, 2, 2, 1376, 233, 3, 2, 2, 2, 1377, 1378, 7, 18, 2, 2, 1378, 1379,
	7, 128, 2, 2, 1379, 1380, 5, 260, 131, 2, 1380, 1381, 7, 129, 2, 2, 1381,
	1384, 5, 226, 114, 2, 1382, 1383, 7, 12, 2, 2, 1383, 1385, 5, 226, 114,
	2, 1384, 1382, 3, 2, 2, 2, 1384, 1385, 3, 2, 2, 2, 1385, 1388, 3, 2, 2,
	2, 1386, 1388, 5, 236, 119, 2, 1387, 1377, 3, 2, 2, 2, 1387, 1386, 3, 2,
	2, 2, 1388, 235, 3, 2, 2, 2, 1389, 1390, 7, 30, 2, 2, 1390, 1391, 7, 128,
	2, 2, 1391, 1392, 5, 260, 131, 2, 1392, 1393, 7, 129, 2, 2, 1393, 1394,
	5, 238, 120, 2, 1394, 237, 3, 2, 2, 2, 1395, 1399, 7, 130, 2, 2, 1396,
	1398, 5, 240, 121, 2, 1397, 1396, 3, 2, 2, 2, 1398, 1401, 3, 2, 2, 2, 1399,
	1397, 3, 2, 2, 2, 1399, 1400, 3, 2, 2, 2, 1400, 1402, 3, 2, 2, 2, 1401,
	1399, 3, 2, 2, 2, 1402, 1403, 7, 131, 2, 2, 1403, 239, 3, 2, 2, 2, 1404,
	1406, 5, 242, 122, 2, 1405, 1404, 3, 2, 2, 2, 1406, 1407, 3, 2, 2, 2, 1407,
	1405, 3, 2, 2, 2, 1407, 1408, 3, 2, 2, 2, 1408, 1410, 3, 2, 2, 2, 1409,
	1411, 5, 226, 114, 2, 1410, 1409, 3, 2, 2, 2, 1411, 1412, 3, 2, 2, 2, 1412,
	1410, 3, 2, 2, 2, 1412, 1413, 3, 2, 2, 2, 1413, 241, 3, 2, 2, 2, 1414,
	1420, 7, 5, 2, 2, 1415, 1421, 5, 230, 116, 2, 1416, 1417, 7, 128, 2, 2,
	1417, 1418, 5, 230, 116, 2, 1418, 1419, 7, 129, 2, 2, 1419, 1421, 3, 2,
	2, 2, 1420, 1415, 3, 2, 2, 2, 1420, 1416, 3, 2, 2, 2, 1421, 1422, 3, 2,
	2, 2, 1422, 1423, 7, 145, 2, 2, 1423, 1427, 3, 2, 2, 2, 1424, 1425, 7,
	9, 2, 2, 1425, 1427, 7, 145, 2, 2, 1426, 1414, 3, 2, 2, 2, 1426, 1424,
	3, 2, 2, 2, 1427, 243, 3, 2, 2, 2, 1428, 1433, 5, 246, 124, 2, 1429, 1433,
	5, 248, 125, 2, 1430, 1433, 5, 250, 126, 2, 1431, 1433, 5, 254, 128, 2,
	1432, 1428, 3, 2, 2, 2, 1432, 1429, 3, 2, 2, 2, 1432, 1430, 3, 2, 2, 2,
	1432, 1431, 3, 2, 2, 2, 1433, 245, 3, 2, 2, 2, 1434, 1435, 7, 36, 2, 2,
	1435, 1436, 7, 128, 2, 2, 1436, 1437, 5, 260, 131, 2, 1437, 1438, 7, 129,
	2, 2, 1438, 1439, 5, 226, 114, 2, 1439, 247, 3, 2, 2, 2, 1440, 1441, 7,
	10, 2, 2, 1441, 1442, 5, 226, 114, 2, 1442, 1443, 7, 36, 2, 2, 1443, 1444,
	7, 128, 2, 2, 1444, 1445, 5, 260, 131, 2, 1445, 1446, 7, 129, 2, 2, 1446,
	1447, 7, 134, 2, 2, 1447, 249, 3, 2, 2, 2, 1448, 1449, 7, 16, 2, 2, 1449,
	1451, 7, 128, 2, 2, 1450, 1452, 5, 252, 127, 2, 1451, 1450, 3, 2, 2, 2,
	1451, 1452, 3, 2, 2, 2, 1452, 1453, 3, 2, 2, 2, 1453, 1455, 7, 134, 2,
	2, 1454, 1456, 5, 260, 131, 2, 1455, 1454, 3, 2, 2, 2, 1455, 1456, 3, 2,
	2, 2, 1456, 1457, 3, 2, 2, 2, 1457, 1459, 7, 134, 2, 2, 1458, 1460, 5,
	258, 130, 2, 1459, 1458, 3, 2, 2, 2, 1459, 1460, 3, 2, 2, 2, 1460, 1461,
	3, 2, 2, 2, 1461, 1462, 7, 129, 2, 2, 1462, 1463, 5, 226, 114, 2, 1463,
	251, 3, 2, 2, 2, 1464, 1465, 5, 154, 78, 2, 1465, 1466, 5, 158, 80, 2,
	1466, 1469, 3, 2, 2, 2, 1467, 1469, 5, 258, 130, 2, 1468, 1464, 3, 2, 2,
	2, 1468, 1467, 3, 2, 2, 2, 1469, 253, 3, 2, 2, 2, 1470, 1471, 7, 16, 2,
	2, 1471, 1472, 7, 128, 2, 2, 1472, 1473, 5, 110, 56, 2, 1473, 1475, 7,
	48, 2, 2, 1474, 1476, 5, 260, 131, 2, 1475, 1474, 3, 2, 2, 2, 1475, 1476,
	3, 2, 2, 2, 1476, 1477, 3, 2, 2, 2, 1477, 1478, 7, 129, 2, 2, 1478, 1479,
	5, 226, 114, 2, 1479, 255, 3, 2, 2, 2, 1480, 1481, 7, 17, 2, 2, 1481, 1489,
	5, 288, 145, 2, 1482, 1489, 7, 8, 2, 2, 1483, 1489, 7, 4, 2, 2, 1484, 1486,
	7, 24, 2, 2, 1485, 1487, 5, 260, 131, 2, 1486, 1485, 3, 2, 2, 2, 1486,
	1487, 3, 2, 2, 2, 1487, 1489, 3, 2, 2, 2, 1488, 1480, 3, 2, 2, 2, 1488,
	1482, 3, 2, 2, 2, 1488, 1483, 3, 2, 2, 2, 1488, 1484, 3, 2, 2, 2, 1489,
	257, 3, 2, 2, 2, 1490, 1495, 5, 260, 131, 2, 1491, 1492, 7, 135, 2, 2,
	1492, 1494, 5, 260, 131, 2, 1493, 1491, 3, 2, 2, 2, 1494, 1497, 3, 2, 2,
	2, 1495, 1493, 3, 2, 2, 2, 1495, 1496, 3, 2, 2, 2, 1496, 259, 3, 2, 2,
	2, 1497, 1495, 3, 2, 2, 2, 1498, 1499, 8, 131, 1, 2, 1499, 1509, 5, 264,
	133, 2, 1500, 1501, 7, 128, 2, 2, 1501, 1502, 5, 232, 117, 2, 1502, 1503,
	7, 129, 2, 2, 1503, 1509, 3, 2, 2, 2, 1504, 1505, 5, 270, 136, 2, 1505,
	1506, 5, 262, 132, 2, 1506, 1507, 5, 260, 131, 3, 1507, 1509, 3, 2, 2,
	2, 1508, 1498, 3, 2, 2, 2, 1508, 1500, 3, 2, 2, 2, 1508, 1504, 3, 2, 2,
	2, 1509, 1554, 3, 2, 2, 2, 1510, 1511, 12, 15, 2, 2, 1511, 1512, 9, 12,
	2, 2, 1512, 1553, 5, 260, 131, 16, 1513, 1514, 12, 14, 2, 2, 1514, 1515,
	9, 13, 2, 2, 1515, 1553, 5, 260, 131, 15, 1516, 1521, 12, 13, 2, 2, 1517,
	1518, 7, 141, 2, 2, 1518, 1522, 7, 141, 2, 2, 1519, 1520, 7, 140, 2, 2,
	1520, 1522, 7, 140, 2, 2, 1521, 1517, 3, 2, 2, 2, 1521, 1519, 3, 2, 2,
	2, 1522, 1523, 3, 2, 2, 2, 1523, 1553, 5, 260, 131, 14, 1524, 1525, 12,
	12, 2, 2, 1525, 1526, 9, 14, 2, 2, 1526, 1553, 5, 260, 131, 13, 1527, 1528,
	12, 11, 2, 2, 1528, 1529, 9, 15, 2, 2, 1529, 1553, 5, 260, 131, 12, 1530,
	1531, 12, 10, 2, 2, 1531, 1532, 7, 158, 2, 2, 1532, 1553, 5, 260, 131,
	11, 1533, 1534, 12, 9, 2, 2, 1534, 1535, 7, 160, 2, 2, 1535, 1553, 5, 260,
	131, 10, 1536, 1537, 12, 8, 2, 2, 1537, 1538, 7, 159, 2, 2, 1538, 1553,
	5, 260, 131, 9, 1539, 1540, 12, 7, 2, 2, 1540, 1541, 7, 150, 2, 2, 1541,
	1553, 5, 260, 131, 8, 1542, 1543, 12, 6, 2, 2, 1543, 1544, 7, 151, 2, 2,
	1544, 1553, 5, 260, 131, 7, 1545, 1546, 12, 5, 2, 2, 1546, 1548, 7, 144,
	2, 2, 1547, 1549, 5, 260, 131, 2, 1548, 1547, 3, 2, 2, 2, 1548, 1549, 3,
	2, 2, 2, 1549, 1550, 3, 2, 2, 2, 1550, 1551, 7, 145, 2, 2, 1551, 1553,
	5, 260, 131, 6, 1552, 1510, 3, 2, 2, 2, 1552, 1513, 3, 2, 2, 2, 1552, 1516,
	3, 2, 2, 2, 1552, 1524, 3, 2, 2, 2, 1552, 1527, 3, 2, 2, 2, 1552, 1530,
	3, 2, 2, 2, 1552, 1533, 3, 2, 2, 2, 1552, 1536, 3, 2, 2, 2, 1552, 1539,
	3, 2, 2, 2, 1552, 1542, 3, 2, 2, 2, 1552, 1545, 3, 2, 2, 2, 1553, 1556,
	3, 2, 2, 2, 1554, 1552, 3, 2, 2, 2, 1554, 1555, 3, 2, 2, 2, 1555, 261,
	3, 2, 2, 2, 1556, 1554, 3, 2, 2, 2, 1557, 1558, 9, 16, 2, 2, 1558, 263,
	3, 2, 2, 2, 1559, 1569, 5, 270, 136, 2, 1560, 1561, 7, 128, 2, 2, 1561,
	1562, 5, 214, 108, 2, 1562, 1563, 7, 129, 2, 2, 1563, 1566, 3, 2, 2, 2,
	1564, 1567, 5, 264, 133, 2, 1565, 1567, 5, 266, 134, 2, 1566, 1564, 3,
	2, 2, 2, 1566, 1565, 3, 2, 2, 2, 1567, 1569, 3, 2, 2, 2, 1568, 1559, 3,
	2, 2, 2, 1568, 1560, 3, 2, 2, 2, 1569, 265, 3, 2, 2, 2, 1570, 1574, 5,
	260, 131, 2, 1571, 1574, 5, 208, 105, 2, 1572, 1574, 5, 210, 106, 2, 1573,
	1570, 3, 2, 2, 2, 1573, 1571, 3, 2, 2, 2, 1573, 1572, 3, 2, 2, 2, 1574,
	267, 3, 2, 2, 2, 1575, 1578, 5, 288, 145, 2, 1576, 1578, 5, 284, 143, 2,
	1577, 1575, 3, 2, 2, 2, 1577, 1576, 3, 2, 2, 2, 1578, 269, 3, 2, 2, 2,
	1579, 1594, 5, 274, 138, 2, 1580, 1586, 7, 27, 2, 2, 1581, 1587, 5, 270,
	136, 2, 1582, 1583, 7, 128, 2, 2, 1583, 1584, 5, 182, 92, 2, 1584, 1585,
	7, 129, 2, 2, 1585, 1587, 3, 2, 2, 2, 1586, 1581, 3, 2, 2, 2, 1586, 1582,
	3, 2, 2, 2, 1587, 1594, 3, 2, 2, 2, 1588, 1589, 9, 17, 2, 2, 1589, 1594,
	5, 270, 136, 2, 1590, 1591, 5, 272, 137, 2, 1591, 1592, 5, 264, 133, 2,
	1592, 1594, 3, 2, 2, 2, 1593, 1579, 3, 2, 2, 2, 1593, 1580, 3, 2, 2, 2,
	1593, 1588, 3, 2, 2, 2, 1593, 1590, 3, 2, 2, 2, 1594, 271, 3, 2, 2, 2,
	1595, 1596, 9, 18, 2, 2, 1596, 273, 3, 2, 2, 2, 1597, 1598, 8, 138, 1,
	2, 1598, 1602, 5, 282, 142, 2, 1599, 1601, 5, 276, 139, 2, 1600, 1599,
	3, 2, 2, 2, 1601, 1604, 3, 2, 2, 2, 1602, 1600, 3, 2, 2, 2, 1602, 1603,
	3, 2, 2, 2, 1603, 1616, 3, 2, 2, 2, 1604, 1602, 3, 2, 2, 2, 1605, 1606,
	12, 3, 2, 2, 1606, 1607, 9, 19, 2, 2, 1607, 1611, 5, 288, 145, 2, 1608,
	1610, 5, 276, 139, 2, 1609, 1608, 3, 2, 2, 2, 1610, 1613, 3, 2, 2, 2, 1611,
	1609, 3, 2, 2, 2, 1611, 1612, 3, 2, 2, 2, 1612, 1615, 3, 2, 2, 2, 1613,
	1611, 3, 2, 2, 2, 1614, 1605, 3, 2, 2, 2, 1615, 1618, 3, 2, 2, 2, 1616,
	1614, 3, 2, 2, 2, 1616, 1617, 3, 2, 2, 2, 1617, 275, 3, 2, 2, 2, 1618,
	1616, 3, 2, 2, 2, 1619, 1620, 7, 132, 2, 2, 1620, 1621, 5, 260, 131, 2,
	1621, 1622, 7, 133, 2, 2, 1622, 1638, 3, 2, 2, 2, 1623, 1625, 7, 128, 2,
	2, 1624, 1626, 5, 278, 140, 2, 1625, 1624, 3, 2, 2, 2, 1625, 1626, 3, 2,
	2, 2, 1626, 1627, 3, 2, 2, 2, 1627, 1638, 7, 129, 2, 2, 1628, 1631, 7,
	128, 2, 2, 1629, 1632, 7, 135, 2, 2, 1630, 1632, 10, 20, 2, 2, 1631, 1629,
	3, 2, 2, 2, 1631, 1630, 3, 2, 2, 2, 1632, 1633, 3, 2, 2, 2, 1633, 1631,
	3, 2, 2, 2, 1633, 1634, 3, 2, 2, 2, 1634, 1635, 3, 2, 2, 2, 1635, 1638,
	7, 129, 2, 2, 1636, 1638, 9, 17, 2, 2, 1637, 1619, 3, 2, 2, 2, 1637, 1623,
	3, 2, 2, 2, 1637, 1628, 3, 2, 2, 2, 1637, 1636, 3, 2, 2, 2, 1638, 277,
	3, 2, 2, 2, 1639, 1644, 5, 280, 141, 2, 1640, 1641, 7, 135, 2, 2, 1641,
	1643, 5, 280, 141, 2, 1642, 1640, 3, 2, 2, 2, 1643, 1646, 3, 2, 2, 2, 1644,
	1642, 3, 2, 2, 2, 1644, 1645, 3, 2, 2, 2, 1645, 279, 3, 2, 2, 2, 1646,
	1644, 3, 2, 2, 2, 1647, 1650, 5, 260, 131, 2, 1648, 1650, 5, 182, 92, 2,
	1649, 1647, 3, 2, 2, 2, 1649, 1648, 3, 2, 2, 2, 1650, 281, 3, 2, 2, 2,
	1651, 1667, 5, 288, 145, 2, 1652, 1667, 5, 284, 143, 2, 1653, 1667, 5,
	286, 144, 2, 1654, 1655, 7, 128, 2, 2, 1655, 1656, 5, 260, 131, 2, 1656,
	1657, 7, 129, 2, 2, 1657, 1667, 3, 2, 2, 2, 1658, 1667, 5, 92, 47, 2, 1659,
	1667, 5, 102, 52, 2, 1660, 1667, 5, 106, 54, 2, 1661, 1667, 5, 108, 55,
	2, 1662, 1667, 5, 78, 40, 2, 1663, 1667, 5, 82, 42, 2, 1664, 1667, 5, 84,
	43, 2, 1665, 1667, 5, 90, 46, 2, 1666, 1651, 3, 2, 2, 2, 1666, 1652, 3,
	2, 2, 2, 1666, 1653, 3, 2, 2, 2, 1666, 1654, 3, 2, 2, 2, 1666, 1658, 3,
	2, 2, 2, 1666, 1659, 3, 2, 2, 2, 1666, 1660, 3, 2, 2, 2, 1666, 1661, 3,
	2, 2, 2, 1666, 1662, 3, 2, 2, 2, 1666, 1663, 3, 2, 2, 2, 1666, 1664, 3,
	2, 2, 2, 1666, 1665, 3, 2, 2, 2, 1667, 283, 3, 2, 2, 2, 1668, 1687, 7,
	175, 2, 2, 1669, 1687, 7, 176, 2, 2, 1670, 1687, 7, 177, 2, 2, 1671, 1673,
	9, 13, 2, 2, 1672, 1671, 3, 2, 2, 2, 1672, 1673, 3, 2, 2, 2, 1673, 1674,
	3, 2, 2, 2, 1674, 1687, 7, 178, 2, 2, 1675, 1677, 9, 13, 2, 2, 1676, 1675,
	3, 2, 2, 2, 1676, 1677, 3, 2, 2, 2, 1677, 1678, 3, 2, 2, 2, 1678, 1687,
	7, 179, 2, 2, 1679, 1687, 7, 173, 2, 2, 1680, 1687, 7, 50, 2, 2, 1681,
	1687, 7, 52, 2, 2, 1682, 1687, 7, 59, 2, 2, 1683, 1687, 7, 51, 2, 2, 1684,
	1687, 7, 40, 2, 2, 1685, 1687, 7, 41, 2, 2, 1686, 1668, 3, 2, 2, 2, 1686,
	1669, 3, 2, 2, 2, 1686, 1670, 3, 2, 2, 2, 1686, 1672, 3, 2, 2, 2, 1686,
	1676, 3, 2, 2, 2, 1686, 1679, 3, 2, 2, 2, 1686, 1680, 3, 2, 2, 2, 1686,
	1681, 3, 2, 2, 2, 1686, 1682, 3, 2, 2, 2, 1686, 1683, 3, 2, 2, 2, 1686,
	1684, 3, 2, 2, 2, 1686, 1685, 3, 2, 2, 2, 1687, 285, 3, 2, 2, 2, 1688,
	1692, 7, 174, 2, 2, 1689, 1691, 9, 21, 2, 2, 1690, 1689, 3, 2, 2, 2, 1691,
	1694, 3, 2, 2, 2, 1692, 1690, 3, 2, 2, 2, 1692, 1693, 3, 2, 2, 2, 1693,
	1695, 3, 2, 2, 2, 1694, 1692, 3, 2, 2, 2, 1695, 1697, 7, 186, 2, 2, 1696,
	1688, 3, 2, 2, 2, 1697, 1698, 3, 2, 2, 2, 1698, 1696, 3, 2, 2, 2, 1698,
	1699, 3, 2, 2, 2, 1699, 287, 3, 2, 2, 2, 1700, 1701, 9, 22, 2, 2, 1701,
	289, 3, 2, 2, 2, 225, 293, 309, 316, 322, 328, 331, 334, 342, 349, 352,
	355, 363, 366, 369, 379, 389, 397, 402, 411, 417, 419, 431, 441, 449, 452,
	455, 464, 487, 494, 497, 503, 512, 518, 520, 529, 531, 540, 544, 553, 555,
	564, 568, 571, 579, 583, 585, 588, 594, 598, 604, 618, 625, 631, 634, 638,
	644, 648, 656, 659, 666, 671, 680, 684, 686, 698, 700, 712, 714, 719, 725,
	728, 734, 738, 741, 744, 755, 761, 763, 766, 774, 779, 785, 794, 799, 801,
	823, 830, 835, 859, 864, 869, 873, 877, 881, 890, 897, 904, 910, 913, 917,
	925, 928, 932, 940, 945, 952, 961, 965, 977, 979, 989, 1000, 1006, 1011,
	1017, 1021, 1026, 1036, 1038, 1046, 1060, 1079, 1081, 1093, 1098, 1102,
	1106, 1110, 1117, 1123, 1135, 1142, 1146, 1151, 1155, 1162, 1167, 1173,
	1176, 1180, 1184, 1191, 1195, 1198, 1207, 1212, 1217, 1219, 1231, 1235,
	1237, 1246, 1250, 1254, 1257, 1261, 1265, 1271, 1275, 1280, 1282, 1286,
	1291, 1294, 1301, 1308, 1311, 1317, 1321, 1325, 1329, 1333, 1337, 1341,
	1345, 1349, 1353, 1356, 1365, 1370, 1372, 1384, 1387, 1399, 1407, 1412,
	1420, 1426, 1432, 1451, 1455, 1459, 1468, 1475, 1486, 1488, 1495, 1508,
	1521, 1548, 1552, 1554, 1566, 1568, 1573, 1577, 1586, 1593, 1602, 1611,
	1616, 1625, 1631, 1633, 1637, 1644, 1649, 1666, 1672, 1676, 1686, 1692,
	1698,
}
var literalNames = []string{
	"", "'auto'", "'break'", "'case'", "'char'", "'const'", "'continue'", "'default'",
	"'do'", "'double'", "", "'enum'", "'extern'", "'float'", "'for'", "'goto'",
	"", "'inline'", "'int'", "'long'", "'register'", "'restrict'", "'return'",
	"'short'", "'signed'", "'sizeof'", "'static'", "'struct'", "'switch'",
	"'typedef'", "'union'", "'unsigned'", "'void'", "'volatile'", "'while'",
	"'_Bool'", "'_Complex'", "'_Imaginery'", "'true'", "'false'", "'BOOL'",
	"'Class'", "'bycopy'", "'byref'", "'id'", "'IMP'", "'in'", "'inout'", "'nil'",
	"'NO'", "'NULL'", "'oneway'", "'out'", "'Protocol'", "'SEL'", "'self'",
	"'super'", "'YES'", "'@autoreleasepool'", "'@catch'", "'@class'", "'@dynamic'",
	"'@encode'", "'@end'", "'@finally'", "'@implementation'", "'@interface'",
	"'@import'", "'@package'", "'@protocol'", "'@optional'", "'@private'",
	"'@property'", "'@protected'", "'@public'", "'@required'", "'@selector'",
	"'@synchronized'", "'@synthesize'", "'@throw'", "'@try'", "'atomic'", "'nonatomic'",
	"'retain'", "'__attribute__'", "'__autoreleasing'", "'__block'", "'__bridge'",
	"'__bridge_retained'", "'__bridge_transfer'", "'__covariant'", "'__contravariant'",
	"'__deprecated'", "'__kindof'", "'__strong'", "", "'__unsafe_unretained'",
	"'__unused'", "'__weak'", "", "", "", "'null_resettable'", "'NS_INLINE'",
	"'NS_ENUM'", "'NS_OPTIONS'", "'assign'", "'copy'", "'getter'", "'setter'",
	"'strong'", "'readonly'", "'readwrite'", "'weak'", "'unsafe_unretained'",
	"'IBOutlet'", "'IBOutletCollection'", "'IBInspectable'", "'IB_DESIGNABLE'",
	"", "", "", "", "", "'__TVOS_PROHIBITED'", "", "", "", "'{'", "'}'", "'['",
	"']'", "';'", "','", "'.'", "'->'", "'@'", "'='", "", "", "", "'~'", "'?'",
	"':'", "", "", "", "", "", "", "'++'", "'--'", "'+'", "'-'", "'*'", "'/'",
	"'&'", "'|'", "'^'", "'%'", "'+='", "'-='", "'*='", "'/='", "'&='", "'|='",
	"'^='", "'%='", "'<<='", "'>>='", "'...'", "", "", "", "", "", "", "",
	"", "", "", "'\\'", "", "", "", "", "", "", "", "", "'defined'", "", "'elif'",
	"", "'undef'", "'ifdef'", "'ifndef'", "'endif'",
}
var symbolicNames = []string{
	"", "AUTO", "BREAK", "CASE", "CHAR", "CONST", "CONTINUE", "DEFAULT", "DO",
	"DOUBLE", "ELSE", "ENUM", "EXTERN", "FLOAT", "FOR", "GOTO", "IF", "INLINE",
	"INT", "LONG", "REGISTER", "RESTRICT", "RETURN", "SHORT", "SIGNED", "SIZEOF",
	"STATIC", "STRUCT", "SWITCH", "TYPEDEF", "UNION", "UNSIGNED", "VOID", "VOLATILE",
	"WHILE", "BOOL_", "COMPLEX", "IMAGINERY", "TRUE", "FALSE", "BOOL", "Class",
	"BYCOPY", "BYREF", "ID", "IMP", "IN", "INOUT", "NIL", "NO", "NULL_", "ONEWAY",
	"OUT", "PROTOCOL_", "SEL", "SELF", "SUPER", "YES", "AUTORELEASEPOOL", "CATCH",
	"CLASS", "DYNAMIC", "ENCODE", "END", "FINALLY", "IMPLEMENTATION", "INTERFACE",
	"IMPORT", "PACKAGE", "PROTOCOL", "OPTIONAL", "PRIVATE", "PROPERTY", "PROTECTED",
	"PUBLIC", "REQUIRED", "SELECTOR", "SYNCHRONIZED", "SYNTHESIZE", "THROW",
	"TRY", "ATOMIC", "NONATOMIC", "RETAIN", "ATTRIBUTE", "AUTORELEASING_QUALIFIER",
	"BLOCK", "BRIDGE", "BRIDGE_RETAINED", "BRIDGE_TRANSFER", "COVARIANT", "CONTRAVARIANT",
	"DEPRECATED", "KINDOF", "STRONG_QUALIFIER", "TYPEOF", "UNSAFE_UNRETAINED_QUALIFIER",
	"UNUSED", "WEAK_QUALIFIER", "NULL_UNSPECIFIED", "NULLABLE", "NONNULL",
	"NULL_RESETTABLE", "NS_INLINE", "NS_ENUM", "NS_OPTIONS", "ASSIGN", "COPY",
	"GETTER", "SETTER", "STRONG", "READONLY", "READWRITE", "WEAK", "UNSAFE_UNRETAINED",
	"IB_OUTLET", "IB_OUTLET_COLLECTION", "IB_INSPECTABLE", "IB_DESIGNABLE",
	"NS_ASSUME_NONNULL_BEGIN", "NS_ASSUME_NONNULL_END", "EXTERN_SUFFIX", "IOS_SUFFIX",
	"MAC_SUFFIX", "TVOS_PROHIBITED", "IDENTIFIER", "LP", "RP", "LBRACE", "RBRACE",
	"LBRACK", "RBRACK", "SEMI", "COMMA", "DOT", "STRUCTACCESS", "AT", "ASSIGNMENT",
	"GT", "LT", "BANG", "TILDE", "QUESTION", "COLON", "EQUAL", "LE", "GE",
	"NOTEQUAL", "AND", "OR", "INC", "DEC", "ADD", "SUB", "MUL", "DIV", "BITAND",
	"BITOR", "BITXOR", "MOD", "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN",
	"AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN", "MOD_ASSIGN", "LSHIFT_ASSIGN",
	"RSHIFT_ASSIGN", "ELIPSIS", "CHARACTER_LITERAL", "STRING_START", "HEX_LITERAL",
	"OCTAL_LITERAL", "BINARY_LITERAL", "DECIMAL_LITERAL", "FLOATING_POINT_LITERAL",
	"WS", "MULTI_COMMENT", "SINGLE_COMMENT", "BACKSLASH", "SHARP", "STRING_NEWLINE",
	"STRING_END", "STRING_VALUE", "DIRECTIVE_IMPORT", "DIRECTIVE_INCLUDE",
	"DIRECTIVE_PRAGMA", "DIRECTIVE_DEFINE", "DIRECTIVE_DEFINED", "DIRECTIVE_IF",
	"DIRECTIVE_ELIF", "DIRECTIVE_ELSE", "DIRECTIVE_UNDEF", "DIRECTIVE_IFDEF",
	"DIRECTIVE_IFNDEF", "DIRECTIVE_ENDIF", "DIRECTIVE_TRUE", "DIRECTIVE_FALSE",
	"DIRECTIVE_ERROR", "DIRECTIVE_WARNING", "DIRECTIVE_BANG", "DIRECTIVE_LP",
	"DIRECTIVE_RP", "DIRECTIVE_EQUAL", "DIRECTIVE_NOTEQUAL", "DIRECTIVE_AND",
	"DIRECTIVE_OR", "DIRECTIVE_LT", "DIRECTIVE_GT", "DIRECTIVE_LE", "DIRECTIVE_GE",
	"DIRECTIVE_STRING", "DIRECTIVE_ID", "DIRECTIVE_DECIMAL_LITERAL", "DIRECTIVE_FLOAT",
	"DIRECTIVE_NEWLINE", "DIRECTIVE_MULTI_COMMENT", "DIRECTIVE_SINGLE_COMMENT",
	"DIRECTIVE_BACKSLASH_NEWLINE", "DIRECTIVE_TEXT_NEWLINE", "DIRECTIVE_TEXT",
}

var ruleNames = []string{
	"translationUnit", "topLevelDeclaration", "importDeclaration", "classInterface",
	"categoryInterface", "classImplementation", "categoryImplementation", "genericTypeSpecifier",
	"protocolDeclaration", "protocolDeclarationSection", "protocolDeclarationList",
	"classDeclarationList", "protocolList", "propertyDeclaration", "propertyAttributesList",
	"propertyAttribute", "protocolName", "instanceVariables", "visibilitySection",
	"accessModifier", "interfaceDeclarationList", "classMethodDeclaration",
	"instanceMethodDeclaration", "methodDeclaration", "implementationDefinitionList",
	"classMethodDefinition", "instanceMethodDefinition", "methodDefinition",
	"methodSelector", "keywordDeclarator", "selector", "methodType", "propertyImplementation",
	"propertySynthesizeList", "propertySynthesizeItem", "blockType", "genericsSpecifier",
	"typeSpecifierWithPrefixes", "dictionaryExpression", "dictionaryPair",
	"arrayExpression", "boxExpression", "blockParameters", "typeVariableDeclaratorOrName",
	"blockExpression", "messageExpression", "receiver", "messageSelector",
	"keywordArgument", "keywordArgumentType", "selectorExpression", "selectorName",
	"protocolExpression", "encodeExpression", "typeVariableDeclarator", "throwStatement",
	"tryBlock", "catchStatement", "synchronizedStatement", "autoreleaseStatement",
	"functionDeclaration", "functionDefinition", "functionSignature", "attribute",
	"attributeName", "attributeParameters", "attributeParameterList", "attributeParameter",
	"attributeParameterAssignment", "declaration", "functionCallExpression",
	"enumDeclaration", "varDeclaration", "typedefDeclaration", "typeDeclaratorList",
	"typeDeclarator", "declarationSpecifiers", "attributeSpecifier", "initDeclaratorList",
	"initDeclarator", "structOrUnionSpecifier", "fieldDeclaration", "specifierQualifierList",
	"ibOutletQualifier", "arcBehaviourSpecifier", "nullabilitySpecifier", "storageClassSpecifier",
	"typePrefix", "typeQualifier", "protocolQualifier", "typeSpecifier", "typeofExpression",
	"fieldDeclaratorList", "fieldDeclarator", "enumSpecifier", "enumeratorList",
	"enumerator", "enumeratorIdentifier", "directDeclarator", "declaratorSuffix",
	"parameterList", "pointer", "macro", "arrayInitializer", "structInitializer",
	"initializerList", "typeName", "abstractDeclarator", "abstractDeclaratorSuffix",
	"parameterDeclarationList", "parameterDeclaration", "declarator", "statement",
	"labeledStatement", "rangeExpression", "compoundStatement", "selectionStatement",
	"switchStatement", "switchBlock", "switchSection", "switchLabel", "iterationStatement",
	"whileStatement", "doStatement", "forStatement", "forLoopInitializer",
	"forInStatement", "jumpStatement", "expressions", "expression", "assignmentOperator",
	"castExpression", "initializer", "constantExpression", "unaryExpression",
	"unaryOperator", "postfixExpression", "postfix", "argumentExpressionList",
	"argumentExpression", "primaryExpression", "constant", "stringLiteral",
	"identifier",
}

type ObjectiveCParser struct {
	*antlr.BaseParser
}

// NewObjectiveCParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *ObjectiveCParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewObjectiveCParser(input antlr.TokenStream) *ObjectiveCParser {
	this := new(ObjectiveCParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ObjectiveCParser.g4"

	return this
}

// ObjectiveCParser tokens.
const (
	ObjectiveCParserEOF                         = antlr.TokenEOF
	ObjectiveCParserAUTO                        = 1
	ObjectiveCParserBREAK                       = 2
	ObjectiveCParserCASE                        = 3
	ObjectiveCParserCHAR                        = 4
	ObjectiveCParserCONST                       = 5
	ObjectiveCParserCONTINUE                    = 6
	ObjectiveCParserDEFAULT                     = 7
	ObjectiveCParserDO                          = 8
	ObjectiveCParserDOUBLE                      = 9
	ObjectiveCParserELSE                        = 10
	ObjectiveCParserENUM                        = 11
	ObjectiveCParserEXTERN                      = 12
	ObjectiveCParserFLOAT                       = 13
	ObjectiveCParserFOR                         = 14
	ObjectiveCParserGOTO                        = 15
	ObjectiveCParserIF                          = 16
	ObjectiveCParserINLINE                      = 17
	ObjectiveCParserINT                         = 18
	ObjectiveCParserLONG                        = 19
	ObjectiveCParserREGISTER                    = 20
	ObjectiveCParserRESTRICT                    = 21
	ObjectiveCParserRETURN                      = 22
	ObjectiveCParserSHORT                       = 23
	ObjectiveCParserSIGNED                      = 24
	ObjectiveCParserSIZEOF                      = 25
	ObjectiveCParserSTATIC                      = 26
	ObjectiveCParserSTRUCT                      = 27
	ObjectiveCParserSWITCH                      = 28
	ObjectiveCParserTYPEDEF                     = 29
	ObjectiveCParserUNION                       = 30
	ObjectiveCParserUNSIGNED                    = 31
	ObjectiveCParserVOID                        = 32
	ObjectiveCParserVOLATILE                    = 33
	ObjectiveCParserWHILE                       = 34
	ObjectiveCParserBOOL_                       = 35
	ObjectiveCParserCOMPLEX                     = 36
	ObjectiveCParserIMAGINERY                   = 37
	ObjectiveCParserTRUE                        = 38
	ObjectiveCParserFALSE                       = 39
	ObjectiveCParserBOOL                        = 40
	ObjectiveCParserClass                       = 41
	ObjectiveCParserBYCOPY                      = 42
	ObjectiveCParserBYREF                       = 43
	ObjectiveCParserID                          = 44
	ObjectiveCParserIMP                         = 45
	ObjectiveCParserIN                          = 46
	ObjectiveCParserINOUT                       = 47
	ObjectiveCParserNIL                         = 48
	ObjectiveCParserNO                          = 49
	ObjectiveCParserNULL_                       = 50
	ObjectiveCParserONEWAY                      = 51
	ObjectiveCParserOUT                         = 52
	ObjectiveCParserPROTOCOL_                   = 53
	ObjectiveCParserSEL                         = 54
	ObjectiveCParserSELF                        = 55
	ObjectiveCParserSUPER                       = 56
	ObjectiveCParserYES                         = 57
	ObjectiveCParserAUTORELEASEPOOL             = 58
	ObjectiveCParserCATCH                       = 59
	ObjectiveCParserCLASS                       = 60
	ObjectiveCParserDYNAMIC                     = 61
	ObjectiveCParserENCODE                      = 62
	ObjectiveCParserEND                         = 63
	ObjectiveCParserFINALLY                     = 64
	ObjectiveCParserIMPLEMENTATION              = 65
	ObjectiveCParserINTERFACE                   = 66
	ObjectiveCParserIMPORT                      = 67
	ObjectiveCParserPACKAGE                     = 68
	ObjectiveCParserPROTOCOL                    = 69
	ObjectiveCParserOPTIONAL                    = 70
	ObjectiveCParserPRIVATE                     = 71
	ObjectiveCParserPROPERTY                    = 72
	ObjectiveCParserPROTECTED                   = 73
	ObjectiveCParserPUBLIC                      = 74
	ObjectiveCParserREQUIRED                    = 75
	ObjectiveCParserSELECTOR                    = 76
	ObjectiveCParserSYNCHRONIZED                = 77
	ObjectiveCParserSYNTHESIZE                  = 78
	ObjectiveCParserTHROW                       = 79
	ObjectiveCParserTRY                         = 80
	ObjectiveCParserATOMIC                      = 81
	ObjectiveCParserNONATOMIC                   = 82
	ObjectiveCParserRETAIN                      = 83
	ObjectiveCParserATTRIBUTE                   = 84
	ObjectiveCParserAUTORELEASING_QUALIFIER     = 85
	ObjectiveCParserBLOCK                       = 86
	ObjectiveCParserBRIDGE                      = 87
	ObjectiveCParserBRIDGE_RETAINED             = 88
	ObjectiveCParserBRIDGE_TRANSFER             = 89
	ObjectiveCParserCOVARIANT                   = 90
	ObjectiveCParserCONTRAVARIANT               = 91
	ObjectiveCParserDEPRECATED                  = 92
	ObjectiveCParserKINDOF                      = 93
	ObjectiveCParserSTRONG_QUALIFIER            = 94
	ObjectiveCParserTYPEOF                      = 95
	ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER = 96
	ObjectiveCParserUNUSED                      = 97
	ObjectiveCParserWEAK_QUALIFIER              = 98
	ObjectiveCParserNULL_UNSPECIFIED            = 99
	ObjectiveCParserNULLABLE                    = 100
	ObjectiveCParserNONNULL                     = 101
	ObjectiveCParserNULL_RESETTABLE             = 102
	ObjectiveCParserNS_INLINE                   = 103
	ObjectiveCParserNS_ENUM                     = 104
	ObjectiveCParserNS_OPTIONS                  = 105
	ObjectiveCParserASSIGN                      = 106
	ObjectiveCParserCOPY                        = 107
	ObjectiveCParserGETTER                      = 108
	ObjectiveCParserSETTER                      = 109
	ObjectiveCParserSTRONG                      = 110
	ObjectiveCParserREADONLY                    = 111
	ObjectiveCParserREADWRITE                   = 112
	ObjectiveCParserWEAK                        = 113
	ObjectiveCParserUNSAFE_UNRETAINED           = 114
	ObjectiveCParserIB_OUTLET                   = 115
	ObjectiveCParserIB_OUTLET_COLLECTION        = 116
	ObjectiveCParserIB_INSPECTABLE              = 117
	ObjectiveCParserIB_DESIGNABLE               = 118
	ObjectiveCParserNS_ASSUME_NONNULL_BEGIN     = 119
	ObjectiveCParserNS_ASSUME_NONNULL_END       = 120
	ObjectiveCParserEXTERN_SUFFIX               = 121
	ObjectiveCParserIOS_SUFFIX                  = 122
	ObjectiveCParserMAC_SUFFIX                  = 123
	ObjectiveCParserTVOS_PROHIBITED             = 124
	ObjectiveCParserIDENTIFIER                  = 125
	ObjectiveCParserLP                          = 126
	ObjectiveCParserRP                          = 127
	ObjectiveCParserLBRACE                      = 128
	ObjectiveCParserRBRACE                      = 129
	ObjectiveCParserLBRACK                      = 130
	ObjectiveCParserRBRACK                      = 131
	ObjectiveCParserSEMI                        = 132
	ObjectiveCParserCOMMA                       = 133
	ObjectiveCParserDOT                         = 134
	ObjectiveCParserSTRUCTACCESS                = 135
	ObjectiveCParserAT                          = 136
	ObjectiveCParserASSIGNMENT                  = 137
	ObjectiveCParserGT                          = 138
	ObjectiveCParserLT                          = 139
	ObjectiveCParserBANG                        = 140
	ObjectiveCParserTILDE                       = 141
	ObjectiveCParserQUESTION                    = 142
	ObjectiveCParserCOLON                       = 143
	ObjectiveCParserEQUAL                       = 144
	ObjectiveCParserLE                          = 145
	ObjectiveCParserGE                          = 146
	ObjectiveCParserNOTEQUAL                    = 147
	ObjectiveCParserAND                         = 148
	ObjectiveCParserOR                          = 149
	ObjectiveCParserINC                         = 150
	ObjectiveCParserDEC                         = 151
	ObjectiveCParserADD                         = 152
	ObjectiveCParserSUB                         = 153
	ObjectiveCParserMUL                         = 154
	ObjectiveCParserDIV                         = 155
	ObjectiveCParserBITAND                      = 156
	ObjectiveCParserBITOR                       = 157
	ObjectiveCParserBITXOR                      = 158
	ObjectiveCParserMOD                         = 159
	ObjectiveCParserADD_ASSIGN                  = 160
	ObjectiveCParserSUB_ASSIGN                  = 161
	ObjectiveCParserMUL_ASSIGN                  = 162
	ObjectiveCParserDIV_ASSIGN                  = 163
	ObjectiveCParserAND_ASSIGN                  = 164
	ObjectiveCParserOR_ASSIGN                   = 165
	ObjectiveCParserXOR_ASSIGN                  = 166
	ObjectiveCParserMOD_ASSIGN                  = 167
	ObjectiveCParserLSHIFT_ASSIGN               = 168
	ObjectiveCParserRSHIFT_ASSIGN               = 169
	ObjectiveCParserELIPSIS                     = 170
	ObjectiveCParserCHARACTER_LITERAL           = 171
	ObjectiveCParserSTRING_START                = 172
	ObjectiveCParserHEX_LITERAL                 = 173
	ObjectiveCParserOCTAL_LITERAL               = 174
	ObjectiveCParserBINARY_LITERAL              = 175
	ObjectiveCParserDECIMAL_LITERAL             = 176
	ObjectiveCParserFLOATING_POINT_LITERAL      = 177
	ObjectiveCParserWS                          = 178
	ObjectiveCParserMULTI_COMMENT               = 179
	ObjectiveCParserSINGLE_COMMENT              = 180
	ObjectiveCParserBACKSLASH                   = 181
	ObjectiveCParserSHARP                       = 182
	ObjectiveCParserSTRING_NEWLINE              = 183
	ObjectiveCParserSTRING_END                  = 184
	ObjectiveCParserSTRING_VALUE                = 185
	ObjectiveCParserDIRECTIVE_IMPORT            = 186
	ObjectiveCParserDIRECTIVE_INCLUDE           = 187
	ObjectiveCParserDIRECTIVE_PRAGMA            = 188
	ObjectiveCParserDIRECTIVE_DEFINE            = 189
	ObjectiveCParserDIRECTIVE_DEFINED           = 190
	ObjectiveCParserDIRECTIVE_IF                = 191
	ObjectiveCParserDIRECTIVE_ELIF              = 192
	ObjectiveCParserDIRECTIVE_ELSE              = 193
	ObjectiveCParserDIRECTIVE_UNDEF             = 194
	ObjectiveCParserDIRECTIVE_IFDEF             = 195
	ObjectiveCParserDIRECTIVE_IFNDEF            = 196
	ObjectiveCParserDIRECTIVE_ENDIF             = 197
	ObjectiveCParserDIRECTIVE_TRUE              = 198
	ObjectiveCParserDIRECTIVE_FALSE             = 199
	ObjectiveCParserDIRECTIVE_ERROR             = 200
	ObjectiveCParserDIRECTIVE_WARNING           = 201
	ObjectiveCParserDIRECTIVE_BANG              = 202
	ObjectiveCParserDIRECTIVE_LP                = 203
	ObjectiveCParserDIRECTIVE_RP                = 204
	ObjectiveCParserDIRECTIVE_EQUAL             = 205
	ObjectiveCParserDIRECTIVE_NOTEQUAL          = 206
	ObjectiveCParserDIRECTIVE_AND               = 207
	ObjectiveCParserDIRECTIVE_OR                = 208
	ObjectiveCParserDIRECTIVE_LT                = 209
	ObjectiveCParserDIRECTIVE_GT                = 210
	ObjectiveCParserDIRECTIVE_LE                = 211
	ObjectiveCParserDIRECTIVE_GE                = 212
	ObjectiveCParserDIRECTIVE_STRING            = 213
	ObjectiveCParserDIRECTIVE_ID                = 214
	ObjectiveCParserDIRECTIVE_DECIMAL_LITERAL   = 215
	ObjectiveCParserDIRECTIVE_FLOAT             = 216
	ObjectiveCParserDIRECTIVE_NEWLINE           = 217
	ObjectiveCParserDIRECTIVE_MULTI_COMMENT     = 218
	ObjectiveCParserDIRECTIVE_SINGLE_COMMENT    = 219
	ObjectiveCParserDIRECTIVE_BACKSLASH_NEWLINE = 220
	ObjectiveCParserDIRECTIVE_TEXT_NEWLINE      = 221
	ObjectiveCParserDIRECTIVE_TEXT              = 222
)

// ObjectiveCParser rules.
const (
	ObjectiveCParserRULE_translationUnit              = 0
	ObjectiveCParserRULE_topLevelDeclaration          = 1
	ObjectiveCParserRULE_importDeclaration            = 2
	ObjectiveCParserRULE_classInterface               = 3
	ObjectiveCParserRULE_categoryInterface            = 4
	ObjectiveCParserRULE_classImplementation          = 5
	ObjectiveCParserRULE_categoryImplementation       = 6
	ObjectiveCParserRULE_genericTypeSpecifier         = 7
	ObjectiveCParserRULE_protocolDeclaration          = 8
	ObjectiveCParserRULE_protocolDeclarationSection   = 9
	ObjectiveCParserRULE_protocolDeclarationList      = 10
	ObjectiveCParserRULE_classDeclarationList         = 11
	ObjectiveCParserRULE_protocolList                 = 12
	ObjectiveCParserRULE_propertyDeclaration          = 13
	ObjectiveCParserRULE_propertyAttributesList       = 14
	ObjectiveCParserRULE_propertyAttribute            = 15
	ObjectiveCParserRULE_protocolName                 = 16
	ObjectiveCParserRULE_instanceVariables            = 17
	ObjectiveCParserRULE_visibilitySection            = 18
	ObjectiveCParserRULE_accessModifier               = 19
	ObjectiveCParserRULE_interfaceDeclarationList     = 20
	ObjectiveCParserRULE_classMethodDeclaration       = 21
	ObjectiveCParserRULE_instanceMethodDeclaration    = 22
	ObjectiveCParserRULE_methodDeclaration            = 23
	ObjectiveCParserRULE_implementationDefinitionList = 24
	ObjectiveCParserRULE_classMethodDefinition        = 25
	ObjectiveCParserRULE_instanceMethodDefinition     = 26
	ObjectiveCParserRULE_methodDefinition             = 27
	ObjectiveCParserRULE_methodSelector               = 28
	ObjectiveCParserRULE_keywordDeclarator            = 29
	ObjectiveCParserRULE_selector                     = 30
	ObjectiveCParserRULE_methodType                   = 31
	ObjectiveCParserRULE_propertyImplementation       = 32
	ObjectiveCParserRULE_propertySynthesizeList       = 33
	ObjectiveCParserRULE_propertySynthesizeItem       = 34
	ObjectiveCParserRULE_blockType                    = 35
	ObjectiveCParserRULE_genericsSpecifier            = 36
	ObjectiveCParserRULE_typeSpecifierWithPrefixes    = 37
	ObjectiveCParserRULE_dictionaryExpression         = 38
	ObjectiveCParserRULE_dictionaryPair               = 39
	ObjectiveCParserRULE_arrayExpression              = 40
	ObjectiveCParserRULE_boxExpression                = 41
	ObjectiveCParserRULE_blockParameters              = 42
	ObjectiveCParserRULE_typeVariableDeclaratorOrName = 43
	ObjectiveCParserRULE_blockExpression              = 44
	ObjectiveCParserRULE_messageExpression            = 45
	ObjectiveCParserRULE_receiver                     = 46
	ObjectiveCParserRULE_messageSelector              = 47
	ObjectiveCParserRULE_keywordArgument              = 48
	ObjectiveCParserRULE_keywordArgumentType          = 49
	ObjectiveCParserRULE_selectorExpression           = 50
	ObjectiveCParserRULE_selectorName                 = 51
	ObjectiveCParserRULE_protocolExpression           = 52
	ObjectiveCParserRULE_encodeExpression             = 53
	ObjectiveCParserRULE_typeVariableDeclarator       = 54
	ObjectiveCParserRULE_throwStatement               = 55
	ObjectiveCParserRULE_tryBlock                     = 56
	ObjectiveCParserRULE_catchStatement               = 57
	ObjectiveCParserRULE_synchronizedStatement        = 58
	ObjectiveCParserRULE_autoreleaseStatement         = 59
	ObjectiveCParserRULE_functionDeclaration          = 60
	ObjectiveCParserRULE_functionDefinition           = 61
	ObjectiveCParserRULE_functionSignature            = 62
	ObjectiveCParserRULE_attribute                    = 63
	ObjectiveCParserRULE_attributeName                = 64
	ObjectiveCParserRULE_attributeParameters          = 65
	ObjectiveCParserRULE_attributeParameterList       = 66
	ObjectiveCParserRULE_attributeParameter           = 67
	ObjectiveCParserRULE_attributeParameterAssignment = 68
	ObjectiveCParserRULE_declaration                  = 69
	ObjectiveCParserRULE_functionCallExpression       = 70
	ObjectiveCParserRULE_enumDeclaration              = 71
	ObjectiveCParserRULE_varDeclaration               = 72
	ObjectiveCParserRULE_typedefDeclaration           = 73
	ObjectiveCParserRULE_typeDeclaratorList           = 74
	ObjectiveCParserRULE_typeDeclarator               = 75
	ObjectiveCParserRULE_declarationSpecifiers        = 76
	ObjectiveCParserRULE_attributeSpecifier           = 77
	ObjectiveCParserRULE_initDeclaratorList           = 78
	ObjectiveCParserRULE_initDeclarator               = 79
	ObjectiveCParserRULE_structOrUnionSpecifier       = 80
	ObjectiveCParserRULE_fieldDeclaration             = 81
	ObjectiveCParserRULE_specifierQualifierList       = 82
	ObjectiveCParserRULE_ibOutletQualifier            = 83
	ObjectiveCParserRULE_arcBehaviourSpecifier        = 84
	ObjectiveCParserRULE_nullabilitySpecifier         = 85
	ObjectiveCParserRULE_storageClassSpecifier        = 86
	ObjectiveCParserRULE_typePrefix                   = 87
	ObjectiveCParserRULE_typeQualifier                = 88
	ObjectiveCParserRULE_protocolQualifier            = 89
	ObjectiveCParserRULE_typeSpecifier                = 90
	ObjectiveCParserRULE_typeofExpression             = 91
	ObjectiveCParserRULE_fieldDeclaratorList          = 92
	ObjectiveCParserRULE_fieldDeclarator              = 93
	ObjectiveCParserRULE_enumSpecifier                = 94
	ObjectiveCParserRULE_enumeratorList               = 95
	ObjectiveCParserRULE_enumerator                   = 96
	ObjectiveCParserRULE_enumeratorIdentifier         = 97
	ObjectiveCParserRULE_directDeclarator             = 98
	ObjectiveCParserRULE_declaratorSuffix             = 99
	ObjectiveCParserRULE_parameterList                = 100
	ObjectiveCParserRULE_pointer                      = 101
	ObjectiveCParserRULE_macro                        = 102
	ObjectiveCParserRULE_arrayInitializer             = 103
	ObjectiveCParserRULE_structInitializer            = 104
	ObjectiveCParserRULE_initializerList              = 105
	ObjectiveCParserRULE_typeName                     = 106
	ObjectiveCParserRULE_abstractDeclarator           = 107
	ObjectiveCParserRULE_abstractDeclaratorSuffix     = 108
	ObjectiveCParserRULE_parameterDeclarationList     = 109
	ObjectiveCParserRULE_parameterDeclaration         = 110
	ObjectiveCParserRULE_declarator                   = 111
	ObjectiveCParserRULE_statement                    = 112
	ObjectiveCParserRULE_labeledStatement             = 113
	ObjectiveCParserRULE_rangeExpression              = 114
	ObjectiveCParserRULE_compoundStatement            = 115
	ObjectiveCParserRULE_selectionStatement           = 116
	ObjectiveCParserRULE_switchStatement              = 117
	ObjectiveCParserRULE_switchBlock                  = 118
	ObjectiveCParserRULE_switchSection                = 119
	ObjectiveCParserRULE_switchLabel                  = 120
	ObjectiveCParserRULE_iterationStatement           = 121
	ObjectiveCParserRULE_whileStatement               = 122
	ObjectiveCParserRULE_doStatement                  = 123
	ObjectiveCParserRULE_forStatement                 = 124
	ObjectiveCParserRULE_forLoopInitializer           = 125
	ObjectiveCParserRULE_forInStatement               = 126
	ObjectiveCParserRULE_jumpStatement                = 127
	ObjectiveCParserRULE_expressions                  = 128
	ObjectiveCParserRULE_expression                   = 129
	ObjectiveCParserRULE_assignmentOperator           = 130
	ObjectiveCParserRULE_castExpression               = 131
	ObjectiveCParserRULE_initializer                  = 132
	ObjectiveCParserRULE_constantExpression           = 133
	ObjectiveCParserRULE_unaryExpression              = 134
	ObjectiveCParserRULE_unaryOperator                = 135
	ObjectiveCParserRULE_postfixExpression            = 136
	ObjectiveCParserRULE_postfix                      = 137
	ObjectiveCParserRULE_argumentExpressionList       = 138
	ObjectiveCParserRULE_argumentExpression           = 139
	ObjectiveCParserRULE_primaryExpression            = 140
	ObjectiveCParserRULE_constant                     = 141
	ObjectiveCParserRULE_stringLiteral                = 142
	ObjectiveCParserRULE_identifier                   = 143
)

// ITranslationUnitContext is an interface to support dynamic dispatch.
type ITranslationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTranslationUnitContext differentiates from other interfaces.
	IsTranslationUnitContext()
}

type TranslationUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslationUnitContext() *TranslationUnitContext {
	var p = new(TranslationUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_translationUnit
	return p
}

func (*TranslationUnitContext) IsTranslationUnitContext() {}

func NewTranslationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TranslationUnitContext {
	var p = new(TranslationUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_translationUnit

	return p
}

func (s *TranslationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *TranslationUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserEOF, 0)
}

func (s *TranslationUnitContext) AllTopLevelDeclaration() []ITopLevelDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITopLevelDeclarationContext)(nil)).Elem())
	var tst = make([]ITopLevelDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITopLevelDeclarationContext)
		}
	}

	return tst
}

func (s *TranslationUnitContext) TopLevelDeclaration(i int) ITopLevelDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopLevelDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITopLevelDeclarationContext)
}

func (s *TranslationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TranslationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterTranslationUnit(s)
	}
}

func (s *TranslationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitTranslationUnit(s)
	}
}

func (p *ObjectiveCParser) TranslationUnit() (localctx ITranslationUnitContext) {
	this := p
	_ = this

	localctx = NewTranslationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ObjectiveCParserRULE_translationUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(291)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserAUTO)|(1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserEXTERN)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserREGISTER)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSTATIC)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserTYPEDEF)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32))|(1<<(ObjectiveCParserCLASS-32)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(ObjectiveCParserIMPLEMENTATION-65))|(1<<(ObjectiveCParserINTERFACE-65))|(1<<(ObjectiveCParserIMPORT-65))|(1<<(ObjectiveCParserPROTOCOL-65))|(1<<(ObjectiveCParserATOMIC-65))|(1<<(ObjectiveCParserNONATOMIC-65))|(1<<(ObjectiveCParserRETAIN-65))|(1<<(ObjectiveCParserATTRIBUTE-65))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-65))|(1<<(ObjectiveCParserBLOCK-65))|(1<<(ObjectiveCParserBRIDGE-65))|(1<<(ObjectiveCParserBRIDGE_RETAINED-65))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-65))|(1<<(ObjectiveCParserCOVARIANT-65))|(1<<(ObjectiveCParserCONTRAVARIANT-65))|(1<<(ObjectiveCParserDEPRECATED-65))|(1<<(ObjectiveCParserKINDOF-65))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-65))|(1<<(ObjectiveCParserTYPEOF-65))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-65)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(ObjectiveCParserUNUSED-97))|(1<<(ObjectiveCParserWEAK_QUALIFIER-97))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-97))|(1<<(ObjectiveCParserNULLABLE-97))|(1<<(ObjectiveCParserNONNULL-97))|(1<<(ObjectiveCParserNULL_RESETTABLE-97))|(1<<(ObjectiveCParserNS_INLINE-97))|(1<<(ObjectiveCParserNS_ENUM-97))|(1<<(ObjectiveCParserNS_OPTIONS-97))|(1<<(ObjectiveCParserASSIGN-97))|(1<<(ObjectiveCParserCOPY-97))|(1<<(ObjectiveCParserGETTER-97))|(1<<(ObjectiveCParserSETTER-97))|(1<<(ObjectiveCParserSTRONG-97))|(1<<(ObjectiveCParserREADONLY-97))|(1<<(ObjectiveCParserREADWRITE-97))|(1<<(ObjectiveCParserWEAK-97))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-97))|(1<<(ObjectiveCParserIB_OUTLET-97))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-97))|(1<<(ObjectiveCParserIB_INSPECTABLE-97))|(1<<(ObjectiveCParserIB_DESIGNABLE-97))|(1<<(ObjectiveCParserIDENTIFIER-97)))) != 0) {
		{
			p.SetState(288)
			p.TopLevelDeclaration()
		}

		p.SetState(293)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(294)
		p.Match(ObjectiveCParserEOF)
	}

	return localctx
}

// ITopLevelDeclarationContext is an interface to support dynamic dispatch.
type ITopLevelDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopLevelDeclarationContext differentiates from other interfaces.
	IsTopLevelDeclarationContext()
}

type TopLevelDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopLevelDeclarationContext() *TopLevelDeclarationContext {
	var p = new(TopLevelDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_topLevelDeclaration
	return p
}

func (*TopLevelDeclarationContext) IsTopLevelDeclarationContext() {}

func NewTopLevelDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopLevelDeclarationContext {
	var p = new(TopLevelDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_topLevelDeclaration

	return p
}

func (s *TopLevelDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TopLevelDeclarationContext) ImportDeclaration() IImportDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *TopLevelDeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *TopLevelDeclarationContext) Declaration() IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *TopLevelDeclarationContext) ClassInterface() IClassInterfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassInterfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassInterfaceContext)
}

func (s *TopLevelDeclarationContext) ClassImplementation() IClassImplementationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassImplementationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassImplementationContext)
}

func (s *TopLevelDeclarationContext) CategoryInterface() ICategoryInterfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICategoryInterfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICategoryInterfaceContext)
}

func (s *TopLevelDeclarationContext) CategoryImplementation() ICategoryImplementationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICategoryImplementationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICategoryImplementationContext)
}

func (s *TopLevelDeclarationContext) ProtocolDeclaration() IProtocolDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolDeclarationContext)
}

func (s *TopLevelDeclarationContext) ProtocolDeclarationList() IProtocolDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolDeclarationListContext)
}

func (s *TopLevelDeclarationContext) ClassDeclarationList() IClassDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationListContext)
}

func (s *TopLevelDeclarationContext) FunctionDefinition() IFunctionDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *TopLevelDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopLevelDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopLevelDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterTopLevelDeclaration(s)
	}
}

func (s *TopLevelDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitTopLevelDeclaration(s)
	}
}

func (p *ObjectiveCParser) TopLevelDeclaration() (localctx ITopLevelDeclarationContext) {
	this := p
	_ = this

	localctx = NewTopLevelDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ObjectiveCParserRULE_topLevelDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(307)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(296)
			p.ImportDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(297)
			p.FunctionDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(298)
			p.Declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(299)
			p.ClassInterface()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(300)
			p.ClassImplementation()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(301)
			p.CategoryInterface()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(302)
			p.CategoryImplementation()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(303)
			p.ProtocolDeclaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(304)
			p.ProtocolDeclarationList()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(305)
			p.ClassDeclarationList()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(306)
			p.FunctionDefinition()
		}

	}

	return localctx
}

// IImportDeclarationContext is an interface to support dynamic dispatch.
type IImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportDeclarationContext differentiates from other interfaces.
	IsImportDeclarationContext()
}

type ImportDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclarationContext() *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_importDeclaration
	return p
}

func (*ImportDeclarationContext) IsImportDeclarationContext() {}

func NewImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_importDeclaration

	return p
}

func (s *ImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIMPORT, 0)
}

func (s *ImportDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, 0)
}

func (s *ImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterImportDeclaration(s)
	}
}

func (s *ImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitImportDeclaration(s)
	}
}

func (p *ObjectiveCParser) ImportDeclaration() (localctx IImportDeclarationContext) {
	this := p
	_ = this

	localctx = NewImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ObjectiveCParserRULE_importDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(309)
		p.Match(ObjectiveCParserIMPORT)
	}
	{
		p.SetState(310)
		p.Identifier()
	}
	{
		p.SetState(311)
		p.Match(ObjectiveCParserSEMI)
	}

	return localctx
}

// IClassInterfaceContext is an interface to support dynamic dispatch.
type IClassInterfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetClassName returns the className rule contexts.
	GetClassName() IGenericTypeSpecifierContext

	// GetSuperclassName returns the superclassName rule contexts.
	GetSuperclassName() IIdentifierContext

	// SetClassName sets the className rule contexts.
	SetClassName(IGenericTypeSpecifierContext)

	// SetSuperclassName sets the superclassName rule contexts.
	SetSuperclassName(IIdentifierContext)

	// IsClassInterfaceContext differentiates from other interfaces.
	IsClassInterfaceContext()
}

type ClassInterfaceContext struct {
	*antlr.BaseParserRuleContext
	parser         antlr.Parser
	className      IGenericTypeSpecifierContext
	superclassName IIdentifierContext
}

func NewEmptyClassInterfaceContext() *ClassInterfaceContext {
	var p = new(ClassInterfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_classInterface
	return p
}

func (*ClassInterfaceContext) IsClassInterfaceContext() {}

func NewClassInterfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassInterfaceContext {
	var p = new(ClassInterfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_classInterface

	return p
}

func (s *ClassInterfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassInterfaceContext) GetClassName() IGenericTypeSpecifierContext { return s.className }

func (s *ClassInterfaceContext) GetSuperclassName() IIdentifierContext { return s.superclassName }

func (s *ClassInterfaceContext) SetClassName(v IGenericTypeSpecifierContext) { s.className = v }

func (s *ClassInterfaceContext) SetSuperclassName(v IIdentifierContext) { s.superclassName = v }

func (s *ClassInterfaceContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserINTERFACE, 0)
}

func (s *ClassInterfaceContext) END() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserEND, 0)
}

func (s *ClassInterfaceContext) GenericTypeSpecifier() IGenericTypeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenericTypeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenericTypeSpecifierContext)
}

func (s *ClassInterfaceContext) IB_DESIGNABLE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIB_DESIGNABLE, 0)
}

func (s *ClassInterfaceContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOLON, 0)
}

func (s *ClassInterfaceContext) LT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLT, 0)
}

func (s *ClassInterfaceContext) ProtocolList() IProtocolListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolListContext)
}

func (s *ClassInterfaceContext) GT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserGT, 0)
}

func (s *ClassInterfaceContext) InstanceVariables() IInstanceVariablesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstanceVariablesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstanceVariablesContext)
}

func (s *ClassInterfaceContext) InterfaceDeclarationList() IInterfaceDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationListContext)
}

func (s *ClassInterfaceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassInterfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassInterfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassInterfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterClassInterface(s)
	}
}

func (s *ClassInterfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitClassInterface(s)
	}
}

func (p *ObjectiveCParser) ClassInterface() (localctx IClassInterfaceContext) {
	this := p
	_ = this

	localctx = NewClassInterfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ObjectiveCParserRULE_classInterface)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(314)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserIB_DESIGNABLE {
		{
			p.SetState(313)
			p.Match(ObjectiveCParserIB_DESIGNABLE)
		}

	}
	{
		p.SetState(316)
		p.Match(ObjectiveCParserINTERFACE)
	}
	{
		p.SetState(317)

		var _x = p.GenericTypeSpecifier()

		localctx.(*ClassInterfaceContext).className = _x
	}
	p.SetState(320)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserCOLON {
		{
			p.SetState(318)
			p.Match(ObjectiveCParserCOLON)
		}
		{
			p.SetState(319)

			var _x = p.Identifier()

			localctx.(*ClassInterfaceContext).superclassName = _x
		}

	}
	p.SetState(326)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserLT {
		{
			p.SetState(322)
			p.Match(ObjectiveCParserLT)
		}
		{
			p.SetState(323)
			p.ProtocolList()
		}
		{
			p.SetState(324)
			p.Match(ObjectiveCParserGT)
		}

	}
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserLBRACE {
		{
			p.SetState(328)
			p.InstanceVariables()
		}

	}
	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserAUTO)|(1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserEXTERN)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserREGISTER)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSTATIC)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserTYPEDEF)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32)))) != 0) || (((_la-72)&-(0x1f+1)) == 0 && ((1<<uint((_la-72)))&((1<<(ObjectiveCParserPROPERTY-72))|(1<<(ObjectiveCParserATOMIC-72))|(1<<(ObjectiveCParserNONATOMIC-72))|(1<<(ObjectiveCParserRETAIN-72))|(1<<(ObjectiveCParserATTRIBUTE-72))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-72))|(1<<(ObjectiveCParserBLOCK-72))|(1<<(ObjectiveCParserBRIDGE-72))|(1<<(ObjectiveCParserBRIDGE_RETAINED-72))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-72))|(1<<(ObjectiveCParserCOVARIANT-72))|(1<<(ObjectiveCParserCONTRAVARIANT-72))|(1<<(ObjectiveCParserDEPRECATED-72))|(1<<(ObjectiveCParserKINDOF-72))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-72))|(1<<(ObjectiveCParserTYPEOF-72))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-72))|(1<<(ObjectiveCParserUNUSED-72))|(1<<(ObjectiveCParserWEAK_QUALIFIER-72))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-72))|(1<<(ObjectiveCParserNULLABLE-72))|(1<<(ObjectiveCParserNONNULL-72))|(1<<(ObjectiveCParserNULL_RESETTABLE-72))|(1<<(ObjectiveCParserNS_INLINE-72)))) != 0) || (((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(ObjectiveCParserNS_ENUM-104))|(1<<(ObjectiveCParserNS_OPTIONS-104))|(1<<(ObjectiveCParserASSIGN-104))|(1<<(ObjectiveCParserCOPY-104))|(1<<(ObjectiveCParserGETTER-104))|(1<<(ObjectiveCParserSETTER-104))|(1<<(ObjectiveCParserSTRONG-104))|(1<<(ObjectiveCParserREADONLY-104))|(1<<(ObjectiveCParserREADWRITE-104))|(1<<(ObjectiveCParserWEAK-104))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-104))|(1<<(ObjectiveCParserIB_OUTLET-104))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-104))|(1<<(ObjectiveCParserIB_INSPECTABLE-104))|(1<<(ObjectiveCParserIB_DESIGNABLE-104))|(1<<(ObjectiveCParserIDENTIFIER-104)))) != 0) || _la == ObjectiveCParserADD || _la == ObjectiveCParserSUB {
		{
			p.SetState(331)
			p.InterfaceDeclarationList()
		}

	}
	{
		p.SetState(334)
		p.Match(ObjectiveCParserEND)
	}

	return localctx
}

// ICategoryInterfaceContext is an interface to support dynamic dispatch.
type ICategoryInterfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCategoryName returns the categoryName rule contexts.
	GetCategoryName() IGenericTypeSpecifierContext

	// GetClassName returns the className rule contexts.
	GetClassName() IIdentifierContext

	// SetCategoryName sets the categoryName rule contexts.
	SetCategoryName(IGenericTypeSpecifierContext)

	// SetClassName sets the className rule contexts.
	SetClassName(IIdentifierContext)

	// IsCategoryInterfaceContext differentiates from other interfaces.
	IsCategoryInterfaceContext()
}

type CategoryInterfaceContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	categoryName IGenericTypeSpecifierContext
	className    IIdentifierContext
}

func NewEmptyCategoryInterfaceContext() *CategoryInterfaceContext {
	var p = new(CategoryInterfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_categoryInterface
	return p
}

func (*CategoryInterfaceContext) IsCategoryInterfaceContext() {}

func NewCategoryInterfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CategoryInterfaceContext {
	var p = new(CategoryInterfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_categoryInterface

	return p
}

func (s *CategoryInterfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *CategoryInterfaceContext) GetCategoryName() IGenericTypeSpecifierContext {
	return s.categoryName
}

func (s *CategoryInterfaceContext) GetClassName() IIdentifierContext { return s.className }

func (s *CategoryInterfaceContext) SetCategoryName(v IGenericTypeSpecifierContext) {
	s.categoryName = v
}

func (s *CategoryInterfaceContext) SetClassName(v IIdentifierContext) { s.className = v }

func (s *CategoryInterfaceContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserINTERFACE, 0)
}

func (s *CategoryInterfaceContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *CategoryInterfaceContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *CategoryInterfaceContext) END() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserEND, 0)
}

func (s *CategoryInterfaceContext) GenericTypeSpecifier() IGenericTypeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenericTypeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenericTypeSpecifierContext)
}

func (s *CategoryInterfaceContext) LT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLT, 0)
}

func (s *CategoryInterfaceContext) ProtocolList() IProtocolListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolListContext)
}

func (s *CategoryInterfaceContext) GT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserGT, 0)
}

func (s *CategoryInterfaceContext) InstanceVariables() IInstanceVariablesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstanceVariablesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstanceVariablesContext)
}

func (s *CategoryInterfaceContext) InterfaceDeclarationList() IInterfaceDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationListContext)
}

func (s *CategoryInterfaceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CategoryInterfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CategoryInterfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CategoryInterfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterCategoryInterface(s)
	}
}

func (s *CategoryInterfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitCategoryInterface(s)
	}
}

func (p *ObjectiveCParser) CategoryInterface() (localctx ICategoryInterfaceContext) {
	this := p
	_ = this

	localctx = NewCategoryInterfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ObjectiveCParserRULE_categoryInterface)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(336)
		p.Match(ObjectiveCParserINTERFACE)
	}
	{
		p.SetState(337)

		var _x = p.GenericTypeSpecifier()

		localctx.(*CategoryInterfaceContext).categoryName = _x
	}
	{
		p.SetState(338)
		p.Match(ObjectiveCParserLP)
	}
	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
		{
			p.SetState(339)

			var _x = p.Identifier()

			localctx.(*CategoryInterfaceContext).className = _x
		}

	}
	{
		p.SetState(342)
		p.Match(ObjectiveCParserRP)
	}
	p.SetState(347)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserLT {
		{
			p.SetState(343)
			p.Match(ObjectiveCParserLT)
		}
		{
			p.SetState(344)
			p.ProtocolList()
		}
		{
			p.SetState(345)
			p.Match(ObjectiveCParserGT)
		}

	}
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserLBRACE {
		{
			p.SetState(349)
			p.InstanceVariables()
		}

	}
	p.SetState(353)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserAUTO)|(1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserEXTERN)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserREGISTER)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSTATIC)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserTYPEDEF)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32)))) != 0) || (((_la-72)&-(0x1f+1)) == 0 && ((1<<uint((_la-72)))&((1<<(ObjectiveCParserPROPERTY-72))|(1<<(ObjectiveCParserATOMIC-72))|(1<<(ObjectiveCParserNONATOMIC-72))|(1<<(ObjectiveCParserRETAIN-72))|(1<<(ObjectiveCParserATTRIBUTE-72))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-72))|(1<<(ObjectiveCParserBLOCK-72))|(1<<(ObjectiveCParserBRIDGE-72))|(1<<(ObjectiveCParserBRIDGE_RETAINED-72))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-72))|(1<<(ObjectiveCParserCOVARIANT-72))|(1<<(ObjectiveCParserCONTRAVARIANT-72))|(1<<(ObjectiveCParserDEPRECATED-72))|(1<<(ObjectiveCParserKINDOF-72))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-72))|(1<<(ObjectiveCParserTYPEOF-72))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-72))|(1<<(ObjectiveCParserUNUSED-72))|(1<<(ObjectiveCParserWEAK_QUALIFIER-72))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-72))|(1<<(ObjectiveCParserNULLABLE-72))|(1<<(ObjectiveCParserNONNULL-72))|(1<<(ObjectiveCParserNULL_RESETTABLE-72))|(1<<(ObjectiveCParserNS_INLINE-72)))) != 0) || (((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(ObjectiveCParserNS_ENUM-104))|(1<<(ObjectiveCParserNS_OPTIONS-104))|(1<<(ObjectiveCParserASSIGN-104))|(1<<(ObjectiveCParserCOPY-104))|(1<<(ObjectiveCParserGETTER-104))|(1<<(ObjectiveCParserSETTER-104))|(1<<(ObjectiveCParserSTRONG-104))|(1<<(ObjectiveCParserREADONLY-104))|(1<<(ObjectiveCParserREADWRITE-104))|(1<<(ObjectiveCParserWEAK-104))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-104))|(1<<(ObjectiveCParserIB_OUTLET-104))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-104))|(1<<(ObjectiveCParserIB_INSPECTABLE-104))|(1<<(ObjectiveCParserIB_DESIGNABLE-104))|(1<<(ObjectiveCParserIDENTIFIER-104)))) != 0) || _la == ObjectiveCParserADD || _la == ObjectiveCParserSUB {
		{
			p.SetState(352)
			p.InterfaceDeclarationList()
		}

	}
	{
		p.SetState(355)
		p.Match(ObjectiveCParserEND)
	}

	return localctx
}

// IClassImplementationContext is an interface to support dynamic dispatch.
type IClassImplementationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetClassName returns the className rule contexts.
	GetClassName() IGenericTypeSpecifierContext

	// GetSuperclassName returns the superclassName rule contexts.
	GetSuperclassName() IIdentifierContext

	// SetClassName sets the className rule contexts.
	SetClassName(IGenericTypeSpecifierContext)

	// SetSuperclassName sets the superclassName rule contexts.
	SetSuperclassName(IIdentifierContext)

	// IsClassImplementationContext differentiates from other interfaces.
	IsClassImplementationContext()
}

type ClassImplementationContext struct {
	*antlr.BaseParserRuleContext
	parser         antlr.Parser
	className      IGenericTypeSpecifierContext
	superclassName IIdentifierContext
}

func NewEmptyClassImplementationContext() *ClassImplementationContext {
	var p = new(ClassImplementationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_classImplementation
	return p
}

func (*ClassImplementationContext) IsClassImplementationContext() {}

func NewClassImplementationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassImplementationContext {
	var p = new(ClassImplementationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_classImplementation

	return p
}

func (s *ClassImplementationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassImplementationContext) GetClassName() IGenericTypeSpecifierContext { return s.className }

func (s *ClassImplementationContext) GetSuperclassName() IIdentifierContext { return s.superclassName }

func (s *ClassImplementationContext) SetClassName(v IGenericTypeSpecifierContext) { s.className = v }

func (s *ClassImplementationContext) SetSuperclassName(v IIdentifierContext) { s.superclassName = v }

func (s *ClassImplementationContext) IMPLEMENTATION() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIMPLEMENTATION, 0)
}

func (s *ClassImplementationContext) END() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserEND, 0)
}

func (s *ClassImplementationContext) GenericTypeSpecifier() IGenericTypeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenericTypeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenericTypeSpecifierContext)
}

func (s *ClassImplementationContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOLON, 0)
}

func (s *ClassImplementationContext) InstanceVariables() IInstanceVariablesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstanceVariablesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstanceVariablesContext)
}

func (s *ClassImplementationContext) ImplementationDefinitionList() IImplementationDefinitionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementationDefinitionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplementationDefinitionListContext)
}

func (s *ClassImplementationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassImplementationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassImplementationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassImplementationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterClassImplementation(s)
	}
}

func (s *ClassImplementationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitClassImplementation(s)
	}
}

func (p *ObjectiveCParser) ClassImplementation() (localctx IClassImplementationContext) {
	this := p
	_ = this

	localctx = NewClassImplementationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ObjectiveCParserRULE_classImplementation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(357)
		p.Match(ObjectiveCParserIMPLEMENTATION)
	}
	{
		p.SetState(358)

		var _x = p.GenericTypeSpecifier()

		localctx.(*ClassImplementationContext).className = _x
	}
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserCOLON {
		{
			p.SetState(359)
			p.Match(ObjectiveCParserCOLON)
		}
		{
			p.SetState(360)

			var _x = p.Identifier()

			localctx.(*ClassImplementationContext).superclassName = _x
		}

	}
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserLBRACE {
		{
			p.SetState(363)
			p.InstanceVariables()
		}

	}
	p.SetState(367)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserAUTO)|(1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserEXTERN)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserREGISTER)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSTATIC)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserTYPEDEF)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32))|(1<<(ObjectiveCParserDYNAMIC-32)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(ObjectiveCParserSYNTHESIZE-78))|(1<<(ObjectiveCParserATOMIC-78))|(1<<(ObjectiveCParserNONATOMIC-78))|(1<<(ObjectiveCParserRETAIN-78))|(1<<(ObjectiveCParserATTRIBUTE-78))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-78))|(1<<(ObjectiveCParserBLOCK-78))|(1<<(ObjectiveCParserBRIDGE-78))|(1<<(ObjectiveCParserBRIDGE_RETAINED-78))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-78))|(1<<(ObjectiveCParserCOVARIANT-78))|(1<<(ObjectiveCParserCONTRAVARIANT-78))|(1<<(ObjectiveCParserDEPRECATED-78))|(1<<(ObjectiveCParserKINDOF-78))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-78))|(1<<(ObjectiveCParserTYPEOF-78))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-78))|(1<<(ObjectiveCParserUNUSED-78))|(1<<(ObjectiveCParserWEAK_QUALIFIER-78))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-78))|(1<<(ObjectiveCParserNULLABLE-78))|(1<<(ObjectiveCParserNONNULL-78))|(1<<(ObjectiveCParserNULL_RESETTABLE-78))|(1<<(ObjectiveCParserNS_INLINE-78))|(1<<(ObjectiveCParserNS_ENUM-78))|(1<<(ObjectiveCParserNS_OPTIONS-78))|(1<<(ObjectiveCParserASSIGN-78))|(1<<(ObjectiveCParserCOPY-78))|(1<<(ObjectiveCParserGETTER-78))|(1<<(ObjectiveCParserSETTER-78)))) != 0) || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(ObjectiveCParserSTRONG-110))|(1<<(ObjectiveCParserREADONLY-110))|(1<<(ObjectiveCParserREADWRITE-110))|(1<<(ObjectiveCParserWEAK-110))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-110))|(1<<(ObjectiveCParserIB_OUTLET-110))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-110))|(1<<(ObjectiveCParserIB_INSPECTABLE-110))|(1<<(ObjectiveCParserIB_DESIGNABLE-110))|(1<<(ObjectiveCParserIDENTIFIER-110)))) != 0) || _la == ObjectiveCParserADD || _la == ObjectiveCParserSUB {
		{
			p.SetState(366)
			p.ImplementationDefinitionList()
		}

	}
	{
		p.SetState(369)
		p.Match(ObjectiveCParserEND)
	}

	return localctx
}

// ICategoryImplementationContext is an interface to support dynamic dispatch.
type ICategoryImplementationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCategoryName returns the categoryName rule contexts.
	GetCategoryName() IGenericTypeSpecifierContext

	// GetClassName returns the className rule contexts.
	GetClassName() IIdentifierContext

	// SetCategoryName sets the categoryName rule contexts.
	SetCategoryName(IGenericTypeSpecifierContext)

	// SetClassName sets the className rule contexts.
	SetClassName(IIdentifierContext)

	// IsCategoryImplementationContext differentiates from other interfaces.
	IsCategoryImplementationContext()
}

type CategoryImplementationContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	categoryName IGenericTypeSpecifierContext
	className    IIdentifierContext
}

func NewEmptyCategoryImplementationContext() *CategoryImplementationContext {
	var p = new(CategoryImplementationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_categoryImplementation
	return p
}

func (*CategoryImplementationContext) IsCategoryImplementationContext() {}

func NewCategoryImplementationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CategoryImplementationContext {
	var p = new(CategoryImplementationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_categoryImplementation

	return p
}

func (s *CategoryImplementationContext) GetParser() antlr.Parser { return s.parser }

func (s *CategoryImplementationContext) GetCategoryName() IGenericTypeSpecifierContext {
	return s.categoryName
}

func (s *CategoryImplementationContext) GetClassName() IIdentifierContext { return s.className }

func (s *CategoryImplementationContext) SetCategoryName(v IGenericTypeSpecifierContext) {
	s.categoryName = v
}

func (s *CategoryImplementationContext) SetClassName(v IIdentifierContext) { s.className = v }

func (s *CategoryImplementationContext) IMPLEMENTATION() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIMPLEMENTATION, 0)
}

func (s *CategoryImplementationContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *CategoryImplementationContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *CategoryImplementationContext) END() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserEND, 0)
}

func (s *CategoryImplementationContext) GenericTypeSpecifier() IGenericTypeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenericTypeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenericTypeSpecifierContext)
}

func (s *CategoryImplementationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CategoryImplementationContext) ImplementationDefinitionList() IImplementationDefinitionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementationDefinitionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplementationDefinitionListContext)
}

func (s *CategoryImplementationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CategoryImplementationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CategoryImplementationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterCategoryImplementation(s)
	}
}

func (s *CategoryImplementationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitCategoryImplementation(s)
	}
}

func (p *ObjectiveCParser) CategoryImplementation() (localctx ICategoryImplementationContext) {
	this := p
	_ = this

	localctx = NewCategoryImplementationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ObjectiveCParserRULE_categoryImplementation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(371)
		p.Match(ObjectiveCParserIMPLEMENTATION)
	}
	{
		p.SetState(372)

		var _x = p.GenericTypeSpecifier()

		localctx.(*CategoryImplementationContext).categoryName = _x
	}
	{
		p.SetState(373)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(374)

		var _x = p.Identifier()

		localctx.(*CategoryImplementationContext).className = _x
	}
	{
		p.SetState(375)
		p.Match(ObjectiveCParserRP)
	}
	p.SetState(377)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserAUTO)|(1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserEXTERN)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserREGISTER)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSTATIC)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserTYPEDEF)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32))|(1<<(ObjectiveCParserDYNAMIC-32)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(ObjectiveCParserSYNTHESIZE-78))|(1<<(ObjectiveCParserATOMIC-78))|(1<<(ObjectiveCParserNONATOMIC-78))|(1<<(ObjectiveCParserRETAIN-78))|(1<<(ObjectiveCParserATTRIBUTE-78))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-78))|(1<<(ObjectiveCParserBLOCK-78))|(1<<(ObjectiveCParserBRIDGE-78))|(1<<(ObjectiveCParserBRIDGE_RETAINED-78))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-78))|(1<<(ObjectiveCParserCOVARIANT-78))|(1<<(ObjectiveCParserCONTRAVARIANT-78))|(1<<(ObjectiveCParserDEPRECATED-78))|(1<<(ObjectiveCParserKINDOF-78))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-78))|(1<<(ObjectiveCParserTYPEOF-78))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-78))|(1<<(ObjectiveCParserUNUSED-78))|(1<<(ObjectiveCParserWEAK_QUALIFIER-78))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-78))|(1<<(ObjectiveCParserNULLABLE-78))|(1<<(ObjectiveCParserNONNULL-78))|(1<<(ObjectiveCParserNULL_RESETTABLE-78))|(1<<(ObjectiveCParserNS_INLINE-78))|(1<<(ObjectiveCParserNS_ENUM-78))|(1<<(ObjectiveCParserNS_OPTIONS-78))|(1<<(ObjectiveCParserASSIGN-78))|(1<<(ObjectiveCParserCOPY-78))|(1<<(ObjectiveCParserGETTER-78))|(1<<(ObjectiveCParserSETTER-78)))) != 0) || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(ObjectiveCParserSTRONG-110))|(1<<(ObjectiveCParserREADONLY-110))|(1<<(ObjectiveCParserREADWRITE-110))|(1<<(ObjectiveCParserWEAK-110))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-110))|(1<<(ObjectiveCParserIB_OUTLET-110))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-110))|(1<<(ObjectiveCParserIB_INSPECTABLE-110))|(1<<(ObjectiveCParserIB_DESIGNABLE-110))|(1<<(ObjectiveCParserIDENTIFIER-110)))) != 0) || _la == ObjectiveCParserADD || _la == ObjectiveCParserSUB {
		{
			p.SetState(376)
			p.ImplementationDefinitionList()
		}

	}
	{
		p.SetState(379)
		p.Match(ObjectiveCParserEND)
	}

	return localctx
}

// IGenericTypeSpecifierContext is an interface to support dynamic dispatch.
type IGenericTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenericTypeSpecifierContext differentiates from other interfaces.
	IsGenericTypeSpecifierContext()
}

type GenericTypeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericTypeSpecifierContext() *GenericTypeSpecifierContext {
	var p = new(GenericTypeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_genericTypeSpecifier
	return p
}

func (*GenericTypeSpecifierContext) IsGenericTypeSpecifierContext() {}

func NewGenericTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericTypeSpecifierContext {
	var p = new(GenericTypeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_genericTypeSpecifier

	return p
}

func (s *GenericTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericTypeSpecifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GenericTypeSpecifierContext) GenericsSpecifier() IGenericsSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenericsSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenericsSpecifierContext)
}

func (s *GenericTypeSpecifierContext) LT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLT, 0)
}

func (s *GenericTypeSpecifierContext) ProtocolList() IProtocolListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolListContext)
}

func (s *GenericTypeSpecifierContext) GT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserGT, 0)
}

func (s *GenericTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericTypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterGenericTypeSpecifier(s)
	}
}

func (s *GenericTypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitGenericTypeSpecifier(s)
	}
}

func (p *ObjectiveCParser) GenericTypeSpecifier() (localctx IGenericTypeSpecifierContext) {
	this := p
	_ = this

	localctx = NewGenericTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ObjectiveCParserRULE_genericTypeSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(381)
		p.Identifier()
	}
	p.SetState(387)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(382)
			p.Match(ObjectiveCParserLT)
		}
		{
			p.SetState(383)
			p.ProtocolList()
		}
		{
			p.SetState(384)
			p.Match(ObjectiveCParserGT)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(386)
			p.GenericsSpecifier()
		}

	}

	return localctx
}

// IProtocolDeclarationContext is an interface to support dynamic dispatch.
type IProtocolDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocolDeclarationContext differentiates from other interfaces.
	IsProtocolDeclarationContext()
}

type ProtocolDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocolDeclarationContext() *ProtocolDeclarationContext {
	var p = new(ProtocolDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_protocolDeclaration
	return p
}

func (*ProtocolDeclarationContext) IsProtocolDeclarationContext() {}

func NewProtocolDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProtocolDeclarationContext {
	var p = new(ProtocolDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_protocolDeclaration

	return p
}

func (s *ProtocolDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProtocolDeclarationContext) PROTOCOL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserPROTOCOL, 0)
}

func (s *ProtocolDeclarationContext) ProtocolName() IProtocolNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolNameContext)
}

func (s *ProtocolDeclarationContext) END() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserEND, 0)
}

func (s *ProtocolDeclarationContext) LT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLT, 0)
}

func (s *ProtocolDeclarationContext) ProtocolList() IProtocolListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolListContext)
}

func (s *ProtocolDeclarationContext) GT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserGT, 0)
}

func (s *ProtocolDeclarationContext) AllProtocolDeclarationSection() []IProtocolDeclarationSectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProtocolDeclarationSectionContext)(nil)).Elem())
	var tst = make([]IProtocolDeclarationSectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProtocolDeclarationSectionContext)
		}
	}

	return tst
}

func (s *ProtocolDeclarationContext) ProtocolDeclarationSection(i int) IProtocolDeclarationSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolDeclarationSectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProtocolDeclarationSectionContext)
}

func (s *ProtocolDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProtocolDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProtocolDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterProtocolDeclaration(s)
	}
}

func (s *ProtocolDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitProtocolDeclaration(s)
	}
}

func (p *ObjectiveCParser) ProtocolDeclaration() (localctx IProtocolDeclarationContext) {
	this := p
	_ = this

	localctx = NewProtocolDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ObjectiveCParserRULE_protocolDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.Match(ObjectiveCParserPROTOCOL)
	}
	{
		p.SetState(390)
		p.ProtocolName()
	}
	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserLT {
		{
			p.SetState(391)
			p.Match(ObjectiveCParserLT)
		}
		{
			p.SetState(392)
			p.ProtocolList()
		}
		{
			p.SetState(393)
			p.Match(ObjectiveCParserGT)
		}

	}
	p.SetState(400)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserAUTO)|(1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserEXTERN)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserREGISTER)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSTATIC)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserTYPEDEF)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(ObjectiveCParserOPTIONAL-70))|(1<<(ObjectiveCParserPROPERTY-70))|(1<<(ObjectiveCParserREQUIRED-70))|(1<<(ObjectiveCParserATOMIC-70))|(1<<(ObjectiveCParserNONATOMIC-70))|(1<<(ObjectiveCParserRETAIN-70))|(1<<(ObjectiveCParserATTRIBUTE-70))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-70))|(1<<(ObjectiveCParserBLOCK-70))|(1<<(ObjectiveCParserBRIDGE-70))|(1<<(ObjectiveCParserBRIDGE_RETAINED-70))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-70))|(1<<(ObjectiveCParserCOVARIANT-70))|(1<<(ObjectiveCParserCONTRAVARIANT-70))|(1<<(ObjectiveCParserDEPRECATED-70))|(1<<(ObjectiveCParserKINDOF-70))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-70))|(1<<(ObjectiveCParserTYPEOF-70))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-70))|(1<<(ObjectiveCParserUNUSED-70))|(1<<(ObjectiveCParserWEAK_QUALIFIER-70))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-70))|(1<<(ObjectiveCParserNULLABLE-70))|(1<<(ObjectiveCParserNONNULL-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(ObjectiveCParserNULL_RESETTABLE-102))|(1<<(ObjectiveCParserNS_INLINE-102))|(1<<(ObjectiveCParserNS_ENUM-102))|(1<<(ObjectiveCParserNS_OPTIONS-102))|(1<<(ObjectiveCParserASSIGN-102))|(1<<(ObjectiveCParserCOPY-102))|(1<<(ObjectiveCParserGETTER-102))|(1<<(ObjectiveCParserSETTER-102))|(1<<(ObjectiveCParserSTRONG-102))|(1<<(ObjectiveCParserREADONLY-102))|(1<<(ObjectiveCParserREADWRITE-102))|(1<<(ObjectiveCParserWEAK-102))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-102))|(1<<(ObjectiveCParserIB_OUTLET-102))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-102))|(1<<(ObjectiveCParserIB_INSPECTABLE-102))|(1<<(ObjectiveCParserIB_DESIGNABLE-102))|(1<<(ObjectiveCParserIDENTIFIER-102)))) != 0) || _la == ObjectiveCParserADD || _la == ObjectiveCParserSUB {
		{
			p.SetState(397)
			p.ProtocolDeclarationSection()
		}

		p.SetState(402)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(403)
		p.Match(ObjectiveCParserEND)
	}

	return localctx
}

// IProtocolDeclarationSectionContext is an interface to support dynamic dispatch.
type IProtocolDeclarationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetModifier returns the modifier token.
	GetModifier() antlr.Token

	// SetModifier sets the modifier token.
	SetModifier(antlr.Token)

	// IsProtocolDeclarationSectionContext differentiates from other interfaces.
	IsProtocolDeclarationSectionContext()
}

type ProtocolDeclarationSectionContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	modifier antlr.Token
}

func NewEmptyProtocolDeclarationSectionContext() *ProtocolDeclarationSectionContext {
	var p = new(ProtocolDeclarationSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_protocolDeclarationSection
	return p
}

func (*ProtocolDeclarationSectionContext) IsProtocolDeclarationSectionContext() {}

func NewProtocolDeclarationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProtocolDeclarationSectionContext {
	var p = new(ProtocolDeclarationSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_protocolDeclarationSection

	return p
}

func (s *ProtocolDeclarationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProtocolDeclarationSectionContext) GetModifier() antlr.Token { return s.modifier }

func (s *ProtocolDeclarationSectionContext) SetModifier(v antlr.Token) { s.modifier = v }

func (s *ProtocolDeclarationSectionContext) REQUIRED() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserREQUIRED, 0)
}

func (s *ProtocolDeclarationSectionContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserOPTIONAL, 0)
}

func (s *ProtocolDeclarationSectionContext) AllInterfaceDeclarationList() []IInterfaceDeclarationListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterfaceDeclarationListContext)(nil)).Elem())
	var tst = make([]IInterfaceDeclarationListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterfaceDeclarationListContext)
		}
	}

	return tst
}

func (s *ProtocolDeclarationSectionContext) InterfaceDeclarationList(i int) IInterfaceDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceDeclarationListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationListContext)
}

func (s *ProtocolDeclarationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProtocolDeclarationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProtocolDeclarationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterProtocolDeclarationSection(s)
	}
}

func (s *ProtocolDeclarationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitProtocolDeclarationSection(s)
	}
}

func (p *ObjectiveCParser) ProtocolDeclarationSection() (localctx IProtocolDeclarationSectionContext) {
	this := p
	_ = this

	localctx = NewProtocolDeclarationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ObjectiveCParserRULE_protocolDeclarationSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(417)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserOPTIONAL, ObjectiveCParserREQUIRED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(405)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ProtocolDeclarationSectionContext).modifier = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == ObjectiveCParserOPTIONAL || _la == ObjectiveCParserREQUIRED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ProtocolDeclarationSectionContext).modifier = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(409)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(406)
					p.InterfaceDeclarationList()
				}

			}
			p.SetState(411)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())
		}

	case ObjectiveCParserAUTO, ObjectiveCParserCHAR, ObjectiveCParserCONST, ObjectiveCParserDOUBLE, ObjectiveCParserENUM, ObjectiveCParserEXTERN, ObjectiveCParserFLOAT, ObjectiveCParserINLINE, ObjectiveCParserINT, ObjectiveCParserLONG, ObjectiveCParserREGISTER, ObjectiveCParserRESTRICT, ObjectiveCParserSHORT, ObjectiveCParserSIGNED, ObjectiveCParserSTATIC, ObjectiveCParserSTRUCT, ObjectiveCParserTYPEDEF, ObjectiveCParserUNION, ObjectiveCParserUNSIGNED, ObjectiveCParserVOID, ObjectiveCParserVOLATILE, ObjectiveCParserBOOL, ObjectiveCParserClass, ObjectiveCParserBYCOPY, ObjectiveCParserBYREF, ObjectiveCParserID, ObjectiveCParserIMP, ObjectiveCParserIN, ObjectiveCParserINOUT, ObjectiveCParserONEWAY, ObjectiveCParserOUT, ObjectiveCParserPROTOCOL_, ObjectiveCParserSEL, ObjectiveCParserSELF, ObjectiveCParserSUPER, ObjectiveCParserPROPERTY, ObjectiveCParserATOMIC, ObjectiveCParserNONATOMIC, ObjectiveCParserRETAIN, ObjectiveCParserATTRIBUTE, ObjectiveCParserAUTORELEASING_QUALIFIER, ObjectiveCParserBLOCK, ObjectiveCParserBRIDGE, ObjectiveCParserBRIDGE_RETAINED, ObjectiveCParserBRIDGE_TRANSFER, ObjectiveCParserCOVARIANT, ObjectiveCParserCONTRAVARIANT, ObjectiveCParserDEPRECATED, ObjectiveCParserKINDOF, ObjectiveCParserSTRONG_QUALIFIER, ObjectiveCParserTYPEOF, ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER, ObjectiveCParserUNUSED, ObjectiveCParserWEAK_QUALIFIER, ObjectiveCParserNULL_UNSPECIFIED, ObjectiveCParserNULLABLE, ObjectiveCParserNONNULL, ObjectiveCParserNULL_RESETTABLE, ObjectiveCParserNS_INLINE, ObjectiveCParserNS_ENUM, ObjectiveCParserNS_OPTIONS, ObjectiveCParserASSIGN, ObjectiveCParserCOPY, ObjectiveCParserGETTER, ObjectiveCParserSETTER, ObjectiveCParserSTRONG, ObjectiveCParserREADONLY, ObjectiveCParserREADWRITE, ObjectiveCParserWEAK, ObjectiveCParserUNSAFE_UNRETAINED, ObjectiveCParserIB_OUTLET, ObjectiveCParserIB_OUTLET_COLLECTION, ObjectiveCParserIB_INSPECTABLE, ObjectiveCParserIB_DESIGNABLE, ObjectiveCParserIDENTIFIER, ObjectiveCParserADD, ObjectiveCParserSUB:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(413)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(412)
					p.InterfaceDeclarationList()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(415)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProtocolDeclarationListContext is an interface to support dynamic dispatch.
type IProtocolDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocolDeclarationListContext differentiates from other interfaces.
	IsProtocolDeclarationListContext()
}

type ProtocolDeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocolDeclarationListContext() *ProtocolDeclarationListContext {
	var p = new(ProtocolDeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_protocolDeclarationList
	return p
}

func (*ProtocolDeclarationListContext) IsProtocolDeclarationListContext() {}

func NewProtocolDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProtocolDeclarationListContext {
	var p = new(ProtocolDeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_protocolDeclarationList

	return p
}

func (s *ProtocolDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *ProtocolDeclarationListContext) PROTOCOL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserPROTOCOL, 0)
}

func (s *ProtocolDeclarationListContext) ProtocolList() IProtocolListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolListContext)
}

func (s *ProtocolDeclarationListContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, 0)
}

func (s *ProtocolDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProtocolDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProtocolDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterProtocolDeclarationList(s)
	}
}

func (s *ProtocolDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitProtocolDeclarationList(s)
	}
}

func (p *ObjectiveCParser) ProtocolDeclarationList() (localctx IProtocolDeclarationListContext) {
	this := p
	_ = this

	localctx = NewProtocolDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ObjectiveCParserRULE_protocolDeclarationList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(419)
		p.Match(ObjectiveCParserPROTOCOL)
	}
	{
		p.SetState(420)
		p.ProtocolList()
	}
	{
		p.SetState(421)
		p.Match(ObjectiveCParserSEMI)
	}

	return localctx
}

// IClassDeclarationListContext is an interface to support dynamic dispatch.
type IClassDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationListContext differentiates from other interfaces.
	IsClassDeclarationListContext()
}

type ClassDeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationListContext() *ClassDeclarationListContext {
	var p = new(ClassDeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_classDeclarationList
	return p
}

func (*ClassDeclarationListContext) IsClassDeclarationListContext() {}

func NewClassDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationListContext {
	var p = new(ClassDeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_classDeclarationList

	return p
}

func (s *ClassDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationListContext) CLASS() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCLASS, 0)
}

func (s *ClassDeclarationListContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ClassDeclarationListContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassDeclarationListContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, 0)
}

func (s *ClassDeclarationListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *ClassDeclarationListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *ClassDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterClassDeclarationList(s)
	}
}

func (s *ClassDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitClassDeclarationList(s)
	}
}

func (p *ObjectiveCParser) ClassDeclarationList() (localctx IClassDeclarationListContext) {
	this := p
	_ = this

	localctx = NewClassDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ObjectiveCParserRULE_classDeclarationList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(423)
		p.Match(ObjectiveCParserCLASS)
	}
	{
		p.SetState(424)
		p.Identifier()
	}
	p.SetState(429)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ObjectiveCParserCOMMA {
		{
			p.SetState(425)
			p.Match(ObjectiveCParserCOMMA)
		}
		{
			p.SetState(426)
			p.Identifier()
		}

		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(432)
		p.Match(ObjectiveCParserSEMI)
	}

	return localctx
}

// IProtocolListContext is an interface to support dynamic dispatch.
type IProtocolListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocolListContext differentiates from other interfaces.
	IsProtocolListContext()
}

type ProtocolListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocolListContext() *ProtocolListContext {
	var p = new(ProtocolListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_protocolList
	return p
}

func (*ProtocolListContext) IsProtocolListContext() {}

func NewProtocolListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProtocolListContext {
	var p = new(ProtocolListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_protocolList

	return p
}

func (s *ProtocolListContext) GetParser() antlr.Parser { return s.parser }

func (s *ProtocolListContext) AllProtocolName() []IProtocolNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProtocolNameContext)(nil)).Elem())
	var tst = make([]IProtocolNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProtocolNameContext)
		}
	}

	return tst
}

func (s *ProtocolListContext) ProtocolName(i int) IProtocolNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProtocolNameContext)
}

func (s *ProtocolListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *ProtocolListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *ProtocolListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProtocolListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProtocolListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterProtocolList(s)
	}
}

func (s *ProtocolListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitProtocolList(s)
	}
}

func (p *ObjectiveCParser) ProtocolList() (localctx IProtocolListContext) {
	this := p
	_ = this

	localctx = NewProtocolListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ObjectiveCParserRULE_protocolList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(434)
		p.ProtocolName()
	}
	p.SetState(439)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ObjectiveCParserCOMMA {
		{
			p.SetState(435)
			p.Match(ObjectiveCParserCOMMA)
		}
		{
			p.SetState(436)
			p.ProtocolName()
		}

		p.SetState(441)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPropertyDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyDeclarationContext differentiates from other interfaces.
	IsPropertyDeclarationContext()
}

type PropertyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDeclarationContext() *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_propertyDeclaration
	return p
}

func (*PropertyDeclarationContext) IsPropertyDeclarationContext() {}

func NewPropertyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_propertyDeclaration

	return p
}

func (s *PropertyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDeclarationContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserPROPERTY, 0)
}

func (s *PropertyDeclarationContext) FieldDeclaration() IFieldDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *PropertyDeclarationContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *PropertyDeclarationContext) PropertyAttributesList() IPropertyAttributesListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyAttributesListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyAttributesListContext)
}

func (s *PropertyDeclarationContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *PropertyDeclarationContext) IbOutletQualifier() IIbOutletQualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIbOutletQualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIbOutletQualifierContext)
}

func (s *PropertyDeclarationContext) IB_INSPECTABLE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIB_INSPECTABLE, 0)
}

func (s *PropertyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitPropertyDeclaration(s)
	}
}

func (p *ObjectiveCParser) PropertyDeclaration() (localctx IPropertyDeclarationContext) {
	this := p
	_ = this

	localctx = NewPropertyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ObjectiveCParserRULE_propertyDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(442)
		p.Match(ObjectiveCParserPROPERTY)
	}
	p.SetState(447)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserLP {
		{
			p.SetState(443)
			p.Match(ObjectiveCParserLP)
		}
		{
			p.SetState(444)
			p.PropertyAttributesList()
		}
		{
			p.SetState(445)
			p.Match(ObjectiveCParserRP)
		}

	}
	p.SetState(450)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(449)
			p.IbOutletQualifier()
		}

	}
	p.SetState(453)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(452)
			p.Match(ObjectiveCParserIB_INSPECTABLE)
		}

	}
	{
		p.SetState(455)
		p.FieldDeclaration()
	}

	return localctx
}

// IPropertyAttributesListContext is an interface to support dynamic dispatch.
type IPropertyAttributesListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyAttributesListContext differentiates from other interfaces.
	IsPropertyAttributesListContext()
}

type PropertyAttributesListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyAttributesListContext() *PropertyAttributesListContext {
	var p = new(PropertyAttributesListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_propertyAttributesList
	return p
}

func (*PropertyAttributesListContext) IsPropertyAttributesListContext() {}

func NewPropertyAttributesListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyAttributesListContext {
	var p = new(PropertyAttributesListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_propertyAttributesList

	return p
}

func (s *PropertyAttributesListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyAttributesListContext) AllPropertyAttribute() []IPropertyAttributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyAttributeContext)(nil)).Elem())
	var tst = make([]IPropertyAttributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyAttributeContext)
		}
	}

	return tst
}

func (s *PropertyAttributesListContext) PropertyAttribute(i int) IPropertyAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyAttributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyAttributeContext)
}

func (s *PropertyAttributesListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *PropertyAttributesListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *PropertyAttributesListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyAttributesListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyAttributesListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterPropertyAttributesList(s)
	}
}

func (s *PropertyAttributesListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitPropertyAttributesList(s)
	}
}

func (p *ObjectiveCParser) PropertyAttributesList() (localctx IPropertyAttributesListContext) {
	this := p
	_ = this

	localctx = NewPropertyAttributesListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ObjectiveCParserRULE_propertyAttributesList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)
		p.PropertyAttribute()
	}
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ObjectiveCParserCOMMA {
		{
			p.SetState(458)
			p.Match(ObjectiveCParserCOMMA)
		}
		{
			p.SetState(459)
			p.PropertyAttribute()
		}

		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPropertyAttributeContext is an interface to support dynamic dispatch.
type IPropertyAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyAttributeContext differentiates from other interfaces.
	IsPropertyAttributeContext()
}

type PropertyAttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyAttributeContext() *PropertyAttributeContext {
	var p = new(PropertyAttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_propertyAttribute
	return p
}

func (*PropertyAttributeContext) IsPropertyAttributeContext() {}

func NewPropertyAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyAttributeContext {
	var p = new(PropertyAttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_propertyAttribute

	return p
}

func (s *PropertyAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyAttributeContext) ATOMIC() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserATOMIC, 0)
}

func (s *PropertyAttributeContext) NONATOMIC() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNONATOMIC, 0)
}

func (s *PropertyAttributeContext) STRONG() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSTRONG, 0)
}

func (s *PropertyAttributeContext) WEAK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserWEAK, 0)
}

func (s *PropertyAttributeContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRETAIN, 0)
}

func (s *PropertyAttributeContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserASSIGN, 0)
}

func (s *PropertyAttributeContext) UNSAFE_UNRETAINED() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserUNSAFE_UNRETAINED, 0)
}

func (s *PropertyAttributeContext) COPY() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOPY, 0)
}

func (s *PropertyAttributeContext) READONLY() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserREADONLY, 0)
}

func (s *PropertyAttributeContext) READWRITE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserREADWRITE, 0)
}

func (s *PropertyAttributeContext) GETTER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserGETTER, 0)
}

func (s *PropertyAttributeContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserASSIGNMENT, 0)
}

func (s *PropertyAttributeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyAttributeContext) SETTER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSETTER, 0)
}

func (s *PropertyAttributeContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOLON, 0)
}

func (s *PropertyAttributeContext) NullabilitySpecifier() INullabilitySpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullabilitySpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullabilitySpecifierContext)
}

func (s *PropertyAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterPropertyAttribute(s)
	}
}

func (s *PropertyAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitPropertyAttribute(s)
	}
}

func (p *ObjectiveCParser) PropertyAttribute() (localctx IPropertyAttributeContext) {
	this := p
	_ = this

	localctx = NewPropertyAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ObjectiveCParserRULE_propertyAttribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(465)
			p.Match(ObjectiveCParserATOMIC)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(466)
			p.Match(ObjectiveCParserNONATOMIC)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(467)
			p.Match(ObjectiveCParserSTRONG)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(468)
			p.Match(ObjectiveCParserWEAK)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(469)
			p.Match(ObjectiveCParserRETAIN)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(470)
			p.Match(ObjectiveCParserASSIGN)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(471)
			p.Match(ObjectiveCParserUNSAFE_UNRETAINED)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(472)
			p.Match(ObjectiveCParserCOPY)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(473)
			p.Match(ObjectiveCParserREADONLY)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(474)
			p.Match(ObjectiveCParserREADWRITE)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(475)
			p.Match(ObjectiveCParserGETTER)
		}
		{
			p.SetState(476)
			p.Match(ObjectiveCParserASSIGNMENT)
		}
		{
			p.SetState(477)
			p.Identifier()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(478)
			p.Match(ObjectiveCParserSETTER)
		}
		{
			p.SetState(479)
			p.Match(ObjectiveCParserASSIGNMENT)
		}
		{
			p.SetState(480)
			p.Identifier()
		}
		{
			p.SetState(481)
			p.Match(ObjectiveCParserCOLON)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(483)
			p.NullabilitySpecifier()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(484)
			p.Identifier()
		}

	}

	return localctx
}

// IProtocolNameContext is an interface to support dynamic dispatch.
type IProtocolNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocolNameContext differentiates from other interfaces.
	IsProtocolNameContext()
}

type ProtocolNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocolNameContext() *ProtocolNameContext {
	var p = new(ProtocolNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_protocolName
	return p
}

func (*ProtocolNameContext) IsProtocolNameContext() {}

func NewProtocolNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProtocolNameContext {
	var p = new(ProtocolNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_protocolName

	return p
}

func (s *ProtocolNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProtocolNameContext) LT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLT, 0)
}

func (s *ProtocolNameContext) ProtocolList() IProtocolListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolListContext)
}

func (s *ProtocolNameContext) GT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserGT, 0)
}

func (s *ProtocolNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProtocolNameContext) COVARIANT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOVARIANT, 0)
}

func (s *ProtocolNameContext) CONTRAVARIANT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCONTRAVARIANT, 0)
}

func (s *ProtocolNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProtocolNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProtocolNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterProtocolName(s)
	}
}

func (s *ProtocolNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitProtocolName(s)
	}
}

func (p *ObjectiveCParser) ProtocolName() (localctx IProtocolNameContext) {
	this := p
	_ = this

	localctx = NewProtocolNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ObjectiveCParserRULE_protocolName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(495)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserLT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(487)
			p.Match(ObjectiveCParserLT)
		}
		{
			p.SetState(488)
			p.ProtocolList()
		}
		{
			p.SetState(489)
			p.Match(ObjectiveCParserGT)
		}

	case ObjectiveCParserBOOL, ObjectiveCParserClass, ObjectiveCParserBYCOPY, ObjectiveCParserBYREF, ObjectiveCParserID, ObjectiveCParserIMP, ObjectiveCParserIN, ObjectiveCParserINOUT, ObjectiveCParserONEWAY, ObjectiveCParserOUT, ObjectiveCParserPROTOCOL_, ObjectiveCParserSEL, ObjectiveCParserSELF, ObjectiveCParserSUPER, ObjectiveCParserATOMIC, ObjectiveCParserNONATOMIC, ObjectiveCParserRETAIN, ObjectiveCParserAUTORELEASING_QUALIFIER, ObjectiveCParserBLOCK, ObjectiveCParserBRIDGE_RETAINED, ObjectiveCParserBRIDGE_TRANSFER, ObjectiveCParserCOVARIANT, ObjectiveCParserCONTRAVARIANT, ObjectiveCParserDEPRECATED, ObjectiveCParserKINDOF, ObjectiveCParserUNUSED, ObjectiveCParserNULL_UNSPECIFIED, ObjectiveCParserNULLABLE, ObjectiveCParserNONNULL, ObjectiveCParserNULL_RESETTABLE, ObjectiveCParserNS_INLINE, ObjectiveCParserNS_ENUM, ObjectiveCParserNS_OPTIONS, ObjectiveCParserASSIGN, ObjectiveCParserCOPY, ObjectiveCParserGETTER, ObjectiveCParserSETTER, ObjectiveCParserSTRONG, ObjectiveCParserREADONLY, ObjectiveCParserREADWRITE, ObjectiveCParserWEAK, ObjectiveCParserUNSAFE_UNRETAINED, ObjectiveCParserIB_OUTLET, ObjectiveCParserIB_OUTLET_COLLECTION, ObjectiveCParserIB_INSPECTABLE, ObjectiveCParserIB_DESIGNABLE, ObjectiveCParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(492)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(491)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ObjectiveCParserCOVARIANT || _la == ObjectiveCParserCONTRAVARIANT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(494)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInstanceVariablesContext is an interface to support dynamic dispatch.
type IInstanceVariablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstanceVariablesContext differentiates from other interfaces.
	IsInstanceVariablesContext()
}

type InstanceVariablesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceVariablesContext() *InstanceVariablesContext {
	var p = new(InstanceVariablesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_instanceVariables
	return p
}

func (*InstanceVariablesContext) IsInstanceVariablesContext() {}

func NewInstanceVariablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceVariablesContext {
	var p = new(InstanceVariablesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_instanceVariables

	return p
}

func (s *InstanceVariablesContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceVariablesContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACE, 0)
}

func (s *InstanceVariablesContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACE, 0)
}

func (s *InstanceVariablesContext) AllVisibilitySection() []IVisibilitySectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVisibilitySectionContext)(nil)).Elem())
	var tst = make([]IVisibilitySectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVisibilitySectionContext)
		}
	}

	return tst
}

func (s *InstanceVariablesContext) VisibilitySection(i int) IVisibilitySectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibilitySectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVisibilitySectionContext)
}

func (s *InstanceVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceVariablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterInstanceVariables(s)
	}
}

func (s *InstanceVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitInstanceVariables(s)
	}
}

func (p *ObjectiveCParser) InstanceVariables() (localctx IInstanceVariablesContext) {
	this := p
	_ = this

	localctx = NewInstanceVariablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ObjectiveCParserRULE_instanceVariables)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(497)
		p.Match(ObjectiveCParserLBRACE)
	}
	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(ObjectiveCParserPACKAGE-68))|(1<<(ObjectiveCParserPRIVATE-68))|(1<<(ObjectiveCParserPROTECTED-68))|(1<<(ObjectiveCParserPUBLIC-68))|(1<<(ObjectiveCParserATOMIC-68))|(1<<(ObjectiveCParserNONATOMIC-68))|(1<<(ObjectiveCParserRETAIN-68))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-68))|(1<<(ObjectiveCParserBLOCK-68))|(1<<(ObjectiveCParserBRIDGE-68))|(1<<(ObjectiveCParserBRIDGE_RETAINED-68))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-68))|(1<<(ObjectiveCParserCOVARIANT-68))|(1<<(ObjectiveCParserCONTRAVARIANT-68))|(1<<(ObjectiveCParserDEPRECATED-68))|(1<<(ObjectiveCParserKINDOF-68))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-68))|(1<<(ObjectiveCParserTYPEOF-68))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-68))|(1<<(ObjectiveCParserUNUSED-68))|(1<<(ObjectiveCParserWEAK_QUALIFIER-68))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(ObjectiveCParserNULLABLE-100))|(1<<(ObjectiveCParserNONNULL-100))|(1<<(ObjectiveCParserNULL_RESETTABLE-100))|(1<<(ObjectiveCParserNS_INLINE-100))|(1<<(ObjectiveCParserNS_ENUM-100))|(1<<(ObjectiveCParserNS_OPTIONS-100))|(1<<(ObjectiveCParserASSIGN-100))|(1<<(ObjectiveCParserCOPY-100))|(1<<(ObjectiveCParserGETTER-100))|(1<<(ObjectiveCParserSETTER-100))|(1<<(ObjectiveCParserSTRONG-100))|(1<<(ObjectiveCParserREADONLY-100))|(1<<(ObjectiveCParserREADWRITE-100))|(1<<(ObjectiveCParserWEAK-100))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-100))|(1<<(ObjectiveCParserIB_OUTLET-100))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-100))|(1<<(ObjectiveCParserIB_INSPECTABLE-100))|(1<<(ObjectiveCParserIB_DESIGNABLE-100))|(1<<(ObjectiveCParserIDENTIFIER-100)))) != 0) {
		{
			p.SetState(498)
			p.VisibilitySection()
		}

		p.SetState(503)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(504)
		p.Match(ObjectiveCParserRBRACE)
	}

	return localctx
}

// IVisibilitySectionContext is an interface to support dynamic dispatch.
type IVisibilitySectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVisibilitySectionContext differentiates from other interfaces.
	IsVisibilitySectionContext()
}

type VisibilitySectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVisibilitySectionContext() *VisibilitySectionContext {
	var p = new(VisibilitySectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_visibilitySection
	return p
}

func (*VisibilitySectionContext) IsVisibilitySectionContext() {}

func NewVisibilitySectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VisibilitySectionContext {
	var p = new(VisibilitySectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_visibilitySection

	return p
}

func (s *VisibilitySectionContext) GetParser() antlr.Parser { return s.parser }

func (s *VisibilitySectionContext) AccessModifier() IAccessModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccessModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *VisibilitySectionContext) AllFieldDeclaration() []IFieldDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldDeclarationContext)(nil)).Elem())
	var tst = make([]IFieldDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldDeclarationContext)
		}
	}

	return tst
}

func (s *VisibilitySectionContext) FieldDeclaration(i int) IFieldDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *VisibilitySectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilitySectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VisibilitySectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterVisibilitySection(s)
	}
}

func (s *VisibilitySectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitVisibilitySection(s)
	}
}

func (p *ObjectiveCParser) VisibilitySection() (localctx IVisibilitySectionContext) {
	this := p
	_ = this

	localctx = NewVisibilitySectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ObjectiveCParserRULE_visibilitySection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(518)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserPACKAGE, ObjectiveCParserPRIVATE, ObjectiveCParserPROTECTED, ObjectiveCParserPUBLIC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(506)
			p.AccessModifier()
		}
		p.SetState(510)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(507)
					p.FieldDeclaration()
				}

			}
			p.SetState(512)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())
		}

	case ObjectiveCParserCHAR, ObjectiveCParserCONST, ObjectiveCParserDOUBLE, ObjectiveCParserENUM, ObjectiveCParserFLOAT, ObjectiveCParserINLINE, ObjectiveCParserINT, ObjectiveCParserLONG, ObjectiveCParserRESTRICT, ObjectiveCParserSHORT, ObjectiveCParserSIGNED, ObjectiveCParserSTRUCT, ObjectiveCParserUNION, ObjectiveCParserUNSIGNED, ObjectiveCParserVOID, ObjectiveCParserVOLATILE, ObjectiveCParserBOOL, ObjectiveCParserClass, ObjectiveCParserBYCOPY, ObjectiveCParserBYREF, ObjectiveCParserID, ObjectiveCParserIMP, ObjectiveCParserIN, ObjectiveCParserINOUT, ObjectiveCParserONEWAY, ObjectiveCParserOUT, ObjectiveCParserPROTOCOL_, ObjectiveCParserSEL, ObjectiveCParserSELF, ObjectiveCParserSUPER, ObjectiveCParserATOMIC, ObjectiveCParserNONATOMIC, ObjectiveCParserRETAIN, ObjectiveCParserAUTORELEASING_QUALIFIER, ObjectiveCParserBLOCK, ObjectiveCParserBRIDGE, ObjectiveCParserBRIDGE_RETAINED, ObjectiveCParserBRIDGE_TRANSFER, ObjectiveCParserCOVARIANT, ObjectiveCParserCONTRAVARIANT, ObjectiveCParserDEPRECATED, ObjectiveCParserKINDOF, ObjectiveCParserSTRONG_QUALIFIER, ObjectiveCParserTYPEOF, ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER, ObjectiveCParserUNUSED, ObjectiveCParserWEAK_QUALIFIER, ObjectiveCParserNULL_UNSPECIFIED, ObjectiveCParserNULLABLE, ObjectiveCParserNONNULL, ObjectiveCParserNULL_RESETTABLE, ObjectiveCParserNS_INLINE, ObjectiveCParserNS_ENUM, ObjectiveCParserNS_OPTIONS, ObjectiveCParserASSIGN, ObjectiveCParserCOPY, ObjectiveCParserGETTER, ObjectiveCParserSETTER, ObjectiveCParserSTRONG, ObjectiveCParserREADONLY, ObjectiveCParserREADWRITE, ObjectiveCParserWEAK, ObjectiveCParserUNSAFE_UNRETAINED, ObjectiveCParserIB_OUTLET, ObjectiveCParserIB_OUTLET_COLLECTION, ObjectiveCParserIB_INSPECTABLE, ObjectiveCParserIB_DESIGNABLE, ObjectiveCParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(514)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(513)
					p.FieldDeclaration()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(516)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAccessModifierContext is an interface to support dynamic dispatch.
type IAccessModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccessModifierContext differentiates from other interfaces.
	IsAccessModifierContext()
}

type AccessModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessModifierContext() *AccessModifierContext {
	var p = new(AccessModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_accessModifier
	return p
}

func (*AccessModifierContext) IsAccessModifierContext() {}

func NewAccessModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessModifierContext {
	var p = new(AccessModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_accessModifier

	return p
}

func (s *AccessModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserPRIVATE, 0)
}

func (s *AccessModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserPROTECTED, 0)
}

func (s *AccessModifierContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserPACKAGE, 0)
}

func (s *AccessModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserPUBLIC, 0)
}

func (s *AccessModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterAccessModifier(s)
	}
}

func (s *AccessModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitAccessModifier(s)
	}
}

func (p *ObjectiveCParser) AccessModifier() (localctx IAccessModifierContext) {
	this := p
	_ = this

	localctx = NewAccessModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ObjectiveCParserRULE_accessModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(520)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(ObjectiveCParserPACKAGE-68))|(1<<(ObjectiveCParserPRIVATE-68))|(1<<(ObjectiveCParserPROTECTED-68))|(1<<(ObjectiveCParserPUBLIC-68)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IInterfaceDeclarationListContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceDeclarationListContext differentiates from other interfaces.
	IsInterfaceDeclarationListContext()
}

type InterfaceDeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationListContext() *InterfaceDeclarationListContext {
	var p = new(InterfaceDeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_interfaceDeclarationList
	return p
}

func (*InterfaceDeclarationListContext) IsInterfaceDeclarationListContext() {}

func NewInterfaceDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationListContext {
	var p = new(InterfaceDeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_interfaceDeclarationList

	return p
}

func (s *InterfaceDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationListContext) AllDeclaration() []IDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarationContext)(nil)).Elem())
	var tst = make([]IDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarationContext)
		}
	}

	return tst
}

func (s *InterfaceDeclarationListContext) Declaration(i int) IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *InterfaceDeclarationListContext) AllClassMethodDeclaration() []IClassMethodDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassMethodDeclarationContext)(nil)).Elem())
	var tst = make([]IClassMethodDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassMethodDeclarationContext)
		}
	}

	return tst
}

func (s *InterfaceDeclarationListContext) ClassMethodDeclaration(i int) IClassMethodDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassMethodDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassMethodDeclarationContext)
}

func (s *InterfaceDeclarationListContext) AllInstanceMethodDeclaration() []IInstanceMethodDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstanceMethodDeclarationContext)(nil)).Elem())
	var tst = make([]IInstanceMethodDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstanceMethodDeclarationContext)
		}
	}

	return tst
}

func (s *InterfaceDeclarationListContext) InstanceMethodDeclaration(i int) IInstanceMethodDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstanceMethodDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstanceMethodDeclarationContext)
}

func (s *InterfaceDeclarationListContext) AllPropertyDeclaration() []IPropertyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyDeclarationContext)(nil)).Elem())
	var tst = make([]IPropertyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyDeclarationContext)
		}
	}

	return tst
}

func (s *InterfaceDeclarationListContext) PropertyDeclaration(i int) IPropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *InterfaceDeclarationListContext) AllFunctionDeclaration() []IFunctionDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionDeclarationContext)(nil)).Elem())
	var tst = make([]IFunctionDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionDeclarationContext)
		}
	}

	return tst
}

func (s *InterfaceDeclarationListContext) FunctionDeclaration(i int) IFunctionDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *InterfaceDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterInterfaceDeclarationList(s)
	}
}

func (s *InterfaceDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitInterfaceDeclarationList(s)
	}
}

func (p *ObjectiveCParser) InterfaceDeclarationList() (localctx IInterfaceDeclarationListContext) {
	this := p
	_ = this

	localctx = NewInterfaceDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ObjectiveCParserRULE_interfaceDeclarationList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(527)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(522)
					p.Declaration()
				}

			case 2:
				{
					p.SetState(523)
					p.ClassMethodDeclaration()
				}

			case 3:
				{
					p.SetState(524)
					p.InstanceMethodDeclaration()
				}

			case 4:
				{
					p.SetState(525)
					p.PropertyDeclaration()
				}

			case 5:
				{
					p.SetState(526)
					p.FunctionDeclaration()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(529)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())
	}

	return localctx
}

// IClassMethodDeclarationContext is an interface to support dynamic dispatch.
type IClassMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassMethodDeclarationContext differentiates from other interfaces.
	IsClassMethodDeclarationContext()
}

type ClassMethodDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMethodDeclarationContext() *ClassMethodDeclarationContext {
	var p = new(ClassMethodDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_classMethodDeclaration
	return p
}

func (*ClassMethodDeclarationContext) IsClassMethodDeclarationContext() {}

func NewClassMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMethodDeclarationContext {
	var p = new(ClassMethodDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_classMethodDeclaration

	return p
}

func (s *ClassMethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMethodDeclarationContext) ADD() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserADD, 0)
}

func (s *ClassMethodDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *ClassMethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterClassMethodDeclaration(s)
	}
}

func (s *ClassMethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitClassMethodDeclaration(s)
	}
}

func (p *ObjectiveCParser) ClassMethodDeclaration() (localctx IClassMethodDeclarationContext) {
	this := p
	_ = this

	localctx = NewClassMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ObjectiveCParserRULE_classMethodDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(531)
		p.Match(ObjectiveCParserADD)
	}
	{
		p.SetState(532)
		p.MethodDeclaration()
	}

	return localctx
}

// IInstanceMethodDeclarationContext is an interface to support dynamic dispatch.
type IInstanceMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstanceMethodDeclarationContext differentiates from other interfaces.
	IsInstanceMethodDeclarationContext()
}

type InstanceMethodDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceMethodDeclarationContext() *InstanceMethodDeclarationContext {
	var p = new(InstanceMethodDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_instanceMethodDeclaration
	return p
}

func (*InstanceMethodDeclarationContext) IsInstanceMethodDeclarationContext() {}

func NewInstanceMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceMethodDeclarationContext {
	var p = new(InstanceMethodDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_instanceMethodDeclaration

	return p
}

func (s *InstanceMethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceMethodDeclarationContext) SUB() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSUB, 0)
}

func (s *InstanceMethodDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *InstanceMethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceMethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceMethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterInstanceMethodDeclaration(s)
	}
}

func (s *InstanceMethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitInstanceMethodDeclaration(s)
	}
}

func (p *ObjectiveCParser) InstanceMethodDeclaration() (localctx IInstanceMethodDeclarationContext) {
	this := p
	_ = this

	localctx = NewInstanceMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ObjectiveCParserRULE_instanceMethodDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(534)
		p.Match(ObjectiveCParserSUB)
	}
	{
		p.SetState(535)
		p.MethodDeclaration()
	}

	return localctx
}

// IMethodDeclarationContext is an interface to support dynamic dispatch.
type IMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodDeclarationContext differentiates from other interfaces.
	IsMethodDeclarationContext()
}

type MethodDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclarationContext() *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_methodDeclaration
	return p
}

func (*MethodDeclarationContext) IsMethodDeclarationContext() {}

func NewMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_methodDeclaration

	return p
}

func (s *MethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclarationContext) MethodSelector() IMethodSelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodSelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodSelectorContext)
}

func (s *MethodDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, 0)
}

func (s *MethodDeclarationContext) MethodType() IMethodTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodTypeContext)
}

func (s *MethodDeclarationContext) Macro() IMacroContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMacroContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMacroContext)
}

func (s *MethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterMethodDeclaration(s)
	}
}

func (s *MethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitMethodDeclaration(s)
	}
}

func (p *ObjectiveCParser) MethodDeclaration() (localctx IMethodDeclarationContext) {
	this := p
	_ = this

	localctx = NewMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ObjectiveCParserRULE_methodDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(538)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserLP {
		{
			p.SetState(537)
			p.MethodType()
		}

	}
	{
		p.SetState(540)
		p.MethodSelector()
	}
	p.SetState(542)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
		{
			p.SetState(541)
			p.Macro()
		}

	}
	{
		p.SetState(544)
		p.Match(ObjectiveCParserSEMI)
	}

	return localctx
}

// IImplementationDefinitionListContext is an interface to support dynamic dispatch.
type IImplementationDefinitionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplementationDefinitionListContext differentiates from other interfaces.
	IsImplementationDefinitionListContext()
}

type ImplementationDefinitionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementationDefinitionListContext() *ImplementationDefinitionListContext {
	var p = new(ImplementationDefinitionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_implementationDefinitionList
	return p
}

func (*ImplementationDefinitionListContext) IsImplementationDefinitionListContext() {}

func NewImplementationDefinitionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementationDefinitionListContext {
	var p = new(ImplementationDefinitionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_implementationDefinitionList

	return p
}

func (s *ImplementationDefinitionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementationDefinitionListContext) AllFunctionDefinition() []IFunctionDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionDefinitionContext)(nil)).Elem())
	var tst = make([]IFunctionDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionDefinitionContext)
		}
	}

	return tst
}

func (s *ImplementationDefinitionListContext) FunctionDefinition(i int) IFunctionDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *ImplementationDefinitionListContext) AllDeclaration() []IDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarationContext)(nil)).Elem())
	var tst = make([]IDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarationContext)
		}
	}

	return tst
}

func (s *ImplementationDefinitionListContext) Declaration(i int) IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ImplementationDefinitionListContext) AllClassMethodDefinition() []IClassMethodDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassMethodDefinitionContext)(nil)).Elem())
	var tst = make([]IClassMethodDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassMethodDefinitionContext)
		}
	}

	return tst
}

func (s *ImplementationDefinitionListContext) ClassMethodDefinition(i int) IClassMethodDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassMethodDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassMethodDefinitionContext)
}

func (s *ImplementationDefinitionListContext) AllInstanceMethodDefinition() []IInstanceMethodDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstanceMethodDefinitionContext)(nil)).Elem())
	var tst = make([]IInstanceMethodDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstanceMethodDefinitionContext)
		}
	}

	return tst
}

func (s *ImplementationDefinitionListContext) InstanceMethodDefinition(i int) IInstanceMethodDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstanceMethodDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstanceMethodDefinitionContext)
}

func (s *ImplementationDefinitionListContext) AllPropertyImplementation() []IPropertyImplementationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyImplementationContext)(nil)).Elem())
	var tst = make([]IPropertyImplementationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyImplementationContext)
		}
	}

	return tst
}

func (s *ImplementationDefinitionListContext) PropertyImplementation(i int) IPropertyImplementationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyImplementationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyImplementationContext)
}

func (s *ImplementationDefinitionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementationDefinitionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementationDefinitionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterImplementationDefinitionList(s)
	}
}

func (s *ImplementationDefinitionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitImplementationDefinitionList(s)
	}
}

func (p *ObjectiveCParser) ImplementationDefinitionList() (localctx IImplementationDefinitionListContext) {
	this := p
	_ = this

	localctx = NewImplementationDefinitionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ObjectiveCParserRULE_implementationDefinitionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserAUTO)|(1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserEXTERN)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserREGISTER)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSTATIC)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserTYPEDEF)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32))|(1<<(ObjectiveCParserDYNAMIC-32)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(ObjectiveCParserSYNTHESIZE-78))|(1<<(ObjectiveCParserATOMIC-78))|(1<<(ObjectiveCParserNONATOMIC-78))|(1<<(ObjectiveCParserRETAIN-78))|(1<<(ObjectiveCParserATTRIBUTE-78))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-78))|(1<<(ObjectiveCParserBLOCK-78))|(1<<(ObjectiveCParserBRIDGE-78))|(1<<(ObjectiveCParserBRIDGE_RETAINED-78))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-78))|(1<<(ObjectiveCParserCOVARIANT-78))|(1<<(ObjectiveCParserCONTRAVARIANT-78))|(1<<(ObjectiveCParserDEPRECATED-78))|(1<<(ObjectiveCParserKINDOF-78))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-78))|(1<<(ObjectiveCParserTYPEOF-78))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-78))|(1<<(ObjectiveCParserUNUSED-78))|(1<<(ObjectiveCParserWEAK_QUALIFIER-78))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-78))|(1<<(ObjectiveCParserNULLABLE-78))|(1<<(ObjectiveCParserNONNULL-78))|(1<<(ObjectiveCParserNULL_RESETTABLE-78))|(1<<(ObjectiveCParserNS_INLINE-78))|(1<<(ObjectiveCParserNS_ENUM-78))|(1<<(ObjectiveCParserNS_OPTIONS-78))|(1<<(ObjectiveCParserASSIGN-78))|(1<<(ObjectiveCParserCOPY-78))|(1<<(ObjectiveCParserGETTER-78))|(1<<(ObjectiveCParserSETTER-78)))) != 0) || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(ObjectiveCParserSTRONG-110))|(1<<(ObjectiveCParserREADONLY-110))|(1<<(ObjectiveCParserREADWRITE-110))|(1<<(ObjectiveCParserWEAK-110))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-110))|(1<<(ObjectiveCParserIB_OUTLET-110))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-110))|(1<<(ObjectiveCParserIB_INSPECTABLE-110))|(1<<(ObjectiveCParserIB_DESIGNABLE-110))|(1<<(ObjectiveCParserIDENTIFIER-110)))) != 0) || _la == ObjectiveCParserADD || _la == ObjectiveCParserSUB {
		p.SetState(551)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(546)
				p.FunctionDefinition()
			}

		case 2:
			{
				p.SetState(547)
				p.Declaration()
			}

		case 3:
			{
				p.SetState(548)
				p.ClassMethodDefinition()
			}

		case 4:
			{
				p.SetState(549)
				p.InstanceMethodDefinition()
			}

		case 5:
			{
				p.SetState(550)
				p.PropertyImplementation()
			}

		}

		p.SetState(553)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IClassMethodDefinitionContext is an interface to support dynamic dispatch.
type IClassMethodDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassMethodDefinitionContext differentiates from other interfaces.
	IsClassMethodDefinitionContext()
}

type ClassMethodDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMethodDefinitionContext() *ClassMethodDefinitionContext {
	var p = new(ClassMethodDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_classMethodDefinition
	return p
}

func (*ClassMethodDefinitionContext) IsClassMethodDefinitionContext() {}

func NewClassMethodDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMethodDefinitionContext {
	var p = new(ClassMethodDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_classMethodDefinition

	return p
}

func (s *ClassMethodDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMethodDefinitionContext) ADD() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserADD, 0)
}

func (s *ClassMethodDefinitionContext) MethodDefinition() IMethodDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodDefinitionContext)
}

func (s *ClassMethodDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMethodDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMethodDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterClassMethodDefinition(s)
	}
}

func (s *ClassMethodDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitClassMethodDefinition(s)
	}
}

func (p *ObjectiveCParser) ClassMethodDefinition() (localctx IClassMethodDefinitionContext) {
	this := p
	_ = this

	localctx = NewClassMethodDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ObjectiveCParserRULE_classMethodDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(555)
		p.Match(ObjectiveCParserADD)
	}
	{
		p.SetState(556)
		p.MethodDefinition()
	}

	return localctx
}

// IInstanceMethodDefinitionContext is an interface to support dynamic dispatch.
type IInstanceMethodDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstanceMethodDefinitionContext differentiates from other interfaces.
	IsInstanceMethodDefinitionContext()
}

type InstanceMethodDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceMethodDefinitionContext() *InstanceMethodDefinitionContext {
	var p = new(InstanceMethodDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_instanceMethodDefinition
	return p
}

func (*InstanceMethodDefinitionContext) IsInstanceMethodDefinitionContext() {}

func NewInstanceMethodDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceMethodDefinitionContext {
	var p = new(InstanceMethodDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_instanceMethodDefinition

	return p
}

func (s *InstanceMethodDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceMethodDefinitionContext) SUB() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSUB, 0)
}

func (s *InstanceMethodDefinitionContext) MethodDefinition() IMethodDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodDefinitionContext)
}

func (s *InstanceMethodDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceMethodDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceMethodDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterInstanceMethodDefinition(s)
	}
}

func (s *InstanceMethodDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitInstanceMethodDefinition(s)
	}
}

func (p *ObjectiveCParser) InstanceMethodDefinition() (localctx IInstanceMethodDefinitionContext) {
	this := p
	_ = this

	localctx = NewInstanceMethodDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ObjectiveCParserRULE_instanceMethodDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(558)
		p.Match(ObjectiveCParserSUB)
	}
	{
		p.SetState(559)
		p.MethodDefinition()
	}

	return localctx
}

// IMethodDefinitionContext is an interface to support dynamic dispatch.
type IMethodDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodDefinitionContext differentiates from other interfaces.
	IsMethodDefinitionContext()
}

type MethodDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDefinitionContext() *MethodDefinitionContext {
	var p = new(MethodDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_methodDefinition
	return p
}

func (*MethodDefinitionContext) IsMethodDefinitionContext() {}

func NewMethodDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDefinitionContext {
	var p = new(MethodDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_methodDefinition

	return p
}

func (s *MethodDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDefinitionContext) MethodSelector() IMethodSelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodSelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodSelectorContext)
}

func (s *MethodDefinitionContext) CompoundStatement() ICompoundStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *MethodDefinitionContext) MethodType() IMethodTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodTypeContext)
}

func (s *MethodDefinitionContext) InitDeclaratorList() IInitDeclaratorListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitDeclaratorListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitDeclaratorListContext)
}

func (s *MethodDefinitionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, 0)
}

func (s *MethodDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterMethodDefinition(s)
	}
}

func (s *MethodDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitMethodDefinition(s)
	}
}

func (p *ObjectiveCParser) MethodDefinition() (localctx IMethodDefinitionContext) {
	this := p
	_ = this

	localctx = NewMethodDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ObjectiveCParserRULE_methodDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserLP {
		{
			p.SetState(561)
			p.MethodType()
		}

	}
	{
		p.SetState(564)
		p.MethodSelector()
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113))|(1<<(ObjectiveCParserLP-113)))) != 0) || _la == ObjectiveCParserMUL {
		{
			p.SetState(565)
			p.InitDeclaratorList()
		}

	}
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserSEMI {
		{
			p.SetState(568)
			p.Match(ObjectiveCParserSEMI)
		}

	}
	{
		p.SetState(571)
		p.CompoundStatement()
	}

	return localctx
}

// IMethodSelectorContext is an interface to support dynamic dispatch.
type IMethodSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodSelectorContext differentiates from other interfaces.
	IsMethodSelectorContext()
}

type MethodSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodSelectorContext() *MethodSelectorContext {
	var p = new(MethodSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_methodSelector
	return p
}

func (*MethodSelectorContext) IsMethodSelectorContext() {}

func NewMethodSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodSelectorContext {
	var p = new(MethodSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_methodSelector

	return p
}

func (s *MethodSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodSelectorContext) Selector() ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *MethodSelectorContext) AllKeywordDeclarator() []IKeywordDeclaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IKeywordDeclaratorContext)(nil)).Elem())
	var tst = make([]IKeywordDeclaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IKeywordDeclaratorContext)
		}
	}

	return tst
}

func (s *MethodSelectorContext) KeywordDeclarator(i int) IKeywordDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordDeclaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IKeywordDeclaratorContext)
}

func (s *MethodSelectorContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, 0)
}

func (s *MethodSelectorContext) ELIPSIS() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserELIPSIS, 0)
}

func (s *MethodSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterMethodSelector(s)
	}
}

func (s *MethodSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitMethodSelector(s)
	}
}

func (p *ObjectiveCParser) MethodSelector() (localctx IMethodSelectorContext) {
	this := p
	_ = this

	localctx = NewMethodSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ObjectiveCParserRULE_methodSelector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(583)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(573)
			p.Selector()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(575)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(574)
					p.KeywordDeclarator()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(577)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())
		}
		p.SetState(581)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ObjectiveCParserCOMMA {
			{
				p.SetState(579)
				p.Match(ObjectiveCParserCOMMA)
			}
			{
				p.SetState(580)
				p.Match(ObjectiveCParserELIPSIS)
			}

		}

	}

	return localctx
}

// IKeywordDeclaratorContext is an interface to support dynamic dispatch.
type IKeywordDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordDeclaratorContext differentiates from other interfaces.
	IsKeywordDeclaratorContext()
}

type KeywordDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordDeclaratorContext() *KeywordDeclaratorContext {
	var p = new(KeywordDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_keywordDeclarator
	return p
}

func (*KeywordDeclaratorContext) IsKeywordDeclaratorContext() {}

func NewKeywordDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordDeclaratorContext {
	var p = new(KeywordDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_keywordDeclarator

	return p
}

func (s *KeywordDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordDeclaratorContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOLON, 0)
}

func (s *KeywordDeclaratorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *KeywordDeclaratorContext) Selector() ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *KeywordDeclaratorContext) AllMethodType() []IMethodTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMethodTypeContext)(nil)).Elem())
	var tst = make([]IMethodTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMethodTypeContext)
		}
	}

	return tst
}

func (s *KeywordDeclaratorContext) MethodType(i int) IMethodTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMethodTypeContext)
}

func (s *KeywordDeclaratorContext) ArcBehaviourSpecifier() IArcBehaviourSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArcBehaviourSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArcBehaviourSpecifierContext)
}

func (s *KeywordDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterKeywordDeclarator(s)
	}
}

func (s *KeywordDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitKeywordDeclarator(s)
	}
}

func (p *ObjectiveCParser) KeywordDeclarator() (localctx IKeywordDeclaratorContext) {
	this := p
	_ = this

	localctx = NewKeywordDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ObjectiveCParserRULE_keywordDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(586)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserRETURN || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
		{
			p.SetState(585)
			p.Selector()
		}

	}
	{
		p.SetState(588)
		p.Match(ObjectiveCParserCOLON)
	}
	p.SetState(592)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ObjectiveCParserLP {
		{
			p.SetState(589)
			p.MethodType()
		}

		p.SetState(594)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(596)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(595)
			p.ArcBehaviourSpecifier()
		}

	}
	{
		p.SetState(598)
		p.Identifier()
	}

	return localctx
}

// ISelectorContext is an interface to support dynamic dispatch.
type ISelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectorContext differentiates from other interfaces.
	IsSelectorContext()
}

type SelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectorContext() *SelectorContext {
	var p = new(SelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_selector
	return p
}

func (*SelectorContext) IsSelectorContext() {}

func NewSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectorContext {
	var p = new(SelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_selector

	return p
}

func (s *SelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectorContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRETURN, 0)
}

func (s *SelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterSelector(s)
	}
}

func (s *SelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitSelector(s)
	}
}

func (p *ObjectiveCParser) Selector() (localctx ISelectorContext) {
	this := p
	_ = this

	localctx = NewSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ObjectiveCParserRULE_selector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(602)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserBOOL, ObjectiveCParserClass, ObjectiveCParserBYCOPY, ObjectiveCParserBYREF, ObjectiveCParserID, ObjectiveCParserIMP, ObjectiveCParserIN, ObjectiveCParserINOUT, ObjectiveCParserONEWAY, ObjectiveCParserOUT, ObjectiveCParserPROTOCOL_, ObjectiveCParserSEL, ObjectiveCParserSELF, ObjectiveCParserSUPER, ObjectiveCParserATOMIC, ObjectiveCParserNONATOMIC, ObjectiveCParserRETAIN, ObjectiveCParserAUTORELEASING_QUALIFIER, ObjectiveCParserBLOCK, ObjectiveCParserBRIDGE_RETAINED, ObjectiveCParserBRIDGE_TRANSFER, ObjectiveCParserCOVARIANT, ObjectiveCParserCONTRAVARIANT, ObjectiveCParserDEPRECATED, ObjectiveCParserKINDOF, ObjectiveCParserUNUSED, ObjectiveCParserNULL_UNSPECIFIED, ObjectiveCParserNULLABLE, ObjectiveCParserNONNULL, ObjectiveCParserNULL_RESETTABLE, ObjectiveCParserNS_INLINE, ObjectiveCParserNS_ENUM, ObjectiveCParserNS_OPTIONS, ObjectiveCParserASSIGN, ObjectiveCParserCOPY, ObjectiveCParserGETTER, ObjectiveCParserSETTER, ObjectiveCParserSTRONG, ObjectiveCParserREADONLY, ObjectiveCParserREADWRITE, ObjectiveCParserWEAK, ObjectiveCParserUNSAFE_UNRETAINED, ObjectiveCParserIB_OUTLET, ObjectiveCParserIB_OUTLET_COLLECTION, ObjectiveCParserIB_INSPECTABLE, ObjectiveCParserIB_DESIGNABLE, ObjectiveCParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(600)
			p.Identifier()
		}

	case ObjectiveCParserRETURN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(601)
			p.Match(ObjectiveCParserRETURN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMethodTypeContext is an interface to support dynamic dispatch.
type IMethodTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodTypeContext differentiates from other interfaces.
	IsMethodTypeContext()
}

type MethodTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodTypeContext() *MethodTypeContext {
	var p = new(MethodTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_methodType
	return p
}

func (*MethodTypeContext) IsMethodTypeContext() {}

func NewMethodTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodTypeContext {
	var p = new(MethodTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_methodType

	return p
}

func (s *MethodTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodTypeContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *MethodTypeContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MethodTypeContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *MethodTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterMethodType(s)
	}
}

func (s *MethodTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitMethodType(s)
	}
}

func (p *ObjectiveCParser) MethodType() (localctx IMethodTypeContext) {
	this := p
	_ = this

	localctx = NewMethodTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ObjectiveCParserRULE_methodType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(605)
		p.TypeName()
	}
	{
		p.SetState(606)
		p.Match(ObjectiveCParserRP)
	}

	return localctx
}

// IPropertyImplementationContext is an interface to support dynamic dispatch.
type IPropertyImplementationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyImplementationContext differentiates from other interfaces.
	IsPropertyImplementationContext()
}

type PropertyImplementationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyImplementationContext() *PropertyImplementationContext {
	var p = new(PropertyImplementationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_propertyImplementation
	return p
}

func (*PropertyImplementationContext) IsPropertyImplementationContext() {}

func NewPropertyImplementationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyImplementationContext {
	var p = new(PropertyImplementationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_propertyImplementation

	return p
}

func (s *PropertyImplementationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyImplementationContext) SYNTHESIZE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSYNTHESIZE, 0)
}

func (s *PropertyImplementationContext) PropertySynthesizeList() IPropertySynthesizeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertySynthesizeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertySynthesizeListContext)
}

func (s *PropertyImplementationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, 0)
}

func (s *PropertyImplementationContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserDYNAMIC, 0)
}

func (s *PropertyImplementationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyImplementationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyImplementationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterPropertyImplementation(s)
	}
}

func (s *PropertyImplementationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitPropertyImplementation(s)
	}
}

func (p *ObjectiveCParser) PropertyImplementation() (localctx IPropertyImplementationContext) {
	this := p
	_ = this

	localctx = NewPropertyImplementationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ObjectiveCParserRULE_propertyImplementation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(616)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserSYNTHESIZE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(608)
			p.Match(ObjectiveCParserSYNTHESIZE)
		}
		{
			p.SetState(609)
			p.PropertySynthesizeList()
		}
		{
			p.SetState(610)
			p.Match(ObjectiveCParserSEMI)
		}

	case ObjectiveCParserDYNAMIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(612)
			p.Match(ObjectiveCParserDYNAMIC)
		}
		{
			p.SetState(613)
			p.PropertySynthesizeList()
		}
		{
			p.SetState(614)
			p.Match(ObjectiveCParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPropertySynthesizeListContext is an interface to support dynamic dispatch.
type IPropertySynthesizeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertySynthesizeListContext differentiates from other interfaces.
	IsPropertySynthesizeListContext()
}

type PropertySynthesizeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertySynthesizeListContext() *PropertySynthesizeListContext {
	var p = new(PropertySynthesizeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_propertySynthesizeList
	return p
}

func (*PropertySynthesizeListContext) IsPropertySynthesizeListContext() {}

func NewPropertySynthesizeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertySynthesizeListContext {
	var p = new(PropertySynthesizeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_propertySynthesizeList

	return p
}

func (s *PropertySynthesizeListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertySynthesizeListContext) AllPropertySynthesizeItem() []IPropertySynthesizeItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertySynthesizeItemContext)(nil)).Elem())
	var tst = make([]IPropertySynthesizeItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertySynthesizeItemContext)
		}
	}

	return tst
}

func (s *PropertySynthesizeListContext) PropertySynthesizeItem(i int) IPropertySynthesizeItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertySynthesizeItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertySynthesizeItemContext)
}

func (s *PropertySynthesizeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *PropertySynthesizeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *PropertySynthesizeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertySynthesizeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertySynthesizeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterPropertySynthesizeList(s)
	}
}

func (s *PropertySynthesizeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitPropertySynthesizeList(s)
	}
}

func (p *ObjectiveCParser) PropertySynthesizeList() (localctx IPropertySynthesizeListContext) {
	this := p
	_ = this

	localctx = NewPropertySynthesizeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ObjectiveCParserRULE_propertySynthesizeList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		p.PropertySynthesizeItem()
	}
	p.SetState(623)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ObjectiveCParserCOMMA {
		{
			p.SetState(619)
			p.Match(ObjectiveCParserCOMMA)
		}
		{
			p.SetState(620)
			p.PropertySynthesizeItem()
		}

		p.SetState(625)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPropertySynthesizeItemContext is an interface to support dynamic dispatch.
type IPropertySynthesizeItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertySynthesizeItemContext differentiates from other interfaces.
	IsPropertySynthesizeItemContext()
}

type PropertySynthesizeItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertySynthesizeItemContext() *PropertySynthesizeItemContext {
	var p = new(PropertySynthesizeItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_propertySynthesizeItem
	return p
}

func (*PropertySynthesizeItemContext) IsPropertySynthesizeItemContext() {}

func NewPropertySynthesizeItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertySynthesizeItemContext {
	var p = new(PropertySynthesizeItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_propertySynthesizeItem

	return p
}

func (s *PropertySynthesizeItemContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertySynthesizeItemContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *PropertySynthesizeItemContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertySynthesizeItemContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserASSIGNMENT, 0)
}

func (s *PropertySynthesizeItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertySynthesizeItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertySynthesizeItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterPropertySynthesizeItem(s)
	}
}

func (s *PropertySynthesizeItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitPropertySynthesizeItem(s)
	}
}

func (p *ObjectiveCParser) PropertySynthesizeItem() (localctx IPropertySynthesizeItemContext) {
	this := p
	_ = this

	localctx = NewPropertySynthesizeItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ObjectiveCParserRULE_propertySynthesizeItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(626)
		p.Identifier()
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserASSIGNMENT {
		{
			p.SetState(627)
			p.Match(ObjectiveCParserASSIGNMENT)
		}
		{
			p.SetState(628)
			p.Identifier()
		}

	}

	return localctx
}

// IBlockTypeContext is an interface to support dynamic dispatch.
type IBlockTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockTypeContext differentiates from other interfaces.
	IsBlockTypeContext()
}

type BlockTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockTypeContext() *BlockTypeContext {
	var p = new(BlockTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_blockType
	return p
}

func (*BlockTypeContext) IsBlockTypeContext() {}

func NewBlockTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockTypeContext {
	var p = new(BlockTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_blockType

	return p
}

func (s *BlockTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockTypeContext) AllTypeSpecifier() []ITypeSpecifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeSpecifierContext)(nil)).Elem())
	var tst = make([]ITypeSpecifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeSpecifierContext)
		}
	}

	return tst
}

func (s *BlockTypeContext) TypeSpecifier(i int) ITypeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSpecifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *BlockTypeContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *BlockTypeContext) BITXOR() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBITXOR, 0)
}

func (s *BlockTypeContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *BlockTypeContext) AllNullabilitySpecifier() []INullabilitySpecifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INullabilitySpecifierContext)(nil)).Elem())
	var tst = make([]INullabilitySpecifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INullabilitySpecifierContext)
		}
	}

	return tst
}

func (s *BlockTypeContext) NullabilitySpecifier(i int) INullabilitySpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullabilitySpecifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INullabilitySpecifierContext)
}

func (s *BlockTypeContext) BlockParameters() IBlockParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockParametersContext)
}

func (s *BlockTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterBlockType(s)
	}
}

func (s *BlockTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitBlockType(s)
	}
}

func (p *ObjectiveCParser) BlockType() (localctx IBlockTypeContext) {
	this := p
	_ = this

	localctx = NewBlockTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ObjectiveCParserRULE_blockType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(632)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(631)
			p.NullabilitySpecifier()
		}

	}
	{
		p.SetState(634)
		p.TypeSpecifier()
	}
	p.SetState(636)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(ObjectiveCParserNULL_UNSPECIFIED-99))|(1<<(ObjectiveCParserNULLABLE-99))|(1<<(ObjectiveCParserNONNULL-99))|(1<<(ObjectiveCParserNULL_RESETTABLE-99)))) != 0 {
		{
			p.SetState(635)
			p.NullabilitySpecifier()
		}

	}
	{
		p.SetState(638)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(639)
		p.Match(ObjectiveCParserBITXOR)
	}
	p.SetState(642)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(640)
			p.NullabilitySpecifier()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(641)
			p.TypeSpecifier()
		}

	}
	{
		p.SetState(644)
		p.Match(ObjectiveCParserRP)
	}
	p.SetState(646)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserLP {
		{
			p.SetState(645)
			p.BlockParameters()
		}

	}

	return localctx
}

// IGenericsSpecifierContext is an interface to support dynamic dispatch.
type IGenericsSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenericsSpecifierContext differentiates from other interfaces.
	IsGenericsSpecifierContext()
}

type GenericsSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericsSpecifierContext() *GenericsSpecifierContext {
	var p = new(GenericsSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_genericsSpecifier
	return p
}

func (*GenericsSpecifierContext) IsGenericsSpecifierContext() {}

func NewGenericsSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericsSpecifierContext {
	var p = new(GenericsSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_genericsSpecifier

	return p
}

func (s *GenericsSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericsSpecifierContext) LT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLT, 0)
}

func (s *GenericsSpecifierContext) GT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserGT, 0)
}

func (s *GenericsSpecifierContext) AllTypeSpecifierWithPrefixes() []ITypeSpecifierWithPrefixesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeSpecifierWithPrefixesContext)(nil)).Elem())
	var tst = make([]ITypeSpecifierWithPrefixesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeSpecifierWithPrefixesContext)
		}
	}

	return tst
}

func (s *GenericsSpecifierContext) TypeSpecifierWithPrefixes(i int) ITypeSpecifierWithPrefixesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSpecifierWithPrefixesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierWithPrefixesContext)
}

func (s *GenericsSpecifierContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *GenericsSpecifierContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *GenericsSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericsSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericsSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterGenericsSpecifier(s)
	}
}

func (s *GenericsSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitGenericsSpecifier(s)
	}
}

func (p *ObjectiveCParser) GenericsSpecifier() (localctx IGenericsSpecifierContext) {
	this := p
	_ = this

	localctx = NewGenericsSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ObjectiveCParserRULE_genericsSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(648)
		p.Match(ObjectiveCParserLT)
	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-81))|(1<<(ObjectiveCParserTYPEOF-81))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserWEAK_QUALIFIER-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
		{
			p.SetState(649)
			p.TypeSpecifierWithPrefixes()
		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ObjectiveCParserCOMMA {
			{
				p.SetState(650)
				p.Match(ObjectiveCParserCOMMA)
			}
			{
				p.SetState(651)
				p.TypeSpecifierWithPrefixes()
			}

			p.SetState(656)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(659)
		p.Match(ObjectiveCParserGT)
	}

	return localctx
}

// ITypeSpecifierWithPrefixesContext is an interface to support dynamic dispatch.
type ITypeSpecifierWithPrefixesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeSpecifierWithPrefixesContext differentiates from other interfaces.
	IsTypeSpecifierWithPrefixesContext()
}

type TypeSpecifierWithPrefixesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSpecifierWithPrefixesContext() *TypeSpecifierWithPrefixesContext {
	var p = new(TypeSpecifierWithPrefixesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_typeSpecifierWithPrefixes
	return p
}

func (*TypeSpecifierWithPrefixesContext) IsTypeSpecifierWithPrefixesContext() {}

func NewTypeSpecifierWithPrefixesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSpecifierWithPrefixesContext {
	var p = new(TypeSpecifierWithPrefixesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_typeSpecifierWithPrefixes

	return p
}

func (s *TypeSpecifierWithPrefixesContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSpecifierWithPrefixesContext) TypeSpecifier() ITypeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *TypeSpecifierWithPrefixesContext) AllTypePrefix() []ITypePrefixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypePrefixContext)(nil)).Elem())
	var tst = make([]ITypePrefixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypePrefixContext)
		}
	}

	return tst
}

func (s *TypeSpecifierWithPrefixesContext) TypePrefix(i int) ITypePrefixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypePrefixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypePrefixContext)
}

func (s *TypeSpecifierWithPrefixesContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeSpecifierWithPrefixesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSpecifierWithPrefixesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSpecifierWithPrefixesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterTypeSpecifierWithPrefixes(s)
	}
}

func (s *TypeSpecifierWithPrefixesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitTypeSpecifierWithPrefixes(s)
	}
}

func (p *ObjectiveCParser) TypeSpecifierWithPrefixes() (localctx ITypeSpecifierWithPrefixesContext) {
	this := p
	_ = this

	localctx = NewTypeSpecifierWithPrefixesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ObjectiveCParserRULE_typeSpecifierWithPrefixes)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(669)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(664)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(661)
					p.TypePrefix()
				}

			}
			p.SetState(666)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())
		}
		{
			p.SetState(667)
			p.TypeSpecifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(668)
			p.TypeName()
		}

	}

	return localctx
}

// IDictionaryExpressionContext is an interface to support dynamic dispatch.
type IDictionaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryExpressionContext differentiates from other interfaces.
	IsDictionaryExpressionContext()
}

type DictionaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryExpressionContext() *DictionaryExpressionContext {
	var p = new(DictionaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_dictionaryExpression
	return p
}

func (*DictionaryExpressionContext) IsDictionaryExpressionContext() {}

func NewDictionaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryExpressionContext {
	var p = new(DictionaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_dictionaryExpression

	return p
}

func (s *DictionaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryExpressionContext) AT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserAT, 0)
}

func (s *DictionaryExpressionContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACE, 0)
}

func (s *DictionaryExpressionContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACE, 0)
}

func (s *DictionaryExpressionContext) AllDictionaryPair() []IDictionaryPairContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDictionaryPairContext)(nil)).Elem())
	var tst = make([]IDictionaryPairContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDictionaryPairContext)
		}
	}

	return tst
}

func (s *DictionaryExpressionContext) DictionaryPair(i int) IDictionaryPairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryPairContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDictionaryPairContext)
}

func (s *DictionaryExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *DictionaryExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *DictionaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterDictionaryExpression(s)
	}
}

func (s *DictionaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitDictionaryExpression(s)
	}
}

func (p *ObjectiveCParser) DictionaryExpression() (localctx IDictionaryExpressionContext) {
	this := p
	_ = this

	localctx = NewDictionaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ObjectiveCParserRULE_dictionaryExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(671)
		p.Match(ObjectiveCParserAT)
	}
	{
		p.SetState(672)
		p.Match(ObjectiveCParserLBRACE)
	}
	p.SetState(684)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-25)&-(0x1f+1)) == 0 && ((1<<uint((_la-25)))&((1<<(ObjectiveCParserSIZEOF-25))|(1<<(ObjectiveCParserTRUE-25))|(1<<(ObjectiveCParserFALSE-25))|(1<<(ObjectiveCParserBOOL-25))|(1<<(ObjectiveCParserClass-25))|(1<<(ObjectiveCParserBYCOPY-25))|(1<<(ObjectiveCParserBYREF-25))|(1<<(ObjectiveCParserID-25))|(1<<(ObjectiveCParserIMP-25))|(1<<(ObjectiveCParserIN-25))|(1<<(ObjectiveCParserINOUT-25))|(1<<(ObjectiveCParserNIL-25))|(1<<(ObjectiveCParserNO-25))|(1<<(ObjectiveCParserNULL_-25))|(1<<(ObjectiveCParserONEWAY-25))|(1<<(ObjectiveCParserOUT-25))|(1<<(ObjectiveCParserPROTOCOL_-25))|(1<<(ObjectiveCParserSEL-25))|(1<<(ObjectiveCParserSELF-25))|(1<<(ObjectiveCParserSUPER-25)))) != 0) || (((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(ObjectiveCParserYES-57))|(1<<(ObjectiveCParserENCODE-57))|(1<<(ObjectiveCParserPROTOCOL-57))|(1<<(ObjectiveCParserSELECTOR-57))|(1<<(ObjectiveCParserATOMIC-57))|(1<<(ObjectiveCParserNONATOMIC-57))|(1<<(ObjectiveCParserRETAIN-57))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-57))|(1<<(ObjectiveCParserBLOCK-57))|(1<<(ObjectiveCParserBRIDGE_RETAINED-57)))) != 0) || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(ObjectiveCParserBRIDGE_TRANSFER-89))|(1<<(ObjectiveCParserCOVARIANT-89))|(1<<(ObjectiveCParserCONTRAVARIANT-89))|(1<<(ObjectiveCParserDEPRECATED-89))|(1<<(ObjectiveCParserKINDOF-89))|(1<<(ObjectiveCParserUNUSED-89))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-89))|(1<<(ObjectiveCParserNULLABLE-89))|(1<<(ObjectiveCParserNONNULL-89))|(1<<(ObjectiveCParserNULL_RESETTABLE-89))|(1<<(ObjectiveCParserNS_INLINE-89))|(1<<(ObjectiveCParserNS_ENUM-89))|(1<<(ObjectiveCParserNS_OPTIONS-89))|(1<<(ObjectiveCParserASSIGN-89))|(1<<(ObjectiveCParserCOPY-89))|(1<<(ObjectiveCParserGETTER-89))|(1<<(ObjectiveCParserSETTER-89))|(1<<(ObjectiveCParserSTRONG-89))|(1<<(ObjectiveCParserREADONLY-89))|(1<<(ObjectiveCParserREADWRITE-89))|(1<<(ObjectiveCParserWEAK-89))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-89))|(1<<(ObjectiveCParserIB_OUTLET-89))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-89))|(1<<(ObjectiveCParserIB_INSPECTABLE-89))|(1<<(ObjectiveCParserIB_DESIGNABLE-89)))) != 0) || (((_la-125)&-(0x1f+1)) == 0 && ((1<<uint((_la-125)))&((1<<(ObjectiveCParserIDENTIFIER-125))|(1<<(ObjectiveCParserLP-125))|(1<<(ObjectiveCParserLBRACK-125))|(1<<(ObjectiveCParserAT-125))|(1<<(ObjectiveCParserBANG-125))|(1<<(ObjectiveCParserTILDE-125))|(1<<(ObjectiveCParserINC-125))|(1<<(ObjectiveCParserDEC-125))|(1<<(ObjectiveCParserADD-125))|(1<<(ObjectiveCParserSUB-125))|(1<<(ObjectiveCParserMUL-125))|(1<<(ObjectiveCParserBITAND-125)))) != 0) || (((_la-158)&-(0x1f+1)) == 0 && ((1<<uint((_la-158)))&((1<<(ObjectiveCParserBITXOR-158))|(1<<(ObjectiveCParserCHARACTER_LITERAL-158))|(1<<(ObjectiveCParserSTRING_START-158))|(1<<(ObjectiveCParserHEX_LITERAL-158))|(1<<(ObjectiveCParserOCTAL_LITERAL-158))|(1<<(ObjectiveCParserBINARY_LITERAL-158))|(1<<(ObjectiveCParserDECIMAL_LITERAL-158))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-158)))) != 0) {
		{
			p.SetState(673)
			p.DictionaryPair()
		}
		p.SetState(678)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(674)
					p.Match(ObjectiveCParserCOMMA)
				}
				{
					p.SetState(675)
					p.DictionaryPair()
				}

			}
			p.SetState(680)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext())
		}
		p.SetState(682)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ObjectiveCParserCOMMA {
			{
				p.SetState(681)
				p.Match(ObjectiveCParserCOMMA)
			}

		}

	}
	{
		p.SetState(686)
		p.Match(ObjectiveCParserRBRACE)
	}

	return localctx
}

// IDictionaryPairContext is an interface to support dynamic dispatch.
type IDictionaryPairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryPairContext differentiates from other interfaces.
	IsDictionaryPairContext()
}

type DictionaryPairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryPairContext() *DictionaryPairContext {
	var p = new(DictionaryPairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_dictionaryPair
	return p
}

func (*DictionaryPairContext) IsDictionaryPairContext() {}

func NewDictionaryPairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryPairContext {
	var p = new(DictionaryPairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_dictionaryPair

	return p
}

func (s *DictionaryPairContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryPairContext) CastExpression() ICastExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *DictionaryPairContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOLON, 0)
}

func (s *DictionaryPairContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DictionaryPairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryPairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryPairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterDictionaryPair(s)
	}
}

func (s *DictionaryPairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitDictionaryPair(s)
	}
}

func (p *ObjectiveCParser) DictionaryPair() (localctx IDictionaryPairContext) {
	this := p
	_ = this

	localctx = NewDictionaryPairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ObjectiveCParserRULE_dictionaryPair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(688)
		p.CastExpression()
	}
	{
		p.SetState(689)
		p.Match(ObjectiveCParserCOLON)
	}
	{
		p.SetState(690)
		p.expression(0)
	}

	return localctx
}

// IArrayExpressionContext is an interface to support dynamic dispatch.
type IArrayExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayExpressionContext differentiates from other interfaces.
	IsArrayExpressionContext()
}

type ArrayExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayExpressionContext() *ArrayExpressionContext {
	var p = new(ArrayExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_arrayExpression
	return p
}

func (*ArrayExpressionContext) IsArrayExpressionContext() {}

func NewArrayExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayExpressionContext {
	var p = new(ArrayExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_arrayExpression

	return p
}

func (s *ArrayExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayExpressionContext) AT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserAT, 0)
}

func (s *ArrayExpressionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACK, 0)
}

func (s *ArrayExpressionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACK, 0)
}

func (s *ArrayExpressionContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *ArrayExpressionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, 0)
}

func (s *ArrayExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterArrayExpression(s)
	}
}

func (s *ArrayExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitArrayExpression(s)
	}
}

func (p *ObjectiveCParser) ArrayExpression() (localctx IArrayExpressionContext) {
	this := p
	_ = this

	localctx = NewArrayExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ObjectiveCParserRULE_arrayExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(692)
		p.Match(ObjectiveCParserAT)
	}
	{
		p.SetState(693)
		p.Match(ObjectiveCParserLBRACK)
	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-25)&-(0x1f+1)) == 0 && ((1<<uint((_la-25)))&((1<<(ObjectiveCParserSIZEOF-25))|(1<<(ObjectiveCParserTRUE-25))|(1<<(ObjectiveCParserFALSE-25))|(1<<(ObjectiveCParserBOOL-25))|(1<<(ObjectiveCParserClass-25))|(1<<(ObjectiveCParserBYCOPY-25))|(1<<(ObjectiveCParserBYREF-25))|(1<<(ObjectiveCParserID-25))|(1<<(ObjectiveCParserIMP-25))|(1<<(ObjectiveCParserIN-25))|(1<<(ObjectiveCParserINOUT-25))|(1<<(ObjectiveCParserNIL-25))|(1<<(ObjectiveCParserNO-25))|(1<<(ObjectiveCParserNULL_-25))|(1<<(ObjectiveCParserONEWAY-25))|(1<<(ObjectiveCParserOUT-25))|(1<<(ObjectiveCParserPROTOCOL_-25))|(1<<(ObjectiveCParserSEL-25))|(1<<(ObjectiveCParserSELF-25))|(1<<(ObjectiveCParserSUPER-25)))) != 0) || (((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(ObjectiveCParserYES-57))|(1<<(ObjectiveCParserENCODE-57))|(1<<(ObjectiveCParserPROTOCOL-57))|(1<<(ObjectiveCParserSELECTOR-57))|(1<<(ObjectiveCParserATOMIC-57))|(1<<(ObjectiveCParserNONATOMIC-57))|(1<<(ObjectiveCParserRETAIN-57))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-57))|(1<<(ObjectiveCParserBLOCK-57))|(1<<(ObjectiveCParserBRIDGE_RETAINED-57)))) != 0) || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(ObjectiveCParserBRIDGE_TRANSFER-89))|(1<<(ObjectiveCParserCOVARIANT-89))|(1<<(ObjectiveCParserCONTRAVARIANT-89))|(1<<(ObjectiveCParserDEPRECATED-89))|(1<<(ObjectiveCParserKINDOF-89))|(1<<(ObjectiveCParserUNUSED-89))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-89))|(1<<(ObjectiveCParserNULLABLE-89))|(1<<(ObjectiveCParserNONNULL-89))|(1<<(ObjectiveCParserNULL_RESETTABLE-89))|(1<<(ObjectiveCParserNS_INLINE-89))|(1<<(ObjectiveCParserNS_ENUM-89))|(1<<(ObjectiveCParserNS_OPTIONS-89))|(1<<(ObjectiveCParserASSIGN-89))|(1<<(ObjectiveCParserCOPY-89))|(1<<(ObjectiveCParserGETTER-89))|(1<<(ObjectiveCParserSETTER-89))|(1<<(ObjectiveCParserSTRONG-89))|(1<<(ObjectiveCParserREADONLY-89))|(1<<(ObjectiveCParserREADWRITE-89))|(1<<(ObjectiveCParserWEAK-89))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-89))|(1<<(ObjectiveCParserIB_OUTLET-89))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-89))|(1<<(ObjectiveCParserIB_INSPECTABLE-89))|(1<<(ObjectiveCParserIB_DESIGNABLE-89)))) != 0) || (((_la-125)&-(0x1f+1)) == 0 && ((1<<uint((_la-125)))&((1<<(ObjectiveCParserIDENTIFIER-125))|(1<<(ObjectiveCParserLP-125))|(1<<(ObjectiveCParserLBRACK-125))|(1<<(ObjectiveCParserAT-125))|(1<<(ObjectiveCParserBANG-125))|(1<<(ObjectiveCParserTILDE-125))|(1<<(ObjectiveCParserINC-125))|(1<<(ObjectiveCParserDEC-125))|(1<<(ObjectiveCParserADD-125))|(1<<(ObjectiveCParserSUB-125))|(1<<(ObjectiveCParserMUL-125))|(1<<(ObjectiveCParserBITAND-125)))) != 0) || (((_la-158)&-(0x1f+1)) == 0 && ((1<<uint((_la-158)))&((1<<(ObjectiveCParserBITXOR-158))|(1<<(ObjectiveCParserCHARACTER_LITERAL-158))|(1<<(ObjectiveCParserSTRING_START-158))|(1<<(ObjectiveCParserHEX_LITERAL-158))|(1<<(ObjectiveCParserOCTAL_LITERAL-158))|(1<<(ObjectiveCParserBINARY_LITERAL-158))|(1<<(ObjectiveCParserDECIMAL_LITERAL-158))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-158)))) != 0) {
		{
			p.SetState(694)
			p.Expressions()
		}
		p.SetState(696)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ObjectiveCParserCOMMA {
			{
				p.SetState(695)
				p.Match(ObjectiveCParserCOMMA)
			}

		}

	}
	{
		p.SetState(700)
		p.Match(ObjectiveCParserRBRACK)
	}

	return localctx
}

// IBoxExpressionContext is an interface to support dynamic dispatch.
type IBoxExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBoxExpressionContext differentiates from other interfaces.
	IsBoxExpressionContext()
}

type BoxExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoxExpressionContext() *BoxExpressionContext {
	var p = new(BoxExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_boxExpression
	return p
}

func (*BoxExpressionContext) IsBoxExpressionContext() {}

func NewBoxExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoxExpressionContext {
	var p = new(BoxExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_boxExpression

	return p
}

func (s *BoxExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BoxExpressionContext) AT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserAT, 0)
}

func (s *BoxExpressionContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *BoxExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BoxExpressionContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *BoxExpressionContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *BoxExpressionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BoxExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoxExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BoxExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterBoxExpression(s)
	}
}

func (s *BoxExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitBoxExpression(s)
	}
}

func (p *ObjectiveCParser) BoxExpression() (localctx IBoxExpressionContext) {
	this := p
	_ = this

	localctx = NewBoxExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ObjectiveCParserRULE_boxExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(712)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(702)
			p.Match(ObjectiveCParserAT)
		}
		{
			p.SetState(703)
			p.Match(ObjectiveCParserLP)
		}
		{
			p.SetState(704)
			p.expression(0)
		}
		{
			p.SetState(705)
			p.Match(ObjectiveCParserRP)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(707)
			p.Match(ObjectiveCParserAT)
		}
		p.SetState(710)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ObjectiveCParserTRUE, ObjectiveCParserFALSE, ObjectiveCParserNIL, ObjectiveCParserNO, ObjectiveCParserNULL_, ObjectiveCParserYES, ObjectiveCParserADD, ObjectiveCParserSUB, ObjectiveCParserCHARACTER_LITERAL, ObjectiveCParserHEX_LITERAL, ObjectiveCParserOCTAL_LITERAL, ObjectiveCParserBINARY_LITERAL, ObjectiveCParserDECIMAL_LITERAL, ObjectiveCParserFLOATING_POINT_LITERAL:
			{
				p.SetState(708)
				p.Constant()
			}

		case ObjectiveCParserBOOL, ObjectiveCParserClass, ObjectiveCParserBYCOPY, ObjectiveCParserBYREF, ObjectiveCParserID, ObjectiveCParserIMP, ObjectiveCParserIN, ObjectiveCParserINOUT, ObjectiveCParserONEWAY, ObjectiveCParserOUT, ObjectiveCParserPROTOCOL_, ObjectiveCParserSEL, ObjectiveCParserSELF, ObjectiveCParserSUPER, ObjectiveCParserATOMIC, ObjectiveCParserNONATOMIC, ObjectiveCParserRETAIN, ObjectiveCParserAUTORELEASING_QUALIFIER, ObjectiveCParserBLOCK, ObjectiveCParserBRIDGE_RETAINED, ObjectiveCParserBRIDGE_TRANSFER, ObjectiveCParserCOVARIANT, ObjectiveCParserCONTRAVARIANT, ObjectiveCParserDEPRECATED, ObjectiveCParserKINDOF, ObjectiveCParserUNUSED, ObjectiveCParserNULL_UNSPECIFIED, ObjectiveCParserNULLABLE, ObjectiveCParserNONNULL, ObjectiveCParserNULL_RESETTABLE, ObjectiveCParserNS_INLINE, ObjectiveCParserNS_ENUM, ObjectiveCParserNS_OPTIONS, ObjectiveCParserASSIGN, ObjectiveCParserCOPY, ObjectiveCParserGETTER, ObjectiveCParserSETTER, ObjectiveCParserSTRONG, ObjectiveCParserREADONLY, ObjectiveCParserREADWRITE, ObjectiveCParserWEAK, ObjectiveCParserUNSAFE_UNRETAINED, ObjectiveCParserIB_OUTLET, ObjectiveCParserIB_OUTLET_COLLECTION, ObjectiveCParserIB_INSPECTABLE, ObjectiveCParserIB_DESIGNABLE, ObjectiveCParserIDENTIFIER:
			{
				p.SetState(709)
				p.Identifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IBlockParametersContext is an interface to support dynamic dispatch.
type IBlockParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockParametersContext differentiates from other interfaces.
	IsBlockParametersContext()
}

type BlockParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockParametersContext() *BlockParametersContext {
	var p = new(BlockParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_blockParameters
	return p
}

func (*BlockParametersContext) IsBlockParametersContext() {}

func NewBlockParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockParametersContext {
	var p = new(BlockParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_blockParameters

	return p
}

func (s *BlockParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockParametersContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *BlockParametersContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *BlockParametersContext) AllTypeVariableDeclaratorOrName() []ITypeVariableDeclaratorOrNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeVariableDeclaratorOrNameContext)(nil)).Elem())
	var tst = make([]ITypeVariableDeclaratorOrNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeVariableDeclaratorOrNameContext)
		}
	}

	return tst
}

func (s *BlockParametersContext) TypeVariableDeclaratorOrName(i int) ITypeVariableDeclaratorOrNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeVariableDeclaratorOrNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeVariableDeclaratorOrNameContext)
}

func (s *BlockParametersContext) VOID() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserVOID, 0)
}

func (s *BlockParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *BlockParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *BlockParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterBlockParameters(s)
	}
}

func (s *BlockParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitBlockParameters(s)
	}
}

func (p *ObjectiveCParser) BlockParameters() (localctx IBlockParametersContext) {
	this := p
	_ = this

	localctx = NewBlockParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ObjectiveCParserRULE_blockParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(714)
		p.Match(ObjectiveCParserLP)
	}
	p.SetState(726)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserAUTO)|(1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserEXTERN)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserREGISTER)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSTATIC)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserATTRIBUTE-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-81))|(1<<(ObjectiveCParserTYPEOF-81))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserWEAK_QUALIFIER-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(715)
				p.TypeVariableDeclaratorOrName()
			}

		case 2:
			{
				p.SetState(716)
				p.Match(ObjectiveCParserVOID)
			}

		}
		p.SetState(723)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ObjectiveCParserCOMMA {
			{
				p.SetState(719)
				p.Match(ObjectiveCParserCOMMA)
			}
			{
				p.SetState(720)
				p.TypeVariableDeclaratorOrName()
			}

			p.SetState(725)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(728)
		p.Match(ObjectiveCParserRP)
	}

	return localctx
}

// ITypeVariableDeclaratorOrNameContext is an interface to support dynamic dispatch.
type ITypeVariableDeclaratorOrNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeVariableDeclaratorOrNameContext differentiates from other interfaces.
	IsTypeVariableDeclaratorOrNameContext()
}

type TypeVariableDeclaratorOrNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeVariableDeclaratorOrNameContext() *TypeVariableDeclaratorOrNameContext {
	var p = new(TypeVariableDeclaratorOrNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_typeVariableDeclaratorOrName
	return p
}

func (*TypeVariableDeclaratorOrNameContext) IsTypeVariableDeclaratorOrNameContext() {}

func NewTypeVariableDeclaratorOrNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeVariableDeclaratorOrNameContext {
	var p = new(TypeVariableDeclaratorOrNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_typeVariableDeclaratorOrName

	return p
}

func (s *TypeVariableDeclaratorOrNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeVariableDeclaratorOrNameContext) TypeVariableDeclarator() ITypeVariableDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeVariableDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeVariableDeclaratorContext)
}

func (s *TypeVariableDeclaratorOrNameContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeVariableDeclaratorOrNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeVariableDeclaratorOrNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeVariableDeclaratorOrNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterTypeVariableDeclaratorOrName(s)
	}
}

func (s *TypeVariableDeclaratorOrNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitTypeVariableDeclaratorOrName(s)
	}
}

func (p *ObjectiveCParser) TypeVariableDeclaratorOrName() (localctx ITypeVariableDeclaratorOrNameContext) {
	this := p
	_ = this

	localctx = NewTypeVariableDeclaratorOrNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ObjectiveCParserRULE_typeVariableDeclaratorOrName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(730)
			p.TypeVariableDeclarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(731)
			p.TypeName()
		}

	}

	return localctx
}

// IBlockExpressionContext is an interface to support dynamic dispatch.
type IBlockExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockExpressionContext differentiates from other interfaces.
	IsBlockExpressionContext()
}

type BlockExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockExpressionContext() *BlockExpressionContext {
	var p = new(BlockExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_blockExpression
	return p
}

func (*BlockExpressionContext) IsBlockExpressionContext() {}

func NewBlockExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockExpressionContext {
	var p = new(BlockExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_blockExpression

	return p
}

func (s *BlockExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockExpressionContext) BITXOR() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBITXOR, 0)
}

func (s *BlockExpressionContext) CompoundStatement() ICompoundStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *BlockExpressionContext) TypeSpecifier() ITypeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *BlockExpressionContext) NullabilitySpecifier() INullabilitySpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullabilitySpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullabilitySpecifierContext)
}

func (s *BlockExpressionContext) BlockParameters() IBlockParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockParametersContext)
}

func (s *BlockExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterBlockExpression(s)
	}
}

func (s *BlockExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitBlockExpression(s)
	}
}

func (p *ObjectiveCParser) BlockExpression() (localctx IBlockExpressionContext) {
	this := p
	_ = this

	localctx = NewBlockExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ObjectiveCParserRULE_blockExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(734)
		p.Match(ObjectiveCParserBITXOR)
	}
	p.SetState(736)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(735)
			p.TypeSpecifier()
		}

	}
	p.SetState(739)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(ObjectiveCParserNULL_UNSPECIFIED-99))|(1<<(ObjectiveCParserNULLABLE-99))|(1<<(ObjectiveCParserNONNULL-99))|(1<<(ObjectiveCParserNULL_RESETTABLE-99)))) != 0 {
		{
			p.SetState(738)
			p.NullabilitySpecifier()
		}

	}
	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserLP {
		{
			p.SetState(741)
			p.BlockParameters()
		}

	}
	{
		p.SetState(744)
		p.CompoundStatement()
	}

	return localctx
}

// IMessageExpressionContext is an interface to support dynamic dispatch.
type IMessageExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessageExpressionContext differentiates from other interfaces.
	IsMessageExpressionContext()
}

type MessageExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessageExpressionContext() *MessageExpressionContext {
	var p = new(MessageExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_messageExpression
	return p
}

func (*MessageExpressionContext) IsMessageExpressionContext() {}

func NewMessageExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MessageExpressionContext {
	var p = new(MessageExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_messageExpression

	return p
}

func (s *MessageExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MessageExpressionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACK, 0)
}

func (s *MessageExpressionContext) Receiver() IReceiverContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiverContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiverContext)
}

func (s *MessageExpressionContext) MessageSelector() IMessageSelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessageSelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMessageSelectorContext)
}

func (s *MessageExpressionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACK, 0)
}

func (s *MessageExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MessageExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MessageExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterMessageExpression(s)
	}
}

func (s *MessageExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitMessageExpression(s)
	}
}

func (p *ObjectiveCParser) MessageExpression() (localctx IMessageExpressionContext) {
	this := p
	_ = this

	localctx = NewMessageExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ObjectiveCParserRULE_messageExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		p.Match(ObjectiveCParserLBRACK)
	}
	{
		p.SetState(747)
		p.Receiver()
	}
	{
		p.SetState(748)
		p.MessageSelector()
	}
	{
		p.SetState(749)
		p.Match(ObjectiveCParserRBRACK)
	}

	return localctx
}

// IReceiverContext is an interface to support dynamic dispatch.
type IReceiverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiverContext differentiates from other interfaces.
	IsReceiverContext()
}

type ReceiverContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverContext() *ReceiverContext {
	var p = new(ReceiverContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_receiver
	return p
}

func (*ReceiverContext) IsReceiverContext() {}

func NewReceiverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverContext {
	var p = new(ReceiverContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_receiver

	return p
}

func (s *ReceiverContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReceiverContext) TypeSpecifier() ITypeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *ReceiverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterReceiver(s)
	}
}

func (s *ReceiverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitReceiver(s)
	}
}

func (p *ObjectiveCParser) Receiver() (localctx IReceiverContext) {
	this := p
	_ = this

	localctx = NewReceiverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ObjectiveCParserRULE_receiver)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(751)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(752)
			p.TypeSpecifier()
		}

	}

	return localctx
}

// IMessageSelectorContext is an interface to support dynamic dispatch.
type IMessageSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessageSelectorContext differentiates from other interfaces.
	IsMessageSelectorContext()
}

type MessageSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessageSelectorContext() *MessageSelectorContext {
	var p = new(MessageSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_messageSelector
	return p
}

func (*MessageSelectorContext) IsMessageSelectorContext() {}

func NewMessageSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MessageSelectorContext {
	var p = new(MessageSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_messageSelector

	return p
}

func (s *MessageSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *MessageSelectorContext) Selector() ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *MessageSelectorContext) AllKeywordArgument() []IKeywordArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IKeywordArgumentContext)(nil)).Elem())
	var tst = make([]IKeywordArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IKeywordArgumentContext)
		}
	}

	return tst
}

func (s *MessageSelectorContext) KeywordArgument(i int) IKeywordArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IKeywordArgumentContext)
}

func (s *MessageSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MessageSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MessageSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterMessageSelector(s)
	}
}

func (s *MessageSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitMessageSelector(s)
	}
}

func (p *ObjectiveCParser) MessageSelector() (localctx IMessageSelectorContext) {
	this := p
	_ = this

	localctx = NewMessageSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ObjectiveCParserRULE_messageSelector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(761)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(755)
			p.Selector()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(757)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ObjectiveCParserRETURN || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113))|(1<<(ObjectiveCParserCOLON-113)))) != 0) {
			{
				p.SetState(756)
				p.KeywordArgument()
			}

			p.SetState(759)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IKeywordArgumentContext is an interface to support dynamic dispatch.
type IKeywordArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordArgumentContext differentiates from other interfaces.
	IsKeywordArgumentContext()
}

type KeywordArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordArgumentContext() *KeywordArgumentContext {
	var p = new(KeywordArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_keywordArgument
	return p
}

func (*KeywordArgumentContext) IsKeywordArgumentContext() {}

func NewKeywordArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordArgumentContext {
	var p = new(KeywordArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_keywordArgument

	return p
}

func (s *KeywordArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordArgumentContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOLON, 0)
}

func (s *KeywordArgumentContext) AllKeywordArgumentType() []IKeywordArgumentTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IKeywordArgumentTypeContext)(nil)).Elem())
	var tst = make([]IKeywordArgumentTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IKeywordArgumentTypeContext)
		}
	}

	return tst
}

func (s *KeywordArgumentContext) KeywordArgumentType(i int) IKeywordArgumentTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordArgumentTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IKeywordArgumentTypeContext)
}

func (s *KeywordArgumentContext) Selector() ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *KeywordArgumentContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *KeywordArgumentContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *KeywordArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterKeywordArgument(s)
	}
}

func (s *KeywordArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitKeywordArgument(s)
	}
}

func (p *ObjectiveCParser) KeywordArgument() (localctx IKeywordArgumentContext) {
	this := p
	_ = this

	localctx = NewKeywordArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ObjectiveCParserRULE_keywordArgument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserRETURN || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
		{
			p.SetState(763)
			p.Selector()
		}

	}
	{
		p.SetState(766)
		p.Match(ObjectiveCParserCOLON)
	}
	{
		p.SetState(767)
		p.KeywordArgumentType()
	}
	p.SetState(772)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ObjectiveCParserCOMMA {
		{
			p.SetState(768)
			p.Match(ObjectiveCParserCOMMA)
		}
		{
			p.SetState(769)
			p.KeywordArgumentType()
		}

		p.SetState(774)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IKeywordArgumentTypeContext is an interface to support dynamic dispatch.
type IKeywordArgumentTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordArgumentTypeContext differentiates from other interfaces.
	IsKeywordArgumentTypeContext()
}

type KeywordArgumentTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordArgumentTypeContext() *KeywordArgumentTypeContext {
	var p = new(KeywordArgumentTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_keywordArgumentType
	return p
}

func (*KeywordArgumentTypeContext) IsKeywordArgumentTypeContext() {}

func NewKeywordArgumentTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordArgumentTypeContext {
	var p = new(KeywordArgumentTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_keywordArgumentType

	return p
}

func (s *KeywordArgumentTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordArgumentTypeContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *KeywordArgumentTypeContext) NullabilitySpecifier() INullabilitySpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullabilitySpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullabilitySpecifierContext)
}

func (s *KeywordArgumentTypeContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACE, 0)
}

func (s *KeywordArgumentTypeContext) InitializerList() IInitializerListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializerListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializerListContext)
}

func (s *KeywordArgumentTypeContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACE, 0)
}

func (s *KeywordArgumentTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordArgumentTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordArgumentTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterKeywordArgumentType(s)
	}
}

func (s *KeywordArgumentTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitKeywordArgumentType(s)
	}
}

func (p *ObjectiveCParser) KeywordArgumentType() (localctx IKeywordArgumentTypeContext) {
	this := p
	_ = this

	localctx = NewKeywordArgumentTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ObjectiveCParserRULE_keywordArgumentType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.Expressions()
	}
	p.SetState(777)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(776)
			p.NullabilitySpecifier()
		}

	}
	p.SetState(783)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserLBRACE {
		{
			p.SetState(779)
			p.Match(ObjectiveCParserLBRACE)
		}
		{
			p.SetState(780)
			p.InitializerList()
		}
		{
			p.SetState(781)
			p.Match(ObjectiveCParserRBRACE)
		}

	}

	return localctx
}

// ISelectorExpressionContext is an interface to support dynamic dispatch.
type ISelectorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectorExpressionContext differentiates from other interfaces.
	IsSelectorExpressionContext()
}

type SelectorExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectorExpressionContext() *SelectorExpressionContext {
	var p = new(SelectorExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_selectorExpression
	return p
}

func (*SelectorExpressionContext) IsSelectorExpressionContext() {}

func NewSelectorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectorExpressionContext {
	var p = new(SelectorExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_selectorExpression

	return p
}

func (s *SelectorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectorExpressionContext) SELECTOR() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSELECTOR, 0)
}

func (s *SelectorExpressionContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *SelectorExpressionContext) SelectorName() ISelectorNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorNameContext)
}

func (s *SelectorExpressionContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *SelectorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterSelectorExpression(s)
	}
}

func (s *SelectorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitSelectorExpression(s)
	}
}

func (p *ObjectiveCParser) SelectorExpression() (localctx ISelectorExpressionContext) {
	this := p
	_ = this

	localctx = NewSelectorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ObjectiveCParserRULE_selectorExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(785)
		p.Match(ObjectiveCParserSELECTOR)
	}
	{
		p.SetState(786)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(787)
		p.SelectorName()
	}
	{
		p.SetState(788)
		p.Match(ObjectiveCParserRP)
	}

	return localctx
}

// ISelectorNameContext is an interface to support dynamic dispatch.
type ISelectorNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectorNameContext differentiates from other interfaces.
	IsSelectorNameContext()
}

type SelectorNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectorNameContext() *SelectorNameContext {
	var p = new(SelectorNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_selectorName
	return p
}

func (*SelectorNameContext) IsSelectorNameContext() {}

func NewSelectorNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectorNameContext {
	var p = new(SelectorNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_selectorName

	return p
}

func (s *SelectorNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectorNameContext) AllSelector() []ISelectorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectorContext)(nil)).Elem())
	var tst = make([]ISelectorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectorContext)
		}
	}

	return tst
}

func (s *SelectorNameContext) Selector(i int) ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *SelectorNameContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOLON)
}

func (s *SelectorNameContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOLON, i)
}

func (s *SelectorNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectorNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectorNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterSelectorName(s)
	}
}

func (s *SelectorNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitSelectorName(s)
	}
}

func (p *ObjectiveCParser) SelectorName() (localctx ISelectorNameContext) {
	this := p
	_ = this

	localctx = NewSelectorNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ObjectiveCParserRULE_selectorName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(799)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(790)
			p.Selector()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(795)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ObjectiveCParserRETURN || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113))|(1<<(ObjectiveCParserCOLON-113)))) != 0) {
			p.SetState(792)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ObjectiveCParserRETURN || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
				{
					p.SetState(791)
					p.Selector()
				}

			}
			{
				p.SetState(794)
				p.Match(ObjectiveCParserCOLON)
			}

			p.SetState(797)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IProtocolExpressionContext is an interface to support dynamic dispatch.
type IProtocolExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocolExpressionContext differentiates from other interfaces.
	IsProtocolExpressionContext()
}

type ProtocolExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocolExpressionContext() *ProtocolExpressionContext {
	var p = new(ProtocolExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_protocolExpression
	return p
}

func (*ProtocolExpressionContext) IsProtocolExpressionContext() {}

func NewProtocolExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProtocolExpressionContext {
	var p = new(ProtocolExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_protocolExpression

	return p
}

func (s *ProtocolExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProtocolExpressionContext) PROTOCOL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserPROTOCOL, 0)
}

func (s *ProtocolExpressionContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *ProtocolExpressionContext) ProtocolName() IProtocolNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolNameContext)
}

func (s *ProtocolExpressionContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *ProtocolExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProtocolExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProtocolExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterProtocolExpression(s)
	}
}

func (s *ProtocolExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitProtocolExpression(s)
	}
}

func (p *ObjectiveCParser) ProtocolExpression() (localctx IProtocolExpressionContext) {
	this := p
	_ = this

	localctx = NewProtocolExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ObjectiveCParserRULE_protocolExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(801)
		p.Match(ObjectiveCParserPROTOCOL)
	}
	{
		p.SetState(802)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(803)
		p.ProtocolName()
	}
	{
		p.SetState(804)
		p.Match(ObjectiveCParserRP)
	}

	return localctx
}

// IEncodeExpressionContext is an interface to support dynamic dispatch.
type IEncodeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncodeExpressionContext differentiates from other interfaces.
	IsEncodeExpressionContext()
}

type EncodeExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncodeExpressionContext() *EncodeExpressionContext {
	var p = new(EncodeExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_encodeExpression
	return p
}

func (*EncodeExpressionContext) IsEncodeExpressionContext() {}

func NewEncodeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EncodeExpressionContext {
	var p = new(EncodeExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_encodeExpression

	return p
}

func (s *EncodeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *EncodeExpressionContext) ENCODE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserENCODE, 0)
}

func (s *EncodeExpressionContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *EncodeExpressionContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *EncodeExpressionContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *EncodeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncodeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EncodeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterEncodeExpression(s)
	}
}

func (s *EncodeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitEncodeExpression(s)
	}
}

func (p *ObjectiveCParser) EncodeExpression() (localctx IEncodeExpressionContext) {
	this := p
	_ = this

	localctx = NewEncodeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ObjectiveCParserRULE_encodeExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(806)
		p.Match(ObjectiveCParserENCODE)
	}
	{
		p.SetState(807)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(808)
		p.TypeName()
	}
	{
		p.SetState(809)
		p.Match(ObjectiveCParserRP)
	}

	return localctx
}

// ITypeVariableDeclaratorContext is an interface to support dynamic dispatch.
type ITypeVariableDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeVariableDeclaratorContext differentiates from other interfaces.
	IsTypeVariableDeclaratorContext()
}

type TypeVariableDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeVariableDeclaratorContext() *TypeVariableDeclaratorContext {
	var p = new(TypeVariableDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_typeVariableDeclarator
	return p
}

func (*TypeVariableDeclaratorContext) IsTypeVariableDeclaratorContext() {}

func NewTypeVariableDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeVariableDeclaratorContext {
	var p = new(TypeVariableDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_typeVariableDeclarator

	return p
}

func (s *TypeVariableDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeVariableDeclaratorContext) DeclarationSpecifiers() IDeclarationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifiersContext)
}

func (s *TypeVariableDeclaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *TypeVariableDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeVariableDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeVariableDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterTypeVariableDeclarator(s)
	}
}

func (s *TypeVariableDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitTypeVariableDeclarator(s)
	}
}

func (p *ObjectiveCParser) TypeVariableDeclarator() (localctx ITypeVariableDeclaratorContext) {
	this := p
	_ = this

	localctx = NewTypeVariableDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ObjectiveCParserRULE_typeVariableDeclarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(811)
		p.DeclarationSpecifiers()
	}
	{
		p.SetState(812)
		p.Declarator()
	}

	return localctx
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_throwStatement
	return p
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) THROW() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserTHROW, 0)
}

func (s *ThrowStatementContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *ThrowStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ThrowStatementContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *ThrowStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterThrowStatement(s)
	}
}

func (s *ThrowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitThrowStatement(s)
	}
}

func (p *ObjectiveCParser) ThrowStatement() (localctx IThrowStatementContext) {
	this := p
	_ = this

	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ObjectiveCParserRULE_throwStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(814)
			p.Match(ObjectiveCParserTHROW)
		}
		{
			p.SetState(815)
			p.Match(ObjectiveCParserLP)
		}
		{
			p.SetState(816)
			p.Identifier()
		}
		{
			p.SetState(817)
			p.Match(ObjectiveCParserRP)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(819)
			p.Match(ObjectiveCParserTHROW)
		}
		{
			p.SetState(820)
			p.expression(0)
		}

	}

	return localctx
}

// ITryBlockContext is an interface to support dynamic dispatch.
type ITryBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTryStatement returns the tryStatement rule contexts.
	GetTryStatement() ICompoundStatementContext

	// GetFinallyStatement returns the finallyStatement rule contexts.
	GetFinallyStatement() ICompoundStatementContext

	// SetTryStatement sets the tryStatement rule contexts.
	SetTryStatement(ICompoundStatementContext)

	// SetFinallyStatement sets the finallyStatement rule contexts.
	SetFinallyStatement(ICompoundStatementContext)

	// IsTryBlockContext differentiates from other interfaces.
	IsTryBlockContext()
}

type TryBlockContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	tryStatement     ICompoundStatementContext
	finallyStatement ICompoundStatementContext
}

func NewEmptyTryBlockContext() *TryBlockContext {
	var p = new(TryBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_tryBlock
	return p
}

func (*TryBlockContext) IsTryBlockContext() {}

func NewTryBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryBlockContext {
	var p = new(TryBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_tryBlock

	return p
}

func (s *TryBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *TryBlockContext) GetTryStatement() ICompoundStatementContext { return s.tryStatement }

func (s *TryBlockContext) GetFinallyStatement() ICompoundStatementContext { return s.finallyStatement }

func (s *TryBlockContext) SetTryStatement(v ICompoundStatementContext) { s.tryStatement = v }

func (s *TryBlockContext) SetFinallyStatement(v ICompoundStatementContext) { s.finallyStatement = v }

func (s *TryBlockContext) TRY() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserTRY, 0)
}

func (s *TryBlockContext) AllCompoundStatement() []ICompoundStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICompoundStatementContext)(nil)).Elem())
	var tst = make([]ICompoundStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICompoundStatementContext)
		}
	}

	return tst
}

func (s *TryBlockContext) CompoundStatement(i int) ICompoundStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *TryBlockContext) AllCatchStatement() []ICatchStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICatchStatementContext)(nil)).Elem())
	var tst = make([]ICatchStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICatchStatementContext)
		}
	}

	return tst
}

func (s *TryBlockContext) CatchStatement(i int) ICatchStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICatchStatementContext)
}

func (s *TryBlockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserFINALLY, 0)
}

func (s *TryBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterTryBlock(s)
	}
}

func (s *TryBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitTryBlock(s)
	}
}

func (p *ObjectiveCParser) TryBlock() (localctx ITryBlockContext) {
	this := p
	_ = this

	localctx = NewTryBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ObjectiveCParserRULE_tryBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(823)
		p.Match(ObjectiveCParserTRY)
	}
	{
		p.SetState(824)

		var _x = p.CompoundStatement()

		localctx.(*TryBlockContext).tryStatement = _x
	}
	p.SetState(828)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ObjectiveCParserCATCH {
		{
			p.SetState(825)
			p.CatchStatement()
		}

		p.SetState(830)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(833)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserFINALLY {
		{
			p.SetState(831)
			p.Match(ObjectiveCParserFINALLY)
		}
		{
			p.SetState(832)

			var _x = p.CompoundStatement()

			localctx.(*TryBlockContext).finallyStatement = _x
		}

	}

	return localctx
}

// ICatchStatementContext is an interface to support dynamic dispatch.
type ICatchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchStatementContext differentiates from other interfaces.
	IsCatchStatementContext()
}

type CatchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchStatementContext() *CatchStatementContext {
	var p = new(CatchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_catchStatement
	return p
}

func (*CatchStatementContext) IsCatchStatementContext() {}

func NewCatchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchStatementContext {
	var p = new(CatchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_catchStatement

	return p
}

func (s *CatchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchStatementContext) CATCH() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCATCH, 0)
}

func (s *CatchStatementContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *CatchStatementContext) TypeVariableDeclarator() ITypeVariableDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeVariableDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeVariableDeclaratorContext)
}

func (s *CatchStatementContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *CatchStatementContext) CompoundStatement() ICompoundStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *CatchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterCatchStatement(s)
	}
}

func (s *CatchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitCatchStatement(s)
	}
}

func (p *ObjectiveCParser) CatchStatement() (localctx ICatchStatementContext) {
	this := p
	_ = this

	localctx = NewCatchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ObjectiveCParserRULE_catchStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(835)
		p.Match(ObjectiveCParserCATCH)
	}
	{
		p.SetState(836)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(837)
		p.TypeVariableDeclarator()
	}
	{
		p.SetState(838)
		p.Match(ObjectiveCParserRP)
	}
	{
		p.SetState(839)
		p.CompoundStatement()
	}

	return localctx
}

// ISynchronizedStatementContext is an interface to support dynamic dispatch.
type ISynchronizedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSynchronizedStatementContext differentiates from other interfaces.
	IsSynchronizedStatementContext()
}

type SynchronizedStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySynchronizedStatementContext() *SynchronizedStatementContext {
	var p = new(SynchronizedStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_synchronizedStatement
	return p
}

func (*SynchronizedStatementContext) IsSynchronizedStatementContext() {}

func NewSynchronizedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SynchronizedStatementContext {
	var p = new(SynchronizedStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_synchronizedStatement

	return p
}

func (s *SynchronizedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SynchronizedStatementContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSYNCHRONIZED, 0)
}

func (s *SynchronizedStatementContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *SynchronizedStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SynchronizedStatementContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *SynchronizedStatementContext) CompoundStatement() ICompoundStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *SynchronizedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SynchronizedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SynchronizedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterSynchronizedStatement(s)
	}
}

func (s *SynchronizedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitSynchronizedStatement(s)
	}
}

func (p *ObjectiveCParser) SynchronizedStatement() (localctx ISynchronizedStatementContext) {
	this := p
	_ = this

	localctx = NewSynchronizedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ObjectiveCParserRULE_synchronizedStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(841)
		p.Match(ObjectiveCParserSYNCHRONIZED)
	}
	{
		p.SetState(842)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(843)
		p.expression(0)
	}
	{
		p.SetState(844)
		p.Match(ObjectiveCParserRP)
	}
	{
		p.SetState(845)
		p.CompoundStatement()
	}

	return localctx
}

// IAutoreleaseStatementContext is an interface to support dynamic dispatch.
type IAutoreleaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAutoreleaseStatementContext differentiates from other interfaces.
	IsAutoreleaseStatementContext()
}

type AutoreleaseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAutoreleaseStatementContext() *AutoreleaseStatementContext {
	var p = new(AutoreleaseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_autoreleaseStatement
	return p
}

func (*AutoreleaseStatementContext) IsAutoreleaseStatementContext() {}

func NewAutoreleaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AutoreleaseStatementContext {
	var p = new(AutoreleaseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_autoreleaseStatement

	return p
}

func (s *AutoreleaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AutoreleaseStatementContext) AUTORELEASEPOOL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserAUTORELEASEPOOL, 0)
}

func (s *AutoreleaseStatementContext) CompoundStatement() ICompoundStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *AutoreleaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AutoreleaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AutoreleaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterAutoreleaseStatement(s)
	}
}

func (s *AutoreleaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitAutoreleaseStatement(s)
	}
}

func (p *ObjectiveCParser) AutoreleaseStatement() (localctx IAutoreleaseStatementContext) {
	this := p
	_ = this

	localctx = NewAutoreleaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ObjectiveCParserRULE_autoreleaseStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(847)
		p.Match(ObjectiveCParserAUTORELEASEPOOL)
	}
	{
		p.SetState(848)
		p.CompoundStatement()
	}

	return localctx
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_functionDeclaration
	return p
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) FunctionSignature() IFunctionSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionSignatureContext)
}

func (s *FunctionDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, 0)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (p *ObjectiveCParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	this := p
	_ = this

	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ObjectiveCParserRULE_functionDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.FunctionSignature()
	}
	{
		p.SetState(851)
		p.Match(ObjectiveCParserSEMI)
	}

	return localctx
}

// IFunctionDefinitionContext is an interface to support dynamic dispatch.
type IFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDefinitionContext differentiates from other interfaces.
	IsFunctionDefinitionContext()
}

type FunctionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDefinitionContext() *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_functionDefinition
	return p
}

func (*FunctionDefinitionContext) IsFunctionDefinitionContext() {}

func NewFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_functionDefinition

	return p
}

func (s *FunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDefinitionContext) FunctionSignature() IFunctionSignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionSignatureContext)
}

func (s *FunctionDefinitionContext) CompoundStatement() ICompoundStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *FunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterFunctionDefinition(s)
	}
}

func (s *FunctionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitFunctionDefinition(s)
	}
}

func (p *ObjectiveCParser) FunctionDefinition() (localctx IFunctionDefinitionContext) {
	this := p
	_ = this

	localctx = NewFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ObjectiveCParserRULE_functionDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(853)
		p.FunctionSignature()
	}
	{
		p.SetState(854)
		p.CompoundStatement()
	}

	return localctx
}

// IFunctionSignatureContext is an interface to support dynamic dispatch.
type IFunctionSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionSignatureContext differentiates from other interfaces.
	IsFunctionSignatureContext()
}

type FunctionSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionSignatureContext() *FunctionSignatureContext {
	var p = new(FunctionSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_functionSignature
	return p
}

func (*FunctionSignatureContext) IsFunctionSignatureContext() {}

func NewFunctionSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionSignatureContext {
	var p = new(FunctionSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_functionSignature

	return p
}

func (s *FunctionSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionSignatureContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionSignatureContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *FunctionSignatureContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *FunctionSignatureContext) DeclarationSpecifiers() IDeclarationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifiersContext)
}

func (s *FunctionSignatureContext) AttributeSpecifier() IAttributeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierContext)
}

func (s *FunctionSignatureContext) ParameterList() IParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterFunctionSignature(s)
	}
}

func (s *FunctionSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitFunctionSignature(s)
	}
}

func (p *ObjectiveCParser) FunctionSignature() (localctx IFunctionSignatureContext) {
	this := p
	_ = this

	localctx = NewFunctionSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ObjectiveCParserRULE_functionSignature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(857)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(856)
			p.DeclarationSpecifiers()
		}

	}
	{
		p.SetState(859)
		p.Identifier()
	}

	{
		p.SetState(860)
		p.Match(ObjectiveCParserLP)
	}
	p.SetState(862)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserAUTO)|(1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserEXTERN)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserREGISTER)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSTATIC)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserATTRIBUTE-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-81))|(1<<(ObjectiveCParserTYPEOF-81))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserWEAK_QUALIFIER-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
		{
			p.SetState(861)
			p.ParameterList()
		}

	}
	{
		p.SetState(864)
		p.Match(ObjectiveCParserRP)
	}

	p.SetState(867)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserATTRIBUTE {
		{
			p.SetState(866)
			p.AttributeSpecifier()
		}

	}

	return localctx
}

// IAttributeContext is an interface to support dynamic dispatch.
type IAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeContext differentiates from other interfaces.
	IsAttributeContext()
}

type AttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeContext() *AttributeContext {
	var p = new(AttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_attribute
	return p
}

func (*AttributeContext) IsAttributeContext() {}

func NewAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeContext {
	var p = new(AttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_attribute

	return p
}

func (s *AttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeContext) AttributeName() IAttributeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *AttributeContext) AttributeParameters() IAttributeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeParametersContext)
}

func (s *AttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterAttribute(s)
	}
}

func (s *AttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitAttribute(s)
	}
}

func (p *ObjectiveCParser) Attribute() (localctx IAttributeContext) {
	this := p
	_ = this

	localctx = NewAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ObjectiveCParserRULE_attribute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(869)
		p.AttributeName()
	}
	p.SetState(871)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserLP {
		{
			p.SetState(870)
			p.AttributeParameters()
		}

	}

	return localctx
}

// IAttributeNameContext is an interface to support dynamic dispatch.
type IAttributeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeNameContext differentiates from other interfaces.
	IsAttributeNameContext()
}

type AttributeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeNameContext() *AttributeNameContext {
	var p = new(AttributeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_attributeName
	return p
}

func (*AttributeNameContext) IsAttributeNameContext() {}

func NewAttributeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeNameContext {
	var p = new(AttributeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_attributeName

	return p
}

func (s *AttributeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeNameContext) CONST() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCONST, 0)
}

func (s *AttributeNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AttributeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterAttributeName(s)
	}
}

func (s *AttributeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitAttributeName(s)
	}
}

func (p *ObjectiveCParser) AttributeName() (localctx IAttributeNameContext) {
	this := p
	_ = this

	localctx = NewAttributeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ObjectiveCParserRULE_attributeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(875)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserCONST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(873)
			p.Match(ObjectiveCParserCONST)
		}

	case ObjectiveCParserBOOL, ObjectiveCParserClass, ObjectiveCParserBYCOPY, ObjectiveCParserBYREF, ObjectiveCParserID, ObjectiveCParserIMP, ObjectiveCParserIN, ObjectiveCParserINOUT, ObjectiveCParserONEWAY, ObjectiveCParserOUT, ObjectiveCParserPROTOCOL_, ObjectiveCParserSEL, ObjectiveCParserSELF, ObjectiveCParserSUPER, ObjectiveCParserATOMIC, ObjectiveCParserNONATOMIC, ObjectiveCParserRETAIN, ObjectiveCParserAUTORELEASING_QUALIFIER, ObjectiveCParserBLOCK, ObjectiveCParserBRIDGE_RETAINED, ObjectiveCParserBRIDGE_TRANSFER, ObjectiveCParserCOVARIANT, ObjectiveCParserCONTRAVARIANT, ObjectiveCParserDEPRECATED, ObjectiveCParserKINDOF, ObjectiveCParserUNUSED, ObjectiveCParserNULL_UNSPECIFIED, ObjectiveCParserNULLABLE, ObjectiveCParserNONNULL, ObjectiveCParserNULL_RESETTABLE, ObjectiveCParserNS_INLINE, ObjectiveCParserNS_ENUM, ObjectiveCParserNS_OPTIONS, ObjectiveCParserASSIGN, ObjectiveCParserCOPY, ObjectiveCParserGETTER, ObjectiveCParserSETTER, ObjectiveCParserSTRONG, ObjectiveCParserREADONLY, ObjectiveCParserREADWRITE, ObjectiveCParserWEAK, ObjectiveCParserUNSAFE_UNRETAINED, ObjectiveCParserIB_OUTLET, ObjectiveCParserIB_OUTLET_COLLECTION, ObjectiveCParserIB_INSPECTABLE, ObjectiveCParserIB_DESIGNABLE, ObjectiveCParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(874)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttributeParametersContext is an interface to support dynamic dispatch.
type IAttributeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeParametersContext differentiates from other interfaces.
	IsAttributeParametersContext()
}

type AttributeParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeParametersContext() *AttributeParametersContext {
	var p = new(AttributeParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_attributeParameters
	return p
}

func (*AttributeParametersContext) IsAttributeParametersContext() {}

func NewAttributeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeParametersContext {
	var p = new(AttributeParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_attributeParameters

	return p
}

func (s *AttributeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeParametersContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *AttributeParametersContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *AttributeParametersContext) AttributeParameterList() IAttributeParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeParameterListContext)
}

func (s *AttributeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterAttributeParameters(s)
	}
}

func (s *AttributeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitAttributeParameters(s)
	}
}

func (p *ObjectiveCParser) AttributeParameters() (localctx IAttributeParametersContext) {
	this := p
	_ = this

	localctx = NewAttributeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ObjectiveCParserRULE_attributeParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(877)
		p.Match(ObjectiveCParserLP)
	}
	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserCONST || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(ObjectiveCParserTRUE-38))|(1<<(ObjectiveCParserFALSE-38))|(1<<(ObjectiveCParserBOOL-38))|(1<<(ObjectiveCParserClass-38))|(1<<(ObjectiveCParserBYCOPY-38))|(1<<(ObjectiveCParserBYREF-38))|(1<<(ObjectiveCParserID-38))|(1<<(ObjectiveCParserIMP-38))|(1<<(ObjectiveCParserIN-38))|(1<<(ObjectiveCParserINOUT-38))|(1<<(ObjectiveCParserNIL-38))|(1<<(ObjectiveCParserNO-38))|(1<<(ObjectiveCParserNULL_-38))|(1<<(ObjectiveCParserONEWAY-38))|(1<<(ObjectiveCParserOUT-38))|(1<<(ObjectiveCParserPROTOCOL_-38))|(1<<(ObjectiveCParserSEL-38))|(1<<(ObjectiveCParserSELF-38))|(1<<(ObjectiveCParserSUPER-38))|(1<<(ObjectiveCParserYES-38)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) || (((_la-152)&-(0x1f+1)) == 0 && ((1<<uint((_la-152)))&((1<<(ObjectiveCParserADD-152))|(1<<(ObjectiveCParserSUB-152))|(1<<(ObjectiveCParserCHARACTER_LITERAL-152))|(1<<(ObjectiveCParserSTRING_START-152))|(1<<(ObjectiveCParserHEX_LITERAL-152))|(1<<(ObjectiveCParserOCTAL_LITERAL-152))|(1<<(ObjectiveCParserBINARY_LITERAL-152))|(1<<(ObjectiveCParserDECIMAL_LITERAL-152))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-152)))) != 0) {
		{
			p.SetState(878)
			p.AttributeParameterList()
		}

	}
	{
		p.SetState(881)
		p.Match(ObjectiveCParserRP)
	}

	return localctx
}

// IAttributeParameterListContext is an interface to support dynamic dispatch.
type IAttributeParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeParameterListContext differentiates from other interfaces.
	IsAttributeParameterListContext()
}

type AttributeParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeParameterListContext() *AttributeParameterListContext {
	var p = new(AttributeParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_attributeParameterList
	return p
}

func (*AttributeParameterListContext) IsAttributeParameterListContext() {}

func NewAttributeParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeParameterListContext {
	var p = new(AttributeParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_attributeParameterList

	return p
}

func (s *AttributeParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeParameterListContext) AllAttributeParameter() []IAttributeParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeParameterContext)(nil)).Elem())
	var tst = make([]IAttributeParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeParameterContext)
		}
	}

	return tst
}

func (s *AttributeParameterListContext) AttributeParameter(i int) IAttributeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeParameterContext)
}

func (s *AttributeParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *AttributeParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *AttributeParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterAttributeParameterList(s)
	}
}

func (s *AttributeParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitAttributeParameterList(s)
	}
}

func (p *ObjectiveCParser) AttributeParameterList() (localctx IAttributeParameterListContext) {
	this := p
	_ = this

	localctx = NewAttributeParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ObjectiveCParserRULE_attributeParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(883)
		p.AttributeParameter()
	}
	p.SetState(888)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ObjectiveCParserCOMMA {
		{
			p.SetState(884)
			p.Match(ObjectiveCParserCOMMA)
		}
		{
			p.SetState(885)
			p.AttributeParameter()
		}

		p.SetState(890)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAttributeParameterContext is an interface to support dynamic dispatch.
type IAttributeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeParameterContext differentiates from other interfaces.
	IsAttributeParameterContext()
}

type AttributeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeParameterContext() *AttributeParameterContext {
	var p = new(AttributeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_attributeParameter
	return p
}

func (*AttributeParameterContext) IsAttributeParameterContext() {}

func NewAttributeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeParameterContext {
	var p = new(AttributeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_attributeParameter

	return p
}

func (s *AttributeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeParameterContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *AttributeParameterContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *AttributeParameterContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AttributeParameterContext) AttributeParameterAssignment() IAttributeParameterAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeParameterAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeParameterAssignmentContext)
}

func (s *AttributeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterAttributeParameter(s)
	}
}

func (s *AttributeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitAttributeParameter(s)
	}
}

func (p *ObjectiveCParser) AttributeParameter() (localctx IAttributeParameterContext) {
	this := p
	_ = this

	localctx = NewAttributeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ObjectiveCParserRULE_attributeParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(895)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(891)
			p.Attribute()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(892)
			p.Constant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(893)
			p.StringLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(894)
			p.AttributeParameterAssignment()
		}

	}

	return localctx
}

// IAttributeParameterAssignmentContext is an interface to support dynamic dispatch.
type IAttributeParameterAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeParameterAssignmentContext differentiates from other interfaces.
	IsAttributeParameterAssignmentContext()
}

type AttributeParameterAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeParameterAssignmentContext() *AttributeParameterAssignmentContext {
	var p = new(AttributeParameterAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_attributeParameterAssignment
	return p
}

func (*AttributeParameterAssignmentContext) IsAttributeParameterAssignmentContext() {}

func NewAttributeParameterAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeParameterAssignmentContext {
	var p = new(AttributeParameterAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_attributeParameterAssignment

	return p
}

func (s *AttributeParameterAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeParameterAssignmentContext) AllAttributeName() []IAttributeNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeNameContext)(nil)).Elem())
	var tst = make([]IAttributeNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeNameContext)
		}
	}

	return tst
}

func (s *AttributeParameterAssignmentContext) AttributeName(i int) IAttributeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *AttributeParameterAssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserASSIGNMENT, 0)
}

func (s *AttributeParameterAssignmentContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *AttributeParameterAssignmentContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AttributeParameterAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeParameterAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeParameterAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterAttributeParameterAssignment(s)
	}
}

func (s *AttributeParameterAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitAttributeParameterAssignment(s)
	}
}

func (p *ObjectiveCParser) AttributeParameterAssignment() (localctx IAttributeParameterAssignmentContext) {
	this := p
	_ = this

	localctx = NewAttributeParameterAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ObjectiveCParserRULE_attributeParameterAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(897)
		p.AttributeName()
	}
	{
		p.SetState(898)
		p.Match(ObjectiveCParserASSIGNMENT)
	}
	p.SetState(902)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserTRUE, ObjectiveCParserFALSE, ObjectiveCParserNIL, ObjectiveCParserNO, ObjectiveCParserNULL_, ObjectiveCParserYES, ObjectiveCParserADD, ObjectiveCParserSUB, ObjectiveCParserCHARACTER_LITERAL, ObjectiveCParserHEX_LITERAL, ObjectiveCParserOCTAL_LITERAL, ObjectiveCParserBINARY_LITERAL, ObjectiveCParserDECIMAL_LITERAL, ObjectiveCParserFLOATING_POINT_LITERAL:
		{
			p.SetState(899)
			p.Constant()
		}

	case ObjectiveCParserCONST, ObjectiveCParserBOOL, ObjectiveCParserClass, ObjectiveCParserBYCOPY, ObjectiveCParserBYREF, ObjectiveCParserID, ObjectiveCParserIMP, ObjectiveCParserIN, ObjectiveCParserINOUT, ObjectiveCParserONEWAY, ObjectiveCParserOUT, ObjectiveCParserPROTOCOL_, ObjectiveCParserSEL, ObjectiveCParserSELF, ObjectiveCParserSUPER, ObjectiveCParserATOMIC, ObjectiveCParserNONATOMIC, ObjectiveCParserRETAIN, ObjectiveCParserAUTORELEASING_QUALIFIER, ObjectiveCParserBLOCK, ObjectiveCParserBRIDGE_RETAINED, ObjectiveCParserBRIDGE_TRANSFER, ObjectiveCParserCOVARIANT, ObjectiveCParserCONTRAVARIANT, ObjectiveCParserDEPRECATED, ObjectiveCParserKINDOF, ObjectiveCParserUNUSED, ObjectiveCParserNULL_UNSPECIFIED, ObjectiveCParserNULLABLE, ObjectiveCParserNONNULL, ObjectiveCParserNULL_RESETTABLE, ObjectiveCParserNS_INLINE, ObjectiveCParserNS_ENUM, ObjectiveCParserNS_OPTIONS, ObjectiveCParserASSIGN, ObjectiveCParserCOPY, ObjectiveCParserGETTER, ObjectiveCParserSETTER, ObjectiveCParserSTRONG, ObjectiveCParserREADONLY, ObjectiveCParserREADWRITE, ObjectiveCParserWEAK, ObjectiveCParserUNSAFE_UNRETAINED, ObjectiveCParserIB_OUTLET, ObjectiveCParserIB_OUTLET_COLLECTION, ObjectiveCParserIB_INSPECTABLE, ObjectiveCParserIB_DESIGNABLE, ObjectiveCParserIDENTIFIER:
		{
			p.SetState(900)
			p.AttributeName()
		}

	case ObjectiveCParserSTRING_START:
		{
			p.SetState(901)
			p.StringLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *DeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *DeclarationContext) VarDeclaration() IVarDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarDeclarationContext)
}

func (s *DeclarationContext) TypedefDeclaration() ITypedefDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedefDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedefDeclarationContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (p *ObjectiveCParser) Declaration() (localctx IDeclarationContext) {
	this := p
	_ = this

	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ObjectiveCParserRULE_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(908)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(904)
			p.FunctionCallExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(905)
			p.EnumDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(906)
			p.VarDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(907)
			p.TypedefDeclaration()
		}

	}

	return localctx
}

// IFunctionCallExpressionContext is an interface to support dynamic dispatch.
type IFunctionCallExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallExpressionContext differentiates from other interfaces.
	IsFunctionCallExpressionContext()
}

type FunctionCallExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallExpressionContext() *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_functionCallExpression
	return p
}

func (*FunctionCallExpressionContext) IsFunctionCallExpressionContext() {}

func NewFunctionCallExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_functionCallExpression

	return p
}

func (s *FunctionCallExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallExpressionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionCallExpressionContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *FunctionCallExpressionContext) DirectDeclarator() IDirectDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDirectDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDirectDeclaratorContext)
}

func (s *FunctionCallExpressionContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *FunctionCallExpressionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, 0)
}

func (s *FunctionCallExpressionContext) AllAttributeSpecifier() []IAttributeSpecifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeSpecifierContext)(nil)).Elem())
	var tst = make([]IAttributeSpecifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeSpecifierContext)
		}
	}

	return tst
}

func (s *FunctionCallExpressionContext) AttributeSpecifier(i int) IAttributeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeSpecifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierContext)
}

func (s *FunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterFunctionCallExpression(s)
	}
}

func (s *FunctionCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitFunctionCallExpression(s)
	}
}

func (p *ObjectiveCParser) FunctionCallExpression() (localctx IFunctionCallExpressionContext) {
	this := p
	_ = this

	localctx = NewFunctionCallExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ObjectiveCParserRULE_functionCallExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(911)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserATTRIBUTE {
		{
			p.SetState(910)
			p.AttributeSpecifier()
		}

	}
	{
		p.SetState(913)
		p.Identifier()
	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserATTRIBUTE {
		{
			p.SetState(914)
			p.AttributeSpecifier()
		}

	}
	{
		p.SetState(917)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(918)
		p.DirectDeclarator()
	}
	{
		p.SetState(919)
		p.Match(ObjectiveCParserRP)
	}
	{
		p.SetState(920)
		p.Match(ObjectiveCParserSEMI)
	}

	return localctx
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_enumDeclaration
	return p
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) EnumSpecifier() IEnumSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumSpecifierContext)
}

func (s *EnumDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, 0)
}

func (s *EnumDeclarationContext) AttributeSpecifier() IAttributeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierContext)
}

func (s *EnumDeclarationContext) TYPEDEF() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserTYPEDEF, 0)
}

func (s *EnumDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitEnumDeclaration(s)
	}
}

func (p *ObjectiveCParser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	this := p
	_ = this

	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ObjectiveCParserRULE_enumDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(923)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserATTRIBUTE {
		{
			p.SetState(922)
			p.AttributeSpecifier()
		}

	}
	p.SetState(926)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserTYPEDEF {
		{
			p.SetState(925)
			p.Match(ObjectiveCParserTYPEDEF)
		}

	}
	{
		p.SetState(928)
		p.EnumSpecifier()
	}
	p.SetState(930)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
		{
			p.SetState(929)
			p.Identifier()
		}

	}
	{
		p.SetState(932)
		p.Match(ObjectiveCParserSEMI)
	}

	return localctx
}

// IVarDeclarationContext is an interface to support dynamic dispatch.
type IVarDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarDeclarationContext differentiates from other interfaces.
	IsVarDeclarationContext()
}

type VarDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarDeclarationContext() *VarDeclarationContext {
	var p = new(VarDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_varDeclaration
	return p
}

func (*VarDeclarationContext) IsVarDeclarationContext() {}

func NewVarDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarDeclarationContext {
	var p = new(VarDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_varDeclaration

	return p
}

func (s *VarDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VarDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, 0)
}

func (s *VarDeclarationContext) DeclarationSpecifiers() IDeclarationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifiersContext)
}

func (s *VarDeclarationContext) InitDeclaratorList() IInitDeclaratorListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitDeclaratorListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitDeclaratorListContext)
}

func (s *VarDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterVarDeclaration(s)
	}
}

func (s *VarDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitVarDeclaration(s)
	}
}

func (p *ObjectiveCParser) VarDeclaration() (localctx IVarDeclarationContext) {
	this := p
	_ = this

	localctx = NewVarDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ObjectiveCParserRULE_varDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(938)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(934)
			p.DeclarationSpecifiers()
		}
		{
			p.SetState(935)
			p.InitDeclaratorList()
		}

	case 2:
		{
			p.SetState(937)
			p.DeclarationSpecifiers()
		}

	}
	{
		p.SetState(940)
		p.Match(ObjectiveCParserSEMI)
	}

	return localctx
}

// ITypedefDeclarationContext is an interface to support dynamic dispatch.
type ITypedefDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedefDeclarationContext differentiates from other interfaces.
	IsTypedefDeclarationContext()
}

type TypedefDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedefDeclarationContext() *TypedefDeclarationContext {
	var p = new(TypedefDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_typedefDeclaration
	return p
}

func (*TypedefDeclarationContext) IsTypedefDeclarationContext() {}

func NewTypedefDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedefDeclarationContext {
	var p = new(TypedefDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_typedefDeclaration

	return p
}

func (s *TypedefDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedefDeclarationContext) TYPEDEF() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserTYPEDEF, 0)
}

func (s *TypedefDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, 0)
}

func (s *TypedefDeclarationContext) DeclarationSpecifiers() IDeclarationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifiersContext)
}

func (s *TypedefDeclarationContext) TypeDeclaratorList() ITypeDeclaratorListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeDeclaratorListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeDeclaratorListContext)
}

func (s *TypedefDeclarationContext) AttributeSpecifier() IAttributeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierContext)
}

func (s *TypedefDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedefDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedefDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterTypedefDeclaration(s)
	}
}

func (s *TypedefDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitTypedefDeclaration(s)
	}
}

func (p *ObjectiveCParser) TypedefDeclaration() (localctx ITypedefDeclarationContext) {
	this := p
	_ = this

	localctx = NewTypedefDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ObjectiveCParserRULE_typedefDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(943)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserATTRIBUTE {
		{
			p.SetState(942)
			p.AttributeSpecifier()
		}

	}
	{
		p.SetState(945)
		p.Match(ObjectiveCParserTYPEDEF)
	}
	p.SetState(950)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(946)
			p.DeclarationSpecifiers()
		}
		{
			p.SetState(947)
			p.TypeDeclaratorList()
		}

	case 2:
		{
			p.SetState(949)
			p.DeclarationSpecifiers()
		}

	}
	{
		p.SetState(952)
		p.Match(ObjectiveCParserSEMI)
	}

	return localctx
}

// ITypeDeclaratorListContext is an interface to support dynamic dispatch.
type ITypeDeclaratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeDeclaratorListContext differentiates from other interfaces.
	IsTypeDeclaratorListContext()
}

type TypeDeclaratorListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclaratorListContext() *TypeDeclaratorListContext {
	var p = new(TypeDeclaratorListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_typeDeclaratorList
	return p
}

func (*TypeDeclaratorListContext) IsTypeDeclaratorListContext() {}

func NewTypeDeclaratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclaratorListContext {
	var p = new(TypeDeclaratorListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_typeDeclaratorList

	return p
}

func (s *TypeDeclaratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclaratorListContext) AllTypeDeclarator() []ITypeDeclaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeDeclaratorContext)(nil)).Elem())
	var tst = make([]ITypeDeclaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeDeclaratorContext)
		}
	}

	return tst
}

func (s *TypeDeclaratorListContext) TypeDeclarator(i int) ITypeDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeDeclaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeDeclaratorContext)
}

func (s *TypeDeclaratorListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *TypeDeclaratorListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *TypeDeclaratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclaratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclaratorListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterTypeDeclaratorList(s)
	}
}

func (s *TypeDeclaratorListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitTypeDeclaratorList(s)
	}
}

func (p *ObjectiveCParser) TypeDeclaratorList() (localctx ITypeDeclaratorListContext) {
	this := p
	_ = this

	localctx = NewTypeDeclaratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ObjectiveCParserRULE_typeDeclaratorList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(954)
		p.TypeDeclarator()
	}
	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ObjectiveCParserCOMMA {
		{
			p.SetState(955)
			p.Match(ObjectiveCParserCOMMA)
		}
		{
			p.SetState(956)
			p.TypeDeclarator()
		}

		p.SetState(961)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeDeclaratorContext is an interface to support dynamic dispatch.
type ITypeDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeDeclaratorContext differentiates from other interfaces.
	IsTypeDeclaratorContext()
}

type TypeDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclaratorContext() *TypeDeclaratorContext {
	var p = new(TypeDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_typeDeclarator
	return p
}

func (*TypeDeclaratorContext) IsTypeDeclaratorContext() {}

func NewTypeDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclaratorContext {
	var p = new(TypeDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_typeDeclarator

	return p
}

func (s *TypeDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclaratorContext) DirectDeclarator() IDirectDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDirectDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDirectDeclaratorContext)
}

func (s *TypeDeclaratorContext) Pointer() IPointerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPointerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPointerContext)
}

func (s *TypeDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterTypeDeclarator(s)
	}
}

func (s *TypeDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitTypeDeclarator(s)
	}
}

func (p *ObjectiveCParser) TypeDeclarator() (localctx ITypeDeclaratorContext) {
	this := p
	_ = this

	localctx = NewTypeDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ObjectiveCParserRULE_typeDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(963)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserMUL {
		{
			p.SetState(962)
			p.Pointer()
		}

	}
	{
		p.SetState(965)
		p.DirectDeclarator()
	}

	return localctx
}

// IDeclarationSpecifiersContext is an interface to support dynamic dispatch.
type IDeclarationSpecifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationSpecifiersContext differentiates from other interfaces.
	IsDeclarationSpecifiersContext()
}

type DeclarationSpecifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationSpecifiersContext() *DeclarationSpecifiersContext {
	var p = new(DeclarationSpecifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_declarationSpecifiers
	return p
}

func (*DeclarationSpecifiersContext) IsDeclarationSpecifiersContext() {}

func NewDeclarationSpecifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationSpecifiersContext {
	var p = new(DeclarationSpecifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_declarationSpecifiers

	return p
}

func (s *DeclarationSpecifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationSpecifiersContext) AllStorageClassSpecifier() []IStorageClassSpecifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStorageClassSpecifierContext)(nil)).Elem())
	var tst = make([]IStorageClassSpecifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStorageClassSpecifierContext)
		}
	}

	return tst
}

func (s *DeclarationSpecifiersContext) StorageClassSpecifier(i int) IStorageClassSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStorageClassSpecifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStorageClassSpecifierContext)
}

func (s *DeclarationSpecifiersContext) AllAttributeSpecifier() []IAttributeSpecifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeSpecifierContext)(nil)).Elem())
	var tst = make([]IAttributeSpecifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeSpecifierContext)
		}
	}

	return tst
}

func (s *DeclarationSpecifiersContext) AttributeSpecifier(i int) IAttributeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeSpecifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierContext)
}

func (s *DeclarationSpecifiersContext) AllArcBehaviourSpecifier() []IArcBehaviourSpecifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArcBehaviourSpecifierContext)(nil)).Elem())
	var tst = make([]IArcBehaviourSpecifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArcBehaviourSpecifierContext)
		}
	}

	return tst
}

func (s *DeclarationSpecifiersContext) ArcBehaviourSpecifier(i int) IArcBehaviourSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArcBehaviourSpecifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArcBehaviourSpecifierContext)
}

func (s *DeclarationSpecifiersContext) AllNullabilitySpecifier() []INullabilitySpecifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INullabilitySpecifierContext)(nil)).Elem())
	var tst = make([]INullabilitySpecifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INullabilitySpecifierContext)
		}
	}

	return tst
}

func (s *DeclarationSpecifiersContext) NullabilitySpecifier(i int) INullabilitySpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullabilitySpecifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INullabilitySpecifierContext)
}

func (s *DeclarationSpecifiersContext) AllIbOutletQualifier() []IIbOutletQualifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIbOutletQualifierContext)(nil)).Elem())
	var tst = make([]IIbOutletQualifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIbOutletQualifierContext)
		}
	}

	return tst
}

func (s *DeclarationSpecifiersContext) IbOutletQualifier(i int) IIbOutletQualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIbOutletQualifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIbOutletQualifierContext)
}

func (s *DeclarationSpecifiersContext) AllTypePrefix() []ITypePrefixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypePrefixContext)(nil)).Elem())
	var tst = make([]ITypePrefixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypePrefixContext)
		}
	}

	return tst
}

func (s *DeclarationSpecifiersContext) TypePrefix(i int) ITypePrefixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypePrefixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypePrefixContext)
}

func (s *DeclarationSpecifiersContext) AllTypeQualifier() []ITypeQualifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeQualifierContext)(nil)).Elem())
	var tst = make([]ITypeQualifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeQualifierContext)
		}
	}

	return tst
}

func (s *DeclarationSpecifiersContext) TypeQualifier(i int) ITypeQualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeQualifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeQualifierContext)
}

func (s *DeclarationSpecifiersContext) AllTypeSpecifier() []ITypeSpecifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeSpecifierContext)(nil)).Elem())
	var tst = make([]ITypeSpecifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeSpecifierContext)
		}
	}

	return tst
}

func (s *DeclarationSpecifiersContext) TypeSpecifier(i int) ITypeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSpecifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *DeclarationSpecifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationSpecifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationSpecifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterDeclarationSpecifiers(s)
	}
}

func (s *DeclarationSpecifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitDeclarationSpecifiers(s)
	}
}

func (p *ObjectiveCParser) DeclarationSpecifiers() (localctx IDeclarationSpecifiersContext) {
	this := p
	_ = this

	localctx = NewDeclarationSpecifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ObjectiveCParserRULE_declarationSpecifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(975)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(975)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(967)
					p.StorageClassSpecifier()
				}

			case 2:
				{
					p.SetState(968)
					p.AttributeSpecifier()
				}

			case 3:
				{
					p.SetState(969)
					p.ArcBehaviourSpecifier()
				}

			case 4:
				{
					p.SetState(970)
					p.NullabilitySpecifier()
				}

			case 5:
				{
					p.SetState(971)
					p.IbOutletQualifier()
				}

			case 6:
				{
					p.SetState(972)
					p.TypePrefix()
				}

			case 7:
				{
					p.SetState(973)
					p.TypeQualifier()
				}

			case 8:
				{
					p.SetState(974)
					p.TypeSpecifier()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(977)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext())
	}

	return localctx
}

// IAttributeSpecifierContext is an interface to support dynamic dispatch.
type IAttributeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeSpecifierContext differentiates from other interfaces.
	IsAttributeSpecifierContext()
}

type AttributeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeSpecifierContext() *AttributeSpecifierContext {
	var p = new(AttributeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_attributeSpecifier
	return p
}

func (*AttributeSpecifierContext) IsAttributeSpecifierContext() {}

func NewAttributeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeSpecifierContext {
	var p = new(AttributeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_attributeSpecifier

	return p
}

func (s *AttributeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeSpecifierContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserATTRIBUTE, 0)
}

func (s *AttributeSpecifierContext) AllLP() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserLP)
}

func (s *AttributeSpecifierContext) LP(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, i)
}

func (s *AttributeSpecifierContext) AllAttribute() []IAttributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeContext)(nil)).Elem())
	var tst = make([]IAttributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeContext)
		}
	}

	return tst
}

func (s *AttributeSpecifierContext) Attribute(i int) IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *AttributeSpecifierContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserRP)
}

func (s *AttributeSpecifierContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, i)
}

func (s *AttributeSpecifierContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *AttributeSpecifierContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *AttributeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterAttributeSpecifier(s)
	}
}

func (s *AttributeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitAttributeSpecifier(s)
	}
}

func (p *ObjectiveCParser) AttributeSpecifier() (localctx IAttributeSpecifierContext) {
	this := p
	_ = this

	localctx = NewAttributeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ObjectiveCParserRULE_attributeSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(979)
		p.Match(ObjectiveCParserATTRIBUTE)
	}
	{
		p.SetState(980)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(981)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(982)
		p.Attribute()
	}
	p.SetState(987)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ObjectiveCParserCOMMA {
		{
			p.SetState(983)
			p.Match(ObjectiveCParserCOMMA)
		}
		{
			p.SetState(984)
			p.Attribute()
		}

		p.SetState(989)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(990)
		p.Match(ObjectiveCParserRP)
	}
	{
		p.SetState(991)
		p.Match(ObjectiveCParserRP)
	}

	return localctx
}

// IInitDeclaratorListContext is an interface to support dynamic dispatch.
type IInitDeclaratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitDeclaratorListContext differentiates from other interfaces.
	IsInitDeclaratorListContext()
}

type InitDeclaratorListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitDeclaratorListContext() *InitDeclaratorListContext {
	var p = new(InitDeclaratorListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_initDeclaratorList
	return p
}

func (*InitDeclaratorListContext) IsInitDeclaratorListContext() {}

func NewInitDeclaratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitDeclaratorListContext {
	var p = new(InitDeclaratorListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_initDeclaratorList

	return p
}

func (s *InitDeclaratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *InitDeclaratorListContext) AllInitDeclarator() []IInitDeclaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInitDeclaratorContext)(nil)).Elem())
	var tst = make([]IInitDeclaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInitDeclaratorContext)
		}
	}

	return tst
}

func (s *InitDeclaratorListContext) InitDeclarator(i int) IInitDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitDeclaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInitDeclaratorContext)
}

func (s *InitDeclaratorListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *InitDeclaratorListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *InitDeclaratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitDeclaratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitDeclaratorListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterInitDeclaratorList(s)
	}
}

func (s *InitDeclaratorListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitInitDeclaratorList(s)
	}
}

func (p *ObjectiveCParser) InitDeclaratorList() (localctx IInitDeclaratorListContext) {
	this := p
	_ = this

	localctx = NewInitDeclaratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ObjectiveCParserRULE_initDeclaratorList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(993)
		p.InitDeclarator()
	}
	p.SetState(998)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ObjectiveCParserCOMMA {
		{
			p.SetState(994)
			p.Match(ObjectiveCParserCOMMA)
		}
		{
			p.SetState(995)
			p.InitDeclarator()
		}

		p.SetState(1000)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInitDeclaratorContext is an interface to support dynamic dispatch.
type IInitDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitDeclaratorContext differentiates from other interfaces.
	IsInitDeclaratorContext()
}

type InitDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitDeclaratorContext() *InitDeclaratorContext {
	var p = new(InitDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_initDeclarator
	return p
}

func (*InitDeclaratorContext) IsInitDeclaratorContext() {}

func NewInitDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitDeclaratorContext {
	var p = new(InitDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_initDeclarator

	return p
}

func (s *InitDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *InitDeclaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *InitDeclaratorContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserASSIGNMENT, 0)
}

func (s *InitDeclaratorContext) Initializer() IInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *InitDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterInitDeclarator(s)
	}
}

func (s *InitDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitInitDeclarator(s)
	}
}

func (p *ObjectiveCParser) InitDeclarator() (localctx IInitDeclaratorContext) {
	this := p
	_ = this

	localctx = NewInitDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ObjectiveCParserRULE_initDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1001)
		p.Declarator()
	}
	p.SetState(1004)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserASSIGNMENT {
		{
			p.SetState(1002)
			p.Match(ObjectiveCParserASSIGNMENT)
		}
		{
			p.SetState(1003)
			p.Initializer()
		}

	}

	return localctx
}

// IStructOrUnionSpecifierContext is an interface to support dynamic dispatch.
type IStructOrUnionSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructOrUnionSpecifierContext differentiates from other interfaces.
	IsStructOrUnionSpecifierContext()
}

type StructOrUnionSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructOrUnionSpecifierContext() *StructOrUnionSpecifierContext {
	var p = new(StructOrUnionSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_structOrUnionSpecifier
	return p
}

func (*StructOrUnionSpecifierContext) IsStructOrUnionSpecifierContext() {}

func NewStructOrUnionSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructOrUnionSpecifierContext {
	var p = new(StructOrUnionSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_structOrUnionSpecifier

	return p
}

func (s *StructOrUnionSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StructOrUnionSpecifierContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSTRUCT, 0)
}

func (s *StructOrUnionSpecifierContext) UNION() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserUNION, 0)
}

func (s *StructOrUnionSpecifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StructOrUnionSpecifierContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACE, 0)
}

func (s *StructOrUnionSpecifierContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACE, 0)
}

func (s *StructOrUnionSpecifierContext) AllFieldDeclaration() []IFieldDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldDeclarationContext)(nil)).Elem())
	var tst = make([]IFieldDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldDeclarationContext)
		}
	}

	return tst
}

func (s *StructOrUnionSpecifierContext) FieldDeclaration(i int) IFieldDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *StructOrUnionSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructOrUnionSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructOrUnionSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterStructOrUnionSpecifier(s)
	}
}

func (s *StructOrUnionSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitStructOrUnionSpecifier(s)
	}
}

func (p *ObjectiveCParser) StructOrUnionSpecifier() (localctx IStructOrUnionSpecifierContext) {
	this := p
	_ = this

	localctx = NewStructOrUnionSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ObjectiveCParserRULE_structOrUnionSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1006)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ObjectiveCParserSTRUCT || _la == ObjectiveCParserUNION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1019)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1007)
			p.Identifier()
		}

	case 2:
		p.SetState(1009)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
			{
				p.SetState(1008)
				p.Identifier()
			}

		}
		{
			p.SetState(1011)
			p.Match(ObjectiveCParserLBRACE)
		}
		p.SetState(1013)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-81))|(1<<(ObjectiveCParserTYPEOF-81))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserWEAK_QUALIFIER-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
			{
				p.SetState(1012)
				p.FieldDeclaration()
			}

			p.SetState(1015)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1017)
			p.Match(ObjectiveCParserRBRACE)
		}

	}

	return localctx
}

// IFieldDeclarationContext is an interface to support dynamic dispatch.
type IFieldDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldDeclarationContext differentiates from other interfaces.
	IsFieldDeclarationContext()
}

type FieldDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclarationContext() *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_fieldDeclaration
	return p
}

func (*FieldDeclarationContext) IsFieldDeclarationContext() {}

func NewFieldDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_fieldDeclaration

	return p
}

func (s *FieldDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclarationContext) SpecifierQualifierList() ISpecifierQualifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecifierQualifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecifierQualifierListContext)
}

func (s *FieldDeclarationContext) FieldDeclaratorList() IFieldDeclaratorListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldDeclaratorListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldDeclaratorListContext)
}

func (s *FieldDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, 0)
}

func (s *FieldDeclarationContext) Macro() IMacroContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMacroContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMacroContext)
}

func (s *FieldDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterFieldDeclaration(s)
	}
}

func (s *FieldDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitFieldDeclaration(s)
	}
}

func (p *ObjectiveCParser) FieldDeclaration() (localctx IFieldDeclarationContext) {
	this := p
	_ = this

	localctx = NewFieldDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ObjectiveCParserRULE_fieldDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1021)
		p.SpecifierQualifierList()
	}
	{
		p.SetState(1022)
		p.FieldDeclaratorList()
	}
	p.SetState(1024)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
		{
			p.SetState(1023)
			p.Macro()
		}

	}
	{
		p.SetState(1026)
		p.Match(ObjectiveCParserSEMI)
	}

	return localctx
}

// ISpecifierQualifierListContext is an interface to support dynamic dispatch.
type ISpecifierQualifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecifierQualifierListContext differentiates from other interfaces.
	IsSpecifierQualifierListContext()
}

type SpecifierQualifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecifierQualifierListContext() *SpecifierQualifierListContext {
	var p = new(SpecifierQualifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_specifierQualifierList
	return p
}

func (*SpecifierQualifierListContext) IsSpecifierQualifierListContext() {}

func NewSpecifierQualifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecifierQualifierListContext {
	var p = new(SpecifierQualifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_specifierQualifierList

	return p
}

func (s *SpecifierQualifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecifierQualifierListContext) AllArcBehaviourSpecifier() []IArcBehaviourSpecifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArcBehaviourSpecifierContext)(nil)).Elem())
	var tst = make([]IArcBehaviourSpecifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArcBehaviourSpecifierContext)
		}
	}

	return tst
}

func (s *SpecifierQualifierListContext) ArcBehaviourSpecifier(i int) IArcBehaviourSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArcBehaviourSpecifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArcBehaviourSpecifierContext)
}

func (s *SpecifierQualifierListContext) AllNullabilitySpecifier() []INullabilitySpecifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INullabilitySpecifierContext)(nil)).Elem())
	var tst = make([]INullabilitySpecifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INullabilitySpecifierContext)
		}
	}

	return tst
}

func (s *SpecifierQualifierListContext) NullabilitySpecifier(i int) INullabilitySpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullabilitySpecifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INullabilitySpecifierContext)
}

func (s *SpecifierQualifierListContext) AllIbOutletQualifier() []IIbOutletQualifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIbOutletQualifierContext)(nil)).Elem())
	var tst = make([]IIbOutletQualifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIbOutletQualifierContext)
		}
	}

	return tst
}

func (s *SpecifierQualifierListContext) IbOutletQualifier(i int) IIbOutletQualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIbOutletQualifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIbOutletQualifierContext)
}

func (s *SpecifierQualifierListContext) AllTypePrefix() []ITypePrefixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypePrefixContext)(nil)).Elem())
	var tst = make([]ITypePrefixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypePrefixContext)
		}
	}

	return tst
}

func (s *SpecifierQualifierListContext) TypePrefix(i int) ITypePrefixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypePrefixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypePrefixContext)
}

func (s *SpecifierQualifierListContext) AllTypeQualifier() []ITypeQualifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeQualifierContext)(nil)).Elem())
	var tst = make([]ITypeQualifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeQualifierContext)
		}
	}

	return tst
}

func (s *SpecifierQualifierListContext) TypeQualifier(i int) ITypeQualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeQualifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeQualifierContext)
}

func (s *SpecifierQualifierListContext) AllTypeSpecifier() []ITypeSpecifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeSpecifierContext)(nil)).Elem())
	var tst = make([]ITypeSpecifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeSpecifierContext)
		}
	}

	return tst
}

func (s *SpecifierQualifierListContext) TypeSpecifier(i int) ITypeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSpecifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *SpecifierQualifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecifierQualifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecifierQualifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterSpecifierQualifierList(s)
	}
}

func (s *SpecifierQualifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitSpecifierQualifierList(s)
	}
}

func (p *ObjectiveCParser) SpecifierQualifierList() (localctx ISpecifierQualifierListContext) {
	this := p
	_ = this

	localctx = NewSpecifierQualifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ObjectiveCParserRULE_specifierQualifierList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1034)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(1034)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1028)
					p.ArcBehaviourSpecifier()
				}

			case 2:
				{
					p.SetState(1029)
					p.NullabilitySpecifier()
				}

			case 3:
				{
					p.SetState(1030)
					p.IbOutletQualifier()
				}

			case 4:
				{
					p.SetState(1031)
					p.TypePrefix()
				}

			case 5:
				{
					p.SetState(1032)
					p.TypeQualifier()
				}

			case 6:
				{
					p.SetState(1033)
					p.TypeSpecifier()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1036)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())
	}

	return localctx
}

// IIbOutletQualifierContext is an interface to support dynamic dispatch.
type IIbOutletQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIbOutletQualifierContext differentiates from other interfaces.
	IsIbOutletQualifierContext()
}

type IbOutletQualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIbOutletQualifierContext() *IbOutletQualifierContext {
	var p = new(IbOutletQualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_ibOutletQualifier
	return p
}

func (*IbOutletQualifierContext) IsIbOutletQualifierContext() {}

func NewIbOutletQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IbOutletQualifierContext {
	var p = new(IbOutletQualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_ibOutletQualifier

	return p
}

func (s *IbOutletQualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IbOutletQualifierContext) IB_OUTLET_COLLECTION() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIB_OUTLET_COLLECTION, 0)
}

func (s *IbOutletQualifierContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *IbOutletQualifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IbOutletQualifierContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *IbOutletQualifierContext) IB_OUTLET() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIB_OUTLET, 0)
}

func (s *IbOutletQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IbOutletQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IbOutletQualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterIbOutletQualifier(s)
	}
}

func (s *IbOutletQualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitIbOutletQualifier(s)
	}
}

func (p *ObjectiveCParser) IbOutletQualifier() (localctx IIbOutletQualifierContext) {
	this := p
	_ = this

	localctx = NewIbOutletQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ObjectiveCParserRULE_ibOutletQualifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1044)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserIB_OUTLET_COLLECTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1038)
			p.Match(ObjectiveCParserIB_OUTLET_COLLECTION)
		}
		{
			p.SetState(1039)
			p.Match(ObjectiveCParserLP)
		}
		{
			p.SetState(1040)
			p.Identifier()
		}
		{
			p.SetState(1041)
			p.Match(ObjectiveCParserRP)
		}

	case ObjectiveCParserIB_OUTLET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1043)
			p.Match(ObjectiveCParserIB_OUTLET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArcBehaviourSpecifierContext is an interface to support dynamic dispatch.
type IArcBehaviourSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArcBehaviourSpecifierContext differentiates from other interfaces.
	IsArcBehaviourSpecifierContext()
}

type ArcBehaviourSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArcBehaviourSpecifierContext() *ArcBehaviourSpecifierContext {
	var p = new(ArcBehaviourSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_arcBehaviourSpecifier
	return p
}

func (*ArcBehaviourSpecifierContext) IsArcBehaviourSpecifierContext() {}

func NewArcBehaviourSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArcBehaviourSpecifierContext {
	var p = new(ArcBehaviourSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_arcBehaviourSpecifier

	return p
}

func (s *ArcBehaviourSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ArcBehaviourSpecifierContext) WEAK_QUALIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserWEAK_QUALIFIER, 0)
}

func (s *ArcBehaviourSpecifierContext) STRONG_QUALIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSTRONG_QUALIFIER, 0)
}

func (s *ArcBehaviourSpecifierContext) AUTORELEASING_QUALIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserAUTORELEASING_QUALIFIER, 0)
}

func (s *ArcBehaviourSpecifierContext) UNSAFE_UNRETAINED_QUALIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER, 0)
}

func (s *ArcBehaviourSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArcBehaviourSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArcBehaviourSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterArcBehaviourSpecifier(s)
	}
}

func (s *ArcBehaviourSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitArcBehaviourSpecifier(s)
	}
}

func (p *ObjectiveCParser) ArcBehaviourSpecifier() (localctx IArcBehaviourSpecifierContext) {
	this := p
	_ = this

	localctx = NewArcBehaviourSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ObjectiveCParserRULE_arcBehaviourSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1046)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-85)&-(0x1f+1)) == 0 && ((1<<uint((_la-85)))&((1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-85))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-85))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-85))|(1<<(ObjectiveCParserWEAK_QUALIFIER-85)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INullabilitySpecifierContext is an interface to support dynamic dispatch.
type INullabilitySpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNullabilitySpecifierContext differentiates from other interfaces.
	IsNullabilitySpecifierContext()
}

type NullabilitySpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullabilitySpecifierContext() *NullabilitySpecifierContext {
	var p = new(NullabilitySpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_nullabilitySpecifier
	return p
}

func (*NullabilitySpecifierContext) IsNullabilitySpecifierContext() {}

func NewNullabilitySpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullabilitySpecifierContext {
	var p = new(NullabilitySpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_nullabilitySpecifier

	return p
}

func (s *NullabilitySpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *NullabilitySpecifierContext) NULL_UNSPECIFIED() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNULL_UNSPECIFIED, 0)
}

func (s *NullabilitySpecifierContext) NULLABLE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNULLABLE, 0)
}

func (s *NullabilitySpecifierContext) NONNULL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNONNULL, 0)
}

func (s *NullabilitySpecifierContext) NULL_RESETTABLE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNULL_RESETTABLE, 0)
}

func (s *NullabilitySpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullabilitySpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullabilitySpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterNullabilitySpecifier(s)
	}
}

func (s *NullabilitySpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitNullabilitySpecifier(s)
	}
}

func (p *ObjectiveCParser) NullabilitySpecifier() (localctx INullabilitySpecifierContext) {
	this := p
	_ = this

	localctx = NewNullabilitySpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ObjectiveCParserRULE_nullabilitySpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1048)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(ObjectiveCParserNULL_UNSPECIFIED-99))|(1<<(ObjectiveCParserNULLABLE-99))|(1<<(ObjectiveCParserNONNULL-99))|(1<<(ObjectiveCParserNULL_RESETTABLE-99)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStorageClassSpecifierContext is an interface to support dynamic dispatch.
type IStorageClassSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStorageClassSpecifierContext differentiates from other interfaces.
	IsStorageClassSpecifierContext()
}

type StorageClassSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorageClassSpecifierContext() *StorageClassSpecifierContext {
	var p = new(StorageClassSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_storageClassSpecifier
	return p
}

func (*StorageClassSpecifierContext) IsStorageClassSpecifierContext() {}

func NewStorageClassSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageClassSpecifierContext {
	var p = new(StorageClassSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_storageClassSpecifier

	return p
}

func (s *StorageClassSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StorageClassSpecifierContext) AUTO() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserAUTO, 0)
}

func (s *StorageClassSpecifierContext) REGISTER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserREGISTER, 0)
}

func (s *StorageClassSpecifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSTATIC, 0)
}

func (s *StorageClassSpecifierContext) EXTERN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserEXTERN, 0)
}

func (s *StorageClassSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageClassSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageClassSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterStorageClassSpecifier(s)
	}
}

func (s *StorageClassSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitStorageClassSpecifier(s)
	}
}

func (p *ObjectiveCParser) StorageClassSpecifier() (localctx IStorageClassSpecifierContext) {
	this := p
	_ = this

	localctx = NewStorageClassSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ObjectiveCParserRULE_storageClassSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1050)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserAUTO)|(1<<ObjectiveCParserEXTERN)|(1<<ObjectiveCParserREGISTER)|(1<<ObjectiveCParserSTATIC))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypePrefixContext is an interface to support dynamic dispatch.
type ITypePrefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypePrefixContext differentiates from other interfaces.
	IsTypePrefixContext()
}

type TypePrefixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypePrefixContext() *TypePrefixContext {
	var p = new(TypePrefixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_typePrefix
	return p
}

func (*TypePrefixContext) IsTypePrefixContext() {}

func NewTypePrefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypePrefixContext {
	var p = new(TypePrefixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_typePrefix

	return p
}

func (s *TypePrefixContext) GetParser() antlr.Parser { return s.parser }

func (s *TypePrefixContext) BRIDGE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBRIDGE, 0)
}

func (s *TypePrefixContext) BRIDGE_TRANSFER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBRIDGE_TRANSFER, 0)
}

func (s *TypePrefixContext) BRIDGE_RETAINED() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBRIDGE_RETAINED, 0)
}

func (s *TypePrefixContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBLOCK, 0)
}

func (s *TypePrefixContext) INLINE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserINLINE, 0)
}

func (s *TypePrefixContext) NS_INLINE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNS_INLINE, 0)
}

func (s *TypePrefixContext) KINDOF() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserKINDOF, 0)
}

func (s *TypePrefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypePrefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypePrefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterTypePrefix(s)
	}
}

func (s *TypePrefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitTypePrefix(s)
	}
}

func (p *ObjectiveCParser) TypePrefix() (localctx ITypePrefixContext) {
	this := p
	_ = this

	localctx = NewTypePrefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ObjectiveCParserRULE_typePrefix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1052)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ObjectiveCParserINLINE || (((_la-86)&-(0x1f+1)) == 0 && ((1<<uint((_la-86)))&((1<<(ObjectiveCParserBLOCK-86))|(1<<(ObjectiveCParserBRIDGE-86))|(1<<(ObjectiveCParserBRIDGE_RETAINED-86))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-86))|(1<<(ObjectiveCParserKINDOF-86))|(1<<(ObjectiveCParserNS_INLINE-86)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypeQualifierContext is an interface to support dynamic dispatch.
type ITypeQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeQualifierContext differentiates from other interfaces.
	IsTypeQualifierContext()
}

type TypeQualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeQualifierContext() *TypeQualifierContext {
	var p = new(TypeQualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_typeQualifier
	return p
}

func (*TypeQualifierContext) IsTypeQualifierContext() {}

func NewTypeQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeQualifierContext {
	var p = new(TypeQualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_typeQualifier

	return p
}

func (s *TypeQualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeQualifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCONST, 0)
}

func (s *TypeQualifierContext) VOLATILE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserVOLATILE, 0)
}

func (s *TypeQualifierContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRESTRICT, 0)
}

func (s *TypeQualifierContext) ProtocolQualifier() IProtocolQualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolQualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolQualifierContext)
}

func (s *TypeQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeQualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterTypeQualifier(s)
	}
}

func (s *TypeQualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitTypeQualifier(s)
	}
}

func (p *ObjectiveCParser) TypeQualifier() (localctx ITypeQualifierContext) {
	this := p
	_ = this

	localctx = NewTypeQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ObjectiveCParserRULE_typeQualifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1058)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserCONST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1054)
			p.Match(ObjectiveCParserCONST)
		}

	case ObjectiveCParserVOLATILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1055)
			p.Match(ObjectiveCParserVOLATILE)
		}

	case ObjectiveCParserRESTRICT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1056)
			p.Match(ObjectiveCParserRESTRICT)
		}

	case ObjectiveCParserBYCOPY, ObjectiveCParserBYREF, ObjectiveCParserIN, ObjectiveCParserINOUT, ObjectiveCParserONEWAY, ObjectiveCParserOUT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1057)
			p.ProtocolQualifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProtocolQualifierContext is an interface to support dynamic dispatch.
type IProtocolQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocolQualifierContext differentiates from other interfaces.
	IsProtocolQualifierContext()
}

type ProtocolQualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocolQualifierContext() *ProtocolQualifierContext {
	var p = new(ProtocolQualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_protocolQualifier
	return p
}

func (*ProtocolQualifierContext) IsProtocolQualifierContext() {}

func NewProtocolQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProtocolQualifierContext {
	var p = new(ProtocolQualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_protocolQualifier

	return p
}

func (s *ProtocolQualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ProtocolQualifierContext) IN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIN, 0)
}

func (s *ProtocolQualifierContext) OUT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserOUT, 0)
}

func (s *ProtocolQualifierContext) INOUT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserINOUT, 0)
}

func (s *ProtocolQualifierContext) BYCOPY() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBYCOPY, 0)
}

func (s *ProtocolQualifierContext) BYREF() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBYREF, 0)
}

func (s *ProtocolQualifierContext) ONEWAY() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserONEWAY, 0)
}

func (s *ProtocolQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProtocolQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProtocolQualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterProtocolQualifier(s)
	}
}

func (s *ProtocolQualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitProtocolQualifier(s)
	}
}

func (p *ObjectiveCParser) ProtocolQualifier() (localctx IProtocolQualifierContext) {
	this := p
	_ = this

	localctx = NewProtocolQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ObjectiveCParserRULE_protocolQualifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1060)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(ObjectiveCParserBYCOPY-42))|(1<<(ObjectiveCParserBYREF-42))|(1<<(ObjectiveCParserIN-42))|(1<<(ObjectiveCParserINOUT-42))|(1<<(ObjectiveCParserONEWAY-42))|(1<<(ObjectiveCParserOUT-42)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypeSpecifierContext is an interface to support dynamic dispatch.
type ITypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeSpecifierContext differentiates from other interfaces.
	IsTypeSpecifierContext()
}

type TypeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSpecifierContext() *TypeSpecifierContext {
	var p = new(TypeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_typeSpecifier
	return p
}

func (*TypeSpecifierContext) IsTypeSpecifierContext() {}

func NewTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSpecifierContext {
	var p = new(TypeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_typeSpecifier

	return p
}

func (s *TypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSpecifierContext) VOID() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserVOID, 0)
}

func (s *TypeSpecifierContext) CHAR() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCHAR, 0)
}

func (s *TypeSpecifierContext) SHORT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSHORT, 0)
}

func (s *TypeSpecifierContext) INT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserINT, 0)
}

func (s *TypeSpecifierContext) LONG() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLONG, 0)
}

func (s *TypeSpecifierContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserFLOAT, 0)
}

func (s *TypeSpecifierContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserDOUBLE, 0)
}

func (s *TypeSpecifierContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSIGNED, 0)
}

func (s *TypeSpecifierContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserUNSIGNED, 0)
}

func (s *TypeSpecifierContext) TypeofExpression() ITypeofExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeofExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeofExpressionContext)
}

func (s *TypeSpecifierContext) GenericTypeSpecifier() IGenericTypeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenericTypeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenericTypeSpecifierContext)
}

func (s *TypeSpecifierContext) StructOrUnionSpecifier() IStructOrUnionSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStructOrUnionSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStructOrUnionSpecifierContext)
}

func (s *TypeSpecifierContext) EnumSpecifier() IEnumSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumSpecifierContext)
}

func (s *TypeSpecifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeSpecifierContext) Pointer() IPointerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPointerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPointerContext)
}

func (s *TypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterTypeSpecifier(s)
	}
}

func (s *TypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitTypeSpecifier(s)
	}
}

func (p *ObjectiveCParser) TypeSpecifier() (localctx ITypeSpecifierContext) {
	this := p
	_ = this

	localctx = NewTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ObjectiveCParserRULE_typeSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1079)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1062)
			p.Match(ObjectiveCParserVOID)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1063)
			p.Match(ObjectiveCParserCHAR)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1064)
			p.Match(ObjectiveCParserSHORT)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1065)
			p.Match(ObjectiveCParserINT)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1066)
			p.Match(ObjectiveCParserLONG)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1067)
			p.Match(ObjectiveCParserFLOAT)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1068)
			p.Match(ObjectiveCParserDOUBLE)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1069)
			p.Match(ObjectiveCParserSIGNED)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1070)
			p.Match(ObjectiveCParserUNSIGNED)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1071)
			p.TypeofExpression()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1072)
			p.GenericTypeSpecifier()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1073)
			p.StructOrUnionSpecifier()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1074)
			p.EnumSpecifier()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1075)
			p.Identifier()
		}
		p.SetState(1077)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1076)
				p.Pointer()
			}

		}

	}

	return localctx
}

// ITypeofExpressionContext is an interface to support dynamic dispatch.
type ITypeofExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeofExpressionContext differentiates from other interfaces.
	IsTypeofExpressionContext()
}

type TypeofExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeofExpressionContext() *TypeofExpressionContext {
	var p = new(TypeofExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_typeofExpression
	return p
}

func (*TypeofExpressionContext) IsTypeofExpressionContext() {}

func NewTypeofExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeofExpressionContext {
	var p = new(TypeofExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_typeofExpression

	return p
}

func (s *TypeofExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeofExpressionContext) TYPEOF() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserTYPEOF, 0)
}

func (s *TypeofExpressionContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *TypeofExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeofExpressionContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *TypeofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeofExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterTypeofExpression(s)
	}
}

func (s *TypeofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitTypeofExpression(s)
	}
}

func (p *ObjectiveCParser) TypeofExpression() (localctx ITypeofExpressionContext) {
	this := p
	_ = this

	localctx = NewTypeofExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ObjectiveCParserRULE_typeofExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1081)
		p.Match(ObjectiveCParserTYPEOF)
	}

	{
		p.SetState(1082)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(1083)
		p.expression(0)
	}
	{
		p.SetState(1084)
		p.Match(ObjectiveCParserRP)
	}

	return localctx
}

// IFieldDeclaratorListContext is an interface to support dynamic dispatch.
type IFieldDeclaratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldDeclaratorListContext differentiates from other interfaces.
	IsFieldDeclaratorListContext()
}

type FieldDeclaratorListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclaratorListContext() *FieldDeclaratorListContext {
	var p = new(FieldDeclaratorListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_fieldDeclaratorList
	return p
}

func (*FieldDeclaratorListContext) IsFieldDeclaratorListContext() {}

func NewFieldDeclaratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclaratorListContext {
	var p = new(FieldDeclaratorListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_fieldDeclaratorList

	return p
}

func (s *FieldDeclaratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclaratorListContext) AllFieldDeclarator() []IFieldDeclaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldDeclaratorContext)(nil)).Elem())
	var tst = make([]IFieldDeclaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldDeclaratorContext)
		}
	}

	return tst
}

func (s *FieldDeclaratorListContext) FieldDeclarator(i int) IFieldDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldDeclaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldDeclaratorContext)
}

func (s *FieldDeclaratorListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *FieldDeclaratorListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *FieldDeclaratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclaratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclaratorListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterFieldDeclaratorList(s)
	}
}

func (s *FieldDeclaratorListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitFieldDeclaratorList(s)
	}
}

func (p *ObjectiveCParser) FieldDeclaratorList() (localctx IFieldDeclaratorListContext) {
	this := p
	_ = this

	localctx = NewFieldDeclaratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ObjectiveCParserRULE_fieldDeclaratorList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1086)
		p.FieldDeclarator()
	}
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ObjectiveCParserCOMMA {
		{
			p.SetState(1087)
			p.Match(ObjectiveCParserCOMMA)
		}
		{
			p.SetState(1088)
			p.FieldDeclarator()
		}

		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFieldDeclaratorContext is an interface to support dynamic dispatch.
type IFieldDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldDeclaratorContext differentiates from other interfaces.
	IsFieldDeclaratorContext()
}

type FieldDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclaratorContext() *FieldDeclaratorContext {
	var p = new(FieldDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_fieldDeclarator
	return p
}

func (*FieldDeclaratorContext) IsFieldDeclaratorContext() {}

func NewFieldDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclaratorContext {
	var p = new(FieldDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_fieldDeclarator

	return p
}

func (s *FieldDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *FieldDeclaratorContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOLON, 0)
}

func (s *FieldDeclaratorContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *FieldDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterFieldDeclarator(s)
	}
}

func (s *FieldDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitFieldDeclarator(s)
	}
}

func (p *ObjectiveCParser) FieldDeclarator() (localctx IFieldDeclaratorContext) {
	this := p
	_ = this

	localctx = NewFieldDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ObjectiveCParserRULE_fieldDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1100)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1094)
			p.Declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1096)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113))|(1<<(ObjectiveCParserLP-113)))) != 0) || _la == ObjectiveCParserMUL {
			{
				p.SetState(1095)
				p.Declarator()
			}

		}
		{
			p.SetState(1098)
			p.Match(ObjectiveCParserCOLON)
		}
		{
			p.SetState(1099)
			p.Constant()
		}

	}

	return localctx
}

// IEnumSpecifierContext is an interface to support dynamic dispatch.
type IEnumSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumSpecifierContext differentiates from other interfaces.
	IsEnumSpecifierContext()
}

type EnumSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumSpecifierContext() *EnumSpecifierContext {
	var p = new(EnumSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_enumSpecifier
	return p
}

func (*EnumSpecifierContext) IsEnumSpecifierContext() {}

func NewEnumSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumSpecifierContext {
	var p = new(EnumSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_enumSpecifier

	return p
}

func (s *EnumSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumSpecifierContext) ENUM() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserENUM, 0)
}

func (s *EnumSpecifierContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *EnumSpecifierContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumSpecifierContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACE, 0)
}

func (s *EnumSpecifierContext) EnumeratorList() IEnumeratorListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratorListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeratorListContext)
}

func (s *EnumSpecifierContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACE, 0)
}

func (s *EnumSpecifierContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOLON, 0)
}

func (s *EnumSpecifierContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *EnumSpecifierContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *EnumSpecifierContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, 0)
}

func (s *EnumSpecifierContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *EnumSpecifierContext) NS_OPTIONS() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNS_OPTIONS, 0)
}

func (s *EnumSpecifierContext) NS_ENUM() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNS_ENUM, 0)
}

func (s *EnumSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterEnumSpecifier(s)
	}
}

func (s *EnumSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitEnumSpecifier(s)
	}
}

func (p *ObjectiveCParser) EnumSpecifier() (localctx IEnumSpecifierContext) {
	this := p
	_ = this

	localctx = NewEnumSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ObjectiveCParserRULE_enumSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1133)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserENUM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1102)
			p.Match(ObjectiveCParserENUM)
		}
		p.SetState(1108)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
			p.SetState(1104)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
				{
					p.SetState(1103)
					p.Identifier()
				}

			}
			{
				p.SetState(1106)
				p.Match(ObjectiveCParserCOLON)
			}
			{
				p.SetState(1107)
				p.TypeName()
			}

		}
		p.SetState(1121)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ObjectiveCParserBOOL, ObjectiveCParserClass, ObjectiveCParserBYCOPY, ObjectiveCParserBYREF, ObjectiveCParserID, ObjectiveCParserIMP, ObjectiveCParserIN, ObjectiveCParserINOUT, ObjectiveCParserONEWAY, ObjectiveCParserOUT, ObjectiveCParserPROTOCOL_, ObjectiveCParserSEL, ObjectiveCParserSELF, ObjectiveCParserSUPER, ObjectiveCParserATOMIC, ObjectiveCParserNONATOMIC, ObjectiveCParserRETAIN, ObjectiveCParserAUTORELEASING_QUALIFIER, ObjectiveCParserBLOCK, ObjectiveCParserBRIDGE_RETAINED, ObjectiveCParserBRIDGE_TRANSFER, ObjectiveCParserCOVARIANT, ObjectiveCParserCONTRAVARIANT, ObjectiveCParserDEPRECATED, ObjectiveCParserKINDOF, ObjectiveCParserUNUSED, ObjectiveCParserNULL_UNSPECIFIED, ObjectiveCParserNULLABLE, ObjectiveCParserNONNULL, ObjectiveCParserNULL_RESETTABLE, ObjectiveCParserNS_INLINE, ObjectiveCParserNS_ENUM, ObjectiveCParserNS_OPTIONS, ObjectiveCParserASSIGN, ObjectiveCParserCOPY, ObjectiveCParserGETTER, ObjectiveCParserSETTER, ObjectiveCParserSTRONG, ObjectiveCParserREADONLY, ObjectiveCParserREADWRITE, ObjectiveCParserWEAK, ObjectiveCParserUNSAFE_UNRETAINED, ObjectiveCParserIB_OUTLET, ObjectiveCParserIB_OUTLET_COLLECTION, ObjectiveCParserIB_INSPECTABLE, ObjectiveCParserIB_DESIGNABLE, ObjectiveCParserIDENTIFIER:
			{
				p.SetState(1110)
				p.Identifier()
			}
			p.SetState(1115)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1111)
					p.Match(ObjectiveCParserLBRACE)
				}
				{
					p.SetState(1112)
					p.EnumeratorList()
				}
				{
					p.SetState(1113)
					p.Match(ObjectiveCParserRBRACE)
				}

			}

		case ObjectiveCParserLBRACE:
			{
				p.SetState(1117)
				p.Match(ObjectiveCParserLBRACE)
			}
			{
				p.SetState(1118)
				p.EnumeratorList()
			}
			{
				p.SetState(1119)
				p.Match(ObjectiveCParserRBRACE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case ObjectiveCParserNS_ENUM, ObjectiveCParserNS_OPTIONS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1123)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ObjectiveCParserNS_ENUM || _la == ObjectiveCParserNS_OPTIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1124)
			p.Match(ObjectiveCParserLP)
		}
		{
			p.SetState(1125)
			p.TypeName()
		}
		{
			p.SetState(1126)
			p.Match(ObjectiveCParserCOMMA)
		}
		{
			p.SetState(1127)
			p.Identifier()
		}
		{
			p.SetState(1128)
			p.Match(ObjectiveCParserRP)
		}
		{
			p.SetState(1129)
			p.Match(ObjectiveCParserLBRACE)
		}
		{
			p.SetState(1130)
			p.EnumeratorList()
		}
		{
			p.SetState(1131)
			p.Match(ObjectiveCParserRBRACE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnumeratorListContext is an interface to support dynamic dispatch.
type IEnumeratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratorListContext differentiates from other interfaces.
	IsEnumeratorListContext()
}

type EnumeratorListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorListContext() *EnumeratorListContext {
	var p = new(EnumeratorListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_enumeratorList
	return p
}

func (*EnumeratorListContext) IsEnumeratorListContext() {}

func NewEnumeratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorListContext {
	var p = new(EnumeratorListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_enumeratorList

	return p
}

func (s *EnumeratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorListContext) AllEnumerator() []IEnumeratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumeratorContext)(nil)).Elem())
	var tst = make([]IEnumeratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumeratorContext)
		}
	}

	return tst
}

func (s *EnumeratorListContext) Enumerator(i int) IEnumeratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumeratorContext)
}

func (s *EnumeratorListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *EnumeratorListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *EnumeratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterEnumeratorList(s)
	}
}

func (s *EnumeratorListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitEnumeratorList(s)
	}
}

func (p *ObjectiveCParser) EnumeratorList() (localctx IEnumeratorListContext) {
	this := p
	_ = this

	localctx = NewEnumeratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ObjectiveCParserRULE_enumeratorList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1135)
		p.Enumerator()
	}
	p.SetState(1140)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1136)
				p.Match(ObjectiveCParserCOMMA)
			}
			{
				p.SetState(1137)
				p.Enumerator()
			}

		}
		p.SetState(1142)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext())
	}
	p.SetState(1144)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserCOMMA {
		{
			p.SetState(1143)
			p.Match(ObjectiveCParserCOMMA)
		}

	}

	return localctx
}

// IEnumeratorContext is an interface to support dynamic dispatch.
type IEnumeratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratorContext differentiates from other interfaces.
	IsEnumeratorContext()
}

type EnumeratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorContext() *EnumeratorContext {
	var p = new(EnumeratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_enumerator
	return p
}

func (*EnumeratorContext) IsEnumeratorContext() {}

func NewEnumeratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorContext {
	var p = new(EnumeratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_enumerator

	return p
}

func (s *EnumeratorContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorContext) EnumeratorIdentifier() IEnumeratorIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratorIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeratorIdentifierContext)
}

func (s *EnumeratorContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserASSIGNMENT, 0)
}

func (s *EnumeratorContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnumeratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterEnumerator(s)
	}
}

func (s *EnumeratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitEnumerator(s)
	}
}

func (p *ObjectiveCParser) Enumerator() (localctx IEnumeratorContext) {
	this := p
	_ = this

	localctx = NewEnumeratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ObjectiveCParserRULE_enumerator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1146)
		p.EnumeratorIdentifier()
	}
	p.SetState(1149)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserASSIGNMENT {
		{
			p.SetState(1147)
			p.Match(ObjectiveCParserASSIGNMENT)
		}
		{
			p.SetState(1148)
			p.expression(0)
		}

	}

	return localctx
}

// IEnumeratorIdentifierContext is an interface to support dynamic dispatch.
type IEnumeratorIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratorIdentifierContext differentiates from other interfaces.
	IsEnumeratorIdentifierContext()
}

type EnumeratorIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorIdentifierContext() *EnumeratorIdentifierContext {
	var p = new(EnumeratorIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_enumeratorIdentifier
	return p
}

func (*EnumeratorIdentifierContext) IsEnumeratorIdentifierContext() {}

func NewEnumeratorIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorIdentifierContext {
	var p = new(EnumeratorIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_enumeratorIdentifier

	return p
}

func (s *EnumeratorIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorIdentifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumeratorIdentifierContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserDEFAULT, 0)
}

func (s *EnumeratorIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterEnumeratorIdentifier(s)
	}
}

func (s *EnumeratorIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitEnumeratorIdentifier(s)
	}
}

func (p *ObjectiveCParser) EnumeratorIdentifier() (localctx IEnumeratorIdentifierContext) {
	this := p
	_ = this

	localctx = NewEnumeratorIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ObjectiveCParserRULE_enumeratorIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1153)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserBOOL, ObjectiveCParserClass, ObjectiveCParserBYCOPY, ObjectiveCParserBYREF, ObjectiveCParserID, ObjectiveCParserIMP, ObjectiveCParserIN, ObjectiveCParserINOUT, ObjectiveCParserONEWAY, ObjectiveCParserOUT, ObjectiveCParserPROTOCOL_, ObjectiveCParserSEL, ObjectiveCParserSELF, ObjectiveCParserSUPER, ObjectiveCParserATOMIC, ObjectiveCParserNONATOMIC, ObjectiveCParserRETAIN, ObjectiveCParserAUTORELEASING_QUALIFIER, ObjectiveCParserBLOCK, ObjectiveCParserBRIDGE_RETAINED, ObjectiveCParserBRIDGE_TRANSFER, ObjectiveCParserCOVARIANT, ObjectiveCParserCONTRAVARIANT, ObjectiveCParserDEPRECATED, ObjectiveCParserKINDOF, ObjectiveCParserUNUSED, ObjectiveCParserNULL_UNSPECIFIED, ObjectiveCParserNULLABLE, ObjectiveCParserNONNULL, ObjectiveCParserNULL_RESETTABLE, ObjectiveCParserNS_INLINE, ObjectiveCParserNS_ENUM, ObjectiveCParserNS_OPTIONS, ObjectiveCParserASSIGN, ObjectiveCParserCOPY, ObjectiveCParserGETTER, ObjectiveCParserSETTER, ObjectiveCParserSTRONG, ObjectiveCParserREADONLY, ObjectiveCParserREADWRITE, ObjectiveCParserWEAK, ObjectiveCParserUNSAFE_UNRETAINED, ObjectiveCParserIB_OUTLET, ObjectiveCParserIB_OUTLET_COLLECTION, ObjectiveCParserIB_INSPECTABLE, ObjectiveCParserIB_DESIGNABLE, ObjectiveCParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1151)
			p.Identifier()
		}

	case ObjectiveCParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1152)
			p.Match(ObjectiveCParserDEFAULT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDirectDeclaratorContext is an interface to support dynamic dispatch.
type IDirectDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirectDeclaratorContext differentiates from other interfaces.
	IsDirectDeclaratorContext()
}

type DirectDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectDeclaratorContext() *DirectDeclaratorContext {
	var p = new(DirectDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_directDeclarator
	return p
}

func (*DirectDeclaratorContext) IsDirectDeclaratorContext() {}

func NewDirectDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectDeclaratorContext {
	var p = new(DirectDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_directDeclarator

	return p
}

func (s *DirectDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectDeclaratorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DirectDeclaratorContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *DirectDeclaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *DirectDeclaratorContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *DirectDeclaratorContext) AllDeclaratorSuffix() []IDeclaratorSuffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclaratorSuffixContext)(nil)).Elem())
	var tst = make([]IDeclaratorSuffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclaratorSuffixContext)
		}
	}

	return tst
}

func (s *DirectDeclaratorContext) DeclaratorSuffix(i int) IDeclaratorSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorSuffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorSuffixContext)
}

func (s *DirectDeclaratorContext) BITXOR() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBITXOR, 0)
}

func (s *DirectDeclaratorContext) BlockParameters() IBlockParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockParametersContext)
}

func (s *DirectDeclaratorContext) NullabilitySpecifier() INullabilitySpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullabilitySpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullabilitySpecifierContext)
}

func (s *DirectDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterDirectDeclarator(s)
	}
}

func (s *DirectDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitDirectDeclarator(s)
	}
}

func (p *ObjectiveCParser) DirectDeclarator() (localctx IDirectDeclaratorContext) {
	this := p
	_ = this

	localctx = NewDirectDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ObjectiveCParserRULE_directDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1178)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1160)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ObjectiveCParserBOOL, ObjectiveCParserClass, ObjectiveCParserBYCOPY, ObjectiveCParserBYREF, ObjectiveCParserID, ObjectiveCParserIMP, ObjectiveCParserIN, ObjectiveCParserINOUT, ObjectiveCParserONEWAY, ObjectiveCParserOUT, ObjectiveCParserPROTOCOL_, ObjectiveCParserSEL, ObjectiveCParserSELF, ObjectiveCParserSUPER, ObjectiveCParserATOMIC, ObjectiveCParserNONATOMIC, ObjectiveCParserRETAIN, ObjectiveCParserAUTORELEASING_QUALIFIER, ObjectiveCParserBLOCK, ObjectiveCParserBRIDGE_RETAINED, ObjectiveCParserBRIDGE_TRANSFER, ObjectiveCParserCOVARIANT, ObjectiveCParserCONTRAVARIANT, ObjectiveCParserDEPRECATED, ObjectiveCParserKINDOF, ObjectiveCParserUNUSED, ObjectiveCParserNULL_UNSPECIFIED, ObjectiveCParserNULLABLE, ObjectiveCParserNONNULL, ObjectiveCParserNULL_RESETTABLE, ObjectiveCParserNS_INLINE, ObjectiveCParserNS_ENUM, ObjectiveCParserNS_OPTIONS, ObjectiveCParserASSIGN, ObjectiveCParserCOPY, ObjectiveCParserGETTER, ObjectiveCParserSETTER, ObjectiveCParserSTRONG, ObjectiveCParserREADONLY, ObjectiveCParserREADWRITE, ObjectiveCParserWEAK, ObjectiveCParserUNSAFE_UNRETAINED, ObjectiveCParserIB_OUTLET, ObjectiveCParserIB_OUTLET_COLLECTION, ObjectiveCParserIB_INSPECTABLE, ObjectiveCParserIB_DESIGNABLE, ObjectiveCParserIDENTIFIER:
			{
				p.SetState(1155)
				p.Identifier()
			}

		case ObjectiveCParserLP:
			{
				p.SetState(1156)
				p.Match(ObjectiveCParserLP)
			}
			{
				p.SetState(1157)
				p.Declarator()
			}
			{
				p.SetState(1158)
				p.Match(ObjectiveCParserRP)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(1165)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ObjectiveCParserLBRACK {
			{
				p.SetState(1162)
				p.DeclaratorSuffix()
			}

			p.SetState(1167)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1168)
			p.Match(ObjectiveCParserLP)
		}
		{
			p.SetState(1169)
			p.Match(ObjectiveCParserBITXOR)
		}
		p.SetState(1171)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1170)
				p.NullabilitySpecifier()
			}

		}
		p.SetState(1174)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
			{
				p.SetState(1173)
				p.Identifier()
			}

		}
		{
			p.SetState(1176)
			p.Match(ObjectiveCParserRP)
		}
		{
			p.SetState(1177)
			p.BlockParameters()
		}

	}

	return localctx
}

// IDeclaratorSuffixContext is an interface to support dynamic dispatch.
type IDeclaratorSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaratorSuffixContext differentiates from other interfaces.
	IsDeclaratorSuffixContext()
}

type DeclaratorSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratorSuffixContext() *DeclaratorSuffixContext {
	var p = new(DeclaratorSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_declaratorSuffix
	return p
}

func (*DeclaratorSuffixContext) IsDeclaratorSuffixContext() {}

func NewDeclaratorSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratorSuffixContext {
	var p = new(DeclaratorSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_declaratorSuffix

	return p
}

func (s *DeclaratorSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratorSuffixContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACK, 0)
}

func (s *DeclaratorSuffixContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACK, 0)
}

func (s *DeclaratorSuffixContext) ConstantExpression() IConstantExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *DeclaratorSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratorSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaratorSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterDeclaratorSuffix(s)
	}
}

func (s *DeclaratorSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitDeclaratorSuffix(s)
	}
}

func (p *ObjectiveCParser) DeclaratorSuffix() (localctx IDeclaratorSuffixContext) {
	this := p
	_ = this

	localctx = NewDeclaratorSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ObjectiveCParserRULE_declaratorSuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1180)
		p.Match(ObjectiveCParserLBRACK)
	}
	p.SetState(1182)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(ObjectiveCParserTRUE-38))|(1<<(ObjectiveCParserFALSE-38))|(1<<(ObjectiveCParserBOOL-38))|(1<<(ObjectiveCParserClass-38))|(1<<(ObjectiveCParserBYCOPY-38))|(1<<(ObjectiveCParserBYREF-38))|(1<<(ObjectiveCParserID-38))|(1<<(ObjectiveCParserIMP-38))|(1<<(ObjectiveCParserIN-38))|(1<<(ObjectiveCParserINOUT-38))|(1<<(ObjectiveCParserNIL-38))|(1<<(ObjectiveCParserNO-38))|(1<<(ObjectiveCParserNULL_-38))|(1<<(ObjectiveCParserONEWAY-38))|(1<<(ObjectiveCParserOUT-38))|(1<<(ObjectiveCParserPROTOCOL_-38))|(1<<(ObjectiveCParserSEL-38))|(1<<(ObjectiveCParserSELF-38))|(1<<(ObjectiveCParserSUPER-38))|(1<<(ObjectiveCParserYES-38)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) || (((_la-152)&-(0x1f+1)) == 0 && ((1<<uint((_la-152)))&((1<<(ObjectiveCParserADD-152))|(1<<(ObjectiveCParserSUB-152))|(1<<(ObjectiveCParserCHARACTER_LITERAL-152))|(1<<(ObjectiveCParserHEX_LITERAL-152))|(1<<(ObjectiveCParserOCTAL_LITERAL-152))|(1<<(ObjectiveCParserBINARY_LITERAL-152))|(1<<(ObjectiveCParserDECIMAL_LITERAL-152))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-152)))) != 0) {
		{
			p.SetState(1181)
			p.ConstantExpression()
		}

	}
	{
		p.SetState(1184)
		p.Match(ObjectiveCParserRBRACK)
	}

	return localctx
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_parameterList
	return p
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) ParameterDeclarationList() IParameterDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterDeclarationListContext)
}

func (s *ParameterListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, 0)
}

func (s *ParameterListContext) ELIPSIS() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserELIPSIS, 0)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (p *ObjectiveCParser) ParameterList() (localctx IParameterListContext) {
	this := p
	_ = this

	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ObjectiveCParserRULE_parameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1186)
		p.ParameterDeclarationList()
	}
	p.SetState(1189)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserCOMMA {
		{
			p.SetState(1187)
			p.Match(ObjectiveCParserCOMMA)
		}
		{
			p.SetState(1188)
			p.Match(ObjectiveCParserELIPSIS)
		}

	}

	return localctx
}

// IPointerContext is an interface to support dynamic dispatch.
type IPointerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPointerContext differentiates from other interfaces.
	IsPointerContext()
}

type PointerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerContext() *PointerContext {
	var p = new(PointerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_pointer
	return p
}

func (*PointerContext) IsPointerContext() {}

func NewPointerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerContext {
	var p = new(PointerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_pointer

	return p
}

func (s *PointerContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerContext) MUL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserMUL, 0)
}

func (s *PointerContext) DeclarationSpecifiers() IDeclarationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifiersContext)
}

func (s *PointerContext) Pointer() IPointerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPointerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPointerContext)
}

func (s *PointerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterPointer(s)
	}
}

func (s *PointerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitPointer(s)
	}
}

func (p *ObjectiveCParser) Pointer() (localctx IPointerContext) {
	this := p
	_ = this

	localctx = NewPointerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ObjectiveCParserRULE_pointer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1191)
		p.Match(ObjectiveCParserMUL)
	}
	p.SetState(1193)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1192)
			p.DeclarationSpecifiers()
		}

	}
	p.SetState(1196)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1195)
			p.Pointer()
		}

	}

	return localctx
}

// IMacroContext is an interface to support dynamic dispatch.
type IMacroContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMacroContext differentiates from other interfaces.
	IsMacroContext()
}

type MacroContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacroContext() *MacroContext {
	var p = new(MacroContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_macro
	return p
}

func (*MacroContext) IsMacroContext() {}

func NewMacroContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MacroContext {
	var p = new(MacroContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_macro

	return p
}

func (s *MacroContext) GetParser() antlr.Parser { return s.parser }

func (s *MacroContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MacroContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *MacroContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem())
	var tst = make([]IPrimaryExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrimaryExpressionContext)
		}
	}

	return tst
}

func (s *MacroContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *MacroContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *MacroContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *MacroContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *MacroContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MacroContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MacroContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterMacro(s)
	}
}

func (s *MacroContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitMacro(s)
	}
}

func (p *ObjectiveCParser) Macro() (localctx IMacroContext) {
	this := p
	_ = this

	localctx = NewMacroContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ObjectiveCParserRULE_macro)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1198)
		p.Identifier()
	}
	p.SetState(1210)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserLP {
		{
			p.SetState(1199)
			p.Match(ObjectiveCParserLP)
		}
		{
			p.SetState(1200)
			p.PrimaryExpression()
		}
		p.SetState(1205)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ObjectiveCParserCOMMA {
			{
				p.SetState(1201)
				p.Match(ObjectiveCParserCOMMA)
			}
			{
				p.SetState(1202)
				p.PrimaryExpression()
			}

			p.SetState(1207)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1208)
			p.Match(ObjectiveCParserRP)
		}

	}

	return localctx
}

// IArrayInitializerContext is an interface to support dynamic dispatch.
type IArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayInitializerContext differentiates from other interfaces.
	IsArrayInitializerContext()
}

type ArrayInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayInitializerContext() *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_arrayInitializer
	return p
}

func (*ArrayInitializerContext) IsArrayInitializerContext() {}

func NewArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_arrayInitializer

	return p
}

func (s *ArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACE, 0)
}

func (s *ArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACE, 0)
}

func (s *ArrayInitializerContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *ArrayInitializerContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, 0)
}

func (s *ArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterArrayInitializer(s)
	}
}

func (s *ArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitArrayInitializer(s)
	}
}

func (p *ObjectiveCParser) ArrayInitializer() (localctx IArrayInitializerContext) {
	this := p
	_ = this

	localctx = NewArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ObjectiveCParserRULE_arrayInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1212)
		p.Match(ObjectiveCParserLBRACE)
	}
	p.SetState(1217)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-25)&-(0x1f+1)) == 0 && ((1<<uint((_la-25)))&((1<<(ObjectiveCParserSIZEOF-25))|(1<<(ObjectiveCParserTRUE-25))|(1<<(ObjectiveCParserFALSE-25))|(1<<(ObjectiveCParserBOOL-25))|(1<<(ObjectiveCParserClass-25))|(1<<(ObjectiveCParserBYCOPY-25))|(1<<(ObjectiveCParserBYREF-25))|(1<<(ObjectiveCParserID-25))|(1<<(ObjectiveCParserIMP-25))|(1<<(ObjectiveCParserIN-25))|(1<<(ObjectiveCParserINOUT-25))|(1<<(ObjectiveCParserNIL-25))|(1<<(ObjectiveCParserNO-25))|(1<<(ObjectiveCParserNULL_-25))|(1<<(ObjectiveCParserONEWAY-25))|(1<<(ObjectiveCParserOUT-25))|(1<<(ObjectiveCParserPROTOCOL_-25))|(1<<(ObjectiveCParserSEL-25))|(1<<(ObjectiveCParserSELF-25))|(1<<(ObjectiveCParserSUPER-25)))) != 0) || (((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(ObjectiveCParserYES-57))|(1<<(ObjectiveCParserENCODE-57))|(1<<(ObjectiveCParserPROTOCOL-57))|(1<<(ObjectiveCParserSELECTOR-57))|(1<<(ObjectiveCParserATOMIC-57))|(1<<(ObjectiveCParserNONATOMIC-57))|(1<<(ObjectiveCParserRETAIN-57))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-57))|(1<<(ObjectiveCParserBLOCK-57))|(1<<(ObjectiveCParserBRIDGE_RETAINED-57)))) != 0) || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(ObjectiveCParserBRIDGE_TRANSFER-89))|(1<<(ObjectiveCParserCOVARIANT-89))|(1<<(ObjectiveCParserCONTRAVARIANT-89))|(1<<(ObjectiveCParserDEPRECATED-89))|(1<<(ObjectiveCParserKINDOF-89))|(1<<(ObjectiveCParserUNUSED-89))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-89))|(1<<(ObjectiveCParserNULLABLE-89))|(1<<(ObjectiveCParserNONNULL-89))|(1<<(ObjectiveCParserNULL_RESETTABLE-89))|(1<<(ObjectiveCParserNS_INLINE-89))|(1<<(ObjectiveCParserNS_ENUM-89))|(1<<(ObjectiveCParserNS_OPTIONS-89))|(1<<(ObjectiveCParserASSIGN-89))|(1<<(ObjectiveCParserCOPY-89))|(1<<(ObjectiveCParserGETTER-89))|(1<<(ObjectiveCParserSETTER-89))|(1<<(ObjectiveCParserSTRONG-89))|(1<<(ObjectiveCParserREADONLY-89))|(1<<(ObjectiveCParserREADWRITE-89))|(1<<(ObjectiveCParserWEAK-89))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-89))|(1<<(ObjectiveCParserIB_OUTLET-89))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-89))|(1<<(ObjectiveCParserIB_INSPECTABLE-89))|(1<<(ObjectiveCParserIB_DESIGNABLE-89)))) != 0) || (((_la-125)&-(0x1f+1)) == 0 && ((1<<uint((_la-125)))&((1<<(ObjectiveCParserIDENTIFIER-125))|(1<<(ObjectiveCParserLP-125))|(1<<(ObjectiveCParserLBRACK-125))|(1<<(ObjectiveCParserAT-125))|(1<<(ObjectiveCParserBANG-125))|(1<<(ObjectiveCParserTILDE-125))|(1<<(ObjectiveCParserINC-125))|(1<<(ObjectiveCParserDEC-125))|(1<<(ObjectiveCParserADD-125))|(1<<(ObjectiveCParserSUB-125))|(1<<(ObjectiveCParserMUL-125))|(1<<(ObjectiveCParserBITAND-125)))) != 0) || (((_la-158)&-(0x1f+1)) == 0 && ((1<<uint((_la-158)))&((1<<(ObjectiveCParserBITXOR-158))|(1<<(ObjectiveCParserCHARACTER_LITERAL-158))|(1<<(ObjectiveCParserSTRING_START-158))|(1<<(ObjectiveCParserHEX_LITERAL-158))|(1<<(ObjectiveCParserOCTAL_LITERAL-158))|(1<<(ObjectiveCParserBINARY_LITERAL-158))|(1<<(ObjectiveCParserDECIMAL_LITERAL-158))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-158)))) != 0) {
		{
			p.SetState(1213)
			p.Expressions()
		}
		p.SetState(1215)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ObjectiveCParserCOMMA {
			{
				p.SetState(1214)
				p.Match(ObjectiveCParserCOMMA)
			}

		}

	}
	{
		p.SetState(1219)
		p.Match(ObjectiveCParserRBRACE)
	}

	return localctx
}

// IStructInitializerContext is an interface to support dynamic dispatch.
type IStructInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructInitializerContext differentiates from other interfaces.
	IsStructInitializerContext()
}

type StructInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructInitializerContext() *StructInitializerContext {
	var p = new(StructInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_structInitializer
	return p
}

func (*StructInitializerContext) IsStructInitializerContext() {}

func NewStructInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructInitializerContext {
	var p = new(StructInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_structInitializer

	return p
}

func (s *StructInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *StructInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACE, 0)
}

func (s *StructInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACE, 0)
}

func (s *StructInitializerContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserDOT)
}

func (s *StructInitializerContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserDOT, i)
}

func (s *StructInitializerContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *StructInitializerContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StructInitializerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *StructInitializerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *StructInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterStructInitializer(s)
	}
}

func (s *StructInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitStructInitializer(s)
	}
}

func (p *ObjectiveCParser) StructInitializer() (localctx IStructInitializerContext) {
	this := p
	_ = this

	localctx = NewStructInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ObjectiveCParserRULE_structInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1221)
		p.Match(ObjectiveCParserLBRACE)
	}
	p.SetState(1235)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserDOT {
		{
			p.SetState(1222)
			p.Match(ObjectiveCParserDOT)
		}
		{
			p.SetState(1223)
			p.expression(0)
		}
		p.SetState(1229)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1224)
					p.Match(ObjectiveCParserCOMMA)
				}
				{
					p.SetState(1225)
					p.Match(ObjectiveCParserDOT)
				}
				{
					p.SetState(1226)
					p.expression(0)
				}

			}
			p.SetState(1231)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext())
		}
		p.SetState(1233)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ObjectiveCParserCOMMA {
			{
				p.SetState(1232)
				p.Match(ObjectiveCParserCOMMA)
			}

		}

	}
	{
		p.SetState(1237)
		p.Match(ObjectiveCParserRBRACE)
	}

	return localctx
}

// IInitializerListContext is an interface to support dynamic dispatch.
type IInitializerListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializerListContext differentiates from other interfaces.
	IsInitializerListContext()
}

type InitializerListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerListContext() *InitializerListContext {
	var p = new(InitializerListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_initializerList
	return p
}

func (*InitializerListContext) IsInitializerListContext() {}

func NewInitializerListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerListContext {
	var p = new(InitializerListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_initializerList

	return p
}

func (s *InitializerListContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerListContext) AllInitializer() []IInitializerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInitializerContext)(nil)).Elem())
	var tst = make([]IInitializerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInitializerContext)
		}
	}

	return tst
}

func (s *InitializerListContext) Initializer(i int) IInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *InitializerListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *InitializerListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *InitializerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterInitializerList(s)
	}
}

func (s *InitializerListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitInitializerList(s)
	}
}

func (p *ObjectiveCParser) InitializerList() (localctx IInitializerListContext) {
	this := p
	_ = this

	localctx = NewInitializerListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ObjectiveCParserRULE_initializerList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1239)
		p.Initializer()
	}
	p.SetState(1244)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1240)
				p.Match(ObjectiveCParserCOMMA)
			}
			{
				p.SetState(1241)
				p.Initializer()
			}

		}
		p.SetState(1246)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())
	}
	p.SetState(1248)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserCOMMA {
		{
			p.SetState(1247)
			p.Match(ObjectiveCParserCOMMA)
		}

	}

	return localctx
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_typeName
	return p
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) SpecifierQualifierList() ISpecifierQualifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecifierQualifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecifierQualifierListContext)
}

func (s *TypeNameContext) AbstractDeclarator() IAbstractDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstractDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclaratorContext)
}

func (s *TypeNameContext) BlockType() IBlockTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockTypeContext)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (p *ObjectiveCParser) TypeName() (localctx ITypeNameContext) {
	this := p
	_ = this

	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ObjectiveCParserRULE_typeName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1255)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1250)
			p.SpecifierQualifierList()
		}
		p.SetState(1252)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-126)&-(0x1f+1)) == 0 && ((1<<uint((_la-126)))&((1<<(ObjectiveCParserLP-126))|(1<<(ObjectiveCParserLBRACK-126))|(1<<(ObjectiveCParserMUL-126)))) != 0 {
			{
				p.SetState(1251)
				p.AbstractDeclarator()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1254)
			p.BlockType()
		}

	}

	return localctx
}

// IAbstractDeclaratorContext is an interface to support dynamic dispatch.
type IAbstractDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstractDeclaratorContext differentiates from other interfaces.
	IsAbstractDeclaratorContext()
}

type AbstractDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstractDeclaratorContext() *AbstractDeclaratorContext {
	var p = new(AbstractDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_abstractDeclarator
	return p
}

func (*AbstractDeclaratorContext) IsAbstractDeclaratorContext() {}

func NewAbstractDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbstractDeclaratorContext {
	var p = new(AbstractDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_abstractDeclarator

	return p
}

func (s *AbstractDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *AbstractDeclaratorContext) Pointer() IPointerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPointerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPointerContext)
}

func (s *AbstractDeclaratorContext) AbstractDeclarator() IAbstractDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstractDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclaratorContext)
}

func (s *AbstractDeclaratorContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *AbstractDeclaratorContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *AbstractDeclaratorContext) AllAbstractDeclaratorSuffix() []IAbstractDeclaratorSuffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAbstractDeclaratorSuffixContext)(nil)).Elem())
	var tst = make([]IAbstractDeclaratorSuffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAbstractDeclaratorSuffixContext)
		}
	}

	return tst
}

func (s *AbstractDeclaratorContext) AbstractDeclaratorSuffix(i int) IAbstractDeclaratorSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstractDeclaratorSuffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclaratorSuffixContext)
}

func (s *AbstractDeclaratorContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserLBRACK)
}

func (s *AbstractDeclaratorContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACK, i)
}

func (s *AbstractDeclaratorContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserRBRACK)
}

func (s *AbstractDeclaratorContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACK, i)
}

func (s *AbstractDeclaratorContext) AllConstantExpression() []IConstantExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstantExpressionContext)(nil)).Elem())
	var tst = make([]IConstantExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstantExpressionContext)
		}
	}

	return tst
}

func (s *AbstractDeclaratorContext) ConstantExpression(i int) IConstantExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *AbstractDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbstractDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbstractDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterAbstractDeclarator(s)
	}
}

func (s *AbstractDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitAbstractDeclarator(s)
	}
}

func (p *ObjectiveCParser) AbstractDeclarator() (localctx IAbstractDeclaratorContext) {
	this := p
	_ = this

	localctx = NewAbstractDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, ObjectiveCParserRULE_abstractDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1280)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserMUL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1257)
			p.Pointer()
		}
		p.SetState(1259)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-126)&-(0x1f+1)) == 0 && ((1<<uint((_la-126)))&((1<<(ObjectiveCParserLP-126))|(1<<(ObjectiveCParserLBRACK-126))|(1<<(ObjectiveCParserMUL-126)))) != 0 {
			{
				p.SetState(1258)
				p.AbstractDeclarator()
			}

		}

	case ObjectiveCParserLP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1261)
			p.Match(ObjectiveCParserLP)
		}
		p.SetState(1263)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-126)&-(0x1f+1)) == 0 && ((1<<uint((_la-126)))&((1<<(ObjectiveCParserLP-126))|(1<<(ObjectiveCParserLBRACK-126))|(1<<(ObjectiveCParserMUL-126)))) != 0 {
			{
				p.SetState(1262)
				p.AbstractDeclarator()
			}

		}
		{
			p.SetState(1265)
			p.Match(ObjectiveCParserRP)
		}
		p.SetState(1267)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ObjectiveCParserLP || _la == ObjectiveCParserLBRACK {
			{
				p.SetState(1266)
				p.AbstractDeclaratorSuffix()
			}

			p.SetState(1269)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case ObjectiveCParserLBRACK:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1276)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ObjectiveCParserLBRACK {
			{
				p.SetState(1271)
				p.Match(ObjectiveCParserLBRACK)
			}
			p.SetState(1273)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(ObjectiveCParserTRUE-38))|(1<<(ObjectiveCParserFALSE-38))|(1<<(ObjectiveCParserBOOL-38))|(1<<(ObjectiveCParserClass-38))|(1<<(ObjectiveCParserBYCOPY-38))|(1<<(ObjectiveCParserBYREF-38))|(1<<(ObjectiveCParserID-38))|(1<<(ObjectiveCParserIMP-38))|(1<<(ObjectiveCParserIN-38))|(1<<(ObjectiveCParserINOUT-38))|(1<<(ObjectiveCParserNIL-38))|(1<<(ObjectiveCParserNO-38))|(1<<(ObjectiveCParserNULL_-38))|(1<<(ObjectiveCParserONEWAY-38))|(1<<(ObjectiveCParserOUT-38))|(1<<(ObjectiveCParserPROTOCOL_-38))|(1<<(ObjectiveCParserSEL-38))|(1<<(ObjectiveCParserSELF-38))|(1<<(ObjectiveCParserSUPER-38))|(1<<(ObjectiveCParserYES-38)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) || (((_la-152)&-(0x1f+1)) == 0 && ((1<<uint((_la-152)))&((1<<(ObjectiveCParserADD-152))|(1<<(ObjectiveCParserSUB-152))|(1<<(ObjectiveCParserCHARACTER_LITERAL-152))|(1<<(ObjectiveCParserHEX_LITERAL-152))|(1<<(ObjectiveCParserOCTAL_LITERAL-152))|(1<<(ObjectiveCParserBINARY_LITERAL-152))|(1<<(ObjectiveCParserDECIMAL_LITERAL-152))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-152)))) != 0) {
				{
					p.SetState(1272)
					p.ConstantExpression()
				}

			}
			{
				p.SetState(1275)
				p.Match(ObjectiveCParserRBRACK)
			}

			p.SetState(1278)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAbstractDeclaratorSuffixContext is an interface to support dynamic dispatch.
type IAbstractDeclaratorSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstractDeclaratorSuffixContext differentiates from other interfaces.
	IsAbstractDeclaratorSuffixContext()
}

type AbstractDeclaratorSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstractDeclaratorSuffixContext() *AbstractDeclaratorSuffixContext {
	var p = new(AbstractDeclaratorSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_abstractDeclaratorSuffix
	return p
}

func (*AbstractDeclaratorSuffixContext) IsAbstractDeclaratorSuffixContext() {}

func NewAbstractDeclaratorSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbstractDeclaratorSuffixContext {
	var p = new(AbstractDeclaratorSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_abstractDeclaratorSuffix

	return p
}

func (s *AbstractDeclaratorSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *AbstractDeclaratorSuffixContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACK, 0)
}

func (s *AbstractDeclaratorSuffixContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACK, 0)
}

func (s *AbstractDeclaratorSuffixContext) ConstantExpression() IConstantExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *AbstractDeclaratorSuffixContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *AbstractDeclaratorSuffixContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *AbstractDeclaratorSuffixContext) ParameterDeclarationList() IParameterDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterDeclarationListContext)
}

func (s *AbstractDeclaratorSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbstractDeclaratorSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbstractDeclaratorSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterAbstractDeclaratorSuffix(s)
	}
}

func (s *AbstractDeclaratorSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitAbstractDeclaratorSuffix(s)
	}
}

func (p *ObjectiveCParser) AbstractDeclaratorSuffix() (localctx IAbstractDeclaratorSuffixContext) {
	this := p
	_ = this

	localctx = NewAbstractDeclaratorSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, ObjectiveCParserRULE_abstractDeclaratorSuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1292)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserLBRACK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1282)
			p.Match(ObjectiveCParserLBRACK)
		}
		p.SetState(1284)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(ObjectiveCParserTRUE-38))|(1<<(ObjectiveCParserFALSE-38))|(1<<(ObjectiveCParserBOOL-38))|(1<<(ObjectiveCParserClass-38))|(1<<(ObjectiveCParserBYCOPY-38))|(1<<(ObjectiveCParserBYREF-38))|(1<<(ObjectiveCParserID-38))|(1<<(ObjectiveCParserIMP-38))|(1<<(ObjectiveCParserIN-38))|(1<<(ObjectiveCParserINOUT-38))|(1<<(ObjectiveCParserNIL-38))|(1<<(ObjectiveCParserNO-38))|(1<<(ObjectiveCParserNULL_-38))|(1<<(ObjectiveCParserONEWAY-38))|(1<<(ObjectiveCParserOUT-38))|(1<<(ObjectiveCParserPROTOCOL_-38))|(1<<(ObjectiveCParserSEL-38))|(1<<(ObjectiveCParserSELF-38))|(1<<(ObjectiveCParserSUPER-38))|(1<<(ObjectiveCParserYES-38)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) || (((_la-152)&-(0x1f+1)) == 0 && ((1<<uint((_la-152)))&((1<<(ObjectiveCParserADD-152))|(1<<(ObjectiveCParserSUB-152))|(1<<(ObjectiveCParserCHARACTER_LITERAL-152))|(1<<(ObjectiveCParserHEX_LITERAL-152))|(1<<(ObjectiveCParserOCTAL_LITERAL-152))|(1<<(ObjectiveCParserBINARY_LITERAL-152))|(1<<(ObjectiveCParserDECIMAL_LITERAL-152))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-152)))) != 0) {
			{
				p.SetState(1283)
				p.ConstantExpression()
			}

		}
		{
			p.SetState(1286)
			p.Match(ObjectiveCParserRBRACK)
		}

	case ObjectiveCParserLP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1287)
			p.Match(ObjectiveCParserLP)
		}
		p.SetState(1289)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserAUTO)|(1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserEXTERN)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserREGISTER)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSTATIC)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserATTRIBUTE-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-81))|(1<<(ObjectiveCParserTYPEOF-81))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserWEAK_QUALIFIER-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0) {
			{
				p.SetState(1288)
				p.ParameterDeclarationList()
			}

		}
		{
			p.SetState(1291)
			p.Match(ObjectiveCParserRP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParameterDeclarationListContext is an interface to support dynamic dispatch.
type IParameterDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterDeclarationListContext differentiates from other interfaces.
	IsParameterDeclarationListContext()
}

type ParameterDeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterDeclarationListContext() *ParameterDeclarationListContext {
	var p = new(ParameterDeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_parameterDeclarationList
	return p
}

func (*ParameterDeclarationListContext) IsParameterDeclarationListContext() {}

func NewParameterDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDeclarationListContext {
	var p = new(ParameterDeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_parameterDeclarationList

	return p
}

func (s *ParameterDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterDeclarationListContext) AllParameterDeclaration() []IParameterDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterDeclarationContext)(nil)).Elem())
	var tst = make([]IParameterDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterDeclarationContext)
		}
	}

	return tst
}

func (s *ParameterDeclarationListContext) ParameterDeclaration(i int) IParameterDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterDeclarationContext)
}

func (s *ParameterDeclarationListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *ParameterDeclarationListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *ParameterDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterParameterDeclarationList(s)
	}
}

func (s *ParameterDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitParameterDeclarationList(s)
	}
}

func (p *ObjectiveCParser) ParameterDeclarationList() (localctx IParameterDeclarationListContext) {
	this := p
	_ = this

	localctx = NewParameterDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, ObjectiveCParserRULE_parameterDeclarationList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1294)
		p.ParameterDeclaration()
	}
	p.SetState(1299)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1295)
				p.Match(ObjectiveCParserCOMMA)
			}
			{
				p.SetState(1296)
				p.ParameterDeclaration()
			}

		}
		p.SetState(1301)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext())
	}

	return localctx
}

// IParameterDeclarationContext is an interface to support dynamic dispatch.
type IParameterDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterDeclarationContext differentiates from other interfaces.
	IsParameterDeclarationContext()
}

type ParameterDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterDeclarationContext() *ParameterDeclarationContext {
	var p = new(ParameterDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_parameterDeclaration
	return p
}

func (*ParameterDeclarationContext) IsParameterDeclarationContext() {}

func NewParameterDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDeclarationContext {
	var p = new(ParameterDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_parameterDeclaration

	return p
}

func (s *ParameterDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterDeclarationContext) DeclarationSpecifiers() IDeclarationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifiersContext)
}

func (s *ParameterDeclarationContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *ParameterDeclarationContext) VOID() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserVOID, 0)
}

func (s *ParameterDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterParameterDeclaration(s)
	}
}

func (s *ParameterDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitParameterDeclaration(s)
	}
}

func (p *ObjectiveCParser) ParameterDeclaration() (localctx IParameterDeclarationContext) {
	this := p
	_ = this

	localctx = NewParameterDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, ObjectiveCParserRULE_parameterDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1306)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 165, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1302)
			p.DeclarationSpecifiers()
		}
		{
			p.SetState(1303)
			p.Declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1305)
			p.Match(ObjectiveCParserVOID)
		}

	}

	return localctx
}

// IDeclaratorContext is an interface to support dynamic dispatch.
type IDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaratorContext differentiates from other interfaces.
	IsDeclaratorContext()
}

type DeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratorContext() *DeclaratorContext {
	var p = new(DeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_declarator
	return p
}

func (*DeclaratorContext) IsDeclaratorContext() {}

func NewDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratorContext {
	var p = new(DeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_declarator

	return p
}

func (s *DeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratorContext) DirectDeclarator() IDirectDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDirectDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDirectDeclaratorContext)
}

func (s *DeclaratorContext) Pointer() IPointerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPointerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPointerContext)
}

func (s *DeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterDeclarator(s)
	}
}

func (s *DeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitDeclarator(s)
	}
}

func (p *ObjectiveCParser) Declarator() (localctx IDeclaratorContext) {
	this := p
	_ = this

	localctx = NewDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, ObjectiveCParserRULE_declarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1309)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserMUL {
		{
			p.SetState(1308)
			p.Pointer()
		}

	}
	{
		p.SetState(1311)
		p.DirectDeclarator()
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) LabeledStatement() ILabeledStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabeledStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabeledStatementContext)
}

func (s *StatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, 0)
}

func (s *StatementContext) CompoundStatement() ICompoundStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *StatementContext) SelectionStatement() ISelectionStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectionStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectionStatementContext)
}

func (s *StatementContext) IterationStatement() IIterationStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIterationStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIterationStatementContext)
}

func (s *StatementContext) JumpStatement() IJumpStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJumpStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJumpStatementContext)
}

func (s *StatementContext) SynchronizedStatement() ISynchronizedStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISynchronizedStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISynchronizedStatementContext)
}

func (s *StatementContext) AutoreleaseStatement() IAutoreleaseStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAutoreleaseStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAutoreleaseStatementContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrowStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) TryBlock() ITryBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryBlockContext)
}

func (s *StatementContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *ObjectiveCParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, ObjectiveCParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1354)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 177, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1313)
			p.LabeledStatement()
		}
		p.SetState(1315)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1314)
				p.Match(ObjectiveCParserSEMI)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1317)
			p.CompoundStatement()
		}
		p.SetState(1319)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1318)
				p.Match(ObjectiveCParserSEMI)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1321)
			p.SelectionStatement()
		}
		p.SetState(1323)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1322)
				p.Match(ObjectiveCParserSEMI)
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1325)
			p.IterationStatement()
		}
		p.SetState(1327)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1326)
				p.Match(ObjectiveCParserSEMI)
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1329)
			p.JumpStatement()
		}
		p.SetState(1331)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1330)
				p.Match(ObjectiveCParserSEMI)
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1333)
			p.SynchronizedStatement()
		}
		p.SetState(1335)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1334)
				p.Match(ObjectiveCParserSEMI)
			}

		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1337)
			p.AutoreleaseStatement()
		}
		p.SetState(1339)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1338)
				p.Match(ObjectiveCParserSEMI)
			}

		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1341)
			p.ThrowStatement()
		}
		p.SetState(1343)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1342)
				p.Match(ObjectiveCParserSEMI)
			}

		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1345)
			p.TryBlock()
		}
		p.SetState(1347)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1346)
				p.Match(ObjectiveCParserSEMI)
			}

		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1349)
			p.Expressions()
		}
		p.SetState(1351)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1350)
				p.Match(ObjectiveCParserSEMI)
			}

		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1353)
			p.Match(ObjectiveCParserSEMI)
		}

	}

	return localctx
}

// ILabeledStatementContext is an interface to support dynamic dispatch.
type ILabeledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabeledStatementContext differentiates from other interfaces.
	IsLabeledStatementContext()
}

type LabeledStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledStatementContext() *LabeledStatementContext {
	var p = new(LabeledStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_labeledStatement
	return p
}

func (*LabeledStatementContext) IsLabeledStatementContext() {}

func NewLabeledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledStatementContext {
	var p = new(LabeledStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_labeledStatement

	return p
}

func (s *LabeledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabeledStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOLON, 0)
}

func (s *LabeledStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabeledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterLabeledStatement(s)
	}
}

func (s *LabeledStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitLabeledStatement(s)
	}
}

func (p *ObjectiveCParser) LabeledStatement() (localctx ILabeledStatementContext) {
	this := p
	_ = this

	localctx = NewLabeledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, ObjectiveCParserRULE_labeledStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1356)
		p.Identifier()
	}
	{
		p.SetState(1357)
		p.Match(ObjectiveCParserCOLON)
	}
	{
		p.SetState(1358)
		p.Statement()
	}

	return localctx
}

// IRangeExpressionContext is an interface to support dynamic dispatch.
type IRangeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRangeExpressionContext differentiates from other interfaces.
	IsRangeExpressionContext()
}

type RangeExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeExpressionContext() *RangeExpressionContext {
	var p = new(RangeExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_rangeExpression
	return p
}

func (*RangeExpressionContext) IsRangeExpressionContext() {}

func NewRangeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeExpressionContext {
	var p = new(RangeExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_rangeExpression

	return p
}

func (s *RangeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeExpressionContext) AllConstantExpression() []IConstantExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstantExpressionContext)(nil)).Elem())
	var tst = make([]IConstantExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstantExpressionContext)
		}
	}

	return tst
}

func (s *RangeExpressionContext) ConstantExpression(i int) IConstantExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *RangeExpressionContext) ELIPSIS() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserELIPSIS, 0)
}

func (s *RangeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterRangeExpression(s)
	}
}

func (s *RangeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitRangeExpression(s)
	}
}

func (p *ObjectiveCParser) RangeExpression() (localctx IRangeExpressionContext) {
	this := p
	_ = this

	localctx = NewRangeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, ObjectiveCParserRULE_rangeExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1360)
		p.ConstantExpression()
	}
	p.SetState(1363)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ObjectiveCParserELIPSIS {
		{
			p.SetState(1361)
			p.Match(ObjectiveCParserELIPSIS)
		}
		{
			p.SetState(1362)
			p.ConstantExpression()
		}

	}

	return localctx
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_compoundStatement
	return p
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACE, 0)
}

func (s *CompoundStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACE, 0)
}

func (s *CompoundStatementContext) AllDeclaration() []IDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarationContext)(nil)).Elem())
	var tst = make([]IDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarationContext)
		}
	}

	return tst
}

func (s *CompoundStatementContext) Declaration(i int) IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *CompoundStatementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *CompoundStatementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (p *ObjectiveCParser) CompoundStatement() (localctx ICompoundStatementContext) {
	this := p
	_ = this

	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, ObjectiveCParserRULE_compoundStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1365)
		p.Match(ObjectiveCParserLBRACE)
	}
	p.SetState(1370)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserAUTO)|(1<<ObjectiveCParserBREAK)|(1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserCONTINUE)|(1<<ObjectiveCParserDO)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserEXTERN)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserFOR)|(1<<ObjectiveCParserGOTO)|(1<<ObjectiveCParserIF)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserREGISTER)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserRETURN)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSIZEOF)|(1<<ObjectiveCParserSTATIC)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserSWITCH)|(1<<ObjectiveCParserTYPEDEF)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserWHILE-32))|(1<<(ObjectiveCParserTRUE-32))|(1<<(ObjectiveCParserFALSE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserNIL-32))|(1<<(ObjectiveCParserNO-32))|(1<<(ObjectiveCParserNULL_-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32))|(1<<(ObjectiveCParserYES-32))|(1<<(ObjectiveCParserAUTORELEASEPOOL-32))|(1<<(ObjectiveCParserENCODE-32)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(ObjectiveCParserPROTOCOL-69))|(1<<(ObjectiveCParserSELECTOR-69))|(1<<(ObjectiveCParserSYNCHRONIZED-69))|(1<<(ObjectiveCParserTHROW-69))|(1<<(ObjectiveCParserTRY-69))|(1<<(ObjectiveCParserATOMIC-69))|(1<<(ObjectiveCParserNONATOMIC-69))|(1<<(ObjectiveCParserRETAIN-69))|(1<<(ObjectiveCParserATTRIBUTE-69))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-69))|(1<<(ObjectiveCParserBLOCK-69))|(1<<(ObjectiveCParserBRIDGE-69))|(1<<(ObjectiveCParserBRIDGE_RETAINED-69))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-69))|(1<<(ObjectiveCParserCOVARIANT-69))|(1<<(ObjectiveCParserCONTRAVARIANT-69))|(1<<(ObjectiveCParserDEPRECATED-69))|(1<<(ObjectiveCParserKINDOF-69))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-69))|(1<<(ObjectiveCParserTYPEOF-69))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-69))|(1<<(ObjectiveCParserUNUSED-69))|(1<<(ObjectiveCParserWEAK_QUALIFIER-69))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-69))|(1<<(ObjectiveCParserNULLABLE-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(ObjectiveCParserNONNULL-101))|(1<<(ObjectiveCParserNULL_RESETTABLE-101))|(1<<(ObjectiveCParserNS_INLINE-101))|(1<<(ObjectiveCParserNS_ENUM-101))|(1<<(ObjectiveCParserNS_OPTIONS-101))|(1<<(ObjectiveCParserASSIGN-101))|(1<<(ObjectiveCParserCOPY-101))|(1<<(ObjectiveCParserGETTER-101))|(1<<(ObjectiveCParserSETTER-101))|(1<<(ObjectiveCParserSTRONG-101))|(1<<(ObjectiveCParserREADONLY-101))|(1<<(ObjectiveCParserREADWRITE-101))|(1<<(ObjectiveCParserWEAK-101))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-101))|(1<<(ObjectiveCParserIB_OUTLET-101))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-101))|(1<<(ObjectiveCParserIB_INSPECTABLE-101))|(1<<(ObjectiveCParserIB_DESIGNABLE-101))|(1<<(ObjectiveCParserIDENTIFIER-101))|(1<<(ObjectiveCParserLP-101))|(1<<(ObjectiveCParserLBRACE-101))|(1<<(ObjectiveCParserLBRACK-101))|(1<<(ObjectiveCParserSEMI-101)))) != 0) || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(ObjectiveCParserAT-136))|(1<<(ObjectiveCParserBANG-136))|(1<<(ObjectiveCParserTILDE-136))|(1<<(ObjectiveCParserINC-136))|(1<<(ObjectiveCParserDEC-136))|(1<<(ObjectiveCParserADD-136))|(1<<(ObjectiveCParserSUB-136))|(1<<(ObjectiveCParserMUL-136))|(1<<(ObjectiveCParserBITAND-136))|(1<<(ObjectiveCParserBITXOR-136)))) != 0) || (((_la-171)&-(0x1f+1)) == 0 && ((1<<uint((_la-171)))&((1<<(ObjectiveCParserCHARACTER_LITERAL-171))|(1<<(ObjectiveCParserSTRING_START-171))|(1<<(ObjectiveCParserHEX_LITERAL-171))|(1<<(ObjectiveCParserOCTAL_LITERAL-171))|(1<<(ObjectiveCParserBINARY_LITERAL-171))|(1<<(ObjectiveCParserDECIMAL_LITERAL-171))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-171)))) != 0) {
		p.SetState(1368)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1366)
				p.Declaration()
			}

		case 2:
			{
				p.SetState(1367)
				p.Statement()
			}

		}

		p.SetState(1372)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1373)
		p.Match(ObjectiveCParserRBRACE)
	}

	return localctx
}

// ISelectionStatementContext is an interface to support dynamic dispatch.
type ISelectionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIfBody returns the ifBody rule contexts.
	GetIfBody() IStatementContext

	// GetElseBody returns the elseBody rule contexts.
	GetElseBody() IStatementContext

	// SetIfBody sets the ifBody rule contexts.
	SetIfBody(IStatementContext)

	// SetElseBody sets the elseBody rule contexts.
	SetElseBody(IStatementContext)

	// IsSelectionStatementContext differentiates from other interfaces.
	IsSelectionStatementContext()
}

type SelectionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	ifBody   IStatementContext
	elseBody IStatementContext
}

func NewEmptySelectionStatementContext() *SelectionStatementContext {
	var p = new(SelectionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_selectionStatement
	return p
}

func (*SelectionStatementContext) IsSelectionStatementContext() {}

func NewSelectionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionStatementContext {
	var p = new(SelectionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_selectionStatement

	return p
}

func (s *SelectionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionStatementContext) GetIfBody() IStatementContext { return s.ifBody }

func (s *SelectionStatementContext) GetElseBody() IStatementContext { return s.elseBody }

func (s *SelectionStatementContext) SetIfBody(v IStatementContext) { s.ifBody = v }

func (s *SelectionStatementContext) SetElseBody(v IStatementContext) { s.elseBody = v }

func (s *SelectionStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIF, 0)
}

func (s *SelectionStatementContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *SelectionStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectionStatementContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *SelectionStatementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *SelectionStatementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SelectionStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserELSE, 0)
}

func (s *SelectionStatementContext) SwitchStatement() ISwitchStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *SelectionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterSelectionStatement(s)
	}
}

func (s *SelectionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitSelectionStatement(s)
	}
}

func (p *ObjectiveCParser) SelectionStatement() (localctx ISelectionStatementContext) {
	this := p
	_ = this

	localctx = NewSelectionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, ObjectiveCParserRULE_selectionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1385)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1375)
			p.Match(ObjectiveCParserIF)
		}
		{
			p.SetState(1376)
			p.Match(ObjectiveCParserLP)
		}
		{
			p.SetState(1377)
			p.expression(0)
		}
		{
			p.SetState(1378)
			p.Match(ObjectiveCParserRP)
		}
		{
			p.SetState(1379)

			var _x = p.Statement()

			localctx.(*SelectionStatementContext).ifBody = _x
		}
		p.SetState(1382)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1380)
				p.Match(ObjectiveCParserELSE)
			}
			{
				p.SetState(1381)

				var _x = p.Statement()

				localctx.(*SelectionStatementContext).elseBody = _x
			}

		}

	case ObjectiveCParserSWITCH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1384)
			p.SwitchStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_switchStatement
	return p
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSWITCH, 0)
}

func (s *SwitchStatementContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *SwitchStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchStatementContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *SwitchStatementContext) SwitchBlock() ISwitchBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (p *ObjectiveCParser) SwitchStatement() (localctx ISwitchStatementContext) {
	this := p
	_ = this

	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, ObjectiveCParserRULE_switchStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1387)
		p.Match(ObjectiveCParserSWITCH)
	}
	{
		p.SetState(1388)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(1389)
		p.expression(0)
	}
	{
		p.SetState(1390)
		p.Match(ObjectiveCParserRP)
	}
	{
		p.SetState(1391)
		p.SwitchBlock()
	}

	return localctx
}

// ISwitchBlockContext is an interface to support dynamic dispatch.
type ISwitchBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchBlockContext differentiates from other interfaces.
	IsSwitchBlockContext()
}

type SwitchBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockContext() *SwitchBlockContext {
	var p = new(SwitchBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_switchBlock
	return p
}

func (*SwitchBlockContext) IsSwitchBlockContext() {}

func NewSwitchBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockContext {
	var p = new(SwitchBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_switchBlock

	return p
}

func (s *SwitchBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACE, 0)
}

func (s *SwitchBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACE, 0)
}

func (s *SwitchBlockContext) AllSwitchSection() []ISwitchSectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISwitchSectionContext)(nil)).Elem())
	var tst = make([]ISwitchSectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISwitchSectionContext)
		}
	}

	return tst
}

func (s *SwitchBlockContext) SwitchSection(i int) ISwitchSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchSectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISwitchSectionContext)
}

func (s *SwitchBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterSwitchBlock(s)
	}
}

func (s *SwitchBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitSwitchBlock(s)
	}
}

func (p *ObjectiveCParser) SwitchBlock() (localctx ISwitchBlockContext) {
	this := p
	_ = this

	localctx = NewSwitchBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, ObjectiveCParserRULE_switchBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1393)
		p.Match(ObjectiveCParserLBRACE)
	}
	p.SetState(1397)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ObjectiveCParserCASE || _la == ObjectiveCParserDEFAULT {
		{
			p.SetState(1394)
			p.SwitchSection()
		}

		p.SetState(1399)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1400)
		p.Match(ObjectiveCParserRBRACE)
	}

	return localctx
}

// ISwitchSectionContext is an interface to support dynamic dispatch.
type ISwitchSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchSectionContext differentiates from other interfaces.
	IsSwitchSectionContext()
}

type SwitchSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchSectionContext() *SwitchSectionContext {
	var p = new(SwitchSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_switchSection
	return p
}

func (*SwitchSectionContext) IsSwitchSectionContext() {}

func NewSwitchSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchSectionContext {
	var p = new(SwitchSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_switchSection

	return p
}

func (s *SwitchSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchSectionContext) AllSwitchLabel() []ISwitchLabelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISwitchLabelContext)(nil)).Elem())
	var tst = make([]ISwitchLabelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISwitchLabelContext)
		}
	}

	return tst
}

func (s *SwitchSectionContext) SwitchLabel(i int) ISwitchLabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchLabelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISwitchLabelContext)
}

func (s *SwitchSectionContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *SwitchSectionContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SwitchSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterSwitchSection(s)
	}
}

func (s *SwitchSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitSwitchSection(s)
	}
}

func (p *ObjectiveCParser) SwitchSection() (localctx ISwitchSectionContext) {
	this := p
	_ = this

	localctx = NewSwitchSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, ObjectiveCParserRULE_switchSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1403)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ObjectiveCParserCASE || _la == ObjectiveCParserDEFAULT {
		{
			p.SetState(1402)
			p.SwitchLabel()
		}

		p.SetState(1405)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserBREAK)|(1<<ObjectiveCParserCONTINUE)|(1<<ObjectiveCParserDO)|(1<<ObjectiveCParserFOR)|(1<<ObjectiveCParserGOTO)|(1<<ObjectiveCParserIF)|(1<<ObjectiveCParserRETURN)|(1<<ObjectiveCParserSIZEOF)|(1<<ObjectiveCParserSWITCH))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(ObjectiveCParserWHILE-34))|(1<<(ObjectiveCParserTRUE-34))|(1<<(ObjectiveCParserFALSE-34))|(1<<(ObjectiveCParserBOOL-34))|(1<<(ObjectiveCParserClass-34))|(1<<(ObjectiveCParserBYCOPY-34))|(1<<(ObjectiveCParserBYREF-34))|(1<<(ObjectiveCParserID-34))|(1<<(ObjectiveCParserIMP-34))|(1<<(ObjectiveCParserIN-34))|(1<<(ObjectiveCParserINOUT-34))|(1<<(ObjectiveCParserNIL-34))|(1<<(ObjectiveCParserNO-34))|(1<<(ObjectiveCParserNULL_-34))|(1<<(ObjectiveCParserONEWAY-34))|(1<<(ObjectiveCParserOUT-34))|(1<<(ObjectiveCParserPROTOCOL_-34))|(1<<(ObjectiveCParserSEL-34))|(1<<(ObjectiveCParserSELF-34))|(1<<(ObjectiveCParserSUPER-34))|(1<<(ObjectiveCParserYES-34))|(1<<(ObjectiveCParserAUTORELEASEPOOL-34))|(1<<(ObjectiveCParserENCODE-34)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(ObjectiveCParserPROTOCOL-69))|(1<<(ObjectiveCParserSELECTOR-69))|(1<<(ObjectiveCParserSYNCHRONIZED-69))|(1<<(ObjectiveCParserTHROW-69))|(1<<(ObjectiveCParserTRY-69))|(1<<(ObjectiveCParserATOMIC-69))|(1<<(ObjectiveCParserNONATOMIC-69))|(1<<(ObjectiveCParserRETAIN-69))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-69))|(1<<(ObjectiveCParserBLOCK-69))|(1<<(ObjectiveCParserBRIDGE_RETAINED-69))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-69))|(1<<(ObjectiveCParserCOVARIANT-69))|(1<<(ObjectiveCParserCONTRAVARIANT-69))|(1<<(ObjectiveCParserDEPRECATED-69))|(1<<(ObjectiveCParserKINDOF-69))|(1<<(ObjectiveCParserUNUSED-69))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-69))|(1<<(ObjectiveCParserNULLABLE-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(ObjectiveCParserNONNULL-101))|(1<<(ObjectiveCParserNULL_RESETTABLE-101))|(1<<(ObjectiveCParserNS_INLINE-101))|(1<<(ObjectiveCParserNS_ENUM-101))|(1<<(ObjectiveCParserNS_OPTIONS-101))|(1<<(ObjectiveCParserASSIGN-101))|(1<<(ObjectiveCParserCOPY-101))|(1<<(ObjectiveCParserGETTER-101))|(1<<(ObjectiveCParserSETTER-101))|(1<<(ObjectiveCParserSTRONG-101))|(1<<(ObjectiveCParserREADONLY-101))|(1<<(ObjectiveCParserREADWRITE-101))|(1<<(ObjectiveCParserWEAK-101))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-101))|(1<<(ObjectiveCParserIB_OUTLET-101))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-101))|(1<<(ObjectiveCParserIB_INSPECTABLE-101))|(1<<(ObjectiveCParserIB_DESIGNABLE-101))|(1<<(ObjectiveCParserIDENTIFIER-101))|(1<<(ObjectiveCParserLP-101))|(1<<(ObjectiveCParserLBRACE-101))|(1<<(ObjectiveCParserLBRACK-101))|(1<<(ObjectiveCParserSEMI-101)))) != 0) || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(ObjectiveCParserAT-136))|(1<<(ObjectiveCParserBANG-136))|(1<<(ObjectiveCParserTILDE-136))|(1<<(ObjectiveCParserINC-136))|(1<<(ObjectiveCParserDEC-136))|(1<<(ObjectiveCParserADD-136))|(1<<(ObjectiveCParserSUB-136))|(1<<(ObjectiveCParserMUL-136))|(1<<(ObjectiveCParserBITAND-136))|(1<<(ObjectiveCParserBITXOR-136)))) != 0) || (((_la-171)&-(0x1f+1)) == 0 && ((1<<uint((_la-171)))&((1<<(ObjectiveCParserCHARACTER_LITERAL-171))|(1<<(ObjectiveCParserSTRING_START-171))|(1<<(ObjectiveCParserHEX_LITERAL-171))|(1<<(ObjectiveCParserOCTAL_LITERAL-171))|(1<<(ObjectiveCParserBINARY_LITERAL-171))|(1<<(ObjectiveCParserDECIMAL_LITERAL-171))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-171)))) != 0) {
		{
			p.SetState(1407)
			p.Statement()
		}

		p.SetState(1410)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISwitchLabelContext is an interface to support dynamic dispatch.
type ISwitchLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchLabelContext differentiates from other interfaces.
	IsSwitchLabelContext()
}

type SwitchLabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchLabelContext() *SwitchLabelContext {
	var p = new(SwitchLabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_switchLabel
	return p
}

func (*SwitchLabelContext) IsSwitchLabelContext() {}

func NewSwitchLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchLabelContext {
	var p = new(SwitchLabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_switchLabel

	return p
}

func (s *SwitchLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchLabelContext) CASE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCASE, 0)
}

func (s *SwitchLabelContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOLON, 0)
}

func (s *SwitchLabelContext) RangeExpression() IRangeExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRangeExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRangeExpressionContext)
}

func (s *SwitchLabelContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *SwitchLabelContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *SwitchLabelContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserDEFAULT, 0)
}

func (s *SwitchLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterSwitchLabel(s)
	}
}

func (s *SwitchLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitSwitchLabel(s)
	}
}

func (p *ObjectiveCParser) SwitchLabel() (localctx ISwitchLabelContext) {
	this := p
	_ = this

	localctx = NewSwitchLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, ObjectiveCParserRULE_switchLabel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1424)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1412)
			p.Match(ObjectiveCParserCASE)
		}
		p.SetState(1418)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ObjectiveCParserTRUE, ObjectiveCParserFALSE, ObjectiveCParserBOOL, ObjectiveCParserClass, ObjectiveCParserBYCOPY, ObjectiveCParserBYREF, ObjectiveCParserID, ObjectiveCParserIMP, ObjectiveCParserIN, ObjectiveCParserINOUT, ObjectiveCParserNIL, ObjectiveCParserNO, ObjectiveCParserNULL_, ObjectiveCParserONEWAY, ObjectiveCParserOUT, ObjectiveCParserPROTOCOL_, ObjectiveCParserSEL, ObjectiveCParserSELF, ObjectiveCParserSUPER, ObjectiveCParserYES, ObjectiveCParserATOMIC, ObjectiveCParserNONATOMIC, ObjectiveCParserRETAIN, ObjectiveCParserAUTORELEASING_QUALIFIER, ObjectiveCParserBLOCK, ObjectiveCParserBRIDGE_RETAINED, ObjectiveCParserBRIDGE_TRANSFER, ObjectiveCParserCOVARIANT, ObjectiveCParserCONTRAVARIANT, ObjectiveCParserDEPRECATED, ObjectiveCParserKINDOF, ObjectiveCParserUNUSED, ObjectiveCParserNULL_UNSPECIFIED, ObjectiveCParserNULLABLE, ObjectiveCParserNONNULL, ObjectiveCParserNULL_RESETTABLE, ObjectiveCParserNS_INLINE, ObjectiveCParserNS_ENUM, ObjectiveCParserNS_OPTIONS, ObjectiveCParserASSIGN, ObjectiveCParserCOPY, ObjectiveCParserGETTER, ObjectiveCParserSETTER, ObjectiveCParserSTRONG, ObjectiveCParserREADONLY, ObjectiveCParserREADWRITE, ObjectiveCParserWEAK, ObjectiveCParserUNSAFE_UNRETAINED, ObjectiveCParserIB_OUTLET, ObjectiveCParserIB_OUTLET_COLLECTION, ObjectiveCParserIB_INSPECTABLE, ObjectiveCParserIB_DESIGNABLE, ObjectiveCParserIDENTIFIER, ObjectiveCParserADD, ObjectiveCParserSUB, ObjectiveCParserCHARACTER_LITERAL, ObjectiveCParserHEX_LITERAL, ObjectiveCParserOCTAL_LITERAL, ObjectiveCParserBINARY_LITERAL, ObjectiveCParserDECIMAL_LITERAL, ObjectiveCParserFLOATING_POINT_LITERAL:
			{
				p.SetState(1413)
				p.RangeExpression()
			}

		case ObjectiveCParserLP:
			{
				p.SetState(1414)
				p.Match(ObjectiveCParserLP)
			}
			{
				p.SetState(1415)
				p.RangeExpression()
			}
			{
				p.SetState(1416)
				p.Match(ObjectiveCParserRP)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1420)
			p.Match(ObjectiveCParserCOLON)
		}

	case ObjectiveCParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1422)
			p.Match(ObjectiveCParserDEFAULT)
		}
		{
			p.SetState(1423)
			p.Match(ObjectiveCParserCOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIterationStatementContext is an interface to support dynamic dispatch.
type IIterationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIterationStatementContext differentiates from other interfaces.
	IsIterationStatementContext()
}

type IterationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterationStatementContext() *IterationStatementContext {
	var p = new(IterationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_iterationStatement
	return p
}

func (*IterationStatementContext) IsIterationStatementContext() {}

func NewIterationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterationStatementContext {
	var p = new(IterationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_iterationStatement

	return p
}

func (s *IterationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterationStatementContext) WhileStatement() IWhileStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhileStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *IterationStatementContext) DoStatement() IDoStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoStatementContext)
}

func (s *IterationStatementContext) ForStatement() IForStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *IterationStatementContext) ForInStatement() IForInStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForInStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForInStatementContext)
}

func (s *IterationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IterationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterIterationStatement(s)
	}
}

func (s *IterationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitIterationStatement(s)
	}
}

func (p *ObjectiveCParser) IterationStatement() (localctx IIterationStatementContext) {
	this := p
	_ = this

	localctx = NewIterationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, ObjectiveCParserRULE_iterationStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1430)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 188, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1426)
			p.WhileStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1427)
			p.DoStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1428)
			p.ForStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1429)
			p.ForInStatement()
		}

	}

	return localctx
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_whileStatement
	return p
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserWHILE, 0)
}

func (s *WhileStatementContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *ObjectiveCParser) WhileStatement() (localctx IWhileStatementContext) {
	this := p
	_ = this

	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, ObjectiveCParserRULE_whileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1432)
		p.Match(ObjectiveCParserWHILE)
	}
	{
		p.SetState(1433)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(1434)
		p.expression(0)
	}
	{
		p.SetState(1435)
		p.Match(ObjectiveCParserRP)
	}
	{
		p.SetState(1436)
		p.Statement()
	}

	return localctx
}

// IDoStatementContext is an interface to support dynamic dispatch.
type IDoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoStatementContext differentiates from other interfaces.
	IsDoStatementContext()
}

type DoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoStatementContext() *DoStatementContext {
	var p = new(DoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_doStatement
	return p
}

func (*DoStatementContext) IsDoStatementContext() {}

func NewDoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoStatementContext {
	var p = new(DoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_doStatement

	return p
}

func (s *DoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserDO, 0)
}

func (s *DoStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserWHILE, 0)
}

func (s *DoStatementContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *DoStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DoStatementContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *DoStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, 0)
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitDoStatement(s)
	}
}

func (p *ObjectiveCParser) DoStatement() (localctx IDoStatementContext) {
	this := p
	_ = this

	localctx = NewDoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, ObjectiveCParserRULE_doStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1438)
		p.Match(ObjectiveCParserDO)
	}
	{
		p.SetState(1439)
		p.Statement()
	}
	{
		p.SetState(1440)
		p.Match(ObjectiveCParserWHILE)
	}
	{
		p.SetState(1441)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(1442)
		p.expression(0)
	}
	{
		p.SetState(1443)
		p.Match(ObjectiveCParserRP)
	}
	{
		p.SetState(1444)
		p.Match(ObjectiveCParserSEMI)
	}

	return localctx
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_forStatement
	return p
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserFOR, 0)
}

func (s *ForStatementContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *ForStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserSEMI)
}

func (s *ForStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEMI, i)
}

func (s *ForStatementContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) ForLoopInitializer() IForLoopInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForLoopInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForLoopInitializerContext)
}

func (s *ForStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *ObjectiveCParser) ForStatement() (localctx IForStatementContext) {
	this := p
	_ = this

	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, ObjectiveCParserRULE_forStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1446)
		p.Match(ObjectiveCParserFOR)
	}
	{
		p.SetState(1447)
		p.Match(ObjectiveCParserLP)
	}
	p.SetState(1449)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserAUTO)|(1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserEXTERN)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserREGISTER)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSIZEOF)|(1<<ObjectiveCParserSTATIC)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserTRUE-32))|(1<<(ObjectiveCParserFALSE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserNIL-32))|(1<<(ObjectiveCParserNO-32))|(1<<(ObjectiveCParserNULL_-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32))|(1<<(ObjectiveCParserYES-32))|(1<<(ObjectiveCParserENCODE-32)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(ObjectiveCParserPROTOCOL-69))|(1<<(ObjectiveCParserSELECTOR-69))|(1<<(ObjectiveCParserATOMIC-69))|(1<<(ObjectiveCParserNONATOMIC-69))|(1<<(ObjectiveCParserRETAIN-69))|(1<<(ObjectiveCParserATTRIBUTE-69))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-69))|(1<<(ObjectiveCParserBLOCK-69))|(1<<(ObjectiveCParserBRIDGE-69))|(1<<(ObjectiveCParserBRIDGE_RETAINED-69))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-69))|(1<<(ObjectiveCParserCOVARIANT-69))|(1<<(ObjectiveCParserCONTRAVARIANT-69))|(1<<(ObjectiveCParserDEPRECATED-69))|(1<<(ObjectiveCParserKINDOF-69))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-69))|(1<<(ObjectiveCParserTYPEOF-69))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-69))|(1<<(ObjectiveCParserUNUSED-69))|(1<<(ObjectiveCParserWEAK_QUALIFIER-69))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-69))|(1<<(ObjectiveCParserNULLABLE-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(ObjectiveCParserNONNULL-101))|(1<<(ObjectiveCParserNULL_RESETTABLE-101))|(1<<(ObjectiveCParserNS_INLINE-101))|(1<<(ObjectiveCParserNS_ENUM-101))|(1<<(ObjectiveCParserNS_OPTIONS-101))|(1<<(ObjectiveCParserASSIGN-101))|(1<<(ObjectiveCParserCOPY-101))|(1<<(ObjectiveCParserGETTER-101))|(1<<(ObjectiveCParserSETTER-101))|(1<<(ObjectiveCParserSTRONG-101))|(1<<(ObjectiveCParserREADONLY-101))|(1<<(ObjectiveCParserREADWRITE-101))|(1<<(ObjectiveCParserWEAK-101))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-101))|(1<<(ObjectiveCParserIB_OUTLET-101))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-101))|(1<<(ObjectiveCParserIB_INSPECTABLE-101))|(1<<(ObjectiveCParserIB_DESIGNABLE-101))|(1<<(ObjectiveCParserIDENTIFIER-101))|(1<<(ObjectiveCParserLP-101))|(1<<(ObjectiveCParserLBRACK-101)))) != 0) || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(ObjectiveCParserAT-136))|(1<<(ObjectiveCParserBANG-136))|(1<<(ObjectiveCParserTILDE-136))|(1<<(ObjectiveCParserINC-136))|(1<<(ObjectiveCParserDEC-136))|(1<<(ObjectiveCParserADD-136))|(1<<(ObjectiveCParserSUB-136))|(1<<(ObjectiveCParserMUL-136))|(1<<(ObjectiveCParserBITAND-136))|(1<<(ObjectiveCParserBITXOR-136)))) != 0) || (((_la-171)&-(0x1f+1)) == 0 && ((1<<uint((_la-171)))&((1<<(ObjectiveCParserCHARACTER_LITERAL-171))|(1<<(ObjectiveCParserSTRING_START-171))|(1<<(ObjectiveCParserHEX_LITERAL-171))|(1<<(ObjectiveCParserOCTAL_LITERAL-171))|(1<<(ObjectiveCParserBINARY_LITERAL-171))|(1<<(ObjectiveCParserDECIMAL_LITERAL-171))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-171)))) != 0) {
		{
			p.SetState(1448)
			p.ForLoopInitializer()
		}

	}
	{
		p.SetState(1451)
		p.Match(ObjectiveCParserSEMI)
	}
	p.SetState(1453)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-25)&-(0x1f+1)) == 0 && ((1<<uint((_la-25)))&((1<<(ObjectiveCParserSIZEOF-25))|(1<<(ObjectiveCParserTRUE-25))|(1<<(ObjectiveCParserFALSE-25))|(1<<(ObjectiveCParserBOOL-25))|(1<<(ObjectiveCParserClass-25))|(1<<(ObjectiveCParserBYCOPY-25))|(1<<(ObjectiveCParserBYREF-25))|(1<<(ObjectiveCParserID-25))|(1<<(ObjectiveCParserIMP-25))|(1<<(ObjectiveCParserIN-25))|(1<<(ObjectiveCParserINOUT-25))|(1<<(ObjectiveCParserNIL-25))|(1<<(ObjectiveCParserNO-25))|(1<<(ObjectiveCParserNULL_-25))|(1<<(ObjectiveCParserONEWAY-25))|(1<<(ObjectiveCParserOUT-25))|(1<<(ObjectiveCParserPROTOCOL_-25))|(1<<(ObjectiveCParserSEL-25))|(1<<(ObjectiveCParserSELF-25))|(1<<(ObjectiveCParserSUPER-25)))) != 0) || (((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(ObjectiveCParserYES-57))|(1<<(ObjectiveCParserENCODE-57))|(1<<(ObjectiveCParserPROTOCOL-57))|(1<<(ObjectiveCParserSELECTOR-57))|(1<<(ObjectiveCParserATOMIC-57))|(1<<(ObjectiveCParserNONATOMIC-57))|(1<<(ObjectiveCParserRETAIN-57))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-57))|(1<<(ObjectiveCParserBLOCK-57))|(1<<(ObjectiveCParserBRIDGE_RETAINED-57)))) != 0) || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(ObjectiveCParserBRIDGE_TRANSFER-89))|(1<<(ObjectiveCParserCOVARIANT-89))|(1<<(ObjectiveCParserCONTRAVARIANT-89))|(1<<(ObjectiveCParserDEPRECATED-89))|(1<<(ObjectiveCParserKINDOF-89))|(1<<(ObjectiveCParserUNUSED-89))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-89))|(1<<(ObjectiveCParserNULLABLE-89))|(1<<(ObjectiveCParserNONNULL-89))|(1<<(ObjectiveCParserNULL_RESETTABLE-89))|(1<<(ObjectiveCParserNS_INLINE-89))|(1<<(ObjectiveCParserNS_ENUM-89))|(1<<(ObjectiveCParserNS_OPTIONS-89))|(1<<(ObjectiveCParserASSIGN-89))|(1<<(ObjectiveCParserCOPY-89))|(1<<(ObjectiveCParserGETTER-89))|(1<<(ObjectiveCParserSETTER-89))|(1<<(ObjectiveCParserSTRONG-89))|(1<<(ObjectiveCParserREADONLY-89))|(1<<(ObjectiveCParserREADWRITE-89))|(1<<(ObjectiveCParserWEAK-89))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-89))|(1<<(ObjectiveCParserIB_OUTLET-89))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-89))|(1<<(ObjectiveCParserIB_INSPECTABLE-89))|(1<<(ObjectiveCParserIB_DESIGNABLE-89)))) != 0) || (((_la-125)&-(0x1f+1)) == 0 && ((1<<uint((_la-125)))&((1<<(ObjectiveCParserIDENTIFIER-125))|(1<<(ObjectiveCParserLP-125))|(1<<(ObjectiveCParserLBRACK-125))|(1<<(ObjectiveCParserAT-125))|(1<<(ObjectiveCParserBANG-125))|(1<<(ObjectiveCParserTILDE-125))|(1<<(ObjectiveCParserINC-125))|(1<<(ObjectiveCParserDEC-125))|(1<<(ObjectiveCParserADD-125))|(1<<(ObjectiveCParserSUB-125))|(1<<(ObjectiveCParserMUL-125))|(1<<(ObjectiveCParserBITAND-125)))) != 0) || (((_la-158)&-(0x1f+1)) == 0 && ((1<<uint((_la-158)))&((1<<(ObjectiveCParserBITXOR-158))|(1<<(ObjectiveCParserCHARACTER_LITERAL-158))|(1<<(ObjectiveCParserSTRING_START-158))|(1<<(ObjectiveCParserHEX_LITERAL-158))|(1<<(ObjectiveCParserOCTAL_LITERAL-158))|(1<<(ObjectiveCParserBINARY_LITERAL-158))|(1<<(ObjectiveCParserDECIMAL_LITERAL-158))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-158)))) != 0) {
		{
			p.SetState(1452)
			p.expression(0)
		}

	}
	{
		p.SetState(1455)
		p.Match(ObjectiveCParserSEMI)
	}
	p.SetState(1457)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-25)&-(0x1f+1)) == 0 && ((1<<uint((_la-25)))&((1<<(ObjectiveCParserSIZEOF-25))|(1<<(ObjectiveCParserTRUE-25))|(1<<(ObjectiveCParserFALSE-25))|(1<<(ObjectiveCParserBOOL-25))|(1<<(ObjectiveCParserClass-25))|(1<<(ObjectiveCParserBYCOPY-25))|(1<<(ObjectiveCParserBYREF-25))|(1<<(ObjectiveCParserID-25))|(1<<(ObjectiveCParserIMP-25))|(1<<(ObjectiveCParserIN-25))|(1<<(ObjectiveCParserINOUT-25))|(1<<(ObjectiveCParserNIL-25))|(1<<(ObjectiveCParserNO-25))|(1<<(ObjectiveCParserNULL_-25))|(1<<(ObjectiveCParserONEWAY-25))|(1<<(ObjectiveCParserOUT-25))|(1<<(ObjectiveCParserPROTOCOL_-25))|(1<<(ObjectiveCParserSEL-25))|(1<<(ObjectiveCParserSELF-25))|(1<<(ObjectiveCParserSUPER-25)))) != 0) || (((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(ObjectiveCParserYES-57))|(1<<(ObjectiveCParserENCODE-57))|(1<<(ObjectiveCParserPROTOCOL-57))|(1<<(ObjectiveCParserSELECTOR-57))|(1<<(ObjectiveCParserATOMIC-57))|(1<<(ObjectiveCParserNONATOMIC-57))|(1<<(ObjectiveCParserRETAIN-57))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-57))|(1<<(ObjectiveCParserBLOCK-57))|(1<<(ObjectiveCParserBRIDGE_RETAINED-57)))) != 0) || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(ObjectiveCParserBRIDGE_TRANSFER-89))|(1<<(ObjectiveCParserCOVARIANT-89))|(1<<(ObjectiveCParserCONTRAVARIANT-89))|(1<<(ObjectiveCParserDEPRECATED-89))|(1<<(ObjectiveCParserKINDOF-89))|(1<<(ObjectiveCParserUNUSED-89))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-89))|(1<<(ObjectiveCParserNULLABLE-89))|(1<<(ObjectiveCParserNONNULL-89))|(1<<(ObjectiveCParserNULL_RESETTABLE-89))|(1<<(ObjectiveCParserNS_INLINE-89))|(1<<(ObjectiveCParserNS_ENUM-89))|(1<<(ObjectiveCParserNS_OPTIONS-89))|(1<<(ObjectiveCParserASSIGN-89))|(1<<(ObjectiveCParserCOPY-89))|(1<<(ObjectiveCParserGETTER-89))|(1<<(ObjectiveCParserSETTER-89))|(1<<(ObjectiveCParserSTRONG-89))|(1<<(ObjectiveCParserREADONLY-89))|(1<<(ObjectiveCParserREADWRITE-89))|(1<<(ObjectiveCParserWEAK-89))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-89))|(1<<(ObjectiveCParserIB_OUTLET-89))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-89))|(1<<(ObjectiveCParserIB_INSPECTABLE-89))|(1<<(ObjectiveCParserIB_DESIGNABLE-89)))) != 0) || (((_la-125)&-(0x1f+1)) == 0 && ((1<<uint((_la-125)))&((1<<(ObjectiveCParserIDENTIFIER-125))|(1<<(ObjectiveCParserLP-125))|(1<<(ObjectiveCParserLBRACK-125))|(1<<(ObjectiveCParserAT-125))|(1<<(ObjectiveCParserBANG-125))|(1<<(ObjectiveCParserTILDE-125))|(1<<(ObjectiveCParserINC-125))|(1<<(ObjectiveCParserDEC-125))|(1<<(ObjectiveCParserADD-125))|(1<<(ObjectiveCParserSUB-125))|(1<<(ObjectiveCParserMUL-125))|(1<<(ObjectiveCParserBITAND-125)))) != 0) || (((_la-158)&-(0x1f+1)) == 0 && ((1<<uint((_la-158)))&((1<<(ObjectiveCParserBITXOR-158))|(1<<(ObjectiveCParserCHARACTER_LITERAL-158))|(1<<(ObjectiveCParserSTRING_START-158))|(1<<(ObjectiveCParserHEX_LITERAL-158))|(1<<(ObjectiveCParserOCTAL_LITERAL-158))|(1<<(ObjectiveCParserBINARY_LITERAL-158))|(1<<(ObjectiveCParserDECIMAL_LITERAL-158))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-158)))) != 0) {
		{
			p.SetState(1456)
			p.Expressions()
		}

	}
	{
		p.SetState(1459)
		p.Match(ObjectiveCParserRP)
	}
	{
		p.SetState(1460)
		p.Statement()
	}

	return localctx
}

// IForLoopInitializerContext is an interface to support dynamic dispatch.
type IForLoopInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForLoopInitializerContext differentiates from other interfaces.
	IsForLoopInitializerContext()
}

type ForLoopInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForLoopInitializerContext() *ForLoopInitializerContext {
	var p = new(ForLoopInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_forLoopInitializer
	return p
}

func (*ForLoopInitializerContext) IsForLoopInitializerContext() {}

func NewForLoopInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForLoopInitializerContext {
	var p = new(ForLoopInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_forLoopInitializer

	return p
}

func (s *ForLoopInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ForLoopInitializerContext) DeclarationSpecifiers() IDeclarationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifiersContext)
}

func (s *ForLoopInitializerContext) InitDeclaratorList() IInitDeclaratorListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitDeclaratorListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitDeclaratorListContext)
}

func (s *ForLoopInitializerContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *ForLoopInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForLoopInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForLoopInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterForLoopInitializer(s)
	}
}

func (s *ForLoopInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitForLoopInitializer(s)
	}
}

func (p *ObjectiveCParser) ForLoopInitializer() (localctx IForLoopInitializerContext) {
	this := p
	_ = this

	localctx = NewForLoopInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, ObjectiveCParserRULE_forLoopInitializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1466)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 192, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1462)
			p.DeclarationSpecifiers()
		}
		{
			p.SetState(1463)
			p.InitDeclaratorList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1465)
			p.Expressions()
		}

	}

	return localctx
}

// IForInStatementContext is an interface to support dynamic dispatch.
type IForInStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForInStatementContext differentiates from other interfaces.
	IsForInStatementContext()
}

type ForInStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInStatementContext() *ForInStatementContext {
	var p = new(ForInStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_forInStatement
	return p
}

func (*ForInStatementContext) IsForInStatementContext() {}

func NewForInStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInStatementContext {
	var p = new(ForInStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_forInStatement

	return p
}

func (s *ForInStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserFOR, 0)
}

func (s *ForInStatementContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *ForInStatementContext) TypeVariableDeclarator() ITypeVariableDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeVariableDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeVariableDeclaratorContext)
}

func (s *ForInStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIN, 0)
}

func (s *ForInStatementContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *ForInStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForInStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForInStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterForInStatement(s)
	}
}

func (s *ForInStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitForInStatement(s)
	}
}

func (p *ObjectiveCParser) ForInStatement() (localctx IForInStatementContext) {
	this := p
	_ = this

	localctx = NewForInStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, ObjectiveCParserRULE_forInStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1468)
		p.Match(ObjectiveCParserFOR)
	}
	{
		p.SetState(1469)
		p.Match(ObjectiveCParserLP)
	}
	{
		p.SetState(1470)
		p.TypeVariableDeclarator()
	}
	{
		p.SetState(1471)
		p.Match(ObjectiveCParserIN)
	}
	p.SetState(1473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-25)&-(0x1f+1)) == 0 && ((1<<uint((_la-25)))&((1<<(ObjectiveCParserSIZEOF-25))|(1<<(ObjectiveCParserTRUE-25))|(1<<(ObjectiveCParserFALSE-25))|(1<<(ObjectiveCParserBOOL-25))|(1<<(ObjectiveCParserClass-25))|(1<<(ObjectiveCParserBYCOPY-25))|(1<<(ObjectiveCParserBYREF-25))|(1<<(ObjectiveCParserID-25))|(1<<(ObjectiveCParserIMP-25))|(1<<(ObjectiveCParserIN-25))|(1<<(ObjectiveCParserINOUT-25))|(1<<(ObjectiveCParserNIL-25))|(1<<(ObjectiveCParserNO-25))|(1<<(ObjectiveCParserNULL_-25))|(1<<(ObjectiveCParserONEWAY-25))|(1<<(ObjectiveCParserOUT-25))|(1<<(ObjectiveCParserPROTOCOL_-25))|(1<<(ObjectiveCParserSEL-25))|(1<<(ObjectiveCParserSELF-25))|(1<<(ObjectiveCParserSUPER-25)))) != 0) || (((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(ObjectiveCParserYES-57))|(1<<(ObjectiveCParserENCODE-57))|(1<<(ObjectiveCParserPROTOCOL-57))|(1<<(ObjectiveCParserSELECTOR-57))|(1<<(ObjectiveCParserATOMIC-57))|(1<<(ObjectiveCParserNONATOMIC-57))|(1<<(ObjectiveCParserRETAIN-57))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-57))|(1<<(ObjectiveCParserBLOCK-57))|(1<<(ObjectiveCParserBRIDGE_RETAINED-57)))) != 0) || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(ObjectiveCParserBRIDGE_TRANSFER-89))|(1<<(ObjectiveCParserCOVARIANT-89))|(1<<(ObjectiveCParserCONTRAVARIANT-89))|(1<<(ObjectiveCParserDEPRECATED-89))|(1<<(ObjectiveCParserKINDOF-89))|(1<<(ObjectiveCParserUNUSED-89))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-89))|(1<<(ObjectiveCParserNULLABLE-89))|(1<<(ObjectiveCParserNONNULL-89))|(1<<(ObjectiveCParserNULL_RESETTABLE-89))|(1<<(ObjectiveCParserNS_INLINE-89))|(1<<(ObjectiveCParserNS_ENUM-89))|(1<<(ObjectiveCParserNS_OPTIONS-89))|(1<<(ObjectiveCParserASSIGN-89))|(1<<(ObjectiveCParserCOPY-89))|(1<<(ObjectiveCParserGETTER-89))|(1<<(ObjectiveCParserSETTER-89))|(1<<(ObjectiveCParserSTRONG-89))|(1<<(ObjectiveCParserREADONLY-89))|(1<<(ObjectiveCParserREADWRITE-89))|(1<<(ObjectiveCParserWEAK-89))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-89))|(1<<(ObjectiveCParserIB_OUTLET-89))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-89))|(1<<(ObjectiveCParserIB_INSPECTABLE-89))|(1<<(ObjectiveCParserIB_DESIGNABLE-89)))) != 0) || (((_la-125)&-(0x1f+1)) == 0 && ((1<<uint((_la-125)))&((1<<(ObjectiveCParserIDENTIFIER-125))|(1<<(ObjectiveCParserLP-125))|(1<<(ObjectiveCParserLBRACK-125))|(1<<(ObjectiveCParserAT-125))|(1<<(ObjectiveCParserBANG-125))|(1<<(ObjectiveCParserTILDE-125))|(1<<(ObjectiveCParserINC-125))|(1<<(ObjectiveCParserDEC-125))|(1<<(ObjectiveCParserADD-125))|(1<<(ObjectiveCParserSUB-125))|(1<<(ObjectiveCParserMUL-125))|(1<<(ObjectiveCParserBITAND-125)))) != 0) || (((_la-158)&-(0x1f+1)) == 0 && ((1<<uint((_la-158)))&((1<<(ObjectiveCParserBITXOR-158))|(1<<(ObjectiveCParserCHARACTER_LITERAL-158))|(1<<(ObjectiveCParserSTRING_START-158))|(1<<(ObjectiveCParserHEX_LITERAL-158))|(1<<(ObjectiveCParserOCTAL_LITERAL-158))|(1<<(ObjectiveCParserBINARY_LITERAL-158))|(1<<(ObjectiveCParserDECIMAL_LITERAL-158))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-158)))) != 0) {
		{
			p.SetState(1472)
			p.expression(0)
		}

	}
	{
		p.SetState(1475)
		p.Match(ObjectiveCParserRP)
	}
	{
		p.SetState(1476)
		p.Statement()
	}

	return localctx
}

// IJumpStatementContext is an interface to support dynamic dispatch.
type IJumpStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJumpStatementContext differentiates from other interfaces.
	IsJumpStatementContext()
}

type JumpStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJumpStatementContext() *JumpStatementContext {
	var p = new(JumpStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_jumpStatement
	return p
}

func (*JumpStatementContext) IsJumpStatementContext() {}

func NewJumpStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JumpStatementContext {
	var p = new(JumpStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_jumpStatement

	return p
}

func (s *JumpStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *JumpStatementContext) GOTO() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserGOTO, 0)
}

func (s *JumpStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JumpStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCONTINUE, 0)
}

func (s *JumpStatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBREAK, 0)
}

func (s *JumpStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRETURN, 0)
}

func (s *JumpStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JumpStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JumpStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JumpStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterJumpStatement(s)
	}
}

func (s *JumpStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitJumpStatement(s)
	}
}

func (p *ObjectiveCParser) JumpStatement() (localctx IJumpStatementContext) {
	this := p
	_ = this

	localctx = NewJumpStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, ObjectiveCParserRULE_jumpStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1486)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserGOTO:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1478)
			p.Match(ObjectiveCParserGOTO)
		}
		{
			p.SetState(1479)
			p.Identifier()
		}

	case ObjectiveCParserCONTINUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1480)
			p.Match(ObjectiveCParserCONTINUE)
		}

	case ObjectiveCParserBREAK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1481)
			p.Match(ObjectiveCParserBREAK)
		}

	case ObjectiveCParserRETURN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1482)
			p.Match(ObjectiveCParserRETURN)
		}
		p.SetState(1484)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1483)
				p.expression(0)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpressionsContext is an interface to support dynamic dispatch.
type IExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionsContext differentiates from other interfaces.
	IsExpressionsContext()
}

type ExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsContext() *ExpressionsContext {
	var p = new(ExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_expressions
	return p
}

func (*ExpressionsContext) IsExpressionsContext() {}

func NewExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsContext {
	var p = new(ExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_expressions

	return p
}

func (s *ExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionsContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *ExpressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *ExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterExpressions(s)
	}
}

func (s *ExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitExpressions(s)
	}
}

func (p *ObjectiveCParser) Expressions() (localctx IExpressionsContext) {
	this := p
	_ = this

	localctx = NewExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, ObjectiveCParserRULE_expressions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1488)
		p.expression(0)
	}
	p.SetState(1493)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1489)
				p.Match(ObjectiveCParserCOMMA)
			}
			{
				p.SetState(1490)
				p.expression(0)
			}

		}
		p.SetState(1495)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetAssignmentExpression returns the assignmentExpression rule contexts.
	GetAssignmentExpression() IExpressionContext

	// GetTrueExpression returns the trueExpression rule contexts.
	GetTrueExpression() IExpressionContext

	// GetFalseExpression returns the falseExpression rule contexts.
	GetFalseExpression() IExpressionContext

	// SetAssignmentExpression sets the assignmentExpression rule contexts.
	SetAssignmentExpression(IExpressionContext)

	// SetTrueExpression sets the trueExpression rule contexts.
	SetTrueExpression(IExpressionContext)

	// SetFalseExpression sets the falseExpression rule contexts.
	SetFalseExpression(IExpressionContext)

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser               antlr.Parser
	assignmentExpression IExpressionContext
	op                   antlr.Token
	trueExpression       IExpressionContext
	falseExpression      IExpressionContext
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) GetOp() antlr.Token { return s.op }

func (s *ExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExpressionContext) GetAssignmentExpression() IExpressionContext {
	return s.assignmentExpression
}

func (s *ExpressionContext) GetTrueExpression() IExpressionContext { return s.trueExpression }

func (s *ExpressionContext) GetFalseExpression() IExpressionContext { return s.falseExpression }

func (s *ExpressionContext) SetAssignmentExpression(v IExpressionContext) { s.assignmentExpression = v }

func (s *ExpressionContext) SetTrueExpression(v IExpressionContext) { s.trueExpression = v }

func (s *ExpressionContext) SetFalseExpression(v IExpressionContext) { s.falseExpression = v }

func (s *ExpressionContext) CastExpression() ICastExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *ExpressionContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *ExpressionContext) CompoundStatement() ICompoundStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *ExpressionContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *ExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *ExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) MUL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserMUL, 0)
}

func (s *ExpressionContext) DIV() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserDIV, 0)
}

func (s *ExpressionContext) MOD() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserMOD, 0)
}

func (s *ExpressionContext) ADD() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserADD, 0)
}

func (s *ExpressionContext) SUB() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSUB, 0)
}

func (s *ExpressionContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserLT)
}

func (s *ExpressionContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLT, i)
}

func (s *ExpressionContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserGT)
}

func (s *ExpressionContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserGT, i)
}

func (s *ExpressionContext) LE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLE, 0)
}

func (s *ExpressionContext) GE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserGE, 0)
}

func (s *ExpressionContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNOTEQUAL, 0)
}

func (s *ExpressionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserEQUAL, 0)
}

func (s *ExpressionContext) BITAND() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBITAND, 0)
}

func (s *ExpressionContext) BITXOR() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBITXOR, 0)
}

func (s *ExpressionContext) BITOR() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBITOR, 0)
}

func (s *ExpressionContext) AND() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserAND, 0)
}

func (s *ExpressionContext) OR() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserOR, 0)
}

func (s *ExpressionContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserQUESTION, 0)
}

func (s *ExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOLON, 0)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *ObjectiveCParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *ObjectiveCParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 258
	p.EnterRecursionRule(localctx, 258, ObjectiveCParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1506)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 197, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1497)
			p.CastExpression()
		}

	case 2:
		{
			p.SetState(1498)
			p.Match(ObjectiveCParserLP)
		}
		{
			p.SetState(1499)
			p.CompoundStatement()
		}
		{
			p.SetState(1500)
			p.Match(ObjectiveCParserRP)
		}

	case 3:
		{
			p.SetState(1502)
			p.UnaryExpression()
		}
		{
			p.SetState(1503)
			p.AssignmentOperator()
		}
		{
			p.SetState(1504)

			var _x = p.expression(1)

			localctx.(*ExpressionContext).assignmentExpression = _x
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1552)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1550)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 200, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ObjectiveCParserRULE_expression)
				p.SetState(1508)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(1509)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-154)&-(0x1f+1)) == 0 && ((1<<uint((_la-154)))&((1<<(ObjectiveCParserMUL-154))|(1<<(ObjectiveCParserDIV-154))|(1<<(ObjectiveCParserMOD-154)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1510)
					p.expression(14)
				}

			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ObjectiveCParserRULE_expression)
				p.SetState(1511)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(1512)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == ObjectiveCParserADD || _la == ObjectiveCParserSUB) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1513)
					p.expression(13)
				}

			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ObjectiveCParserRULE_expression)
				p.SetState(1514)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				p.SetState(1519)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case ObjectiveCParserLT:
					{
						p.SetState(1515)
						p.Match(ObjectiveCParserLT)
					}
					{
						p.SetState(1516)
						p.Match(ObjectiveCParserLT)
					}

				case ObjectiveCParserGT:
					{
						p.SetState(1517)
						p.Match(ObjectiveCParserGT)
					}
					{
						p.SetState(1518)
						p.Match(ObjectiveCParserGT)
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}
				{
					p.SetState(1521)
					p.expression(12)
				}

			case 4:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ObjectiveCParserRULE_expression)
				p.SetState(1522)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(1523)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(ObjectiveCParserGT-138))|(1<<(ObjectiveCParserLT-138))|(1<<(ObjectiveCParserLE-138))|(1<<(ObjectiveCParserGE-138)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1524)
					p.expression(11)
				}

			case 5:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ObjectiveCParserRULE_expression)
				p.SetState(1525)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(1526)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == ObjectiveCParserEQUAL || _la == ObjectiveCParserNOTEQUAL) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1527)
					p.expression(10)
				}

			case 6:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ObjectiveCParserRULE_expression)
				p.SetState(1528)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(1529)

					var _m = p.Match(ObjectiveCParserBITAND)

					localctx.(*ExpressionContext).op = _m
				}
				{
					p.SetState(1530)
					p.expression(9)
				}

			case 7:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ObjectiveCParserRULE_expression)
				p.SetState(1531)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(1532)

					var _m = p.Match(ObjectiveCParserBITXOR)

					localctx.(*ExpressionContext).op = _m
				}
				{
					p.SetState(1533)
					p.expression(8)
				}

			case 8:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ObjectiveCParserRULE_expression)
				p.SetState(1534)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(1535)

					var _m = p.Match(ObjectiveCParserBITOR)

					localctx.(*ExpressionContext).op = _m
				}
				{
					p.SetState(1536)
					p.expression(7)
				}

			case 9:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ObjectiveCParserRULE_expression)
				p.SetState(1537)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(1538)

					var _m = p.Match(ObjectiveCParserAND)

					localctx.(*ExpressionContext).op = _m
				}
				{
					p.SetState(1539)
					p.expression(6)
				}

			case 10:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ObjectiveCParserRULE_expression)
				p.SetState(1540)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(1541)

					var _m = p.Match(ObjectiveCParserOR)

					localctx.(*ExpressionContext).op = _m
				}
				{
					p.SetState(1542)
					p.expression(5)
				}

			case 11:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ObjectiveCParserRULE_expression)
				p.SetState(1543)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1544)
					p.Match(ObjectiveCParserQUESTION)
				}
				p.SetState(1546)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la-25)&-(0x1f+1)) == 0 && ((1<<uint((_la-25)))&((1<<(ObjectiveCParserSIZEOF-25))|(1<<(ObjectiveCParserTRUE-25))|(1<<(ObjectiveCParserFALSE-25))|(1<<(ObjectiveCParserBOOL-25))|(1<<(ObjectiveCParserClass-25))|(1<<(ObjectiveCParserBYCOPY-25))|(1<<(ObjectiveCParserBYREF-25))|(1<<(ObjectiveCParserID-25))|(1<<(ObjectiveCParserIMP-25))|(1<<(ObjectiveCParserIN-25))|(1<<(ObjectiveCParserINOUT-25))|(1<<(ObjectiveCParserNIL-25))|(1<<(ObjectiveCParserNO-25))|(1<<(ObjectiveCParserNULL_-25))|(1<<(ObjectiveCParserONEWAY-25))|(1<<(ObjectiveCParserOUT-25))|(1<<(ObjectiveCParserPROTOCOL_-25))|(1<<(ObjectiveCParserSEL-25))|(1<<(ObjectiveCParserSELF-25))|(1<<(ObjectiveCParserSUPER-25)))) != 0) || (((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(ObjectiveCParserYES-57))|(1<<(ObjectiveCParserENCODE-57))|(1<<(ObjectiveCParserPROTOCOL-57))|(1<<(ObjectiveCParserSELECTOR-57))|(1<<(ObjectiveCParserATOMIC-57))|(1<<(ObjectiveCParserNONATOMIC-57))|(1<<(ObjectiveCParserRETAIN-57))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-57))|(1<<(ObjectiveCParserBLOCK-57))|(1<<(ObjectiveCParserBRIDGE_RETAINED-57)))) != 0) || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(ObjectiveCParserBRIDGE_TRANSFER-89))|(1<<(ObjectiveCParserCOVARIANT-89))|(1<<(ObjectiveCParserCONTRAVARIANT-89))|(1<<(ObjectiveCParserDEPRECATED-89))|(1<<(ObjectiveCParserKINDOF-89))|(1<<(ObjectiveCParserUNUSED-89))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-89))|(1<<(ObjectiveCParserNULLABLE-89))|(1<<(ObjectiveCParserNONNULL-89))|(1<<(ObjectiveCParserNULL_RESETTABLE-89))|(1<<(ObjectiveCParserNS_INLINE-89))|(1<<(ObjectiveCParserNS_ENUM-89))|(1<<(ObjectiveCParserNS_OPTIONS-89))|(1<<(ObjectiveCParserASSIGN-89))|(1<<(ObjectiveCParserCOPY-89))|(1<<(ObjectiveCParserGETTER-89))|(1<<(ObjectiveCParserSETTER-89))|(1<<(ObjectiveCParserSTRONG-89))|(1<<(ObjectiveCParserREADONLY-89))|(1<<(ObjectiveCParserREADWRITE-89))|(1<<(ObjectiveCParserWEAK-89))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-89))|(1<<(ObjectiveCParserIB_OUTLET-89))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-89))|(1<<(ObjectiveCParserIB_INSPECTABLE-89))|(1<<(ObjectiveCParserIB_DESIGNABLE-89)))) != 0) || (((_la-125)&-(0x1f+1)) == 0 && ((1<<uint((_la-125)))&((1<<(ObjectiveCParserIDENTIFIER-125))|(1<<(ObjectiveCParserLP-125))|(1<<(ObjectiveCParserLBRACK-125))|(1<<(ObjectiveCParserAT-125))|(1<<(ObjectiveCParserBANG-125))|(1<<(ObjectiveCParserTILDE-125))|(1<<(ObjectiveCParserINC-125))|(1<<(ObjectiveCParserDEC-125))|(1<<(ObjectiveCParserADD-125))|(1<<(ObjectiveCParserSUB-125))|(1<<(ObjectiveCParserMUL-125))|(1<<(ObjectiveCParserBITAND-125)))) != 0) || (((_la-158)&-(0x1f+1)) == 0 && ((1<<uint((_la-158)))&((1<<(ObjectiveCParserBITXOR-158))|(1<<(ObjectiveCParserCHARACTER_LITERAL-158))|(1<<(ObjectiveCParserSTRING_START-158))|(1<<(ObjectiveCParserHEX_LITERAL-158))|(1<<(ObjectiveCParserOCTAL_LITERAL-158))|(1<<(ObjectiveCParserBINARY_LITERAL-158))|(1<<(ObjectiveCParserDECIMAL_LITERAL-158))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-158)))) != 0) {
					{
						p.SetState(1545)

						var _x = p.expression(0)

						localctx.(*ExpressionContext).trueExpression = _x
					}

				}
				{
					p.SetState(1548)
					p.Match(ObjectiveCParserCOLON)
				}
				{
					p.SetState(1549)

					var _x = p.expression(4)

					localctx.(*ExpressionContext).falseExpression = _x
				}

			}

		}
		p.SetState(1554)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext())
	}

	return localctx
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_assignmentOperator
	return p
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserASSIGNMENT, 0)
}

func (s *AssignmentOperatorContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserMUL_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserDIV_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserMOD_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserADD_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSUB_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) LSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLSHIFT_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) RSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRSHIFT_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserAND_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserXOR_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserOR_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitAssignmentOperator(s)
	}
}

func (p *ObjectiveCParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	this := p
	_ = this

	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, ObjectiveCParserRULE_assignmentOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1555)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-137)&-(0x1f+1)) == 0 && ((1<<uint((_la-137)))&((1<<(ObjectiveCParserASSIGNMENT-137))|(1<<(ObjectiveCParserADD_ASSIGN-137))|(1<<(ObjectiveCParserSUB_ASSIGN-137))|(1<<(ObjectiveCParserMUL_ASSIGN-137))|(1<<(ObjectiveCParserDIV_ASSIGN-137))|(1<<(ObjectiveCParserAND_ASSIGN-137))|(1<<(ObjectiveCParserOR_ASSIGN-137))|(1<<(ObjectiveCParserXOR_ASSIGN-137))|(1<<(ObjectiveCParserMOD_ASSIGN-137))|(1<<(ObjectiveCParserLSHIFT_ASSIGN-137)))) != 0) || _la == ObjectiveCParserRSHIFT_ASSIGN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICastExpressionContext is an interface to support dynamic dispatch.
type ICastExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastExpressionContext differentiates from other interfaces.
	IsCastExpressionContext()
}

type CastExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastExpressionContext() *CastExpressionContext {
	var p = new(CastExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_castExpression
	return p
}

func (*CastExpressionContext) IsCastExpressionContext() {}

func NewCastExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastExpressionContext {
	var p = new(CastExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_castExpression

	return p
}

func (s *CastExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *CastExpressionContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *CastExpressionContext) TypeName() ITypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *CastExpressionContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *CastExpressionContext) CastExpression() ICastExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *CastExpressionContext) Initializer() IInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterCastExpression(s)
	}
}

func (s *CastExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitCastExpression(s)
	}
}

func (p *ObjectiveCParser) CastExpression() (localctx ICastExpressionContext) {
	this := p
	_ = this

	localctx = NewCastExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, ObjectiveCParserRULE_castExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1566)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1557)
			p.UnaryExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1558)
			p.Match(ObjectiveCParserLP)
		}
		{
			p.SetState(1559)
			p.TypeName()
		}
		{
			p.SetState(1560)
			p.Match(ObjectiveCParserRP)
		}

		p.SetState(1564)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 202, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1562)
				p.CastExpression()
			}

		case 2:
			{
				p.SetState(1563)
				p.Initializer()
			}

		}

	}

	return localctx
}

// IInitializerContext is an interface to support dynamic dispatch.
type IInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializerContext differentiates from other interfaces.
	IsInitializerContext()
}

type InitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerContext() *InitializerContext {
	var p = new(InitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_initializer
	return p
}

func (*InitializerContext) IsInitializerContext() {}

func NewInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerContext {
	var p = new(InitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_initializer

	return p
}

func (s *InitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InitializerContext) ArrayInitializer() IArrayInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *InitializerContext) StructInitializer() IStructInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStructInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStructInitializerContext)
}

func (s *InitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterInitializer(s)
	}
}

func (s *InitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitInitializer(s)
	}
}

func (p *ObjectiveCParser) Initializer() (localctx IInitializerContext) {
	this := p
	_ = this

	localctx = NewInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, ObjectiveCParserRULE_initializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1568)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1569)
			p.ArrayInitializer()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1570)
			p.StructInitializer()
		}

	}

	return localctx
}

// IConstantExpressionContext is an interface to support dynamic dispatch.
type IConstantExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantExpressionContext differentiates from other interfaces.
	IsConstantExpressionContext()
}

type ConstantExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantExpressionContext() *ConstantExpressionContext {
	var p = new(ConstantExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_constantExpression
	return p
}

func (*ConstantExpressionContext) IsConstantExpressionContext() {}

func NewConstantExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantExpressionContext {
	var p = new(ConstantExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_constantExpression

	return p
}

func (s *ConstantExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantExpressionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstantExpressionContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterConstantExpression(s)
	}
}

func (s *ConstantExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitConstantExpression(s)
	}
}

func (p *ObjectiveCParser) ConstantExpression() (localctx IConstantExpressionContext) {
	this := p
	_ = this

	localctx = NewConstantExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, ObjectiveCParserRULE_constantExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1575)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserBOOL, ObjectiveCParserClass, ObjectiveCParserBYCOPY, ObjectiveCParserBYREF, ObjectiveCParserID, ObjectiveCParserIMP, ObjectiveCParserIN, ObjectiveCParserINOUT, ObjectiveCParserONEWAY, ObjectiveCParserOUT, ObjectiveCParserPROTOCOL_, ObjectiveCParserSEL, ObjectiveCParserSELF, ObjectiveCParserSUPER, ObjectiveCParserATOMIC, ObjectiveCParserNONATOMIC, ObjectiveCParserRETAIN, ObjectiveCParserAUTORELEASING_QUALIFIER, ObjectiveCParserBLOCK, ObjectiveCParserBRIDGE_RETAINED, ObjectiveCParserBRIDGE_TRANSFER, ObjectiveCParserCOVARIANT, ObjectiveCParserCONTRAVARIANT, ObjectiveCParserDEPRECATED, ObjectiveCParserKINDOF, ObjectiveCParserUNUSED, ObjectiveCParserNULL_UNSPECIFIED, ObjectiveCParserNULLABLE, ObjectiveCParserNONNULL, ObjectiveCParserNULL_RESETTABLE, ObjectiveCParserNS_INLINE, ObjectiveCParserNS_ENUM, ObjectiveCParserNS_OPTIONS, ObjectiveCParserASSIGN, ObjectiveCParserCOPY, ObjectiveCParserGETTER, ObjectiveCParserSETTER, ObjectiveCParserSTRONG, ObjectiveCParserREADONLY, ObjectiveCParserREADWRITE, ObjectiveCParserWEAK, ObjectiveCParserUNSAFE_UNRETAINED, ObjectiveCParserIB_OUTLET, ObjectiveCParserIB_OUTLET_COLLECTION, ObjectiveCParserIB_INSPECTABLE, ObjectiveCParserIB_DESIGNABLE, ObjectiveCParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1573)
			p.Identifier()
		}

	case ObjectiveCParserTRUE, ObjectiveCParserFALSE, ObjectiveCParserNIL, ObjectiveCParserNO, ObjectiveCParserNULL_, ObjectiveCParserYES, ObjectiveCParserADD, ObjectiveCParserSUB, ObjectiveCParserCHARACTER_LITERAL, ObjectiveCParserHEX_LITERAL, ObjectiveCParserOCTAL_LITERAL, ObjectiveCParserBINARY_LITERAL, ObjectiveCParserDECIMAL_LITERAL, ObjectiveCParserFLOATING_POINT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1574)
			p.Constant()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnaryExpressionContext is an interface to support dynamic dispatch.
type IUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsUnaryExpressionContext differentiates from other interfaces.
	IsUnaryExpressionContext()
}

type UnaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyUnaryExpressionContext() *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_unaryExpression
	return p
}

func (*UnaryExpressionContext) IsUnaryExpressionContext() {}

func NewUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_unaryExpression

	return p
}

func (s *UnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExpressionContext) GetOp() antlr.Token { return s.op }

func (s *UnaryExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *UnaryExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *UnaryExpressionContext) SIZEOF() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSIZEOF, 0)
}

func (s *UnaryExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *UnaryExpressionContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *UnaryExpressionContext) TypeSpecifier() ITypeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *UnaryExpressionContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *UnaryExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserINC, 0)
}

func (s *UnaryExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserDEC, 0)
}

func (s *UnaryExpressionContext) UnaryOperator() IUnaryOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *UnaryExpressionContext) CastExpression() ICastExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *UnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitUnaryExpression(s)
	}
}

func (p *ObjectiveCParser) UnaryExpression() (localctx IUnaryExpressionContext) {
	this := p
	_ = this

	localctx = NewUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, ObjectiveCParserRULE_unaryExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1591)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1577)
			p.postfixExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1578)
			p.Match(ObjectiveCParserSIZEOF)
		}
		p.SetState(1584)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 206, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1579)
				p.UnaryExpression()
			}

		case 2:
			{
				p.SetState(1580)
				p.Match(ObjectiveCParserLP)
			}
			{
				p.SetState(1581)
				p.TypeSpecifier()
			}
			{
				p.SetState(1582)
				p.Match(ObjectiveCParserRP)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1586)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnaryExpressionContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == ObjectiveCParserINC || _la == ObjectiveCParserDEC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnaryExpressionContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1587)
			p.UnaryExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1588)
			p.UnaryOperator()
		}
		{
			p.SetState(1589)
			p.CastExpression()
		}

	}

	return localctx
}

// IUnaryOperatorContext is an interface to support dynamic dispatch.
type IUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryOperatorContext differentiates from other interfaces.
	IsUnaryOperatorContext()
}

type UnaryOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryOperatorContext() *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_unaryOperator
	return p
}

func (*UnaryOperatorContext) IsUnaryOperatorContext() {}

func NewUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_unaryOperator

	return p
}

func (s *UnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryOperatorContext) BITAND() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBITAND, 0)
}

func (s *UnaryOperatorContext) MUL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserMUL, 0)
}

func (s *UnaryOperatorContext) ADD() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserADD, 0)
}

func (s *UnaryOperatorContext) SUB() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSUB, 0)
}

func (s *UnaryOperatorContext) TILDE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserTILDE, 0)
}

func (s *UnaryOperatorContext) BANG() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBANG, 0)
}

func (s *UnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitUnaryOperator(s)
	}
}

func (p *ObjectiveCParser) UnaryOperator() (localctx IUnaryOperatorContext) {
	this := p
	_ = this

	localctx = NewUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, ObjectiveCParserRULE_unaryOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1593)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(ObjectiveCParserBANG-140))|(1<<(ObjectiveCParserTILDE-140))|(1<<(ObjectiveCParserADD-140))|(1<<(ObjectiveCParserSUB-140))|(1<<(ObjectiveCParserMUL-140))|(1<<(ObjectiveCParserBITAND-140)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPostfixExpressionContext is an interface to support dynamic dispatch.
type IPostfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixExpressionContext differentiates from other interfaces.
	IsPostfixExpressionContext()
}

type PostfixExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExpressionContext() *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_postfixExpression
	return p
}

func (*PostfixExpressionContext) IsPostfixExpressionContext() {}

func NewPostfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_postfixExpression

	return p
}

func (s *PostfixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PostfixExpressionContext) AllPostfix() []IPostfixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPostfixContext)(nil)).Elem())
	var tst = make([]IPostfixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPostfixContext)
		}
	}

	return tst
}

func (s *PostfixExpressionContext) Postfix(i int) IPostfixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPostfixContext)
}

func (s *PostfixExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *PostfixExpressionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PostfixExpressionContext) DOT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserDOT, 0)
}

func (s *PostfixExpressionContext) STRUCTACCESS() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSTRUCTACCESS, 0)
}

func (s *PostfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterPostfixExpression(s)
	}
}

func (s *PostfixExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitPostfixExpression(s)
	}
}

func (p *ObjectiveCParser) PostfixExpression() (localctx IPostfixExpressionContext) {
	return p.postfixExpression(0)
}

func (p *ObjectiveCParser) postfixExpression(_p int) (localctx IPostfixExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPostfixExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPostfixExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 272
	p.EnterRecursionRule(localctx, 272, ObjectiveCParserRULE_postfixExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1596)
		p.PrimaryExpression()
	}
	p.SetState(1600)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1597)
				p.Postfix()
			}

		}
		p.SetState(1602)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext())
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1614)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewPostfixExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ObjectiveCParserRULE_postfixExpression)
			p.SetState(1603)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1604)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ObjectiveCParserDOT || _la == ObjectiveCParserSTRUCTACCESS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1605)
				p.Identifier()
			}
			p.SetState(1609)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 209, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1606)
						p.Postfix()
					}

				}
				p.SetState(1611)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 209, p.GetParserRuleContext())
			}

		}
		p.SetState(1616)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext())
	}

	return localctx
}

// IPostfixContext is an interface to support dynamic dispatch.
type IPostfixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RP returns the _RP token.
	Get_RP() antlr.Token

	// Get_tset3110 returns the _tset3110 token.
	Get_tset3110() antlr.Token

	// GetOp returns the op token.
	GetOp() antlr.Token

	// Set_RP sets the _RP token.
	Set_RP(antlr.Token)

	// Set_tset3110 sets the _tset3110 token.
	Set_tset3110(antlr.Token)

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetMacroArguments returns the macroArguments token list.
	GetMacroArguments() []antlr.Token

	// SetMacroArguments sets the macroArguments token list.
	SetMacroArguments([]antlr.Token)

	// IsPostfixContext differentiates from other interfaces.
	IsPostfixContext()
}

type PostfixContext struct {
	*antlr.BaseParserRuleContext
	parser         antlr.Parser
	_RP            antlr.Token
	macroArguments []antlr.Token
	_tset3110      antlr.Token
	op             antlr.Token
}

func NewEmptyPostfixContext() *PostfixContext {
	var p = new(PostfixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_postfix
	return p
}

func (*PostfixContext) IsPostfixContext() {}

func NewPostfixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixContext {
	var p = new(PostfixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_postfix

	return p
}

func (s *PostfixContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixContext) Get_RP() antlr.Token { return s._RP }

func (s *PostfixContext) Get_tset3110() antlr.Token { return s._tset3110 }

func (s *PostfixContext) GetOp() antlr.Token { return s.op }

func (s *PostfixContext) Set_RP(v antlr.Token) { s._RP = v }

func (s *PostfixContext) Set_tset3110(v antlr.Token) { s._tset3110 = v }

func (s *PostfixContext) SetOp(v antlr.Token) { s.op = v }

func (s *PostfixContext) GetMacroArguments() []antlr.Token { return s.macroArguments }

func (s *PostfixContext) SetMacroArguments(v []antlr.Token) { s.macroArguments = v }

func (s *PostfixContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLBRACK, 0)
}

func (s *PostfixContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PostfixContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRBRACK, 0)
}

func (s *PostfixContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *PostfixContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserRP)
}

func (s *PostfixContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, i)
}

func (s *PostfixContext) ArgumentExpressionList() IArgumentExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentExpressionListContext)
}

func (s *PostfixContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *PostfixContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *PostfixContext) INC() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserINC, 0)
}

func (s *PostfixContext) DEC() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserDEC, 0)
}

func (s *PostfixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterPostfix(s)
	}
}

func (s *PostfixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitPostfix(s)
	}
}

func (p *ObjectiveCParser) Postfix() (localctx IPostfixContext) {
	this := p
	_ = this

	localctx = NewPostfixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, ObjectiveCParserRULE_postfix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1635)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 214, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1617)
			p.Match(ObjectiveCParserLBRACK)
		}
		{
			p.SetState(1618)
			p.expression(0)
		}
		{
			p.SetState(1619)
			p.Match(ObjectiveCParserRBRACK)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1621)
			p.Match(ObjectiveCParserLP)
		}
		p.SetState(1623)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSIZEOF)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserTRUE-32))|(1<<(ObjectiveCParserFALSE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserNIL-32))|(1<<(ObjectiveCParserNO-32))|(1<<(ObjectiveCParserNULL_-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32))|(1<<(ObjectiveCParserYES-32))|(1<<(ObjectiveCParserENCODE-32)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(ObjectiveCParserPROTOCOL-69))|(1<<(ObjectiveCParserSELECTOR-69))|(1<<(ObjectiveCParserATOMIC-69))|(1<<(ObjectiveCParserNONATOMIC-69))|(1<<(ObjectiveCParserRETAIN-69))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-69))|(1<<(ObjectiveCParserBLOCK-69))|(1<<(ObjectiveCParserBRIDGE_RETAINED-69))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-69))|(1<<(ObjectiveCParserCOVARIANT-69))|(1<<(ObjectiveCParserCONTRAVARIANT-69))|(1<<(ObjectiveCParserDEPRECATED-69))|(1<<(ObjectiveCParserKINDOF-69))|(1<<(ObjectiveCParserTYPEOF-69))|(1<<(ObjectiveCParserUNUSED-69))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-69))|(1<<(ObjectiveCParserNULLABLE-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(ObjectiveCParserNONNULL-101))|(1<<(ObjectiveCParserNULL_RESETTABLE-101))|(1<<(ObjectiveCParserNS_INLINE-101))|(1<<(ObjectiveCParserNS_ENUM-101))|(1<<(ObjectiveCParserNS_OPTIONS-101))|(1<<(ObjectiveCParserASSIGN-101))|(1<<(ObjectiveCParserCOPY-101))|(1<<(ObjectiveCParserGETTER-101))|(1<<(ObjectiveCParserSETTER-101))|(1<<(ObjectiveCParserSTRONG-101))|(1<<(ObjectiveCParserREADONLY-101))|(1<<(ObjectiveCParserREADWRITE-101))|(1<<(ObjectiveCParserWEAK-101))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-101))|(1<<(ObjectiveCParserIB_OUTLET-101))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-101))|(1<<(ObjectiveCParserIB_INSPECTABLE-101))|(1<<(ObjectiveCParserIB_DESIGNABLE-101))|(1<<(ObjectiveCParserIDENTIFIER-101))|(1<<(ObjectiveCParserLP-101))|(1<<(ObjectiveCParserLBRACK-101)))) != 0) || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(ObjectiveCParserAT-136))|(1<<(ObjectiveCParserBANG-136))|(1<<(ObjectiveCParserTILDE-136))|(1<<(ObjectiveCParserINC-136))|(1<<(ObjectiveCParserDEC-136))|(1<<(ObjectiveCParserADD-136))|(1<<(ObjectiveCParserSUB-136))|(1<<(ObjectiveCParserMUL-136))|(1<<(ObjectiveCParserBITAND-136))|(1<<(ObjectiveCParserBITXOR-136)))) != 0) || (((_la-171)&-(0x1f+1)) == 0 && ((1<<uint((_la-171)))&((1<<(ObjectiveCParserCHARACTER_LITERAL-171))|(1<<(ObjectiveCParserSTRING_START-171))|(1<<(ObjectiveCParserHEX_LITERAL-171))|(1<<(ObjectiveCParserOCTAL_LITERAL-171))|(1<<(ObjectiveCParserBINARY_LITERAL-171))|(1<<(ObjectiveCParserDECIMAL_LITERAL-171))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-171)))) != 0) {
			{
				p.SetState(1622)
				p.ArgumentExpressionList()
			}

		}
		{
			p.SetState(1625)
			p.Match(ObjectiveCParserRP)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1626)
			p.Match(ObjectiveCParserLP)
		}
		p.SetState(1629)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ObjectiveCParserAUTO)|(1<<ObjectiveCParserBREAK)|(1<<ObjectiveCParserCASE)|(1<<ObjectiveCParserCHAR)|(1<<ObjectiveCParserCONST)|(1<<ObjectiveCParserCONTINUE)|(1<<ObjectiveCParserDEFAULT)|(1<<ObjectiveCParserDO)|(1<<ObjectiveCParserDOUBLE)|(1<<ObjectiveCParserELSE)|(1<<ObjectiveCParserENUM)|(1<<ObjectiveCParserEXTERN)|(1<<ObjectiveCParserFLOAT)|(1<<ObjectiveCParserFOR)|(1<<ObjectiveCParserGOTO)|(1<<ObjectiveCParserIF)|(1<<ObjectiveCParserINLINE)|(1<<ObjectiveCParserINT)|(1<<ObjectiveCParserLONG)|(1<<ObjectiveCParserREGISTER)|(1<<ObjectiveCParserRESTRICT)|(1<<ObjectiveCParserRETURN)|(1<<ObjectiveCParserSHORT)|(1<<ObjectiveCParserSIGNED)|(1<<ObjectiveCParserSIZEOF)|(1<<ObjectiveCParserSTATIC)|(1<<ObjectiveCParserSTRUCT)|(1<<ObjectiveCParserSWITCH)|(1<<ObjectiveCParserTYPEDEF)|(1<<ObjectiveCParserUNION)|(1<<ObjectiveCParserUNSIGNED))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ObjectiveCParserVOID-32))|(1<<(ObjectiveCParserVOLATILE-32))|(1<<(ObjectiveCParserWHILE-32))|(1<<(ObjectiveCParserBOOL_-32))|(1<<(ObjectiveCParserCOMPLEX-32))|(1<<(ObjectiveCParserIMAGINERY-32))|(1<<(ObjectiveCParserTRUE-32))|(1<<(ObjectiveCParserFALSE-32))|(1<<(ObjectiveCParserBOOL-32))|(1<<(ObjectiveCParserClass-32))|(1<<(ObjectiveCParserBYCOPY-32))|(1<<(ObjectiveCParserBYREF-32))|(1<<(ObjectiveCParserID-32))|(1<<(ObjectiveCParserIMP-32))|(1<<(ObjectiveCParserIN-32))|(1<<(ObjectiveCParserINOUT-32))|(1<<(ObjectiveCParserNIL-32))|(1<<(ObjectiveCParserNO-32))|(1<<(ObjectiveCParserNULL_-32))|(1<<(ObjectiveCParserONEWAY-32))|(1<<(ObjectiveCParserOUT-32))|(1<<(ObjectiveCParserPROTOCOL_-32))|(1<<(ObjectiveCParserSEL-32))|(1<<(ObjectiveCParserSELF-32))|(1<<(ObjectiveCParserSUPER-32))|(1<<(ObjectiveCParserYES-32))|(1<<(ObjectiveCParserAUTORELEASEPOOL-32))|(1<<(ObjectiveCParserCATCH-32))|(1<<(ObjectiveCParserCLASS-32))|(1<<(ObjectiveCParserDYNAMIC-32))|(1<<(ObjectiveCParserENCODE-32))|(1<<(ObjectiveCParserEND-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ObjectiveCParserFINALLY-64))|(1<<(ObjectiveCParserIMPLEMENTATION-64))|(1<<(ObjectiveCParserINTERFACE-64))|(1<<(ObjectiveCParserIMPORT-64))|(1<<(ObjectiveCParserPACKAGE-64))|(1<<(ObjectiveCParserPROTOCOL-64))|(1<<(ObjectiveCParserOPTIONAL-64))|(1<<(ObjectiveCParserPRIVATE-64))|(1<<(ObjectiveCParserPROPERTY-64))|(1<<(ObjectiveCParserPROTECTED-64))|(1<<(ObjectiveCParserPUBLIC-64))|(1<<(ObjectiveCParserREQUIRED-64))|(1<<(ObjectiveCParserSELECTOR-64))|(1<<(ObjectiveCParserSYNCHRONIZED-64))|(1<<(ObjectiveCParserSYNTHESIZE-64))|(1<<(ObjectiveCParserTHROW-64))|(1<<(ObjectiveCParserTRY-64))|(1<<(ObjectiveCParserATOMIC-64))|(1<<(ObjectiveCParserNONATOMIC-64))|(1<<(ObjectiveCParserRETAIN-64))|(1<<(ObjectiveCParserATTRIBUTE-64))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-64))|(1<<(ObjectiveCParserBLOCK-64))|(1<<(ObjectiveCParserBRIDGE-64))|(1<<(ObjectiveCParserBRIDGE_RETAINED-64))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-64))|(1<<(ObjectiveCParserCOVARIANT-64))|(1<<(ObjectiveCParserCONTRAVARIANT-64))|(1<<(ObjectiveCParserDEPRECATED-64))|(1<<(ObjectiveCParserKINDOF-64))|(1<<(ObjectiveCParserSTRONG_QUALIFIER-64))|(1<<(ObjectiveCParserTYPEOF-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ObjectiveCParserUNSAFE_UNRETAINED_QUALIFIER-96))|(1<<(ObjectiveCParserUNUSED-96))|(1<<(ObjectiveCParserWEAK_QUALIFIER-96))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-96))|(1<<(ObjectiveCParserNULLABLE-96))|(1<<(ObjectiveCParserNONNULL-96))|(1<<(ObjectiveCParserNULL_RESETTABLE-96))|(1<<(ObjectiveCParserNS_INLINE-96))|(1<<(ObjectiveCParserNS_ENUM-96))|(1<<(ObjectiveCParserNS_OPTIONS-96))|(1<<(ObjectiveCParserASSIGN-96))|(1<<(ObjectiveCParserCOPY-96))|(1<<(ObjectiveCParserGETTER-96))|(1<<(ObjectiveCParserSETTER-96))|(1<<(ObjectiveCParserSTRONG-96))|(1<<(ObjectiveCParserREADONLY-96))|(1<<(ObjectiveCParserREADWRITE-96))|(1<<(ObjectiveCParserWEAK-96))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-96))|(1<<(ObjectiveCParserIB_OUTLET-96))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-96))|(1<<(ObjectiveCParserIB_INSPECTABLE-96))|(1<<(ObjectiveCParserIB_DESIGNABLE-96))|(1<<(ObjectiveCParserNS_ASSUME_NONNULL_BEGIN-96))|(1<<(ObjectiveCParserNS_ASSUME_NONNULL_END-96))|(1<<(ObjectiveCParserEXTERN_SUFFIX-96))|(1<<(ObjectiveCParserIOS_SUFFIX-96))|(1<<(ObjectiveCParserMAC_SUFFIX-96))|(1<<(ObjectiveCParserTVOS_PROHIBITED-96))|(1<<(ObjectiveCParserIDENTIFIER-96))|(1<<(ObjectiveCParserLP-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(ObjectiveCParserLBRACE-128))|(1<<(ObjectiveCParserRBRACE-128))|(1<<(ObjectiveCParserLBRACK-128))|(1<<(ObjectiveCParserRBRACK-128))|(1<<(ObjectiveCParserSEMI-128))|(1<<(ObjectiveCParserCOMMA-128))|(1<<(ObjectiveCParserDOT-128))|(1<<(ObjectiveCParserSTRUCTACCESS-128))|(1<<(ObjectiveCParserAT-128))|(1<<(ObjectiveCParserASSIGNMENT-128))|(1<<(ObjectiveCParserGT-128))|(1<<(ObjectiveCParserLT-128))|(1<<(ObjectiveCParserBANG-128))|(1<<(ObjectiveCParserTILDE-128))|(1<<(ObjectiveCParserQUESTION-128))|(1<<(ObjectiveCParserCOLON-128))|(1<<(ObjectiveCParserEQUAL-128))|(1<<(ObjectiveCParserLE-128))|(1<<(ObjectiveCParserGE-128))|(1<<(ObjectiveCParserNOTEQUAL-128))|(1<<(ObjectiveCParserAND-128))|(1<<(ObjectiveCParserOR-128))|(1<<(ObjectiveCParserINC-128))|(1<<(ObjectiveCParserDEC-128))|(1<<(ObjectiveCParserADD-128))|(1<<(ObjectiveCParserSUB-128))|(1<<(ObjectiveCParserMUL-128))|(1<<(ObjectiveCParserDIV-128))|(1<<(ObjectiveCParserBITAND-128))|(1<<(ObjectiveCParserBITOR-128))|(1<<(ObjectiveCParserBITXOR-128))|(1<<(ObjectiveCParserMOD-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(ObjectiveCParserADD_ASSIGN-160))|(1<<(ObjectiveCParserSUB_ASSIGN-160))|(1<<(ObjectiveCParserMUL_ASSIGN-160))|(1<<(ObjectiveCParserDIV_ASSIGN-160))|(1<<(ObjectiveCParserAND_ASSIGN-160))|(1<<(ObjectiveCParserOR_ASSIGN-160))|(1<<(ObjectiveCParserXOR_ASSIGN-160))|(1<<(ObjectiveCParserMOD_ASSIGN-160))|(1<<(ObjectiveCParserLSHIFT_ASSIGN-160))|(1<<(ObjectiveCParserRSHIFT_ASSIGN-160))|(1<<(ObjectiveCParserELIPSIS-160))|(1<<(ObjectiveCParserCHARACTER_LITERAL-160))|(1<<(ObjectiveCParserSTRING_START-160))|(1<<(ObjectiveCParserHEX_LITERAL-160))|(1<<(ObjectiveCParserOCTAL_LITERAL-160))|(1<<(ObjectiveCParserBINARY_LITERAL-160))|(1<<(ObjectiveCParserDECIMAL_LITERAL-160))|(1<<(ObjectiveCParserFLOATING_POINT_LITERAL-160))|(1<<(ObjectiveCParserWS-160))|(1<<(ObjectiveCParserMULTI_COMMENT-160))|(1<<(ObjectiveCParserSINGLE_COMMENT-160))|(1<<(ObjectiveCParserBACKSLASH-160))|(1<<(ObjectiveCParserSHARP-160))|(1<<(ObjectiveCParserSTRING_NEWLINE-160))|(1<<(ObjectiveCParserSTRING_END-160))|(1<<(ObjectiveCParserSTRING_VALUE-160))|(1<<(ObjectiveCParserDIRECTIVE_IMPORT-160))|(1<<(ObjectiveCParserDIRECTIVE_INCLUDE-160))|(1<<(ObjectiveCParserDIRECTIVE_PRAGMA-160))|(1<<(ObjectiveCParserDIRECTIVE_DEFINE-160))|(1<<(ObjectiveCParserDIRECTIVE_DEFINED-160))|(1<<(ObjectiveCParserDIRECTIVE_IF-160)))) != 0) || (((_la-192)&-(0x1f+1)) == 0 && ((1<<uint((_la-192)))&((1<<(ObjectiveCParserDIRECTIVE_ELIF-192))|(1<<(ObjectiveCParserDIRECTIVE_ELSE-192))|(1<<(ObjectiveCParserDIRECTIVE_UNDEF-192))|(1<<(ObjectiveCParserDIRECTIVE_IFDEF-192))|(1<<(ObjectiveCParserDIRECTIVE_IFNDEF-192))|(1<<(ObjectiveCParserDIRECTIVE_ENDIF-192))|(1<<(ObjectiveCParserDIRECTIVE_TRUE-192))|(1<<(ObjectiveCParserDIRECTIVE_FALSE-192))|(1<<(ObjectiveCParserDIRECTIVE_ERROR-192))|(1<<(ObjectiveCParserDIRECTIVE_WARNING-192))|(1<<(ObjectiveCParserDIRECTIVE_BANG-192))|(1<<(ObjectiveCParserDIRECTIVE_LP-192))|(1<<(ObjectiveCParserDIRECTIVE_RP-192))|(1<<(ObjectiveCParserDIRECTIVE_EQUAL-192))|(1<<(ObjectiveCParserDIRECTIVE_NOTEQUAL-192))|(1<<(ObjectiveCParserDIRECTIVE_AND-192))|(1<<(ObjectiveCParserDIRECTIVE_OR-192))|(1<<(ObjectiveCParserDIRECTIVE_LT-192))|(1<<(ObjectiveCParserDIRECTIVE_GT-192))|(1<<(ObjectiveCParserDIRECTIVE_LE-192))|(1<<(ObjectiveCParserDIRECTIVE_GE-192))|(1<<(ObjectiveCParserDIRECTIVE_STRING-192))|(1<<(ObjectiveCParserDIRECTIVE_ID-192))|(1<<(ObjectiveCParserDIRECTIVE_DECIMAL_LITERAL-192))|(1<<(ObjectiveCParserDIRECTIVE_FLOAT-192))|(1<<(ObjectiveCParserDIRECTIVE_NEWLINE-192))|(1<<(ObjectiveCParserDIRECTIVE_MULTI_COMMENT-192))|(1<<(ObjectiveCParserDIRECTIVE_SINGLE_COMMENT-192))|(1<<(ObjectiveCParserDIRECTIVE_BACKSLASH_NEWLINE-192))|(1<<(ObjectiveCParserDIRECTIVE_TEXT_NEWLINE-192))|(1<<(ObjectiveCParserDIRECTIVE_TEXT-192)))) != 0) {
			p.SetState(1629)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 212, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1627)
					p.Match(ObjectiveCParserCOMMA)
				}

			case 2:
				{
					p.SetState(1628)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*PostfixContext)._tset3110 = _lt

					_la = p.GetTokenStream().LA(1)

					if _la <= 0 || _la == ObjectiveCParserRP {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*PostfixContext)._tset3110 = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				localctx.(*PostfixContext).macroArguments = append(localctx.(*PostfixContext).macroArguments, localctx.(*PostfixContext)._tset3110)

			}

			p.SetState(1631)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1633)
			p.Match(ObjectiveCParserRP)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1634)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PostfixContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == ObjectiveCParserINC || _la == ObjectiveCParserDEC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PostfixContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IArgumentExpressionListContext is an interface to support dynamic dispatch.
type IArgumentExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentExpressionListContext differentiates from other interfaces.
	IsArgumentExpressionListContext()
}

type ArgumentExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentExpressionListContext() *ArgumentExpressionListContext {
	var p = new(ArgumentExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_argumentExpressionList
	return p
}

func (*ArgumentExpressionListContext) IsArgumentExpressionListContext() {}

func NewArgumentExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentExpressionListContext {
	var p = new(ArgumentExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_argumentExpressionList

	return p
}

func (s *ArgumentExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentExpressionListContext) AllArgumentExpression() []IArgumentExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentExpressionContext)(nil)).Elem())
	var tst = make([]IArgumentExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentExpressionContext)
		}
	}

	return tst
}

func (s *ArgumentExpressionListContext) ArgumentExpression(i int) IArgumentExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentExpressionContext)
}

func (s *ArgumentExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserCOMMA)
}

func (s *ArgumentExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMA, i)
}

func (s *ArgumentExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterArgumentExpressionList(s)
	}
}

func (s *ArgumentExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitArgumentExpressionList(s)
	}
}

func (p *ObjectiveCParser) ArgumentExpressionList() (localctx IArgumentExpressionListContext) {
	this := p
	_ = this

	localctx = NewArgumentExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, ObjectiveCParserRULE_argumentExpressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1637)
		p.ArgumentExpression()
	}
	p.SetState(1642)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ObjectiveCParserCOMMA {
		{
			p.SetState(1638)
			p.Match(ObjectiveCParserCOMMA)
		}
		{
			p.SetState(1639)
			p.ArgumentExpression()
		}

		p.SetState(1644)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArgumentExpressionContext is an interface to support dynamic dispatch.
type IArgumentExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentExpressionContext differentiates from other interfaces.
	IsArgumentExpressionContext()
}

type ArgumentExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentExpressionContext() *ArgumentExpressionContext {
	var p = new(ArgumentExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_argumentExpression
	return p
}

func (*ArgumentExpressionContext) IsArgumentExpressionContext() {}

func NewArgumentExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentExpressionContext {
	var p = new(ArgumentExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_argumentExpression

	return p
}

func (s *ArgumentExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArgumentExpressionContext) TypeSpecifier() ITypeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *ArgumentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterArgumentExpression(s)
	}
}

func (s *ArgumentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitArgumentExpression(s)
	}
}

func (p *ObjectiveCParser) ArgumentExpression() (localctx IArgumentExpressionContext) {
	this := p
	_ = this

	localctx = NewArgumentExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, ObjectiveCParserRULE_argumentExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1647)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1645)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1646)
			p.TypeSpecifier()
		}

	}

	return localctx
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrimaryExpressionContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PrimaryExpressionContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PrimaryExpressionContext) LP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLP, 0)
}

func (s *PrimaryExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryExpressionContext) RP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRP, 0)
}

func (s *PrimaryExpressionContext) MessageExpression() IMessageExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessageExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMessageExpressionContext)
}

func (s *PrimaryExpressionContext) SelectorExpression() ISelectorExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorExpressionContext)
}

func (s *PrimaryExpressionContext) ProtocolExpression() IProtocolExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolExpressionContext)
}

func (s *PrimaryExpressionContext) EncodeExpression() IEncodeExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEncodeExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEncodeExpressionContext)
}

func (s *PrimaryExpressionContext) DictionaryExpression() IDictionaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryExpressionContext)
}

func (s *PrimaryExpressionContext) ArrayExpression() IArrayExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayExpressionContext)
}

func (s *PrimaryExpressionContext) BoxExpression() IBoxExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoxExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoxExpressionContext)
}

func (s *PrimaryExpressionContext) BlockExpression() IBlockExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockExpressionContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

func (p *ObjectiveCParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	this := p
	_ = this

	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, ObjectiveCParserRULE_primaryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1664)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 217, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1649)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1650)
			p.Constant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1651)
			p.StringLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1652)
			p.Match(ObjectiveCParserLP)
		}
		{
			p.SetState(1653)
			p.expression(0)
		}
		{
			p.SetState(1654)
			p.Match(ObjectiveCParserRP)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1656)
			p.MessageExpression()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1657)
			p.SelectorExpression()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1658)
			p.ProtocolExpression()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1659)
			p.EncodeExpression()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1660)
			p.DictionaryExpression()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1661)
			p.ArrayExpression()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1662)
			p.BoxExpression()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1663)
			p.BlockExpression()
		}

	}

	return localctx
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserHEX_LITERAL, 0)
}

func (s *ConstantContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserOCTAL_LITERAL, 0)
}

func (s *ConstantContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBINARY_LITERAL, 0)
}

func (s *ConstantContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserDECIMAL_LITERAL, 0)
}

func (s *ConstantContext) ADD() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserADD, 0)
}

func (s *ConstantContext) SUB() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSUB, 0)
}

func (s *ConstantContext) FLOATING_POINT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserFLOATING_POINT_LITERAL, 0)
}

func (s *ConstantContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCHARACTER_LITERAL, 0)
}

func (s *ConstantContext) NIL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNIL, 0)
}

func (s *ConstantContext) NULL_() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNULL_, 0)
}

func (s *ConstantContext) YES() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserYES, 0)
}

func (s *ConstantContext) NO() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNO, 0)
}

func (s *ConstantContext) TRUE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserTRUE, 0)
}

func (s *ConstantContext) FALSE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserFALSE, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (p *ObjectiveCParser) Constant() (localctx IConstantContext) {
	this := p
	_ = this

	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, ObjectiveCParserRULE_constant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1684)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 220, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1666)
			p.Match(ObjectiveCParserHEX_LITERAL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1667)
			p.Match(ObjectiveCParserOCTAL_LITERAL)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1668)
			p.Match(ObjectiveCParserBINARY_LITERAL)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1670)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ObjectiveCParserADD || _la == ObjectiveCParserSUB {
			{
				p.SetState(1669)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ObjectiveCParserADD || _la == ObjectiveCParserSUB) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1672)
			p.Match(ObjectiveCParserDECIMAL_LITERAL)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1674)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ObjectiveCParserADD || _la == ObjectiveCParserSUB {
			{
				p.SetState(1673)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ObjectiveCParserADD || _la == ObjectiveCParserSUB) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1676)
			p.Match(ObjectiveCParserFLOATING_POINT_LITERAL)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1677)
			p.Match(ObjectiveCParserCHARACTER_LITERAL)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1678)
			p.Match(ObjectiveCParserNIL)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1679)
			p.Match(ObjectiveCParserNULL_)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1680)
			p.Match(ObjectiveCParserYES)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1681)
			p.Match(ObjectiveCParserNO)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1682)
			p.Match(ObjectiveCParserTRUE)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1683)
			p.Match(ObjectiveCParserFALSE)
		}

	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllSTRING_START() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserSTRING_START)
}

func (s *StringLiteralContext) STRING_START(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSTRING_START, i)
}

func (s *StringLiteralContext) AllSTRING_END() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserSTRING_END)
}

func (s *StringLiteralContext) STRING_END(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSTRING_END, i)
}

func (s *StringLiteralContext) AllSTRING_VALUE() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserSTRING_VALUE)
}

func (s *StringLiteralContext) STRING_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSTRING_VALUE, i)
}

func (s *StringLiteralContext) AllSTRING_NEWLINE() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserSTRING_NEWLINE)
}

func (s *StringLiteralContext) STRING_NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSTRING_NEWLINE, i)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *ObjectiveCParser) StringLiteral() (localctx IStringLiteralContext) {
	this := p
	_ = this

	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, ObjectiveCParserRULE_stringLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1694)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1686)
				p.Match(ObjectiveCParserSTRING_START)
			}
			p.SetState(1690)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == ObjectiveCParserSTRING_NEWLINE || _la == ObjectiveCParserSTRING_VALUE {
				{
					p.SetState(1687)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ObjectiveCParserSTRING_NEWLINE || _la == ObjectiveCParserSTRING_VALUE) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

				p.SetState(1692)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1693)
				p.Match(ObjectiveCParserSTRING_END)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1696)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 222, p.GetParserRuleContext())
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIDENTIFIER, 0)
}

func (s *IdentifierContext) BOOL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBOOL, 0)
}

func (s *IdentifierContext) Class() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserClass, 0)
}

func (s *IdentifierContext) BYCOPY() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBYCOPY, 0)
}

func (s *IdentifierContext) BYREF() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBYREF, 0)
}

func (s *IdentifierContext) ID() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserID, 0)
}

func (s *IdentifierContext) IMP() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIMP, 0)
}

func (s *IdentifierContext) IN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIN, 0)
}

func (s *IdentifierContext) INOUT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserINOUT, 0)
}

func (s *IdentifierContext) ONEWAY() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserONEWAY, 0)
}

func (s *IdentifierContext) OUT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserOUT, 0)
}

func (s *IdentifierContext) PROTOCOL_() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserPROTOCOL_, 0)
}

func (s *IdentifierContext) SEL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSEL, 0)
}

func (s *IdentifierContext) SELF() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSELF, 0)
}

func (s *IdentifierContext) SUPER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSUPER, 0)
}

func (s *IdentifierContext) ATOMIC() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserATOMIC, 0)
}

func (s *IdentifierContext) NONATOMIC() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNONATOMIC, 0)
}

func (s *IdentifierContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserRETAIN, 0)
}

func (s *IdentifierContext) AUTORELEASING_QUALIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserAUTORELEASING_QUALIFIER, 0)
}

func (s *IdentifierContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBLOCK, 0)
}

func (s *IdentifierContext) BRIDGE_RETAINED() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBRIDGE_RETAINED, 0)
}

func (s *IdentifierContext) BRIDGE_TRANSFER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserBRIDGE_TRANSFER, 0)
}

func (s *IdentifierContext) COVARIANT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOVARIANT, 0)
}

func (s *IdentifierContext) CONTRAVARIANT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCONTRAVARIANT, 0)
}

func (s *IdentifierContext) DEPRECATED() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserDEPRECATED, 0)
}

func (s *IdentifierContext) KINDOF() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserKINDOF, 0)
}

func (s *IdentifierContext) UNUSED() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserUNUSED, 0)
}

func (s *IdentifierContext) NS_INLINE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNS_INLINE, 0)
}

func (s *IdentifierContext) NS_ENUM() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNS_ENUM, 0)
}

func (s *IdentifierContext) NS_OPTIONS() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNS_OPTIONS, 0)
}

func (s *IdentifierContext) NULL_UNSPECIFIED() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNULL_UNSPECIFIED, 0)
}

func (s *IdentifierContext) NULLABLE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNULLABLE, 0)
}

func (s *IdentifierContext) NONNULL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNONNULL, 0)
}

func (s *IdentifierContext) NULL_RESETTABLE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserNULL_RESETTABLE, 0)
}

func (s *IdentifierContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserASSIGN, 0)
}

func (s *IdentifierContext) COPY() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOPY, 0)
}

func (s *IdentifierContext) GETTER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserGETTER, 0)
}

func (s *IdentifierContext) SETTER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSETTER, 0)
}

func (s *IdentifierContext) STRONG() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSTRONG, 0)
}

func (s *IdentifierContext) READONLY() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserREADONLY, 0)
}

func (s *IdentifierContext) READWRITE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserREADWRITE, 0)
}

func (s *IdentifierContext) WEAK() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserWEAK, 0)
}

func (s *IdentifierContext) UNSAFE_UNRETAINED() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserUNSAFE_UNRETAINED, 0)
}

func (s *IdentifierContext) IB_OUTLET() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIB_OUTLET, 0)
}

func (s *IdentifierContext) IB_OUTLET_COLLECTION() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIB_OUTLET_COLLECTION, 0)
}

func (s *IdentifierContext) IB_INSPECTABLE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIB_INSPECTABLE, 0)
}

func (s *IdentifierContext) IB_DESIGNABLE() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIB_DESIGNABLE, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *ObjectiveCParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, ObjectiveCParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1698)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ObjectiveCParserBOOL-40))|(1<<(ObjectiveCParserClass-40))|(1<<(ObjectiveCParserBYCOPY-40))|(1<<(ObjectiveCParserBYREF-40))|(1<<(ObjectiveCParserID-40))|(1<<(ObjectiveCParserIMP-40))|(1<<(ObjectiveCParserIN-40))|(1<<(ObjectiveCParserINOUT-40))|(1<<(ObjectiveCParserONEWAY-40))|(1<<(ObjectiveCParserOUT-40))|(1<<(ObjectiveCParserPROTOCOL_-40))|(1<<(ObjectiveCParserSEL-40))|(1<<(ObjectiveCParserSELF-40))|(1<<(ObjectiveCParserSUPER-40)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(ObjectiveCParserATOMIC-81))|(1<<(ObjectiveCParserNONATOMIC-81))|(1<<(ObjectiveCParserRETAIN-81))|(1<<(ObjectiveCParserAUTORELEASING_QUALIFIER-81))|(1<<(ObjectiveCParserBLOCK-81))|(1<<(ObjectiveCParserBRIDGE_RETAINED-81))|(1<<(ObjectiveCParserBRIDGE_TRANSFER-81))|(1<<(ObjectiveCParserCOVARIANT-81))|(1<<(ObjectiveCParserCONTRAVARIANT-81))|(1<<(ObjectiveCParserDEPRECATED-81))|(1<<(ObjectiveCParserKINDOF-81))|(1<<(ObjectiveCParserUNUSED-81))|(1<<(ObjectiveCParserNULL_UNSPECIFIED-81))|(1<<(ObjectiveCParserNULLABLE-81))|(1<<(ObjectiveCParserNONNULL-81))|(1<<(ObjectiveCParserNULL_RESETTABLE-81))|(1<<(ObjectiveCParserNS_INLINE-81))|(1<<(ObjectiveCParserNS_ENUM-81))|(1<<(ObjectiveCParserNS_OPTIONS-81))|(1<<(ObjectiveCParserASSIGN-81))|(1<<(ObjectiveCParserCOPY-81))|(1<<(ObjectiveCParserGETTER-81))|(1<<(ObjectiveCParserSETTER-81))|(1<<(ObjectiveCParserSTRONG-81))|(1<<(ObjectiveCParserREADONLY-81))|(1<<(ObjectiveCParserREADWRITE-81)))) != 0) || (((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(ObjectiveCParserWEAK-113))|(1<<(ObjectiveCParserUNSAFE_UNRETAINED-113))|(1<<(ObjectiveCParserIB_OUTLET-113))|(1<<(ObjectiveCParserIB_OUTLET_COLLECTION-113))|(1<<(ObjectiveCParserIB_INSPECTABLE-113))|(1<<(ObjectiveCParserIB_DESIGNABLE-113))|(1<<(ObjectiveCParserIDENTIFIER-113)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *ObjectiveCParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 129:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 136:
		var t *PostfixExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PostfixExpressionContext)
		}
		return p.PostfixExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ObjectiveCParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ObjectiveCParser) PostfixExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
