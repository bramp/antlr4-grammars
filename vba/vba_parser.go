// Code generated from vba.g4 by ANTLR 4.9.3. DO NOT EDIT.

package vba // vba
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 222, 2651,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 3, 2, 3, 2, 3, 2, 3, 3, 5, 3, 301, 10, 3, 3, 3,
	7, 3, 304, 10, 3, 12, 3, 14, 3, 307, 11, 3, 3, 3, 3, 3, 7, 3, 311, 10,
	3, 12, 3, 14, 3, 314, 11, 3, 5, 3, 316, 10, 3, 3, 3, 5, 3, 319, 10, 3,
	3, 3, 7, 3, 322, 10, 3, 12, 3, 14, 3, 325, 11, 3, 3, 3, 5, 3, 328, 10,
	3, 3, 3, 7, 3, 331, 10, 3, 12, 3, 14, 3, 334, 11, 3, 3, 3, 5, 3, 337, 10,
	3, 3, 3, 7, 3, 340, 10, 3, 12, 3, 14, 3, 343, 11, 3, 3, 3, 5, 3, 346, 10,
	3, 3, 3, 7, 3, 349, 10, 3, 12, 3, 14, 3, 352, 11, 3, 3, 3, 5, 3, 355, 10,
	3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 5, 3, 5, 7, 5, 365, 10, 5, 12,
	5, 14, 5, 368, 11, 5, 3, 5, 6, 5, 371, 10, 5, 13, 5, 14, 5, 372, 3, 5,
	3, 5, 3, 6, 3, 6, 5, 6, 379, 10, 6, 3, 6, 3, 6, 5, 6, 383, 10, 6, 3, 6,
	3, 6, 7, 6, 387, 10, 6, 12, 6, 14, 6, 390, 11, 6, 3, 7, 3, 7, 6, 7, 394,
	10, 7, 13, 7, 14, 7, 395, 6, 7, 398, 10, 7, 13, 7, 14, 7, 399, 3, 8, 3,
	8, 6, 8, 404, 10, 8, 13, 8, 14, 8, 405, 3, 8, 3, 8, 7, 8, 410, 10, 8, 12,
	8, 14, 8, 413, 11, 8, 3, 8, 7, 8, 416, 10, 8, 12, 8, 14, 8, 419, 11, 8,
	3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 5, 9, 429, 10, 9, 3, 10,
	3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 441,
	10, 10, 3, 11, 3, 11, 5, 11, 445, 10, 11, 3, 12, 3, 12, 6, 12, 449, 10,
	12, 13, 12, 14, 12, 450, 3, 12, 3, 12, 7, 12, 455, 10, 12, 12, 12, 14,
	12, 458, 11, 12, 3, 12, 7, 12, 461, 10, 12, 12, 12, 14, 12, 464, 11, 12,
	3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 472, 10, 13, 3, 14, 3,
	14, 3, 14, 3, 14, 5, 14, 478, 10, 14, 3, 14, 3, 14, 5, 14, 482, 10, 14,
	3, 14, 3, 14, 5, 14, 486, 10, 14, 3, 14, 3, 14, 5, 14, 490, 10, 14, 3,
	14, 7, 14, 493, 10, 14, 12, 14, 14, 14, 496, 11, 14, 3, 15, 3, 15, 3, 15,
	3, 15, 7, 15, 502, 10, 15, 12, 15, 14, 15, 505, 11, 15, 3, 15, 3, 15, 3,
	16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
	3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
	16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
	3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
	16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
	3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
	16, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16, 577, 10, 16, 3, 17, 3, 17, 3, 17,
	3, 17, 5, 17, 583, 10, 17, 3, 17, 3, 17, 5, 17, 587, 10, 17, 3, 17, 5,
	17, 590, 10, 17, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19, 3, 19, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 606, 10, 21, 3, 21, 3,
	21, 5, 21, 610, 10, 21, 3, 21, 7, 21, 613, 10, 21, 12, 21, 14, 21, 616,
	11, 21, 5, 21, 618, 10, 21, 3, 22, 3, 22, 3, 22, 5, 22, 623, 10, 22, 3,
	22, 3, 22, 3, 22, 3, 22, 5, 22, 629, 10, 22, 3, 22, 3, 22, 5, 22, 633,
	10, 22, 3, 22, 7, 22, 636, 10, 22, 12, 22, 14, 22, 639, 11, 22, 3, 23,
	3, 23, 5, 23, 643, 10, 23, 3, 23, 3, 23, 5, 23, 647, 10, 23, 3, 23, 5,
	23, 650, 10, 23, 3, 23, 3, 23, 5, 23, 654, 10, 23, 3, 23, 3, 23, 3, 24,
	3, 24, 5, 24, 660, 10, 24, 3, 24, 3, 24, 5, 24, 664, 10, 24, 3, 24, 3,
	24, 3, 25, 3, 25, 3, 25, 5, 25, 671, 10, 25, 3, 25, 3, 25, 3, 25, 3, 25,
	5, 25, 677, 10, 25, 3, 25, 3, 25, 5, 25, 681, 10, 25, 3, 25, 5, 25, 684,
	10, 25, 3, 25, 3, 25, 3, 25, 5, 25, 689, 10, 25, 3, 25, 3, 25, 3, 25, 3,
	25, 3, 25, 3, 25, 3, 25, 3, 25, 5, 25, 699, 10, 25, 3, 25, 5, 25, 702,
	10, 25, 3, 25, 5, 25, 705, 10, 25, 3, 25, 3, 25, 5, 25, 709, 10, 25, 3,
	26, 3, 26, 3, 26, 3, 26, 5, 26, 715, 10, 26, 3, 26, 3, 26, 5, 26, 719,
	10, 26, 3, 26, 7, 26, 722, 10, 26, 12, 26, 14, 26, 725, 11, 26, 3, 27,
	3, 27, 3, 27, 3, 27, 5, 27, 731, 10, 27, 3, 27, 3, 27, 5, 27, 735, 10,
	27, 3, 27, 3, 27, 5, 27, 739, 10, 27, 3, 27, 3, 27, 5, 27, 743, 10, 27,
	3, 27, 5, 27, 746, 10, 27, 3, 28, 3, 28, 3, 28, 5, 28, 751, 10, 28, 3,
	28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 762,
	10, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28,
	3, 28, 3, 28, 5, 28, 775, 10, 28, 3, 29, 3, 29, 3, 30, 3, 30, 3, 30, 5,
	30, 782, 10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 789, 10, 30,
	12, 30, 14, 30, 792, 11, 30, 3, 30, 3, 30, 3, 31, 3, 31, 5, 31, 798, 10,
	31, 3, 31, 3, 31, 5, 31, 802, 10, 31, 3, 31, 5, 31, 805, 10, 31, 3, 31,
	3, 31, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32, 814, 10, 32, 3, 32, 7,
	32, 817, 10, 32, 12, 32, 14, 32, 820, 11, 32, 3, 33, 3, 33, 3, 33, 3, 33,
	3, 34, 3, 34, 3, 34, 5, 34, 829, 10, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5,
	34, 835, 10, 34, 3, 34, 3, 34, 3, 35, 3, 35, 3, 36, 3, 36, 3, 36, 3, 36,
	5, 36, 845, 10, 36, 3, 36, 3, 36, 5, 36, 849, 10, 36, 3, 36, 3, 36, 3,
	37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 859, 10, 37, 3, 37, 3, 37,
	3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 867, 10, 37, 3, 37, 3, 37, 3, 37, 5,
	37, 872, 10, 37, 3, 38, 3, 38, 3, 38, 3, 38, 5, 38, 878, 10, 38, 3, 38,
	3, 38, 5, 38, 882, 10, 38, 3, 38, 5, 38, 885, 10, 38, 3, 38, 3, 38, 5,
	38, 889, 10, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38,
	3, 38, 5, 38, 900, 10, 38, 3, 38, 3, 38, 5, 38, 904, 10, 38, 3, 38, 3,
	38, 3, 38, 5, 38, 909, 10, 38, 3, 39, 3, 39, 3, 39, 5, 39, 914, 10, 39,
	3, 39, 3, 39, 5, 39, 918, 10, 39, 3, 39, 3, 39, 5, 39, 922, 10, 39, 3,
	39, 3, 39, 5, 39, 926, 10, 39, 3, 39, 5, 39, 929, 10, 39, 3, 39, 5, 39,
	932, 10, 39, 3, 39, 5, 39, 935, 10, 39, 3, 39, 5, 39, 938, 10, 39, 3, 39,
	3, 39, 5, 39, 942, 10, 39, 3, 39, 3, 39, 3, 40, 3, 40, 3, 40, 3, 40, 5,
	40, 950, 10, 40, 3, 40, 3, 40, 5, 40, 954, 10, 40, 3, 40, 5, 40, 957, 10,
	40, 3, 40, 5, 40, 960, 10, 40, 3, 40, 3, 40, 5, 40, 964, 10, 40, 3, 40,
	3, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 3, 42, 3, 43, 3,
	43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43,
	987, 10, 43, 3, 43, 3, 43, 7, 43, 991, 10, 43, 12, 43, 14, 43, 994, 11,
	43, 3, 43, 5, 43, 997, 10, 43, 3, 43, 3, 43, 5, 43, 1001, 10, 43, 3, 44,
	3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 1010, 10, 44, 3, 45, 3,
	45, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 1021, 10, 46,
	3, 47, 3, 47, 3, 47, 5, 47, 1026, 10, 47, 3, 48, 3, 48, 3, 48, 3, 48, 3,
	49, 3, 49, 3, 49, 3, 49, 5, 49, 1036, 10, 49, 3, 49, 3, 49, 5, 49, 1040,
	10, 49, 3, 49, 6, 49, 1043, 10, 49, 13, 49, 14, 49, 1044, 3, 50, 3, 50,
	3, 50, 3, 50, 3, 51, 3, 51, 5, 51, 1053, 10, 51, 3, 51, 3, 51, 5, 51, 1057,
	10, 51, 3, 51, 3, 51, 5, 51, 1061, 10, 51, 3, 51, 3, 51, 3, 52, 3, 52,
	3, 52, 3, 52, 5, 52, 1069, 10, 52, 3, 52, 3, 52, 5, 52, 1073, 10, 52, 3,
	52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 53, 3, 54, 3, 54, 3, 54, 3, 54, 5, 54,
	1085, 10, 54, 3, 54, 3, 54, 5, 54, 1089, 10, 54, 3, 54, 3, 54, 3, 54, 3,
	54, 3, 54, 5, 54, 1096, 10, 54, 5, 54, 1098, 10, 54, 3, 55, 3, 55, 3, 55,
	3, 55, 5, 55, 1104, 10, 55, 3, 55, 3, 55, 5, 55, 1108, 10, 55, 3, 55, 3,
	55, 3, 56, 3, 56, 5, 56, 1114, 10, 56, 3, 56, 3, 56, 5, 56, 1118, 10, 56,
	3, 56, 3, 56, 5, 56, 1122, 10, 56, 3, 56, 3, 56, 3, 57, 3, 57, 7, 57, 1128,
	10, 57, 12, 57, 14, 57, 1131, 11, 57, 3, 57, 5, 57, 1134, 10, 57, 3, 57,
	3, 57, 3, 58, 3, 58, 5, 58, 1140, 10, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3,
	58, 3, 58, 3, 58, 7, 58, 1149, 10, 58, 12, 58, 14, 58, 1152, 11, 58, 3,
	59, 3, 59, 5, 59, 1156, 10, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59,
	3, 59, 7, 59, 1165, 10, 59, 12, 59, 14, 59, 1168, 11, 59, 3, 60, 3, 60,
	3, 60, 3, 60, 3, 60, 7, 60, 1175, 10, 60, 12, 60, 14, 60, 1178, 11, 60,
	3, 61, 3, 61, 5, 61, 1182, 10, 61, 3, 61, 3, 61, 5, 61, 1186, 10, 61, 3,
	61, 3, 61, 5, 61, 1190, 10, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3, 62, 3, 62,
	3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 64, 3, 64, 3,
	64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 5, 64, 1214, 10, 64, 3, 65, 3, 65,
	3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 5, 65, 1224, 10, 65, 3, 65, 3,
	65, 5, 65, 1228, 10, 65, 3, 65, 7, 65, 1231, 10, 65, 12, 65, 14, 65, 1234,
	11, 65, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 5, 66,
	1244, 10, 66, 3, 66, 3, 66, 5, 66, 1248, 10, 66, 3, 66, 7, 66, 1251, 10,
	66, 12, 66, 14, 66, 1254, 11, 66, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3,
	67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67, 1267, 10, 67, 3, 67, 3, 67,
	5, 67, 1271, 10, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 5,
	67, 1280, 10, 67, 3, 67, 3, 67, 5, 67, 1284, 10, 67, 3, 67, 5, 67, 1287,
	10, 67, 3, 68, 3, 68, 5, 68, 1291, 10, 68, 3, 68, 3, 68, 5, 68, 1295, 10,
	68, 3, 68, 5, 68, 1298, 10, 68, 7, 68, 1300, 10, 68, 12, 68, 14, 68, 1303,
	11, 68, 3, 68, 5, 68, 1306, 10, 68, 3, 68, 5, 68, 1309, 10, 68, 3, 68,
	3, 68, 5, 68, 1313, 10, 68, 3, 68, 5, 68, 1316, 10, 68, 6, 68, 1318, 10,
	68, 13, 68, 14, 68, 1319, 5, 68, 1322, 10, 68, 3, 69, 3, 69, 3, 69, 5,
	69, 1327, 10, 69, 3, 69, 3, 69, 5, 69, 1331, 10, 69, 3, 69, 3, 69, 5, 69,
	1335, 10, 69, 3, 69, 3, 69, 5, 69, 1339, 10, 69, 5, 69, 1341, 10, 69, 3,
	70, 3, 70, 3, 70, 3, 70, 5, 70, 1347, 10, 70, 3, 70, 3, 70, 5, 70, 1351,
	10, 70, 3, 70, 5, 70, 1354, 10, 70, 3, 71, 3, 71, 3, 71, 5, 71, 1359, 10,
	71, 3, 71, 3, 71, 5, 71, 1363, 10, 71, 3, 71, 3, 71, 3, 71, 3, 71, 5, 71,
	1369, 10, 71, 3, 71, 5, 71, 1372, 10, 71, 3, 71, 5, 71, 1375, 10, 71, 3,
	71, 3, 71, 5, 71, 1379, 10, 71, 3, 71, 3, 71, 5, 71, 1383, 10, 71, 3, 71,
	3, 71, 3, 72, 3, 72, 3, 72, 5, 72, 1390, 10, 72, 3, 72, 3, 72, 5, 72, 1394,
	10, 72, 3, 72, 3, 72, 3, 72, 3, 72, 5, 72, 1400, 10, 72, 3, 72, 5, 72,
	1403, 10, 72, 3, 72, 3, 72, 5, 72, 1407, 10, 72, 3, 72, 3, 72, 3, 73, 3,
	73, 3, 73, 5, 73, 1414, 10, 73, 3, 73, 3, 73, 5, 73, 1418, 10, 73, 3, 73,
	3, 73, 3, 73, 3, 73, 5, 73, 1424, 10, 73, 3, 73, 5, 73, 1427, 10, 73, 3,
	73, 3, 73, 5, 73, 1431, 10, 73, 3, 73, 3, 73, 3, 74, 3, 74, 3, 74, 3, 74,
	5, 74, 1439, 10, 74, 3, 74, 3, 74, 5, 74, 1443, 10, 74, 3, 74, 5, 74, 1446,
	10, 74, 3, 74, 5, 74, 1449, 10, 74, 3, 74, 3, 74, 5, 74, 1453, 10, 74,
	3, 74, 3, 74, 3, 75, 3, 75, 3, 75, 3, 75, 5, 75, 1461, 10, 75, 3, 75, 3,
	75, 5, 75, 1465, 10, 75, 3, 75, 3, 75, 5, 75, 1469, 10, 75, 5, 75, 1471,
	10, 75, 3, 75, 5, 75, 1474, 10, 75, 3, 76, 3, 76, 3, 76, 5, 76, 1479, 10,
	76, 3, 77, 3, 77, 3, 77, 3, 77, 5, 77, 1485, 10, 77, 3, 77, 3, 77, 5, 77,
	1489, 10, 77, 3, 77, 3, 77, 5, 77, 1493, 10, 77, 3, 77, 7, 77, 1496, 10,
	77, 12, 77, 14, 77, 1499, 11, 77, 3, 78, 3, 78, 5, 78, 1503, 10, 78, 3,
	78, 3, 78, 5, 78, 1507, 10, 78, 3, 78, 3, 78, 5, 78, 1511, 10, 78, 3, 78,
	3, 78, 3, 78, 5, 78, 1516, 10, 78, 3, 79, 3, 79, 3, 80, 3, 80, 3, 80, 3,
	80, 5, 80, 1524, 10, 80, 5, 80, 1526, 10, 80, 3, 81, 3, 81, 3, 82, 3, 82,
	3, 82, 3, 82, 3, 83, 3, 83, 3, 83, 3, 83, 5, 83, 1538, 10, 83, 3, 83, 3,
	83, 5, 83, 1542, 10, 83, 3, 83, 3, 83, 3, 84, 3, 84, 3, 84, 3, 84, 5, 84,
	1550, 10, 84, 3, 84, 3, 84, 5, 84, 1554, 10, 84, 3, 84, 3, 84, 3, 85, 3,
	85, 3, 85, 3, 85, 5, 85, 1562, 10, 85, 3, 85, 3, 85, 5, 85, 1566, 10, 85,
	3, 85, 3, 85, 5, 85, 1570, 10, 85, 3, 85, 3, 85, 5, 85, 1574, 10, 85, 3,
	85, 3, 85, 5, 85, 1578, 10, 85, 3, 85, 3, 85, 5, 85, 1582, 10, 85, 3, 85,
	3, 85, 3, 86, 3, 86, 3, 86, 3, 86, 5, 86, 1590, 10, 86, 3, 86, 3, 86, 5,
	86, 1594, 10, 86, 3, 86, 3, 86, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87,
	3, 87, 7, 87, 1605, 10, 87, 12, 87, 14, 87, 1608, 11, 87, 3, 87, 3, 87,
	3, 88, 3, 88, 5, 88, 1614, 10, 88, 3, 88, 3, 88, 5, 88, 1618, 10, 88, 3,
	88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 5, 88, 1629,
	10, 88, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1636, 10, 89, 3, 90,
	3, 90, 3, 90, 5, 90, 1641, 10, 90, 3, 90, 3, 90, 5, 90, 1645, 10, 90, 3,
	90, 7, 90, 1648, 10, 90, 12, 90, 14, 90, 1651, 11, 90, 5, 90, 1653, 10,
	90, 3, 91, 3, 91, 3, 91, 3, 91, 5, 91, 1659, 10, 91, 3, 91, 3, 91, 5, 91,
	1663, 10, 91, 3, 91, 5, 91, 1666, 10, 91, 3, 92, 3, 92, 3, 92, 3, 92, 5,
	92, 1672, 10, 92, 3, 92, 3, 92, 5, 92, 1676, 10, 92, 3, 92, 3, 92, 3, 93,
	3, 93, 3, 93, 3, 93, 5, 93, 1684, 10, 93, 3, 93, 3, 93, 5, 93, 1688, 10,
	93, 3, 93, 3, 93, 3, 94, 3, 94, 3, 95, 3, 95, 3, 95, 5, 95, 1697, 10, 95,
	3, 95, 3, 95, 5, 95, 1701, 10, 95, 3, 95, 3, 95, 5, 95, 1705, 10, 95, 3,
	95, 3, 95, 5, 95, 1709, 10, 95, 3, 95, 5, 95, 1712, 10, 95, 3, 95, 3, 95,
	5, 95, 1716, 10, 95, 3, 95, 3, 95, 3, 96, 3, 96, 5, 96, 1722, 10, 96, 3,
	96, 3, 96, 5, 96, 1726, 10, 96, 3, 96, 3, 96, 3, 97, 3, 97, 3, 97, 5, 97,
	1733, 10, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 7, 97, 1740, 10, 97, 12,
	97, 14, 97, 1743, 11, 97, 3, 97, 3, 97, 3, 98, 3, 98, 5, 98, 1749, 10,
	98, 3, 98, 3, 98, 5, 98, 1753, 10, 98, 3, 98, 5, 98, 1756, 10, 98, 3, 98,
	5, 98, 1759, 10, 98, 3, 98, 5, 98, 1762, 10, 98, 3, 98, 3, 98, 5, 98, 1766,
	10, 98, 3, 98, 3, 98, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99,
	5, 99, 1777, 10, 99, 3, 100, 3, 100, 3, 100, 3, 100, 3, 101, 3, 101, 3,
	101, 3, 101, 5, 101, 1787, 10, 101, 3, 101, 3, 101, 5, 101, 1791, 10, 101,
	3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 5, 101, 1798, 10, 101, 5, 101,
	1800, 10, 101, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 5, 102, 1807, 10,
	102, 3, 102, 3, 102, 5, 102, 1811, 10, 102, 3, 102, 3, 102, 5, 102, 1815,
	10, 102, 3, 102, 7, 102, 1818, 10, 102, 12, 102, 14, 102, 1821, 11, 102,
	3, 102, 3, 102, 3, 102, 3, 102, 5, 102, 1827, 10, 102, 3, 102, 3, 102,
	3, 102, 3, 102, 3, 102, 5, 102, 1834, 10, 102, 3, 102, 3, 102, 3, 102,
	5, 102, 1839, 10, 102, 3, 102, 3, 102, 5, 102, 1843, 10, 102, 3, 102, 3,
	102, 3, 102, 3, 102, 5, 102, 1849, 10, 102, 3, 102, 3, 102, 3, 102, 5,
	102, 1854, 10, 102, 3, 102, 3, 102, 3, 102, 5, 102, 1859, 10, 102, 3, 102,
	5, 102, 1862, 10, 102, 3, 102, 3, 102, 5, 102, 1866, 10, 102, 3, 102, 3,
	102, 5, 102, 1870, 10, 102, 3, 102, 3, 102, 3, 102, 5, 102, 1875, 10, 102,
	3, 102, 3, 102, 5, 102, 1879, 10, 102, 3, 102, 3, 102, 3, 102, 5, 102,
	1884, 10, 102, 3, 102, 3, 102, 5, 102, 1888, 10, 102, 3, 102, 3, 102, 3,
	102, 5, 102, 1893, 10, 102, 3, 102, 3, 102, 5, 102, 1897, 10, 102, 3, 102,
	3, 102, 3, 102, 5, 102, 1902, 10, 102, 3, 102, 3, 102, 5, 102, 1906, 10,
	102, 3, 102, 3, 102, 3, 102, 5, 102, 1911, 10, 102, 3, 102, 3, 102, 5,
	102, 1915, 10, 102, 3, 102, 3, 102, 3, 102, 5, 102, 1920, 10, 102, 3, 102,
	3, 102, 5, 102, 1924, 10, 102, 3, 102, 3, 102, 3, 102, 5, 102, 1929, 10,
	102, 3, 102, 3, 102, 5, 102, 1933, 10, 102, 3, 102, 3, 102, 3, 102, 5,
	102, 1938, 10, 102, 3, 102, 3, 102, 5, 102, 1942, 10, 102, 3, 102, 3, 102,
	3, 102, 5, 102, 1947, 10, 102, 3, 102, 3, 102, 5, 102, 1951, 10, 102, 3,
	102, 3, 102, 3, 102, 5, 102, 1956, 10, 102, 3, 102, 3, 102, 5, 102, 1960,
	10, 102, 3, 102, 3, 102, 3, 102, 5, 102, 1965, 10, 102, 3, 102, 3, 102,
	5, 102, 1969, 10, 102, 3, 102, 3, 102, 3, 102, 5, 102, 1974, 10, 102, 3,
	102, 3, 102, 5, 102, 1978, 10, 102, 3, 102, 3, 102, 3, 102, 5, 102, 1983,
	10, 102, 3, 102, 3, 102, 5, 102, 1987, 10, 102, 3, 102, 3, 102, 3, 102,
	5, 102, 1992, 10, 102, 3, 102, 3, 102, 5, 102, 1996, 10, 102, 3, 102, 3,
	102, 3, 102, 5, 102, 2001, 10, 102, 3, 102, 3, 102, 5, 102, 2005, 10, 102,
	3, 102, 3, 102, 3, 102, 5, 102, 2010, 10, 102, 3, 102, 3, 102, 5, 102,
	2014, 10, 102, 3, 102, 3, 102, 3, 102, 5, 102, 2019, 10, 102, 3, 102, 3,
	102, 5, 102, 2023, 10, 102, 3, 102, 3, 102, 3, 102, 5, 102, 2028, 10, 102,
	3, 102, 3, 102, 5, 102, 2032, 10, 102, 3, 102, 3, 102, 3, 102, 5, 102,
	2037, 10, 102, 3, 102, 3, 102, 5, 102, 2041, 10, 102, 3, 102, 7, 102, 2044,
	10, 102, 12, 102, 14, 102, 2047, 11, 102, 3, 103, 3, 103, 3, 103, 5, 103,
	2052, 10, 103, 3, 103, 3, 103, 3, 103, 5, 103, 2057, 10, 103, 3, 103, 3,
	103, 3, 104, 3, 104, 5, 104, 2063, 10, 104, 3, 104, 3, 104, 5, 104, 2067,
	10, 104, 3, 104, 7, 104, 2070, 10, 104, 12, 104, 14, 104, 2073, 11, 104,
	3, 105, 3, 105, 5, 105, 2077, 10, 105, 3, 105, 3, 105, 5, 105, 2081, 10,
	105, 3, 105, 3, 105, 5, 105, 2085, 10, 105, 5, 105, 2087, 10, 105, 3, 105,
	3, 105, 5, 105, 2091, 10, 105, 5, 105, 2093, 10, 105, 3, 105, 5, 105, 2096,
	10, 105, 3, 105, 3, 105, 5, 105, 2100, 10, 105, 3, 106, 3, 106, 3, 106,
	3, 106, 3, 106, 5, 106, 2107, 10, 106, 3, 106, 3, 106, 3, 107, 3, 107,
	3, 107, 3, 107, 5, 107, 2115, 10, 107, 3, 107, 3, 107, 5, 107, 2119, 10,
	107, 3, 107, 3, 107, 3, 108, 3, 108, 3, 108, 3, 108, 3, 108, 3, 108, 5,
	108, 2129, 10, 108, 3, 108, 3, 108, 5, 108, 2133, 10, 108, 3, 108, 3, 108,
	3, 109, 3, 109, 3, 109, 3, 109, 5, 109, 2141, 10, 109, 3, 109, 3, 109,
	5, 109, 2145, 10, 109, 3, 109, 5, 109, 2148, 10, 109, 3, 110, 5, 110, 2151,
	10, 110, 3, 110, 3, 110, 3, 111, 3, 111, 5, 111, 2157, 10, 111, 3, 112,
	3, 112, 3, 112, 3, 112, 5, 112, 2163, 10, 112, 3, 112, 5, 112, 2166, 10,
	112, 3, 112, 3, 112, 5, 112, 2170, 10, 112, 3, 112, 3, 112, 5, 112, 2174,
	10, 112, 3, 112, 3, 112, 5, 112, 2178, 10, 112, 3, 112, 5, 112, 2181, 10,
	112, 3, 112, 3, 112, 3, 112, 3, 112, 7, 112, 2187, 10, 112, 12, 112, 14,
	112, 2190, 11, 112, 3, 113, 3, 113, 3, 113, 5, 113, 2195, 10, 113, 3, 113,
	3, 113, 3, 113, 5, 113, 2200, 10, 113, 3, 113, 5, 113, 2203, 10, 113, 3,
	113, 3, 113, 5, 113, 2207, 10, 113, 3, 113, 3, 113, 5, 113, 2211, 10, 113,
	3, 113, 3, 113, 5, 113, 2215, 10, 113, 3, 113, 5, 113, 2218, 10, 113, 3,
	113, 3, 113, 3, 113, 3, 113, 7, 113, 2224, 10, 113, 12, 113, 14, 113, 2227,
	11, 113, 3, 114, 3, 114, 5, 114, 2231, 10, 114, 3, 115, 5, 115, 2234, 10,
	115, 3, 115, 3, 115, 3, 115, 5, 115, 2239, 10, 115, 3, 115, 3, 115, 5,
	115, 2243, 10, 115, 3, 115, 5, 115, 2246, 10, 115, 3, 115, 5, 115, 2249,
	10, 115, 3, 115, 3, 115, 3, 115, 3, 115, 7, 115, 2255, 10, 115, 12, 115,
	14, 115, 2258, 11, 115, 3, 116, 3, 116, 3, 116, 5, 116, 2263, 10, 116,
	3, 116, 5, 116, 2266, 10, 116, 3, 116, 3, 116, 3, 116, 3, 116, 7, 116,
	2272, 10, 116, 12, 116, 14, 116, 2275, 11, 116, 3, 117, 3, 117, 3, 117,
	3, 117, 5, 117, 2281, 10, 117, 3, 118, 3, 118, 5, 118, 2285, 10, 118, 3,
	118, 5, 118, 2288, 10, 118, 3, 118, 5, 118, 2291, 10, 118, 3, 118, 3, 118,
	3, 118, 3, 118, 7, 118, 2297, 10, 118, 12, 118, 14, 118, 2300, 11, 118,
	3, 119, 3, 119, 5, 119, 2304, 10, 119, 3, 119, 5, 119, 2307, 10, 119, 3,
	119, 5, 119, 2310, 10, 119, 3, 119, 3, 119, 5, 119, 2314, 10, 119, 3, 119,
	3, 119, 5, 119, 2318, 10, 119, 5, 119, 2320, 10, 119, 3, 119, 3, 119, 5,
	119, 2324, 10, 119, 3, 119, 5, 119, 2327, 10, 119, 3, 119, 3, 119, 3, 119,
	3, 119, 7, 119, 2333, 10, 119, 12, 119, 14, 119, 2336, 11, 119, 3, 120,
	3, 120, 5, 120, 2340, 10, 120, 3, 120, 6, 120, 2343, 10, 120, 13, 120,
	14, 120, 2344, 3, 120, 5, 120, 2348, 10, 120, 3, 120, 5, 120, 2351, 10,
	120, 3, 120, 3, 120, 3, 120, 3, 120, 7, 120, 2357, 10, 120, 12, 120, 14,
	120, 2360, 11, 120, 3, 121, 3, 121, 3, 121, 5, 121, 2365, 10, 121, 3, 122,
	3, 122, 3, 123, 5, 123, 2370, 10, 123, 3, 123, 5, 123, 2373, 10, 123, 3,
	123, 3, 123, 5, 123, 2377, 10, 123, 7, 123, 2379, 10, 123, 12, 123, 14,
	123, 2382, 11, 123, 3, 123, 3, 123, 5, 123, 2386, 10, 123, 3, 123, 3, 123,
	5, 123, 2390, 10, 123, 3, 123, 5, 123, 2393, 10, 123, 7, 123, 2395, 10,
	123, 12, 123, 14, 123, 2398, 11, 123, 3, 124, 5, 124, 2401, 10, 124, 3,
	124, 3, 124, 5, 124, 2405, 10, 124, 3, 124, 5, 124, 2408, 10, 124, 3, 124,
	3, 124, 3, 125, 3, 125, 3, 125, 5, 125, 2415, 10, 125, 3, 126, 3, 126,
	5, 126, 2419, 10, 126, 3, 126, 3, 126, 5, 126, 2423, 10, 126, 3, 126, 3,
	126, 5, 126, 2427, 10, 126, 3, 126, 7, 126, 2430, 10, 126, 12, 126, 14,
	126, 2433, 11, 126, 5, 126, 2435, 10, 126, 3, 126, 5, 126, 2438, 10, 126,
	3, 126, 3, 126, 3, 127, 3, 127, 5, 127, 2444, 10, 127, 3, 127, 3, 127,
	5, 127, 2448, 10, 127, 3, 127, 3, 127, 5, 127, 2452, 10, 127, 3, 127, 3,
	127, 5, 127, 2456, 10, 127, 3, 127, 5, 127, 2459, 10, 127, 3, 127, 3, 127,
	5, 127, 2463, 10, 127, 3, 127, 5, 127, 2466, 10, 127, 3, 127, 5, 127, 2469,
	10, 127, 3, 127, 5, 127, 2472, 10, 127, 3, 127, 5, 127, 2475, 10, 127,
	3, 127, 5, 127, 2478, 10, 127, 3, 128, 3, 128, 5, 128, 2482, 10, 128, 3,
	128, 3, 128, 3, 129, 3, 129, 5, 129, 2488, 10, 129, 3, 129, 3, 129, 5,
	129, 2492, 10, 129, 3, 129, 7, 129, 2495, 10, 129, 12, 129, 14, 129, 2498,
	11, 129, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 5, 130, 2505, 10, 130,
	3, 130, 3, 130, 3, 131, 3, 131, 6, 131, 2511, 10, 131, 13, 131, 14, 131,
	2512, 3, 132, 3, 132, 5, 132, 2517, 10, 132, 3, 132, 3, 132, 5, 132, 2521,
	10, 132, 3, 132, 3, 132, 5, 132, 2525, 10, 132, 3, 132, 5, 132, 2528, 10,
	132, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133, 3,
	133, 3, 133, 5, 133, 2540, 10, 133, 3, 133, 3, 133, 5, 133, 2544, 10, 133,
	3, 133, 5, 133, 2547, 10, 133, 3, 133, 5, 133, 2550, 10, 133, 3, 134, 3,
	134, 3, 134, 7, 134, 2555, 10, 134, 12, 134, 14, 134, 2558, 11, 134, 3,
	134, 3, 134, 3, 134, 6, 134, 2563, 10, 134, 13, 134, 14, 134, 2564, 5,
	134, 2567, 10, 134, 3, 135, 3, 135, 3, 136, 3, 136, 3, 136, 7, 136, 2574,
	10, 136, 12, 136, 14, 136, 2577, 11, 136, 3, 137, 3, 137, 5, 137, 2581,
	10, 137, 3, 137, 3, 137, 5, 137, 2585, 10, 137, 3, 138, 3, 138, 5, 138,
	2589, 10, 138, 3, 138, 3, 138, 5, 138, 2593, 10, 138, 3, 138, 5, 138, 2596,
	10, 138, 3, 139, 3, 139, 3, 139, 3, 140, 3, 140, 3, 141, 3, 141, 5, 141,
	2605, 10, 141, 3, 141, 5, 141, 2608, 10, 141, 3, 141, 3, 141, 5, 141, 2612,
	10, 141, 3, 141, 5, 141, 2615, 10, 141, 3, 142, 3, 142, 3, 143, 3, 143,
	3, 144, 3, 144, 3, 145, 3, 145, 3, 146, 3, 146, 3, 147, 5, 147, 2628, 10,
	147, 3, 147, 3, 147, 3, 147, 5, 147, 2633, 10, 147, 3, 147, 5, 147, 2636,
	10, 147, 3, 148, 3, 148, 5, 148, 2640, 10, 148, 3, 148, 3, 148, 5, 148,
	2644, 10, 148, 7, 148, 2646, 10, 148, 12, 148, 14, 148, 2649, 11, 148,
	3, 148, 3, 818, 3, 202, 149, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
	26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60,
	62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96,
	98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126,
	128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156,
	158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186,
	188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216,
	218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246,
	248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276,
	278, 280, 282, 284, 286, 288, 290, 292, 294, 2, 21, 5, 2, 21, 21, 34, 34,
	169, 169, 3, 2, 37, 48, 4, 2, 178, 178, 182, 182, 3, 2, 70, 74, 5, 2, 191,
	191, 198, 198, 202, 202, 3, 2, 121, 122, 7, 2, 17, 17, 21, 21, 88, 88,
	130, 130, 141, 141, 4, 2, 144, 145, 186, 186, 4, 2, 101, 103, 160, 160,
	3, 2, 3, 4, 4, 2, 162, 162, 168, 168, 3, 2, 6, 7, 4, 2, 23, 24, 131, 131,
	3, 2, 23, 24, 7, 2, 89, 89, 99, 99, 191, 194, 196, 196, 200, 200, 6, 2,
	75, 75, 118, 119, 173, 173, 207, 213, 5, 2, 5, 5, 7, 10, 188, 188, 6, 2,
	77, 77, 81, 81, 134, 134, 139, 139, 11, 2, 11, 55, 64, 69, 75, 99, 104,
	104, 110, 120, 123, 124, 129, 134, 139, 144, 146, 187, 2, 3079, 2, 296,
	3, 2, 2, 2, 4, 300, 3, 2, 2, 2, 6, 356, 3, 2, 2, 2, 8, 362, 3, 2, 2, 2,
	10, 376, 3, 2, 2, 2, 12, 397, 3, 2, 2, 2, 14, 401, 3, 2, 2, 2, 16, 428,
	3, 2, 2, 2, 18, 440, 3, 2, 2, 2, 20, 444, 3, 2, 2, 2, 22, 446, 3, 2, 2,
	2, 24, 471, 3, 2, 2, 2, 26, 473, 3, 2, 2, 2, 28, 497, 3, 2, 2, 2, 30, 576,
	3, 2, 2, 2, 32, 578, 3, 2, 2, 2, 34, 591, 3, 2, 2, 2, 36, 593, 3, 2, 2,
	2, 38, 597, 3, 2, 2, 2, 40, 601, 3, 2, 2, 2, 42, 622, 3, 2, 2, 2, 44, 640,
	3, 2, 2, 2, 46, 657, 3, 2, 2, 2, 48, 670, 3, 2, 2, 2, 50, 710, 3, 2, 2,
	2, 52, 726, 3, 2, 2, 2, 54, 774, 3, 2, 2, 2, 56, 776, 3, 2, 2, 2, 58, 781,
	3, 2, 2, 2, 60, 795, 3, 2, 2, 2, 62, 808, 3, 2, 2, 2, 64, 821, 3, 2, 2,
	2, 66, 828, 3, 2, 2, 2, 68, 838, 3, 2, 2, 2, 70, 840, 3, 2, 2, 2, 72, 852,
	3, 2, 2, 2, 74, 873, 3, 2, 2, 2, 76, 913, 3, 2, 2, 2, 78, 945, 3, 2, 2,
	2, 80, 967, 3, 2, 2, 2, 82, 971, 3, 2, 2, 2, 84, 1000, 3, 2, 2, 2, 86,
	1002, 3, 2, 2, 2, 88, 1011, 3, 2, 2, 2, 90, 1013, 3, 2, 2, 2, 92, 1022,
	3, 2, 2, 2, 94, 1027, 3, 2, 2, 2, 96, 1031, 3, 2, 2, 2, 98, 1046, 3, 2,
	2, 2, 100, 1052, 3, 2, 2, 2, 102, 1064, 3, 2, 2, 2, 104, 1076, 3, 2, 2,
	2, 106, 1080, 3, 2, 2, 2, 108, 1099, 3, 2, 2, 2, 110, 1111, 3, 2, 2, 2,
	112, 1125, 3, 2, 2, 2, 114, 1137, 3, 2, 2, 2, 116, 1153, 3, 2, 2, 2, 118,
	1169, 3, 2, 2, 2, 120, 1179, 3, 2, 2, 2, 122, 1193, 3, 2, 2, 2, 124, 1197,
	3, 2, 2, 2, 126, 1205, 3, 2, 2, 2, 128, 1215, 3, 2, 2, 2, 130, 1235, 3,
	2, 2, 2, 132, 1255, 3, 2, 2, 2, 134, 1321, 3, 2, 2, 2, 136, 1340, 3, 2,
	2, 2, 138, 1342, 3, 2, 2, 2, 140, 1358, 3, 2, 2, 2, 142, 1389, 3, 2, 2,
	2, 144, 1413, 3, 2, 2, 2, 146, 1434, 3, 2, 2, 2, 148, 1456, 3, 2, 2, 2,
	150, 1475, 3, 2, 2, 2, 152, 1480, 3, 2, 2, 2, 154, 1500, 3, 2, 2, 2, 156,
	1517, 3, 2, 2, 2, 158, 1519, 3, 2, 2, 2, 160, 1527, 3, 2, 2, 2, 162, 1529,
	3, 2, 2, 2, 164, 1533, 3, 2, 2, 2, 166, 1545, 3, 2, 2, 2, 168, 1557, 3,
	2, 2, 2, 170, 1585, 3, 2, 2, 2, 172, 1597, 3, 2, 2, 2, 174, 1628, 3, 2,
	2, 2, 176, 1630, 3, 2, 2, 2, 178, 1652, 3, 2, 2, 2, 180, 1654, 3, 2, 2,
	2, 182, 1667, 3, 2, 2, 2, 184, 1679, 3, 2, 2, 2, 186, 1691, 3, 2, 2, 2,
	188, 1696, 3, 2, 2, 2, 190, 1719, 3, 2, 2, 2, 192, 1732, 3, 2, 2, 2, 194,
	1746, 3, 2, 2, 2, 196, 1769, 3, 2, 2, 2, 198, 1778, 3, 2, 2, 2, 200, 1782,
	3, 2, 2, 2, 202, 1861, 3, 2, 2, 2, 204, 2051, 3, 2, 2, 2, 206, 2060, 3,
	2, 2, 2, 208, 2074, 3, 2, 2, 2, 210, 2101, 3, 2, 2, 2, 212, 2110, 3, 2,
	2, 2, 214, 2122, 3, 2, 2, 2, 216, 2136, 3, 2, 2, 2, 218, 2150, 3, 2, 2,
	2, 220, 2156, 3, 2, 2, 2, 222, 2158, 3, 2, 2, 2, 224, 2191, 3, 2, 2, 2,
	226, 2230, 3, 2, 2, 2, 228, 2233, 3, 2, 2, 2, 230, 2259, 3, 2, 2, 2, 232,
	2280, 3, 2, 2, 2, 234, 2282, 3, 2, 2, 2, 236, 2303, 3, 2, 2, 2, 238, 2339,
	3, 2, 2, 2, 240, 2361, 3, 2, 2, 2, 242, 2366, 3, 2, 2, 2, 244, 2380, 3,
	2, 2, 2, 246, 2400, 3, 2, 2, 2, 248, 2411, 3, 2, 2, 2, 250, 2416, 3, 2,
	2, 2, 252, 2443, 3, 2, 2, 2, 254, 2479, 3, 2, 2, 2, 256, 2485, 3, 2, 2,
	2, 258, 2504, 3, 2, 2, 2, 260, 2510, 3, 2, 2, 2, 262, 2514, 3, 2, 2, 2,
	264, 2549, 3, 2, 2, 2, 266, 2566, 3, 2, 2, 2, 268, 2568, 3, 2, 2, 2, 270,
	2570, 3, 2, 2, 2, 272, 2578, 3, 2, 2, 2, 274, 2586, 3, 2, 2, 2, 276, 2597,
	3, 2, 2, 2, 278, 2600, 3, 2, 2, 2, 280, 2604, 3, 2, 2, 2, 282, 2616, 3,
	2, 2, 2, 284, 2618, 3, 2, 2, 2, 286, 2620, 3, 2, 2, 2, 288, 2622, 3, 2,
	2, 2, 290, 2624, 3, 2, 2, 2, 292, 2627, 3, 2, 2, 2, 294, 2647, 3, 2, 2,
	2, 296, 297, 5, 4, 3, 2, 297, 298, 7, 2, 2, 3, 298, 3, 3, 2, 2, 2, 299,
	301, 7, 221, 2, 2, 300, 299, 3, 2, 2, 2, 300, 301, 3, 2, 2, 2, 301, 305,
	3, 2, 2, 2, 302, 304, 5, 292, 147, 2, 303, 302, 3, 2, 2, 2, 304, 307, 3,
	2, 2, 2, 305, 303, 3, 2, 2, 2, 305, 306, 3, 2, 2, 2, 306, 315, 3, 2, 2,
	2, 307, 305, 3, 2, 2, 2, 308, 312, 5, 6, 4, 2, 309, 311, 5, 292, 147, 2,
	310, 309, 3, 2, 2, 2, 311, 314, 3, 2, 2, 2, 312, 310, 3, 2, 2, 2, 312,
	313, 3, 2, 2, 2, 313, 316, 3, 2, 2, 2, 314, 312, 3, 2, 2, 2, 315, 308,
	3, 2, 2, 2, 315, 316, 3, 2, 2, 2, 316, 318, 3, 2, 2, 2, 317, 319, 5, 8,
	5, 2, 318, 317, 3, 2, 2, 2, 318, 319, 3, 2, 2, 2, 319, 323, 3, 2, 2, 2,
	320, 322, 5, 292, 147, 2, 321, 320, 3, 2, 2, 2, 322, 325, 3, 2, 2, 2, 323,
	321, 3, 2, 2, 2, 323, 324, 3, 2, 2, 2, 324, 327, 3, 2, 2, 2, 325, 323,
	3, 2, 2, 2, 326, 328, 5, 12, 7, 2, 327, 326, 3, 2, 2, 2, 327, 328, 3, 2,
	2, 2, 328, 332, 3, 2, 2, 2, 329, 331, 5, 292, 147, 2, 330, 329, 3, 2, 2,
	2, 331, 334, 3, 2, 2, 2, 332, 330, 3, 2, 2, 2, 332, 333, 3, 2, 2, 2, 333,
	336, 3, 2, 2, 2, 334, 332, 3, 2, 2, 2, 335, 337, 5, 14, 8, 2, 336, 335,
	3, 2, 2, 2, 336, 337, 3, 2, 2, 2, 337, 341, 3, 2, 2, 2, 338, 340, 5, 292,
	147, 2, 339, 338, 3, 2, 2, 2, 340, 343, 3, 2, 2, 2, 341, 339, 3, 2, 2,
	2, 341, 342, 3, 2, 2, 2, 342, 345, 3, 2, 2, 2, 343, 341, 3, 2, 2, 2, 344,
	346, 5, 22, 12, 2, 345, 344, 3, 2, 2, 2, 345, 346, 3, 2, 2, 2, 346, 350,
	3, 2, 2, 2, 347, 349, 5, 292, 147, 2, 348, 347, 3, 2, 2, 2, 349, 352, 3,
	2, 2, 2, 350, 348, 3, 2, 2, 2, 350, 351, 3, 2, 2, 2, 351, 354, 3, 2, 2,
	2, 352, 350, 3, 2, 2, 2, 353, 355, 7, 221, 2, 2, 354, 353, 3, 2, 2, 2,
	354, 355, 3, 2, 2, 2, 355, 5, 3, 2, 2, 2, 356, 357, 7, 180, 2, 2, 357,
	358, 7, 221, 2, 2, 358, 359, 7, 212, 2, 2, 359, 360, 7, 221, 2, 2, 360,
	361, 7, 30, 2, 2, 361, 7, 3, 2, 2, 2, 362, 366, 7, 19, 2, 2, 363, 365,
	5, 292, 147, 2, 364, 363, 3, 2, 2, 2, 365, 368, 3, 2, 2, 2, 366, 364, 3,
	2, 2, 2, 366, 367, 3, 2, 2, 2, 367, 370, 3, 2, 2, 2, 368, 366, 3, 2, 2,
	2, 369, 371, 5, 10, 6, 2, 370, 369, 3, 2, 2, 2, 371, 372, 3, 2, 2, 2, 372,
	370, 3, 2, 2, 2, 372, 373, 3, 2, 2, 2, 373, 374, 3, 2, 2, 2, 374, 375,
	7, 64, 2, 2, 375, 9, 3, 2, 2, 2, 376, 378, 5, 260, 131, 2, 377, 379, 7,
	221, 2, 2, 378, 377, 3, 2, 2, 2, 378, 379, 3, 2, 2, 2, 379, 380, 3, 2,
	2, 2, 380, 382, 7, 191, 2, 2, 381, 383, 7, 221, 2, 2, 382, 381, 3, 2, 2,
	2, 382, 383, 3, 2, 2, 2, 383, 384, 3, 2, 2, 2, 384, 388, 5, 278, 140, 2,
	385, 387, 5, 292, 147, 2, 386, 385, 3, 2, 2, 2, 387, 390, 3, 2, 2, 2, 388,
	386, 3, 2, 2, 2, 388, 389, 3, 2, 2, 2, 389, 11, 3, 2, 2, 2, 390, 388, 3,
	2, 2, 2, 391, 393, 5, 26, 14, 2, 392, 394, 5, 292, 147, 2, 393, 392, 3,
	2, 2, 2, 394, 395, 3, 2, 2, 2, 395, 393, 3, 2, 2, 2, 395, 396, 3, 2, 2,
	2, 396, 398, 3, 2, 2, 2, 397, 391, 3, 2, 2, 2, 398, 399, 3, 2, 2, 2, 399,
	397, 3, 2, 2, 2, 399, 400, 3, 2, 2, 2, 400, 13, 3, 2, 2, 2, 401, 411, 5,
	18, 10, 2, 402, 404, 5, 292, 147, 2, 403, 402, 3, 2, 2, 2, 404, 405, 3,
	2, 2, 2, 405, 403, 3, 2, 2, 2, 405, 406, 3, 2, 2, 2, 406, 407, 3, 2, 2,
	2, 407, 408, 5, 18, 10, 2, 408, 410, 3, 2, 2, 2, 409, 403, 3, 2, 2, 2,
	410, 413, 3, 2, 2, 2, 411, 409, 3, 2, 2, 2, 411, 412, 3, 2, 2, 2, 412,
	417, 3, 2, 2, 2, 413, 411, 3, 2, 2, 2, 414, 416, 5, 292, 147, 2, 415, 414,
	3, 2, 2, 2, 416, 419, 3, 2, 2, 2, 417, 415, 3, 2, 2, 2, 417, 418, 3, 2,
	2, 2, 418, 15, 3, 2, 2, 2, 419, 417, 3, 2, 2, 2, 420, 421, 7, 125, 2, 2,
	421, 422, 7, 221, 2, 2, 422, 429, 7, 210, 2, 2, 423, 424, 7, 127, 2, 2,
	424, 425, 7, 221, 2, 2, 425, 429, 9, 2, 2, 2, 426, 429, 7, 126, 2, 2, 427,
	429, 7, 128, 2, 2, 428, 420, 3, 2, 2, 2, 428, 423, 3, 2, 2, 2, 428, 426,
	3, 2, 2, 2, 428, 427, 3, 2, 2, 2, 429, 17, 3, 2, 2, 2, 430, 441, 5, 290,
	146, 2, 431, 441, 5, 48, 25, 2, 432, 441, 5, 58, 30, 2, 433, 441, 5, 66,
	34, 2, 434, 441, 5, 42, 22, 2, 435, 441, 5, 94, 48, 2, 436, 441, 5, 204,
	103, 2, 437, 441, 5, 16, 9, 2, 438, 441, 5, 192, 97, 2, 439, 441, 5, 20,
	11, 2, 440, 430, 3, 2, 2, 2, 440, 431, 3, 2, 2, 2, 440, 432, 3, 2, 2, 2,
	440, 433, 3, 2, 2, 2, 440, 434, 3, 2, 2, 2, 440, 435, 3, 2, 2, 2, 440,
	436, 3, 2, 2, 2, 440, 437, 3, 2, 2, 2, 440, 438, 3, 2, 2, 2, 440, 439,
	3, 2, 2, 2, 441, 19, 3, 2, 2, 2, 442, 445, 5, 110, 56, 2, 443, 445, 5,
	112, 57, 2, 444, 442, 3, 2, 2, 2, 444, 443, 3, 2, 2, 2, 445, 21, 3, 2,
	2, 2, 446, 456, 5, 24, 13, 2, 447, 449, 5, 292, 147, 2, 448, 447, 3, 2,
	2, 2, 449, 450, 3, 2, 2, 2, 450, 448, 3, 2, 2, 2, 450, 451, 3, 2, 2, 2,
	451, 452, 3, 2, 2, 2, 452, 453, 5, 24, 13, 2, 453, 455, 3, 2, 2, 2, 454,
	448, 3, 2, 2, 2, 455, 458, 3, 2, 2, 2, 456, 454, 3, 2, 2, 2, 456, 457,
	3, 2, 2, 2, 457, 462, 3, 2, 2, 2, 458, 456, 3, 2, 2, 2, 459, 461, 5, 292,
	147, 2, 460, 459, 3, 2, 2, 2, 461, 464, 3, 2, 2, 2, 462, 460, 3, 2, 2,
	2, 462, 463, 3, 2, 2, 2, 463, 23, 3, 2, 2, 2, 464, 462, 3, 2, 2, 2, 465,
	472, 5, 76, 39, 2, 466, 472, 5, 140, 71, 2, 467, 472, 5, 142, 72, 2, 468,
	472, 5, 144, 73, 2, 469, 472, 5, 188, 95, 2, 470, 472, 5, 20, 11, 2, 471,
	465, 3, 2, 2, 2, 471, 466, 3, 2, 2, 2, 471, 467, 3, 2, 2, 2, 471, 468,
	3, 2, 2, 2, 471, 469, 3, 2, 2, 2, 471, 470, 3, 2, 2, 2, 472, 25, 3, 2,
	2, 2, 473, 474, 7, 15, 2, 2, 474, 475, 7, 221, 2, 2, 475, 477, 5, 232,
	117, 2, 476, 478, 7, 221, 2, 2, 477, 476, 3, 2, 2, 2, 477, 478, 3, 2, 2,
	2, 478, 479, 3, 2, 2, 2, 479, 481, 7, 191, 2, 2, 480, 482, 7, 221, 2, 2,
	481, 480, 3, 2, 2, 2, 481, 482, 3, 2, 2, 2, 482, 483, 3, 2, 2, 2, 483,
	494, 5, 278, 140, 2, 484, 486, 7, 221, 2, 2, 485, 484, 3, 2, 2, 2, 485,
	486, 3, 2, 2, 2, 486, 487, 3, 2, 2, 2, 487, 489, 7, 3, 2, 2, 488, 490,
	7, 221, 2, 2, 489, 488, 3, 2, 2, 2, 489, 490, 3, 2, 2, 2, 490, 491, 3,
	2, 2, 2, 491, 493, 5, 278, 140, 2, 492, 485, 3, 2, 2, 2, 493, 496, 3, 2,
	2, 2, 494, 492, 3, 2, 2, 2, 494, 495, 3, 2, 2, 2, 495, 27, 3, 2, 2, 2,
	496, 494, 3, 2, 2, 2, 497, 503, 5, 30, 16, 2, 498, 499, 5, 294, 148, 2,
	499, 500, 5, 30, 16, 2, 500, 502, 3, 2, 2, 2, 501, 498, 3, 2, 2, 2, 502,
	505, 3, 2, 2, 2, 503, 501, 3, 2, 2, 2, 503, 504, 3, 2, 2, 2, 504, 506,
	3, 2, 2, 2, 505, 503, 3, 2, 2, 2, 506, 507, 5, 294, 148, 2, 507, 29, 3,
	2, 2, 2, 508, 577, 5, 276, 139, 2, 509, 577, 5, 32, 17, 2, 510, 577, 5,
	26, 14, 2, 511, 577, 5, 34, 18, 2, 512, 577, 5, 36, 19, 2, 513, 577, 5,
	38, 20, 2, 514, 577, 5, 40, 21, 2, 515, 577, 5, 42, 22, 2, 516, 577, 5,
	46, 24, 2, 517, 577, 5, 52, 27, 2, 518, 577, 5, 50, 26, 2, 519, 577, 5,
	54, 28, 2, 520, 577, 5, 56, 29, 2, 521, 577, 5, 62, 32, 2, 522, 577, 5,
	64, 33, 2, 523, 577, 5, 68, 35, 2, 524, 577, 5, 220, 111, 2, 525, 577,
	5, 70, 36, 2, 526, 577, 5, 72, 37, 2, 527, 577, 5, 74, 38, 2, 528, 577,
	5, 78, 40, 2, 529, 577, 5, 80, 41, 2, 530, 577, 5, 82, 42, 2, 531, 577,
	5, 84, 43, 2, 532, 577, 5, 94, 48, 2, 533, 577, 5, 96, 49, 2, 534, 577,
	5, 98, 50, 2, 535, 577, 5, 100, 51, 2, 536, 577, 5, 102, 52, 2, 537, 577,
	5, 104, 53, 2, 538, 577, 5, 106, 54, 2, 539, 577, 5, 108, 55, 2, 540, 577,
	5, 20, 11, 2, 541, 577, 5, 120, 61, 2, 542, 577, 5, 122, 62, 2, 543, 577,
	5, 124, 63, 2, 544, 577, 5, 126, 64, 2, 545, 577, 5, 128, 65, 2, 546, 577,
	5, 130, 66, 2, 547, 577, 5, 132, 67, 2, 548, 577, 5, 138, 70, 2, 549, 577,
	5, 146, 74, 2, 550, 577, 5, 148, 75, 2, 551, 577, 5, 150, 76, 2, 552, 577,
	5, 152, 77, 2, 553, 577, 5, 156, 79, 2, 554, 577, 5, 158, 80, 2, 555, 577,
	5, 160, 81, 2, 556, 577, 5, 162, 82, 2, 557, 577, 5, 164, 83, 2, 558, 577,
	5, 166, 84, 2, 559, 577, 5, 168, 85, 2, 560, 577, 5, 170, 86, 2, 561, 577,
	5, 172, 87, 2, 562, 577, 5, 180, 91, 2, 563, 577, 5, 182, 92, 2, 564, 577,
	5, 184, 93, 2, 565, 577, 5, 186, 94, 2, 566, 577, 5, 190, 96, 2, 567, 577,
	5, 198, 100, 2, 568, 577, 5, 200, 101, 2, 569, 577, 5, 204, 103, 2, 570,
	577, 5, 210, 106, 2, 571, 577, 5, 212, 107, 2, 572, 577, 5, 214, 108, 2,
	573, 577, 5, 216, 109, 2, 574, 577, 5, 226, 114, 2, 575, 577, 5, 232, 117,
	2, 576, 508, 3, 2, 2, 2, 576, 509, 3, 2, 2, 2, 576, 510, 3, 2, 2, 2, 576,
	511, 3, 2, 2, 2, 576, 512, 3, 2, 2, 2, 576, 513, 3, 2, 2, 2, 576, 514,
	3, 2, 2, 2, 576, 515, 3, 2, 2, 2, 576, 516, 3, 2, 2, 2, 576, 517, 3, 2,
	2, 2, 576, 518, 3, 2, 2, 2, 576, 519, 3, 2, 2, 2, 576, 520, 3, 2, 2, 2,
	576, 521, 3, 2, 2, 2, 576, 522, 3, 2, 2, 2, 576, 523, 3, 2, 2, 2, 576,
	524, 3, 2, 2, 2, 576, 525, 3, 2, 2, 2, 576, 526, 3, 2, 2, 2, 576, 527,
	3, 2, 2, 2, 576, 528, 3, 2, 2, 2, 576, 529, 3, 2, 2, 2, 576, 530, 3, 2,
	2, 2, 576, 531, 3, 2, 2, 2, 576, 532, 3, 2, 2, 2, 576, 533, 3, 2, 2, 2,
	576, 534, 3, 2, 2, 2, 576, 535, 3, 2, 2, 2, 576, 536, 3, 2, 2, 2, 576,
	537, 3, 2, 2, 2, 576, 538, 3, 2, 2, 2, 576, 539, 3, 2, 2, 2, 576, 540,
	3, 2, 2, 2, 576, 541, 3, 2, 2, 2, 576, 542, 3, 2, 2, 2, 576, 543, 3, 2,
	2, 2, 576, 544, 3, 2, 2, 2, 576, 545, 3, 2, 2, 2, 576, 546, 3, 2, 2, 2,
	576, 547, 3, 2, 2, 2, 576, 548, 3, 2, 2, 2, 576, 549, 3, 2, 2, 2, 576,
	550, 3, 2, 2, 2, 576, 551, 3, 2, 2, 2, 576, 552, 3, 2, 2, 2, 576, 553,
	3, 2, 2, 2, 576, 554, 3, 2, 2, 2, 576, 555, 3, 2, 2, 2, 576, 556, 3, 2,
	2, 2, 576, 557, 3, 2, 2, 2, 576, 558, 3, 2, 2, 2, 576, 559, 3, 2, 2, 2,
	576, 560, 3, 2, 2, 2, 576, 561, 3, 2, 2, 2, 576, 562, 3, 2, 2, 2, 576,
	563, 3, 2, 2, 2, 576, 564, 3, 2, 2, 2, 576, 565, 3, 2, 2, 2, 576, 566,
	3, 2, 2, 2, 576, 567, 3, 2, 2, 2, 576, 568, 3, 2, 2, 2, 576, 569, 3, 2,
	2, 2, 576, 570, 3, 2, 2, 2, 576, 571, 3, 2, 2, 2, 576, 572, 3, 2, 2, 2,
	576, 573, 3, 2, 2, 2, 576, 574, 3, 2, 2, 2, 576, 575, 3, 2, 2, 2, 577,
	31, 3, 2, 2, 2, 578, 579, 7, 16, 2, 2, 579, 580, 7, 221, 2, 2, 580, 589,
	5, 202, 102, 2, 581, 583, 7, 221, 2, 2, 582, 581, 3, 2, 2, 2, 582, 583,
	3, 2, 2, 2, 583, 584, 3, 2, 2, 2, 584, 586, 7, 3, 2, 2, 585, 587, 7, 221,
	2, 2, 586, 585, 3, 2, 2, 2, 586, 587, 3, 2, 2, 2, 587, 588, 3, 2, 2, 2,
	588, 590, 5, 202, 102, 2, 589, 582, 3, 2, 2, 2, 589, 590, 3, 2, 2, 2, 590,
	33, 3, 2, 2, 2, 591, 592, 7, 20, 2, 2, 592, 35, 3, 2, 2, 2, 593, 594, 7,
	28, 2, 2, 594, 595, 7, 221, 2, 2, 595, 596, 5, 202, 102, 2, 596, 37, 3,
	2, 2, 2, 597, 598, 7, 29, 2, 2, 598, 599, 7, 221, 2, 2, 599, 600, 5, 202,
	102, 2, 600, 39, 3, 2, 2, 2, 601, 617, 7, 31, 2, 2, 602, 603, 7, 221, 2,
	2, 603, 614, 5, 218, 110, 2, 604, 606, 7, 221, 2, 2, 605, 604, 3, 2, 2,
	2, 605, 606, 3, 2, 2, 2, 606, 607, 3, 2, 2, 2, 607, 609, 7, 3, 2, 2, 608,
	610, 7, 221, 2, 2, 609, 608, 3, 2, 2, 2, 609, 610, 3, 2, 2, 2, 610, 611,
	3, 2, 2, 2, 611, 613, 5, 218, 110, 2, 612, 605, 3, 2, 2, 2, 613, 616, 3,
	2, 2, 2, 614, 612, 3, 2, 2, 2, 614, 615, 3, 2, 2, 2, 615, 618, 3, 2, 2,
	2, 616, 614, 3, 2, 2, 2, 617, 602, 3, 2, 2, 2, 617, 618, 3, 2, 2, 2, 618,
	41, 3, 2, 2, 2, 619, 620, 5, 284, 143, 2, 620, 621, 7, 221, 2, 2, 621,
	623, 3, 2, 2, 2, 622, 619, 3, 2, 2, 2, 622, 623, 3, 2, 2, 2, 623, 624,
	3, 2, 2, 2, 624, 625, 7, 33, 2, 2, 625, 626, 7, 221, 2, 2, 626, 637, 5,
	44, 23, 2, 627, 629, 7, 221, 2, 2, 628, 627, 3, 2, 2, 2, 628, 629, 3, 2,
	2, 2, 629, 630, 3, 2, 2, 2, 630, 632, 7, 3, 2, 2, 631, 633, 7, 221, 2,
	2, 632, 631, 3, 2, 2, 2, 632, 633, 3, 2, 2, 2, 633, 634, 3, 2, 2, 2, 634,
	636, 5, 44, 23, 2, 635, 628, 3, 2, 2, 2, 636, 639, 3, 2, 2, 2, 637, 635,
	3, 2, 2, 2, 637, 638, 3, 2, 2, 2, 638, 43, 3, 2, 2, 2, 639, 637, 3, 2,
	2, 2, 640, 642, 5, 260, 131, 2, 641, 643, 5, 282, 142, 2, 642, 641, 3,
	2, 2, 2, 642, 643, 3, 2, 2, 2, 643, 646, 3, 2, 2, 2, 644, 645, 7, 221,
	2, 2, 645, 647, 5, 262, 132, 2, 646, 644, 3, 2, 2, 2, 646, 647, 3, 2, 2,
	2, 647, 649, 3, 2, 2, 2, 648, 650, 7, 221, 2, 2, 649, 648, 3, 2, 2, 2,
	649, 650, 3, 2, 2, 2, 650, 651, 3, 2, 2, 2, 651, 653, 7, 191, 2, 2, 652,
	654, 7, 221, 2, 2, 653, 652, 3, 2, 2, 2, 653, 654, 3, 2, 2, 2, 654, 655,
	3, 2, 2, 2, 655, 656, 5, 202, 102, 2, 656, 45, 3, 2, 2, 2, 657, 659, 7,
	35, 2, 2, 658, 660, 7, 221, 2, 2, 659, 658, 3, 2, 2, 2, 659, 660, 3, 2,
	2, 2, 660, 661, 3, 2, 2, 2, 661, 663, 7, 191, 2, 2, 662, 664, 7, 221, 2,
	2, 663, 662, 3, 2, 2, 2, 663, 664, 3, 2, 2, 2, 664, 665, 3, 2, 2, 2, 665,
	666, 5, 202, 102, 2, 666, 47, 3, 2, 2, 2, 667, 668, 5, 284, 143, 2, 668,
	669, 7, 221, 2, 2, 669, 671, 3, 2, 2, 2, 670, 667, 3, 2, 2, 2, 670, 671,
	3, 2, 2, 2, 671, 672, 3, 2, 2, 2, 672, 673, 7, 36, 2, 2, 673, 676, 7, 221,
	2, 2, 674, 675, 7, 138, 2, 2, 675, 677, 7, 221, 2, 2, 676, 674, 3, 2, 2,
	2, 676, 677, 3, 2, 2, 2, 677, 683, 3, 2, 2, 2, 678, 680, 7, 79, 2, 2, 679,
	681, 5, 282, 142, 2, 680, 679, 3, 2, 2, 2, 680, 681, 3, 2, 2, 2, 681, 684,
	3, 2, 2, 2, 682, 684, 7, 167, 2, 2, 683, 678, 3, 2, 2, 2, 683, 682, 3,
	2, 2, 2, 684, 685, 3, 2, 2, 2, 685, 686, 7, 221, 2, 2, 686, 688, 5, 260,
	131, 2, 687, 689, 5, 282, 142, 2, 688, 687, 3, 2, 2, 2, 688, 689, 3, 2,
	2, 2, 689, 690, 3, 2, 2, 2, 690, 691, 7, 221, 2, 2, 691, 692, 7, 98, 2,
	2, 692, 693, 7, 221, 2, 2, 693, 698, 7, 207, 2, 2, 694, 695, 7, 221, 2,
	2, 695, 696, 7, 13, 2, 2, 696, 697, 7, 221, 2, 2, 697, 699, 7, 207, 2,
	2, 698, 694, 3, 2, 2, 2, 698, 699, 3, 2, 2, 2, 699, 704, 3, 2, 2, 2, 700,
	702, 7, 221, 2, 2, 701, 700, 3, 2, 2, 2, 701, 702, 3, 2, 2, 2, 702, 703,
	3, 2, 2, 2, 703, 705, 5, 250, 126, 2, 704, 701, 3, 2, 2, 2, 704, 705, 3,
	2, 2, 2, 705, 708, 3, 2, 2, 2, 706, 707, 7, 221, 2, 2, 707, 709, 5, 262,
	132, 2, 708, 706, 3, 2, 2, 2, 708, 709, 3, 2, 2, 2, 709, 49, 3, 2, 2, 2,
	710, 711, 9, 3, 2, 2, 711, 712, 7, 221, 2, 2, 712, 723, 5, 274, 138, 2,
	713, 715, 7, 221, 2, 2, 714, 713, 3, 2, 2, 2, 714, 715, 3, 2, 2, 2, 715,
	716, 3, 2, 2, 2, 716, 718, 7, 3, 2, 2, 717, 719, 7, 221, 2, 2, 718, 717,
	3, 2, 2, 2, 718, 719, 3, 2, 2, 2, 719, 720, 3, 2, 2, 2, 720, 722, 5, 274,
	138, 2, 721, 714, 3, 2, 2, 2, 722, 725, 3, 2, 2, 2, 723, 721, 3, 2, 2,
	2, 723, 724, 3, 2, 2, 2, 724, 51, 3, 2, 2, 2, 725, 723, 3, 2, 2, 2, 726,
	727, 7, 49, 2, 2, 727, 728, 7, 221, 2, 2, 728, 730, 5, 202, 102, 2, 729,
	731, 7, 221, 2, 2, 730, 729, 3, 2, 2, 2, 730, 731, 3, 2, 2, 2, 731, 732,
	3, 2, 2, 2, 732, 734, 7, 3, 2, 2, 733, 735, 7, 221, 2, 2, 734, 733, 3,
	2, 2, 2, 734, 735, 3, 2, 2, 2, 735, 736, 3, 2, 2, 2, 736, 745, 5, 202,
	102, 2, 737, 739, 7, 221, 2, 2, 738, 737, 3, 2, 2, 2, 738, 739, 3, 2, 2,
	2, 739, 740, 3, 2, 2, 2, 740, 742, 7, 3, 2, 2, 741, 743, 7, 221, 2, 2,
	742, 741, 3, 2, 2, 2, 742, 743, 3, 2, 2, 2, 743, 744, 3, 2, 2, 2, 744,
	746, 5, 202, 102, 2, 745, 738, 3, 2, 2, 2, 745, 746, 3, 2, 2, 2, 746, 53,
	3, 2, 2, 2, 747, 748, 7, 51, 2, 2, 748, 750, 5, 294, 148, 2, 749, 751,
	5, 28, 15, 2, 750, 749, 3, 2, 2, 2, 750, 751, 3, 2, 2, 2, 751, 752, 3,
	2, 2, 2, 752, 753, 7, 95, 2, 2, 753, 775, 3, 2, 2, 2, 754, 755, 7, 51,
	2, 2, 755, 756, 7, 221, 2, 2, 756, 757, 9, 4, 2, 2, 757, 758, 7, 221, 2,
	2, 758, 759, 5, 202, 102, 2, 759, 761, 5, 294, 148, 2, 760, 762, 5, 28,
	15, 2, 761, 760, 3, 2, 2, 2, 761, 762, 3, 2, 2, 2, 762, 763, 3, 2, 2, 2,
	763, 764, 7, 95, 2, 2, 764, 775, 3, 2, 2, 2, 765, 766, 7, 51, 2, 2, 766,
	767, 5, 294, 148, 2, 767, 768, 5, 28, 15, 2, 768, 769, 7, 95, 2, 2, 769,
	770, 7, 221, 2, 2, 770, 771, 9, 4, 2, 2, 771, 772, 7, 221, 2, 2, 772, 773,
	5, 202, 102, 2, 773, 775, 3, 2, 2, 2, 774, 747, 3, 2, 2, 2, 774, 754, 3,
	2, 2, 2, 774, 765, 3, 2, 2, 2, 775, 55, 3, 2, 2, 2, 776, 777, 7, 64, 2,
	2, 777, 57, 3, 2, 2, 2, 778, 779, 5, 284, 143, 2, 779, 780, 7, 221, 2,
	2, 780, 782, 3, 2, 2, 2, 781, 778, 3, 2, 2, 2, 781, 782, 3, 2, 2, 2, 782,
	783, 3, 2, 2, 2, 783, 784, 7, 65, 2, 2, 784, 785, 7, 221, 2, 2, 785, 786,
	5, 260, 131, 2, 786, 790, 5, 294, 148, 2, 787, 789, 5, 60, 31, 2, 788,
	787, 3, 2, 2, 2, 789, 792, 3, 2, 2, 2, 790, 788, 3, 2, 2, 2, 790, 791,
	3, 2, 2, 2, 791, 793, 3, 2, 2, 2, 792, 790, 3, 2, 2, 2, 793, 794, 7, 56,
	2, 2, 794, 59, 3, 2, 2, 2, 795, 804, 5, 260, 131, 2, 796, 798, 7, 221,
	2, 2, 797, 796, 3, 2, 2, 2, 797, 798, 3, 2, 2, 2, 798, 799, 3, 2, 2, 2,
	799, 801, 7, 191, 2, 2, 800, 802, 7, 221, 2, 2, 801, 800, 3, 2, 2, 2, 801,
	802, 3, 2, 2, 2, 802, 803, 3, 2, 2, 2, 803, 805, 5, 202, 102, 2, 804, 797,
	3, 2, 2, 2, 804, 805, 3, 2, 2, 2, 805, 806, 3, 2, 2, 2, 806, 807, 5, 294,
	148, 2, 807, 61, 3, 2, 2, 2, 808, 809, 7, 67, 2, 2, 809, 810, 7, 221, 2,
	2, 810, 818, 5, 202, 102, 2, 811, 813, 7, 3, 2, 2, 812, 814, 7, 221, 2,
	2, 813, 812, 3, 2, 2, 2, 813, 814, 3, 2, 2, 2, 814, 815, 3, 2, 2, 2, 815,
	817, 5, 202, 102, 2, 816, 811, 3, 2, 2, 2, 817, 820, 3, 2, 2, 2, 818, 819,
	3, 2, 2, 2, 818, 816, 3, 2, 2, 2, 819, 63, 3, 2, 2, 2, 820, 818, 3, 2,
	2, 2, 821, 822, 7, 68, 2, 2, 822, 823, 7, 221, 2, 2, 823, 824, 5, 202,
	102, 2, 824, 65, 3, 2, 2, 2, 825, 826, 5, 284, 143, 2, 826, 827, 7, 221,
	2, 2, 827, 829, 3, 2, 2, 2, 828, 825, 3, 2, 2, 2, 828, 829, 3, 2, 2, 2,
	829, 830, 3, 2, 2, 2, 830, 831, 7, 69, 2, 2, 831, 832, 7, 221, 2, 2, 832,
	834, 5, 260, 131, 2, 833, 835, 7, 221, 2, 2, 834, 833, 3, 2, 2, 2, 834,
	835, 3, 2, 2, 2, 835, 836, 3, 2, 2, 2, 836, 837, 5, 250, 126, 2, 837, 67,
	3, 2, 2, 2, 838, 839, 9, 5, 2, 2, 839, 69, 3, 2, 2, 2, 840, 841, 7, 76,
	2, 2, 841, 842, 7, 221, 2, 2, 842, 844, 5, 202, 102, 2, 843, 845, 7, 221,
	2, 2, 844, 843, 3, 2, 2, 2, 844, 845, 3, 2, 2, 2, 845, 846, 3, 2, 2, 2,
	846, 848, 7, 3, 2, 2, 847, 849, 7, 221, 2, 2, 848, 847, 3, 2, 2, 2, 848,
	849, 3, 2, 2, 2, 849, 850, 3, 2, 2, 2, 850, 851, 5, 202, 102, 2, 851, 71,
	3, 2, 2, 2, 852, 853, 7, 78, 2, 2, 853, 854, 7, 221, 2, 2, 854, 855, 7,
	53, 2, 2, 855, 856, 7, 221, 2, 2, 856, 858, 5, 260, 131, 2, 857, 859, 5,
	282, 142, 2, 858, 857, 3, 2, 2, 2, 858, 859, 3, 2, 2, 2, 859, 860, 3, 2,
	2, 2, 860, 861, 7, 221, 2, 2, 861, 862, 7, 87, 2, 2, 862, 863, 7, 221,
	2, 2, 863, 864, 5, 202, 102, 2, 864, 866, 5, 294, 148, 2, 865, 867, 5,
	28, 15, 2, 866, 865, 3, 2, 2, 2, 866, 867, 3, 2, 2, 2, 867, 868, 3, 2,
	2, 2, 868, 871, 7, 115, 2, 2, 869, 870, 7, 221, 2, 2, 870, 872, 5, 260,
	131, 2, 871, 869, 3, 2, 2, 2, 871, 872, 3, 2, 2, 2, 872, 73, 3, 2, 2, 2,
	873, 874, 7, 78, 2, 2, 874, 875, 7, 221, 2, 2, 875, 877, 5, 260, 131, 2,
	876, 878, 5, 282, 142, 2, 877, 876, 3, 2, 2, 2, 877, 878, 3, 2, 2, 2, 878,
	881, 3, 2, 2, 2, 879, 880, 7, 221, 2, 2, 880, 882, 5, 262, 132, 2, 881,
	879, 3, 2, 2, 2, 881, 882, 3, 2, 2, 2, 882, 884, 3, 2, 2, 2, 883, 885,
	7, 221, 2, 2, 884, 883, 3, 2, 2, 2, 884, 885, 3, 2, 2, 2, 885, 886, 3,
	2, 2, 2, 886, 888, 7, 191, 2, 2, 887, 889, 7, 221, 2, 2, 888, 887, 3, 2,
	2, 2, 888, 889, 3, 2, 2, 2, 889, 890, 3, 2, 2, 2, 890, 891, 5, 202, 102,
	2, 891, 892, 7, 221, 2, 2, 892, 893, 7, 172, 2, 2, 893, 894, 7, 221, 2,
	2, 894, 899, 5, 202, 102, 2, 895, 896, 7, 221, 2, 2, 896, 897, 7, 164,
	2, 2, 897, 898, 7, 221, 2, 2, 898, 900, 5, 202, 102, 2, 899, 895, 3, 2,
	2, 2, 899, 900, 3, 2, 2, 2, 900, 901, 3, 2, 2, 2, 901, 903, 5, 294, 148,
	2, 902, 904, 5, 28, 15, 2, 903, 902, 3, 2, 2, 2, 903, 904, 3, 2, 2, 2,
	904, 905, 3, 2, 2, 2, 905, 908, 7, 115, 2, 2, 906, 907, 7, 221, 2, 2, 907,
	909, 5, 260, 131, 2, 908, 906, 3, 2, 2, 2, 908, 909, 3, 2, 2, 2, 909, 75,
	3, 2, 2, 2, 910, 911, 5, 284, 143, 2, 911, 912, 7, 221, 2, 2, 912, 914,
	3, 2, 2, 2, 913, 910, 3, 2, 2, 2, 913, 914, 3, 2, 2, 2, 914, 917, 3, 2,
	2, 2, 915, 916, 7, 163, 2, 2, 916, 918, 7, 221, 2, 2, 917, 915, 3, 2, 2,
	2, 917, 918, 3, 2, 2, 2, 918, 919, 3, 2, 2, 2, 919, 921, 7, 79, 2, 2, 920,
	922, 7, 221, 2, 2, 921, 920, 3, 2, 2, 2, 921, 922, 3, 2, 2, 2, 922, 923,
	3, 2, 2, 2, 923, 925, 5, 260, 131, 2, 924, 926, 5, 282, 142, 2, 925, 924,
	3, 2, 2, 2, 925, 926, 3, 2, 2, 2, 926, 931, 3, 2, 2, 2, 927, 929, 7, 221,
	2, 2, 928, 927, 3, 2, 2, 2, 928, 929, 3, 2, 2, 2, 929, 930, 3, 2, 2, 2,
	930, 932, 5, 250, 126, 2, 931, 928, 3, 2, 2, 2, 931, 932, 3, 2, 2, 2, 932,
	937, 3, 2, 2, 2, 933, 935, 7, 221, 2, 2, 934, 933, 3, 2, 2, 2, 934, 935,
	3, 2, 2, 2, 935, 936, 3, 2, 2, 2, 936, 938, 5, 262, 132, 2, 937, 934, 3,
	2, 2, 2, 937, 938, 3, 2, 2, 2, 938, 939, 3, 2, 2, 2, 939, 941, 5, 294,
	148, 2, 940, 942, 5, 28, 15, 2, 941, 940, 3, 2, 2, 2, 941, 942, 3, 2, 2,
	2, 942, 943, 3, 2, 2, 2, 943, 944, 7, 57, 2, 2, 944, 77, 3, 2, 2, 2, 945,
	946, 7, 80, 2, 2, 946, 947, 7, 221, 2, 2, 947, 949, 5, 218, 110, 2, 948,
	950, 7, 221, 2, 2, 949, 948, 3, 2, 2, 2, 949, 950, 3, 2, 2, 2, 950, 951,
	3, 2, 2, 2, 951, 953, 7, 3, 2, 2, 952, 954, 7, 221, 2, 2, 953, 952, 3,
	2, 2, 2, 953, 954, 3, 2, 2, 2, 954, 956, 3, 2, 2, 2, 955, 957, 5, 202,
	102, 2, 956, 955, 3, 2, 2, 2, 956, 957, 3, 2, 2, 2, 957, 959, 3, 2, 2,
	2, 958, 960, 7, 221, 2, 2, 959, 958, 3, 2, 2, 2, 959, 960, 3, 2, 2, 2,
	960, 961, 3, 2, 2, 2, 961, 963, 7, 3, 2, 2, 962, 964, 7, 221, 2, 2, 963,
	962, 3, 2, 2, 2, 963, 964, 3, 2, 2, 2, 964, 965, 3, 2, 2, 2, 965, 966,
	5, 202, 102, 2, 966, 79, 3, 2, 2, 2, 967, 968, 7, 82, 2, 2, 968, 969, 7,
	221, 2, 2, 969, 970, 5, 202, 102, 2, 970, 81, 3, 2, 2, 2, 971, 972, 7,
	83, 2, 2, 972, 973, 7, 221, 2, 2, 973, 974, 5, 202, 102, 2, 974, 83, 3,
	2, 2, 2, 975, 976, 7, 84, 2, 2, 976, 977, 7, 221, 2, 2, 977, 978, 5, 88,
	45, 2, 978, 979, 7, 221, 2, 2, 979, 980, 7, 170, 2, 2, 980, 981, 7, 221,
	2, 2, 981, 986, 5, 30, 16, 2, 982, 983, 7, 221, 2, 2, 983, 984, 7, 54,
	2, 2, 984, 985, 7, 221, 2, 2, 985, 987, 5, 30, 16, 2, 986, 982, 3, 2, 2,
	2, 986, 987, 3, 2, 2, 2, 987, 1001, 3, 2, 2, 2, 988, 992, 5, 86, 44, 2,
	989, 991, 5, 90, 46, 2, 990, 989, 3, 2, 2, 2, 991, 994, 3, 2, 2, 2, 992,
	990, 3, 2, 2, 2, 992, 993, 3, 2, 2, 2, 993, 996, 3, 2, 2, 2, 994, 992,
	3, 2, 2, 2, 995, 997, 5, 92, 47, 2, 996, 995, 3, 2, 2, 2, 996, 997, 3,
	2, 2, 2, 997, 998, 3, 2, 2, 2, 998, 999, 7, 58, 2, 2, 999, 1001, 3, 2,
	2, 2, 1000, 975, 3, 2, 2, 2, 1000, 988, 3, 2, 2, 2, 1001, 85, 3, 2, 2,
	2, 1002, 1003, 7, 84, 2, 2, 1003, 1004, 7, 221, 2, 2, 1004, 1005, 5, 88,
	45, 2, 1005, 1006, 7, 221, 2, 2, 1006, 1007, 7, 170, 2, 2, 1007, 1009,
	5, 294, 148, 2, 1008, 1010, 5, 28, 15, 2, 1009, 1008, 3, 2, 2, 2, 1009,
	1010, 3, 2, 2, 2, 1010, 87, 3, 2, 2, 2, 1011, 1012, 5, 202, 102, 2, 1012,
	89, 3, 2, 2, 2, 1013, 1014, 7, 55, 2, 2, 1014, 1015, 7, 221, 2, 2, 1015,
	1016, 5, 88, 45, 2, 1016, 1017, 7, 221, 2, 2, 1017, 1018, 7, 170, 2, 2,
	1018, 1020, 5, 294, 148, 2, 1019, 1021, 5, 28, 15, 2, 1020, 1019, 3, 2,
	2, 2, 1020, 1021, 3, 2, 2, 2, 1021, 91, 3, 2, 2, 2, 1022, 1023, 7, 54,
	2, 2, 1023, 1025, 5, 294, 148, 2, 1024, 1026, 5, 28, 15, 2, 1025, 1024,
	3, 2, 2, 2, 1025, 1026, 3, 2, 2, 2, 1026, 93, 3, 2, 2, 2, 1027, 1028, 7,
	86, 2, 2, 1028, 1029, 7, 221, 2, 2, 1029, 1030, 5, 260, 131, 2, 1030, 95,
	3, 2, 2, 2, 1031, 1032, 7, 88, 2, 2, 1032, 1033, 7, 221, 2, 2, 1033, 1042,
	5, 218, 110, 2, 1034, 1036, 7, 221, 2, 2, 1035, 1034, 3, 2, 2, 2, 1035,
	1036, 3, 2, 2, 2, 1036, 1037, 3, 2, 2, 2, 1037, 1039, 7, 3, 2, 2, 1038,
	1040, 7, 221, 2, 2, 1039, 1038, 3, 2, 2, 2, 1039, 1040, 3, 2, 2, 2, 1040,
	1041, 3, 2, 2, 2, 1041, 1043, 5, 202, 102, 2, 1042, 1035, 3, 2, 2, 2, 1043,
	1044, 3, 2, 2, 2, 1044, 1042, 3, 2, 2, 2, 1044, 1045, 3, 2, 2, 2, 1045,
	97, 3, 2, 2, 2, 1046, 1047, 7, 91, 2, 2, 1047, 1048, 7, 221, 2, 2, 1048,
	1049, 5, 202, 102, 2, 1049, 99, 3, 2, 2, 2, 1050, 1051, 7, 97, 2, 2, 1051,
	1053, 7, 221, 2, 2, 1052, 1050, 3, 2, 2, 2, 1052, 1053, 3, 2, 2, 2, 1053,
	1054, 3, 2, 2, 2, 1054, 1056, 5, 232, 117, 2, 1055, 1057, 7, 221, 2, 2,
	1056, 1055, 3, 2, 2, 2, 1056, 1057, 3, 2, 2, 2, 1057, 1058, 3, 2, 2, 2,
	1058, 1060, 9, 6, 2, 2, 1059, 1061, 7, 221, 2, 2, 1060, 1059, 3, 2, 2,
	2, 1060, 1061, 3, 2, 2, 2, 1061, 1062, 3, 2, 2, 2, 1062, 1063, 5, 202,
	102, 2, 1063, 101, 3, 2, 2, 2, 1064, 1065, 7, 100, 2, 2, 1065, 1066, 7,
	221, 2, 2, 1066, 1068, 5, 218, 110, 2, 1067, 1069, 7, 221, 2, 2, 1068,
	1067, 3, 2, 2, 2, 1068, 1069, 3, 2, 2, 2, 1069, 1070, 3, 2, 2, 2, 1070,
	1072, 7, 3, 2, 2, 1071, 1073, 7, 221, 2, 2, 1072, 1071, 3, 2, 2, 2, 1072,
	1073, 3, 2, 2, 2, 1073, 1074, 3, 2, 2, 2, 1074, 1075, 5, 202, 102, 2, 1075,
	103, 3, 2, 2, 2, 1076, 1077, 7, 92, 2, 2, 1077, 1078, 7, 221, 2, 2, 1078,
	1079, 5, 202, 102, 2, 1079, 105, 3, 2, 2, 2, 1080, 1081, 7, 93, 2, 2, 1081,
	1082, 7, 221, 2, 2, 1082, 1097, 5, 202, 102, 2, 1083, 1085, 7, 221, 2,
	2, 1084, 1083, 3, 2, 2, 2, 1084, 1085, 3, 2, 2, 2, 1085, 1086, 3, 2, 2,
	2, 1086, 1088, 7, 3, 2, 2, 1087, 1089, 7, 221, 2, 2, 1088, 1087, 3, 2,
	2, 2, 1088, 1089, 3, 2, 2, 2, 1089, 1090, 3, 2, 2, 2, 1090, 1095, 5, 202,
	102, 2, 1091, 1092, 7, 221, 2, 2, 1092, 1093, 7, 172, 2, 2, 1093, 1094,
	7, 221, 2, 2, 1094, 1096, 5, 202, 102, 2, 1095, 1091, 3, 2, 2, 2, 1095,
	1096, 3, 2, 2, 2, 1096, 1098, 3, 2, 2, 2, 1097, 1084, 3, 2, 2, 2, 1097,
	1098, 3, 2, 2, 2, 1098, 107, 3, 2, 2, 2, 1099, 1100, 7, 104, 2, 2, 1100,
	1101, 7, 221, 2, 2, 1101, 1103, 5, 232, 117, 2, 1102, 1104, 7, 221, 2,
	2, 1103, 1102, 3, 2, 2, 2, 1103, 1104, 3, 2, 2, 2, 1104, 1105, 3, 2, 2,
	2, 1105, 1107, 7, 191, 2, 2, 1106, 1108, 7, 221, 2, 2, 1107, 1106, 3, 2,
	2, 2, 1107, 1108, 3, 2, 2, 2, 1108, 1109, 3, 2, 2, 2, 1109, 1110, 5, 202,
	102, 2, 1110, 109, 3, 2, 2, 2, 1111, 1113, 7, 105, 2, 2, 1112, 1114, 7,
	221, 2, 2, 1113, 1112, 3, 2, 2, 2, 1113, 1114, 3, 2, 2, 2, 1114, 1115,
	3, 2, 2, 2, 1115, 1117, 5, 260, 131, 2, 1116, 1118, 7, 221, 2, 2, 1117,
	1116, 3, 2, 2, 2, 1117, 1118, 3, 2, 2, 2, 1118, 1119, 3, 2, 2, 2, 1119,
	1121, 7, 191, 2, 2, 1120, 1122, 7, 221, 2, 2, 1121, 1120, 3, 2, 2, 2, 1121,
	1122, 3, 2, 2, 2, 1122, 1123, 3, 2, 2, 2, 1123, 1124, 5, 202, 102, 2, 1124,
	111, 3, 2, 2, 2, 1125, 1129, 5, 114, 58, 2, 1126, 1128, 5, 116, 59, 2,
	1127, 1126, 3, 2, 2, 2, 1128, 1131, 3, 2, 2, 2, 1129, 1127, 3, 2, 2, 2,
	1129, 1130, 3, 2, 2, 2, 1130, 1133, 3, 2, 2, 2, 1131, 1129, 3, 2, 2, 2,
	1132, 1134, 5, 118, 60, 2, 1133, 1132, 3, 2, 2, 2, 1133, 1134, 3, 2, 2,
	2, 1134, 1135, 3, 2, 2, 2, 1135, 1136, 7, 109, 2, 2, 1136, 113, 3, 2, 2,
	2, 1137, 1139, 7, 106, 2, 2, 1138, 1140, 7, 221, 2, 2, 1139, 1138, 3, 2,
	2, 2, 1139, 1140, 3, 2, 2, 2, 1140, 1141, 3, 2, 2, 2, 1141, 1142, 5, 88,
	45, 2, 1142, 1143, 7, 221, 2, 2, 1143, 1144, 7, 170, 2, 2, 1144, 1150,
	5, 294, 148, 2, 1145, 1149, 5, 14, 8, 2, 1146, 1149, 5, 22, 12, 2, 1147,
	1149, 5, 28, 15, 2, 1148, 1145, 3, 2, 2, 2, 1148, 1146, 3, 2, 2, 2, 1148,
	1147, 3, 2, 2, 2, 1149, 1152, 3, 2, 2, 2, 1150, 1148, 3, 2, 2, 2, 1150,
	1151, 3, 2, 2, 2, 1151, 115, 3, 2, 2, 2, 1152, 1150, 3, 2, 2, 2, 1153,
	1155, 7, 107, 2, 2, 1154, 1156, 7, 221, 2, 2, 1155, 1154, 3, 2, 2, 2, 1155,
	1156, 3, 2, 2, 2, 1156, 1157, 3, 2, 2, 2, 1157, 1158, 5, 88, 45, 2, 1158,
	1159, 7, 221, 2, 2, 1159, 1160, 7, 170, 2, 2, 1160, 1166, 5, 294, 148,
	2, 1161, 1165, 5, 14, 8, 2, 1162, 1165, 5, 22, 12, 2, 1163, 1165, 5, 28,
	15, 2, 1164, 1161, 3, 2, 2, 2, 1164, 1162, 3, 2, 2, 2, 1164, 1163, 3, 2,
	2, 2, 1165, 1168, 3, 2, 2, 2, 1166, 1164, 3, 2, 2, 2, 1166, 1167, 3, 2,
	2, 2, 1167, 117, 3, 2, 2, 2, 1168, 1166, 3, 2, 2, 2, 1169, 1170, 7, 108,
	2, 2, 1170, 1176, 5, 294, 148, 2, 1171, 1175, 5, 14, 8, 2, 1172, 1175,
	5, 22, 12, 2, 1173, 1175, 5, 28, 15, 2, 1174, 1171, 3, 2, 2, 2, 1174, 1172,
	3, 2, 2, 2, 1174, 1173, 3, 2, 2, 2, 1175, 1178, 3, 2, 2, 2, 1176, 1174,
	3, 2, 2, 2, 1176, 1177, 3, 2, 2, 2, 1177, 119, 3, 2, 2, 2, 1178, 1176,
	3, 2, 2, 2, 1179, 1181, 7, 111, 2, 2, 1180, 1182, 7, 221, 2, 2, 1181, 1180,
	3, 2, 2, 2, 1181, 1182, 3, 2, 2, 2, 1182, 1183, 3, 2, 2, 2, 1183, 1185,
	7, 195, 2, 2, 1184, 1186, 7, 221, 2, 2, 1185, 1184, 3, 2, 2, 2, 1185, 1186,
	3, 2, 2, 2, 1186, 1187, 3, 2, 2, 2, 1187, 1189, 5, 244, 123, 2, 1188, 1190,
	7, 221, 2, 2, 1189, 1188, 3, 2, 2, 2, 1189, 1190, 3, 2, 2, 2, 1190, 1191,
	3, 2, 2, 2, 1191, 1192, 7, 204, 2, 2, 1192, 121, 3, 2, 2, 2, 1193, 1194,
	7, 112, 2, 2, 1194, 1195, 7, 221, 2, 2, 1195, 1196, 5, 202, 102, 2, 1196,
	123, 3, 2, 2, 2, 1197, 1198, 7, 114, 2, 2, 1198, 1199, 7, 221, 2, 2, 1199,
	1200, 5, 202, 102, 2, 1200, 1201, 7, 221, 2, 2, 1201, 1202, 7, 18, 2, 2,
	1202, 1203, 7, 221, 2, 2, 1203, 1204, 5, 202, 102, 2, 1204, 125, 3, 2,
	2, 2, 1205, 1206, 9, 7, 2, 2, 1206, 1213, 7, 221, 2, 2, 1207, 1208, 7,
	83, 2, 2, 1208, 1209, 7, 221, 2, 2, 1209, 1214, 5, 202, 102, 2, 1210, 1211,
	7, 149, 2, 2, 1211, 1212, 7, 221, 2, 2, 1212, 1214, 7, 115, 2, 2, 1213,
	1207, 3, 2, 2, 2, 1213, 1210, 3, 2, 2, 2, 1214, 127, 3, 2, 2, 2, 1215,
	1216, 7, 120, 2, 2, 1216, 1217, 7, 221, 2, 2, 1217, 1218, 5, 202, 102,
	2, 1218, 1219, 7, 221, 2, 2, 1219, 1220, 7, 83, 2, 2, 1220, 1221, 7, 221,
	2, 2, 1221, 1232, 5, 202, 102, 2, 1222, 1224, 7, 221, 2, 2, 1223, 1222,
	3, 2, 2, 2, 1223, 1224, 3, 2, 2, 2, 1224, 1225, 3, 2, 2, 2, 1225, 1227,
	7, 3, 2, 2, 1226, 1228, 7, 221, 2, 2, 1227, 1226, 3, 2, 2, 2, 1227, 1228,
	3, 2, 2, 2, 1228, 1229, 3, 2, 2, 2, 1229, 1231, 5, 202, 102, 2, 1230, 1223,
	3, 2, 2, 2, 1231, 1234, 3, 2, 2, 2, 1232, 1230, 3, 2, 2, 2, 1232, 1233,
	3, 2, 2, 2, 1233, 129, 3, 2, 2, 2, 1234, 1232, 3, 2, 2, 2, 1235, 1236,
	7, 120, 2, 2, 1236, 1237, 7, 221, 2, 2, 1237, 1238, 5, 202, 102, 2, 1238,
	1239, 7, 221, 2, 2, 1239, 1240, 7, 82, 2, 2, 1240, 1241, 7, 221, 2, 2,
	1241, 1252, 5, 202, 102, 2, 1242, 1244, 7, 221, 2, 2, 1243, 1242, 3, 2,
	2, 2, 1243, 1244, 3, 2, 2, 2, 1244, 1245, 3, 2, 2, 2, 1245, 1247, 7, 3,
	2, 2, 1246, 1248, 7, 221, 2, 2, 1247, 1246, 3, 2, 2, 2, 1247, 1248, 3,
	2, 2, 2, 1248, 1249, 3, 2, 2, 2, 1249, 1251, 5, 202, 102, 2, 1250, 1243,
	3, 2, 2, 2, 1251, 1254, 3, 2, 2, 2, 1252, 1250, 3, 2, 2, 2, 1252, 1253,
	3, 2, 2, 2, 1253, 131, 3, 2, 2, 2, 1254, 1252, 3, 2, 2, 2, 1255, 1256,
	7, 123, 2, 2, 1256, 1257, 7, 221, 2, 2, 1257, 1258, 5, 202, 102, 2, 1258,
	1259, 7, 221, 2, 2, 1259, 1260, 7, 78, 2, 2, 1260, 1261, 7, 221, 2, 2,
	1261, 1266, 9, 8, 2, 2, 1262, 1263, 7, 221, 2, 2, 1263, 1264, 7, 11, 2,
	2, 1264, 1265, 7, 221, 2, 2, 1265, 1267, 9, 9, 2, 2, 1266, 1262, 3, 2,
	2, 2, 1266, 1267, 3, 2, 2, 2, 1267, 1270, 3, 2, 2, 2, 1268, 1269, 7, 221,
	2, 2, 1269, 1271, 9, 10, 2, 2, 1270, 1268, 3, 2, 2, 2, 1270, 1271, 3, 2,
	2, 2, 1271, 1272, 3, 2, 2, 2, 1272, 1273, 7, 221, 2, 2, 1273, 1274, 7,
	18, 2, 2, 1274, 1275, 7, 221, 2, 2, 1275, 1286, 5, 218, 110, 2, 1276, 1277,
	7, 221, 2, 2, 1277, 1279, 7, 96, 2, 2, 1278, 1280, 7, 221, 2, 2, 1279,
	1278, 3, 2, 2, 2, 1279, 1280, 3, 2, 2, 2, 1280, 1281, 3, 2, 2, 2, 1281,
	1283, 7, 191, 2, 2, 1282, 1284, 7, 221, 2, 2, 1283, 1282, 3, 2, 2, 2, 1283,
	1284, 3, 2, 2, 2, 1284, 1285, 3, 2, 2, 2, 1285, 1287, 5, 202, 102, 2, 1286,
	1276, 3, 2, 2, 2, 1286, 1287, 3, 2, 2, 2, 1287, 133, 3, 2, 2, 2, 1288,
	1301, 5, 136, 69, 2, 1289, 1291, 7, 221, 2, 2, 1290, 1289, 3, 2, 2, 2,
	1290, 1291, 3, 2, 2, 2, 1291, 1292, 3, 2, 2, 2, 1292, 1294, 9, 11, 2, 2,
	1293, 1295, 7, 221, 2, 2, 1294, 1293, 3, 2, 2, 2, 1294, 1295, 3, 2, 2,
	2, 1295, 1297, 3, 2, 2, 2, 1296, 1298, 5, 136, 69, 2, 1297, 1296, 3, 2,
	2, 2, 1297, 1298, 3, 2, 2, 2, 1298, 1300, 3, 2, 2, 2, 1299, 1290, 3, 2,
	2, 2, 1300, 1303, 3, 2, 2, 2, 1301, 1299, 3, 2, 2, 2, 1301, 1302, 3, 2,
	2, 2, 1302, 1322, 3, 2, 2, 2, 1303, 1301, 3, 2, 2, 2, 1304, 1306, 5, 136,
	69, 2, 1305, 1304, 3, 2, 2, 2, 1305, 1306, 3, 2, 2, 2, 1306, 1317, 3, 2,
	2, 2, 1307, 1309, 7, 221, 2, 2, 1308, 1307, 3, 2, 2, 2, 1308, 1309, 3,
	2, 2, 2, 1309, 1310, 3, 2, 2, 2, 1310, 1312, 9, 11, 2, 2, 1311, 1313, 7,
	221, 2, 2, 1312, 1311, 3, 2, 2, 2, 1312, 1313, 3, 2, 2, 2, 1313, 1315,
	3, 2, 2, 2, 1314, 1316, 5, 136, 69, 2, 1315, 1314, 3, 2, 2, 2, 1315, 1316,
	3, 2, 2, 2, 1316, 1318, 3, 2, 2, 2, 1317, 1308, 3, 2, 2, 2, 1318, 1319,
	3, 2, 2, 2, 1319, 1317, 3, 2, 2, 2, 1319, 1320, 3, 2, 2, 2, 1320, 1322,
	3, 2, 2, 2, 1321, 1288, 3, 2, 2, 2, 1321, 1305, 3, 2, 2, 2, 1322, 135,
	3, 2, 2, 2, 1323, 1341, 5, 202, 102, 2, 1324, 1338, 9, 12, 2, 2, 1325,
	1327, 7, 221, 2, 2, 1326, 1325, 3, 2, 2, 2, 1326, 1327, 3, 2, 2, 2, 1327,
	1328, 3, 2, 2, 2, 1328, 1330, 7, 195, 2, 2, 1329, 1331, 7, 221, 2, 2, 1330,
	1329, 3, 2, 2, 2, 1330, 1331, 3, 2, 2, 2, 1331, 1332, 3, 2, 2, 2, 1332,
	1334, 5, 244, 123, 2, 1333, 1335, 7, 221, 2, 2, 1334, 1333, 3, 2, 2, 2,
	1334, 1335, 3, 2, 2, 2, 1335, 1336, 3, 2, 2, 2, 1336, 1337, 7, 204, 2,
	2, 1337, 1339, 3, 2, 2, 2, 1338, 1326, 3, 2, 2, 2, 1338, 1339, 3, 2, 2,
	2, 1339, 1341, 3, 2, 2, 2, 1340, 1323, 3, 2, 2, 2, 1340, 1324, 3, 2, 2,
	2, 1341, 137, 3, 2, 2, 2, 1342, 1343, 7, 133, 2, 2, 1343, 1344, 7, 221,
	2, 2, 1344, 1346, 5, 218, 110, 2, 1345, 1347, 7, 221, 2, 2, 1346, 1345,
	3, 2, 2, 2, 1346, 1347, 3, 2, 2, 2, 1347, 1348, 3, 2, 2, 2, 1348, 1353,
	7, 3, 2, 2, 1349, 1351, 7, 221, 2, 2, 1350, 1349, 3, 2, 2, 2, 1350, 1351,
	3, 2, 2, 2, 1351, 1352, 3, 2, 2, 2, 1352, 1354, 5, 134, 68, 2, 1353, 1350,
	3, 2, 2, 2, 1353, 1354, 3, 2, 2, 2, 1354, 139, 3, 2, 2, 2, 1355, 1356,
	5, 284, 143, 2, 1356, 1357, 7, 221, 2, 2, 1357, 1359, 3, 2, 2, 2, 1358,
	1355, 3, 2, 2, 2, 1358, 1359, 3, 2, 2, 2, 1359, 1362, 3, 2, 2, 2, 1360,
	1361, 7, 163, 2, 2, 1361, 1363, 7, 221, 2, 2, 1362, 1360, 3, 2, 2, 2, 1362,
	1363, 3, 2, 2, 2, 1363, 1364, 3, 2, 2, 2, 1364, 1365, 7, 135, 2, 2, 1365,
	1366, 7, 221, 2, 2, 1366, 1368, 5, 260, 131, 2, 1367, 1369, 5, 282, 142,
	2, 1368, 1367, 3, 2, 2, 2, 1368, 1369, 3, 2, 2, 2, 1369, 1374, 3, 2, 2,
	2, 1370, 1372, 7, 221, 2, 2, 1371, 1370, 3, 2, 2, 2, 1371, 1372, 3, 2,
	2, 2, 1372, 1373, 3, 2, 2, 2, 1373, 1375, 5, 250, 126, 2, 1374, 1371, 3,
	2, 2, 2, 1374, 1375, 3, 2, 2, 2, 1375, 1378, 3, 2, 2, 2, 1376, 1377, 7,
	221, 2, 2, 1377, 1379, 5, 262, 132, 2, 1378, 1376, 3, 2, 2, 2, 1378, 1379,
	3, 2, 2, 2, 1379, 1380, 3, 2, 2, 2, 1380, 1382, 5, 294, 148, 2, 1381, 1383,
	5, 28, 15, 2, 1382, 1381, 3, 2, 2, 2, 1382, 1383, 3, 2, 2, 2, 1383, 1384,
	3, 2, 2, 2, 1384, 1385, 7, 59, 2, 2, 1385, 141, 3, 2, 2, 2, 1386, 1387,
	5, 284, 143, 2, 1387, 1388, 7, 221, 2, 2, 1388, 1390, 3, 2, 2, 2, 1389,
	1386, 3, 2, 2, 2, 1389, 1390, 3, 2, 2, 2, 1390, 1393, 3, 2, 2, 2, 1391,
	1392, 7, 163, 2, 2, 1392, 1394, 7, 221, 2, 2, 1393, 1391, 3, 2, 2, 2, 1393,
	1394, 3, 2, 2, 2, 1394, 1395, 3, 2, 2, 2, 1395, 1396, 7, 137, 2, 2, 1396,
	1397, 7, 221, 2, 2, 1397, 1402, 5, 260, 131, 2, 1398, 1400, 7, 221, 2,
	2, 1399, 1398, 3, 2, 2, 2, 1399, 1400, 3, 2, 2, 2, 1400, 1401, 3, 2, 2,
	2, 1401, 1403, 5, 250, 126, 2, 1402, 1399, 3, 2, 2, 2, 1402, 1403, 3, 2,
	2, 2, 1403, 1404, 3, 2, 2, 2, 1404, 1406, 5, 294, 148, 2, 1405, 1407, 5,
	28, 15, 2, 1406, 1405, 3, 2, 2, 2, 1406, 1407, 3, 2, 2, 2, 1407, 1408,
	3, 2, 2, 2, 1408, 1409, 7, 59, 2, 2, 1409, 143, 3, 2, 2, 2, 1410, 1411,
	5, 284, 143, 2, 1411, 1412, 7, 221, 2, 2, 1412, 1414, 3, 2, 2, 2, 1413,
	1410, 3, 2, 2, 2, 1413, 1414, 3, 2, 2, 2, 1414, 1417, 3, 2, 2, 2, 1415,
	1416, 7, 163, 2, 2, 1416, 1418, 7, 221, 2, 2, 1417, 1415, 3, 2, 2, 2, 1417,
	1418, 3, 2, 2, 2, 1418, 1419, 3, 2, 2, 2, 1419, 1420, 7, 136, 2, 2, 1420,
	1421, 7, 221, 2, 2, 1421, 1426, 5, 260, 131, 2, 1422, 1424, 7, 221, 2,
	2, 1423, 1422, 3, 2, 2, 2, 1423, 1424, 3, 2, 2, 2, 1424, 1425, 3, 2, 2,
	2, 1425, 1427, 5, 250, 126, 2, 1426, 1423, 3, 2, 2, 2, 1426, 1427, 3, 2,
	2, 2, 1427, 1428, 3, 2, 2, 2, 1428, 1430, 5, 294, 148, 2, 1429, 1431, 5,
	28, 15, 2, 1430, 1429, 3, 2, 2, 2, 1430, 1431, 3, 2, 2, 2, 1431, 1432,
	3, 2, 2, 2, 1432, 1433, 7, 59, 2, 2, 1433, 145, 3, 2, 2, 2, 1434, 1435,
	7, 140, 2, 2, 1435, 1436, 7, 221, 2, 2, 1436, 1438, 5, 218, 110, 2, 1437,
	1439, 7, 221, 2, 2, 1438, 1437, 3, 2, 2, 2, 1438, 1439, 3, 2, 2, 2, 1439,
	1440, 3, 2, 2, 2, 1440, 1442, 7, 3, 2, 2, 1441, 1443, 7, 221, 2, 2, 1442,
	1441, 3, 2, 2, 2, 1442, 1443, 3, 2, 2, 2, 1443, 1445, 3, 2, 2, 2, 1444,
	1446, 5, 202, 102, 2, 1445, 1444, 3, 2, 2, 2, 1445, 1446, 3, 2, 2, 2, 1446,
	1448, 3, 2, 2, 2, 1447, 1449, 7, 221, 2, 2, 1448, 1447, 3, 2, 2, 2, 1448,
	1449, 3, 2, 2, 2, 1449, 1450, 3, 2, 2, 2, 1450, 1452, 7, 3, 2, 2, 1451,
	1453, 7, 221, 2, 2, 1452, 1451, 3, 2, 2, 2, 1452, 1453, 3, 2, 2, 2, 1453,
	1454, 3, 2, 2, 2, 1454, 1455, 5, 202, 102, 2, 1455, 147, 3, 2, 2, 2, 1456,
	1457, 7, 143, 2, 2, 1457, 1458, 7, 221, 2, 2, 1458, 1473, 5, 260, 131,
	2, 1459, 1461, 7, 221, 2, 2, 1460, 1459, 3, 2, 2, 2, 1460, 1461, 3, 2,
	2, 2, 1461, 1462, 3, 2, 2, 2, 1462, 1464, 7, 195, 2, 2, 1463, 1465, 7,
	221, 2, 2, 1464, 1463, 3, 2, 2, 2, 1464, 1465, 3, 2, 2, 2, 1465, 1470,
	3, 2, 2, 2, 1466, 1468, 5, 244, 123, 2, 1467, 1469, 7, 221, 2, 2, 1468,
	1467, 3, 2, 2, 2, 1468, 1469, 3, 2, 2, 2, 1469, 1471, 3, 2, 2, 2, 1470,
	1466, 3, 2, 2, 2, 1470, 1471, 3, 2, 2, 2, 1471, 1472, 3, 2, 2, 2, 1472,
	1474, 7, 204, 2, 2, 1473, 1460, 3, 2, 2, 2, 1473, 1474, 3, 2, 2, 2, 1474,
	149, 3, 2, 2, 2, 1475, 1478, 7, 142, 2, 2, 1476, 1477, 7, 221, 2, 2, 1477,
	1479, 5, 202, 102, 2, 1478, 1476, 3, 2, 2, 2, 1478, 1479, 3, 2, 2, 2, 1479,
	151, 3, 2, 2, 2, 1480, 1481, 7, 146, 2, 2, 1481, 1484, 7, 221, 2, 2, 1482,
	1483, 7, 132, 2, 2, 1483, 1485, 7, 221, 2, 2, 1484, 1482, 3, 2, 2, 2, 1484,
	1485, 3, 2, 2, 2, 1485, 1486, 3, 2, 2, 2, 1486, 1497, 5, 154, 78, 2, 1487,
	1489, 7, 221, 2, 2, 1488, 1487, 3, 2, 2, 2, 1488, 1489, 3, 2, 2, 2, 1489,
	1490, 3, 2, 2, 2, 1490, 1492, 7, 3, 2, 2, 1491, 1493, 7, 221, 2, 2, 1492,
	1491, 3, 2, 2, 2, 1492, 1493, 3, 2, 2, 2, 1493, 1494, 3, 2, 2, 2, 1494,
	1496, 5, 154, 78, 2, 1495, 1488, 3, 2, 2, 2, 1496, 1499, 3, 2, 2, 2, 1497,
	1495, 3, 2, 2, 2, 1497, 1498, 3, 2, 2, 2, 1498, 153, 3, 2, 2, 2, 1499,
	1497, 3, 2, 2, 2, 1500, 1502, 5, 232, 117, 2, 1501, 1503, 7, 221, 2, 2,
	1502, 1501, 3, 2, 2, 2, 1502, 1503, 3, 2, 2, 2, 1503, 1504, 3, 2, 2, 2,
	1504, 1506, 7, 195, 2, 2, 1505, 1507, 7, 221, 2, 2, 1506, 1505, 3, 2, 2,
	2, 1506, 1507, 3, 2, 2, 2, 1507, 1508, 3, 2, 2, 2, 1508, 1510, 5, 256,
	129, 2, 1509, 1511, 7, 221, 2, 2, 1510, 1509, 3, 2, 2, 2, 1510, 1511, 3,
	2, 2, 2, 1511, 1512, 3, 2, 2, 2, 1512, 1515, 7, 204, 2, 2, 1513, 1514,
	7, 221, 2, 2, 1514, 1516, 5, 262, 132, 2, 1515, 1513, 3, 2, 2, 2, 1515,
	1516, 3, 2, 2, 2, 1516, 155, 3, 2, 2, 2, 1517, 1518, 7, 148, 2, 2, 1518,
	157, 3, 2, 2, 2, 1519, 1525, 7, 149, 2, 2, 1520, 1523, 7, 221, 2, 2, 1521,
	1524, 7, 115, 2, 2, 1522, 1524, 5, 260, 131, 2, 1523, 1521, 3, 2, 2, 2,
	1523, 1522, 3, 2, 2, 2, 1524, 1526, 3, 2, 2, 2, 1525, 1520, 3, 2, 2, 2,
	1525, 1526, 3, 2, 2, 2, 1526, 159, 3, 2, 2, 2, 1527, 1528, 7, 150, 2, 2,
	1528, 161, 3, 2, 2, 2, 1529, 1530, 7, 151, 2, 2, 1530, 1531, 7, 221, 2,
	2, 1531, 1532, 5, 202, 102, 2, 1532, 163, 3, 2, 2, 2, 1533, 1534, 7, 152,
	2, 2, 1534, 1535, 7, 221, 2, 2, 1535, 1537, 5, 232, 117, 2, 1536, 1538,
	7, 221, 2, 2, 1537, 1536, 3, 2, 2, 2, 1537, 1538, 3, 2, 2, 2, 1538, 1539,
	3, 2, 2, 2, 1539, 1541, 7, 191, 2, 2, 1540, 1542, 7, 221, 2, 2, 1541, 1540,
	3, 2, 2, 2, 1541, 1542, 3, 2, 2, 2, 1542, 1543, 3, 2, 2, 2, 1543, 1544,
	5, 202, 102, 2, 1544, 165, 3, 2, 2, 2, 1545, 1546, 7, 153, 2, 2, 1546,
	1547, 7, 221, 2, 2, 1547, 1549, 5, 202, 102, 2, 1548, 1550, 7, 221, 2,
	2, 1549, 1548, 3, 2, 2, 2, 1549, 1550, 3, 2, 2, 2, 1550, 1551, 3, 2, 2,
	2, 1551, 1553, 7, 3, 2, 2, 1552, 1554, 7, 221, 2, 2, 1553, 1552, 3, 2,
	2, 2, 1553, 1554, 3, 2, 2, 2, 1554, 1555, 3, 2, 2, 2, 1555, 1556, 5, 202,
	102, 2, 1556, 167, 3, 2, 2, 2, 1557, 1558, 7, 154, 2, 2, 1558, 1559, 7,
	221, 2, 2, 1559, 1561, 5, 202, 102, 2, 1560, 1562, 7, 221, 2, 2, 1561,
	1560, 3, 2, 2, 2, 1561, 1562, 3, 2, 2, 2, 1562, 1563, 3, 2, 2, 2, 1563,
	1565, 7, 3, 2, 2, 1564, 1566, 7, 221, 2, 2, 1565, 1564, 3, 2, 2, 2, 1565,
	1566, 3, 2, 2, 2, 1566, 1567, 3, 2, 2, 2, 1567, 1569, 5, 202, 102, 2, 1568,
	1570, 7, 221, 2, 2, 1569, 1568, 3, 2, 2, 2, 1569, 1570, 3, 2, 2, 2, 1570,
	1571, 3, 2, 2, 2, 1571, 1573, 7, 3, 2, 2, 1572, 1574, 7, 221, 2, 2, 1573,
	1572, 3, 2, 2, 2, 1573, 1574, 3, 2, 2, 2, 1574, 1575, 3, 2, 2, 2, 1575,
	1577, 5, 202, 102, 2, 1576, 1578, 7, 221, 2, 2, 1577, 1576, 3, 2, 2, 2,
	1577, 1578, 3, 2, 2, 2, 1578, 1579, 3, 2, 2, 2, 1579, 1581, 7, 3, 2, 2,
	1580, 1582, 7, 221, 2, 2, 1581, 1580, 3, 2, 2, 2, 1581, 1582, 3, 2, 2,
	2, 1582, 1583, 3, 2, 2, 2, 1583, 1584, 5, 202, 102, 2, 1584, 169, 3, 2,
	2, 2, 1585, 1586, 7, 155, 2, 2, 1586, 1587, 7, 221, 2, 2, 1587, 1589, 5,
	218, 110, 2, 1588, 1590, 7, 221, 2, 2, 1589, 1588, 3, 2, 2, 2, 1589, 1590,
	3, 2, 2, 2, 1590, 1591, 3, 2, 2, 2, 1591, 1593, 7, 3, 2, 2, 1592, 1594,
	7, 221, 2, 2, 1593, 1592, 3, 2, 2, 2, 1593, 1594, 3, 2, 2, 2, 1594, 1595,
	3, 2, 2, 2, 1595, 1596, 5, 202, 102, 2, 1596, 171, 3, 2, 2, 2, 1597, 1598,
	7, 156, 2, 2, 1598, 1599, 7, 221, 2, 2, 1599, 1600, 7, 27, 2, 2, 1600,
	1601, 7, 221, 2, 2, 1601, 1602, 5, 202, 102, 2, 1602, 1606, 5, 294, 148,
	2, 1603, 1605, 5, 176, 89, 2, 1604, 1603, 3, 2, 2, 2, 1605, 1608, 3, 2,
	2, 2, 1606, 1604, 3, 2, 2, 2, 1606, 1607, 3, 2, 2, 2, 1607, 1609, 3, 2,
	2, 2, 1608, 1606, 3, 2, 2, 2, 1609, 1610, 7, 60, 2, 2, 1610, 173, 3, 2,
	2, 2, 1611, 1613, 7, 89, 2, 2, 1612, 1614, 7, 221, 2, 2, 1613, 1612, 3,
	2, 2, 2, 1613, 1614, 3, 2, 2, 2, 1614, 1615, 3, 2, 2, 2, 1615, 1617, 5,
	268, 135, 2, 1616, 1618, 7, 221, 2, 2, 1617, 1616, 3, 2, 2, 2, 1617, 1618,
	3, 2, 2, 2, 1618, 1619, 3, 2, 2, 2, 1619, 1620, 5, 202, 102, 2, 1620, 1629,
	3, 2, 2, 2, 1621, 1622, 5, 202, 102, 2, 1622, 1623, 7, 221, 2, 2, 1623,
	1624, 7, 172, 2, 2, 1624, 1625, 7, 221, 2, 2, 1625, 1626, 5, 202, 102,
	2, 1626, 1629, 3, 2, 2, 2, 1627, 1629, 5, 202, 102, 2, 1628, 1611, 3, 2,
	2, 2, 1628, 1621, 3, 2, 2, 2, 1628, 1627, 3, 2, 2, 2, 1629, 175, 3, 2,
	2, 2, 1630, 1631, 7, 27, 2, 2, 1631, 1632, 7, 221, 2, 2, 1632, 1633, 5,
	178, 90, 2, 1633, 1635, 5, 294, 148, 2, 1634, 1636, 5, 28, 15, 2, 1635,
	1634, 3, 2, 2, 2, 1635, 1636, 3, 2, 2, 2, 1636, 177, 3, 2, 2, 2, 1637,
	1653, 7, 54, 2, 2, 1638, 1649, 5, 174, 88, 2, 1639, 1641, 7, 221, 2, 2,
	1640, 1639, 3, 2, 2, 2, 1640, 1641, 3, 2, 2, 2, 1641, 1642, 3, 2, 2, 2,
	1642, 1644, 7, 3, 2, 2, 1643, 1645, 7, 221, 2, 2, 1644, 1643, 3, 2, 2,
	2, 1644, 1645, 3, 2, 2, 2, 1645, 1646, 3, 2, 2, 2, 1646, 1648, 5, 174,
	88, 2, 1647, 1640, 3, 2, 2, 2, 1648, 1651, 3, 2, 2, 2, 1649, 1647, 3, 2,
	2, 2, 1649, 1650, 3, 2, 2, 2, 1650, 1653, 3, 2, 2, 2, 1651, 1649, 3, 2,
	2, 2, 1652, 1637, 3, 2, 2, 2, 1652, 1638, 3, 2, 2, 2, 1653, 179, 3, 2,
	2, 2, 1654, 1655, 7, 157, 2, 2, 1655, 1656, 7, 221, 2, 2, 1656, 1665, 5,
	202, 102, 2, 1657, 1659, 7, 221, 2, 2, 1658, 1657, 3, 2, 2, 2, 1658, 1659,
	3, 2, 2, 2, 1659, 1660, 3, 2, 2, 2, 1660, 1662, 7, 3, 2, 2, 1661, 1663,
	7, 221, 2, 2, 1662, 1661, 3, 2, 2, 2, 1662, 1663, 3, 2, 2, 2, 1663, 1664,
	3, 2, 2, 2, 1664, 1666, 5, 202, 102, 2, 1665, 1658, 3, 2, 2, 2, 1665, 1666,
	3, 2, 2, 2, 1666, 181, 3, 2, 2, 2, 1667, 1668, 7, 159, 2, 2, 1668, 1669,
	7, 221, 2, 2, 1669, 1671, 5, 202, 102, 2, 1670, 1672, 7, 221, 2, 2, 1671,
	1670, 3, 2, 2, 2, 1671, 1672, 3, 2, 2, 2, 1672, 1673, 3, 2, 2, 2, 1673,
	1675, 7, 3, 2, 2, 1674, 1676, 7, 221, 2, 2, 1675, 1674, 3, 2, 2, 2, 1675,
	1676, 3, 2, 2, 2, 1676, 1677, 3, 2, 2, 2, 1677, 1678, 5, 202, 102, 2, 1678,
	183, 3, 2, 2, 2, 1679, 1680, 7, 158, 2, 2, 1680, 1681, 7, 221, 2, 2, 1681,
	1683, 5, 232, 117, 2, 1682, 1684, 7, 221, 2, 2, 1683, 1682, 3, 2, 2, 2,
	1683, 1684, 3, 2, 2, 2, 1684, 1685, 3, 2, 2, 2, 1685, 1687, 7, 191, 2,
	2, 1686, 1688, 7, 221, 2, 2, 1687, 1686, 3, 2, 2, 2, 1687, 1688, 3, 2,
	2, 2, 1688, 1689, 3, 2, 2, 2, 1689, 1690, 5, 202, 102, 2, 1690, 185, 3,
	2, 2, 2, 1691, 1692, 7, 165, 2, 2, 1692, 187, 3, 2, 2, 2, 1693, 1694, 5,
	284, 143, 2, 1694, 1695, 7, 221, 2, 2, 1695, 1697, 3, 2, 2, 2, 1696, 1693,
	3, 2, 2, 2, 1696, 1697, 3, 2, 2, 2, 1697, 1700, 3, 2, 2, 2, 1698, 1699,
	7, 163, 2, 2, 1699, 1701, 7, 221, 2, 2, 1700, 1698, 3, 2, 2, 2, 1700, 1701,
	3, 2, 2, 2, 1701, 1702, 3, 2, 2, 2, 1702, 1704, 7, 167, 2, 2, 1703, 1705,
	7, 221, 2, 2, 1704, 1703, 3, 2, 2, 2, 1704, 1705, 3, 2, 2, 2, 1705, 1706,
	3, 2, 2, 2, 1706, 1711, 5, 260, 131, 2, 1707, 1709, 7, 221, 2, 2, 1708,
	1707, 3, 2, 2, 2, 1708, 1709, 3, 2, 2, 2, 1709, 1710, 3, 2, 2, 2, 1710,
	1712, 5, 250, 126, 2, 1711, 1708, 3, 2, 2, 2, 1711, 1712, 3, 2, 2, 2, 1712,
	1713, 3, 2, 2, 2, 1713, 1715, 5, 294, 148, 2, 1714, 1716, 5, 28, 15, 2,
	1715, 1714, 3, 2, 2, 2, 1715, 1716, 3, 2, 2, 2, 1716, 1717, 3, 2, 2, 2,
	1717, 1718, 7, 61, 2, 2, 1718, 189, 3, 2, 2, 2, 1719, 1721, 7, 171, 2,
	2, 1720, 1722, 7, 221, 2, 2, 1721, 1720, 3, 2, 2, 2, 1721, 1722, 3, 2,
	2, 2, 1722, 1723, 3, 2, 2, 2, 1723, 1725, 7, 191, 2, 2, 1724, 1726, 7,
	221, 2, 2, 1725, 1724, 3, 2, 2, 2, 1725, 1726, 3, 2, 2, 2, 1726, 1727,
	3, 2, 2, 2, 1727, 1728, 5, 202, 102, 2, 1728, 191, 3, 2, 2, 2, 1729, 1730,
	5, 284, 143, 2, 1730, 1731, 7, 221, 2, 2, 1731, 1733, 3, 2, 2, 2, 1732,
	1729, 3, 2, 2, 2, 1732, 1733, 3, 2, 2, 2, 1733, 1734, 3, 2, 2, 2, 1734,
	1735, 7, 174, 2, 2, 1735, 1736, 7, 221, 2, 2, 1736, 1737, 5, 260, 131,
	2, 1737, 1741, 5, 294, 148, 2, 1738, 1740, 5, 194, 98, 2, 1739, 1738, 3,
	2, 2, 2, 1740, 1743, 3, 2, 2, 2, 1741, 1739, 3, 2, 2, 2, 1741, 1742, 3,
	2, 2, 2, 1742, 1744, 3, 2, 2, 2, 1743, 1741, 3, 2, 2, 2, 1744, 1745, 7,
	62, 2, 2, 1745, 193, 3, 2, 2, 2, 1746, 1761, 5, 260, 131, 2, 1747, 1749,
	7, 221, 2, 2, 1748, 1747, 3, 2, 2, 2, 1748, 1749, 3, 2, 2, 2, 1749, 1750,
	3, 2, 2, 2, 1750, 1755, 7, 195, 2, 2, 1751, 1753, 7, 221, 2, 2, 1752, 1751,
	3, 2, 2, 2, 1752, 1753, 3, 2, 2, 2, 1753, 1754, 3, 2, 2, 2, 1754, 1756,
	5, 256, 129, 2, 1755, 1752, 3, 2, 2, 2, 1755, 1756, 3, 2, 2, 2, 1756, 1758,
	3, 2, 2, 2, 1757, 1759, 7, 221, 2, 2, 1758, 1757, 3, 2, 2, 2, 1758, 1759,
	3, 2, 2, 2, 1759, 1760, 3, 2, 2, 2, 1760, 1762, 7, 204, 2, 2, 1761, 1748,
	3, 2, 2, 2, 1761, 1762, 3, 2, 2, 2, 1762, 1765, 3, 2, 2, 2, 1763, 1764,
	7, 221, 2, 2, 1764, 1766, 5, 262, 132, 2, 1765, 1763, 3, 2, 2, 2, 1765,
	1766, 3, 2, 2, 2, 1766, 1767, 3, 2, 2, 2, 1767, 1768, 5, 294, 148, 2, 1768,
	195, 3, 2, 2, 2, 1769, 1770, 7, 175, 2, 2, 1770, 1771, 7, 221, 2, 2, 1771,
	1776, 5, 202, 102, 2, 1772, 1773, 7, 221, 2, 2, 1773, 1774, 7, 89, 2, 2,
	1774, 1775, 7, 221, 2, 2, 1775, 1777, 5, 280, 141, 2, 1776, 1772, 3, 2,
	2, 2, 1776, 1777, 3, 2, 2, 2, 1777, 197, 3, 2, 2, 2, 1778, 1779, 7, 176,
	2, 2, 1779, 1780, 7, 221, 2, 2, 1780, 1781, 5, 202, 102, 2, 1781, 199,
	3, 2, 2, 2, 1782, 1783, 7, 177, 2, 2, 1783, 1784, 7, 221, 2, 2, 1784, 1799,
	5, 218, 110, 2, 1785, 1787, 7, 221, 2, 2, 1786, 1785, 3, 2, 2, 2, 1786,
	1787, 3, 2, 2, 2, 1787, 1788, 3, 2, 2, 2, 1788, 1790, 7, 3, 2, 2, 1789,
	1791, 7, 221, 2, 2, 1790, 1789, 3, 2, 2, 2, 1790, 1791, 3, 2, 2, 2, 1791,
	1792, 3, 2, 2, 2, 1792, 1797, 5, 202, 102, 2, 1793, 1794, 7, 221, 2, 2,
	1794, 1795, 7, 172, 2, 2, 1795, 1796, 7, 221, 2, 2, 1796, 1798, 5, 202,
	102, 2, 1797, 1793, 3, 2, 2, 2, 1797, 1798, 3, 2, 2, 2, 1798, 1800, 3,
	2, 2, 2, 1799, 1786, 3, 2, 2, 2, 1799, 1800, 3, 2, 2, 2, 1800, 201, 3,
	2, 2, 2, 1801, 1802, 8, 102, 1, 2, 1802, 1862, 5, 278, 140, 2, 1803, 1862,
	5, 232, 117, 2, 1804, 1806, 7, 195, 2, 2, 1805, 1807, 7, 221, 2, 2, 1806,
	1805, 3, 2, 2, 2, 1806, 1807, 3, 2, 2, 2, 1807, 1808, 3, 2, 2, 2, 1808,
	1819, 5, 202, 102, 2, 1809, 1811, 7, 221, 2, 2, 1810, 1809, 3, 2, 2, 2,
	1810, 1811, 3, 2, 2, 2, 1811, 1812, 3, 2, 2, 2, 1812, 1814, 7, 3, 2, 2,
	1813, 1815, 7, 221, 2, 2, 1814, 1813, 3, 2, 2, 2, 1814, 1815, 3, 2, 2,
	2, 1815, 1816, 3, 2, 2, 2, 1816, 1818, 5, 202, 102, 2, 1817, 1810, 3, 2,
	2, 2, 1818, 1821, 3, 2, 2, 2, 1819, 1817, 3, 2, 2, 2, 1819, 1820, 3, 2,
	2, 2, 1820, 1822, 3, 2, 2, 2, 1821, 1819, 3, 2, 2, 2, 1822, 1823, 7, 204,
	2, 2, 1823, 1862, 3, 2, 2, 2, 1824, 1826, 7, 116, 2, 2, 1825, 1827, 7,
	221, 2, 2, 1826, 1825, 3, 2, 2, 2, 1826, 1827, 3, 2, 2, 2, 1827, 1828,
	3, 2, 2, 2, 1828, 1862, 5, 202, 102, 30, 1829, 1862, 5, 196, 99, 2, 1830,
	1862, 5, 120, 61, 2, 1831, 1833, 7, 12, 2, 2, 1832, 1834, 7, 221, 2, 2,
	1833, 1832, 3, 2, 2, 2, 1833, 1834, 3, 2, 2, 2, 1834, 1835, 3, 2, 2, 2,
	1835, 1862, 5, 202, 102, 27, 1836, 1838, 5, 232, 117, 2, 1837, 1839, 7,
	221, 2, 2, 1838, 1837, 3, 2, 2, 2, 1838, 1839, 3, 2, 2, 2, 1839, 1840,
	3, 2, 2, 2, 1840, 1842, 7, 189, 2, 2, 1841, 1843, 7, 221, 2, 2, 1842, 1841,
	3, 2, 2, 2, 1842, 1843, 3, 2, 2, 2, 1843, 1844, 3, 2, 2, 2, 1844, 1845,
	5, 202, 102, 26, 1845, 1862, 3, 2, 2, 2, 1846, 1848, 7, 197, 2, 2, 1847,
	1849, 7, 221, 2, 2, 1848, 1847, 3, 2, 2, 2, 1848, 1849, 3, 2, 2, 2, 1849,
	1850, 3, 2, 2, 2, 1850, 1862, 5, 202, 102, 16, 1851, 1853, 7, 201, 2, 2,
	1852, 1854, 7, 221, 2, 2, 1853, 1852, 3, 2, 2, 2, 1853, 1854, 3, 2, 2,
	2, 1854, 1855, 3, 2, 2, 2, 1855, 1862, 5, 202, 102, 15, 1856, 1858, 7,
	117, 2, 2, 1857, 1859, 7, 221, 2, 2, 1858, 1857, 3, 2, 2, 2, 1858, 1859,
	3, 2, 2, 2, 1859, 1860, 3, 2, 2, 2, 1860, 1862, 5, 202, 102, 3, 1861, 1801,
	3, 2, 2, 2, 1861, 1803, 3, 2, 2, 2, 1861, 1804, 3, 2, 2, 2, 1861, 1824,
	3, 2, 2, 2, 1861, 1829, 3, 2, 2, 2, 1861, 1830, 3, 2, 2, 2, 1861, 1831,
	3, 2, 2, 2, 1861, 1836, 3, 2, 2, 2, 1861, 1846, 3, 2, 2, 2, 1861, 1851,
	3, 2, 2, 2, 1861, 1856, 3, 2, 2, 2, 1862, 2045, 3, 2, 2, 2, 1863, 1865,
	12, 25, 2, 2, 1864, 1866, 7, 221, 2, 2, 1865, 1864, 3, 2, 2, 2, 1865, 1866,
	3, 2, 2, 2, 1866, 1867, 3, 2, 2, 2, 1867, 1869, 7, 89, 2, 2, 1868, 1870,
	7, 221, 2, 2, 1869, 1868, 3, 2, 2, 2, 1869, 1870, 3, 2, 2, 2, 1870, 1871,
	3, 2, 2, 2, 1871, 2044, 5, 202, 102, 26, 1872, 1874, 12, 24, 2, 2, 1873,
	1875, 7, 221, 2, 2, 1874, 1873, 3, 2, 2, 2, 1874, 1875, 3, 2, 2, 2, 1875,
	1876, 3, 2, 2, 2, 1876, 1878, 7, 99, 2, 2, 1877, 1879, 7, 221, 2, 2, 1878,
	1877, 3, 2, 2, 2, 1878, 1879, 3, 2, 2, 2, 1879, 1880, 3, 2, 2, 2, 1880,
	2044, 5, 202, 102, 25, 1881, 1883, 12, 23, 2, 2, 1882, 1884, 7, 221, 2,
	2, 1883, 1882, 3, 2, 2, 2, 1883, 1884, 3, 2, 2, 2, 1884, 1885, 3, 2, 2,
	2, 1885, 1887, 7, 192, 2, 2, 1886, 1888, 7, 221, 2, 2, 1887, 1886, 3, 2,
	2, 2, 1887, 1888, 3, 2, 2, 2, 1888, 1889, 3, 2, 2, 2, 1889, 2044, 5, 202,
	102, 24, 1890, 1892, 12, 22, 2, 2, 1891, 1893, 7, 221, 2, 2, 1892, 1891,
	3, 2, 2, 2, 1892, 1893, 3, 2, 2, 2, 1893, 1894, 3, 2, 2, 2, 1894, 1896,
	7, 194, 2, 2, 1895, 1897, 7, 221, 2, 2, 1896, 1895, 3, 2, 2, 2, 1896, 1897,
	3, 2, 2, 2, 1897, 1898, 3, 2, 2, 2, 1898, 2044, 5, 202, 102, 23, 1899,
	1901, 12, 21, 2, 2, 1900, 1902, 7, 221, 2, 2, 1901, 1900, 3, 2, 2, 2, 1901,
	1902, 3, 2, 2, 2, 1902, 1903, 3, 2, 2, 2, 1903, 1905, 7, 193, 2, 2, 1904,
	1906, 7, 221, 2, 2, 1905, 1904, 3, 2, 2, 2, 1905, 1906, 3, 2, 2, 2, 1906,
	1907, 3, 2, 2, 2, 1907, 2044, 5, 202, 102, 22, 1908, 1910, 12, 20, 2, 2,
	1909, 1911, 7, 221, 2, 2, 1910, 1909, 3, 2, 2, 2, 1910, 1911, 3, 2, 2,
	2, 1911, 1912, 3, 2, 2, 2, 1912, 1914, 7, 196, 2, 2, 1913, 1915, 7, 221,
	2, 2, 1914, 1913, 3, 2, 2, 2, 1914, 1915, 3, 2, 2, 2, 1915, 1916, 3, 2,
	2, 2, 1916, 2044, 5, 202, 102, 21, 1917, 1919, 12, 19, 2, 2, 1918, 1920,
	7, 221, 2, 2, 1919, 1918, 3, 2, 2, 2, 1919, 1920, 3, 2, 2, 2, 1920, 1921,
	3, 2, 2, 2, 1921, 1923, 7, 200, 2, 2, 1922, 1924, 7, 221, 2, 2, 1923, 1922,
	3, 2, 2, 2, 1923, 1924, 3, 2, 2, 2, 1924, 1925, 3, 2, 2, 2, 1925, 2044,
	5, 202, 102, 20, 1926, 1928, 12, 18, 2, 2, 1927, 1929, 7, 221, 2, 2, 1928,
	1927, 3, 2, 2, 2, 1928, 1929, 3, 2, 2, 2, 1929, 1930, 3, 2, 2, 2, 1930,
	1932, 7, 191, 2, 2, 1931, 1933, 7, 221, 2, 2, 1932, 1931, 3, 2, 2, 2, 1932,
	1933, 3, 2, 2, 2, 1933, 1934, 3, 2, 2, 2, 1934, 2044, 5, 202, 102, 19,
	1935, 1937, 12, 17, 2, 2, 1936, 1938, 7, 221, 2, 2, 1937, 1936, 3, 2, 2,
	2, 1937, 1938, 3, 2, 2, 2, 1938, 1939, 3, 2, 2, 2, 1939, 1941, 7, 203,
	2, 2, 1940, 1942, 7, 221, 2, 2, 1941, 1940, 3, 2, 2, 2, 1941, 1942, 3,
	2, 2, 2, 1942, 1943, 3, 2, 2, 2, 1943, 2044, 5, 202, 102, 18, 1944, 1946,
	12, 14, 2, 2, 1945, 1947, 7, 221, 2, 2, 1946, 1945, 3, 2, 2, 2, 1946, 1947,
	3, 2, 2, 2, 1947, 1948, 3, 2, 2, 2, 1948, 1950, 7, 190, 2, 2, 1949, 1951,
	7, 221, 2, 2, 1950, 1949, 3, 2, 2, 2, 1950, 1951, 3, 2, 2, 2, 1951, 1952,
	3, 2, 2, 2, 1952, 2044, 5, 202, 102, 15, 1953, 1955, 12, 13, 2, 2, 1954,
	1956, 7, 221, 2, 2, 1955, 1954, 3, 2, 2, 2, 1955, 1956, 3, 2, 2, 2, 1956,
	1957, 3, 2, 2, 2, 1957, 1959, 7, 199, 2, 2, 1958, 1960, 7, 221, 2, 2, 1959,
	1958, 3, 2, 2, 2, 1959, 1960, 3, 2, 2, 2, 1960, 1961, 3, 2, 2, 2, 1961,
	2044, 5, 202, 102, 14, 1962, 1964, 12, 12, 2, 2, 1963, 1965, 7, 221, 2,
	2, 1964, 1963, 3, 2, 2, 2, 1964, 1965, 3, 2, 2, 2, 1965, 1966, 3, 2, 2,
	2, 1966, 1968, 7, 113, 2, 2, 1967, 1969, 7, 221, 2, 2, 1968, 1967, 3, 2,
	2, 2, 1968, 1969, 3, 2, 2, 2, 1969, 1970, 3, 2, 2, 2, 1970, 2044, 5, 202,
	102, 13, 1971, 1973, 12, 11, 2, 2, 1972, 1974, 7, 221, 2, 2, 1973, 1972,
	3, 2, 2, 2, 1973, 1974, 3, 2, 2, 2, 1974, 1975, 3, 2, 2, 2, 1975, 1977,
	7, 201, 2, 2, 1976, 1978, 7, 221, 2, 2, 1977, 1976, 3, 2, 2, 2, 1977, 1978,
	3, 2, 2, 2, 1978, 1979, 3, 2, 2, 2, 1979, 2044, 5, 202, 102, 12, 1980,
	1982, 12, 10, 2, 2, 1981, 1983, 7, 221, 2, 2, 1982, 1981, 3, 2, 2, 2, 1982,
	1983, 3, 2, 2, 2, 1983, 1984, 3, 2, 2, 2, 1984, 1986, 7, 197, 2, 2, 1985,
	1987, 7, 221, 2, 2, 1986, 1985, 3, 2, 2, 2, 1986, 1987, 3, 2, 2, 2, 1987,
	1988, 3, 2, 2, 2, 1988, 2044, 5, 202, 102, 11, 1989, 1991, 12, 9, 2, 2,
	1990, 1992, 7, 221, 2, 2, 1991, 1990, 3, 2, 2, 2, 1991, 1992, 3, 2, 2,
	2, 1992, 1993, 3, 2, 2, 2, 1993, 1995, 7, 188, 2, 2, 1994, 1996, 7, 221,
	2, 2, 1995, 1994, 3, 2, 2, 2, 1995, 1996, 3, 2, 2, 2, 1996, 1997, 3, 2,
	2, 2, 1997, 2044, 5, 202, 102, 10, 1998, 2000, 12, 8, 2, 2, 1999, 2001,
	7, 221, 2, 2, 2000, 1999, 3, 2, 2, 2, 2000, 2001, 3, 2, 2, 2, 2001, 2002,
	3, 2, 2, 2, 2002, 2004, 7, 85, 2, 2, 2003, 2005, 7, 221, 2, 2, 2004, 2003,
	3, 2, 2, 2, 2004, 2005, 3, 2, 2, 2, 2005, 2006, 3, 2, 2, 2, 2006, 2044,
	5, 202, 102, 9, 2007, 2009, 12, 7, 2, 2, 2008, 2010, 7, 221, 2, 2, 2009,
	2008, 3, 2, 2, 2, 2009, 2010, 3, 2, 2, 2, 2010, 2011, 3, 2, 2, 2, 2011,
	2013, 7, 66, 2, 2, 2012, 2014, 7, 221, 2, 2, 2013, 2012, 3, 2, 2, 2, 2013,
	2014, 3, 2, 2, 2, 2014, 2015, 3, 2, 2, 2, 2015, 2044, 5, 202, 102, 8, 2016,
	2018, 12, 6, 2, 2, 2017, 2019, 7, 221, 2, 2, 2018, 2017, 3, 2, 2, 2, 2018,
	2019, 3, 2, 2, 2, 2019, 2020, 3, 2, 2, 2, 2020, 2022, 7, 187, 2, 2, 2021,
	2023, 7, 221, 2, 2, 2022, 2021, 3, 2, 2, 2, 2022, 2023, 3, 2, 2, 2, 2023,
	2024, 3, 2, 2, 2, 2024, 2044, 5, 202, 102, 7, 2025, 2027, 12, 5, 2, 2,
	2026, 2028, 7, 221, 2, 2, 2027, 2026, 3, 2, 2, 2, 2027, 2028, 3, 2, 2,
	2, 2028, 2029, 3, 2, 2, 2, 2029, 2031, 7, 129, 2, 2, 2030, 2032, 7, 221,
	2, 2, 2031, 2030, 3, 2, 2, 2, 2031, 2032, 3, 2, 2, 2, 2032, 2033, 3, 2,
	2, 2, 2033, 2044, 5, 202, 102, 6, 2034, 2036, 12, 4, 2, 2, 2035, 2037,
	7, 221, 2, 2, 2036, 2035, 3, 2, 2, 2, 2036, 2037, 3, 2, 2, 2, 2037, 2038,
	3, 2, 2, 2, 2038, 2040, 7, 14, 2, 2, 2039, 2041, 7, 221, 2, 2, 2040, 2039,
	3, 2, 2, 2, 2040, 2041, 3, 2, 2, 2, 2041, 2042, 3, 2, 2, 2, 2042, 2044,
	5, 202, 102, 5, 2043, 1863, 3, 2, 2, 2, 2043, 1872, 3, 2, 2, 2, 2043, 1881,
	3, 2, 2, 2, 2043, 1890, 3, 2, 2, 2, 2043, 1899, 3, 2, 2, 2, 2043, 1908,
	3, 2, 2, 2, 2043, 1917, 3, 2, 2, 2, 2043, 1926, 3, 2, 2, 2, 2043, 1935,
	3, 2, 2, 2, 2043, 1944, 3, 2, 2, 2, 2043, 1953, 3, 2, 2, 2, 2043, 1962,
	3, 2, 2, 2, 2043, 1971, 3, 2, 2, 2, 2043, 1980, 3, 2, 2, 2, 2043, 1989,
	3, 2, 2, 2, 2043, 1998, 3, 2, 2, 2, 2043, 2007, 3, 2, 2, 2, 2043, 2016,
	3, 2, 2, 2, 2043, 2025, 3, 2, 2, 2, 2043, 2034, 3, 2, 2, 2, 2044, 2047,
	3, 2, 2, 2, 2045, 2043, 3, 2, 2, 2, 2045, 2046, 3, 2, 2, 2, 2046, 203,
	3, 2, 2, 2, 2047, 2045, 3, 2, 2, 2, 2048, 2052, 7, 50, 2, 2, 2049, 2052,
	7, 163, 2, 2, 2050, 2052, 5, 284, 143, 2, 2051, 2048, 3, 2, 2, 2, 2051,
	2049, 3, 2, 2, 2, 2051, 2050, 3, 2, 2, 2, 2052, 2053, 3, 2, 2, 2, 2053,
	2056, 7, 221, 2, 2, 2054, 2055, 7, 185, 2, 2, 2055, 2057, 7, 221, 2, 2,
	2056, 2054, 3, 2, 2, 2, 2056, 2057, 3, 2, 2, 2, 2057, 2058, 3, 2, 2, 2,
	2058, 2059, 5, 206, 104, 2, 2059, 205, 3, 2, 2, 2, 2060, 2071, 5, 208,
	105, 2, 2061, 2063, 7, 221, 2, 2, 2062, 2061, 3, 2, 2, 2, 2062, 2063, 3,
	2, 2, 2, 2063, 2064, 3, 2, 2, 2, 2064, 2066, 7, 3, 2, 2, 2065, 2067, 7,
	221, 2, 2, 2066, 2065, 3, 2, 2, 2, 2066, 2067, 3, 2, 2, 2, 2067, 2068,
	3, 2, 2, 2, 2068, 2070, 5, 208, 105, 2, 2069, 2062, 3, 2, 2, 2, 2070, 2073,
	3, 2, 2, 2, 2071, 2069, 3, 2, 2, 2, 2071, 2072, 3, 2, 2, 2, 2072, 207,
	3, 2, 2, 2, 2073, 2071, 3, 2, 2, 2, 2074, 2092, 5, 260, 131, 2, 2075, 2077,
	7, 221, 2, 2, 2076, 2075, 3, 2, 2, 2, 2076, 2077, 3, 2, 2, 2, 2077, 2078,
	3, 2, 2, 2, 2078, 2080, 7, 195, 2, 2, 2079, 2081, 7, 221, 2, 2, 2080, 2079,
	3, 2, 2, 2, 2080, 2081, 3, 2, 2, 2, 2081, 2086, 3, 2, 2, 2, 2082, 2084,
	5, 256, 129, 2, 2083, 2085, 7, 221, 2, 2, 2084, 2083, 3, 2, 2, 2, 2084,
	2085, 3, 2, 2, 2, 2085, 2087, 3, 2, 2, 2, 2086, 2082, 3, 2, 2, 2, 2086,
	2087, 3, 2, 2, 2, 2087, 2088, 3, 2, 2, 2, 2088, 2090, 7, 204, 2, 2, 2089,
	2091, 7, 221, 2, 2, 2090, 2089, 3, 2, 2, 2, 2090, 2091, 3, 2, 2, 2, 2091,
	2093, 3, 2, 2, 2, 2092, 2076, 3, 2, 2, 2, 2092, 2093, 3, 2, 2, 2, 2093,
	2095, 3, 2, 2, 2, 2094, 2096, 5, 282, 142, 2, 2095, 2094, 3, 2, 2, 2, 2095,
	2096, 3, 2, 2, 2, 2096, 2099, 3, 2, 2, 2, 2097, 2098, 7, 221, 2, 2, 2098,
	2100, 5, 262, 132, 2, 2099, 2097, 3, 2, 2, 2, 2099, 2100, 3, 2, 2, 2, 2100,
	209, 3, 2, 2, 2, 2101, 2102, 7, 182, 2, 2, 2102, 2103, 7, 221, 2, 2, 2103,
	2104, 5, 202, 102, 2, 2104, 2106, 5, 294, 148, 2, 2105, 2107, 5, 28, 15,
	2, 2106, 2105, 3, 2, 2, 2, 2106, 2107, 3, 2, 2, 2, 2107, 2108, 3, 2, 2,
	2, 2108, 2109, 7, 181, 2, 2, 2109, 211, 3, 2, 2, 2, 2110, 2111, 7, 183,
	2, 2, 2111, 2112, 7, 221, 2, 2, 2112, 2114, 5, 218, 110, 2, 2113, 2115,
	7, 221, 2, 2, 2114, 2113, 3, 2, 2, 2, 2114, 2115, 3, 2, 2, 2, 2115, 2116,
	3, 2, 2, 2, 2116, 2118, 7, 3, 2, 2, 2117, 2119, 7, 221, 2, 2, 2118, 2117,
	3, 2, 2, 2, 2118, 2119, 3, 2, 2, 2, 2119, 2120, 3, 2, 2, 2, 2120, 2121,
	5, 202, 102, 2, 2121, 213, 3, 2, 2, 2, 2122, 2123, 7, 184, 2, 2, 2123,
	2128, 7, 221, 2, 2, 2124, 2129, 5, 232, 117, 2, 2125, 2126, 7, 116, 2,
	2, 2126, 2127, 7, 221, 2, 2, 2127, 2129, 5, 280, 141, 2, 2128, 2124, 3,
	2, 2, 2, 2128, 2125, 3, 2, 2, 2, 2129, 2130, 3, 2, 2, 2, 2130, 2132, 5,
	294, 148, 2, 2131, 2133, 5, 28, 15, 2, 2132, 2131, 3, 2, 2, 2, 2132, 2133,
	3, 2, 2, 2, 2133, 2134, 3, 2, 2, 2, 2134, 2135, 7, 63, 2, 2, 2135, 215,
	3, 2, 2, 2, 2136, 2137, 7, 186, 2, 2, 2137, 2138, 7, 221, 2, 2, 2138, 2140,
	5, 218, 110, 2, 2139, 2141, 7, 221, 2, 2, 2140, 2139, 3, 2, 2, 2, 2140,
	2141, 3, 2, 2, 2, 2141, 2142, 3, 2, 2, 2, 2142, 2147, 7, 3, 2, 2, 2143,
	2145, 7, 221, 2, 2, 2144, 2143, 3, 2, 2, 2, 2144, 2145, 3, 2, 2, 2, 2145,
	2146, 3, 2, 2, 2, 2146, 2148, 5, 134, 68, 2, 2147, 2144, 3, 2, 2, 2, 2147,
	2148, 3, 2, 2, 2, 2148, 217, 3, 2, 2, 2, 2149, 2151, 7, 5, 2, 2, 2150,
	2149, 3, 2, 2, 2, 2150, 2151, 3, 2, 2, 2, 2151, 2152, 3, 2, 2, 2, 2152,
	2153, 5, 202, 102, 2, 2153, 219, 3, 2, 2, 2, 2154, 2157, 5, 222, 112, 2,
	2155, 2157, 5, 224, 113, 2, 2156, 2154, 3, 2, 2, 2, 2156, 2155, 3, 2, 2,
	2, 2157, 221, 3, 2, 2, 2, 2158, 2159, 7, 26, 2, 2, 2159, 2160, 7, 221,
	2, 2, 2160, 2162, 5, 260, 131, 2, 2161, 2163, 5, 282, 142, 2, 2162, 2161,
	3, 2, 2, 2, 2162, 2163, 3, 2, 2, 2, 2163, 2177, 3, 2, 2, 2, 2164, 2166,
	7, 221, 2, 2, 2165, 2164, 3, 2, 2, 2, 2165, 2166, 3, 2, 2, 2, 2166, 2167,
	3, 2, 2, 2, 2167, 2169, 7, 195, 2, 2, 2168, 2170, 7, 221, 2, 2, 2169, 2168,
	3, 2, 2, 2, 2169, 2170, 3, 2, 2, 2, 2170, 2171, 3, 2, 2, 2, 2171, 2173,
	5, 244, 123, 2, 2172, 2174, 7, 221, 2, 2, 2173, 2172, 3, 2, 2, 2, 2173,
	2174, 3, 2, 2, 2, 2174, 2175, 3, 2, 2, 2, 2175, 2176, 7, 204, 2, 2, 2176,
	2178, 3, 2, 2, 2, 2177, 2165, 3, 2, 2, 2, 2177, 2178, 3, 2, 2, 2, 2178,
	2188, 3, 2, 2, 2, 2179, 2181, 7, 221, 2, 2, 2180, 2179, 3, 2, 2, 2, 2180,
	2181, 3, 2, 2, 2, 2181, 2182, 3, 2, 2, 2, 2182, 2183, 7, 195, 2, 2, 2183,
	2184, 5, 256, 129, 2, 2184, 2185, 7, 204, 2, 2, 2185, 2187, 3, 2, 2, 2,
	2186, 2180, 3, 2, 2, 2, 2187, 2190, 3, 2, 2, 2, 2188, 2186, 3, 2, 2, 2,
	2188, 2189, 3, 2, 2, 2, 2189, 223, 3, 2, 2, 2, 2190, 2188, 3, 2, 2, 2,
	2191, 2192, 7, 26, 2, 2, 2192, 2194, 7, 221, 2, 2, 2193, 2195, 5, 232,
	117, 2, 2194, 2193, 3, 2, 2, 2, 2194, 2195, 3, 2, 2, 2, 2195, 2196, 3,
	2, 2, 2, 2196, 2197, 7, 6, 2, 2, 2197, 2199, 5, 260, 131, 2, 2198, 2200,
	5, 282, 142, 2, 2199, 2198, 3, 2, 2, 2, 2199, 2200, 3, 2, 2, 2, 2200, 2214,
	3, 2, 2, 2, 2201, 2203, 7, 221, 2, 2, 2202, 2201, 3, 2, 2, 2, 2202, 2203,
	3, 2, 2, 2, 2203, 2204, 3, 2, 2, 2, 2204, 2206, 7, 195, 2, 2, 2205, 2207,
	7, 221, 2, 2, 2206, 2205, 3, 2, 2, 2, 2206, 2207, 3, 2, 2, 2, 2207, 2208,
	3, 2, 2, 2, 2208, 2210, 5, 244, 123, 2, 2209, 2211, 7, 221, 2, 2, 2210,
	2209, 3, 2, 2, 2, 2210, 2211, 3, 2, 2, 2, 2211, 2212, 3, 2, 2, 2, 2212,
	2213, 7, 204, 2, 2, 2213, 2215, 3, 2, 2, 2, 2214, 2202, 3, 2, 2, 2, 2214,
	2215, 3, 2, 2, 2, 2215, 2225, 3, 2, 2, 2, 2216, 2218, 7, 221, 2, 2, 2217,
	2216, 3, 2, 2, 2, 2217, 2218, 3, 2, 2, 2, 2218, 2219, 3, 2, 2, 2, 2219,
	2220, 7, 195, 2, 2, 2220, 2221, 5, 256, 129, 2, 2221, 2222, 7, 204, 2,
	2, 2222, 2224, 3, 2, 2, 2, 2223, 2217, 3, 2, 2, 2, 2224, 2227, 3, 2, 2,
	2, 2225, 2223, 3, 2, 2, 2, 2225, 2226, 3, 2, 2, 2, 2226, 225, 3, 2, 2,
	2, 2227, 2225, 3, 2, 2, 2, 2228, 2231, 5, 228, 115, 2, 2229, 2231, 5, 230,
	116, 2, 2230, 2228, 3, 2, 2, 2, 2230, 2229, 3, 2, 2, 2, 2231, 227, 3, 2,
	2, 2, 2232, 2234, 5, 232, 117, 2, 2233, 2232, 3, 2, 2, 2, 2233, 2234, 3,
	2, 2, 2, 2234, 2235, 3, 2, 2, 2, 2235, 2236, 7, 6, 2, 2, 2236, 2238, 5,
	260, 131, 2, 2237, 2239, 5, 282, 142, 2, 2238, 2237, 3, 2, 2, 2, 2238,
	2239, 3, 2, 2, 2, 2239, 2242, 3, 2, 2, 2, 2240, 2241, 7, 221, 2, 2, 2241,
	2243, 5, 244, 123, 2, 2242, 2240, 3, 2, 2, 2, 2242, 2243, 3, 2, 2, 2, 2243,
	2245, 3, 2, 2, 2, 2244, 2246, 5, 248, 125, 2, 2245, 2244, 3, 2, 2, 2, 2245,
	2246, 3, 2, 2, 2, 2246, 2256, 3, 2, 2, 2, 2247, 2249, 7, 221, 2, 2, 2248,
	2247, 3, 2, 2, 2, 2248, 2249, 3, 2, 2, 2, 2249, 2250, 3, 2, 2, 2, 2250,
	2251, 7, 195, 2, 2, 2251, 2252, 5, 256, 129, 2, 2252, 2253, 7, 204, 2,
	2, 2253, 2255, 3, 2, 2, 2, 2254, 2248, 3, 2, 2, 2, 2255, 2258, 3, 2, 2,
	2, 2256, 2254, 3, 2, 2, 2, 2256, 2257, 3, 2, 2, 2, 2257, 229, 3, 2, 2,
	2, 2258, 2256, 3, 2, 2, 2, 2259, 2262, 5, 266, 134, 2, 2260, 2261, 7, 221,
	2, 2, 2261, 2263, 5, 244, 123, 2, 2262, 2260, 3, 2, 2, 2, 2262, 2263, 3,
	2, 2, 2, 2263, 2273, 3, 2, 2, 2, 2264, 2266, 7, 221, 2, 2, 2265, 2264,
	3, 2, 2, 2, 2265, 2266, 3, 2, 2, 2, 2266, 2267, 3, 2, 2, 2, 2267, 2268,
	7, 195, 2, 2, 2268, 2269, 5, 256, 129, 2, 2269, 2270, 7, 204, 2, 2, 2270,
	2272, 3, 2, 2, 2, 2271, 2265, 3, 2, 2, 2, 2272, 2275, 3, 2, 2, 2, 2273,
	2271, 3, 2, 2, 2, 2273, 2274, 3, 2, 2, 2, 2274, 231, 3, 2, 2, 2, 2275,
	2273, 3, 2, 2, 2, 2276, 2281, 5, 238, 120, 2, 2277, 2281, 5, 234, 118,
	2, 2278, 2281, 5, 236, 119, 2, 2279, 2281, 5, 242, 122, 2, 2280, 2276,
	3, 2, 2, 2, 2280, 2277, 3, 2, 2, 2, 2280, 2278, 3, 2, 2, 2, 2280, 2279,
	3, 2, 2, 2, 2281, 233, 3, 2, 2, 2, 2282, 2284, 5, 260, 131, 2, 2283, 2285,
	5, 282, 142, 2, 2284, 2283, 3, 2, 2, 2, 2284, 2285, 3, 2, 2, 2, 2285, 2287,
	3, 2, 2, 2, 2286, 2288, 5, 248, 125, 2, 2287, 2286, 3, 2, 2, 2, 2287, 2288,
	3, 2, 2, 2, 2288, 2298, 3, 2, 2, 2, 2289, 2291, 7, 221, 2, 2, 2290, 2289,
	3, 2, 2, 2, 2290, 2291, 3, 2, 2, 2, 2291, 2292, 3, 2, 2, 2, 2292, 2293,
	7, 195, 2, 2, 2293, 2294, 5, 256, 129, 2, 2294, 2295, 7, 204, 2, 2, 2295,
	2297, 3, 2, 2, 2, 2296, 2290, 3, 2, 2, 2, 2297, 2300, 3, 2, 2, 2, 2298,
	2296, 3, 2, 2, 2, 2298, 2299, 3, 2, 2, 2, 2299, 235, 3, 2, 2, 2, 2300,
	2298, 3, 2, 2, 2, 2301, 2304, 5, 260, 131, 2, 2302, 2304, 5, 264, 133,
	2, 2303, 2301, 3, 2, 2, 2, 2303, 2302, 3, 2, 2, 2, 2304, 2306, 3, 2, 2,
	2, 2305, 2307, 5, 282, 142, 2, 2306, 2305, 3, 2, 2, 2, 2306, 2307, 3, 2,
	2, 2, 2307, 2309, 3, 2, 2, 2, 2308, 2310, 7, 221, 2, 2, 2309, 2308, 3,
	2, 2, 2, 2309, 2310, 3, 2, 2, 2, 2310, 2311, 3, 2, 2, 2, 2311, 2313, 7,
	195, 2, 2, 2312, 2314, 7, 221, 2, 2, 2313, 2312, 3, 2, 2, 2, 2313, 2314,
	3, 2, 2, 2, 2314, 2319, 3, 2, 2, 2, 2315, 2317, 5, 244, 123, 2, 2316, 2318,
	7, 221, 2, 2, 2317, 2316, 3, 2, 2, 2, 2317, 2318, 3, 2, 2, 2, 2318, 2320,
	3, 2, 2, 2, 2319, 2315, 3, 2, 2, 2, 2319, 2320, 3, 2, 2, 2, 2320, 2321,
	3, 2, 2, 2, 2321, 2323, 7, 204, 2, 2, 2322, 2324, 5, 248, 125, 2, 2323,
	2322, 3, 2, 2, 2, 2323, 2324, 3, 2, 2, 2, 2324, 2334, 3, 2, 2, 2, 2325,
	2327, 7, 221, 2, 2, 2326, 2325, 3, 2, 2, 2, 2326, 2327, 3, 2, 2, 2, 2327,
	2328, 3, 2, 2, 2, 2328, 2329, 7, 195, 2, 2, 2329, 2330, 5, 256, 129, 2,
	2330, 2331, 7, 204, 2, 2, 2331, 2333, 3, 2, 2, 2, 2332, 2326, 3, 2, 2,
	2, 2333, 2336, 3, 2, 2, 2, 2334, 2332, 3, 2, 2, 2, 2334, 2335, 3, 2, 2,
	2, 2335, 237, 3, 2, 2, 2, 2336, 2334, 3, 2, 2, 2, 2337, 2340, 5, 234, 118,
	2, 2338, 2340, 5, 236, 119, 2, 2339, 2337, 3, 2, 2, 2, 2339, 2338, 3, 2,
	2, 2, 2339, 2340, 3, 2, 2, 2, 2340, 2342, 3, 2, 2, 2, 2341, 2343, 5, 240,
	121, 2, 2342, 2341, 3, 2, 2, 2, 2343, 2344, 3, 2, 2, 2, 2344, 2342, 3,
	2, 2, 2, 2344, 2345, 3, 2, 2, 2, 2345, 2347, 3, 2, 2, 2, 2346, 2348, 5,
	248, 125, 2, 2347, 2346, 3, 2, 2, 2, 2347, 2348, 3, 2, 2, 2, 2348, 2358,
	3, 2, 2, 2, 2349, 2351, 7, 221, 2, 2, 2350, 2349, 3, 2, 2, 2, 2350, 2351,
	3, 2, 2, 2, 2351, 2352, 3, 2, 2, 2, 2352, 2353, 7, 195, 2, 2, 2353, 2354,
	5, 256, 129, 2, 2354, 2355, 7, 204, 2, 2, 2355, 2357, 3, 2, 2, 2, 2356,
	2350, 3, 2, 2, 2, 2357, 2360, 3, 2, 2, 2, 2358, 2356, 3, 2, 2, 2, 2358,
	2359, 3, 2, 2, 2, 2359, 239, 3, 2, 2, 2, 2360, 2358, 3, 2, 2, 2, 2361,
	2364, 9, 13, 2, 2, 2362, 2365, 5, 234, 118, 2, 2363, 2365, 5, 236, 119,
	2, 2364, 2362, 3, 2, 2, 2, 2364, 2363, 3, 2, 2, 2, 2365, 241, 3, 2, 2,
	2, 2366, 2367, 5, 248, 125, 2, 2367, 243, 3, 2, 2, 2, 2368, 2370, 5, 246,
	124, 2, 2369, 2368, 3, 2, 2, 2, 2369, 2370, 3, 2, 2, 2, 2370, 2372, 3,
	2, 2, 2, 2371, 2373, 7, 221, 2, 2, 2372, 2371, 3, 2, 2, 2, 2372, 2373,
	3, 2, 2, 2, 2373, 2374, 3, 2, 2, 2, 2374, 2376, 9, 11, 2, 2, 2375, 2377,
	7, 221, 2, 2, 2376, 2375, 3, 2, 2, 2, 2376, 2377, 3, 2, 2, 2, 2377, 2379,
	3, 2, 2, 2, 2378, 2369, 3, 2, 2, 2, 2379, 2382, 3, 2, 2, 2, 2380, 2378,
	3, 2, 2, 2, 2380, 2381, 3, 2, 2, 2, 2381, 2383, 3, 2, 2, 2, 2382, 2380,
	3, 2, 2, 2, 2383, 2396, 5, 246, 124, 2, 2384, 2386, 7, 221, 2, 2, 2385,
	2384, 3, 2, 2, 2, 2385, 2386, 3, 2, 2, 2, 2386, 2387, 3, 2, 2, 2, 2387,
	2389, 9, 11, 2, 2, 2388, 2390, 7, 221, 2, 2, 2389, 2388, 3, 2, 2, 2, 2389,
	2390, 3, 2, 2, 2, 2390, 2392, 3, 2, 2, 2, 2391, 2393, 5, 246, 124, 2, 2392,
	2391, 3, 2, 2, 2, 2392, 2393, 3, 2, 2, 2, 2393, 2395, 3, 2, 2, 2, 2394,
	2385, 3, 2, 2, 2, 2395, 2398, 3, 2, 2, 2, 2396, 2394, 3, 2, 2, 2, 2396,
	2397, 3, 2, 2, 2, 2397, 245, 3, 2, 2, 2, 2398, 2396, 3, 2, 2, 2, 2399,
	2401, 7, 195, 2, 2, 2400, 2399, 3, 2, 2, 2, 2400, 2401, 3, 2, 2, 2, 2401,
	2404, 3, 2, 2, 2, 2402, 2403, 9, 14, 2, 2, 2403, 2405, 7, 221, 2, 2, 2404,
	2402, 3, 2, 2, 2, 2404, 2405, 3, 2, 2, 2, 2405, 2407, 3, 2, 2, 2, 2406,
	2408, 7, 204, 2, 2, 2407, 2406, 3, 2, 2, 2, 2407, 2408, 3, 2, 2, 2, 2408,
	2409, 3, 2, 2, 2, 2409, 2410, 5, 202, 102, 2, 2410, 247, 3, 2, 2, 2, 2411,
	2412, 7, 7, 2, 2, 2412, 2414, 5, 260, 131, 2, 2413, 2415, 5, 282, 142,
	2, 2414, 2413, 3, 2, 2, 2, 2414, 2415, 3, 2, 2, 2, 2415, 249, 3, 2, 2,
	2, 2416, 2434, 7, 195, 2, 2, 2417, 2419, 7, 221, 2, 2, 2418, 2417, 3, 2,
	2, 2, 2418, 2419, 3, 2, 2, 2, 2419, 2420, 3, 2, 2, 2, 2420, 2431, 5, 252,
	127, 2, 2421, 2423, 7, 221, 2, 2, 2422, 2421, 3, 2, 2, 2, 2422, 2423, 3,
	2, 2, 2, 2423, 2424, 3, 2, 2, 2, 2424, 2426, 7, 3, 2, 2, 2425, 2427, 7,
	221, 2, 2, 2426, 2425, 3, 2, 2, 2, 2426, 2427, 3, 2, 2, 2, 2427, 2428,
	3, 2, 2, 2, 2428, 2430, 5, 252, 127, 2, 2429, 2422, 3, 2, 2, 2, 2430, 2433,
	3, 2, 2, 2, 2431, 2429, 3, 2, 2, 2, 2431, 2432, 3, 2, 2, 2, 2432, 2435,
	3, 2, 2, 2, 2433, 2431, 3, 2, 2, 2, 2434, 2418, 3, 2, 2, 2, 2434, 2435,
	3, 2, 2, 2, 2435, 2437, 3, 2, 2, 2, 2436, 2438, 7, 221, 2, 2, 2437, 2436,
	3, 2, 2, 2, 2437, 2438, 3, 2, 2, 2, 2438, 2439, 3, 2, 2, 2, 2439, 2440,
	7, 204, 2, 2, 2440, 251, 3, 2, 2, 2, 2441, 2442, 7, 124, 2, 2, 2442, 2444,
	7, 221, 2, 2, 2443, 2441, 3, 2, 2, 2, 2443, 2444, 3, 2, 2, 2, 2444, 2447,
	3, 2, 2, 2, 2445, 2446, 9, 15, 2, 2, 2446, 2448, 7, 221, 2, 2, 2447, 2445,
	3, 2, 2, 2, 2447, 2448, 3, 2, 2, 2, 2448, 2451, 3, 2, 2, 2, 2449, 2450,
	7, 131, 2, 2, 2450, 2452, 7, 221, 2, 2, 2451, 2449, 3, 2, 2, 2, 2451, 2452,
	3, 2, 2, 2, 2452, 2453, 3, 2, 2, 2, 2453, 2455, 5, 260, 131, 2, 2454, 2456,
	5, 282, 142, 2, 2455, 2454, 3, 2, 2, 2, 2455, 2456, 3, 2, 2, 2, 2456, 2465,
	3, 2, 2, 2, 2457, 2459, 7, 221, 2, 2, 2458, 2457, 3, 2, 2, 2, 2458, 2459,
	3, 2, 2, 2, 2459, 2460, 3, 2, 2, 2, 2460, 2462, 7, 195, 2, 2, 2461, 2463,
	7, 221, 2, 2, 2462, 2461, 3, 2, 2, 2, 2462, 2463, 3, 2, 2, 2, 2463, 2464,
	3, 2, 2, 2, 2464, 2466, 7, 204, 2, 2, 2465, 2458, 3, 2, 2, 2, 2465, 2466,
	3, 2, 2, 2, 2466, 2471, 3, 2, 2, 2, 2467, 2469, 7, 221, 2, 2, 2468, 2467,
	3, 2, 2, 2, 2468, 2469, 3, 2, 2, 2, 2469, 2470, 3, 2, 2, 2, 2470, 2472,
	5, 262, 132, 2, 2471, 2468, 3, 2, 2, 2, 2471, 2472, 3, 2, 2, 2, 2472, 2477,
	3, 2, 2, 2, 2473, 2475, 7, 221, 2, 2, 2474, 2473, 3, 2, 2, 2, 2474, 2475,
	3, 2, 2, 2, 2475, 2476, 3, 2, 2, 2, 2476, 2478, 5, 254, 128, 2, 2477, 2474,
	3, 2, 2, 2, 2477, 2478, 3, 2, 2, 2, 2478, 253, 3, 2, 2, 2, 2479, 2481,
	7, 191, 2, 2, 2480, 2482, 7, 221, 2, 2, 2481, 2480, 3, 2, 2, 2, 2481, 2482,
	3, 2, 2, 2, 2482, 2483, 3, 2, 2, 2, 2483, 2484, 5, 202, 102, 2, 2484, 255,
	3, 2, 2, 2, 2485, 2496, 5, 258, 130, 2, 2486, 2488, 7, 221, 2, 2, 2487,
	2486, 3, 2, 2, 2, 2487, 2488, 3, 2, 2, 2, 2488, 2489, 3, 2, 2, 2, 2489,
	2491, 7, 3, 2, 2, 2490, 2492, 7, 221, 2, 2, 2491, 2490, 3, 2, 2, 2, 2491,
	2492, 3, 2, 2, 2, 2492, 2493, 3, 2, 2, 2, 2493, 2495, 5, 258, 130, 2, 2494,
	2487, 3, 2, 2, 2, 2495, 2498, 3, 2, 2, 2, 2496, 2494, 3, 2, 2, 2, 2496,
	2497, 3, 2, 2, 2, 2497, 257, 3, 2, 2, 2, 2498, 2496, 3, 2, 2, 2, 2499,
	2500, 5, 202, 102, 2, 2500, 2501, 7, 221, 2, 2, 2501, 2502, 7, 172, 2,
	2, 2502, 2503, 7, 221, 2, 2, 2503, 2505, 3, 2, 2, 2, 2504, 2499, 3, 2,
	2, 2, 2504, 2505, 3, 2, 2, 2, 2505, 2506, 3, 2, 2, 2, 2506, 2507, 5, 202,
	102, 2, 2507, 259, 3, 2, 2, 2, 2508, 2511, 7, 222, 2, 2, 2509, 2511, 5,
	286, 144, 2, 2510, 2508, 3, 2, 2, 2, 2510, 2509, 3, 2, 2, 2, 2511, 2512,
	3, 2, 2, 2, 2512, 2510, 3, 2, 2, 2, 2512, 2513, 3, 2, 2, 2, 2513, 261,
	3, 2, 2, 2, 2514, 2516, 7, 18, 2, 2, 2515, 2517, 7, 221, 2, 2, 2516, 2515,
	3, 2, 2, 2, 2516, 2517, 3, 2, 2, 2, 2517, 2520, 3, 2, 2, 2, 2518, 2519,
	7, 116, 2, 2, 2519, 2521, 7, 221, 2, 2, 2520, 2518, 3, 2, 2, 2, 2520, 2521,
	3, 2, 2, 2, 2521, 2522, 3, 2, 2, 2, 2522, 2527, 5, 280, 141, 2, 2523, 2525,
	7, 221, 2, 2, 2524, 2523, 3, 2, 2, 2, 2524, 2525, 3, 2, 2, 2, 2525, 2526,
	3, 2, 2, 2, 2526, 2528, 5, 272, 137, 2, 2527, 2524, 3, 2, 2, 2, 2527, 2528,
	3, 2, 2, 2, 2528, 263, 3, 2, 2, 2, 2529, 2550, 7, 22, 2, 2, 2530, 2550,
	7, 25, 2, 2, 2531, 2550, 7, 32, 2, 2, 2532, 2550, 7, 35, 2, 2, 2533, 2550,
	7, 52, 2, 2, 2534, 2550, 7, 90, 2, 2, 2535, 2550, 7, 94, 2, 2, 2536, 2550,
	7, 161, 2, 2, 2537, 2546, 7, 166, 2, 2, 2538, 2540, 7, 221, 2, 2, 2539,
	2538, 3, 2, 2, 2, 2539, 2540, 3, 2, 2, 2, 2540, 2541, 3, 2, 2, 2, 2541,
	2543, 7, 199, 2, 2, 2542, 2544, 7, 221, 2, 2, 2543, 2542, 3, 2, 2, 2, 2543,
	2544, 3, 2, 2, 2, 2544, 2545, 3, 2, 2, 2, 2545, 2547, 5, 202, 102, 2, 2546,
	2539, 3, 2, 2, 2, 2546, 2547, 3, 2, 2, 2, 2547, 2550, 3, 2, 2, 2, 2548,
	2550, 7, 179, 2, 2, 2549, 2529, 3, 2, 2, 2, 2549, 2530, 3, 2, 2, 2, 2549,
	2531, 3, 2, 2, 2, 2549, 2532, 3, 2, 2, 2, 2549, 2533, 3, 2, 2, 2, 2549,
	2534, 3, 2, 2, 2, 2549, 2535, 3, 2, 2, 2, 2549, 2536, 3, 2, 2, 2, 2549,
	2537, 3, 2, 2, 2, 2549, 2548, 3, 2, 2, 2, 2550, 265, 3, 2, 2, 2, 2551,
	2556, 7, 222, 2, 2, 2552, 2555, 5, 286, 144, 2, 2553, 2555, 7, 222, 2,
	2, 2554, 2552, 3, 2, 2, 2, 2554, 2553, 3, 2, 2, 2, 2555, 2558, 3, 2, 2,
	2, 2556, 2554, 3, 2, 2, 2, 2556, 2557, 3, 2, 2, 2, 2557, 2567, 3, 2, 2,
	2, 2558, 2556, 3, 2, 2, 2, 2559, 2562, 5, 286, 144, 2, 2560, 2563, 5, 286,
	144, 2, 2561, 2563, 7, 222, 2, 2, 2562, 2560, 3, 2, 2, 2, 2562, 2561, 3,
	2, 2, 2, 2563, 2564, 3, 2, 2, 2, 2564, 2562, 3, 2, 2, 2, 2564, 2565, 3,
	2, 2, 2, 2565, 2567, 3, 2, 2, 2, 2566, 2551, 3, 2, 2, 2, 2566, 2559, 3,
	2, 2, 2, 2567, 267, 3, 2, 2, 2, 2568, 2569, 9, 16, 2, 2, 2569, 269, 3,
	2, 2, 2, 2570, 2575, 5, 260, 131, 2, 2571, 2572, 9, 13, 2, 2, 2572, 2574,
	5, 260, 131, 2, 2573, 2571, 3, 2, 2, 2, 2574, 2577, 3, 2, 2, 2, 2575, 2573,
	3, 2, 2, 2, 2575, 2576, 3, 2, 2, 2, 2576, 271, 3, 2, 2, 2, 2577, 2575,
	3, 2, 2, 2, 2578, 2580, 7, 199, 2, 2, 2579, 2581, 7, 221, 2, 2, 2580, 2579,
	3, 2, 2, 2, 2580, 2581, 3, 2, 2, 2, 2581, 2584, 3, 2, 2, 2, 2582, 2585,
	7, 211, 2, 2, 2583, 2585, 5, 260, 131, 2, 2584, 2582, 3, 2, 2, 2, 2584,
	2583, 3, 2, 2, 2, 2585, 273, 3, 2, 2, 2, 2586, 2595, 5, 266, 134, 2, 2587,
	2589, 7, 221, 2, 2, 2588, 2587, 3, 2, 2, 2, 2588, 2589, 3, 2, 2, 2, 2589,
	2590, 3, 2, 2, 2, 2590, 2592, 7, 197, 2, 2, 2591, 2593, 7, 221, 2, 2, 2592,
	2591, 3, 2, 2, 2, 2592, 2593, 3, 2, 2, 2, 2593, 2594, 3, 2, 2, 2, 2594,
	2596, 5, 266, 134, 2, 2595, 2588, 3, 2, 2, 2, 2595, 2596, 3, 2, 2, 2, 2596,
	275, 3, 2, 2, 2, 2597, 2598, 5, 260, 131, 2, 2598, 2599, 7, 219, 2, 2,
	2599, 277, 3, 2, 2, 2, 2600, 2601, 9, 17, 2, 2, 2601, 279, 3, 2, 2, 2,
	2602, 2605, 5, 264, 133, 2, 2603, 2605, 5, 270, 136, 2, 2604, 2602, 3,
	2, 2, 2, 2604, 2603, 3, 2, 2, 2, 2605, 2614, 3, 2, 2, 2, 2606, 2608, 7,
	221, 2, 2, 2607, 2606, 3, 2, 2, 2, 2607, 2608, 3, 2, 2, 2, 2608, 2609,
	3, 2, 2, 2, 2609, 2611, 7, 195, 2, 2, 2610, 2612, 7, 221, 2, 2, 2611, 2610,
	3, 2, 2, 2, 2611, 2612, 3, 2, 2, 2, 2612, 2613, 3, 2, 2, 2, 2613, 2615,
	7, 204, 2, 2, 2614, 2607, 3, 2, 2, 2, 2614, 2615, 3, 2, 2, 2, 2615, 281,
	3, 2, 2, 2, 2616, 2617, 9, 18, 2, 2, 2617, 283, 3, 2, 2, 2, 2618, 2619,
	9, 19, 2, 2, 2619, 285, 3, 2, 2, 2, 2620, 2621, 9, 20, 2, 2, 2621, 287,
	3, 2, 2, 2, 2622, 2623, 7, 216, 2, 2, 2623, 289, 3, 2, 2, 2, 2624, 2625,
	7, 217, 2, 2, 2625, 291, 3, 2, 2, 2, 2626, 2628, 7, 221, 2, 2, 2627, 2626,
	3, 2, 2, 2, 2627, 2628, 3, 2, 2, 2, 2628, 2632, 3, 2, 2, 2, 2629, 2633,
	7, 215, 2, 2, 2630, 2633, 5, 290, 146, 2, 2631, 2633, 5, 288, 145, 2, 2632,
	2629, 3, 2, 2, 2, 2632, 2630, 3, 2, 2, 2, 2632, 2631, 3, 2, 2, 2, 2633,
	2635, 3, 2, 2, 2, 2634, 2636, 7, 221, 2, 2, 2635, 2634, 3, 2, 2, 2, 2635,
	2636, 3, 2, 2, 2, 2636, 293, 3, 2, 2, 2, 2637, 2646, 5, 292, 147, 2, 2638,
	2640, 7, 221, 2, 2, 2639, 2638, 3, 2, 2, 2, 2639, 2640, 3, 2, 2, 2, 2640,
	2641, 3, 2, 2, 2, 2641, 2643, 7, 219, 2, 2, 2642, 2644, 7, 221, 2, 2, 2643,
	2642, 3, 2, 2, 2, 2643, 2644, 3, 2, 2, 2, 2644, 2646, 3, 2, 2, 2, 2645,
	2637, 3, 2, 2, 2, 2645, 2639, 3, 2, 2, 2, 2646, 2649, 3, 2, 2, 2, 2647,
	2645, 3, 2, 2, 2, 2647, 2648, 3, 2, 2, 2, 2648, 295, 3, 2, 2, 2, 2649,
	2647, 3, 2, 2, 2, 453, 300, 305, 312, 315, 318, 323, 327, 332, 336, 341,
	345, 350, 354, 366, 372, 378, 382, 388, 395, 399, 405, 411, 417, 428, 440,
	444, 450, 456, 462, 471, 477, 481, 485, 489, 494, 503, 576, 582, 586, 589,
	605, 609, 614, 617, 622, 628, 632, 637, 642, 646, 649, 653, 659, 663, 670,
	676, 680, 683, 688, 698, 701, 704, 708, 714, 718, 723, 730, 734, 738, 742,
	745, 750, 761, 774, 781, 790, 797, 801, 804, 813, 818, 828, 834, 844, 848,
	858, 866, 871, 877, 881, 884, 888, 899, 903, 908, 913, 917, 921, 925, 928,
	931, 934, 937, 941, 949, 953, 956, 959, 963, 986, 992, 996, 1000, 1009,
	1020, 1025, 1035, 1039, 1044, 1052, 1056, 1060, 1068, 1072, 1084, 1088,
	1095, 1097, 1103, 1107, 1113, 1117, 1121, 1129, 1133, 1139, 1148, 1150,
	1155, 1164, 1166, 1174, 1176, 1181, 1185, 1189, 1213, 1223, 1227, 1232,
	1243, 1247, 1252, 1266, 1270, 1279, 1283, 1286, 1290, 1294, 1297, 1301,
	1305, 1308, 1312, 1315, 1319, 1321, 1326, 1330, 1334, 1338, 1340, 1346,
	1350, 1353, 1358, 1362, 1368, 1371, 1374, 1378, 1382, 1389, 1393, 1399,
	1402, 1406, 1413, 1417, 1423, 1426, 1430, 1438, 1442, 1445, 1448, 1452,
	1460, 1464, 1468, 1470, 1473, 1478, 1484, 1488, 1492, 1497, 1502, 1506,
	1510, 1515, 1523, 1525, 1537, 1541, 1549, 1553, 1561, 1565, 1569, 1573,
	1577, 1581, 1589, 1593, 1606, 1613, 1617, 1628, 1635, 1640, 1644, 1649,
	1652, 1658, 1662, 1665, 1671, 1675, 1683, 1687, 1696, 1700, 1704, 1708,
	1711, 1715, 1721, 1725, 1732, 1741, 1748, 1752, 1755, 1758, 1761, 1765,
	1776, 1786, 1790, 1797, 1799, 1806, 1810, 1814, 1819, 1826, 1833, 1838,
	1842, 1848, 1853, 1858, 1861, 1865, 1869, 1874, 1878, 1883, 1887, 1892,
	1896, 1901, 1905, 1910, 1914, 1919, 1923, 1928, 1932, 1937, 1941, 1946,
	1950, 1955, 1959, 1964, 1968, 1973, 1977, 1982, 1986, 1991, 1995, 2000,
	2004, 2009, 2013, 2018, 2022, 2027, 2031, 2036, 2040, 2043, 2045, 2051,
	2056, 2062, 2066, 2071, 2076, 2080, 2084, 2086, 2090, 2092, 2095, 2099,
	2106, 2114, 2118, 2128, 2132, 2140, 2144, 2147, 2150, 2156, 2162, 2165,
	2169, 2173, 2177, 2180, 2188, 2194, 2199, 2202, 2206, 2210, 2214, 2217,
	2225, 2230, 2233, 2238, 2242, 2245, 2248, 2256, 2262, 2265, 2273, 2280,
	2284, 2287, 2290, 2298, 2303, 2306, 2309, 2313, 2317, 2319, 2323, 2326,
	2334, 2339, 2344, 2347, 2350, 2358, 2364, 2369, 2372, 2376, 2380, 2385,
	2389, 2392, 2396, 2400, 2404, 2407, 2414, 2418, 2422, 2426, 2431, 2434,
	2437, 2443, 2447, 2451, 2455, 2458, 2462, 2465, 2468, 2471, 2474, 2477,
	2481, 2487, 2491, 2496, 2504, 2510, 2512, 2516, 2520, 2524, 2527, 2539,
	2543, 2546, 2549, 2554, 2556, 2562, 2564, 2566, 2575, 2580, 2584, 2588,
	2592, 2595, 2604, 2607, 2611, 2614, 2627, 2632, 2635, 2639, 2643, 2645,
	2647,
}
var literalNames = []string{
	"", "','", "';'", "'#'", "'.'", "'!'", "'%'", "'@'", "'$'", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "'&'", "':='", "", "'='",
	"'>='", "'>'", "'<='", "'('", "'<'", "'-'", "'-='", "'*'", "'<>'", "'+'",
	"'+='", "'^'", "')'", "'['", "']'", "", "", "", "", "", "", "", "", "",
	"", "", "'''", "':'", "'_'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "ACCESS", "ADDRESSOF", "ALIAS", "AND",
	"ATTRIBUTE", "APPACTIVATE", "APPEND", "AS", "BEGIN", "BEEP", "BINARY",
	"BOOLEAN", "BYVAL", "BYREF", "BYTE", "CALL", "CASE", "CHDIR", "CHDRIVE",
	"CLASS", "CLOSE", "COLLECTION", "CONST", "DATABASE", "DATE", "DECLARE",
	"DEFBOOL", "DEFBYTE", "DEFDATE", "DEFDBL", "DEFDEC", "DEFCUR", "DEFINT",
	"DEFLNG", "DEFOBJ", "DEFSNG", "DEFSTR", "DEFVAR", "DELETESETTING", "DIM",
	"DO", "DOUBLE", "EACH", "ELSE", "ELSEIF", "END_ENUM", "END_FUNCTION", "END_IF",
	"END_PROPERTY", "END_SELECT", "END_SUB", "END_TYPE", "END_WITH", "END",
	"ENUM", "EQV", "ERASE", "ERROR", "EVENT", "EXIT_DO", "EXIT_FOR", "EXIT_FUNCTION",
	"EXIT_PROPERTY", "EXIT_SUB", "FALSE", "FILECOPY", "FRIEND", "FOR", "FUNCTION",
	"GET", "GLOBAL", "GOSUB", "GOTO", "IF", "IMP", "IMPLEMENTS", "IN", "INPUT",
	"IS", "INTEGER", "KILL", "LOAD", "LOCK", "LONG", "LOOP", "LEN", "LET",
	"LIB", "LIKE", "LINE_INPUT", "LOCK_READ", "LOCK_WRITE", "LOCK_READ_WRITE",
	"LSET", "MACRO_CONST", "MACRO_IF", "MACRO_ELSEIF", "MACRO_ELSE", "MACRO_END_IF",
	"ME", "MID", "MKDIR", "MOD", "NAME", "NEXT", "NEW", "NOT", "NOTHING", "NULL_",
	"ON", "ON_ERROR", "ON_LOCAL_ERROR", "OPEN", "OPTIONAL", "OPTION_BASE",
	"OPTION_EXPLICIT", "OPTION_COMPARE", "OPTION_PRIVATE_MODULE", "OR", "OUTPUT",
	"PARAMARRAY", "PRESERVE", "PRINT", "PRIVATE", "PROPERTY_GET", "PROPERTY_LET",
	"PROPERTY_SET", "PTRSAFE", "PUBLIC", "PUT", "RANDOM", "RANDOMIZE", "RAISEEVENT",
	"READ", "READ_WRITE", "REDIM", "REM", "RESET", "RESUME", "RETURN", "RMDIR",
	"RSET", "SAVEPICTURE", "SAVESETTING", "SEEK", "SELECT", "SENDKEYS", "SET",
	"SETATTR", "SHARED", "SINGLE", "SPC", "STATIC", "STEP", "STOP", "STRING",
	"SUB", "TAB", "TEXT", "THEN", "TIME", "TO", "TRUE", "TYPE", "TYPEOF", "UNLOAD",
	"UNLOCK", "UNTIL", "VARIANT", "VERSION", "WEND", "WHILE", "WIDTH", "WITH",
	"WITHEVENTS", "WRITE", "XOR", "AMPERSAND", "ASSIGN", "DIV", "EQ", "GEQ",
	"GT", "LEQ", "LPAREN", "LT", "MINUS", "MINUS_EQ", "MULT", "NEQ", "PLUS",
	"PLUS_EQ", "POW", "RPAREN", "L_SQUARE_BRACKET", "R_SQUARE_BRACKET", "STRINGLITERAL",
	"OCTLITERAL", "HEXLITERAL", "SHORTLITERAL", "INTEGERLITERAL", "DOUBLELITERAL",
	"DATELITERAL", "LINE_CONTINUATION", "NEWLINE", "REMCOMMENT", "COMMENT",
	"SINGLEQUOTE", "COLON", "UNDERSCORE", "WS", "IDENTIFIER",
}

var ruleNames = []string{
	"startRule", "module", "moduleHeader", "moduleConfig", "moduleConfigElement",
	"moduleAttributes", "moduleDeclarations", "moduleOption", "moduleDeclarationsElement",
	"macroStmt", "moduleBody", "moduleBodyElement", "attributeStmt", "block",
	"blockStmt", "appactivateStmt", "beepStmt", "chdirStmt", "chdriveStmt",
	"closeStmt", "constStmt", "constSubStmt", "dateStmt", "declareStmt", "deftypeStmt",
	"deleteSettingStmt", "doLoopStmt", "endStmt", "enumerationStmt", "enumerationStmt_Constant",
	"eraseStmt", "errorStmt", "eventStmt", "exitStmt", "filecopyStmt", "forEachStmt",
	"forNextStmt", "functionStmt", "getStmt", "goSubStmt", "goToStmt", "ifThenElseStmt",
	"ifBlockStmt", "ifConditionStmt", "ifElseIfBlockStmt", "ifElseBlockStmt",
	"implementsStmt", "inputStmt", "killStmt", "letStmt", "lineInputStmt",
	"loadStmt", "lockStmt", "lsetStmt", "macroConstStmt", "macroIfThenElseStmt",
	"macroIfBlockStmt", "macroElseIfBlockStmt", "macroElseBlockStmt", "midStmt",
	"mkdirStmt", "nameStmt", "onErrorStmt", "onGoToStmt", "onGoSubStmt", "openStmt",
	"outputList", "outputList_Expression", "printStmt", "propertyGetStmt",
	"propertySetStmt", "propertyLetStmt", "putStmt", "raiseEventStmt", "randomizeStmt",
	"redimStmt", "redimSubStmt", "resetStmt", "resumeStmt", "returnStmt", "rmdirStmt",
	"rsetStmt", "savepictureStmt", "saveSettingStmt", "seekStmt", "selectCaseStmt",
	"sC_Selection", "sC_Case", "sC_Cond", "sendkeysStmt", "setattrStmt", "setStmt",
	"stopStmt", "subStmt", "timeStmt", "typeStmt", "typeStmt_Element", "typeOfStmt",
	"unloadStmt", "unlockStmt", "valueStmt", "variableStmt", "variableListStmt",
	"variableSubStmt", "whileWendStmt", "widthStmt", "withStmt", "writeStmt",
	"fileNumber", "explicitCallStmt", "eCS_ProcedureCall", "eCS_MemberProcedureCall",
	"implicitCallStmt_InBlock", "iCS_B_MemberProcedureCall", "iCS_B_ProcedureCall",
	"implicitCallStmt_InStmt", "iCS_S_VariableOrProcedureCall", "iCS_S_ProcedureOrArrayCall",
	"iCS_S_MembersCall", "iCS_S_MemberCall", "iCS_S_DictionaryCall", "argsCall",
	"argCall", "dictionaryCallStmt", "argList", "arg", "argDefaultValue", "subscripts",
	"subscript_", "ambiguousIdentifier", "asTypeClause", "baseType", "certainIdentifier",
	"comparisonOperator", "complexType", "fieldLength", "letterrange", "lineLabel",
	"literal", "type_", "typeHint", "visibility", "ambiguousKeyword", "remComment",
	"comment", "endOfLine", "endOfStatement",
}

type vbaParser struct {
	*antlr.BaseParser
}

// NewvbaParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *vbaParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewvbaParser(input antlr.TokenStream) *vbaParser {
	this := new(vbaParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "vba.g4"

	return this
}

// vbaParser tokens.
const (
	vbaParserEOF                   = antlr.TokenEOF
	vbaParserT__0                  = 1
	vbaParserT__1                  = 2
	vbaParserT__2                  = 3
	vbaParserT__3                  = 4
	vbaParserT__4                  = 5
	vbaParserT__5                  = 6
	vbaParserT__6                  = 7
	vbaParserT__7                  = 8
	vbaParserACCESS                = 9
	vbaParserADDRESSOF             = 10
	vbaParserALIAS                 = 11
	vbaParserAND                   = 12
	vbaParserATTRIBUTE             = 13
	vbaParserAPPACTIVATE           = 14
	vbaParserAPPEND                = 15
	vbaParserAS                    = 16
	vbaParserBEGIN                 = 17
	vbaParserBEEP                  = 18
	vbaParserBINARY                = 19
	vbaParserBOOLEAN               = 20
	vbaParserBYVAL                 = 21
	vbaParserBYREF                 = 22
	vbaParserBYTE                  = 23
	vbaParserCALL                  = 24
	vbaParserCASE                  = 25
	vbaParserCHDIR                 = 26
	vbaParserCHDRIVE               = 27
	vbaParserCLASS                 = 28
	vbaParserCLOSE                 = 29
	vbaParserCOLLECTION            = 30
	vbaParserCONST                 = 31
	vbaParserDATABASE              = 32
	vbaParserDATE                  = 33
	vbaParserDECLARE               = 34
	vbaParserDEFBOOL               = 35
	vbaParserDEFBYTE               = 36
	vbaParserDEFDATE               = 37
	vbaParserDEFDBL                = 38
	vbaParserDEFDEC                = 39
	vbaParserDEFCUR                = 40
	vbaParserDEFINT                = 41
	vbaParserDEFLNG                = 42
	vbaParserDEFOBJ                = 43
	vbaParserDEFSNG                = 44
	vbaParserDEFSTR                = 45
	vbaParserDEFVAR                = 46
	vbaParserDELETESETTING         = 47
	vbaParserDIM                   = 48
	vbaParserDO                    = 49
	vbaParserDOUBLE                = 50
	vbaParserEACH                  = 51
	vbaParserELSE                  = 52
	vbaParserELSEIF                = 53
	vbaParserEND_ENUM              = 54
	vbaParserEND_FUNCTION          = 55
	vbaParserEND_IF                = 56
	vbaParserEND_PROPERTY          = 57
	vbaParserEND_SELECT            = 58
	vbaParserEND_SUB               = 59
	vbaParserEND_TYPE              = 60
	vbaParserEND_WITH              = 61
	vbaParserEND                   = 62
	vbaParserENUM                  = 63
	vbaParserEQV                   = 64
	vbaParserERASE                 = 65
	vbaParserERROR                 = 66
	vbaParserEVENT                 = 67
	vbaParserEXIT_DO               = 68
	vbaParserEXIT_FOR              = 69
	vbaParserEXIT_FUNCTION         = 70
	vbaParserEXIT_PROPERTY         = 71
	vbaParserEXIT_SUB              = 72
	vbaParserFALSE                 = 73
	vbaParserFILECOPY              = 74
	vbaParserFRIEND                = 75
	vbaParserFOR                   = 76
	vbaParserFUNCTION              = 77
	vbaParserGET                   = 78
	vbaParserGLOBAL                = 79
	vbaParserGOSUB                 = 80
	vbaParserGOTO                  = 81
	vbaParserIF                    = 82
	vbaParserIMP                   = 83
	vbaParserIMPLEMENTS            = 84
	vbaParserIN                    = 85
	vbaParserINPUT                 = 86
	vbaParserIS                    = 87
	vbaParserINTEGER               = 88
	vbaParserKILL                  = 89
	vbaParserLOAD                  = 90
	vbaParserLOCK                  = 91
	vbaParserLONG                  = 92
	vbaParserLOOP                  = 93
	vbaParserLEN                   = 94
	vbaParserLET                   = 95
	vbaParserLIB                   = 96
	vbaParserLIKE                  = 97
	vbaParserLINE_INPUT            = 98
	vbaParserLOCK_READ             = 99
	vbaParserLOCK_WRITE            = 100
	vbaParserLOCK_READ_WRITE       = 101
	vbaParserLSET                  = 102
	vbaParserMACRO_CONST           = 103
	vbaParserMACRO_IF              = 104
	vbaParserMACRO_ELSEIF          = 105
	vbaParserMACRO_ELSE            = 106
	vbaParserMACRO_END_IF          = 107
	vbaParserME                    = 108
	vbaParserMID                   = 109
	vbaParserMKDIR                 = 110
	vbaParserMOD                   = 111
	vbaParserNAME                  = 112
	vbaParserNEXT                  = 113
	vbaParserNEW                   = 114
	vbaParserNOT                   = 115
	vbaParserNOTHING               = 116
	vbaParserNULL_                 = 117
	vbaParserON                    = 118
	vbaParserON_ERROR              = 119
	vbaParserON_LOCAL_ERROR        = 120
	vbaParserOPEN                  = 121
	vbaParserOPTIONAL              = 122
	vbaParserOPTION_BASE           = 123
	vbaParserOPTION_EXPLICIT       = 124
	vbaParserOPTION_COMPARE        = 125
	vbaParserOPTION_PRIVATE_MODULE = 126
	vbaParserOR                    = 127
	vbaParserOUTPUT                = 128
	vbaParserPARAMARRAY            = 129
	vbaParserPRESERVE              = 130
	vbaParserPRINT                 = 131
	vbaParserPRIVATE               = 132
	vbaParserPROPERTY_GET          = 133
	vbaParserPROPERTY_LET          = 134
	vbaParserPROPERTY_SET          = 135
	vbaParserPTRSAFE               = 136
	vbaParserPUBLIC                = 137
	vbaParserPUT                   = 138
	vbaParserRANDOM                = 139
	vbaParserRANDOMIZE             = 140
	vbaParserRAISEEVENT            = 141
	vbaParserREAD                  = 142
	vbaParserREAD_WRITE            = 143
	vbaParserREDIM                 = 144
	vbaParserREM                   = 145
	vbaParserRESET                 = 146
	vbaParserRESUME                = 147
	vbaParserRETURN                = 148
	vbaParserRMDIR                 = 149
	vbaParserRSET                  = 150
	vbaParserSAVEPICTURE           = 151
	vbaParserSAVESETTING           = 152
	vbaParserSEEK                  = 153
	vbaParserSELECT                = 154
	vbaParserSENDKEYS              = 155
	vbaParserSET                   = 156
	vbaParserSETATTR               = 157
	vbaParserSHARED                = 158
	vbaParserSINGLE                = 159
	vbaParserSPC                   = 160
	vbaParserSTATIC                = 161
	vbaParserSTEP                  = 162
	vbaParserSTOP                  = 163
	vbaParserSTRING                = 164
	vbaParserSUB                   = 165
	vbaParserTAB                   = 166
	vbaParserTEXT                  = 167
	vbaParserTHEN                  = 168
	vbaParserTIME                  = 169
	vbaParserTO                    = 170
	vbaParserTRUE                  = 171
	vbaParserTYPE                  = 172
	vbaParserTYPEOF                = 173
	vbaParserUNLOAD                = 174
	vbaParserUNLOCK                = 175
	vbaParserUNTIL                 = 176
	vbaParserVARIANT               = 177
	vbaParserVERSION               = 178
	vbaParserWEND                  = 179
	vbaParserWHILE                 = 180
	vbaParserWIDTH                 = 181
	vbaParserWITH                  = 182
	vbaParserWITHEVENTS            = 183
	vbaParserWRITE                 = 184
	vbaParserXOR                   = 185
	vbaParserAMPERSAND             = 186
	vbaParserASSIGN                = 187
	vbaParserDIV                   = 188
	vbaParserEQ                    = 189
	vbaParserGEQ                   = 190
	vbaParserGT                    = 191
	vbaParserLEQ                   = 192
	vbaParserLPAREN                = 193
	vbaParserLT                    = 194
	vbaParserMINUS                 = 195
	vbaParserMINUS_EQ              = 196
	vbaParserMULT                  = 197
	vbaParserNEQ                   = 198
	vbaParserPLUS                  = 199
	vbaParserPLUS_EQ               = 200
	vbaParserPOW                   = 201
	vbaParserRPAREN                = 202
	vbaParserL_SQUARE_BRACKET      = 203
	vbaParserR_SQUARE_BRACKET      = 204
	vbaParserSTRINGLITERAL         = 205
	vbaParserOCTLITERAL            = 206
	vbaParserHEXLITERAL            = 207
	vbaParserSHORTLITERAL          = 208
	vbaParserINTEGERLITERAL        = 209
	vbaParserDOUBLELITERAL         = 210
	vbaParserDATELITERAL           = 211
	vbaParserLINE_CONTINUATION     = 212
	vbaParserNEWLINE               = 213
	vbaParserREMCOMMENT            = 214
	vbaParserCOMMENT               = 215
	vbaParserSINGLEQUOTE           = 216
	vbaParserCOLON                 = 217
	vbaParserUNDERSCORE            = 218
	vbaParserWS                    = 219
	vbaParserIDENTIFIER            = 220
)

// vbaParser rules.
const (
	vbaParserRULE_startRule                     = 0
	vbaParserRULE_module                        = 1
	vbaParserRULE_moduleHeader                  = 2
	vbaParserRULE_moduleConfig                  = 3
	vbaParserRULE_moduleConfigElement           = 4
	vbaParserRULE_moduleAttributes              = 5
	vbaParserRULE_moduleDeclarations            = 6
	vbaParserRULE_moduleOption                  = 7
	vbaParserRULE_moduleDeclarationsElement     = 8
	vbaParserRULE_macroStmt                     = 9
	vbaParserRULE_moduleBody                    = 10
	vbaParserRULE_moduleBodyElement             = 11
	vbaParserRULE_attributeStmt                 = 12
	vbaParserRULE_block                         = 13
	vbaParserRULE_blockStmt                     = 14
	vbaParserRULE_appactivateStmt               = 15
	vbaParserRULE_beepStmt                      = 16
	vbaParserRULE_chdirStmt                     = 17
	vbaParserRULE_chdriveStmt                   = 18
	vbaParserRULE_closeStmt                     = 19
	vbaParserRULE_constStmt                     = 20
	vbaParserRULE_constSubStmt                  = 21
	vbaParserRULE_dateStmt                      = 22
	vbaParserRULE_declareStmt                   = 23
	vbaParserRULE_deftypeStmt                   = 24
	vbaParserRULE_deleteSettingStmt             = 25
	vbaParserRULE_doLoopStmt                    = 26
	vbaParserRULE_endStmt                       = 27
	vbaParserRULE_enumerationStmt               = 28
	vbaParserRULE_enumerationStmt_Constant      = 29
	vbaParserRULE_eraseStmt                     = 30
	vbaParserRULE_errorStmt                     = 31
	vbaParserRULE_eventStmt                     = 32
	vbaParserRULE_exitStmt                      = 33
	vbaParserRULE_filecopyStmt                  = 34
	vbaParserRULE_forEachStmt                   = 35
	vbaParserRULE_forNextStmt                   = 36
	vbaParserRULE_functionStmt                  = 37
	vbaParserRULE_getStmt                       = 38
	vbaParserRULE_goSubStmt                     = 39
	vbaParserRULE_goToStmt                      = 40
	vbaParserRULE_ifThenElseStmt                = 41
	vbaParserRULE_ifBlockStmt                   = 42
	vbaParserRULE_ifConditionStmt               = 43
	vbaParserRULE_ifElseIfBlockStmt             = 44
	vbaParserRULE_ifElseBlockStmt               = 45
	vbaParserRULE_implementsStmt                = 46
	vbaParserRULE_inputStmt                     = 47
	vbaParserRULE_killStmt                      = 48
	vbaParserRULE_letStmt                       = 49
	vbaParserRULE_lineInputStmt                 = 50
	vbaParserRULE_loadStmt                      = 51
	vbaParserRULE_lockStmt                      = 52
	vbaParserRULE_lsetStmt                      = 53
	vbaParserRULE_macroConstStmt                = 54
	vbaParserRULE_macroIfThenElseStmt           = 55
	vbaParserRULE_macroIfBlockStmt              = 56
	vbaParserRULE_macroElseIfBlockStmt          = 57
	vbaParserRULE_macroElseBlockStmt            = 58
	vbaParserRULE_midStmt                       = 59
	vbaParserRULE_mkdirStmt                     = 60
	vbaParserRULE_nameStmt                      = 61
	vbaParserRULE_onErrorStmt                   = 62
	vbaParserRULE_onGoToStmt                    = 63
	vbaParserRULE_onGoSubStmt                   = 64
	vbaParserRULE_openStmt                      = 65
	vbaParserRULE_outputList                    = 66
	vbaParserRULE_outputList_Expression         = 67
	vbaParserRULE_printStmt                     = 68
	vbaParserRULE_propertyGetStmt               = 69
	vbaParserRULE_propertySetStmt               = 70
	vbaParserRULE_propertyLetStmt               = 71
	vbaParserRULE_putStmt                       = 72
	vbaParserRULE_raiseEventStmt                = 73
	vbaParserRULE_randomizeStmt                 = 74
	vbaParserRULE_redimStmt                     = 75
	vbaParserRULE_redimSubStmt                  = 76
	vbaParserRULE_resetStmt                     = 77
	vbaParserRULE_resumeStmt                    = 78
	vbaParserRULE_returnStmt                    = 79
	vbaParserRULE_rmdirStmt                     = 80
	vbaParserRULE_rsetStmt                      = 81
	vbaParserRULE_savepictureStmt               = 82
	vbaParserRULE_saveSettingStmt               = 83
	vbaParserRULE_seekStmt                      = 84
	vbaParserRULE_selectCaseStmt                = 85
	vbaParserRULE_sC_Selection                  = 86
	vbaParserRULE_sC_Case                       = 87
	vbaParserRULE_sC_Cond                       = 88
	vbaParserRULE_sendkeysStmt                  = 89
	vbaParserRULE_setattrStmt                   = 90
	vbaParserRULE_setStmt                       = 91
	vbaParserRULE_stopStmt                      = 92
	vbaParserRULE_subStmt                       = 93
	vbaParserRULE_timeStmt                      = 94
	vbaParserRULE_typeStmt                      = 95
	vbaParserRULE_typeStmt_Element              = 96
	vbaParserRULE_typeOfStmt                    = 97
	vbaParserRULE_unloadStmt                    = 98
	vbaParserRULE_unlockStmt                    = 99
	vbaParserRULE_valueStmt                     = 100
	vbaParserRULE_variableStmt                  = 101
	vbaParserRULE_variableListStmt              = 102
	vbaParserRULE_variableSubStmt               = 103
	vbaParserRULE_whileWendStmt                 = 104
	vbaParserRULE_widthStmt                     = 105
	vbaParserRULE_withStmt                      = 106
	vbaParserRULE_writeStmt                     = 107
	vbaParserRULE_fileNumber                    = 108
	vbaParserRULE_explicitCallStmt              = 109
	vbaParserRULE_eCS_ProcedureCall             = 110
	vbaParserRULE_eCS_MemberProcedureCall       = 111
	vbaParserRULE_implicitCallStmt_InBlock      = 112
	vbaParserRULE_iCS_B_MemberProcedureCall     = 113
	vbaParserRULE_iCS_B_ProcedureCall           = 114
	vbaParserRULE_implicitCallStmt_InStmt       = 115
	vbaParserRULE_iCS_S_VariableOrProcedureCall = 116
	vbaParserRULE_iCS_S_ProcedureOrArrayCall    = 117
	vbaParserRULE_iCS_S_MembersCall             = 118
	vbaParserRULE_iCS_S_MemberCall              = 119
	vbaParserRULE_iCS_S_DictionaryCall          = 120
	vbaParserRULE_argsCall                      = 121
	vbaParserRULE_argCall                       = 122
	vbaParserRULE_dictionaryCallStmt            = 123
	vbaParserRULE_argList                       = 124
	vbaParserRULE_arg                           = 125
	vbaParserRULE_argDefaultValue               = 126
	vbaParserRULE_subscripts                    = 127
	vbaParserRULE_subscript_                    = 128
	vbaParserRULE_ambiguousIdentifier           = 129
	vbaParserRULE_asTypeClause                  = 130
	vbaParserRULE_baseType                      = 131
	vbaParserRULE_certainIdentifier             = 132
	vbaParserRULE_comparisonOperator            = 133
	vbaParserRULE_complexType                   = 134
	vbaParserRULE_fieldLength                   = 135
	vbaParserRULE_letterrange                   = 136
	vbaParserRULE_lineLabel                     = 137
	vbaParserRULE_literal                       = 138
	vbaParserRULE_type_                         = 139
	vbaParserRULE_typeHint                      = 140
	vbaParserRULE_visibility                    = 141
	vbaParserRULE_ambiguousKeyword              = 142
	vbaParserRULE_remComment                    = 143
	vbaParserRULE_comment                       = 144
	vbaParserRULE_endOfLine                     = 145
	vbaParserRULE_endOfStatement                = 146
)

// IStartRuleContext is an interface to support dynamic dispatch.
type IStartRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartRuleContext differentiates from other interfaces.
	IsStartRuleContext()
}

type StartRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartRuleContext() *StartRuleContext {
	var p = new(StartRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_startRule
	return p
}

func (*StartRuleContext) IsStartRuleContext() {}

func NewStartRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartRuleContext {
	var p = new(StartRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_startRule

	return p
}

func (s *StartRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *StartRuleContext) Module() IModuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleContext)
}

func (s *StartRuleContext) EOF() antlr.TerminalNode {
	return s.GetToken(vbaParserEOF, 0)
}

func (s *StartRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterStartRule(s)
	}
}

func (s *StartRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitStartRule(s)
	}
}

func (p *vbaParser) StartRule() (localctx IStartRuleContext) {
	this := p
	_ = this

	localctx = NewStartRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, vbaParserRULE_startRule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(294)
		p.Module()
	}
	{
		p.SetState(295)
		p.Match(vbaParserEOF)
	}

	return localctx
}

// IModuleContext is an interface to support dynamic dispatch.
type IModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleContext differentiates from other interfaces.
	IsModuleContext()
}

type ModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleContext() *ModuleContext {
	var p = new(ModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_module
	return p
}

func (*ModuleContext) IsModuleContext() {}

func NewModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleContext {
	var p = new(ModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_module

	return p
}

func (s *ModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ModuleContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ModuleContext) AllEndOfLine() []IEndOfLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEndOfLineContext)(nil)).Elem())
	var tst = make([]IEndOfLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEndOfLineContext)
		}
	}

	return tst
}

func (s *ModuleContext) EndOfLine(i int) IEndOfLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEndOfLineContext)
}

func (s *ModuleContext) ModuleHeader() IModuleHeaderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleHeaderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleHeaderContext)
}

func (s *ModuleContext) ModuleConfig() IModuleConfigContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleConfigContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleConfigContext)
}

func (s *ModuleContext) ModuleAttributes() IModuleAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleAttributesContext)
}

func (s *ModuleContext) ModuleDeclarations() IModuleDeclarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleDeclarationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleDeclarationsContext)
}

func (s *ModuleContext) ModuleBody() IModuleBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleBodyContext)
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterModule(s)
	}
}

func (s *ModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitModule(s)
	}
}

func (p *vbaParser) Module() (localctx IModuleContext) {
	this := p
	_ = this

	localctx = NewModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, vbaParserRULE_module)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(298)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(297)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(303)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(300)
				p.EndOfLine()
			}

		}
		p.SetState(305)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())
	}
	p.SetState(313)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserVERSION {
		{
			p.SetState(306)
			p.ModuleHeader()
		}
		p.SetState(310)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(307)
					p.EndOfLine()
				}

			}
			p.SetState(312)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())
		}

	}
	p.SetState(316)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserBEGIN {
		{
			p.SetState(315)
			p.ModuleConfig()
		}

	}
	p.SetState(321)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(318)
				p.EndOfLine()
			}

		}
		p.SetState(323)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())
	}
	p.SetState(325)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserATTRIBUTE {
		{
			p.SetState(324)
			p.ModuleAttributes()
		}

	}
	p.SetState(330)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(327)
				p.EndOfLine()
			}

		}
		p.SetState(332)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())
	}
	p.SetState(334)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(333)
			p.ModuleDeclarations()
		}

	}
	p.SetState(339)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(336)
				p.EndOfLine()
			}

		}
		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())
	}
	p.SetState(343)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(vbaParserFRIEND-75))|(1<<(vbaParserFUNCTION-75))|(1<<(vbaParserGLOBAL-75))|(1<<(vbaParserMACRO_CONST-75))|(1<<(vbaParserMACRO_IF-75)))) != 0) || (((_la-132)&-(0x1f+1)) == 0 && ((1<<uint((_la-132)))&((1<<(vbaParserPRIVATE-132))|(1<<(vbaParserPROPERTY_GET-132))|(1<<(vbaParserPROPERTY_LET-132))|(1<<(vbaParserPROPERTY_SET-132))|(1<<(vbaParserPUBLIC-132))|(1<<(vbaParserSTATIC-132)))) != 0) || _la == vbaParserSUB {
		{
			p.SetState(342)
			p.ModuleBody()
		}

	}
	p.SetState(348)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(345)
				p.EndOfLine()
			}

		}
		p.SetState(350)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext())
	}
	p.SetState(352)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(351)
			p.Match(vbaParserWS)
		}

	}

	return localctx
}

// IModuleHeaderContext is an interface to support dynamic dispatch.
type IModuleHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleHeaderContext differentiates from other interfaces.
	IsModuleHeaderContext()
}

type ModuleHeaderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleHeaderContext() *ModuleHeaderContext {
	var p = new(ModuleHeaderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_moduleHeader
	return p
}

func (*ModuleHeaderContext) IsModuleHeaderContext() {}

func NewModuleHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleHeaderContext {
	var p = new(ModuleHeaderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_moduleHeader

	return p
}

func (s *ModuleHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleHeaderContext) VERSION() antlr.TerminalNode {
	return s.GetToken(vbaParserVERSION, 0)
}

func (s *ModuleHeaderContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ModuleHeaderContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ModuleHeaderContext) DOUBLELITERAL() antlr.TerminalNode {
	return s.GetToken(vbaParserDOUBLELITERAL, 0)
}

func (s *ModuleHeaderContext) CLASS() antlr.TerminalNode {
	return s.GetToken(vbaParserCLASS, 0)
}

func (s *ModuleHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterModuleHeader(s)
	}
}

func (s *ModuleHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitModuleHeader(s)
	}
}

func (p *vbaParser) ModuleHeader() (localctx IModuleHeaderContext) {
	this := p
	_ = this

	localctx = NewModuleHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, vbaParserRULE_moduleHeader)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(354)
		p.Match(vbaParserVERSION)
	}
	{
		p.SetState(355)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(356)
		p.Match(vbaParserDOUBLELITERAL)
	}
	{
		p.SetState(357)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(358)
		p.Match(vbaParserCLASS)
	}

	return localctx
}

// IModuleConfigContext is an interface to support dynamic dispatch.
type IModuleConfigContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleConfigContext differentiates from other interfaces.
	IsModuleConfigContext()
}

type ModuleConfigContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleConfigContext() *ModuleConfigContext {
	var p = new(ModuleConfigContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_moduleConfig
	return p
}

func (*ModuleConfigContext) IsModuleConfigContext() {}

func NewModuleConfigContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleConfigContext {
	var p = new(ModuleConfigContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_moduleConfig

	return p
}

func (s *ModuleConfigContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleConfigContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vbaParserBEGIN, 0)
}

func (s *ModuleConfigContext) END() antlr.TerminalNode {
	return s.GetToken(vbaParserEND, 0)
}

func (s *ModuleConfigContext) AllEndOfLine() []IEndOfLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEndOfLineContext)(nil)).Elem())
	var tst = make([]IEndOfLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEndOfLineContext)
		}
	}

	return tst
}

func (s *ModuleConfigContext) EndOfLine(i int) IEndOfLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEndOfLineContext)
}

func (s *ModuleConfigContext) AllModuleConfigElement() []IModuleConfigElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleConfigElementContext)(nil)).Elem())
	var tst = make([]IModuleConfigElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleConfigElementContext)
		}
	}

	return tst
}

func (s *ModuleConfigContext) ModuleConfigElement(i int) IModuleConfigElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleConfigElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleConfigElementContext)
}

func (s *ModuleConfigContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleConfigContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleConfigContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterModuleConfig(s)
	}
}

func (s *ModuleConfigContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitModuleConfig(s)
	}
}

func (p *vbaParser) ModuleConfig() (localctx IModuleConfigContext) {
	this := p
	_ = this

	localctx = NewModuleConfigContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, vbaParserRULE_moduleConfig)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(360)
		p.Match(vbaParserBEGIN)
	}
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(vbaParserNEWLINE-213))|(1<<(vbaParserREMCOMMENT-213))|(1<<(vbaParserCOMMENT-213))|(1<<(vbaParserWS-213)))) != 0 {
		{
			p.SetState(361)
			p.EndOfLine()
		}

		p.SetState(366)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(367)
				p.ModuleConfigElement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(370)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext())
	}
	{
		p.SetState(372)
		p.Match(vbaParserEND)
	}

	return localctx
}

// IModuleConfigElementContext is an interface to support dynamic dispatch.
type IModuleConfigElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleConfigElementContext differentiates from other interfaces.
	IsModuleConfigElementContext()
}

type ModuleConfigElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleConfigElementContext() *ModuleConfigElementContext {
	var p = new(ModuleConfigElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_moduleConfigElement
	return p
}

func (*ModuleConfigElementContext) IsModuleConfigElementContext() {}

func NewModuleConfigElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleConfigElementContext {
	var p = new(ModuleConfigElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_moduleConfigElement

	return p
}

func (s *ModuleConfigElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleConfigElementContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *ModuleConfigElementContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *ModuleConfigElementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ModuleConfigElementContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ModuleConfigElementContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ModuleConfigElementContext) AllEndOfLine() []IEndOfLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEndOfLineContext)(nil)).Elem())
	var tst = make([]IEndOfLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEndOfLineContext)
		}
	}

	return tst
}

func (s *ModuleConfigElementContext) EndOfLine(i int) IEndOfLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEndOfLineContext)
}

func (s *ModuleConfigElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleConfigElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleConfigElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterModuleConfigElement(s)
	}
}

func (s *ModuleConfigElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitModuleConfigElement(s)
	}
}

func (p *vbaParser) ModuleConfigElement() (localctx IModuleConfigElementContext) {
	this := p
	_ = this

	localctx = NewModuleConfigElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, vbaParserRULE_moduleConfigElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(374)
		p.AmbiguousIdentifier()
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(375)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(378)
		p.Match(vbaParserEQ)
	}
	p.SetState(380)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(379)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(382)
		p.Literal()
	}
	p.SetState(386)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(vbaParserNEWLINE-213))|(1<<(vbaParserREMCOMMENT-213))|(1<<(vbaParserCOMMENT-213))|(1<<(vbaParserWS-213)))) != 0 {
		{
			p.SetState(383)
			p.EndOfLine()
		}

		p.SetState(388)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IModuleAttributesContext is an interface to support dynamic dispatch.
type IModuleAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleAttributesContext differentiates from other interfaces.
	IsModuleAttributesContext()
}

type ModuleAttributesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleAttributesContext() *ModuleAttributesContext {
	var p = new(ModuleAttributesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_moduleAttributes
	return p
}

func (*ModuleAttributesContext) IsModuleAttributesContext() {}

func NewModuleAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleAttributesContext {
	var p = new(ModuleAttributesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_moduleAttributes

	return p
}

func (s *ModuleAttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleAttributesContext) AllAttributeStmt() []IAttributeStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeStmtContext)(nil)).Elem())
	var tst = make([]IAttributeStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeStmtContext)
		}
	}

	return tst
}

func (s *ModuleAttributesContext) AttributeStmt(i int) IAttributeStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeStmtContext)
}

func (s *ModuleAttributesContext) AllEndOfLine() []IEndOfLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEndOfLineContext)(nil)).Elem())
	var tst = make([]IEndOfLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEndOfLineContext)
		}
	}

	return tst
}

func (s *ModuleAttributesContext) EndOfLine(i int) IEndOfLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEndOfLineContext)
}

func (s *ModuleAttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleAttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleAttributesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterModuleAttributes(s)
	}
}

func (s *ModuleAttributesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitModuleAttributes(s)
	}
}

func (p *vbaParser) ModuleAttributes() (localctx IModuleAttributesContext) {
	this := p
	_ = this

	localctx = NewModuleAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, vbaParserRULE_moduleAttributes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == vbaParserATTRIBUTE {
		{
			p.SetState(389)
			p.AttributeStmt()
		}
		p.SetState(391)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(390)
					p.EndOfLine()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(393)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())
		}

		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IModuleDeclarationsContext is an interface to support dynamic dispatch.
type IModuleDeclarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleDeclarationsContext differentiates from other interfaces.
	IsModuleDeclarationsContext()
}

type ModuleDeclarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDeclarationsContext() *ModuleDeclarationsContext {
	var p = new(ModuleDeclarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_moduleDeclarations
	return p
}

func (*ModuleDeclarationsContext) IsModuleDeclarationsContext() {}

func NewModuleDeclarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDeclarationsContext {
	var p = new(ModuleDeclarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_moduleDeclarations

	return p
}

func (s *ModuleDeclarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDeclarationsContext) AllModuleDeclarationsElement() []IModuleDeclarationsElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleDeclarationsElementContext)(nil)).Elem())
	var tst = make([]IModuleDeclarationsElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleDeclarationsElementContext)
		}
	}

	return tst
}

func (s *ModuleDeclarationsContext) ModuleDeclarationsElement(i int) IModuleDeclarationsElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleDeclarationsElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleDeclarationsElementContext)
}

func (s *ModuleDeclarationsContext) AllEndOfLine() []IEndOfLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEndOfLineContext)(nil)).Elem())
	var tst = make([]IEndOfLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEndOfLineContext)
		}
	}

	return tst
}

func (s *ModuleDeclarationsContext) EndOfLine(i int) IEndOfLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEndOfLineContext)
}

func (s *ModuleDeclarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDeclarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDeclarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterModuleDeclarations(s)
	}
}

func (s *ModuleDeclarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitModuleDeclarations(s)
	}
}

func (p *vbaParser) ModuleDeclarations() (localctx IModuleDeclarationsContext) {
	this := p
	_ = this

	localctx = NewModuleDeclarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, vbaParserRULE_moduleDeclarations)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(399)
		p.ModuleDeclarationsElement()
	}
	p.SetState(409)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(401)
			p.GetErrorHandler().Sync(p)
			_alt = 1
			for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1:
					{
						p.SetState(400)
						p.EndOfLine()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

				p.SetState(403)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())
			}
			{
				p.SetState(405)
				p.ModuleDeclarationsElement()
			}

		}
		p.SetState(411)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
	}
	p.SetState(415)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(412)
				p.EndOfLine()
			}

		}
		p.SetState(417)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())
	}

	return localctx
}

// IModuleOptionContext is an interface to support dynamic dispatch.
type IModuleOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleOptionContext differentiates from other interfaces.
	IsModuleOptionContext()
}

type ModuleOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleOptionContext() *ModuleOptionContext {
	var p = new(ModuleOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_moduleOption
	return p
}

func (*ModuleOptionContext) IsModuleOptionContext() {}

func NewModuleOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleOptionContext {
	var p = new(ModuleOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_moduleOption

	return p
}

func (s *ModuleOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleOptionContext) CopyFrom(ctx *ModuleOptionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ModuleOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type OptionExplicitStmtContext struct {
	*ModuleOptionContext
}

func NewOptionExplicitStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OptionExplicitStmtContext {
	var p = new(OptionExplicitStmtContext)

	p.ModuleOptionContext = NewEmptyModuleOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ModuleOptionContext))

	return p
}

func (s *OptionExplicitStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionExplicitStmtContext) OPTION_EXPLICIT() antlr.TerminalNode {
	return s.GetToken(vbaParserOPTION_EXPLICIT, 0)
}

func (s *OptionExplicitStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterOptionExplicitStmt(s)
	}
}

func (s *OptionExplicitStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitOptionExplicitStmt(s)
	}
}

type OptionBaseStmtContext struct {
	*ModuleOptionContext
}

func NewOptionBaseStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OptionBaseStmtContext {
	var p = new(OptionBaseStmtContext)

	p.ModuleOptionContext = NewEmptyModuleOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ModuleOptionContext))

	return p
}

func (s *OptionBaseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionBaseStmtContext) OPTION_BASE() antlr.TerminalNode {
	return s.GetToken(vbaParserOPTION_BASE, 0)
}

func (s *OptionBaseStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *OptionBaseStmtContext) SHORTLITERAL() antlr.TerminalNode {
	return s.GetToken(vbaParserSHORTLITERAL, 0)
}

func (s *OptionBaseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterOptionBaseStmt(s)
	}
}

func (s *OptionBaseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitOptionBaseStmt(s)
	}
}

type OptionPrivateModuleStmtContext struct {
	*ModuleOptionContext
}

func NewOptionPrivateModuleStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OptionPrivateModuleStmtContext {
	var p = new(OptionPrivateModuleStmtContext)

	p.ModuleOptionContext = NewEmptyModuleOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ModuleOptionContext))

	return p
}

func (s *OptionPrivateModuleStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionPrivateModuleStmtContext) OPTION_PRIVATE_MODULE() antlr.TerminalNode {
	return s.GetToken(vbaParserOPTION_PRIVATE_MODULE, 0)
}

func (s *OptionPrivateModuleStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterOptionPrivateModuleStmt(s)
	}
}

func (s *OptionPrivateModuleStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitOptionPrivateModuleStmt(s)
	}
}

type OptionCompareStmtContext struct {
	*ModuleOptionContext
}

func NewOptionCompareStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OptionCompareStmtContext {
	var p = new(OptionCompareStmtContext)

	p.ModuleOptionContext = NewEmptyModuleOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ModuleOptionContext))

	return p
}

func (s *OptionCompareStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionCompareStmtContext) OPTION_COMPARE() antlr.TerminalNode {
	return s.GetToken(vbaParserOPTION_COMPARE, 0)
}

func (s *OptionCompareStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *OptionCompareStmtContext) BINARY() antlr.TerminalNode {
	return s.GetToken(vbaParserBINARY, 0)
}

func (s *OptionCompareStmtContext) TEXT() antlr.TerminalNode {
	return s.GetToken(vbaParserTEXT, 0)
}

func (s *OptionCompareStmtContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(vbaParserDATABASE, 0)
}

func (s *OptionCompareStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterOptionCompareStmt(s)
	}
}

func (s *OptionCompareStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitOptionCompareStmt(s)
	}
}

func (p *vbaParser) ModuleOption() (localctx IModuleOptionContext) {
	this := p
	_ = this

	localctx = NewModuleOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, vbaParserRULE_moduleOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(426)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vbaParserOPTION_BASE:
		localctx = NewOptionBaseStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(418)
			p.Match(vbaParserOPTION_BASE)
		}
		{
			p.SetState(419)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(420)
			p.Match(vbaParserSHORTLITERAL)
		}

	case vbaParserOPTION_COMPARE:
		localctx = NewOptionCompareStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(421)
			p.Match(vbaParserOPTION_COMPARE)
		}
		{
			p.SetState(422)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(423)
			_la = p.GetTokenStream().LA(1)

			if !(_la == vbaParserBINARY || _la == vbaParserDATABASE || _la == vbaParserTEXT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case vbaParserOPTION_EXPLICIT:
		localctx = NewOptionExplicitStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(424)
			p.Match(vbaParserOPTION_EXPLICIT)
		}

	case vbaParserOPTION_PRIVATE_MODULE:
		localctx = NewOptionPrivateModuleStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(425)
			p.Match(vbaParserOPTION_PRIVATE_MODULE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModuleDeclarationsElementContext is an interface to support dynamic dispatch.
type IModuleDeclarationsElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleDeclarationsElementContext differentiates from other interfaces.
	IsModuleDeclarationsElementContext()
}

type ModuleDeclarationsElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDeclarationsElementContext() *ModuleDeclarationsElementContext {
	var p = new(ModuleDeclarationsElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_moduleDeclarationsElement
	return p
}

func (*ModuleDeclarationsElementContext) IsModuleDeclarationsElementContext() {}

func NewModuleDeclarationsElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDeclarationsElementContext {
	var p = new(ModuleDeclarationsElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_moduleDeclarationsElement

	return p
}

func (s *ModuleDeclarationsElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDeclarationsElementContext) Comment() ICommentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *ModuleDeclarationsElementContext) DeclareStmt() IDeclareStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclareStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclareStmtContext)
}

func (s *ModuleDeclarationsElementContext) EnumerationStmt() IEnumerationStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerationStmtContext)
}

func (s *ModuleDeclarationsElementContext) EventStmt() IEventStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEventStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEventStmtContext)
}

func (s *ModuleDeclarationsElementContext) ConstStmt() IConstStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstStmtContext)
}

func (s *ModuleDeclarationsElementContext) ImplementsStmt() IImplementsStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementsStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplementsStmtContext)
}

func (s *ModuleDeclarationsElementContext) VariableStmt() IVariableStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableStmtContext)
}

func (s *ModuleDeclarationsElementContext) ModuleOption() IModuleOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleOptionContext)
}

func (s *ModuleDeclarationsElementContext) TypeStmt() ITypeStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeStmtContext)
}

func (s *ModuleDeclarationsElementContext) MacroStmt() IMacroStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMacroStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMacroStmtContext)
}

func (s *ModuleDeclarationsElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDeclarationsElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDeclarationsElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterModuleDeclarationsElement(s)
	}
}

func (s *ModuleDeclarationsElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitModuleDeclarationsElement(s)
	}
}

func (p *vbaParser) ModuleDeclarationsElement() (localctx IModuleDeclarationsElementContext) {
	this := p
	_ = this

	localctx = NewModuleDeclarationsElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, vbaParserRULE_moduleDeclarationsElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(438)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(428)
			p.Comment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(429)
			p.DeclareStmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(430)
			p.EnumerationStmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(431)
			p.EventStmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(432)
			p.ConstStmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(433)
			p.ImplementsStmt()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(434)
			p.VariableStmt()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(435)
			p.ModuleOption()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(436)
			p.TypeStmt()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(437)
			p.MacroStmt()
		}

	}

	return localctx
}

// IMacroStmtContext is an interface to support dynamic dispatch.
type IMacroStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMacroStmtContext differentiates from other interfaces.
	IsMacroStmtContext()
}

type MacroStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacroStmtContext() *MacroStmtContext {
	var p = new(MacroStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_macroStmt
	return p
}

func (*MacroStmtContext) IsMacroStmtContext() {}

func NewMacroStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MacroStmtContext {
	var p = new(MacroStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_macroStmt

	return p
}

func (s *MacroStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *MacroStmtContext) MacroConstStmt() IMacroConstStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMacroConstStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMacroConstStmtContext)
}

func (s *MacroStmtContext) MacroIfThenElseStmt() IMacroIfThenElseStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMacroIfThenElseStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMacroIfThenElseStmtContext)
}

func (s *MacroStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MacroStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MacroStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterMacroStmt(s)
	}
}

func (s *MacroStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitMacroStmt(s)
	}
}

func (p *vbaParser) MacroStmt() (localctx IMacroStmtContext) {
	this := p
	_ = this

	localctx = NewMacroStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, vbaParserRULE_macroStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(442)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vbaParserMACRO_CONST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(440)
			p.MacroConstStmt()
		}

	case vbaParserMACRO_IF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(441)
			p.MacroIfThenElseStmt()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModuleBodyContext is an interface to support dynamic dispatch.
type IModuleBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleBodyContext differentiates from other interfaces.
	IsModuleBodyContext()
}

type ModuleBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleBodyContext() *ModuleBodyContext {
	var p = new(ModuleBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_moduleBody
	return p
}

func (*ModuleBodyContext) IsModuleBodyContext() {}

func NewModuleBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleBodyContext {
	var p = new(ModuleBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_moduleBody

	return p
}

func (s *ModuleBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleBodyContext) AllModuleBodyElement() []IModuleBodyElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleBodyElementContext)(nil)).Elem())
	var tst = make([]IModuleBodyElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleBodyElementContext)
		}
	}

	return tst
}

func (s *ModuleBodyContext) ModuleBodyElement(i int) IModuleBodyElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleBodyElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleBodyElementContext)
}

func (s *ModuleBodyContext) AllEndOfLine() []IEndOfLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEndOfLineContext)(nil)).Elem())
	var tst = make([]IEndOfLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEndOfLineContext)
		}
	}

	return tst
}

func (s *ModuleBodyContext) EndOfLine(i int) IEndOfLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEndOfLineContext)
}

func (s *ModuleBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterModuleBody(s)
	}
}

func (s *ModuleBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitModuleBody(s)
	}
}

func (p *vbaParser) ModuleBody() (localctx IModuleBodyContext) {
	this := p
	_ = this

	localctx = NewModuleBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, vbaParserRULE_moduleBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(444)
		p.ModuleBodyElement()
	}
	p.SetState(454)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(446)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(vbaParserNEWLINE-213))|(1<<(vbaParserREMCOMMENT-213))|(1<<(vbaParserCOMMENT-213))|(1<<(vbaParserWS-213)))) != 0) {
				{
					p.SetState(445)
					p.EndOfLine()
				}

				p.SetState(448)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(450)
				p.ModuleBodyElement()
			}

		}
		p.SetState(456)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(457)
				p.EndOfLine()
			}

		}
		p.SetState(462)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())
	}

	return localctx
}

// IModuleBodyElementContext is an interface to support dynamic dispatch.
type IModuleBodyElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleBodyElementContext differentiates from other interfaces.
	IsModuleBodyElementContext()
}

type ModuleBodyElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleBodyElementContext() *ModuleBodyElementContext {
	var p = new(ModuleBodyElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_moduleBodyElement
	return p
}

func (*ModuleBodyElementContext) IsModuleBodyElementContext() {}

func NewModuleBodyElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleBodyElementContext {
	var p = new(ModuleBodyElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_moduleBodyElement

	return p
}

func (s *ModuleBodyElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleBodyElementContext) FunctionStmt() IFunctionStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionStmtContext)
}

func (s *ModuleBodyElementContext) PropertyGetStmt() IPropertyGetStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyGetStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyGetStmtContext)
}

func (s *ModuleBodyElementContext) PropertySetStmt() IPropertySetStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertySetStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertySetStmtContext)
}

func (s *ModuleBodyElementContext) PropertyLetStmt() IPropertyLetStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyLetStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyLetStmtContext)
}

func (s *ModuleBodyElementContext) SubStmt() ISubStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubStmtContext)
}

func (s *ModuleBodyElementContext) MacroStmt() IMacroStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMacroStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMacroStmtContext)
}

func (s *ModuleBodyElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleBodyElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleBodyElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterModuleBodyElement(s)
	}
}

func (s *ModuleBodyElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitModuleBodyElement(s)
	}
}

func (p *vbaParser) ModuleBodyElement() (localctx IModuleBodyElementContext) {
	this := p
	_ = this

	localctx = NewModuleBodyElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, vbaParserRULE_moduleBodyElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(463)
			p.FunctionStmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(464)
			p.PropertyGetStmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(465)
			p.PropertySetStmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(466)
			p.PropertyLetStmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(467)
			p.SubStmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(468)
			p.MacroStmt()
		}

	}

	return localctx
}

// IAttributeStmtContext is an interface to support dynamic dispatch.
type IAttributeStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeStmtContext differentiates from other interfaces.
	IsAttributeStmtContext()
}

type AttributeStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeStmtContext() *AttributeStmtContext {
	var p = new(AttributeStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_attributeStmt
	return p
}

func (*AttributeStmtContext) IsAttributeStmtContext() {}

func NewAttributeStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeStmtContext {
	var p = new(AttributeStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_attributeStmt

	return p
}

func (s *AttributeStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeStmtContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(vbaParserATTRIBUTE, 0)
}

func (s *AttributeStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *AttributeStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *AttributeStmtContext) ImplicitCallStmt_InStmt() IImplicitCallStmt_InStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitCallStmt_InStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitCallStmt_InStmtContext)
}

func (s *AttributeStmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *AttributeStmtContext) AllLiteral() []ILiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralContext)(nil)).Elem())
	var tst = make([]ILiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralContext)
		}
	}

	return tst
}

func (s *AttributeStmtContext) Literal(i int) ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AttributeStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterAttributeStmt(s)
	}
}

func (s *AttributeStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitAttributeStmt(s)
	}
}

func (p *vbaParser) AttributeStmt() (localctx IAttributeStmtContext) {
	this := p
	_ = this

	localctx = NewAttributeStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, vbaParserRULE_attributeStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(471)
		p.Match(vbaParserATTRIBUTE)
	}
	{
		p.SetState(472)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(473)
		p.ImplicitCallStmt_InStmt()
	}
	p.SetState(475)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(474)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(477)
		p.Match(vbaParserEQ)
	}
	p.SetState(479)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(478)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(481)
		p.Literal()
	}
	p.SetState(492)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(483)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(482)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(485)
				p.Match(vbaParserT__0)
			}
			p.SetState(487)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(486)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(489)
				p.Literal()
			}

		}
		p.SetState(494)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())
	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllBlockStmt() []IBlockStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockStmtContext)(nil)).Elem())
	var tst = make([]IBlockStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockStmtContext)
		}
	}

	return tst
}

func (s *BlockContext) BlockStmt(i int) IBlockStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockStmtContext)
}

func (s *BlockContext) AllEndOfStatement() []IEndOfStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem())
	var tst = make([]IEndOfStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEndOfStatementContext)
		}
	}

	return tst
}

func (s *BlockContext) EndOfStatement(i int) IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *vbaParser) Block() (localctx IBlockContext) {
	this := p
	_ = this

	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, vbaParserRULE_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(495)
		p.BlockStmt()
	}
	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(496)
				p.EndOfStatement()
			}
			{
				p.SetState(497)
				p.BlockStmt()
			}

		}
		p.SetState(503)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())
	}
	{
		p.SetState(504)
		p.EndOfStatement()
	}

	return localctx
}

// IBlockStmtContext is an interface to support dynamic dispatch.
type IBlockStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStmtContext differentiates from other interfaces.
	IsBlockStmtContext()
}

type BlockStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStmtContext() *BlockStmtContext {
	var p = new(BlockStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_blockStmt
	return p
}

func (*BlockStmtContext) IsBlockStmtContext() {}

func NewBlockStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStmtContext {
	var p = new(BlockStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_blockStmt

	return p
}

func (s *BlockStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStmtContext) LineLabel() ILineLabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineLabelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineLabelContext)
}

func (s *BlockStmtContext) AppactivateStmt() IAppactivateStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAppactivateStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAppactivateStmtContext)
}

func (s *BlockStmtContext) AttributeStmt() IAttributeStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeStmtContext)
}

func (s *BlockStmtContext) BeepStmt() IBeepStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBeepStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBeepStmtContext)
}

func (s *BlockStmtContext) ChdirStmt() IChdirStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChdirStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChdirStmtContext)
}

func (s *BlockStmtContext) ChdriveStmt() IChdriveStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChdriveStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChdriveStmtContext)
}

func (s *BlockStmtContext) CloseStmt() ICloseStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICloseStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICloseStmtContext)
}

func (s *BlockStmtContext) ConstStmt() IConstStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstStmtContext)
}

func (s *BlockStmtContext) DateStmt() IDateStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDateStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDateStmtContext)
}

func (s *BlockStmtContext) DeleteSettingStmt() IDeleteSettingStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeleteSettingStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeleteSettingStmtContext)
}

func (s *BlockStmtContext) DeftypeStmt() IDeftypeStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeftypeStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeftypeStmtContext)
}

func (s *BlockStmtContext) DoLoopStmt() IDoLoopStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoLoopStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoLoopStmtContext)
}

func (s *BlockStmtContext) EndStmt() IEndStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndStmtContext)
}

func (s *BlockStmtContext) EraseStmt() IEraseStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEraseStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEraseStmtContext)
}

func (s *BlockStmtContext) ErrorStmt() IErrorStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IErrorStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IErrorStmtContext)
}

func (s *BlockStmtContext) ExitStmt() IExitStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExitStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExitStmtContext)
}

func (s *BlockStmtContext) ExplicitCallStmt() IExplicitCallStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicitCallStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicitCallStmtContext)
}

func (s *BlockStmtContext) FilecopyStmt() IFilecopyStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilecopyStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilecopyStmtContext)
}

func (s *BlockStmtContext) ForEachStmt() IForEachStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForEachStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForEachStmtContext)
}

func (s *BlockStmtContext) ForNextStmt() IForNextStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForNextStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForNextStmtContext)
}

func (s *BlockStmtContext) GetStmt() IGetStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGetStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGetStmtContext)
}

func (s *BlockStmtContext) GoSubStmt() IGoSubStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoSubStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoSubStmtContext)
}

func (s *BlockStmtContext) GoToStmt() IGoToStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoToStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoToStmtContext)
}

func (s *BlockStmtContext) IfThenElseStmt() IIfThenElseStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfThenElseStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfThenElseStmtContext)
}

func (s *BlockStmtContext) ImplementsStmt() IImplementsStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementsStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplementsStmtContext)
}

func (s *BlockStmtContext) InputStmt() IInputStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInputStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInputStmtContext)
}

func (s *BlockStmtContext) KillStmt() IKillStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKillStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKillStmtContext)
}

func (s *BlockStmtContext) LetStmt() ILetStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILetStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILetStmtContext)
}

func (s *BlockStmtContext) LineInputStmt() ILineInputStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineInputStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineInputStmtContext)
}

func (s *BlockStmtContext) LoadStmt() ILoadStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoadStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoadStmtContext)
}

func (s *BlockStmtContext) LockStmt() ILockStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILockStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILockStmtContext)
}

func (s *BlockStmtContext) LsetStmt() ILsetStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILsetStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILsetStmtContext)
}

func (s *BlockStmtContext) MacroStmt() IMacroStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMacroStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMacroStmtContext)
}

func (s *BlockStmtContext) MidStmt() IMidStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMidStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMidStmtContext)
}

func (s *BlockStmtContext) MkdirStmt() IMkdirStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMkdirStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMkdirStmtContext)
}

func (s *BlockStmtContext) NameStmt() INameStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameStmtContext)
}

func (s *BlockStmtContext) OnErrorStmt() IOnErrorStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnErrorStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnErrorStmtContext)
}

func (s *BlockStmtContext) OnGoToStmt() IOnGoToStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnGoToStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnGoToStmtContext)
}

func (s *BlockStmtContext) OnGoSubStmt() IOnGoSubStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnGoSubStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnGoSubStmtContext)
}

func (s *BlockStmtContext) OpenStmt() IOpenStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOpenStmtContext)
}

func (s *BlockStmtContext) PrintStmt() IPrintStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrintStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrintStmtContext)
}

func (s *BlockStmtContext) PutStmt() IPutStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPutStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPutStmtContext)
}

func (s *BlockStmtContext) RaiseEventStmt() IRaiseEventStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaiseEventStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaiseEventStmtContext)
}

func (s *BlockStmtContext) RandomizeStmt() IRandomizeStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRandomizeStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRandomizeStmtContext)
}

func (s *BlockStmtContext) RedimStmt() IRedimStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRedimStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRedimStmtContext)
}

func (s *BlockStmtContext) ResetStmt() IResetStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResetStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IResetStmtContext)
}

func (s *BlockStmtContext) ResumeStmt() IResumeStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResumeStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IResumeStmtContext)
}

func (s *BlockStmtContext) ReturnStmt() IReturnStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnStmtContext)
}

func (s *BlockStmtContext) RmdirStmt() IRmdirStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRmdirStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRmdirStmtContext)
}

func (s *BlockStmtContext) RsetStmt() IRsetStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRsetStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRsetStmtContext)
}

func (s *BlockStmtContext) SavepictureStmt() ISavepictureStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISavepictureStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISavepictureStmtContext)
}

func (s *BlockStmtContext) SaveSettingStmt() ISaveSettingStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISaveSettingStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISaveSettingStmtContext)
}

func (s *BlockStmtContext) SeekStmt() ISeekStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeekStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeekStmtContext)
}

func (s *BlockStmtContext) SelectCaseStmt() ISelectCaseStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectCaseStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectCaseStmtContext)
}

func (s *BlockStmtContext) SendkeysStmt() ISendkeysStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendkeysStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendkeysStmtContext)
}

func (s *BlockStmtContext) SetattrStmt() ISetattrStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetattrStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetattrStmtContext)
}

func (s *BlockStmtContext) SetStmt() ISetStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetStmtContext)
}

func (s *BlockStmtContext) StopStmt() IStopStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStopStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStopStmtContext)
}

func (s *BlockStmtContext) TimeStmt() ITimeStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeStmtContext)
}

func (s *BlockStmtContext) UnloadStmt() IUnloadStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnloadStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnloadStmtContext)
}

func (s *BlockStmtContext) UnlockStmt() IUnlockStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnlockStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnlockStmtContext)
}

func (s *BlockStmtContext) VariableStmt() IVariableStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableStmtContext)
}

func (s *BlockStmtContext) WhileWendStmt() IWhileWendStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhileWendStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhileWendStmtContext)
}

func (s *BlockStmtContext) WidthStmt() IWidthStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWidthStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWidthStmtContext)
}

func (s *BlockStmtContext) WithStmt() IWithStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithStmtContext)
}

func (s *BlockStmtContext) WriteStmt() IWriteStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteStmtContext)
}

func (s *BlockStmtContext) ImplicitCallStmt_InBlock() IImplicitCallStmt_InBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitCallStmt_InBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitCallStmt_InBlockContext)
}

func (s *BlockStmtContext) ImplicitCallStmt_InStmt() IImplicitCallStmt_InStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitCallStmt_InStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitCallStmt_InStmtContext)
}

func (s *BlockStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterBlockStmt(s)
	}
}

func (s *BlockStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitBlockStmt(s)
	}
}

func (p *vbaParser) BlockStmt() (localctx IBlockStmtContext) {
	this := p
	_ = this

	localctx = NewBlockStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, vbaParserRULE_blockStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(506)
			p.LineLabel()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(507)
			p.AppactivateStmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(508)
			p.AttributeStmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(509)
			p.BeepStmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(510)
			p.ChdirStmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(511)
			p.ChdriveStmt()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(512)
			p.CloseStmt()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(513)
			p.ConstStmt()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(514)
			p.DateStmt()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(515)
			p.DeleteSettingStmt()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(516)
			p.DeftypeStmt()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(517)
			p.DoLoopStmt()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(518)
			p.EndStmt()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(519)
			p.EraseStmt()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(520)
			p.ErrorStmt()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(521)
			p.ExitStmt()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(522)
			p.ExplicitCallStmt()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(523)
			p.FilecopyStmt()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(524)
			p.ForEachStmt()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(525)
			p.ForNextStmt()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(526)
			p.GetStmt()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(527)
			p.GoSubStmt()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(528)
			p.GoToStmt()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(529)
			p.IfThenElseStmt()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(530)
			p.ImplementsStmt()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(531)
			p.InputStmt()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(532)
			p.KillStmt()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(533)
			p.LetStmt()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(534)
			p.LineInputStmt()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(535)
			p.LoadStmt()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(536)
			p.LockStmt()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(537)
			p.LsetStmt()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(538)
			p.MacroStmt()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(539)
			p.MidStmt()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(540)
			p.MkdirStmt()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(541)
			p.NameStmt()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(542)
			p.OnErrorStmt()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(543)
			p.OnGoToStmt()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(544)
			p.OnGoSubStmt()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(545)
			p.OpenStmt()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(546)
			p.PrintStmt()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(547)
			p.PutStmt()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(548)
			p.RaiseEventStmt()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(549)
			p.RandomizeStmt()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(550)
			p.RedimStmt()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(551)
			p.ResetStmt()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(552)
			p.ResumeStmt()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(553)
			p.ReturnStmt()
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(554)
			p.RmdirStmt()
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(555)
			p.RsetStmt()
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(556)
			p.SavepictureStmt()
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(557)
			p.SaveSettingStmt()
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(558)
			p.SeekStmt()
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(559)
			p.SelectCaseStmt()
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(560)
			p.SendkeysStmt()
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(561)
			p.SetattrStmt()
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(562)
			p.SetStmt()
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(563)
			p.StopStmt()
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(564)
			p.TimeStmt()
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(565)
			p.UnloadStmt()
		}

	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(566)
			p.UnlockStmt()
		}

	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(567)
			p.VariableStmt()
		}

	case 63:
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(568)
			p.WhileWendStmt()
		}

	case 64:
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(569)
			p.WidthStmt()
		}

	case 65:
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(570)
			p.WithStmt()
		}

	case 66:
		p.EnterOuterAlt(localctx, 66)
		{
			p.SetState(571)
			p.WriteStmt()
		}

	case 67:
		p.EnterOuterAlt(localctx, 67)
		{
			p.SetState(572)
			p.ImplicitCallStmt_InBlock()
		}

	case 68:
		p.EnterOuterAlt(localctx, 68)
		{
			p.SetState(573)
			p.ImplicitCallStmt_InStmt()
		}

	}

	return localctx
}

// IAppactivateStmtContext is an interface to support dynamic dispatch.
type IAppactivateStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAppactivateStmtContext differentiates from other interfaces.
	IsAppactivateStmtContext()
}

type AppactivateStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAppactivateStmtContext() *AppactivateStmtContext {
	var p = new(AppactivateStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_appactivateStmt
	return p
}

func (*AppactivateStmtContext) IsAppactivateStmtContext() {}

func NewAppactivateStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AppactivateStmtContext {
	var p = new(AppactivateStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_appactivateStmt

	return p
}

func (s *AppactivateStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AppactivateStmtContext) APPACTIVATE() antlr.TerminalNode {
	return s.GetToken(vbaParserAPPACTIVATE, 0)
}

func (s *AppactivateStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *AppactivateStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *AppactivateStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *AppactivateStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *AppactivateStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AppactivateStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AppactivateStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterAppactivateStmt(s)
	}
}

func (s *AppactivateStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitAppactivateStmt(s)
	}
}

func (p *vbaParser) AppactivateStmt() (localctx IAppactivateStmtContext) {
	this := p
	_ = this

	localctx = NewAppactivateStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, vbaParserRULE_appactivateStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(576)
		p.Match(vbaParserAPPACTIVATE)
	}
	{
		p.SetState(577)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(578)
		p.valueStmt(0)
	}
	p.SetState(587)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
		p.SetState(580)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(579)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(582)
			p.Match(vbaParserT__0)
		}
		p.SetState(584)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(583)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(586)
			p.valueStmt(0)
		}

	}

	return localctx
}

// IBeepStmtContext is an interface to support dynamic dispatch.
type IBeepStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBeepStmtContext differentiates from other interfaces.
	IsBeepStmtContext()
}

type BeepStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeepStmtContext() *BeepStmtContext {
	var p = new(BeepStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_beepStmt
	return p
}

func (*BeepStmtContext) IsBeepStmtContext() {}

func NewBeepStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeepStmtContext {
	var p = new(BeepStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_beepStmt

	return p
}

func (s *BeepStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *BeepStmtContext) BEEP() antlr.TerminalNode {
	return s.GetToken(vbaParserBEEP, 0)
}

func (s *BeepStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeepStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeepStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterBeepStmt(s)
	}
}

func (s *BeepStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitBeepStmt(s)
	}
}

func (p *vbaParser) BeepStmt() (localctx IBeepStmtContext) {
	this := p
	_ = this

	localctx = NewBeepStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, vbaParserRULE_beepStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(589)
		p.Match(vbaParserBEEP)
	}

	return localctx
}

// IChdirStmtContext is an interface to support dynamic dispatch.
type IChdirStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChdirStmtContext differentiates from other interfaces.
	IsChdirStmtContext()
}

type ChdirStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChdirStmtContext() *ChdirStmtContext {
	var p = new(ChdirStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_chdirStmt
	return p
}

func (*ChdirStmtContext) IsChdirStmtContext() {}

func NewChdirStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChdirStmtContext {
	var p = new(ChdirStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_chdirStmt

	return p
}

func (s *ChdirStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ChdirStmtContext) CHDIR() antlr.TerminalNode {
	return s.GetToken(vbaParserCHDIR, 0)
}

func (s *ChdirStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *ChdirStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *ChdirStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChdirStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChdirStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterChdirStmt(s)
	}
}

func (s *ChdirStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitChdirStmt(s)
	}
}

func (p *vbaParser) ChdirStmt() (localctx IChdirStmtContext) {
	this := p
	_ = this

	localctx = NewChdirStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, vbaParserRULE_chdirStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(591)
		p.Match(vbaParserCHDIR)
	}
	{
		p.SetState(592)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(593)
		p.valueStmt(0)
	}

	return localctx
}

// IChdriveStmtContext is an interface to support dynamic dispatch.
type IChdriveStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChdriveStmtContext differentiates from other interfaces.
	IsChdriveStmtContext()
}

type ChdriveStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChdriveStmtContext() *ChdriveStmtContext {
	var p = new(ChdriveStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_chdriveStmt
	return p
}

func (*ChdriveStmtContext) IsChdriveStmtContext() {}

func NewChdriveStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChdriveStmtContext {
	var p = new(ChdriveStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_chdriveStmt

	return p
}

func (s *ChdriveStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ChdriveStmtContext) CHDRIVE() antlr.TerminalNode {
	return s.GetToken(vbaParserCHDRIVE, 0)
}

func (s *ChdriveStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *ChdriveStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *ChdriveStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChdriveStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChdriveStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterChdriveStmt(s)
	}
}

func (s *ChdriveStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitChdriveStmt(s)
	}
}

func (p *vbaParser) ChdriveStmt() (localctx IChdriveStmtContext) {
	this := p
	_ = this

	localctx = NewChdriveStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, vbaParserRULE_chdriveStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(595)
		p.Match(vbaParserCHDRIVE)
	}
	{
		p.SetState(596)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(597)
		p.valueStmt(0)
	}

	return localctx
}

// ICloseStmtContext is an interface to support dynamic dispatch.
type ICloseStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCloseStmtContext differentiates from other interfaces.
	IsCloseStmtContext()
}

type CloseStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloseStmtContext() *CloseStmtContext {
	var p = new(CloseStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_closeStmt
	return p
}

func (*CloseStmtContext) IsCloseStmtContext() {}

func NewCloseStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloseStmtContext {
	var p = new(CloseStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_closeStmt

	return p
}

func (s *CloseStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CloseStmtContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(vbaParserCLOSE, 0)
}

func (s *CloseStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *CloseStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *CloseStmtContext) AllFileNumber() []IFileNumberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileNumberContext)(nil)).Elem())
	var tst = make([]IFileNumberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileNumberContext)
		}
	}

	return tst
}

func (s *CloseStmtContext) FileNumber(i int) IFileNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNumberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileNumberContext)
}

func (s *CloseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterCloseStmt(s)
	}
}

func (s *CloseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitCloseStmt(s)
	}
}

func (p *vbaParser) CloseStmt() (localctx ICloseStmtContext) {
	this := p
	_ = this

	localctx = NewCloseStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, vbaParserRULE_closeStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(599)
		p.Match(vbaParserCLOSE)
	}
	p.SetState(615)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(600)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(601)
			p.FileNumber()
		}
		p.SetState(612)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(603)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(602)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(605)
					p.Match(vbaParserT__0)
				}
				p.SetState(607)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(606)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(609)
					p.FileNumber()
				}

			}
			p.SetState(614)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IConstStmtContext is an interface to support dynamic dispatch.
type IConstStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstStmtContext differentiates from other interfaces.
	IsConstStmtContext()
}

type ConstStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstStmtContext() *ConstStmtContext {
	var p = new(ConstStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_constStmt
	return p
}

func (*ConstStmtContext) IsConstStmtContext() {}

func NewConstStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstStmtContext {
	var p = new(ConstStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_constStmt

	return p
}

func (s *ConstStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstStmtContext) CONST() antlr.TerminalNode {
	return s.GetToken(vbaParserCONST, 0)
}

func (s *ConstStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ConstStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ConstStmtContext) AllConstSubStmt() []IConstSubStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstSubStmtContext)(nil)).Elem())
	var tst = make([]IConstSubStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstSubStmtContext)
		}
	}

	return tst
}

func (s *ConstStmtContext) ConstSubStmt(i int) IConstSubStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstSubStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstSubStmtContext)
}

func (s *ConstStmtContext) Visibility() IVisibilityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibilityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *ConstStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterConstStmt(s)
	}
}

func (s *ConstStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitConstStmt(s)
	}
}

func (p *vbaParser) ConstStmt() (localctx IConstStmtContext) {
	this := p
	_ = this

	localctx = NewConstStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, vbaParserRULE_constStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(620)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserFRIEND || _la == vbaParserGLOBAL || _la == vbaParserPRIVATE || _la == vbaParserPUBLIC {
		{
			p.SetState(617)
			p.Visibility()
		}
		{
			p.SetState(618)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(622)
		p.Match(vbaParserCONST)
	}
	{
		p.SetState(623)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(624)
		p.ConstSubStmt()
	}
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(626)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(625)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(628)
				p.Match(vbaParserT__0)
			}
			p.SetState(630)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(629)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(632)
				p.ConstSubStmt()
			}

		}
		p.SetState(637)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())
	}

	return localctx
}

// IConstSubStmtContext is an interface to support dynamic dispatch.
type IConstSubStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstSubStmtContext differentiates from other interfaces.
	IsConstSubStmtContext()
}

type ConstSubStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstSubStmtContext() *ConstSubStmtContext {
	var p = new(ConstSubStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_constSubStmt
	return p
}

func (*ConstSubStmtContext) IsConstSubStmtContext() {}

func NewConstSubStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstSubStmtContext {
	var p = new(ConstSubStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_constSubStmt

	return p
}

func (s *ConstSubStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstSubStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *ConstSubStmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *ConstSubStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *ConstSubStmtContext) TypeHint() ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *ConstSubStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ConstSubStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ConstSubStmtContext) AsTypeClause() IAsTypeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsTypeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsTypeClauseContext)
}

func (s *ConstSubStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstSubStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstSubStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterConstSubStmt(s)
	}
}

func (s *ConstSubStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitConstSubStmt(s)
	}
}

func (p *vbaParser) ConstSubStmt() (localctx IConstSubStmtContext) {
	this := p
	_ = this

	localctx = NewConstSubStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, vbaParserRULE_constSubStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(638)
		p.AmbiguousIdentifier()
	}
	p.SetState(640)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__2)|(1<<vbaParserT__4)|(1<<vbaParserT__5)|(1<<vbaParserT__6)|(1<<vbaParserT__7))) != 0) || _la == vbaParserAMPERSAND {
		{
			p.SetState(639)
			p.TypeHint()
		}

	}
	p.SetState(644)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(642)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(643)
			p.AsTypeClause()
		}

	}
	p.SetState(647)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(646)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(649)
		p.Match(vbaParserEQ)
	}
	p.SetState(651)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(650)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(653)
		p.valueStmt(0)
	}

	return localctx
}

// IDateStmtContext is an interface to support dynamic dispatch.
type IDateStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDateStmtContext differentiates from other interfaces.
	IsDateStmtContext()
}

type DateStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateStmtContext() *DateStmtContext {
	var p = new(DateStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_dateStmt
	return p
}

func (*DateStmtContext) IsDateStmtContext() {}

func NewDateStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateStmtContext {
	var p = new(DateStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_dateStmt

	return p
}

func (s *DateStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DateStmtContext) DATE() antlr.TerminalNode {
	return s.GetToken(vbaParserDATE, 0)
}

func (s *DateStmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *DateStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *DateStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *DateStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *DateStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterDateStmt(s)
	}
}

func (s *DateStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitDateStmt(s)
	}
}

func (p *vbaParser) DateStmt() (localctx IDateStmtContext) {
	this := p
	_ = this

	localctx = NewDateStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, vbaParserRULE_dateStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(655)
		p.Match(vbaParserDATE)
	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(656)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(659)
		p.Match(vbaParserEQ)
	}
	p.SetState(661)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(660)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(663)
		p.valueStmt(0)
	}

	return localctx
}

// IDeclareStmtContext is an interface to support dynamic dispatch.
type IDeclareStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclareStmtContext differentiates from other interfaces.
	IsDeclareStmtContext()
}

type DeclareStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareStmtContext() *DeclareStmtContext {
	var p = new(DeclareStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_declareStmt
	return p
}

func (*DeclareStmtContext) IsDeclareStmtContext() {}

func NewDeclareStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareStmtContext {
	var p = new(DeclareStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_declareStmt

	return p
}

func (s *DeclareStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareStmtContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(vbaParserDECLARE, 0)
}

func (s *DeclareStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *DeclareStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *DeclareStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *DeclareStmtContext) LIB() antlr.TerminalNode {
	return s.GetToken(vbaParserLIB, 0)
}

func (s *DeclareStmtContext) AllSTRINGLITERAL() []antlr.TerminalNode {
	return s.GetTokens(vbaParserSTRINGLITERAL)
}

func (s *DeclareStmtContext) STRINGLITERAL(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserSTRINGLITERAL, i)
}

func (s *DeclareStmtContext) SUB() antlr.TerminalNode {
	return s.GetToken(vbaParserSUB, 0)
}

func (s *DeclareStmtContext) Visibility() IVisibilityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibilityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *DeclareStmtContext) PTRSAFE() antlr.TerminalNode {
	return s.GetToken(vbaParserPTRSAFE, 0)
}

func (s *DeclareStmtContext) AllTypeHint() []ITypeHintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeHintContext)(nil)).Elem())
	var tst = make([]ITypeHintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeHintContext)
		}
	}

	return tst
}

func (s *DeclareStmtContext) TypeHint(i int) ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *DeclareStmtContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(vbaParserALIAS, 0)
}

func (s *DeclareStmtContext) ArgList() IArgListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgListContext)
}

func (s *DeclareStmtContext) AsTypeClause() IAsTypeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsTypeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsTypeClauseContext)
}

func (s *DeclareStmtContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(vbaParserFUNCTION, 0)
}

func (s *DeclareStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterDeclareStmt(s)
	}
}

func (s *DeclareStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitDeclareStmt(s)
	}
}

func (p *vbaParser) DeclareStmt() (localctx IDeclareStmtContext) {
	this := p
	_ = this

	localctx = NewDeclareStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, vbaParserRULE_declareStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserFRIEND || _la == vbaParserGLOBAL || _la == vbaParserPRIVATE || _la == vbaParserPUBLIC {
		{
			p.SetState(665)
			p.Visibility()
		}
		{
			p.SetState(666)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(670)
		p.Match(vbaParserDECLARE)
	}
	{
		p.SetState(671)
		p.Match(vbaParserWS)
	}
	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserPTRSAFE {
		{
			p.SetState(672)
			p.Match(vbaParserPTRSAFE)
		}
		{
			p.SetState(673)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(681)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vbaParserFUNCTION:
		{
			p.SetState(676)
			p.Match(vbaParserFUNCTION)
		}
		p.SetState(678)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__2)|(1<<vbaParserT__4)|(1<<vbaParserT__5)|(1<<vbaParserT__6)|(1<<vbaParserT__7))) != 0) || _la == vbaParserAMPERSAND {
			{
				p.SetState(677)
				p.TypeHint()
			}

		}

	case vbaParserSUB:
		{
			p.SetState(680)
			p.Match(vbaParserSUB)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(683)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(684)
		p.AmbiguousIdentifier()
	}
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__2)|(1<<vbaParserT__4)|(1<<vbaParserT__5)|(1<<vbaParserT__6)|(1<<vbaParserT__7))) != 0) || _la == vbaParserAMPERSAND {
		{
			p.SetState(685)
			p.TypeHint()
		}

	}
	{
		p.SetState(688)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(689)
		p.Match(vbaParserLIB)
	}
	{
		p.SetState(690)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(691)
		p.Match(vbaParserSTRINGLITERAL)
	}
	p.SetState(696)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(692)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(693)
			p.Match(vbaParserALIAS)
		}
		{
			p.SetState(694)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(695)
			p.Match(vbaParserSTRINGLITERAL)
		}

	}
	p.SetState(702)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
		p.SetState(699)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(698)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(701)
			p.ArgList()
		}

	}
	p.SetState(706)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(704)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(705)
			p.AsTypeClause()
		}

	}

	return localctx
}

// IDeftypeStmtContext is an interface to support dynamic dispatch.
type IDeftypeStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeftypeStmtContext differentiates from other interfaces.
	IsDeftypeStmtContext()
}

type DeftypeStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeftypeStmtContext() *DeftypeStmtContext {
	var p = new(DeftypeStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_deftypeStmt
	return p
}

func (*DeftypeStmtContext) IsDeftypeStmtContext() {}

func NewDeftypeStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeftypeStmtContext {
	var p = new(DeftypeStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_deftypeStmt

	return p
}

func (s *DeftypeStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DeftypeStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *DeftypeStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *DeftypeStmtContext) AllLetterrange() []ILetterrangeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILetterrangeContext)(nil)).Elem())
	var tst = make([]ILetterrangeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILetterrangeContext)
		}
	}

	return tst
}

func (s *DeftypeStmtContext) Letterrange(i int) ILetterrangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILetterrangeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILetterrangeContext)
}

func (s *DeftypeStmtContext) DEFBOOL() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFBOOL, 0)
}

func (s *DeftypeStmtContext) DEFBYTE() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFBYTE, 0)
}

func (s *DeftypeStmtContext) DEFINT() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFINT, 0)
}

func (s *DeftypeStmtContext) DEFLNG() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFLNG, 0)
}

func (s *DeftypeStmtContext) DEFCUR() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFCUR, 0)
}

func (s *DeftypeStmtContext) DEFSNG() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFSNG, 0)
}

func (s *DeftypeStmtContext) DEFDBL() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFDBL, 0)
}

func (s *DeftypeStmtContext) DEFDEC() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFDEC, 0)
}

func (s *DeftypeStmtContext) DEFDATE() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFDATE, 0)
}

func (s *DeftypeStmtContext) DEFSTR() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFSTR, 0)
}

func (s *DeftypeStmtContext) DEFOBJ() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFOBJ, 0)
}

func (s *DeftypeStmtContext) DEFVAR() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFVAR, 0)
}

func (s *DeftypeStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeftypeStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeftypeStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterDeftypeStmt(s)
	}
}

func (s *DeftypeStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitDeftypeStmt(s)
	}
}

func (p *vbaParser) DeftypeStmt() (localctx IDeftypeStmtContext) {
	this := p
	_ = this

	localctx = NewDeftypeStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, vbaParserRULE_deftypeStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(708)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(vbaParserDEFBOOL-35))|(1<<(vbaParserDEFBYTE-35))|(1<<(vbaParserDEFDATE-35))|(1<<(vbaParserDEFDBL-35))|(1<<(vbaParserDEFDEC-35))|(1<<(vbaParserDEFCUR-35))|(1<<(vbaParserDEFINT-35))|(1<<(vbaParserDEFLNG-35))|(1<<(vbaParserDEFOBJ-35))|(1<<(vbaParserDEFSNG-35))|(1<<(vbaParserDEFSTR-35))|(1<<(vbaParserDEFVAR-35)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(709)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(710)
		p.Letterrange()
	}
	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(712)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(711)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(714)
				p.Match(vbaParserT__0)
			}
			p.SetState(716)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(715)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(718)
				p.Letterrange()
			}

		}
		p.SetState(723)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())
	}

	return localctx
}

// IDeleteSettingStmtContext is an interface to support dynamic dispatch.
type IDeleteSettingStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeleteSettingStmtContext differentiates from other interfaces.
	IsDeleteSettingStmtContext()
}

type DeleteSettingStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteSettingStmtContext() *DeleteSettingStmtContext {
	var p = new(DeleteSettingStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_deleteSettingStmt
	return p
}

func (*DeleteSettingStmtContext) IsDeleteSettingStmtContext() {}

func NewDeleteSettingStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteSettingStmtContext {
	var p = new(DeleteSettingStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_deleteSettingStmt

	return p
}

func (s *DeleteSettingStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteSettingStmtContext) DELETESETTING() antlr.TerminalNode {
	return s.GetToken(vbaParserDELETESETTING, 0)
}

func (s *DeleteSettingStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *DeleteSettingStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *DeleteSettingStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *DeleteSettingStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *DeleteSettingStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteSettingStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteSettingStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterDeleteSettingStmt(s)
	}
}

func (s *DeleteSettingStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitDeleteSettingStmt(s)
	}
}

func (p *vbaParser) DeleteSettingStmt() (localctx IDeleteSettingStmtContext) {
	this := p
	_ = this

	localctx = NewDeleteSettingStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, vbaParserRULE_deleteSettingStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(724)
		p.Match(vbaParserDELETESETTING)
	}
	{
		p.SetState(725)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(726)
		p.valueStmt(0)
	}
	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(727)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(730)
		p.Match(vbaParserT__0)
	}
	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(731)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(734)
		p.valueStmt(0)
	}
	p.SetState(743)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(735)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(738)
			p.Match(vbaParserT__0)
		}
		p.SetState(740)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(739)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(742)
			p.valueStmt(0)
		}

	}

	return localctx
}

// IDoLoopStmtContext is an interface to support dynamic dispatch.
type IDoLoopStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoLoopStmtContext differentiates from other interfaces.
	IsDoLoopStmtContext()
}

type DoLoopStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoLoopStmtContext() *DoLoopStmtContext {
	var p = new(DoLoopStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_doLoopStmt
	return p
}

func (*DoLoopStmtContext) IsDoLoopStmtContext() {}

func NewDoLoopStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoLoopStmtContext {
	var p = new(DoLoopStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_doLoopStmt

	return p
}

func (s *DoLoopStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DoLoopStmtContext) DO() antlr.TerminalNode {
	return s.GetToken(vbaParserDO, 0)
}

func (s *DoLoopStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *DoLoopStmtContext) LOOP() antlr.TerminalNode {
	return s.GetToken(vbaParserLOOP, 0)
}

func (s *DoLoopStmtContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *DoLoopStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *DoLoopStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *DoLoopStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *DoLoopStmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(vbaParserWHILE, 0)
}

func (s *DoLoopStmtContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(vbaParserUNTIL, 0)
}

func (s *DoLoopStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoLoopStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoLoopStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterDoLoopStmt(s)
	}
}

func (s *DoLoopStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitDoLoopStmt(s)
	}
}

func (p *vbaParser) DoLoopStmt() (localctx IDoLoopStmtContext) {
	this := p
	_ = this

	localctx = NewDoLoopStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, vbaParserRULE_doLoopStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(772)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(745)
			p.Match(vbaParserDO)
		}
		{
			p.SetState(746)
			p.EndOfStatement()
		}
		p.SetState(748)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(747)
				p.Block()
			}

		}
		{
			p.SetState(750)
			p.Match(vbaParserLOOP)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(752)
			p.Match(vbaParserDO)
		}
		{
			p.SetState(753)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(754)
			_la = p.GetTokenStream().LA(1)

			if !(_la == vbaParserUNTIL || _la == vbaParserWHILE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(755)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(756)
			p.valueStmt(0)
		}
		{
			p.SetState(757)
			p.EndOfStatement()
		}
		p.SetState(759)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(758)
				p.Block()
			}

		}
		{
			p.SetState(761)
			p.Match(vbaParserLOOP)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(763)
			p.Match(vbaParserDO)
		}
		{
			p.SetState(764)
			p.EndOfStatement()
		}
		{
			p.SetState(765)
			p.Block()
		}
		{
			p.SetState(766)
			p.Match(vbaParserLOOP)
		}
		{
			p.SetState(767)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(768)
			_la = p.GetTokenStream().LA(1)

			if !(_la == vbaParserUNTIL || _la == vbaParserWHILE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(769)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(770)
			p.valueStmt(0)
		}

	}

	return localctx
}

// IEndStmtContext is an interface to support dynamic dispatch.
type IEndStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndStmtContext differentiates from other interfaces.
	IsEndStmtContext()
}

type EndStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndStmtContext() *EndStmtContext {
	var p = new(EndStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_endStmt
	return p
}

func (*EndStmtContext) IsEndStmtContext() {}

func NewEndStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndStmtContext {
	var p = new(EndStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_endStmt

	return p
}

func (s *EndStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *EndStmtContext) END() antlr.TerminalNode {
	return s.GetToken(vbaParserEND, 0)
}

func (s *EndStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterEndStmt(s)
	}
}

func (s *EndStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitEndStmt(s)
	}
}

func (p *vbaParser) EndStmt() (localctx IEndStmtContext) {
	this := p
	_ = this

	localctx = NewEndStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, vbaParserRULE_endStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(774)
		p.Match(vbaParserEND)
	}

	return localctx
}

// IEnumerationStmtContext is an interface to support dynamic dispatch.
type IEnumerationStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerationStmtContext differentiates from other interfaces.
	IsEnumerationStmtContext()
}

type EnumerationStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerationStmtContext() *EnumerationStmtContext {
	var p = new(EnumerationStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_enumerationStmt
	return p
}

func (*EnumerationStmtContext) IsEnumerationStmtContext() {}

func NewEnumerationStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumerationStmtContext {
	var p = new(EnumerationStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_enumerationStmt

	return p
}

func (s *EnumerationStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumerationStmtContext) ENUM() antlr.TerminalNode {
	return s.GetToken(vbaParserENUM, 0)
}

func (s *EnumerationStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *EnumerationStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *EnumerationStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *EnumerationStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *EnumerationStmtContext) END_ENUM() antlr.TerminalNode {
	return s.GetToken(vbaParserEND_ENUM, 0)
}

func (s *EnumerationStmtContext) Visibility() IVisibilityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibilityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *EnumerationStmtContext) AllEnumerationStmt_Constant() []IEnumerationStmt_ConstantContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumerationStmt_ConstantContext)(nil)).Elem())
	var tst = make([]IEnumerationStmt_ConstantContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumerationStmt_ConstantContext)
		}
	}

	return tst
}

func (s *EnumerationStmtContext) EnumerationStmt_Constant(i int) IEnumerationStmt_ConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationStmt_ConstantContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumerationStmt_ConstantContext)
}

func (s *EnumerationStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumerationStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumerationStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterEnumerationStmt(s)
	}
}

func (s *EnumerationStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitEnumerationStmt(s)
	}
}

func (p *vbaParser) EnumerationStmt() (localctx IEnumerationStmtContext) {
	this := p
	_ = this

	localctx = NewEnumerationStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, vbaParserRULE_enumerationStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(779)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserFRIEND || _la == vbaParserGLOBAL || _la == vbaParserPRIVATE || _la == vbaParserPUBLIC {
		{
			p.SetState(776)
			p.Visibility()
		}
		{
			p.SetState(777)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(781)
		p.Match(vbaParserENUM)
	}
	{
		p.SetState(782)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(783)
		p.AmbiguousIdentifier()
	}
	{
		p.SetState(784)
		p.EndOfStatement()
	}
	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || _la == vbaParserIDENTIFIER {
		{
			p.SetState(785)
			p.EnumerationStmt_Constant()
		}

		p.SetState(790)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(791)
		p.Match(vbaParserEND_ENUM)
	}

	return localctx
}

// IEnumerationStmt_ConstantContext is an interface to support dynamic dispatch.
type IEnumerationStmt_ConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerationStmt_ConstantContext differentiates from other interfaces.
	IsEnumerationStmt_ConstantContext()
}

type EnumerationStmt_ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerationStmt_ConstantContext() *EnumerationStmt_ConstantContext {
	var p = new(EnumerationStmt_ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_enumerationStmt_Constant
	return p
}

func (*EnumerationStmt_ConstantContext) IsEnumerationStmt_ConstantContext() {}

func NewEnumerationStmt_ConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumerationStmt_ConstantContext {
	var p = new(EnumerationStmt_ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_enumerationStmt_Constant

	return p
}

func (s *EnumerationStmt_ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumerationStmt_ConstantContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *EnumerationStmt_ConstantContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *EnumerationStmt_ConstantContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *EnumerationStmt_ConstantContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *EnumerationStmt_ConstantContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *EnumerationStmt_ConstantContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *EnumerationStmt_ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumerationStmt_ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumerationStmt_ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterEnumerationStmt_Constant(s)
	}
}

func (s *EnumerationStmt_ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitEnumerationStmt_Constant(s)
	}
}

func (p *vbaParser) EnumerationStmt_Constant() (localctx IEnumerationStmt_ConstantContext) {
	this := p
	_ = this

	localctx = NewEnumerationStmt_ConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, vbaParserRULE_enumerationStmt_Constant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(793)
		p.AmbiguousIdentifier()
	}
	p.SetState(802)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
		p.SetState(795)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(794)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(797)
			p.Match(vbaParserEQ)
		}
		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(798)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(801)
			p.valueStmt(0)
		}

	}
	{
		p.SetState(804)
		p.EndOfStatement()
	}

	return localctx
}

// IEraseStmtContext is an interface to support dynamic dispatch.
type IEraseStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEraseStmtContext differentiates from other interfaces.
	IsEraseStmtContext()
}

type EraseStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEraseStmtContext() *EraseStmtContext {
	var p = new(EraseStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_eraseStmt
	return p
}

func (*EraseStmtContext) IsEraseStmtContext() {}

func NewEraseStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EraseStmtContext {
	var p = new(EraseStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_eraseStmt

	return p
}

func (s *EraseStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *EraseStmtContext) ERASE() antlr.TerminalNode {
	return s.GetToken(vbaParserERASE, 0)
}

func (s *EraseStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *EraseStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *EraseStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *EraseStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *EraseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EraseStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EraseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterEraseStmt(s)
	}
}

func (s *EraseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitEraseStmt(s)
	}
}

func (p *vbaParser) EraseStmt() (localctx IEraseStmtContext) {
	this := p
	_ = this

	localctx = NewEraseStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, vbaParserRULE_eraseStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(806)
		p.Match(vbaParserERASE)
	}
	{
		p.SetState(807)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(808)
		p.valueStmt(0)
	}
	p.SetState(816)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())

	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(809)
				p.Match(vbaParserT__0)
			}
			p.SetState(811)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(810)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(813)
				p.valueStmt(0)
			}

		}
		p.SetState(818)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())
	}

	return localctx
}

// IErrorStmtContext is an interface to support dynamic dispatch.
type IErrorStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsErrorStmtContext differentiates from other interfaces.
	IsErrorStmtContext()
}

type ErrorStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorStmtContext() *ErrorStmtContext {
	var p = new(ErrorStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_errorStmt
	return p
}

func (*ErrorStmtContext) IsErrorStmtContext() {}

func NewErrorStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorStmtContext {
	var p = new(ErrorStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_errorStmt

	return p
}

func (s *ErrorStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorStmtContext) ERROR() antlr.TerminalNode {
	return s.GetToken(vbaParserERROR, 0)
}

func (s *ErrorStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *ErrorStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *ErrorStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterErrorStmt(s)
	}
}

func (s *ErrorStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitErrorStmt(s)
	}
}

func (p *vbaParser) ErrorStmt() (localctx IErrorStmtContext) {
	this := p
	_ = this

	localctx = NewErrorStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, vbaParserRULE_errorStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(819)
		p.Match(vbaParserERROR)
	}
	{
		p.SetState(820)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(821)
		p.valueStmt(0)
	}

	return localctx
}

// IEventStmtContext is an interface to support dynamic dispatch.
type IEventStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEventStmtContext differentiates from other interfaces.
	IsEventStmtContext()
}

type EventStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventStmtContext() *EventStmtContext {
	var p = new(EventStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_eventStmt
	return p
}

func (*EventStmtContext) IsEventStmtContext() {}

func NewEventStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventStmtContext {
	var p = new(EventStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_eventStmt

	return p
}

func (s *EventStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *EventStmtContext) EVENT() antlr.TerminalNode {
	return s.GetToken(vbaParserEVENT, 0)
}

func (s *EventStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *EventStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *EventStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *EventStmtContext) ArgList() IArgListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgListContext)
}

func (s *EventStmtContext) Visibility() IVisibilityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibilityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *EventStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterEventStmt(s)
	}
}

func (s *EventStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitEventStmt(s)
	}
}

func (p *vbaParser) EventStmt() (localctx IEventStmtContext) {
	this := p
	_ = this

	localctx = NewEventStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, vbaParserRULE_eventStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(826)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserFRIEND || _la == vbaParserGLOBAL || _la == vbaParserPRIVATE || _la == vbaParserPUBLIC {
		{
			p.SetState(823)
			p.Visibility()
		}
		{
			p.SetState(824)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(828)
		p.Match(vbaParserEVENT)
	}
	{
		p.SetState(829)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(830)
		p.AmbiguousIdentifier()
	}
	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(831)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(834)
		p.ArgList()
	}

	return localctx
}

// IExitStmtContext is an interface to support dynamic dispatch.
type IExitStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExitStmtContext differentiates from other interfaces.
	IsExitStmtContext()
}

type ExitStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExitStmtContext() *ExitStmtContext {
	var p = new(ExitStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_exitStmt
	return p
}

func (*ExitStmtContext) IsExitStmtContext() {}

func NewExitStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExitStmtContext {
	var p = new(ExitStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_exitStmt

	return p
}

func (s *ExitStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExitStmtContext) EXIT_DO() antlr.TerminalNode {
	return s.GetToken(vbaParserEXIT_DO, 0)
}

func (s *ExitStmtContext) EXIT_FOR() antlr.TerminalNode {
	return s.GetToken(vbaParserEXIT_FOR, 0)
}

func (s *ExitStmtContext) EXIT_FUNCTION() antlr.TerminalNode {
	return s.GetToken(vbaParserEXIT_FUNCTION, 0)
}

func (s *ExitStmtContext) EXIT_PROPERTY() antlr.TerminalNode {
	return s.GetToken(vbaParserEXIT_PROPERTY, 0)
}

func (s *ExitStmtContext) EXIT_SUB() antlr.TerminalNode {
	return s.GetToken(vbaParserEXIT_SUB, 0)
}

func (s *ExitStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExitStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExitStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterExitStmt(s)
	}
}

func (s *ExitStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitExitStmt(s)
	}
}

func (p *vbaParser) ExitStmt() (localctx IExitStmtContext) {
	this := p
	_ = this

	localctx = NewExitStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, vbaParserRULE_exitStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(836)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vbaParserEXIT_DO-68))|(1<<(vbaParserEXIT_FOR-68))|(1<<(vbaParserEXIT_FUNCTION-68))|(1<<(vbaParserEXIT_PROPERTY-68))|(1<<(vbaParserEXIT_SUB-68)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFilecopyStmtContext is an interface to support dynamic dispatch.
type IFilecopyStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilecopyStmtContext differentiates from other interfaces.
	IsFilecopyStmtContext()
}

type FilecopyStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilecopyStmtContext() *FilecopyStmtContext {
	var p = new(FilecopyStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_filecopyStmt
	return p
}

func (*FilecopyStmtContext) IsFilecopyStmtContext() {}

func NewFilecopyStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilecopyStmtContext {
	var p = new(FilecopyStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_filecopyStmt

	return p
}

func (s *FilecopyStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *FilecopyStmtContext) FILECOPY() antlr.TerminalNode {
	return s.GetToken(vbaParserFILECOPY, 0)
}

func (s *FilecopyStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *FilecopyStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *FilecopyStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *FilecopyStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *FilecopyStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilecopyStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilecopyStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterFilecopyStmt(s)
	}
}

func (s *FilecopyStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitFilecopyStmt(s)
	}
}

func (p *vbaParser) FilecopyStmt() (localctx IFilecopyStmtContext) {
	this := p
	_ = this

	localctx = NewFilecopyStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, vbaParserRULE_filecopyStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(838)
		p.Match(vbaParserFILECOPY)
	}
	{
		p.SetState(839)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(840)
		p.valueStmt(0)
	}
	p.SetState(842)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(841)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(844)
		p.Match(vbaParserT__0)
	}
	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(845)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(848)
		p.valueStmt(0)
	}

	return localctx
}

// IForEachStmtContext is an interface to support dynamic dispatch.
type IForEachStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForEachStmtContext differentiates from other interfaces.
	IsForEachStmtContext()
}

type ForEachStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForEachStmtContext() *ForEachStmtContext {
	var p = new(ForEachStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_forEachStmt
	return p
}

func (*ForEachStmtContext) IsForEachStmtContext() {}

func NewForEachStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForEachStmtContext {
	var p = new(ForEachStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_forEachStmt

	return p
}

func (s *ForEachStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ForEachStmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(vbaParserFOR, 0)
}

func (s *ForEachStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ForEachStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ForEachStmtContext) EACH() antlr.TerminalNode {
	return s.GetToken(vbaParserEACH, 0)
}

func (s *ForEachStmtContext) AllAmbiguousIdentifier() []IAmbiguousIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem())
	var tst = make([]IAmbiguousIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAmbiguousIdentifierContext)
		}
	}

	return tst
}

func (s *ForEachStmtContext) AmbiguousIdentifier(i int) IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *ForEachStmtContext) IN() antlr.TerminalNode {
	return s.GetToken(vbaParserIN, 0)
}

func (s *ForEachStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *ForEachStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *ForEachStmtContext) NEXT() antlr.TerminalNode {
	return s.GetToken(vbaParserNEXT, 0)
}

func (s *ForEachStmtContext) TypeHint() ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *ForEachStmtContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ForEachStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForEachStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForEachStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterForEachStmt(s)
	}
}

func (s *ForEachStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitForEachStmt(s)
	}
}

func (p *vbaParser) ForEachStmt() (localctx IForEachStmtContext) {
	this := p
	_ = this

	localctx = NewForEachStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, vbaParserRULE_forEachStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.Match(vbaParserFOR)
	}
	{
		p.SetState(851)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(852)
		p.Match(vbaParserEACH)
	}
	{
		p.SetState(853)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(854)
		p.AmbiguousIdentifier()
	}
	p.SetState(856)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__2)|(1<<vbaParserT__4)|(1<<vbaParserT__5)|(1<<vbaParserT__6)|(1<<vbaParserT__7))) != 0) || _la == vbaParserAMPERSAND {
		{
			p.SetState(855)
			p.TypeHint()
		}

	}
	{
		p.SetState(858)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(859)
		p.Match(vbaParserIN)
	}
	{
		p.SetState(860)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(861)
		p.valueStmt(0)
	}
	{
		p.SetState(862)
		p.EndOfStatement()
	}
	p.SetState(864)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(863)
			p.Block()
		}

	}
	{
		p.SetState(866)
		p.Match(vbaParserNEXT)
	}
	p.SetState(869)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(867)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(868)
			p.AmbiguousIdentifier()
		}

	}

	return localctx
}

// IForNextStmtContext is an interface to support dynamic dispatch.
type IForNextStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForNextStmtContext differentiates from other interfaces.
	IsForNextStmtContext()
}

type ForNextStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForNextStmtContext() *ForNextStmtContext {
	var p = new(ForNextStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_forNextStmt
	return p
}

func (*ForNextStmtContext) IsForNextStmtContext() {}

func NewForNextStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForNextStmtContext {
	var p = new(ForNextStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_forNextStmt

	return p
}

func (s *ForNextStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ForNextStmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(vbaParserFOR, 0)
}

func (s *ForNextStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ForNextStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ForNextStmtContext) AllAmbiguousIdentifier() []IAmbiguousIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem())
	var tst = make([]IAmbiguousIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAmbiguousIdentifierContext)
		}
	}

	return tst
}

func (s *ForNextStmtContext) AmbiguousIdentifier(i int) IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *ForNextStmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *ForNextStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *ForNextStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *ForNextStmtContext) TO() antlr.TerminalNode {
	return s.GetToken(vbaParserTO, 0)
}

func (s *ForNextStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *ForNextStmtContext) NEXT() antlr.TerminalNode {
	return s.GetToken(vbaParserNEXT, 0)
}

func (s *ForNextStmtContext) TypeHint() ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *ForNextStmtContext) AsTypeClause() IAsTypeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsTypeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsTypeClauseContext)
}

func (s *ForNextStmtContext) STEP() antlr.TerminalNode {
	return s.GetToken(vbaParserSTEP, 0)
}

func (s *ForNextStmtContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ForNextStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForNextStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForNextStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterForNextStmt(s)
	}
}

func (s *ForNextStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitForNextStmt(s)
	}
}

func (p *vbaParser) ForNextStmt() (localctx IForNextStmtContext) {
	this := p
	_ = this

	localctx = NewForNextStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, vbaParserRULE_forNextStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(871)
		p.Match(vbaParserFOR)
	}
	{
		p.SetState(872)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(873)
		p.AmbiguousIdentifier()
	}
	p.SetState(875)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__2)|(1<<vbaParserT__4)|(1<<vbaParserT__5)|(1<<vbaParserT__6)|(1<<vbaParserT__7))) != 0) || _la == vbaParserAMPERSAND {
		{
			p.SetState(874)
			p.TypeHint()
		}

	}
	p.SetState(879)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(877)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(878)
			p.AsTypeClause()
		}

	}
	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(881)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(884)
		p.Match(vbaParserEQ)
	}
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(885)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(888)
		p.valueStmt(0)
	}
	{
		p.SetState(889)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(890)
		p.Match(vbaParserTO)
	}
	{
		p.SetState(891)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(892)
		p.valueStmt(0)
	}
	p.SetState(897)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(893)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(894)
			p.Match(vbaParserSTEP)
		}
		{
			p.SetState(895)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(896)
			p.valueStmt(0)
		}

	}
	{
		p.SetState(899)
		p.EndOfStatement()
	}
	p.SetState(901)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(900)
			p.Block()
		}

	}
	{
		p.SetState(903)
		p.Match(vbaParserNEXT)
	}
	p.SetState(906)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(904)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(905)
			p.AmbiguousIdentifier()
		}

	}

	return localctx
}

// IFunctionStmtContext is an interface to support dynamic dispatch.
type IFunctionStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionStmtContext differentiates from other interfaces.
	IsFunctionStmtContext()
}

type FunctionStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionStmtContext() *FunctionStmtContext {
	var p = new(FunctionStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_functionStmt
	return p
}

func (*FunctionStmtContext) IsFunctionStmtContext() {}

func NewFunctionStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionStmtContext {
	var p = new(FunctionStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_functionStmt

	return p
}

func (s *FunctionStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionStmtContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(vbaParserFUNCTION, 0)
}

func (s *FunctionStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *FunctionStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *FunctionStmtContext) END_FUNCTION() antlr.TerminalNode {
	return s.GetToken(vbaParserEND_FUNCTION, 0)
}

func (s *FunctionStmtContext) Visibility() IVisibilityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibilityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *FunctionStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *FunctionStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *FunctionStmtContext) STATIC() antlr.TerminalNode {
	return s.GetToken(vbaParserSTATIC, 0)
}

func (s *FunctionStmtContext) TypeHint() ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *FunctionStmtContext) ArgList() IArgListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgListContext)
}

func (s *FunctionStmtContext) AsTypeClause() IAsTypeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsTypeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsTypeClauseContext)
}

func (s *FunctionStmtContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterFunctionStmt(s)
	}
}

func (s *FunctionStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitFunctionStmt(s)
	}
}

func (p *vbaParser) FunctionStmt() (localctx IFunctionStmtContext) {
	this := p
	_ = this

	localctx = NewFunctionStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, vbaParserRULE_functionStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(911)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserFRIEND || _la == vbaParserGLOBAL || _la == vbaParserPRIVATE || _la == vbaParserPUBLIC {
		{
			p.SetState(908)
			p.Visibility()
		}
		{
			p.SetState(909)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserSTATIC {
		{
			p.SetState(913)
			p.Match(vbaParserSTATIC)
		}
		{
			p.SetState(914)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(917)
		p.Match(vbaParserFUNCTION)
	}
	p.SetState(919)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(918)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(921)
		p.AmbiguousIdentifier()
	}
	p.SetState(923)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(922)
			p.TypeHint()
		}

	}
	p.SetState(929)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) == 1 {
		p.SetState(926)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(925)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(928)
			p.ArgList()
		}

	}
	p.SetState(935)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		p.SetState(932)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(931)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(934)
			p.AsTypeClause()
		}

	}
	{
		p.SetState(937)
		p.EndOfStatement()
	}
	p.SetState(939)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserEXIT_DO-64))|(1<<(vbaParserEXIT_FOR-64))|(1<<(vbaParserEXIT_FUNCTION-64))|(1<<(vbaParserEXIT_PROPERTY-64))|(1<<(vbaParserEXIT_SUB-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLINE_INPUT-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserMACRO_CONST-96))|(1<<(vbaParserMACRO_IF-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserON_ERROR-96))|(1<<(vbaParserON_LOCAL_ERROR-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || _la == vbaParserIDENTIFIER {
		{
			p.SetState(938)
			p.Block()
		}

	}
	{
		p.SetState(941)
		p.Match(vbaParserEND_FUNCTION)
	}

	return localctx
}

// IGetStmtContext is an interface to support dynamic dispatch.
type IGetStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGetStmtContext differentiates from other interfaces.
	IsGetStmtContext()
}

type GetStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetStmtContext() *GetStmtContext {
	var p = new(GetStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_getStmt
	return p
}

func (*GetStmtContext) IsGetStmtContext() {}

func NewGetStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetStmtContext {
	var p = new(GetStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_getStmt

	return p
}

func (s *GetStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GetStmtContext) GET() antlr.TerminalNode {
	return s.GetToken(vbaParserGET, 0)
}

func (s *GetStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *GetStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *GetStmtContext) FileNumber() IFileNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNumberContext)
}

func (s *GetStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *GetStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *GetStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterGetStmt(s)
	}
}

func (s *GetStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitGetStmt(s)
	}
}

func (p *vbaParser) GetStmt() (localctx IGetStmtContext) {
	this := p
	_ = this

	localctx = NewGetStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, vbaParserRULE_getStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(943)
		p.Match(vbaParserGET)
	}
	{
		p.SetState(944)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(945)
		p.FileNumber()
	}
	p.SetState(947)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(946)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(949)
		p.Match(vbaParserT__0)
	}
	p.SetState(951)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(950)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(954)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || (((_la-193)&-(0x1f+1)) == 0 && ((1<<uint((_la-193)))&((1<<(vbaParserLPAREN-193))|(1<<(vbaParserMINUS-193))|(1<<(vbaParserPLUS-193))|(1<<(vbaParserSTRINGLITERAL-193))|(1<<(vbaParserOCTLITERAL-193))|(1<<(vbaParserHEXLITERAL-193))|(1<<(vbaParserSHORTLITERAL-193))|(1<<(vbaParserINTEGERLITERAL-193))|(1<<(vbaParserDOUBLELITERAL-193))|(1<<(vbaParserDATELITERAL-193))|(1<<(vbaParserIDENTIFIER-193)))) != 0) {
		{
			p.SetState(953)
			p.valueStmt(0)
		}

	}
	p.SetState(957)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(956)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(959)
		p.Match(vbaParserT__0)
	}
	p.SetState(961)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(960)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(963)
		p.valueStmt(0)
	}

	return localctx
}

// IGoSubStmtContext is an interface to support dynamic dispatch.
type IGoSubStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoSubStmtContext differentiates from other interfaces.
	IsGoSubStmtContext()
}

type GoSubStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoSubStmtContext() *GoSubStmtContext {
	var p = new(GoSubStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_goSubStmt
	return p
}

func (*GoSubStmtContext) IsGoSubStmtContext() {}

func NewGoSubStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoSubStmtContext {
	var p = new(GoSubStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_goSubStmt

	return p
}

func (s *GoSubStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GoSubStmtContext) GOSUB() antlr.TerminalNode {
	return s.GetToken(vbaParserGOSUB, 0)
}

func (s *GoSubStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *GoSubStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *GoSubStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoSubStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoSubStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterGoSubStmt(s)
	}
}

func (s *GoSubStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitGoSubStmt(s)
	}
}

func (p *vbaParser) GoSubStmt() (localctx IGoSubStmtContext) {
	this := p
	_ = this

	localctx = NewGoSubStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, vbaParserRULE_goSubStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(965)
		p.Match(vbaParserGOSUB)
	}
	{
		p.SetState(966)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(967)
		p.valueStmt(0)
	}

	return localctx
}

// IGoToStmtContext is an interface to support dynamic dispatch.
type IGoToStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoToStmtContext differentiates from other interfaces.
	IsGoToStmtContext()
}

type GoToStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoToStmtContext() *GoToStmtContext {
	var p = new(GoToStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_goToStmt
	return p
}

func (*GoToStmtContext) IsGoToStmtContext() {}

func NewGoToStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoToStmtContext {
	var p = new(GoToStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_goToStmt

	return p
}

func (s *GoToStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GoToStmtContext) GOTO() antlr.TerminalNode {
	return s.GetToken(vbaParserGOTO, 0)
}

func (s *GoToStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *GoToStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *GoToStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoToStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoToStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterGoToStmt(s)
	}
}

func (s *GoToStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitGoToStmt(s)
	}
}

func (p *vbaParser) GoToStmt() (localctx IGoToStmtContext) {
	this := p
	_ = this

	localctx = NewGoToStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, vbaParserRULE_goToStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(969)
		p.Match(vbaParserGOTO)
	}
	{
		p.SetState(970)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(971)
		p.valueStmt(0)
	}

	return localctx
}

// IIfThenElseStmtContext is an interface to support dynamic dispatch.
type IIfThenElseStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfThenElseStmtContext differentiates from other interfaces.
	IsIfThenElseStmtContext()
}

type IfThenElseStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfThenElseStmtContext() *IfThenElseStmtContext {
	var p = new(IfThenElseStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_ifThenElseStmt
	return p
}

func (*IfThenElseStmtContext) IsIfThenElseStmtContext() {}

func NewIfThenElseStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfThenElseStmtContext {
	var p = new(IfThenElseStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_ifThenElseStmt

	return p
}

func (s *IfThenElseStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfThenElseStmtContext) CopyFrom(ctx *IfThenElseStmtContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IfThenElseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfThenElseStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BlockIfThenElseContext struct {
	*IfThenElseStmtContext
}

func NewBlockIfThenElseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BlockIfThenElseContext {
	var p = new(BlockIfThenElseContext)

	p.IfThenElseStmtContext = NewEmptyIfThenElseStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IfThenElseStmtContext))

	return p
}

func (s *BlockIfThenElseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockIfThenElseContext) IfBlockStmt() IIfBlockStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfBlockStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfBlockStmtContext)
}

func (s *BlockIfThenElseContext) END_IF() antlr.TerminalNode {
	return s.GetToken(vbaParserEND_IF, 0)
}

func (s *BlockIfThenElseContext) AllIfElseIfBlockStmt() []IIfElseIfBlockStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIfElseIfBlockStmtContext)(nil)).Elem())
	var tst = make([]IIfElseIfBlockStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIfElseIfBlockStmtContext)
		}
	}

	return tst
}

func (s *BlockIfThenElseContext) IfElseIfBlockStmt(i int) IIfElseIfBlockStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfElseIfBlockStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIfElseIfBlockStmtContext)
}

func (s *BlockIfThenElseContext) IfElseBlockStmt() IIfElseBlockStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfElseBlockStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfElseBlockStmtContext)
}

func (s *BlockIfThenElseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterBlockIfThenElse(s)
	}
}

func (s *BlockIfThenElseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitBlockIfThenElse(s)
	}
}

type InlineIfThenElseContext struct {
	*IfThenElseStmtContext
}

func NewInlineIfThenElseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineIfThenElseContext {
	var p = new(InlineIfThenElseContext)

	p.IfThenElseStmtContext = NewEmptyIfThenElseStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IfThenElseStmtContext))

	return p
}

func (s *InlineIfThenElseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineIfThenElseContext) IF() antlr.TerminalNode {
	return s.GetToken(vbaParserIF, 0)
}

func (s *InlineIfThenElseContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *InlineIfThenElseContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *InlineIfThenElseContext) IfConditionStmt() IIfConditionStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfConditionStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfConditionStmtContext)
}

func (s *InlineIfThenElseContext) THEN() antlr.TerminalNode {
	return s.GetToken(vbaParserTHEN, 0)
}

func (s *InlineIfThenElseContext) AllBlockStmt() []IBlockStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockStmtContext)(nil)).Elem())
	var tst = make([]IBlockStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockStmtContext)
		}
	}

	return tst
}

func (s *InlineIfThenElseContext) BlockStmt(i int) IBlockStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockStmtContext)
}

func (s *InlineIfThenElseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(vbaParserELSE, 0)
}

func (s *InlineIfThenElseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterInlineIfThenElse(s)
	}
}

func (s *InlineIfThenElseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitInlineIfThenElse(s)
	}
}

func (p *vbaParser) IfThenElseStmt() (localctx IIfThenElseStmtContext) {
	this := p
	_ = this

	localctx = NewIfThenElseStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, vbaParserRULE_ifThenElseStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(998)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		localctx = NewInlineIfThenElseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(973)
			p.Match(vbaParserIF)
		}
		{
			p.SetState(974)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(975)
			p.IfConditionStmt()
		}
		{
			p.SetState(976)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(977)
			p.Match(vbaParserTHEN)
		}
		{
			p.SetState(978)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(979)
			p.BlockStmt()
		}
		p.SetState(984)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(980)
				p.Match(vbaParserWS)
			}
			{
				p.SetState(981)
				p.Match(vbaParserELSE)
			}
			{
				p.SetState(982)
				p.Match(vbaParserWS)
			}
			{
				p.SetState(983)
				p.BlockStmt()
			}

		}

	case 2:
		localctx = NewBlockIfThenElseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(986)
			p.IfBlockStmt()
		}
		p.SetState(990)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == vbaParserELSEIF {
			{
				p.SetState(987)
				p.IfElseIfBlockStmt()
			}

			p.SetState(992)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(994)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserELSE {
			{
				p.SetState(993)
				p.IfElseBlockStmt()
			}

		}
		{
			p.SetState(996)
			p.Match(vbaParserEND_IF)
		}

	}

	return localctx
}

// IIfBlockStmtContext is an interface to support dynamic dispatch.
type IIfBlockStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfBlockStmtContext differentiates from other interfaces.
	IsIfBlockStmtContext()
}

type IfBlockStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfBlockStmtContext() *IfBlockStmtContext {
	var p = new(IfBlockStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_ifBlockStmt
	return p
}

func (*IfBlockStmtContext) IsIfBlockStmtContext() {}

func NewIfBlockStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfBlockStmtContext {
	var p = new(IfBlockStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_ifBlockStmt

	return p
}

func (s *IfBlockStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfBlockStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(vbaParserIF, 0)
}

func (s *IfBlockStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *IfBlockStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *IfBlockStmtContext) IfConditionStmt() IIfConditionStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfConditionStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfConditionStmtContext)
}

func (s *IfBlockStmtContext) THEN() antlr.TerminalNode {
	return s.GetToken(vbaParserTHEN, 0)
}

func (s *IfBlockStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *IfBlockStmtContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *IfBlockStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfBlockStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfBlockStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterIfBlockStmt(s)
	}
}

func (s *IfBlockStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitIfBlockStmt(s)
	}
}

func (p *vbaParser) IfBlockStmt() (localctx IIfBlockStmtContext) {
	this := p
	_ = this

	localctx = NewIfBlockStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, vbaParserRULE_ifBlockStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1000)
		p.Match(vbaParserIF)
	}
	{
		p.SetState(1001)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1002)
		p.IfConditionStmt()
	}
	{
		p.SetState(1003)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1004)
		p.Match(vbaParserTHEN)
	}
	{
		p.SetState(1005)
		p.EndOfStatement()
	}
	p.SetState(1007)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1006)
			p.Block()
		}

	}

	return localctx
}

// IIfConditionStmtContext is an interface to support dynamic dispatch.
type IIfConditionStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfConditionStmtContext differentiates from other interfaces.
	IsIfConditionStmtContext()
}

type IfConditionStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfConditionStmtContext() *IfConditionStmtContext {
	var p = new(IfConditionStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_ifConditionStmt
	return p
}

func (*IfConditionStmtContext) IsIfConditionStmtContext() {}

func NewIfConditionStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfConditionStmtContext {
	var p = new(IfConditionStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_ifConditionStmt

	return p
}

func (s *IfConditionStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfConditionStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *IfConditionStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfConditionStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfConditionStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterIfConditionStmt(s)
	}
}

func (s *IfConditionStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitIfConditionStmt(s)
	}
}

func (p *vbaParser) IfConditionStmt() (localctx IIfConditionStmtContext) {
	this := p
	_ = this

	localctx = NewIfConditionStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, vbaParserRULE_ifConditionStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1009)
		p.valueStmt(0)
	}

	return localctx
}

// IIfElseIfBlockStmtContext is an interface to support dynamic dispatch.
type IIfElseIfBlockStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfElseIfBlockStmtContext differentiates from other interfaces.
	IsIfElseIfBlockStmtContext()
}

type IfElseIfBlockStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfElseIfBlockStmtContext() *IfElseIfBlockStmtContext {
	var p = new(IfElseIfBlockStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_ifElseIfBlockStmt
	return p
}

func (*IfElseIfBlockStmtContext) IsIfElseIfBlockStmtContext() {}

func NewIfElseIfBlockStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfElseIfBlockStmtContext {
	var p = new(IfElseIfBlockStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_ifElseIfBlockStmt

	return p
}

func (s *IfElseIfBlockStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfElseIfBlockStmtContext) ELSEIF() antlr.TerminalNode {
	return s.GetToken(vbaParserELSEIF, 0)
}

func (s *IfElseIfBlockStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *IfElseIfBlockStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *IfElseIfBlockStmtContext) IfConditionStmt() IIfConditionStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfConditionStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfConditionStmtContext)
}

func (s *IfElseIfBlockStmtContext) THEN() antlr.TerminalNode {
	return s.GetToken(vbaParserTHEN, 0)
}

func (s *IfElseIfBlockStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *IfElseIfBlockStmtContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *IfElseIfBlockStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfElseIfBlockStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfElseIfBlockStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterIfElseIfBlockStmt(s)
	}
}

func (s *IfElseIfBlockStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitIfElseIfBlockStmt(s)
	}
}

func (p *vbaParser) IfElseIfBlockStmt() (localctx IIfElseIfBlockStmtContext) {
	this := p
	_ = this

	localctx = NewIfElseIfBlockStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, vbaParserRULE_ifElseIfBlockStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1011)
		p.Match(vbaParserELSEIF)
	}
	{
		p.SetState(1012)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1013)
		p.IfConditionStmt()
	}
	{
		p.SetState(1014)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1015)
		p.Match(vbaParserTHEN)
	}
	{
		p.SetState(1016)
		p.EndOfStatement()
	}
	p.SetState(1018)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1017)
			p.Block()
		}

	}

	return localctx
}

// IIfElseBlockStmtContext is an interface to support dynamic dispatch.
type IIfElseBlockStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfElseBlockStmtContext differentiates from other interfaces.
	IsIfElseBlockStmtContext()
}

type IfElseBlockStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfElseBlockStmtContext() *IfElseBlockStmtContext {
	var p = new(IfElseBlockStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_ifElseBlockStmt
	return p
}

func (*IfElseBlockStmtContext) IsIfElseBlockStmtContext() {}

func NewIfElseBlockStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfElseBlockStmtContext {
	var p = new(IfElseBlockStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_ifElseBlockStmt

	return p
}

func (s *IfElseBlockStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfElseBlockStmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(vbaParserELSE, 0)
}

func (s *IfElseBlockStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *IfElseBlockStmtContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *IfElseBlockStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfElseBlockStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfElseBlockStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterIfElseBlockStmt(s)
	}
}

func (s *IfElseBlockStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitIfElseBlockStmt(s)
	}
}

func (p *vbaParser) IfElseBlockStmt() (localctx IIfElseBlockStmtContext) {
	this := p
	_ = this

	localctx = NewIfElseBlockStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, vbaParserRULE_ifElseBlockStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1020)
		p.Match(vbaParserELSE)
	}
	{
		p.SetState(1021)
		p.EndOfStatement()
	}
	p.SetState(1023)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserEXIT_DO-64))|(1<<(vbaParserEXIT_FOR-64))|(1<<(vbaParserEXIT_FUNCTION-64))|(1<<(vbaParserEXIT_PROPERTY-64))|(1<<(vbaParserEXIT_SUB-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLINE_INPUT-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserMACRO_CONST-96))|(1<<(vbaParserMACRO_IF-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserON_ERROR-96))|(1<<(vbaParserON_LOCAL_ERROR-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || _la == vbaParserIDENTIFIER {
		{
			p.SetState(1022)
			p.Block()
		}

	}

	return localctx
}

// IImplementsStmtContext is an interface to support dynamic dispatch.
type IImplementsStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplementsStmtContext differentiates from other interfaces.
	IsImplementsStmtContext()
}

type ImplementsStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementsStmtContext() *ImplementsStmtContext {
	var p = new(ImplementsStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_implementsStmt
	return p
}

func (*ImplementsStmtContext) IsImplementsStmtContext() {}

func NewImplementsStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementsStmtContext {
	var p = new(ImplementsStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_implementsStmt

	return p
}

func (s *ImplementsStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementsStmtContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(vbaParserIMPLEMENTS, 0)
}

func (s *ImplementsStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *ImplementsStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *ImplementsStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementsStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementsStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterImplementsStmt(s)
	}
}

func (s *ImplementsStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitImplementsStmt(s)
	}
}

func (p *vbaParser) ImplementsStmt() (localctx IImplementsStmtContext) {
	this := p
	_ = this

	localctx = NewImplementsStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, vbaParserRULE_implementsStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1025)
		p.Match(vbaParserIMPLEMENTS)
	}
	{
		p.SetState(1026)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1027)
		p.AmbiguousIdentifier()
	}

	return localctx
}

// IInputStmtContext is an interface to support dynamic dispatch.
type IInputStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInputStmtContext differentiates from other interfaces.
	IsInputStmtContext()
}

type InputStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputStmtContext() *InputStmtContext {
	var p = new(InputStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_inputStmt
	return p
}

func (*InputStmtContext) IsInputStmtContext() {}

func NewInputStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputStmtContext {
	var p = new(InputStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_inputStmt

	return p
}

func (s *InputStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *InputStmtContext) INPUT() antlr.TerminalNode {
	return s.GetToken(vbaParserINPUT, 0)
}

func (s *InputStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *InputStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *InputStmtContext) FileNumber() IFileNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNumberContext)
}

func (s *InputStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *InputStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *InputStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterInputStmt(s)
	}
}

func (s *InputStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitInputStmt(s)
	}
}

func (p *vbaParser) InputStmt() (localctx IInputStmtContext) {
	this := p
	_ = this

	localctx = NewInputStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, vbaParserRULE_inputStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1029)
		p.Match(vbaParserINPUT)
	}
	{
		p.SetState(1030)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1031)
		p.FileNumber()
	}
	p.SetState(1040)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(1033)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(1032)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(1035)
				p.Match(vbaParserT__0)
			}
			p.SetState(1037)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(1036)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(1039)
				p.valueStmt(0)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1042)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())
	}

	return localctx
}

// IKillStmtContext is an interface to support dynamic dispatch.
type IKillStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKillStmtContext differentiates from other interfaces.
	IsKillStmtContext()
}

type KillStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKillStmtContext() *KillStmtContext {
	var p = new(KillStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_killStmt
	return p
}

func (*KillStmtContext) IsKillStmtContext() {}

func NewKillStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillStmtContext {
	var p = new(KillStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_killStmt

	return p
}

func (s *KillStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *KillStmtContext) KILL() antlr.TerminalNode {
	return s.GetToken(vbaParserKILL, 0)
}

func (s *KillStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *KillStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *KillStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KillStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterKillStmt(s)
	}
}

func (s *KillStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitKillStmt(s)
	}
}

func (p *vbaParser) KillStmt() (localctx IKillStmtContext) {
	this := p
	_ = this

	localctx = NewKillStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, vbaParserRULE_killStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1044)
		p.Match(vbaParserKILL)
	}
	{
		p.SetState(1045)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1046)
		p.valueStmt(0)
	}

	return localctx
}

// ILetStmtContext is an interface to support dynamic dispatch.
type ILetStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLetStmtContext differentiates from other interfaces.
	IsLetStmtContext()
}

type LetStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetStmtContext() *LetStmtContext {
	var p = new(LetStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_letStmt
	return p
}

func (*LetStmtContext) IsLetStmtContext() {}

func NewLetStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetStmtContext {
	var p = new(LetStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_letStmt

	return p
}

func (s *LetStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *LetStmtContext) ImplicitCallStmt_InStmt() IImplicitCallStmt_InStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitCallStmt_InStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitCallStmt_InStmtContext)
}

func (s *LetStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *LetStmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *LetStmtContext) PLUS_EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserPLUS_EQ, 0)
}

func (s *LetStmtContext) MINUS_EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserMINUS_EQ, 0)
}

func (s *LetStmtContext) LET() antlr.TerminalNode {
	return s.GetToken(vbaParserLET, 0)
}

func (s *LetStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *LetStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *LetStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterLetStmt(s)
	}
}

func (s *LetStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitLetStmt(s)
	}
}

func (p *vbaParser) LetStmt() (localctx ILetStmtContext) {
	this := p
	_ = this

	localctx = NewLetStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, vbaParserRULE_letStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1050)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1048)
			p.Match(vbaParserLET)
		}
		{
			p.SetState(1049)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1052)
		p.ImplicitCallStmt_InStmt()
	}
	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1053)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1056)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-189)&-(0x1f+1)) == 0 && ((1<<uint((_la-189)))&((1<<(vbaParserEQ-189))|(1<<(vbaParserMINUS_EQ-189))|(1<<(vbaParserPLUS_EQ-189)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1058)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1057)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1060)
		p.valueStmt(0)
	}

	return localctx
}

// ILineInputStmtContext is an interface to support dynamic dispatch.
type ILineInputStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineInputStmtContext differentiates from other interfaces.
	IsLineInputStmtContext()
}

type LineInputStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineInputStmtContext() *LineInputStmtContext {
	var p = new(LineInputStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_lineInputStmt
	return p
}

func (*LineInputStmtContext) IsLineInputStmtContext() {}

func NewLineInputStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineInputStmtContext {
	var p = new(LineInputStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_lineInputStmt

	return p
}

func (s *LineInputStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *LineInputStmtContext) LINE_INPUT() antlr.TerminalNode {
	return s.GetToken(vbaParserLINE_INPUT, 0)
}

func (s *LineInputStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *LineInputStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *LineInputStmtContext) FileNumber() IFileNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNumberContext)
}

func (s *LineInputStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *LineInputStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineInputStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineInputStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterLineInputStmt(s)
	}
}

func (s *LineInputStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitLineInputStmt(s)
	}
}

func (p *vbaParser) LineInputStmt() (localctx ILineInputStmtContext) {
	this := p
	_ = this

	localctx = NewLineInputStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, vbaParserRULE_lineInputStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1062)
		p.Match(vbaParserLINE_INPUT)
	}
	{
		p.SetState(1063)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1064)
		p.FileNumber()
	}
	p.SetState(1066)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1065)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1068)
		p.Match(vbaParserT__0)
	}
	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1069)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1072)
		p.valueStmt(0)
	}

	return localctx
}

// ILoadStmtContext is an interface to support dynamic dispatch.
type ILoadStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoadStmtContext differentiates from other interfaces.
	IsLoadStmtContext()
}

type LoadStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadStmtContext() *LoadStmtContext {
	var p = new(LoadStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_loadStmt
	return p
}

func (*LoadStmtContext) IsLoadStmtContext() {}

func NewLoadStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadStmtContext {
	var p = new(LoadStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_loadStmt

	return p
}

func (s *LoadStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadStmtContext) LOAD() antlr.TerminalNode {
	return s.GetToken(vbaParserLOAD, 0)
}

func (s *LoadStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *LoadStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *LoadStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterLoadStmt(s)
	}
}

func (s *LoadStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitLoadStmt(s)
	}
}

func (p *vbaParser) LoadStmt() (localctx ILoadStmtContext) {
	this := p
	_ = this

	localctx = NewLoadStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, vbaParserRULE_loadStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1074)
		p.Match(vbaParserLOAD)
	}
	{
		p.SetState(1075)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1076)
		p.valueStmt(0)
	}

	return localctx
}

// ILockStmtContext is an interface to support dynamic dispatch.
type ILockStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLockStmtContext differentiates from other interfaces.
	IsLockStmtContext()
}

type LockStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockStmtContext() *LockStmtContext {
	var p = new(LockStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_lockStmt
	return p
}

func (*LockStmtContext) IsLockStmtContext() {}

func NewLockStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockStmtContext {
	var p = new(LockStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_lockStmt

	return p
}

func (s *LockStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *LockStmtContext) LOCK() antlr.TerminalNode {
	return s.GetToken(vbaParserLOCK, 0)
}

func (s *LockStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *LockStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *LockStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *LockStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *LockStmtContext) TO() antlr.TerminalNode {
	return s.GetToken(vbaParserTO, 0)
}

func (s *LockStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterLockStmt(s)
	}
}

func (s *LockStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitLockStmt(s)
	}
}

func (p *vbaParser) LockStmt() (localctx ILockStmtContext) {
	this := p
	_ = this

	localctx = NewLockStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, vbaParserRULE_lockStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1078)
		p.Match(vbaParserLOCK)
	}
	{
		p.SetState(1079)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1080)
		p.valueStmt(0)
	}
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
		p.SetState(1082)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1081)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1084)
			p.Match(vbaParserT__0)
		}
		p.SetState(1086)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1085)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1088)
			p.valueStmt(0)
		}
		p.SetState(1093)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1089)
				p.Match(vbaParserWS)
			}
			{
				p.SetState(1090)
				p.Match(vbaParserTO)
			}
			{
				p.SetState(1091)
				p.Match(vbaParserWS)
			}
			{
				p.SetState(1092)
				p.valueStmt(0)
			}

		}

	}

	return localctx
}

// ILsetStmtContext is an interface to support dynamic dispatch.
type ILsetStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLsetStmtContext differentiates from other interfaces.
	IsLsetStmtContext()
}

type LsetStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLsetStmtContext() *LsetStmtContext {
	var p = new(LsetStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_lsetStmt
	return p
}

func (*LsetStmtContext) IsLsetStmtContext() {}

func NewLsetStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LsetStmtContext {
	var p = new(LsetStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_lsetStmt

	return p
}

func (s *LsetStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *LsetStmtContext) LSET() antlr.TerminalNode {
	return s.GetToken(vbaParserLSET, 0)
}

func (s *LsetStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *LsetStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *LsetStmtContext) ImplicitCallStmt_InStmt() IImplicitCallStmt_InStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitCallStmt_InStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitCallStmt_InStmtContext)
}

func (s *LsetStmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *LsetStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *LsetStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LsetStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LsetStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterLsetStmt(s)
	}
}

func (s *LsetStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitLsetStmt(s)
	}
}

func (p *vbaParser) LsetStmt() (localctx ILsetStmtContext) {
	this := p
	_ = this

	localctx = NewLsetStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, vbaParserRULE_lsetStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1097)
		p.Match(vbaParserLSET)
	}
	{
		p.SetState(1098)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1099)
		p.ImplicitCallStmt_InStmt()
	}
	p.SetState(1101)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1100)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1103)
		p.Match(vbaParserEQ)
	}
	p.SetState(1105)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1104)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1107)
		p.valueStmt(0)
	}

	return localctx
}

// IMacroConstStmtContext is an interface to support dynamic dispatch.
type IMacroConstStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMacroConstStmtContext differentiates from other interfaces.
	IsMacroConstStmtContext()
}

type MacroConstStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacroConstStmtContext() *MacroConstStmtContext {
	var p = new(MacroConstStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_macroConstStmt
	return p
}

func (*MacroConstStmtContext) IsMacroConstStmtContext() {}

func NewMacroConstStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MacroConstStmtContext {
	var p = new(MacroConstStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_macroConstStmt

	return p
}

func (s *MacroConstStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *MacroConstStmtContext) MACRO_CONST() antlr.TerminalNode {
	return s.GetToken(vbaParserMACRO_CONST, 0)
}

func (s *MacroConstStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *MacroConstStmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *MacroConstStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *MacroConstStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *MacroConstStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *MacroConstStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MacroConstStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MacroConstStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterMacroConstStmt(s)
	}
}

func (s *MacroConstStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitMacroConstStmt(s)
	}
}

func (p *vbaParser) MacroConstStmt() (localctx IMacroConstStmtContext) {
	this := p
	_ = this

	localctx = NewMacroConstStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, vbaParserRULE_macroConstStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1109)
		p.Match(vbaParserMACRO_CONST)
	}
	p.SetState(1111)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1110)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1113)
		p.AmbiguousIdentifier()
	}
	p.SetState(1115)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1114)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1117)
		p.Match(vbaParserEQ)
	}
	p.SetState(1119)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1118)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1121)
		p.valueStmt(0)
	}

	return localctx
}

// IMacroIfThenElseStmtContext is an interface to support dynamic dispatch.
type IMacroIfThenElseStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMacroIfThenElseStmtContext differentiates from other interfaces.
	IsMacroIfThenElseStmtContext()
}

type MacroIfThenElseStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacroIfThenElseStmtContext() *MacroIfThenElseStmtContext {
	var p = new(MacroIfThenElseStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_macroIfThenElseStmt
	return p
}

func (*MacroIfThenElseStmtContext) IsMacroIfThenElseStmtContext() {}

func NewMacroIfThenElseStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MacroIfThenElseStmtContext {
	var p = new(MacroIfThenElseStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_macroIfThenElseStmt

	return p
}

func (s *MacroIfThenElseStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *MacroIfThenElseStmtContext) MacroIfBlockStmt() IMacroIfBlockStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMacroIfBlockStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMacroIfBlockStmtContext)
}

func (s *MacroIfThenElseStmtContext) MACRO_END_IF() antlr.TerminalNode {
	return s.GetToken(vbaParserMACRO_END_IF, 0)
}

func (s *MacroIfThenElseStmtContext) AllMacroElseIfBlockStmt() []IMacroElseIfBlockStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMacroElseIfBlockStmtContext)(nil)).Elem())
	var tst = make([]IMacroElseIfBlockStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMacroElseIfBlockStmtContext)
		}
	}

	return tst
}

func (s *MacroIfThenElseStmtContext) MacroElseIfBlockStmt(i int) IMacroElseIfBlockStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMacroElseIfBlockStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMacroElseIfBlockStmtContext)
}

func (s *MacroIfThenElseStmtContext) MacroElseBlockStmt() IMacroElseBlockStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMacroElseBlockStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMacroElseBlockStmtContext)
}

func (s *MacroIfThenElseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MacroIfThenElseStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MacroIfThenElseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterMacroIfThenElseStmt(s)
	}
}

func (s *MacroIfThenElseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitMacroIfThenElseStmt(s)
	}
}

func (p *vbaParser) MacroIfThenElseStmt() (localctx IMacroIfThenElseStmtContext) {
	this := p
	_ = this

	localctx = NewMacroIfThenElseStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, vbaParserRULE_macroIfThenElseStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1123)
		p.MacroIfBlockStmt()
	}
	p.SetState(1127)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vbaParserMACRO_ELSEIF {
		{
			p.SetState(1124)
			p.MacroElseIfBlockStmt()
		}

		p.SetState(1129)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserMACRO_ELSE {
		{
			p.SetState(1130)
			p.MacroElseBlockStmt()
		}

	}
	{
		p.SetState(1133)
		p.Match(vbaParserMACRO_END_IF)
	}

	return localctx
}

// IMacroIfBlockStmtContext is an interface to support dynamic dispatch.
type IMacroIfBlockStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMacroIfBlockStmtContext differentiates from other interfaces.
	IsMacroIfBlockStmtContext()
}

type MacroIfBlockStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacroIfBlockStmtContext() *MacroIfBlockStmtContext {
	var p = new(MacroIfBlockStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_macroIfBlockStmt
	return p
}

func (*MacroIfBlockStmtContext) IsMacroIfBlockStmtContext() {}

func NewMacroIfBlockStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MacroIfBlockStmtContext {
	var p = new(MacroIfBlockStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_macroIfBlockStmt

	return p
}

func (s *MacroIfBlockStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *MacroIfBlockStmtContext) MACRO_IF() antlr.TerminalNode {
	return s.GetToken(vbaParserMACRO_IF, 0)
}

func (s *MacroIfBlockStmtContext) IfConditionStmt() IIfConditionStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfConditionStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfConditionStmtContext)
}

func (s *MacroIfBlockStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *MacroIfBlockStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *MacroIfBlockStmtContext) THEN() antlr.TerminalNode {
	return s.GetToken(vbaParserTHEN, 0)
}

func (s *MacroIfBlockStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *MacroIfBlockStmtContext) AllModuleDeclarations() []IModuleDeclarationsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleDeclarationsContext)(nil)).Elem())
	var tst = make([]IModuleDeclarationsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleDeclarationsContext)
		}
	}

	return tst
}

func (s *MacroIfBlockStmtContext) ModuleDeclarations(i int) IModuleDeclarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleDeclarationsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleDeclarationsContext)
}

func (s *MacroIfBlockStmtContext) AllModuleBody() []IModuleBodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleBodyContext)(nil)).Elem())
	var tst = make([]IModuleBodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleBodyContext)
		}
	}

	return tst
}

func (s *MacroIfBlockStmtContext) ModuleBody(i int) IModuleBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleBodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleBodyContext)
}

func (s *MacroIfBlockStmtContext) AllBlock() []IBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockContext)(nil)).Elem())
	var tst = make([]IBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockContext)
		}
	}

	return tst
}

func (s *MacroIfBlockStmtContext) Block(i int) IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MacroIfBlockStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MacroIfBlockStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MacroIfBlockStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterMacroIfBlockStmt(s)
	}
}

func (s *MacroIfBlockStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitMacroIfBlockStmt(s)
	}
}

func (p *vbaParser) MacroIfBlockStmt() (localctx IMacroIfBlockStmtContext) {
	this := p
	_ = this

	localctx = NewMacroIfBlockStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, vbaParserRULE_macroIfBlockStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1135)
		p.Match(vbaParserMACRO_IF)
	}
	p.SetState(1137)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1136)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1139)
		p.IfConditionStmt()
	}
	{
		p.SetState(1140)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1141)
		p.Match(vbaParserTHEN)
	}
	{
		p.SetState(1142)
		p.EndOfStatement()
	}
	p.SetState(1148)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserEXIT_DO-64))|(1<<(vbaParserEXIT_FOR-64))|(1<<(vbaParserEXIT_FUNCTION-64))|(1<<(vbaParserEXIT_PROPERTY-64))|(1<<(vbaParserEXIT_SUB-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLINE_INPUT-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserMACRO_CONST-96))|(1<<(vbaParserMACRO_IF-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserON_ERROR-96))|(1<<(vbaParserON_LOCAL_ERROR-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOPTION_BASE-96))|(1<<(vbaParserOPTION_EXPLICIT-96))|(1<<(vbaParserOPTION_COMPARE-96))|(1<<(vbaParserOPTION_PRIVATE_MODULE-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPROPERTY_GET-128))|(1<<(vbaParserPROPERTY_LET-128))|(1<<(vbaParserPROPERTY_SET-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || _la == vbaParserCOMMENT || _la == vbaParserIDENTIFIER {
		p.SetState(1146)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1143)
				p.ModuleDeclarations()
			}

		case 2:
			{
				p.SetState(1144)
				p.ModuleBody()
			}

		case 3:
			{
				p.SetState(1145)
				p.Block()
			}

		}

		p.SetState(1150)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMacroElseIfBlockStmtContext is an interface to support dynamic dispatch.
type IMacroElseIfBlockStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMacroElseIfBlockStmtContext differentiates from other interfaces.
	IsMacroElseIfBlockStmtContext()
}

type MacroElseIfBlockStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacroElseIfBlockStmtContext() *MacroElseIfBlockStmtContext {
	var p = new(MacroElseIfBlockStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_macroElseIfBlockStmt
	return p
}

func (*MacroElseIfBlockStmtContext) IsMacroElseIfBlockStmtContext() {}

func NewMacroElseIfBlockStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MacroElseIfBlockStmtContext {
	var p = new(MacroElseIfBlockStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_macroElseIfBlockStmt

	return p
}

func (s *MacroElseIfBlockStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *MacroElseIfBlockStmtContext) MACRO_ELSEIF() antlr.TerminalNode {
	return s.GetToken(vbaParserMACRO_ELSEIF, 0)
}

func (s *MacroElseIfBlockStmtContext) IfConditionStmt() IIfConditionStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfConditionStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfConditionStmtContext)
}

func (s *MacroElseIfBlockStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *MacroElseIfBlockStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *MacroElseIfBlockStmtContext) THEN() antlr.TerminalNode {
	return s.GetToken(vbaParserTHEN, 0)
}

func (s *MacroElseIfBlockStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *MacroElseIfBlockStmtContext) AllModuleDeclarations() []IModuleDeclarationsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleDeclarationsContext)(nil)).Elem())
	var tst = make([]IModuleDeclarationsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleDeclarationsContext)
		}
	}

	return tst
}

func (s *MacroElseIfBlockStmtContext) ModuleDeclarations(i int) IModuleDeclarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleDeclarationsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleDeclarationsContext)
}

func (s *MacroElseIfBlockStmtContext) AllModuleBody() []IModuleBodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleBodyContext)(nil)).Elem())
	var tst = make([]IModuleBodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleBodyContext)
		}
	}

	return tst
}

func (s *MacroElseIfBlockStmtContext) ModuleBody(i int) IModuleBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleBodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleBodyContext)
}

func (s *MacroElseIfBlockStmtContext) AllBlock() []IBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockContext)(nil)).Elem())
	var tst = make([]IBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockContext)
		}
	}

	return tst
}

func (s *MacroElseIfBlockStmtContext) Block(i int) IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MacroElseIfBlockStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MacroElseIfBlockStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MacroElseIfBlockStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterMacroElseIfBlockStmt(s)
	}
}

func (s *MacroElseIfBlockStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitMacroElseIfBlockStmt(s)
	}
}

func (p *vbaParser) MacroElseIfBlockStmt() (localctx IMacroElseIfBlockStmtContext) {
	this := p
	_ = this

	localctx = NewMacroElseIfBlockStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, vbaParserRULE_macroElseIfBlockStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1151)
		p.Match(vbaParserMACRO_ELSEIF)
	}
	p.SetState(1153)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1152)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1155)
		p.IfConditionStmt()
	}
	{
		p.SetState(1156)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1157)
		p.Match(vbaParserTHEN)
	}
	{
		p.SetState(1158)
		p.EndOfStatement()
	}
	p.SetState(1164)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserEXIT_DO-64))|(1<<(vbaParserEXIT_FOR-64))|(1<<(vbaParserEXIT_FUNCTION-64))|(1<<(vbaParserEXIT_PROPERTY-64))|(1<<(vbaParserEXIT_SUB-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLINE_INPUT-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserMACRO_CONST-96))|(1<<(vbaParserMACRO_IF-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserON_ERROR-96))|(1<<(vbaParserON_LOCAL_ERROR-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOPTION_BASE-96))|(1<<(vbaParserOPTION_EXPLICIT-96))|(1<<(vbaParserOPTION_COMPARE-96))|(1<<(vbaParserOPTION_PRIVATE_MODULE-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPROPERTY_GET-128))|(1<<(vbaParserPROPERTY_LET-128))|(1<<(vbaParserPROPERTY_SET-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || _la == vbaParserCOMMENT || _la == vbaParserIDENTIFIER {
		p.SetState(1162)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1159)
				p.ModuleDeclarations()
			}

		case 2:
			{
				p.SetState(1160)
				p.ModuleBody()
			}

		case 3:
			{
				p.SetState(1161)
				p.Block()
			}

		}

		p.SetState(1166)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMacroElseBlockStmtContext is an interface to support dynamic dispatch.
type IMacroElseBlockStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMacroElseBlockStmtContext differentiates from other interfaces.
	IsMacroElseBlockStmtContext()
}

type MacroElseBlockStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacroElseBlockStmtContext() *MacroElseBlockStmtContext {
	var p = new(MacroElseBlockStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_macroElseBlockStmt
	return p
}

func (*MacroElseBlockStmtContext) IsMacroElseBlockStmtContext() {}

func NewMacroElseBlockStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MacroElseBlockStmtContext {
	var p = new(MacroElseBlockStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_macroElseBlockStmt

	return p
}

func (s *MacroElseBlockStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *MacroElseBlockStmtContext) MACRO_ELSE() antlr.TerminalNode {
	return s.GetToken(vbaParserMACRO_ELSE, 0)
}

func (s *MacroElseBlockStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *MacroElseBlockStmtContext) AllModuleDeclarations() []IModuleDeclarationsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleDeclarationsContext)(nil)).Elem())
	var tst = make([]IModuleDeclarationsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleDeclarationsContext)
		}
	}

	return tst
}

func (s *MacroElseBlockStmtContext) ModuleDeclarations(i int) IModuleDeclarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleDeclarationsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleDeclarationsContext)
}

func (s *MacroElseBlockStmtContext) AllModuleBody() []IModuleBodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleBodyContext)(nil)).Elem())
	var tst = make([]IModuleBodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleBodyContext)
		}
	}

	return tst
}

func (s *MacroElseBlockStmtContext) ModuleBody(i int) IModuleBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleBodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleBodyContext)
}

func (s *MacroElseBlockStmtContext) AllBlock() []IBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockContext)(nil)).Elem())
	var tst = make([]IBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockContext)
		}
	}

	return tst
}

func (s *MacroElseBlockStmtContext) Block(i int) IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MacroElseBlockStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MacroElseBlockStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MacroElseBlockStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterMacroElseBlockStmt(s)
	}
}

func (s *MacroElseBlockStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitMacroElseBlockStmt(s)
	}
}

func (p *vbaParser) MacroElseBlockStmt() (localctx IMacroElseBlockStmtContext) {
	this := p
	_ = this

	localctx = NewMacroElseBlockStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, vbaParserRULE_macroElseBlockStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1167)
		p.Match(vbaParserMACRO_ELSE)
	}
	{
		p.SetState(1168)
		p.EndOfStatement()
	}
	p.SetState(1174)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserEXIT_DO-64))|(1<<(vbaParserEXIT_FOR-64))|(1<<(vbaParserEXIT_FUNCTION-64))|(1<<(vbaParserEXIT_PROPERTY-64))|(1<<(vbaParserEXIT_SUB-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLINE_INPUT-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserMACRO_CONST-96))|(1<<(vbaParserMACRO_IF-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserON_ERROR-96))|(1<<(vbaParserON_LOCAL_ERROR-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOPTION_BASE-96))|(1<<(vbaParserOPTION_EXPLICIT-96))|(1<<(vbaParserOPTION_COMPARE-96))|(1<<(vbaParserOPTION_PRIVATE_MODULE-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPROPERTY_GET-128))|(1<<(vbaParserPROPERTY_LET-128))|(1<<(vbaParserPROPERTY_SET-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || _la == vbaParserCOMMENT || _la == vbaParserIDENTIFIER {
		p.SetState(1172)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1169)
				p.ModuleDeclarations()
			}

		case 2:
			{
				p.SetState(1170)
				p.ModuleBody()
			}

		case 3:
			{
				p.SetState(1171)
				p.Block()
			}

		}

		p.SetState(1176)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMidStmtContext is an interface to support dynamic dispatch.
type IMidStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMidStmtContext differentiates from other interfaces.
	IsMidStmtContext()
}

type MidStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMidStmtContext() *MidStmtContext {
	var p = new(MidStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_midStmt
	return p
}

func (*MidStmtContext) IsMidStmtContext() {}

func NewMidStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MidStmtContext {
	var p = new(MidStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_midStmt

	return p
}

func (s *MidStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *MidStmtContext) MID() antlr.TerminalNode {
	return s.GetToken(vbaParserMID, 0)
}

func (s *MidStmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, 0)
}

func (s *MidStmtContext) ArgsCall() IArgsCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgsCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgsCallContext)
}

func (s *MidStmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, 0)
}

func (s *MidStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *MidStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *MidStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MidStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MidStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterMidStmt(s)
	}
}

func (s *MidStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitMidStmt(s)
	}
}

func (p *vbaParser) MidStmt() (localctx IMidStmtContext) {
	this := p
	_ = this

	localctx = NewMidStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, vbaParserRULE_midStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1177)
		p.Match(vbaParserMID)
	}
	p.SetState(1179)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1178)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1181)
		p.Match(vbaParserLPAREN)
	}
	p.SetState(1183)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1182)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1185)
		p.ArgsCall()
	}
	p.SetState(1187)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1186)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1189)
		p.Match(vbaParserRPAREN)
	}

	return localctx
}

// IMkdirStmtContext is an interface to support dynamic dispatch.
type IMkdirStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMkdirStmtContext differentiates from other interfaces.
	IsMkdirStmtContext()
}

type MkdirStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMkdirStmtContext() *MkdirStmtContext {
	var p = new(MkdirStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_mkdirStmt
	return p
}

func (*MkdirStmtContext) IsMkdirStmtContext() {}

func NewMkdirStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MkdirStmtContext {
	var p = new(MkdirStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_mkdirStmt

	return p
}

func (s *MkdirStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *MkdirStmtContext) MKDIR() antlr.TerminalNode {
	return s.GetToken(vbaParserMKDIR, 0)
}

func (s *MkdirStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *MkdirStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *MkdirStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MkdirStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MkdirStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterMkdirStmt(s)
	}
}

func (s *MkdirStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitMkdirStmt(s)
	}
}

func (p *vbaParser) MkdirStmt() (localctx IMkdirStmtContext) {
	this := p
	_ = this

	localctx = NewMkdirStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, vbaParserRULE_mkdirStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1191)
		p.Match(vbaParserMKDIR)
	}
	{
		p.SetState(1192)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1193)
		p.valueStmt(0)
	}

	return localctx
}

// INameStmtContext is an interface to support dynamic dispatch.
type INameStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameStmtContext differentiates from other interfaces.
	IsNameStmtContext()
}

type NameStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameStmtContext() *NameStmtContext {
	var p = new(NameStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_nameStmt
	return p
}

func (*NameStmtContext) IsNameStmtContext() {}

func NewNameStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameStmtContext {
	var p = new(NameStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_nameStmt

	return p
}

func (s *NameStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *NameStmtContext) NAME() antlr.TerminalNode {
	return s.GetToken(vbaParserNAME, 0)
}

func (s *NameStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *NameStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *NameStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *NameStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *NameStmtContext) AS() antlr.TerminalNode {
	return s.GetToken(vbaParserAS, 0)
}

func (s *NameStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterNameStmt(s)
	}
}

func (s *NameStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitNameStmt(s)
	}
}

func (p *vbaParser) NameStmt() (localctx INameStmtContext) {
	this := p
	_ = this

	localctx = NewNameStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, vbaParserRULE_nameStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1195)
		p.Match(vbaParserNAME)
	}
	{
		p.SetState(1196)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1197)
		p.valueStmt(0)
	}
	{
		p.SetState(1198)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1199)
		p.Match(vbaParserAS)
	}
	{
		p.SetState(1200)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1201)
		p.valueStmt(0)
	}

	return localctx
}

// IOnErrorStmtContext is an interface to support dynamic dispatch.
type IOnErrorStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnErrorStmtContext differentiates from other interfaces.
	IsOnErrorStmtContext()
}

type OnErrorStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnErrorStmtContext() *OnErrorStmtContext {
	var p = new(OnErrorStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_onErrorStmt
	return p
}

func (*OnErrorStmtContext) IsOnErrorStmtContext() {}

func NewOnErrorStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnErrorStmtContext {
	var p = new(OnErrorStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_onErrorStmt

	return p
}

func (s *OnErrorStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *OnErrorStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *OnErrorStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *OnErrorStmtContext) ON_ERROR() antlr.TerminalNode {
	return s.GetToken(vbaParserON_ERROR, 0)
}

func (s *OnErrorStmtContext) ON_LOCAL_ERROR() antlr.TerminalNode {
	return s.GetToken(vbaParserON_LOCAL_ERROR, 0)
}

func (s *OnErrorStmtContext) GOTO() antlr.TerminalNode {
	return s.GetToken(vbaParserGOTO, 0)
}

func (s *OnErrorStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *OnErrorStmtContext) RESUME() antlr.TerminalNode {
	return s.GetToken(vbaParserRESUME, 0)
}

func (s *OnErrorStmtContext) NEXT() antlr.TerminalNode {
	return s.GetToken(vbaParserNEXT, 0)
}

func (s *OnErrorStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnErrorStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnErrorStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterOnErrorStmt(s)
	}
}

func (s *OnErrorStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitOnErrorStmt(s)
	}
}

func (p *vbaParser) OnErrorStmt() (localctx IOnErrorStmtContext) {
	this := p
	_ = this

	localctx = NewOnErrorStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, vbaParserRULE_onErrorStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1203)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vbaParserON_ERROR || _la == vbaParserON_LOCAL_ERROR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1204)
		p.Match(vbaParserWS)
	}
	p.SetState(1211)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vbaParserGOTO:
		{
			p.SetState(1205)
			p.Match(vbaParserGOTO)
		}
		{
			p.SetState(1206)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(1207)
			p.valueStmt(0)
		}

	case vbaParserRESUME:
		{
			p.SetState(1208)
			p.Match(vbaParserRESUME)
		}
		{
			p.SetState(1209)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(1210)
			p.Match(vbaParserNEXT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOnGoToStmtContext is an interface to support dynamic dispatch.
type IOnGoToStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnGoToStmtContext differentiates from other interfaces.
	IsOnGoToStmtContext()
}

type OnGoToStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnGoToStmtContext() *OnGoToStmtContext {
	var p = new(OnGoToStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_onGoToStmt
	return p
}

func (*OnGoToStmtContext) IsOnGoToStmtContext() {}

func NewOnGoToStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnGoToStmtContext {
	var p = new(OnGoToStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_onGoToStmt

	return p
}

func (s *OnGoToStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *OnGoToStmtContext) ON() antlr.TerminalNode {
	return s.GetToken(vbaParserON, 0)
}

func (s *OnGoToStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *OnGoToStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *OnGoToStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *OnGoToStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *OnGoToStmtContext) GOTO() antlr.TerminalNode {
	return s.GetToken(vbaParserGOTO, 0)
}

func (s *OnGoToStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnGoToStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnGoToStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterOnGoToStmt(s)
	}
}

func (s *OnGoToStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitOnGoToStmt(s)
	}
}

func (p *vbaParser) OnGoToStmt() (localctx IOnGoToStmtContext) {
	this := p
	_ = this

	localctx = NewOnGoToStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, vbaParserRULE_onGoToStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1213)
		p.Match(vbaParserON)
	}
	{
		p.SetState(1214)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1215)
		p.valueStmt(0)
	}
	{
		p.SetState(1216)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1217)
		p.Match(vbaParserGOTO)
	}
	{
		p.SetState(1218)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1219)
		p.valueStmt(0)
	}
	p.SetState(1230)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 149, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1221)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(1220)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(1223)
				p.Match(vbaParserT__0)
			}
			p.SetState(1225)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(1224)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(1227)
				p.valueStmt(0)
			}

		}
		p.SetState(1232)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 149, p.GetParserRuleContext())
	}

	return localctx
}

// IOnGoSubStmtContext is an interface to support dynamic dispatch.
type IOnGoSubStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnGoSubStmtContext differentiates from other interfaces.
	IsOnGoSubStmtContext()
}

type OnGoSubStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnGoSubStmtContext() *OnGoSubStmtContext {
	var p = new(OnGoSubStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_onGoSubStmt
	return p
}

func (*OnGoSubStmtContext) IsOnGoSubStmtContext() {}

func NewOnGoSubStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnGoSubStmtContext {
	var p = new(OnGoSubStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_onGoSubStmt

	return p
}

func (s *OnGoSubStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *OnGoSubStmtContext) ON() antlr.TerminalNode {
	return s.GetToken(vbaParserON, 0)
}

func (s *OnGoSubStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *OnGoSubStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *OnGoSubStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *OnGoSubStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *OnGoSubStmtContext) GOSUB() antlr.TerminalNode {
	return s.GetToken(vbaParserGOSUB, 0)
}

func (s *OnGoSubStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnGoSubStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnGoSubStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterOnGoSubStmt(s)
	}
}

func (s *OnGoSubStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitOnGoSubStmt(s)
	}
}

func (p *vbaParser) OnGoSubStmt() (localctx IOnGoSubStmtContext) {
	this := p
	_ = this

	localctx = NewOnGoSubStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, vbaParserRULE_onGoSubStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1233)
		p.Match(vbaParserON)
	}
	{
		p.SetState(1234)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1235)
		p.valueStmt(0)
	}
	{
		p.SetState(1236)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1237)
		p.Match(vbaParserGOSUB)
	}
	{
		p.SetState(1238)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1239)
		p.valueStmt(0)
	}
	p.SetState(1250)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1241)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(1240)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(1243)
				p.Match(vbaParserT__0)
			}
			p.SetState(1245)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(1244)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(1247)
				p.valueStmt(0)
			}

		}
		p.SetState(1252)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())
	}

	return localctx
}

// IOpenStmtContext is an interface to support dynamic dispatch.
type IOpenStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenStmtContext differentiates from other interfaces.
	IsOpenStmtContext()
}

type OpenStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenStmtContext() *OpenStmtContext {
	var p = new(OpenStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_openStmt
	return p
}

func (*OpenStmtContext) IsOpenStmtContext() {}

func NewOpenStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenStmtContext {
	var p = new(OpenStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_openStmt

	return p
}

func (s *OpenStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenStmtContext) OPEN() antlr.TerminalNode {
	return s.GetToken(vbaParserOPEN, 0)
}

func (s *OpenStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *OpenStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *OpenStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *OpenStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *OpenStmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(vbaParserFOR, 0)
}

func (s *OpenStmtContext) AS() antlr.TerminalNode {
	return s.GetToken(vbaParserAS, 0)
}

func (s *OpenStmtContext) FileNumber() IFileNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNumberContext)
}

func (s *OpenStmtContext) APPEND() antlr.TerminalNode {
	return s.GetToken(vbaParserAPPEND, 0)
}

func (s *OpenStmtContext) BINARY() antlr.TerminalNode {
	return s.GetToken(vbaParserBINARY, 0)
}

func (s *OpenStmtContext) INPUT() antlr.TerminalNode {
	return s.GetToken(vbaParserINPUT, 0)
}

func (s *OpenStmtContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(vbaParserOUTPUT, 0)
}

func (s *OpenStmtContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(vbaParserRANDOM, 0)
}

func (s *OpenStmtContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(vbaParserACCESS, 0)
}

func (s *OpenStmtContext) LEN() antlr.TerminalNode {
	return s.GetToken(vbaParserLEN, 0)
}

func (s *OpenStmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *OpenStmtContext) READ() antlr.TerminalNode {
	return s.GetToken(vbaParserREAD, 0)
}

func (s *OpenStmtContext) WRITE() antlr.TerminalNode {
	return s.GetToken(vbaParserWRITE, 0)
}

func (s *OpenStmtContext) READ_WRITE() antlr.TerminalNode {
	return s.GetToken(vbaParserREAD_WRITE, 0)
}

func (s *OpenStmtContext) SHARED() antlr.TerminalNode {
	return s.GetToken(vbaParserSHARED, 0)
}

func (s *OpenStmtContext) LOCK_READ() antlr.TerminalNode {
	return s.GetToken(vbaParserLOCK_READ, 0)
}

func (s *OpenStmtContext) LOCK_WRITE() antlr.TerminalNode {
	return s.GetToken(vbaParserLOCK_WRITE, 0)
}

func (s *OpenStmtContext) LOCK_READ_WRITE() antlr.TerminalNode {
	return s.GetToken(vbaParserLOCK_READ_WRITE, 0)
}

func (s *OpenStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterOpenStmt(s)
	}
}

func (s *OpenStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitOpenStmt(s)
	}
}

func (p *vbaParser) OpenStmt() (localctx IOpenStmtContext) {
	this := p
	_ = this

	localctx = NewOpenStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, vbaParserRULE_openStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1253)
		p.Match(vbaParserOPEN)
	}
	{
		p.SetState(1254)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1255)
		p.valueStmt(0)
	}
	{
		p.SetState(1256)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1257)
		p.Match(vbaParserFOR)
	}
	{
		p.SetState(1258)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1259)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vbaParserAPPEND || _la == vbaParserBINARY || _la == vbaParserINPUT || _la == vbaParserOUTPUT || _la == vbaParserRANDOM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1264)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1260)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(1261)
			p.Match(vbaParserACCESS)
		}
		{
			p.SetState(1262)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(1263)
			_la = p.GetTokenStream().LA(1)

			if !(_la == vbaParserREAD || _la == vbaParserREAD_WRITE || _la == vbaParserWRITE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1268)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1266)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(1267)
			_la = p.GetTokenStream().LA(1)

			if !((((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(vbaParserLOCK_READ-99))|(1<<(vbaParserLOCK_WRITE-99))|(1<<(vbaParserLOCK_READ_WRITE-99)))) != 0) || _la == vbaParserSHARED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1270)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1271)
		p.Match(vbaParserAS)
	}
	{
		p.SetState(1272)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1273)
		p.FileNumber()
	}
	p.SetState(1284)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1274)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(1275)
			p.Match(vbaParserLEN)
		}
		p.SetState(1277)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1276)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1279)
			p.Match(vbaParserEQ)
		}
		p.SetState(1281)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1280)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1283)
			p.valueStmt(0)
		}

	}

	return localctx
}

// IOutputListContext is an interface to support dynamic dispatch.
type IOutputListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutputListContext differentiates from other interfaces.
	IsOutputListContext()
}

type OutputListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutputListContext() *OutputListContext {
	var p = new(OutputListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_outputList
	return p
}

func (*OutputListContext) IsOutputListContext() {}

func NewOutputListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutputListContext {
	var p = new(OutputListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_outputList

	return p
}

func (s *OutputListContext) GetParser() antlr.Parser { return s.parser }

func (s *OutputListContext) AllOutputList_Expression() []IOutputList_ExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOutputList_ExpressionContext)(nil)).Elem())
	var tst = make([]IOutputList_ExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOutputList_ExpressionContext)
		}
	}

	return tst
}

func (s *OutputListContext) OutputList_Expression(i int) IOutputList_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutputList_ExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOutputList_ExpressionContext)
}

func (s *OutputListContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *OutputListContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *OutputListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutputListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutputListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterOutputList(s)
	}
}

func (s *OutputListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitOutputList(s)
	}
}

func (p *vbaParser) OutputList() (localctx IOutputListContext) {
	this := p
	_ = this

	localctx = NewOutputListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, vbaParserRULE_outputList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1319)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1286)
			p.OutputList_Expression()
		}
		p.SetState(1299)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1288)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1287)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1290)
					_la = p.GetTokenStream().LA(1)

					if !(_la == vbaParserT__0 || _la == vbaParserT__1) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(1292)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1291)
						p.Match(vbaParserWS)
					}

				}
				p.SetState(1295)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1294)
						p.OutputList_Expression()
					}

				}

			}
			p.SetState(1301)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1303)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || (((_la-193)&-(0x1f+1)) == 0 && ((1<<uint((_la-193)))&((1<<(vbaParserLPAREN-193))|(1<<(vbaParserMINUS-193))|(1<<(vbaParserPLUS-193))|(1<<(vbaParserSTRINGLITERAL-193))|(1<<(vbaParserOCTLITERAL-193))|(1<<(vbaParserHEXLITERAL-193))|(1<<(vbaParserSHORTLITERAL-193))|(1<<(vbaParserINTEGERLITERAL-193))|(1<<(vbaParserDOUBLELITERAL-193))|(1<<(vbaParserDATELITERAL-193))|(1<<(vbaParserIDENTIFIER-193)))) != 0) {
			{
				p.SetState(1302)
				p.OutputList_Expression()
			}

		}
		p.SetState(1315)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(1306)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1305)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1308)
					_la = p.GetTokenStream().LA(1)

					if !(_la == vbaParserT__0 || _la == vbaParserT__1) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(1310)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1309)
						p.Match(vbaParserWS)
					}

				}
				p.SetState(1313)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 165, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1312)
						p.OutputList_Expression()
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1317)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IOutputList_ExpressionContext is an interface to support dynamic dispatch.
type IOutputList_ExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutputList_ExpressionContext differentiates from other interfaces.
	IsOutputList_ExpressionContext()
}

type OutputList_ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutputList_ExpressionContext() *OutputList_ExpressionContext {
	var p = new(OutputList_ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_outputList_Expression
	return p
}

func (*OutputList_ExpressionContext) IsOutputList_ExpressionContext() {}

func NewOutputList_ExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutputList_ExpressionContext {
	var p = new(OutputList_ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_outputList_Expression

	return p
}

func (s *OutputList_ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OutputList_ExpressionContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *OutputList_ExpressionContext) SPC() antlr.TerminalNode {
	return s.GetToken(vbaParserSPC, 0)
}

func (s *OutputList_ExpressionContext) TAB() antlr.TerminalNode {
	return s.GetToken(vbaParserTAB, 0)
}

func (s *OutputList_ExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, 0)
}

func (s *OutputList_ExpressionContext) ArgsCall() IArgsCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgsCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgsCallContext)
}

func (s *OutputList_ExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, 0)
}

func (s *OutputList_ExpressionContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *OutputList_ExpressionContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *OutputList_ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutputList_ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutputList_ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterOutputList_Expression(s)
	}
}

func (s *OutputList_ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitOutputList_Expression(s)
	}
}

func (p *vbaParser) OutputList_Expression() (localctx IOutputList_ExpressionContext) {
	this := p
	_ = this

	localctx = NewOutputList_ExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, vbaParserRULE_outputList_Expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1338)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1321)
			p.valueStmt(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1322)
			_la = p.GetTokenStream().LA(1)

			if !(_la == vbaParserSPC || _la == vbaParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1336)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
			p.SetState(1324)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(1323)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(1326)
				p.Match(vbaParserLPAREN)
			}
			p.SetState(1328)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1327)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(1330)
				p.ArgsCall()
			}
			p.SetState(1332)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(1331)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(1334)
				p.Match(vbaParserRPAREN)
			}

		}

	}

	return localctx
}

// IPrintStmtContext is an interface to support dynamic dispatch.
type IPrintStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrintStmtContext differentiates from other interfaces.
	IsPrintStmtContext()
}

type PrintStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrintStmtContext() *PrintStmtContext {
	var p = new(PrintStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_printStmt
	return p
}

func (*PrintStmtContext) IsPrintStmtContext() {}

func NewPrintStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrintStmtContext {
	var p = new(PrintStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_printStmt

	return p
}

func (s *PrintStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PrintStmtContext) PRINT() antlr.TerminalNode {
	return s.GetToken(vbaParserPRINT, 0)
}

func (s *PrintStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *PrintStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *PrintStmtContext) FileNumber() IFileNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNumberContext)
}

func (s *PrintStmtContext) OutputList() IOutputListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutputListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutputListContext)
}

func (s *PrintStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrintStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterPrintStmt(s)
	}
}

func (s *PrintStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitPrintStmt(s)
	}
}

func (p *vbaParser) PrintStmt() (localctx IPrintStmtContext) {
	this := p
	_ = this

	localctx = NewPrintStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, vbaParserRULE_printStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1340)
		p.Match(vbaParserPRINT)
	}
	{
		p.SetState(1341)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1342)
		p.FileNumber()
	}
	p.SetState(1344)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1343)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1346)
		p.Match(vbaParserT__0)
	}
	p.SetState(1351)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext()) == 1 {
		p.SetState(1348)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1347)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1350)
			p.OutputList()
		}

	}

	return localctx
}

// IPropertyGetStmtContext is an interface to support dynamic dispatch.
type IPropertyGetStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyGetStmtContext differentiates from other interfaces.
	IsPropertyGetStmtContext()
}

type PropertyGetStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyGetStmtContext() *PropertyGetStmtContext {
	var p = new(PropertyGetStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_propertyGetStmt
	return p
}

func (*PropertyGetStmtContext) IsPropertyGetStmtContext() {}

func NewPropertyGetStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyGetStmtContext {
	var p = new(PropertyGetStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_propertyGetStmt

	return p
}

func (s *PropertyGetStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyGetStmtContext) PROPERTY_GET() antlr.TerminalNode {
	return s.GetToken(vbaParserPROPERTY_GET, 0)
}

func (s *PropertyGetStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *PropertyGetStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *PropertyGetStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *PropertyGetStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *PropertyGetStmtContext) END_PROPERTY() antlr.TerminalNode {
	return s.GetToken(vbaParserEND_PROPERTY, 0)
}

func (s *PropertyGetStmtContext) Visibility() IVisibilityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibilityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *PropertyGetStmtContext) STATIC() antlr.TerminalNode {
	return s.GetToken(vbaParserSTATIC, 0)
}

func (s *PropertyGetStmtContext) TypeHint() ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *PropertyGetStmtContext) ArgList() IArgListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgListContext)
}

func (s *PropertyGetStmtContext) AsTypeClause() IAsTypeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsTypeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsTypeClauseContext)
}

func (s *PropertyGetStmtContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *PropertyGetStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyGetStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyGetStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterPropertyGetStmt(s)
	}
}

func (s *PropertyGetStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitPropertyGetStmt(s)
	}
}

func (p *vbaParser) PropertyGetStmt() (localctx IPropertyGetStmtContext) {
	this := p
	_ = this

	localctx = NewPropertyGetStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, vbaParserRULE_propertyGetStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1356)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserFRIEND || _la == vbaParserGLOBAL || _la == vbaParserPRIVATE || _la == vbaParserPUBLIC {
		{
			p.SetState(1353)
			p.Visibility()
		}
		{
			p.SetState(1354)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(1360)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserSTATIC {
		{
			p.SetState(1358)
			p.Match(vbaParserSTATIC)
		}
		{
			p.SetState(1359)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1362)
		p.Match(vbaParserPROPERTY_GET)
	}
	{
		p.SetState(1363)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1364)
		p.AmbiguousIdentifier()
	}
	p.SetState(1366)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1365)
			p.TypeHint()
		}

	}
	p.SetState(1372)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext()) == 1 {
		p.SetState(1369)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1368)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1371)
			p.ArgList()
		}

	}
	p.SetState(1376)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1374)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(1375)
			p.AsTypeClause()
		}

	}
	{
		p.SetState(1378)
		p.EndOfStatement()
	}
	p.SetState(1380)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserEXIT_DO-64))|(1<<(vbaParserEXIT_FOR-64))|(1<<(vbaParserEXIT_FUNCTION-64))|(1<<(vbaParserEXIT_PROPERTY-64))|(1<<(vbaParserEXIT_SUB-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLINE_INPUT-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserMACRO_CONST-96))|(1<<(vbaParserMACRO_IF-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserON_ERROR-96))|(1<<(vbaParserON_LOCAL_ERROR-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || _la == vbaParserIDENTIFIER {
		{
			p.SetState(1379)
			p.Block()
		}

	}
	{
		p.SetState(1382)
		p.Match(vbaParserEND_PROPERTY)
	}

	return localctx
}

// IPropertySetStmtContext is an interface to support dynamic dispatch.
type IPropertySetStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertySetStmtContext differentiates from other interfaces.
	IsPropertySetStmtContext()
}

type PropertySetStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertySetStmtContext() *PropertySetStmtContext {
	var p = new(PropertySetStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_propertySetStmt
	return p
}

func (*PropertySetStmtContext) IsPropertySetStmtContext() {}

func NewPropertySetStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertySetStmtContext {
	var p = new(PropertySetStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_propertySetStmt

	return p
}

func (s *PropertySetStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertySetStmtContext) PROPERTY_SET() antlr.TerminalNode {
	return s.GetToken(vbaParserPROPERTY_SET, 0)
}

func (s *PropertySetStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *PropertySetStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *PropertySetStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *PropertySetStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *PropertySetStmtContext) END_PROPERTY() antlr.TerminalNode {
	return s.GetToken(vbaParserEND_PROPERTY, 0)
}

func (s *PropertySetStmtContext) Visibility() IVisibilityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibilityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *PropertySetStmtContext) STATIC() antlr.TerminalNode {
	return s.GetToken(vbaParserSTATIC, 0)
}

func (s *PropertySetStmtContext) ArgList() IArgListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgListContext)
}

func (s *PropertySetStmtContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *PropertySetStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertySetStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertySetStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterPropertySetStmt(s)
	}
}

func (s *PropertySetStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitPropertySetStmt(s)
	}
}

func (p *vbaParser) PropertySetStmt() (localctx IPropertySetStmtContext) {
	this := p
	_ = this

	localctx = NewPropertySetStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, vbaParserRULE_propertySetStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1387)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserFRIEND || _la == vbaParserGLOBAL || _la == vbaParserPRIVATE || _la == vbaParserPUBLIC {
		{
			p.SetState(1384)
			p.Visibility()
		}
		{
			p.SetState(1385)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(1391)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserSTATIC {
		{
			p.SetState(1389)
			p.Match(vbaParserSTATIC)
		}
		{
			p.SetState(1390)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1393)
		p.Match(vbaParserPROPERTY_SET)
	}
	{
		p.SetState(1394)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1395)
		p.AmbiguousIdentifier()
	}
	p.SetState(1400)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext()) == 1 {
		p.SetState(1397)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1396)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1399)
			p.ArgList()
		}

	}
	{
		p.SetState(1402)
		p.EndOfStatement()
	}
	p.SetState(1404)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserEXIT_DO-64))|(1<<(vbaParserEXIT_FOR-64))|(1<<(vbaParserEXIT_FUNCTION-64))|(1<<(vbaParserEXIT_PROPERTY-64))|(1<<(vbaParserEXIT_SUB-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLINE_INPUT-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserMACRO_CONST-96))|(1<<(vbaParserMACRO_IF-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserON_ERROR-96))|(1<<(vbaParserON_LOCAL_ERROR-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || _la == vbaParserIDENTIFIER {
		{
			p.SetState(1403)
			p.Block()
		}

	}
	{
		p.SetState(1406)
		p.Match(vbaParserEND_PROPERTY)
	}

	return localctx
}

// IPropertyLetStmtContext is an interface to support dynamic dispatch.
type IPropertyLetStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyLetStmtContext differentiates from other interfaces.
	IsPropertyLetStmtContext()
}

type PropertyLetStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyLetStmtContext() *PropertyLetStmtContext {
	var p = new(PropertyLetStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_propertyLetStmt
	return p
}

func (*PropertyLetStmtContext) IsPropertyLetStmtContext() {}

func NewPropertyLetStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyLetStmtContext {
	var p = new(PropertyLetStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_propertyLetStmt

	return p
}

func (s *PropertyLetStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyLetStmtContext) PROPERTY_LET() antlr.TerminalNode {
	return s.GetToken(vbaParserPROPERTY_LET, 0)
}

func (s *PropertyLetStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *PropertyLetStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *PropertyLetStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *PropertyLetStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *PropertyLetStmtContext) END_PROPERTY() antlr.TerminalNode {
	return s.GetToken(vbaParserEND_PROPERTY, 0)
}

func (s *PropertyLetStmtContext) Visibility() IVisibilityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibilityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *PropertyLetStmtContext) STATIC() antlr.TerminalNode {
	return s.GetToken(vbaParserSTATIC, 0)
}

func (s *PropertyLetStmtContext) ArgList() IArgListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgListContext)
}

func (s *PropertyLetStmtContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *PropertyLetStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyLetStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyLetStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterPropertyLetStmt(s)
	}
}

func (s *PropertyLetStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitPropertyLetStmt(s)
	}
}

func (p *vbaParser) PropertyLetStmt() (localctx IPropertyLetStmtContext) {
	this := p
	_ = this

	localctx = NewPropertyLetStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, vbaParserRULE_propertyLetStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1411)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserFRIEND || _la == vbaParserGLOBAL || _la == vbaParserPRIVATE || _la == vbaParserPUBLIC {
		{
			p.SetState(1408)
			p.Visibility()
		}
		{
			p.SetState(1409)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(1415)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserSTATIC {
		{
			p.SetState(1413)
			p.Match(vbaParserSTATIC)
		}
		{
			p.SetState(1414)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1417)
		p.Match(vbaParserPROPERTY_LET)
	}
	{
		p.SetState(1418)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1419)
		p.AmbiguousIdentifier()
	}
	p.SetState(1424)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
		p.SetState(1421)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1420)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1423)
			p.ArgList()
		}

	}
	{
		p.SetState(1426)
		p.EndOfStatement()
	}
	p.SetState(1428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserEXIT_DO-64))|(1<<(vbaParserEXIT_FOR-64))|(1<<(vbaParserEXIT_FUNCTION-64))|(1<<(vbaParserEXIT_PROPERTY-64))|(1<<(vbaParserEXIT_SUB-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLINE_INPUT-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserMACRO_CONST-96))|(1<<(vbaParserMACRO_IF-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserON_ERROR-96))|(1<<(vbaParserON_LOCAL_ERROR-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || _la == vbaParserIDENTIFIER {
		{
			p.SetState(1427)
			p.Block()
		}

	}
	{
		p.SetState(1430)
		p.Match(vbaParserEND_PROPERTY)
	}

	return localctx
}

// IPutStmtContext is an interface to support dynamic dispatch.
type IPutStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPutStmtContext differentiates from other interfaces.
	IsPutStmtContext()
}

type PutStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPutStmtContext() *PutStmtContext {
	var p = new(PutStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_putStmt
	return p
}

func (*PutStmtContext) IsPutStmtContext() {}

func NewPutStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PutStmtContext {
	var p = new(PutStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_putStmt

	return p
}

func (s *PutStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PutStmtContext) PUT() antlr.TerminalNode {
	return s.GetToken(vbaParserPUT, 0)
}

func (s *PutStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *PutStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *PutStmtContext) FileNumber() IFileNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNumberContext)
}

func (s *PutStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *PutStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *PutStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PutStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PutStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterPutStmt(s)
	}
}

func (s *PutStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitPutStmt(s)
	}
}

func (p *vbaParser) PutStmt() (localctx IPutStmtContext) {
	this := p
	_ = this

	localctx = NewPutStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, vbaParserRULE_putStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1432)
		p.Match(vbaParserPUT)
	}
	{
		p.SetState(1433)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1434)
		p.FileNumber()
	}
	p.SetState(1436)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1435)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1438)
		p.Match(vbaParserT__0)
	}
	p.SetState(1440)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1439)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(1443)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || (((_la-193)&-(0x1f+1)) == 0 && ((1<<uint((_la-193)))&((1<<(vbaParserLPAREN-193))|(1<<(vbaParserMINUS-193))|(1<<(vbaParserPLUS-193))|(1<<(vbaParserSTRINGLITERAL-193))|(1<<(vbaParserOCTLITERAL-193))|(1<<(vbaParserHEXLITERAL-193))|(1<<(vbaParserSHORTLITERAL-193))|(1<<(vbaParserINTEGERLITERAL-193))|(1<<(vbaParserDOUBLELITERAL-193))|(1<<(vbaParserDATELITERAL-193))|(1<<(vbaParserIDENTIFIER-193)))) != 0) {
		{
			p.SetState(1442)
			p.valueStmt(0)
		}

	}
	p.SetState(1446)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1445)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1448)
		p.Match(vbaParserT__0)
	}
	p.SetState(1450)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1449)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1452)
		p.valueStmt(0)
	}

	return localctx
}

// IRaiseEventStmtContext is an interface to support dynamic dispatch.
type IRaiseEventStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRaiseEventStmtContext differentiates from other interfaces.
	IsRaiseEventStmtContext()
}

type RaiseEventStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaiseEventStmtContext() *RaiseEventStmtContext {
	var p = new(RaiseEventStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_raiseEventStmt
	return p
}

func (*RaiseEventStmtContext) IsRaiseEventStmtContext() {}

func NewRaiseEventStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RaiseEventStmtContext {
	var p = new(RaiseEventStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_raiseEventStmt

	return p
}

func (s *RaiseEventStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RaiseEventStmtContext) RAISEEVENT() antlr.TerminalNode {
	return s.GetToken(vbaParserRAISEEVENT, 0)
}

func (s *RaiseEventStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *RaiseEventStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *RaiseEventStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *RaiseEventStmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, 0)
}

func (s *RaiseEventStmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, 0)
}

func (s *RaiseEventStmtContext) ArgsCall() IArgsCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgsCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgsCallContext)
}

func (s *RaiseEventStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RaiseEventStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RaiseEventStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterRaiseEventStmt(s)
	}
}

func (s *RaiseEventStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitRaiseEventStmt(s)
	}
}

func (p *vbaParser) RaiseEventStmt() (localctx IRaiseEventStmtContext) {
	this := p
	_ = this

	localctx = NewRaiseEventStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, vbaParserRULE_raiseEventStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1454)
		p.Match(vbaParserRAISEEVENT)
	}
	{
		p.SetState(1455)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1456)
		p.AmbiguousIdentifier()
	}
	p.SetState(1471)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 202, p.GetParserRuleContext()) == 1 {
		p.SetState(1458)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1457)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1460)
			p.Match(vbaParserLPAREN)
		}
		p.SetState(1462)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 199, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1461)
				p.Match(vbaParserWS)
			}

		}
		p.SetState(1468)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1464)
				p.ArgsCall()
			}
			p.SetState(1466)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(1465)
					p.Match(vbaParserWS)
				}

			}

		}
		{
			p.SetState(1470)
			p.Match(vbaParserRPAREN)
		}

	}

	return localctx
}

// IRandomizeStmtContext is an interface to support dynamic dispatch.
type IRandomizeStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRandomizeStmtContext differentiates from other interfaces.
	IsRandomizeStmtContext()
}

type RandomizeStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRandomizeStmtContext() *RandomizeStmtContext {
	var p = new(RandomizeStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_randomizeStmt
	return p
}

func (*RandomizeStmtContext) IsRandomizeStmtContext() {}

func NewRandomizeStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RandomizeStmtContext {
	var p = new(RandomizeStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_randomizeStmt

	return p
}

func (s *RandomizeStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RandomizeStmtContext) RANDOMIZE() antlr.TerminalNode {
	return s.GetToken(vbaParserRANDOMIZE, 0)
}

func (s *RandomizeStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *RandomizeStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *RandomizeStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RandomizeStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RandomizeStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterRandomizeStmt(s)
	}
}

func (s *RandomizeStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitRandomizeStmt(s)
	}
}

func (p *vbaParser) RandomizeStmt() (localctx IRandomizeStmtContext) {
	this := p
	_ = this

	localctx = NewRandomizeStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, vbaParserRULE_randomizeStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1473)
		p.Match(vbaParserRANDOMIZE)
	}
	p.SetState(1476)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1474)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(1475)
			p.valueStmt(0)
		}

	}

	return localctx
}

// IRedimStmtContext is an interface to support dynamic dispatch.
type IRedimStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRedimStmtContext differentiates from other interfaces.
	IsRedimStmtContext()
}

type RedimStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRedimStmtContext() *RedimStmtContext {
	var p = new(RedimStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_redimStmt
	return p
}

func (*RedimStmtContext) IsRedimStmtContext() {}

func NewRedimStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RedimStmtContext {
	var p = new(RedimStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_redimStmt

	return p
}

func (s *RedimStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RedimStmtContext) REDIM() antlr.TerminalNode {
	return s.GetToken(vbaParserREDIM, 0)
}

func (s *RedimStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *RedimStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *RedimStmtContext) AllRedimSubStmt() []IRedimSubStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRedimSubStmtContext)(nil)).Elem())
	var tst = make([]IRedimSubStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRedimSubStmtContext)
		}
	}

	return tst
}

func (s *RedimStmtContext) RedimSubStmt(i int) IRedimSubStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRedimSubStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRedimSubStmtContext)
}

func (s *RedimStmtContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(vbaParserPRESERVE, 0)
}

func (s *RedimStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RedimStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RedimStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterRedimStmt(s)
	}
}

func (s *RedimStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitRedimStmt(s)
	}
}

func (p *vbaParser) RedimStmt() (localctx IRedimStmtContext) {
	this := p
	_ = this

	localctx = NewRedimStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, vbaParserRULE_redimStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1478)
		p.Match(vbaParserREDIM)
	}
	{
		p.SetState(1479)
		p.Match(vbaParserWS)
	}
	p.SetState(1482)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1480)
			p.Match(vbaParserPRESERVE)
		}
		{
			p.SetState(1481)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1484)
		p.RedimSubStmt()
	}
	p.SetState(1495)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1486)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(1485)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(1488)
				p.Match(vbaParserT__0)
			}
			p.SetState(1490)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(1489)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(1492)
				p.RedimSubStmt()
			}

		}
		p.SetState(1497)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext())
	}

	return localctx
}

// IRedimSubStmtContext is an interface to support dynamic dispatch.
type IRedimSubStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRedimSubStmtContext differentiates from other interfaces.
	IsRedimSubStmtContext()
}

type RedimSubStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRedimSubStmtContext() *RedimSubStmtContext {
	var p = new(RedimSubStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_redimSubStmt
	return p
}

func (*RedimSubStmtContext) IsRedimSubStmtContext() {}

func NewRedimSubStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RedimSubStmtContext {
	var p = new(RedimSubStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_redimSubStmt

	return p
}

func (s *RedimSubStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RedimSubStmtContext) ImplicitCallStmt_InStmt() IImplicitCallStmt_InStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitCallStmt_InStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitCallStmt_InStmtContext)
}

func (s *RedimSubStmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, 0)
}

func (s *RedimSubStmtContext) Subscripts() ISubscriptsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubscriptsContext)
}

func (s *RedimSubStmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, 0)
}

func (s *RedimSubStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *RedimSubStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *RedimSubStmtContext) AsTypeClause() IAsTypeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsTypeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsTypeClauseContext)
}

func (s *RedimSubStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RedimSubStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RedimSubStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterRedimSubStmt(s)
	}
}

func (s *RedimSubStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitRedimSubStmt(s)
	}
}

func (p *vbaParser) RedimSubStmt() (localctx IRedimSubStmtContext) {
	this := p
	_ = this

	localctx = NewRedimSubStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, vbaParserRULE_redimSubStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1498)
		p.ImplicitCallStmt_InStmt()
	}
	p.SetState(1500)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1499)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1502)
		p.Match(vbaParserLPAREN)
	}
	p.SetState(1504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1503)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1506)
		p.Subscripts()
	}
	p.SetState(1508)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1507)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1510)
		p.Match(vbaParserRPAREN)
	}
	p.SetState(1513)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 211, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1511)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(1512)
			p.AsTypeClause()
		}

	}

	return localctx
}

// IResetStmtContext is an interface to support dynamic dispatch.
type IResetStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResetStmtContext differentiates from other interfaces.
	IsResetStmtContext()
}

type ResetStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetStmtContext() *ResetStmtContext {
	var p = new(ResetStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_resetStmt
	return p
}

func (*ResetStmtContext) IsResetStmtContext() {}

func NewResetStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetStmtContext {
	var p = new(ResetStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_resetStmt

	return p
}

func (s *ResetStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetStmtContext) RESET() antlr.TerminalNode {
	return s.GetToken(vbaParserRESET, 0)
}

func (s *ResetStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterResetStmt(s)
	}
}

func (s *ResetStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitResetStmt(s)
	}
}

func (p *vbaParser) ResetStmt() (localctx IResetStmtContext) {
	this := p
	_ = this

	localctx = NewResetStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, vbaParserRULE_resetStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1515)
		p.Match(vbaParserRESET)
	}

	return localctx
}

// IResumeStmtContext is an interface to support dynamic dispatch.
type IResumeStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResumeStmtContext differentiates from other interfaces.
	IsResumeStmtContext()
}

type ResumeStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResumeStmtContext() *ResumeStmtContext {
	var p = new(ResumeStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_resumeStmt
	return p
}

func (*ResumeStmtContext) IsResumeStmtContext() {}

func NewResumeStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResumeStmtContext {
	var p = new(ResumeStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_resumeStmt

	return p
}

func (s *ResumeStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ResumeStmtContext) RESUME() antlr.TerminalNode {
	return s.GetToken(vbaParserRESUME, 0)
}

func (s *ResumeStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *ResumeStmtContext) NEXT() antlr.TerminalNode {
	return s.GetToken(vbaParserNEXT, 0)
}

func (s *ResumeStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *ResumeStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResumeStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterResumeStmt(s)
	}
}

func (s *ResumeStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitResumeStmt(s)
	}
}

func (p *vbaParser) ResumeStmt() (localctx IResumeStmtContext) {
	this := p
	_ = this

	localctx = NewResumeStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, vbaParserRULE_resumeStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1517)
		p.Match(vbaParserRESUME)
	}
	p.SetState(1523)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1518)
			p.Match(vbaParserWS)
		}
		p.SetState(1521)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 212, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1519)
				p.Match(vbaParserNEXT)
			}

		case 2:
			{
				p.SetState(1520)
				p.AmbiguousIdentifier()
			}

		}

	}

	return localctx
}

// IReturnStmtContext is an interface to support dynamic dispatch.
type IReturnStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStmtContext differentiates from other interfaces.
	IsReturnStmtContext()
}

type ReturnStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStmtContext() *ReturnStmtContext {
	var p = new(ReturnStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_returnStmt
	return p
}

func (*ReturnStmtContext) IsReturnStmtContext() {}

func NewReturnStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStmtContext {
	var p = new(ReturnStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_returnStmt

	return p
}

func (s *ReturnStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(vbaParserRETURN, 0)
}

func (s *ReturnStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterReturnStmt(s)
	}
}

func (s *ReturnStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitReturnStmt(s)
	}
}

func (p *vbaParser) ReturnStmt() (localctx IReturnStmtContext) {
	this := p
	_ = this

	localctx = NewReturnStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, vbaParserRULE_returnStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1525)
		p.Match(vbaParserRETURN)
	}

	return localctx
}

// IRmdirStmtContext is an interface to support dynamic dispatch.
type IRmdirStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRmdirStmtContext differentiates from other interfaces.
	IsRmdirStmtContext()
}

type RmdirStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRmdirStmtContext() *RmdirStmtContext {
	var p = new(RmdirStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_rmdirStmt
	return p
}

func (*RmdirStmtContext) IsRmdirStmtContext() {}

func NewRmdirStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RmdirStmtContext {
	var p = new(RmdirStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_rmdirStmt

	return p
}

func (s *RmdirStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RmdirStmtContext) RMDIR() antlr.TerminalNode {
	return s.GetToken(vbaParserRMDIR, 0)
}

func (s *RmdirStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *RmdirStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *RmdirStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RmdirStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RmdirStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterRmdirStmt(s)
	}
}

func (s *RmdirStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitRmdirStmt(s)
	}
}

func (p *vbaParser) RmdirStmt() (localctx IRmdirStmtContext) {
	this := p
	_ = this

	localctx = NewRmdirStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, vbaParserRULE_rmdirStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1527)
		p.Match(vbaParserRMDIR)
	}
	{
		p.SetState(1528)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1529)
		p.valueStmt(0)
	}

	return localctx
}

// IRsetStmtContext is an interface to support dynamic dispatch.
type IRsetStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRsetStmtContext differentiates from other interfaces.
	IsRsetStmtContext()
}

type RsetStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRsetStmtContext() *RsetStmtContext {
	var p = new(RsetStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_rsetStmt
	return p
}

func (*RsetStmtContext) IsRsetStmtContext() {}

func NewRsetStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RsetStmtContext {
	var p = new(RsetStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_rsetStmt

	return p
}

func (s *RsetStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RsetStmtContext) RSET() antlr.TerminalNode {
	return s.GetToken(vbaParserRSET, 0)
}

func (s *RsetStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *RsetStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *RsetStmtContext) ImplicitCallStmt_InStmt() IImplicitCallStmt_InStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitCallStmt_InStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitCallStmt_InStmtContext)
}

func (s *RsetStmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *RsetStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *RsetStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RsetStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RsetStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterRsetStmt(s)
	}
}

func (s *RsetStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitRsetStmt(s)
	}
}

func (p *vbaParser) RsetStmt() (localctx IRsetStmtContext) {
	this := p
	_ = this

	localctx = NewRsetStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, vbaParserRULE_rsetStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1531)
		p.Match(vbaParserRSET)
	}
	{
		p.SetState(1532)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1533)
		p.ImplicitCallStmt_InStmt()
	}
	p.SetState(1535)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1534)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1537)
		p.Match(vbaParserEQ)
	}
	p.SetState(1539)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1538)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1541)
		p.valueStmt(0)
	}

	return localctx
}

// ISavepictureStmtContext is an interface to support dynamic dispatch.
type ISavepictureStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSavepictureStmtContext differentiates from other interfaces.
	IsSavepictureStmtContext()
}

type SavepictureStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySavepictureStmtContext() *SavepictureStmtContext {
	var p = new(SavepictureStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_savepictureStmt
	return p
}

func (*SavepictureStmtContext) IsSavepictureStmtContext() {}

func NewSavepictureStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SavepictureStmtContext {
	var p = new(SavepictureStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_savepictureStmt

	return p
}

func (s *SavepictureStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SavepictureStmtContext) SAVEPICTURE() antlr.TerminalNode {
	return s.GetToken(vbaParserSAVEPICTURE, 0)
}

func (s *SavepictureStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *SavepictureStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *SavepictureStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *SavepictureStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *SavepictureStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SavepictureStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SavepictureStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterSavepictureStmt(s)
	}
}

func (s *SavepictureStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitSavepictureStmt(s)
	}
}

func (p *vbaParser) SavepictureStmt() (localctx ISavepictureStmtContext) {
	this := p
	_ = this

	localctx = NewSavepictureStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, vbaParserRULE_savepictureStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1543)
		p.Match(vbaParserSAVEPICTURE)
	}
	{
		p.SetState(1544)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1545)
		p.valueStmt(0)
	}
	p.SetState(1547)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1546)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1549)
		p.Match(vbaParserT__0)
	}
	p.SetState(1551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1550)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1553)
		p.valueStmt(0)
	}

	return localctx
}

// ISaveSettingStmtContext is an interface to support dynamic dispatch.
type ISaveSettingStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSaveSettingStmtContext differentiates from other interfaces.
	IsSaveSettingStmtContext()
}

type SaveSettingStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySaveSettingStmtContext() *SaveSettingStmtContext {
	var p = new(SaveSettingStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_saveSettingStmt
	return p
}

func (*SaveSettingStmtContext) IsSaveSettingStmtContext() {}

func NewSaveSettingStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SaveSettingStmtContext {
	var p = new(SaveSettingStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_saveSettingStmt

	return p
}

func (s *SaveSettingStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SaveSettingStmtContext) SAVESETTING() antlr.TerminalNode {
	return s.GetToken(vbaParserSAVESETTING, 0)
}

func (s *SaveSettingStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *SaveSettingStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *SaveSettingStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *SaveSettingStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *SaveSettingStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SaveSettingStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SaveSettingStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterSaveSettingStmt(s)
	}
}

func (s *SaveSettingStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitSaveSettingStmt(s)
	}
}

func (p *vbaParser) SaveSettingStmt() (localctx ISaveSettingStmtContext) {
	this := p
	_ = this

	localctx = NewSaveSettingStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, vbaParserRULE_saveSettingStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1555)
		p.Match(vbaParserSAVESETTING)
	}
	{
		p.SetState(1556)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1557)
		p.valueStmt(0)
	}
	p.SetState(1559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1558)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1561)
		p.Match(vbaParserT__0)
	}
	p.SetState(1563)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1562)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1565)
		p.valueStmt(0)
	}
	p.SetState(1567)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1566)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1569)
		p.Match(vbaParserT__0)
	}
	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1570)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1573)
		p.valueStmt(0)
	}
	p.SetState(1575)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1574)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1577)
		p.Match(vbaParserT__0)
	}
	p.SetState(1579)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1578)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1581)
		p.valueStmt(0)
	}

	return localctx
}

// ISeekStmtContext is an interface to support dynamic dispatch.
type ISeekStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeekStmtContext differentiates from other interfaces.
	IsSeekStmtContext()
}

type SeekStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeekStmtContext() *SeekStmtContext {
	var p = new(SeekStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_seekStmt
	return p
}

func (*SeekStmtContext) IsSeekStmtContext() {}

func NewSeekStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SeekStmtContext {
	var p = new(SeekStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_seekStmt

	return p
}

func (s *SeekStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SeekStmtContext) SEEK() antlr.TerminalNode {
	return s.GetToken(vbaParserSEEK, 0)
}

func (s *SeekStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *SeekStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *SeekStmtContext) FileNumber() IFileNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNumberContext)
}

func (s *SeekStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *SeekStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SeekStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SeekStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterSeekStmt(s)
	}
}

func (s *SeekStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitSeekStmt(s)
	}
}

func (p *vbaParser) SeekStmt() (localctx ISeekStmtContext) {
	this := p
	_ = this

	localctx = NewSeekStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, vbaParserRULE_seekStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1583)
		p.Match(vbaParserSEEK)
	}
	{
		p.SetState(1584)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1585)
		p.FileNumber()
	}
	p.SetState(1587)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1586)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1589)
		p.Match(vbaParserT__0)
	}
	p.SetState(1591)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1590)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1593)
		p.valueStmt(0)
	}

	return localctx
}

// ISelectCaseStmtContext is an interface to support dynamic dispatch.
type ISelectCaseStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectCaseStmtContext differentiates from other interfaces.
	IsSelectCaseStmtContext()
}

type SelectCaseStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectCaseStmtContext() *SelectCaseStmtContext {
	var p = new(SelectCaseStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_selectCaseStmt
	return p
}

func (*SelectCaseStmtContext) IsSelectCaseStmtContext() {}

func NewSelectCaseStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectCaseStmtContext {
	var p = new(SelectCaseStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_selectCaseStmt

	return p
}

func (s *SelectCaseStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectCaseStmtContext) SELECT() antlr.TerminalNode {
	return s.GetToken(vbaParserSELECT, 0)
}

func (s *SelectCaseStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *SelectCaseStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *SelectCaseStmtContext) CASE() antlr.TerminalNode {
	return s.GetToken(vbaParserCASE, 0)
}

func (s *SelectCaseStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *SelectCaseStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *SelectCaseStmtContext) END_SELECT() antlr.TerminalNode {
	return s.GetToken(vbaParserEND_SELECT, 0)
}

func (s *SelectCaseStmtContext) AllSC_Case() []ISC_CaseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISC_CaseContext)(nil)).Elem())
	var tst = make([]ISC_CaseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISC_CaseContext)
		}
	}

	return tst
}

func (s *SelectCaseStmtContext) SC_Case(i int) ISC_CaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISC_CaseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISC_CaseContext)
}

func (s *SelectCaseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectCaseStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectCaseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterSelectCaseStmt(s)
	}
}

func (s *SelectCaseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitSelectCaseStmt(s)
	}
}

func (p *vbaParser) SelectCaseStmt() (localctx ISelectCaseStmtContext) {
	this := p
	_ = this

	localctx = NewSelectCaseStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, vbaParserRULE_selectCaseStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1595)
		p.Match(vbaParserSELECT)
	}
	{
		p.SetState(1596)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1597)
		p.Match(vbaParserCASE)
	}
	{
		p.SetState(1598)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1599)
		p.valueStmt(0)
	}
	{
		p.SetState(1600)
		p.EndOfStatement()
	}
	p.SetState(1604)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vbaParserCASE {
		{
			p.SetState(1601)
			p.SC_Case()
		}

		p.SetState(1606)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1607)
		p.Match(vbaParserEND_SELECT)
	}

	return localctx
}

// ISC_SelectionContext is an interface to support dynamic dispatch.
type ISC_SelectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSC_SelectionContext differentiates from other interfaces.
	IsSC_SelectionContext()
}

type SC_SelectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySC_SelectionContext() *SC_SelectionContext {
	var p = new(SC_SelectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_sC_Selection
	return p
}

func (*SC_SelectionContext) IsSC_SelectionContext() {}

func NewSC_SelectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SC_SelectionContext {
	var p = new(SC_SelectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_sC_Selection

	return p
}

func (s *SC_SelectionContext) GetParser() antlr.Parser { return s.parser }

func (s *SC_SelectionContext) CopyFrom(ctx *SC_SelectionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SC_SelectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SC_SelectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CaseCondValueContext struct {
	*SC_SelectionContext
}

func NewCaseCondValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseCondValueContext {
	var p = new(CaseCondValueContext)

	p.SC_SelectionContext = NewEmptySC_SelectionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SC_SelectionContext))

	return p
}

func (s *CaseCondValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseCondValueContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *CaseCondValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterCaseCondValue(s)
	}
}

func (s *CaseCondValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitCaseCondValue(s)
	}
}

type CaseCondToContext struct {
	*SC_SelectionContext
}

func NewCaseCondToContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseCondToContext {
	var p = new(CaseCondToContext)

	p.SC_SelectionContext = NewEmptySC_SelectionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SC_SelectionContext))

	return p
}

func (s *CaseCondToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseCondToContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *CaseCondToContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *CaseCondToContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *CaseCondToContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *CaseCondToContext) TO() antlr.TerminalNode {
	return s.GetToken(vbaParserTO, 0)
}

func (s *CaseCondToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterCaseCondTo(s)
	}
}

func (s *CaseCondToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitCaseCondTo(s)
	}
}

type CaseCondIsContext struct {
	*SC_SelectionContext
}

func NewCaseCondIsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseCondIsContext {
	var p = new(CaseCondIsContext)

	p.SC_SelectionContext = NewEmptySC_SelectionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SC_SelectionContext))

	return p
}

func (s *CaseCondIsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseCondIsContext) IS() antlr.TerminalNode {
	return s.GetToken(vbaParserIS, 0)
}

func (s *CaseCondIsContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *CaseCondIsContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *CaseCondIsContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *CaseCondIsContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *CaseCondIsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterCaseCondIs(s)
	}
}

func (s *CaseCondIsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitCaseCondIs(s)
	}
}

func (p *vbaParser) SC_Selection() (localctx ISC_SelectionContext) {
	this := p
	_ = this

	localctx = NewSC_SelectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, vbaParserRULE_sC_Selection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1626)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCaseCondIsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1609)
			p.Match(vbaParserIS)
		}
		p.SetState(1611)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1610)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1613)
			p.ComparisonOperator()
		}
		p.SetState(1615)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1614)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1617)
			p.valueStmt(0)
		}

	case 2:
		localctx = NewCaseCondToContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1619)
			p.valueStmt(0)
		}
		{
			p.SetState(1620)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(1621)
			p.Match(vbaParserTO)
		}
		{
			p.SetState(1622)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(1623)
			p.valueStmt(0)
		}

	case 3:
		localctx = NewCaseCondValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1625)
			p.valueStmt(0)
		}

	}

	return localctx
}

// ISC_CaseContext is an interface to support dynamic dispatch.
type ISC_CaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSC_CaseContext differentiates from other interfaces.
	IsSC_CaseContext()
}

type SC_CaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySC_CaseContext() *SC_CaseContext {
	var p = new(SC_CaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_sC_Case
	return p
}

func (*SC_CaseContext) IsSC_CaseContext() {}

func NewSC_CaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SC_CaseContext {
	var p = new(SC_CaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_sC_Case

	return p
}

func (s *SC_CaseContext) GetParser() antlr.Parser { return s.parser }

func (s *SC_CaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(vbaParserCASE, 0)
}

func (s *SC_CaseContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *SC_CaseContext) SC_Cond() ISC_CondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISC_CondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISC_CondContext)
}

func (s *SC_CaseContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *SC_CaseContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SC_CaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SC_CaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SC_CaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterSC_Case(s)
	}
}

func (s *SC_CaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitSC_Case(s)
	}
}

func (p *vbaParser) SC_Case() (localctx ISC_CaseContext) {
	this := p
	_ = this

	localctx = NewSC_CaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, vbaParserRULE_sC_Case)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1628)
		p.Match(vbaParserCASE)
	}
	{
		p.SetState(1629)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1630)
		p.SC_Cond()
	}
	{
		p.SetState(1631)
		p.EndOfStatement()
	}
	p.SetState(1633)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 230, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1632)
			p.Block()
		}

	}

	return localctx
}

// ISC_CondContext is an interface to support dynamic dispatch.
type ISC_CondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSC_CondContext differentiates from other interfaces.
	IsSC_CondContext()
}

type SC_CondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySC_CondContext() *SC_CondContext {
	var p = new(SC_CondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_sC_Cond
	return p
}

func (*SC_CondContext) IsSC_CondContext() {}

func NewSC_CondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SC_CondContext {
	var p = new(SC_CondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_sC_Cond

	return p
}

func (s *SC_CondContext) GetParser() antlr.Parser { return s.parser }

func (s *SC_CondContext) CopyFrom(ctx *SC_CondContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SC_CondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SC_CondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CaseCondSelectionContext struct {
	*SC_CondContext
}

func NewCaseCondSelectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseCondSelectionContext {
	var p = new(CaseCondSelectionContext)

	p.SC_CondContext = NewEmptySC_CondContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SC_CondContext))

	return p
}

func (s *CaseCondSelectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseCondSelectionContext) AllSC_Selection() []ISC_SelectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISC_SelectionContext)(nil)).Elem())
	var tst = make([]ISC_SelectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISC_SelectionContext)
		}
	}

	return tst
}

func (s *CaseCondSelectionContext) SC_Selection(i int) ISC_SelectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISC_SelectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISC_SelectionContext)
}

func (s *CaseCondSelectionContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *CaseCondSelectionContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *CaseCondSelectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterCaseCondSelection(s)
	}
}

func (s *CaseCondSelectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitCaseCondSelection(s)
	}
}

type CaseCondElseContext struct {
	*SC_CondContext
}

func NewCaseCondElseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseCondElseContext {
	var p = new(CaseCondElseContext)

	p.SC_CondContext = NewEmptySC_CondContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SC_CondContext))

	return p
}

func (s *CaseCondElseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseCondElseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(vbaParserELSE, 0)
}

func (s *CaseCondElseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterCaseCondElse(s)
	}
}

func (s *CaseCondElseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitCaseCondElse(s)
	}
}

func (p *vbaParser) SC_Cond() (localctx ISC_CondContext) {
	this := p
	_ = this

	localctx = NewSC_CondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, vbaParserRULE_sC_Cond)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1650)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 234, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCaseCondElseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1635)
			p.Match(vbaParserELSE)
		}

	case 2:
		localctx = NewCaseCondSelectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1636)
			p.SC_Selection()
		}
		p.SetState(1647)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1638)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1637)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1640)
					p.Match(vbaParserT__0)
				}
				p.SetState(1642)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1641)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1644)
					p.SC_Selection()
				}

			}
			p.SetState(1649)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext())
		}

	}

	return localctx
}

// ISendkeysStmtContext is an interface to support dynamic dispatch.
type ISendkeysStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendkeysStmtContext differentiates from other interfaces.
	IsSendkeysStmtContext()
}

type SendkeysStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendkeysStmtContext() *SendkeysStmtContext {
	var p = new(SendkeysStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_sendkeysStmt
	return p
}

func (*SendkeysStmtContext) IsSendkeysStmtContext() {}

func NewSendkeysStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendkeysStmtContext {
	var p = new(SendkeysStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_sendkeysStmt

	return p
}

func (s *SendkeysStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SendkeysStmtContext) SENDKEYS() antlr.TerminalNode {
	return s.GetToken(vbaParserSENDKEYS, 0)
}

func (s *SendkeysStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *SendkeysStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *SendkeysStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *SendkeysStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *SendkeysStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendkeysStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendkeysStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterSendkeysStmt(s)
	}
}

func (s *SendkeysStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitSendkeysStmt(s)
	}
}

func (p *vbaParser) SendkeysStmt() (localctx ISendkeysStmtContext) {
	this := p
	_ = this

	localctx = NewSendkeysStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, vbaParserRULE_sendkeysStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1652)
		p.Match(vbaParserSENDKEYS)
	}
	{
		p.SetState(1653)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1654)
		p.valueStmt(0)
	}
	p.SetState(1663)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 237, p.GetParserRuleContext()) == 1 {
		p.SetState(1656)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1655)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1658)
			p.Match(vbaParserT__0)
		}
		p.SetState(1660)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1659)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1662)
			p.valueStmt(0)
		}

	}

	return localctx
}

// ISetattrStmtContext is an interface to support dynamic dispatch.
type ISetattrStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetattrStmtContext differentiates from other interfaces.
	IsSetattrStmtContext()
}

type SetattrStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetattrStmtContext() *SetattrStmtContext {
	var p = new(SetattrStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_setattrStmt
	return p
}

func (*SetattrStmtContext) IsSetattrStmtContext() {}

func NewSetattrStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetattrStmtContext {
	var p = new(SetattrStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_setattrStmt

	return p
}

func (s *SetattrStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SetattrStmtContext) SETATTR() antlr.TerminalNode {
	return s.GetToken(vbaParserSETATTR, 0)
}

func (s *SetattrStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *SetattrStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *SetattrStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *SetattrStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *SetattrStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetattrStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetattrStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterSetattrStmt(s)
	}
}

func (s *SetattrStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitSetattrStmt(s)
	}
}

func (p *vbaParser) SetattrStmt() (localctx ISetattrStmtContext) {
	this := p
	_ = this

	localctx = NewSetattrStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, vbaParserRULE_setattrStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1665)
		p.Match(vbaParserSETATTR)
	}
	{
		p.SetState(1666)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1667)
		p.valueStmt(0)
	}
	p.SetState(1669)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1668)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1671)
		p.Match(vbaParserT__0)
	}
	p.SetState(1673)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1672)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1675)
		p.valueStmt(0)
	}

	return localctx
}

// ISetStmtContext is an interface to support dynamic dispatch.
type ISetStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetStmtContext differentiates from other interfaces.
	IsSetStmtContext()
}

type SetStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStmtContext() *SetStmtContext {
	var p = new(SetStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_setStmt
	return p
}

func (*SetStmtContext) IsSetStmtContext() {}

func NewSetStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStmtContext {
	var p = new(SetStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_setStmt

	return p
}

func (s *SetStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStmtContext) SET() antlr.TerminalNode {
	return s.GetToken(vbaParserSET, 0)
}

func (s *SetStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *SetStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *SetStmtContext) ImplicitCallStmt_InStmt() IImplicitCallStmt_InStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitCallStmt_InStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitCallStmt_InStmtContext)
}

func (s *SetStmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *SetStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *SetStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterSetStmt(s)
	}
}

func (s *SetStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitSetStmt(s)
	}
}

func (p *vbaParser) SetStmt() (localctx ISetStmtContext) {
	this := p
	_ = this

	localctx = NewSetStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, vbaParserRULE_setStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1677)
		p.Match(vbaParserSET)
	}
	{
		p.SetState(1678)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1679)
		p.ImplicitCallStmt_InStmt()
	}
	p.SetState(1681)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1680)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1683)
		p.Match(vbaParserEQ)
	}
	p.SetState(1685)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1684)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1687)
		p.valueStmt(0)
	}

	return localctx
}

// IStopStmtContext is an interface to support dynamic dispatch.
type IStopStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStopStmtContext differentiates from other interfaces.
	IsStopStmtContext()
}

type StopStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopStmtContext() *StopStmtContext {
	var p = new(StopStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_stopStmt
	return p
}

func (*StopStmtContext) IsStopStmtContext() {}

func NewStopStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopStmtContext {
	var p = new(StopStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_stopStmt

	return p
}

func (s *StopStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StopStmtContext) STOP() antlr.TerminalNode {
	return s.GetToken(vbaParserSTOP, 0)
}

func (s *StopStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterStopStmt(s)
	}
}

func (s *StopStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitStopStmt(s)
	}
}

func (p *vbaParser) StopStmt() (localctx IStopStmtContext) {
	this := p
	_ = this

	localctx = NewStopStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, vbaParserRULE_stopStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1689)
		p.Match(vbaParserSTOP)
	}

	return localctx
}

// ISubStmtContext is an interface to support dynamic dispatch.
type ISubStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubStmtContext differentiates from other interfaces.
	IsSubStmtContext()
}

type SubStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubStmtContext() *SubStmtContext {
	var p = new(SubStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_subStmt
	return p
}

func (*SubStmtContext) IsSubStmtContext() {}

func NewSubStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubStmtContext {
	var p = new(SubStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_subStmt

	return p
}

func (s *SubStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SubStmtContext) SUB() antlr.TerminalNode {
	return s.GetToken(vbaParserSUB, 0)
}

func (s *SubStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *SubStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *SubStmtContext) END_SUB() antlr.TerminalNode {
	return s.GetToken(vbaParserEND_SUB, 0)
}

func (s *SubStmtContext) Visibility() IVisibilityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibilityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *SubStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *SubStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *SubStmtContext) STATIC() antlr.TerminalNode {
	return s.GetToken(vbaParserSTATIC, 0)
}

func (s *SubStmtContext) ArgList() IArgListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgListContext)
}

func (s *SubStmtContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SubStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterSubStmt(s)
	}
}

func (s *SubStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitSubStmt(s)
	}
}

func (p *vbaParser) SubStmt() (localctx ISubStmtContext) {
	this := p
	_ = this

	localctx = NewSubStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, vbaParserRULE_subStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1694)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserFRIEND || _la == vbaParserGLOBAL || _la == vbaParserPRIVATE || _la == vbaParserPUBLIC {
		{
			p.SetState(1691)
			p.Visibility()
		}
		{
			p.SetState(1692)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(1698)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserSTATIC {
		{
			p.SetState(1696)
			p.Match(vbaParserSTATIC)
		}
		{
			p.SetState(1697)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1700)
		p.Match(vbaParserSUB)
	}
	p.SetState(1702)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1701)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1704)
		p.AmbiguousIdentifier()
	}
	p.SetState(1709)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 246, p.GetParserRuleContext()) == 1 {
		p.SetState(1706)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1705)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1708)
			p.ArgList()
		}

	}
	{
		p.SetState(1711)
		p.EndOfStatement()
	}
	p.SetState(1713)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserEXIT_DO-64))|(1<<(vbaParserEXIT_FOR-64))|(1<<(vbaParserEXIT_FUNCTION-64))|(1<<(vbaParserEXIT_PROPERTY-64))|(1<<(vbaParserEXIT_SUB-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLINE_INPUT-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserMACRO_CONST-96))|(1<<(vbaParserMACRO_IF-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserON_ERROR-96))|(1<<(vbaParserON_LOCAL_ERROR-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || _la == vbaParserIDENTIFIER {
		{
			p.SetState(1712)
			p.Block()
		}

	}
	{
		p.SetState(1715)
		p.Match(vbaParserEND_SUB)
	}

	return localctx
}

// ITimeStmtContext is an interface to support dynamic dispatch.
type ITimeStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeStmtContext differentiates from other interfaces.
	IsTimeStmtContext()
}

type TimeStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeStmtContext() *TimeStmtContext {
	var p = new(TimeStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_timeStmt
	return p
}

func (*TimeStmtContext) IsTimeStmtContext() {}

func NewTimeStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeStmtContext {
	var p = new(TimeStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_timeStmt

	return p
}

func (s *TimeStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeStmtContext) TIME() antlr.TerminalNode {
	return s.GetToken(vbaParserTIME, 0)
}

func (s *TimeStmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *TimeStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *TimeStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *TimeStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *TimeStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterTimeStmt(s)
	}
}

func (s *TimeStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitTimeStmt(s)
	}
}

func (p *vbaParser) TimeStmt() (localctx ITimeStmtContext) {
	this := p
	_ = this

	localctx = NewTimeStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, vbaParserRULE_timeStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1717)
		p.Match(vbaParserTIME)
	}
	p.SetState(1719)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1718)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1721)
		p.Match(vbaParserEQ)
	}
	p.SetState(1723)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(1722)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1725)
		p.valueStmt(0)
	}

	return localctx
}

// ITypeStmtContext is an interface to support dynamic dispatch.
type ITypeStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeStmtContext differentiates from other interfaces.
	IsTypeStmtContext()
}

type TypeStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeStmtContext() *TypeStmtContext {
	var p = new(TypeStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_typeStmt
	return p
}

func (*TypeStmtContext) IsTypeStmtContext() {}

func NewTypeStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeStmtContext {
	var p = new(TypeStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_typeStmt

	return p
}

func (s *TypeStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeStmtContext) TYPE() antlr.TerminalNode {
	return s.GetToken(vbaParserTYPE, 0)
}

func (s *TypeStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *TypeStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *TypeStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *TypeStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *TypeStmtContext) END_TYPE() antlr.TerminalNode {
	return s.GetToken(vbaParserEND_TYPE, 0)
}

func (s *TypeStmtContext) Visibility() IVisibilityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibilityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *TypeStmtContext) AllTypeStmt_Element() []ITypeStmt_ElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeStmt_ElementContext)(nil)).Elem())
	var tst = make([]ITypeStmt_ElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeStmt_ElementContext)
		}
	}

	return tst
}

func (s *TypeStmtContext) TypeStmt_Element(i int) ITypeStmt_ElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeStmt_ElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeStmt_ElementContext)
}

func (s *TypeStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterTypeStmt(s)
	}
}

func (s *TypeStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitTypeStmt(s)
	}
}

func (p *vbaParser) TypeStmt() (localctx ITypeStmtContext) {
	this := p
	_ = this

	localctx = NewTypeStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, vbaParserRULE_typeStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1730)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserFRIEND || _la == vbaParserGLOBAL || _la == vbaParserPRIVATE || _la == vbaParserPUBLIC {
		{
			p.SetState(1727)
			p.Visibility()
		}
		{
			p.SetState(1728)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(1732)
		p.Match(vbaParserTYPE)
	}
	{
		p.SetState(1733)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1734)
		p.AmbiguousIdentifier()
	}
	{
		p.SetState(1735)
		p.EndOfStatement()
	}
	p.SetState(1739)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || _la == vbaParserIDENTIFIER {
		{
			p.SetState(1736)
			p.TypeStmt_Element()
		}

		p.SetState(1741)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1742)
		p.Match(vbaParserEND_TYPE)
	}

	return localctx
}

// ITypeStmt_ElementContext is an interface to support dynamic dispatch.
type ITypeStmt_ElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeStmt_ElementContext differentiates from other interfaces.
	IsTypeStmt_ElementContext()
}

type TypeStmt_ElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeStmt_ElementContext() *TypeStmt_ElementContext {
	var p = new(TypeStmt_ElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_typeStmt_Element
	return p
}

func (*TypeStmt_ElementContext) IsTypeStmt_ElementContext() {}

func NewTypeStmt_ElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeStmt_ElementContext {
	var p = new(TypeStmt_ElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_typeStmt_Element

	return p
}

func (s *TypeStmt_ElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeStmt_ElementContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *TypeStmt_ElementContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *TypeStmt_ElementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, 0)
}

func (s *TypeStmt_ElementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, 0)
}

func (s *TypeStmt_ElementContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *TypeStmt_ElementContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *TypeStmt_ElementContext) AsTypeClause() IAsTypeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsTypeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsTypeClauseContext)
}

func (s *TypeStmt_ElementContext) Subscripts() ISubscriptsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubscriptsContext)
}

func (s *TypeStmt_ElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeStmt_ElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeStmt_ElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterTypeStmt_Element(s)
	}
}

func (s *TypeStmt_ElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitTypeStmt_Element(s)
	}
}

func (p *vbaParser) TypeStmt_Element() (localctx ITypeStmt_ElementContext) {
	this := p
	_ = this

	localctx = NewTypeStmt_ElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, vbaParserRULE_typeStmt_Element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1744)
		p.AmbiguousIdentifier()
	}
	p.SetState(1759)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 256, p.GetParserRuleContext()) == 1 {
		p.SetState(1746)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1745)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1748)
			p.Match(vbaParserLPAREN)
		}
		p.SetState(1753)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 254, p.GetParserRuleContext()) == 1 {
			p.SetState(1750)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(1749)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(1752)
				p.Subscripts()
			}

		}
		p.SetState(1756)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1755)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1758)
			p.Match(vbaParserRPAREN)
		}

	}
	p.SetState(1763)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 257, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1761)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(1762)
			p.AsTypeClause()
		}

	}
	{
		p.SetState(1765)
		p.EndOfStatement()
	}

	return localctx
}

// ITypeOfStmtContext is an interface to support dynamic dispatch.
type ITypeOfStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeOfStmtContext differentiates from other interfaces.
	IsTypeOfStmtContext()
}

type TypeOfStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeOfStmtContext() *TypeOfStmtContext {
	var p = new(TypeOfStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_typeOfStmt
	return p
}

func (*TypeOfStmtContext) IsTypeOfStmtContext() {}

func NewTypeOfStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeOfStmtContext {
	var p = new(TypeOfStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_typeOfStmt

	return p
}

func (s *TypeOfStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeOfStmtContext) TYPEOF() antlr.TerminalNode {
	return s.GetToken(vbaParserTYPEOF, 0)
}

func (s *TypeOfStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *TypeOfStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *TypeOfStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *TypeOfStmtContext) IS() antlr.TerminalNode {
	return s.GetToken(vbaParserIS, 0)
}

func (s *TypeOfStmtContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeOfStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeOfStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeOfStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterTypeOfStmt(s)
	}
}

func (s *TypeOfStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitTypeOfStmt(s)
	}
}

func (p *vbaParser) TypeOfStmt() (localctx ITypeOfStmtContext) {
	this := p
	_ = this

	localctx = NewTypeOfStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, vbaParserRULE_typeOfStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1767)
		p.Match(vbaParserTYPEOF)
	}
	{
		p.SetState(1768)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1769)
		p.valueStmt(0)
	}
	p.SetState(1774)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 258, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1770)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(1771)
			p.Match(vbaParserIS)
		}
		{
			p.SetState(1772)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(1773)
			p.Type_()
		}

	}

	return localctx
}

// IUnloadStmtContext is an interface to support dynamic dispatch.
type IUnloadStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnloadStmtContext differentiates from other interfaces.
	IsUnloadStmtContext()
}

type UnloadStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnloadStmtContext() *UnloadStmtContext {
	var p = new(UnloadStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_unloadStmt
	return p
}

func (*UnloadStmtContext) IsUnloadStmtContext() {}

func NewUnloadStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnloadStmtContext {
	var p = new(UnloadStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_unloadStmt

	return p
}

func (s *UnloadStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *UnloadStmtContext) UNLOAD() antlr.TerminalNode {
	return s.GetToken(vbaParserUNLOAD, 0)
}

func (s *UnloadStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *UnloadStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *UnloadStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnloadStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnloadStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterUnloadStmt(s)
	}
}

func (s *UnloadStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitUnloadStmt(s)
	}
}

func (p *vbaParser) UnloadStmt() (localctx IUnloadStmtContext) {
	this := p
	_ = this

	localctx = NewUnloadStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, vbaParserRULE_unloadStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1776)
		p.Match(vbaParserUNLOAD)
	}
	{
		p.SetState(1777)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1778)
		p.valueStmt(0)
	}

	return localctx
}

// IUnlockStmtContext is an interface to support dynamic dispatch.
type IUnlockStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnlockStmtContext differentiates from other interfaces.
	IsUnlockStmtContext()
}

type UnlockStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlockStmtContext() *UnlockStmtContext {
	var p = new(UnlockStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_unlockStmt
	return p
}

func (*UnlockStmtContext) IsUnlockStmtContext() {}

func NewUnlockStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnlockStmtContext {
	var p = new(UnlockStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_unlockStmt

	return p
}

func (s *UnlockStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *UnlockStmtContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(vbaParserUNLOCK, 0)
}

func (s *UnlockStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *UnlockStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *UnlockStmtContext) FileNumber() IFileNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNumberContext)
}

func (s *UnlockStmtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *UnlockStmtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *UnlockStmtContext) TO() antlr.TerminalNode {
	return s.GetToken(vbaParserTO, 0)
}

func (s *UnlockStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlockStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnlockStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterUnlockStmt(s)
	}
}

func (s *UnlockStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitUnlockStmt(s)
	}
}

func (p *vbaParser) UnlockStmt() (localctx IUnlockStmtContext) {
	this := p
	_ = this

	localctx = NewUnlockStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, vbaParserRULE_unlockStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1780)
		p.Match(vbaParserUNLOCK)
	}
	{
		p.SetState(1781)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(1782)
		p.FileNumber()
	}
	p.SetState(1797)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 262, p.GetParserRuleContext()) == 1 {
		p.SetState(1784)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1783)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1786)
			p.Match(vbaParserT__0)
		}
		p.SetState(1788)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1787)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1790)
			p.valueStmt(0)
		}
		p.SetState(1795)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 261, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1791)
				p.Match(vbaParserWS)
			}
			{
				p.SetState(1792)
				p.Match(vbaParserTO)
			}
			{
				p.SetState(1793)
				p.Match(vbaParserWS)
			}
			{
				p.SetState(1794)
				p.valueStmt(0)
			}

		}

	}

	return localctx
}

// IValueStmtContext is an interface to support dynamic dispatch.
type IValueStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueStmtContext differentiates from other interfaces.
	IsValueStmtContext()
}

type ValueStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueStmtContext() *ValueStmtContext {
	var p = new(ValueStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_valueStmt
	return p
}

func (*ValueStmtContext) IsValueStmtContext() {}

func NewValueStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueStmtContext {
	var p = new(ValueStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_valueStmt

	return p
}

func (s *ValueStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueStmtContext) CopyFrom(ctx *ValueStmtContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ValueStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type VsStructContext struct {
	*ValueStmtContext
}

func NewVsStructContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsStructContext {
	var p = new(VsStructContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsStructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsStructContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, 0)
}

func (s *VsStructContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsStructContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsStructContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, 0)
}

func (s *VsStructContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsStructContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsStructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsStruct(s)
	}
}

func (s *VsStructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsStruct(s)
	}
}

type VsAddContext struct {
	*ValueStmtContext
}

func NewVsAddContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsAddContext {
	var p = new(VsAddContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsAddContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsAddContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsAddContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsAddContext) PLUS() antlr.TerminalNode {
	return s.GetToken(vbaParserPLUS, 0)
}

func (s *VsAddContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsAddContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsAddContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsAdd(s)
	}
}

func (s *VsAddContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsAdd(s)
	}
}

type VsLtContext struct {
	*ValueStmtContext
}

func NewVsLtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsLtContext {
	var p = new(VsLtContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsLtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsLtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsLtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsLtContext) LT() antlr.TerminalNode {
	return s.GetToken(vbaParserLT, 0)
}

func (s *VsLtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsLtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsLtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsLt(s)
	}
}

func (s *VsLtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsLt(s)
	}
}

type VsAddressOfContext struct {
	*ValueStmtContext
}

func NewVsAddressOfContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsAddressOfContext {
	var p = new(VsAddressOfContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsAddressOfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsAddressOfContext) ADDRESSOF() antlr.TerminalNode {
	return s.GetToken(vbaParserADDRESSOF, 0)
}

func (s *VsAddressOfContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsAddressOfContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *VsAddressOfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsAddressOf(s)
	}
}

func (s *VsAddressOfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsAddressOf(s)
	}
}

type VsNewContext struct {
	*ValueStmtContext
}

func NewVsNewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsNewContext {
	var p = new(VsNewContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsNewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsNewContext) NEW() antlr.TerminalNode {
	return s.GetToken(vbaParserNEW, 0)
}

func (s *VsNewContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsNewContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *VsNewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsNew(s)
	}
}

func (s *VsNewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsNew(s)
	}
}

type VsMultContext struct {
	*ValueStmtContext
}

func NewVsMultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsMultContext {
	var p = new(VsMultContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsMultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsMultContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsMultContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsMultContext) MULT() antlr.TerminalNode {
	return s.GetToken(vbaParserMULT, 0)
}

func (s *VsMultContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsMultContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsMultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsMult(s)
	}
}

func (s *VsMultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsMult(s)
	}
}

type VsNegationContext struct {
	*ValueStmtContext
}

func NewVsNegationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsNegationContext {
	var p = new(VsNegationContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsNegationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsNegationContext) MINUS() antlr.TerminalNode {
	return s.GetToken(vbaParserMINUS, 0)
}

func (s *VsNegationContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsNegationContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *VsNegationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsNegation(s)
	}
}

func (s *VsNegationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsNegation(s)
	}
}

type VsAssignContext struct {
	*ValueStmtContext
}

func NewVsAssignContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsAssignContext {
	var p = new(VsAssignContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsAssignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsAssignContext) ImplicitCallStmt_InStmt() IImplicitCallStmt_InStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitCallStmt_InStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitCallStmt_InStmtContext)
}

func (s *VsAssignContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(vbaParserASSIGN, 0)
}

func (s *VsAssignContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsAssignContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsAssignContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsAssignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsAssign(s)
	}
}

func (s *VsAssignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsAssign(s)
	}
}

type VsLikeContext struct {
	*ValueStmtContext
}

func NewVsLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsLikeContext {
	var p = new(VsLikeContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsLikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsLikeContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsLikeContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsLikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(vbaParserLIKE, 0)
}

func (s *VsLikeContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsLikeContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsLikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsLike(s)
	}
}

func (s *VsLikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsLike(s)
	}
}

type VsDivContext struct {
	*ValueStmtContext
}

func NewVsDivContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsDivContext {
	var p = new(VsDivContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsDivContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsDivContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsDivContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsDivContext) DIV() antlr.TerminalNode {
	return s.GetToken(vbaParserDIV, 0)
}

func (s *VsDivContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsDivContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsDivContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsDiv(s)
	}
}

func (s *VsDivContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsDiv(s)
	}
}

type VsPlusContext struct {
	*ValueStmtContext
}

func NewVsPlusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsPlusContext {
	var p = new(VsPlusContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsPlusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsPlusContext) PLUS() antlr.TerminalNode {
	return s.GetToken(vbaParserPLUS, 0)
}

func (s *VsPlusContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsPlusContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *VsPlusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsPlus(s)
	}
}

func (s *VsPlusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsPlus(s)
	}
}

type VsNotContext struct {
	*ValueStmtContext
}

func NewVsNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsNotContext {
	var p = new(VsNotContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(vbaParserNOT, 0)
}

func (s *VsNotContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsNotContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *VsNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsNot(s)
	}
}

func (s *VsNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsNot(s)
	}
}

type VsGeqContext struct {
	*ValueStmtContext
}

func NewVsGeqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsGeqContext {
	var p = new(VsGeqContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsGeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsGeqContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsGeqContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsGeqContext) GEQ() antlr.TerminalNode {
	return s.GetToken(vbaParserGEQ, 0)
}

func (s *VsGeqContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsGeqContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsGeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsGeq(s)
	}
}

func (s *VsGeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsGeq(s)
	}
}

type VsTypeOfContext struct {
	*ValueStmtContext
}

func NewVsTypeOfContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsTypeOfContext {
	var p = new(VsTypeOfContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsTypeOfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsTypeOfContext) TypeOfStmt() ITypeOfStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeOfStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeOfStmtContext)
}

func (s *VsTypeOfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsTypeOf(s)
	}
}

func (s *VsTypeOfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsTypeOf(s)
	}
}

type VsICSContext struct {
	*ValueStmtContext
}

func NewVsICSContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsICSContext {
	var p = new(VsICSContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsICSContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsICSContext) ImplicitCallStmt_InStmt() IImplicitCallStmt_InStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitCallStmt_InStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitCallStmt_InStmtContext)
}

func (s *VsICSContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsICS(s)
	}
}

func (s *VsICSContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsICS(s)
	}
}

type VsNeqContext struct {
	*ValueStmtContext
}

func NewVsNeqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsNeqContext {
	var p = new(VsNeqContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsNeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsNeqContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsNeqContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsNeqContext) NEQ() antlr.TerminalNode {
	return s.GetToken(vbaParserNEQ, 0)
}

func (s *VsNeqContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsNeqContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsNeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsNeq(s)
	}
}

func (s *VsNeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsNeq(s)
	}
}

type VsXorContext struct {
	*ValueStmtContext
}

func NewVsXorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsXorContext {
	var p = new(VsXorContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsXorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsXorContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsXorContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsXorContext) XOR() antlr.TerminalNode {
	return s.GetToken(vbaParserXOR, 0)
}

func (s *VsXorContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsXorContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsXorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsXor(s)
	}
}

func (s *VsXorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsXor(s)
	}
}

type VsAndContext struct {
	*ValueStmtContext
}

func NewVsAndContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsAndContext {
	var p = new(VsAndContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsAndContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsAndContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsAndContext) AND() antlr.TerminalNode {
	return s.GetToken(vbaParserAND, 0)
}

func (s *VsAndContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsAndContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsAndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsAnd(s)
	}
}

func (s *VsAndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsAnd(s)
	}
}

type VsLeqContext struct {
	*ValueStmtContext
}

func NewVsLeqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsLeqContext {
	var p = new(VsLeqContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsLeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsLeqContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsLeqContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsLeqContext) LEQ() antlr.TerminalNode {
	return s.GetToken(vbaParserLEQ, 0)
}

func (s *VsLeqContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsLeqContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsLeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsLeq(s)
	}
}

func (s *VsLeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsLeq(s)
	}
}

type VsPowContext struct {
	*ValueStmtContext
}

func NewVsPowContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsPowContext {
	var p = new(VsPowContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsPowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsPowContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsPowContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsPowContext) POW() antlr.TerminalNode {
	return s.GetToken(vbaParserPOW, 0)
}

func (s *VsPowContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsPowContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsPowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsPow(s)
	}
}

func (s *VsPowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsPow(s)
	}
}

type VsIsContext struct {
	*ValueStmtContext
}

func NewVsIsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsIsContext {
	var p = new(VsIsContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsIsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsIsContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsIsContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsIsContext) IS() antlr.TerminalNode {
	return s.GetToken(vbaParserIS, 0)
}

func (s *VsIsContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsIsContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsIsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsIs(s)
	}
}

func (s *VsIsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsIs(s)
	}
}

type VsModContext struct {
	*ValueStmtContext
}

func NewVsModContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsModContext {
	var p = new(VsModContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsModContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsModContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsModContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsModContext) MOD() antlr.TerminalNode {
	return s.GetToken(vbaParserMOD, 0)
}

func (s *VsModContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsModContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsModContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsMod(s)
	}
}

func (s *VsModContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsMod(s)
	}
}

type VsAmpContext struct {
	*ValueStmtContext
}

func NewVsAmpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsAmpContext {
	var p = new(VsAmpContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsAmpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsAmpContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsAmpContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsAmpContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(vbaParserAMPERSAND, 0)
}

func (s *VsAmpContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsAmpContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsAmpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsAmp(s)
	}
}

func (s *VsAmpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsAmp(s)
	}
}

type VsOrContext struct {
	*ValueStmtContext
}

func NewVsOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsOrContext {
	var p = new(VsOrContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsOrContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsOrContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsOrContext) OR() antlr.TerminalNode {
	return s.GetToken(vbaParserOR, 0)
}

func (s *VsOrContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsOrContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsOrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsOr(s)
	}
}

func (s *VsOrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsOr(s)
	}
}

type VsMinusContext struct {
	*ValueStmtContext
}

func NewVsMinusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsMinusContext {
	var p = new(VsMinusContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsMinusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsMinusContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsMinusContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsMinusContext) MINUS() antlr.TerminalNode {
	return s.GetToken(vbaParserMINUS, 0)
}

func (s *VsMinusContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsMinusContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsMinusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsMinus(s)
	}
}

func (s *VsMinusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsMinus(s)
	}
}

type VsLiteralContext struct {
	*ValueStmtContext
}

func NewVsLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsLiteralContext {
	var p = new(VsLiteralContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsLiteralContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *VsLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsLiteral(s)
	}
}

func (s *VsLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsLiteral(s)
	}
}

type VsEqvContext struct {
	*ValueStmtContext
}

func NewVsEqvContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsEqvContext {
	var p = new(VsEqvContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsEqvContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsEqvContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsEqvContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsEqvContext) EQV() antlr.TerminalNode {
	return s.GetToken(vbaParserEQV, 0)
}

func (s *VsEqvContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsEqvContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsEqvContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsEqv(s)
	}
}

func (s *VsEqvContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsEqv(s)
	}
}

type VsImpContext struct {
	*ValueStmtContext
}

func NewVsImpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsImpContext {
	var p = new(VsImpContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsImpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsImpContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsImpContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsImpContext) IMP() antlr.TerminalNode {
	return s.GetToken(vbaParserIMP, 0)
}

func (s *VsImpContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsImpContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsImpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsImp(s)
	}
}

func (s *VsImpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsImp(s)
	}
}

type VsGtContext struct {
	*ValueStmtContext
}

func NewVsGtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsGtContext {
	var p = new(VsGtContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsGtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsGtContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsGtContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsGtContext) GT() antlr.TerminalNode {
	return s.GetToken(vbaParserGT, 0)
}

func (s *VsGtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsGtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsGtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsGt(s)
	}
}

func (s *VsGtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsGt(s)
	}
}

type VsEqContext struct {
	*ValueStmtContext
}

func NewVsEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsEqContext {
	var p = new(VsEqContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsEqContext) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *VsEqContext) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *VsEqContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *VsEqContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VsEqContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VsEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsEq(s)
	}
}

func (s *VsEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsEq(s)
	}
}

type VsMidContext struct {
	*ValueStmtContext
}

func NewVsMidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VsMidContext {
	var p = new(VsMidContext)

	p.ValueStmtContext = NewEmptyValueStmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueStmtContext))

	return p
}

func (s *VsMidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VsMidContext) MidStmt() IMidStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMidStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMidStmtContext)
}

func (s *VsMidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVsMid(s)
	}
}

func (s *VsMidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVsMid(s)
	}
}

func (p *vbaParser) ValueStmt() (localctx IValueStmtContext) {
	return p.valueStmt(0)
}

func (p *vbaParser) valueStmt(_p int) (localctx IValueStmtContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewValueStmtContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueStmtContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 200
	p.EnterRecursionRule(localctx, 200, vbaParserRULE_valueStmt, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1859)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 274, p.GetParserRuleContext()) {
	case 1:
		localctx = NewVsLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1800)
			p.Literal()
		}

	case 2:
		localctx = NewVsICSContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1801)
			p.ImplicitCallStmt_InStmt()
		}

	case 3:
		localctx = NewVsStructContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1802)
			p.Match(vbaParserLPAREN)
		}
		p.SetState(1804)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1803)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1806)
			p.valueStmt(0)
		}
		p.SetState(1817)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == vbaParserT__0 || _la == vbaParserWS {
			p.SetState(1808)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(1807)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(1810)
				p.Match(vbaParserT__0)
			}
			p.SetState(1812)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(1811)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(1814)
				p.valueStmt(0)
			}

			p.SetState(1819)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1820)
			p.Match(vbaParserRPAREN)
		}

	case 4:
		localctx = NewVsNewContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1822)
			p.Match(vbaParserNEW)
		}
		p.SetState(1824)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1823)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1826)
			p.valueStmt(28)
		}

	case 5:
		localctx = NewVsTypeOfContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1827)
			p.TypeOfStmt()
		}

	case 6:
		localctx = NewVsMidContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1828)
			p.MidStmt()
		}

	case 7:
		localctx = NewVsAddressOfContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1829)
			p.Match(vbaParserADDRESSOF)
		}
		p.SetState(1831)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1830)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1833)
			p.valueStmt(25)
		}

	case 8:
		localctx = NewVsAssignContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1834)
			p.ImplicitCallStmt_InStmt()
		}
		p.SetState(1836)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1835)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1838)
			p.Match(vbaParserASSIGN)
		}
		p.SetState(1840)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1839)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1842)
			p.valueStmt(24)
		}

	case 9:
		localctx = NewVsNegationContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1844)
			p.Match(vbaParserMINUS)
		}
		p.SetState(1846)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1845)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1848)
			p.valueStmt(14)
		}

	case 10:
		localctx = NewVsPlusContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1849)
			p.Match(vbaParserPLUS)
		}
		p.SetState(1851)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1850)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1853)
			p.valueStmt(13)
		}

	case 11:
		localctx = NewVsNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1854)
			p.Match(vbaParserNOT)
		}
		p.SetState(1856)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(1855)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(1858)
			p.valueStmt(1)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2043)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 316, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2041)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 315, p.GetParserRuleContext()) {
			case 1:
				localctx = NewVsIsContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1861)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
				}
				p.SetState(1863)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1862)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1865)
					p.Match(vbaParserIS)
				}
				p.SetState(1867)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1866)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1869)
					p.valueStmt(24)
				}

			case 2:
				localctx = NewVsLikeContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1870)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
				}
				p.SetState(1872)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1871)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1874)
					p.Match(vbaParserLIKE)
				}
				p.SetState(1876)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1875)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1878)
					p.valueStmt(23)
				}

			case 3:
				localctx = NewVsGeqContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1879)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
				}
				p.SetState(1881)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1880)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1883)
					p.Match(vbaParserGEQ)
				}
				p.SetState(1885)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1884)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1887)
					p.valueStmt(22)
				}

			case 4:
				localctx = NewVsLeqContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1888)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
				}
				p.SetState(1890)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1889)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1892)
					p.Match(vbaParserLEQ)
				}
				p.SetState(1894)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1893)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1896)
					p.valueStmt(21)
				}

			case 5:
				localctx = NewVsGtContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1897)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
				}
				p.SetState(1899)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1898)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1901)
					p.Match(vbaParserGT)
				}
				p.SetState(1903)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1902)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1905)
					p.valueStmt(20)
				}

			case 6:
				localctx = NewVsLtContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1906)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
				}
				p.SetState(1908)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1907)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1910)
					p.Match(vbaParserLT)
				}
				p.SetState(1912)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1911)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1914)
					p.valueStmt(19)
				}

			case 7:
				localctx = NewVsNeqContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1915)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				p.SetState(1917)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1916)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1919)
					p.Match(vbaParserNEQ)
				}
				p.SetState(1921)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1920)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1923)
					p.valueStmt(18)
				}

			case 8:
				localctx = NewVsEqContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1924)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				p.SetState(1926)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1925)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1928)
					p.Match(vbaParserEQ)
				}
				p.SetState(1930)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1929)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1932)
					p.valueStmt(17)
				}

			case 9:
				localctx = NewVsPowContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1933)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				p.SetState(1935)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1934)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1937)
					p.Match(vbaParserPOW)
				}
				p.SetState(1939)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1938)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1941)
					p.valueStmt(16)
				}

			case 10:
				localctx = NewVsDivContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1942)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				p.SetState(1944)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1943)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1946)
					p.Match(vbaParserDIV)
				}
				p.SetState(1948)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1947)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1950)
					p.valueStmt(13)
				}

			case 11:
				localctx = NewVsMultContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1951)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				p.SetState(1953)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1952)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1955)
					p.Match(vbaParserMULT)
				}
				p.SetState(1957)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1956)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1959)
					p.valueStmt(12)
				}

			case 12:
				localctx = NewVsModContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1960)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				p.SetState(1962)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1961)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1964)
					p.Match(vbaParserMOD)
				}
				p.SetState(1966)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1965)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1968)
					p.valueStmt(11)
				}

			case 13:
				localctx = NewVsAddContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1969)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				p.SetState(1971)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1970)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1973)
					p.Match(vbaParserPLUS)
				}
				p.SetState(1975)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1974)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1977)
					p.valueStmt(10)
				}

			case 14:
				localctx = NewVsMinusContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1978)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				p.SetState(1980)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1979)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1982)
					p.Match(vbaParserMINUS)
				}
				p.SetState(1984)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1983)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1986)
					p.valueStmt(9)
				}

			case 15:
				localctx = NewVsAmpContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1987)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				p.SetState(1989)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1988)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1991)
					p.Match(vbaParserAMPERSAND)
				}
				p.SetState(1993)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1992)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(1995)
					p.valueStmt(8)
				}

			case 16:
				localctx = NewVsImpContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(1996)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				p.SetState(1998)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(1997)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(2000)
					p.Match(vbaParserIMP)
				}
				p.SetState(2002)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(2001)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(2004)
					p.valueStmt(7)
				}

			case 17:
				localctx = NewVsEqvContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(2005)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				p.SetState(2007)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(2006)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(2009)
					p.Match(vbaParserEQV)
				}
				p.SetState(2011)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(2010)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(2013)
					p.valueStmt(6)
				}

			case 18:
				localctx = NewVsXorContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(2014)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				p.SetState(2016)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(2015)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(2018)
					p.Match(vbaParserXOR)
				}
				p.SetState(2020)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(2019)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(2022)
					p.valueStmt(5)
				}

			case 19:
				localctx = NewVsOrContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(2023)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				p.SetState(2025)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(2024)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(2027)
					p.Match(vbaParserOR)
				}
				p.SetState(2029)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(2028)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(2031)
					p.valueStmt(4)
				}

			case 20:
				localctx = NewVsAndContext(p, NewValueStmtContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, vbaParserRULE_valueStmt)
				p.SetState(2032)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				p.SetState(2034)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(2033)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(2036)
					p.Match(vbaParserAND)
				}
				p.SetState(2038)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(2037)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(2040)
					p.valueStmt(3)
				}

			}

		}
		p.SetState(2045)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 316, p.GetParserRuleContext())
	}

	return localctx
}

// IVariableStmtContext is an interface to support dynamic dispatch.
type IVariableStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableStmtContext differentiates from other interfaces.
	IsVariableStmtContext()
}

type VariableStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableStmtContext() *VariableStmtContext {
	var p = new(VariableStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_variableStmt
	return p
}

func (*VariableStmtContext) IsVariableStmtContext() {}

func NewVariableStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableStmtContext {
	var p = new(VariableStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_variableStmt

	return p
}

func (s *VariableStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VariableStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VariableStmtContext) VariableListStmt() IVariableListStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableListStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableListStmtContext)
}

func (s *VariableStmtContext) DIM() antlr.TerminalNode {
	return s.GetToken(vbaParserDIM, 0)
}

func (s *VariableStmtContext) STATIC() antlr.TerminalNode {
	return s.GetToken(vbaParserSTATIC, 0)
}

func (s *VariableStmtContext) Visibility() IVisibilityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibilityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *VariableStmtContext) WITHEVENTS() antlr.TerminalNode {
	return s.GetToken(vbaParserWITHEVENTS, 0)
}

func (s *VariableStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVariableStmt(s)
	}
}

func (s *VariableStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVariableStmt(s)
	}
}

func (p *vbaParser) VariableStmt() (localctx IVariableStmtContext) {
	this := p
	_ = this

	localctx = NewVariableStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, vbaParserRULE_variableStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2049)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vbaParserDIM:
		{
			p.SetState(2046)
			p.Match(vbaParserDIM)
		}

	case vbaParserSTATIC:
		{
			p.SetState(2047)
			p.Match(vbaParserSTATIC)
		}

	case vbaParserFRIEND, vbaParserGLOBAL, vbaParserPRIVATE, vbaParserPUBLIC:
		{
			p.SetState(2048)
			p.Visibility()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2051)
		p.Match(vbaParserWS)
	}
	p.SetState(2054)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 318, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2052)
			p.Match(vbaParserWITHEVENTS)
		}
		{
			p.SetState(2053)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(2056)
		p.VariableListStmt()
	}

	return localctx
}

// IVariableListStmtContext is an interface to support dynamic dispatch.
type IVariableListStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableListStmtContext differentiates from other interfaces.
	IsVariableListStmtContext()
}

type VariableListStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableListStmtContext() *VariableListStmtContext {
	var p = new(VariableListStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_variableListStmt
	return p
}

func (*VariableListStmtContext) IsVariableListStmtContext() {}

func NewVariableListStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableListStmtContext {
	var p = new(VariableListStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_variableListStmt

	return p
}

func (s *VariableListStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableListStmtContext) AllVariableSubStmt() []IVariableSubStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableSubStmtContext)(nil)).Elem())
	var tst = make([]IVariableSubStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableSubStmtContext)
		}
	}

	return tst
}

func (s *VariableListStmtContext) VariableSubStmt(i int) IVariableSubStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableSubStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableSubStmtContext)
}

func (s *VariableListStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VariableListStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VariableListStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableListStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableListStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVariableListStmt(s)
	}
}

func (s *VariableListStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVariableListStmt(s)
	}
}

func (p *vbaParser) VariableListStmt() (localctx IVariableListStmtContext) {
	this := p
	_ = this

	localctx = NewVariableListStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, vbaParserRULE_variableListStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2058)
		p.VariableSubStmt()
	}
	p.SetState(2069)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 321, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2060)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2059)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2062)
				p.Match(vbaParserT__0)
			}
			p.SetState(2064)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2063)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2066)
				p.VariableSubStmt()
			}

		}
		p.SetState(2071)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 321, p.GetParserRuleContext())
	}

	return localctx
}

// IVariableSubStmtContext is an interface to support dynamic dispatch.
type IVariableSubStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableSubStmtContext differentiates from other interfaces.
	IsVariableSubStmtContext()
}

type VariableSubStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableSubStmtContext() *VariableSubStmtContext {
	var p = new(VariableSubStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_variableSubStmt
	return p
}

func (*VariableSubStmtContext) IsVariableSubStmtContext() {}

func NewVariableSubStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableSubStmtContext {
	var p = new(VariableSubStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_variableSubStmt

	return p
}

func (s *VariableSubStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableSubStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *VariableSubStmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, 0)
}

func (s *VariableSubStmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, 0)
}

func (s *VariableSubStmtContext) TypeHint() ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *VariableSubStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *VariableSubStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *VariableSubStmtContext) AsTypeClause() IAsTypeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsTypeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsTypeClauseContext)
}

func (s *VariableSubStmtContext) Subscripts() ISubscriptsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubscriptsContext)
}

func (s *VariableSubStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableSubStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableSubStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVariableSubStmt(s)
	}
}

func (s *VariableSubStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVariableSubStmt(s)
	}
}

func (p *vbaParser) VariableSubStmt() (localctx IVariableSubStmtContext) {
	this := p
	_ = this

	localctx = NewVariableSubStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, vbaParserRULE_variableSubStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2072)
		p.AmbiguousIdentifier()
	}
	p.SetState(2090)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 327, p.GetParserRuleContext()) == 1 {
		p.SetState(2074)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2073)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2076)
			p.Match(vbaParserLPAREN)
		}
		p.SetState(2078)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2077)
				p.Match(vbaParserWS)
			}

		}
		p.SetState(2084)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || (((_la-193)&-(0x1f+1)) == 0 && ((1<<uint((_la-193)))&((1<<(vbaParserLPAREN-193))|(1<<(vbaParserMINUS-193))|(1<<(vbaParserPLUS-193))|(1<<(vbaParserSTRINGLITERAL-193))|(1<<(vbaParserOCTLITERAL-193))|(1<<(vbaParserHEXLITERAL-193))|(1<<(vbaParserSHORTLITERAL-193))|(1<<(vbaParserINTEGERLITERAL-193))|(1<<(vbaParserDOUBLELITERAL-193))|(1<<(vbaParserDATELITERAL-193))|(1<<(vbaParserIDENTIFIER-193)))) != 0) {
			{
				p.SetState(2080)
				p.Subscripts()
			}
			p.SetState(2082)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2081)
					p.Match(vbaParserWS)
				}

			}

		}
		{
			p.SetState(2086)
			p.Match(vbaParserRPAREN)
		}
		p.SetState(2088)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 326, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2087)
				p.Match(vbaParserWS)
			}

		}

	}
	p.SetState(2093)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 328, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2092)
			p.TypeHint()
		}

	}
	p.SetState(2097)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 329, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2095)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(2096)
			p.AsTypeClause()
		}

	}

	return localctx
}

// IWhileWendStmtContext is an interface to support dynamic dispatch.
type IWhileWendStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhileWendStmtContext differentiates from other interfaces.
	IsWhileWendStmtContext()
}

type WhileWendStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileWendStmtContext() *WhileWendStmtContext {
	var p = new(WhileWendStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_whileWendStmt
	return p
}

func (*WhileWendStmtContext) IsWhileWendStmtContext() {}

func NewWhileWendStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileWendStmtContext {
	var p = new(WhileWendStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_whileWendStmt

	return p
}

func (s *WhileWendStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileWendStmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(vbaParserWHILE, 0)
}

func (s *WhileWendStmtContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *WhileWendStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *WhileWendStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *WhileWendStmtContext) WEND() antlr.TerminalNode {
	return s.GetToken(vbaParserWEND, 0)
}

func (s *WhileWendStmtContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *WhileWendStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileWendStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileWendStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterWhileWendStmt(s)
	}
}

func (s *WhileWendStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitWhileWendStmt(s)
	}
}

func (p *vbaParser) WhileWendStmt() (localctx IWhileWendStmtContext) {
	this := p
	_ = this

	localctx = NewWhileWendStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, vbaParserRULE_whileWendStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2099)
		p.Match(vbaParserWHILE)
	}
	{
		p.SetState(2100)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(2101)
		p.valueStmt(0)
	}
	{
		p.SetState(2102)
		p.EndOfStatement()
	}
	p.SetState(2104)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2103)
			p.Block()
		}

	}
	{
		p.SetState(2106)
		p.Match(vbaParserWEND)
	}

	return localctx
}

// IWidthStmtContext is an interface to support dynamic dispatch.
type IWidthStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWidthStmtContext differentiates from other interfaces.
	IsWidthStmtContext()
}

type WidthStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWidthStmtContext() *WidthStmtContext {
	var p = new(WidthStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_widthStmt
	return p
}

func (*WidthStmtContext) IsWidthStmtContext() {}

func NewWidthStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WidthStmtContext {
	var p = new(WidthStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_widthStmt

	return p
}

func (s *WidthStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *WidthStmtContext) WIDTH() antlr.TerminalNode {
	return s.GetToken(vbaParserWIDTH, 0)
}

func (s *WidthStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *WidthStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *WidthStmtContext) FileNumber() IFileNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNumberContext)
}

func (s *WidthStmtContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *WidthStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WidthStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WidthStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterWidthStmt(s)
	}
}

func (s *WidthStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitWidthStmt(s)
	}
}

func (p *vbaParser) WidthStmt() (localctx IWidthStmtContext) {
	this := p
	_ = this

	localctx = NewWidthStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, vbaParserRULE_widthStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2108)
		p.Match(vbaParserWIDTH)
	}
	{
		p.SetState(2109)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(2110)
		p.FileNumber()
	}
	p.SetState(2112)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(2111)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(2114)
		p.Match(vbaParserT__0)
	}
	p.SetState(2116)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(2115)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(2118)
		p.valueStmt(0)
	}

	return localctx
}

// IWithStmtContext is an interface to support dynamic dispatch.
type IWithStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithStmtContext differentiates from other interfaces.
	IsWithStmtContext()
}

type WithStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStmtContext() *WithStmtContext {
	var p = new(WithStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_withStmt
	return p
}

func (*WithStmtContext) IsWithStmtContext() {}

func NewWithStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStmtContext {
	var p = new(WithStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_withStmt

	return p
}

func (s *WithStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(vbaParserWITH, 0)
}

func (s *WithStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *WithStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *WithStmtContext) EndOfStatement() IEndOfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndOfStatementContext)
}

func (s *WithStmtContext) END_WITH() antlr.TerminalNode {
	return s.GetToken(vbaParserEND_WITH, 0)
}

func (s *WithStmtContext) ImplicitCallStmt_InStmt() IImplicitCallStmt_InStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitCallStmt_InStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitCallStmt_InStmtContext)
}

func (s *WithStmtContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *WithStmtContext) NEW() antlr.TerminalNode {
	return s.GetToken(vbaParserNEW, 0)
}

func (s *WithStmtContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *WithStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterWithStmt(s)
	}
}

func (s *WithStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitWithStmt(s)
	}
}

func (p *vbaParser) WithStmt() (localctx IWithStmtContext) {
	this := p
	_ = this

	localctx = NewWithStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, vbaParserRULE_withStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2120)
		p.Match(vbaParserWITH)
	}
	{
		p.SetState(2121)
		p.Match(vbaParserWS)
	}
	p.SetState(2126)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 333, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2122)
			p.ImplicitCallStmt_InStmt()
		}

	case 2:
		{
			p.SetState(2123)
			p.Match(vbaParserNEW)
		}
		{
			p.SetState(2124)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(2125)
			p.Type_()
		}

	}
	{
		p.SetState(2128)
		p.EndOfStatement()
	}
	p.SetState(2130)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserEXIT_DO-64))|(1<<(vbaParserEXIT_FOR-64))|(1<<(vbaParserEXIT_FUNCTION-64))|(1<<(vbaParserEXIT_PROPERTY-64))|(1<<(vbaParserEXIT_SUB-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLINE_INPUT-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserMACRO_CONST-96))|(1<<(vbaParserMACRO_IF-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserON_ERROR-96))|(1<<(vbaParserON_LOCAL_ERROR-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || _la == vbaParserIDENTIFIER {
		{
			p.SetState(2129)
			p.Block()
		}

	}
	{
		p.SetState(2132)
		p.Match(vbaParserEND_WITH)
	}

	return localctx
}

// IWriteStmtContext is an interface to support dynamic dispatch.
type IWriteStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteStmtContext differentiates from other interfaces.
	IsWriteStmtContext()
}

type WriteStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteStmtContext() *WriteStmtContext {
	var p = new(WriteStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_writeStmt
	return p
}

func (*WriteStmtContext) IsWriteStmtContext() {}

func NewWriteStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteStmtContext {
	var p = new(WriteStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_writeStmt

	return p
}

func (s *WriteStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteStmtContext) WRITE() antlr.TerminalNode {
	return s.GetToken(vbaParserWRITE, 0)
}

func (s *WriteStmtContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *WriteStmtContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *WriteStmtContext) FileNumber() IFileNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNumberContext)
}

func (s *WriteStmtContext) OutputList() IOutputListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutputListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutputListContext)
}

func (s *WriteStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterWriteStmt(s)
	}
}

func (s *WriteStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitWriteStmt(s)
	}
}

func (p *vbaParser) WriteStmt() (localctx IWriteStmtContext) {
	this := p
	_ = this

	localctx = NewWriteStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, vbaParserRULE_writeStmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2134)
		p.Match(vbaParserWRITE)
	}
	{
		p.SetState(2135)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(2136)
		p.FileNumber()
	}
	p.SetState(2138)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(2137)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(2140)
		p.Match(vbaParserT__0)
	}
	p.SetState(2145)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 337, p.GetParserRuleContext()) == 1 {
		p.SetState(2142)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 336, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2141)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2144)
			p.OutputList()
		}

	}

	return localctx
}

// IFileNumberContext is an interface to support dynamic dispatch.
type IFileNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileNumberContext differentiates from other interfaces.
	IsFileNumberContext()
}

type FileNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileNumberContext() *FileNumberContext {
	var p = new(FileNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_fileNumber
	return p
}

func (*FileNumberContext) IsFileNumberContext() {}

func NewFileNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileNumberContext {
	var p = new(FileNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_fileNumber

	return p
}

func (s *FileNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *FileNumberContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *FileNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterFileNumber(s)
	}
}

func (s *FileNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitFileNumber(s)
	}
}

func (p *vbaParser) FileNumber() (localctx IFileNumberContext) {
	this := p
	_ = this

	localctx = NewFileNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, vbaParserRULE_fileNumber)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2148)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserT__2 {
		{
			p.SetState(2147)
			p.Match(vbaParserT__2)
		}

	}
	{
		p.SetState(2150)
		p.valueStmt(0)
	}

	return localctx
}

// IExplicitCallStmtContext is an interface to support dynamic dispatch.
type IExplicitCallStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplicitCallStmtContext differentiates from other interfaces.
	IsExplicitCallStmtContext()
}

type ExplicitCallStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitCallStmtContext() *ExplicitCallStmtContext {
	var p = new(ExplicitCallStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_explicitCallStmt
	return p
}

func (*ExplicitCallStmtContext) IsExplicitCallStmtContext() {}

func NewExplicitCallStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitCallStmtContext {
	var p = new(ExplicitCallStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_explicitCallStmt

	return p
}

func (s *ExplicitCallStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitCallStmtContext) ECS_ProcedureCall() IECS_ProcedureCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IECS_ProcedureCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IECS_ProcedureCallContext)
}

func (s *ExplicitCallStmtContext) ECS_MemberProcedureCall() IECS_MemberProcedureCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IECS_MemberProcedureCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IECS_MemberProcedureCallContext)
}

func (s *ExplicitCallStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitCallStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitCallStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterExplicitCallStmt(s)
	}
}

func (s *ExplicitCallStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitExplicitCallStmt(s)
	}
}

func (p *vbaParser) ExplicitCallStmt() (localctx IExplicitCallStmtContext) {
	this := p
	_ = this

	localctx = NewExplicitCallStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, vbaParserRULE_explicitCallStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2154)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 339, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2152)
			p.ECS_ProcedureCall()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2153)
			p.ECS_MemberProcedureCall()
		}

	}

	return localctx
}

// IECS_ProcedureCallContext is an interface to support dynamic dispatch.
type IECS_ProcedureCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsECS_ProcedureCallContext differentiates from other interfaces.
	IsECS_ProcedureCallContext()
}

type ECS_ProcedureCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyECS_ProcedureCallContext() *ECS_ProcedureCallContext {
	var p = new(ECS_ProcedureCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_eCS_ProcedureCall
	return p
}

func (*ECS_ProcedureCallContext) IsECS_ProcedureCallContext() {}

func NewECS_ProcedureCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ECS_ProcedureCallContext {
	var p = new(ECS_ProcedureCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_eCS_ProcedureCall

	return p
}

func (s *ECS_ProcedureCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ECS_ProcedureCallContext) CALL() antlr.TerminalNode {
	return s.GetToken(vbaParserCALL, 0)
}

func (s *ECS_ProcedureCallContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ECS_ProcedureCallContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ECS_ProcedureCallContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *ECS_ProcedureCallContext) TypeHint() ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *ECS_ProcedureCallContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(vbaParserLPAREN)
}

func (s *ECS_ProcedureCallContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, i)
}

func (s *ECS_ProcedureCallContext) ArgsCall() IArgsCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgsCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgsCallContext)
}

func (s *ECS_ProcedureCallContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(vbaParserRPAREN)
}

func (s *ECS_ProcedureCallContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, i)
}

func (s *ECS_ProcedureCallContext) AllSubscripts() []ISubscriptsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem())
	var tst = make([]ISubscriptsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptsContext)
		}
	}

	return tst
}

func (s *ECS_ProcedureCallContext) Subscripts(i int) ISubscriptsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptsContext)
}

func (s *ECS_ProcedureCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ECS_ProcedureCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ECS_ProcedureCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterECS_ProcedureCall(s)
	}
}

func (s *ECS_ProcedureCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitECS_ProcedureCall(s)
	}
}

func (p *vbaParser) ECS_ProcedureCall() (localctx IECS_ProcedureCallContext) {
	this := p
	_ = this

	localctx = NewECS_ProcedureCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, vbaParserRULE_eCS_ProcedureCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2156)
		p.Match(vbaParserCALL)
	}
	{
		p.SetState(2157)
		p.Match(vbaParserWS)
	}
	{
		p.SetState(2158)
		p.AmbiguousIdentifier()
	}
	p.SetState(2160)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 340, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2159)
			p.TypeHint()
		}

	}
	p.SetState(2175)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 344, p.GetParserRuleContext()) == 1 {
		p.SetState(2163)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2162)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2165)
			p.Match(vbaParserLPAREN)
		}
		p.SetState(2167)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 342, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2166)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2169)
			p.ArgsCall()
		}
		p.SetState(2171)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2170)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2173)
			p.Match(vbaParserRPAREN)
		}

	}
	p.SetState(2186)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 346, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2178)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2177)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2180)
				p.Match(vbaParserLPAREN)
			}
			{
				p.SetState(2181)
				p.Subscripts()
			}
			{
				p.SetState(2182)
				p.Match(vbaParserRPAREN)
			}

		}
		p.SetState(2188)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 346, p.GetParserRuleContext())
	}

	return localctx
}

// IECS_MemberProcedureCallContext is an interface to support dynamic dispatch.
type IECS_MemberProcedureCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsECS_MemberProcedureCallContext differentiates from other interfaces.
	IsECS_MemberProcedureCallContext()
}

type ECS_MemberProcedureCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyECS_MemberProcedureCallContext() *ECS_MemberProcedureCallContext {
	var p = new(ECS_MemberProcedureCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_eCS_MemberProcedureCall
	return p
}

func (*ECS_MemberProcedureCallContext) IsECS_MemberProcedureCallContext() {}

func NewECS_MemberProcedureCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ECS_MemberProcedureCallContext {
	var p = new(ECS_MemberProcedureCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_eCS_MemberProcedureCall

	return p
}

func (s *ECS_MemberProcedureCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ECS_MemberProcedureCallContext) CALL() antlr.TerminalNode {
	return s.GetToken(vbaParserCALL, 0)
}

func (s *ECS_MemberProcedureCallContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ECS_MemberProcedureCallContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ECS_MemberProcedureCallContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *ECS_MemberProcedureCallContext) ImplicitCallStmt_InStmt() IImplicitCallStmt_InStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitCallStmt_InStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitCallStmt_InStmtContext)
}

func (s *ECS_MemberProcedureCallContext) TypeHint() ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *ECS_MemberProcedureCallContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(vbaParserLPAREN)
}

func (s *ECS_MemberProcedureCallContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, i)
}

func (s *ECS_MemberProcedureCallContext) ArgsCall() IArgsCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgsCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgsCallContext)
}

func (s *ECS_MemberProcedureCallContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(vbaParserRPAREN)
}

func (s *ECS_MemberProcedureCallContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, i)
}

func (s *ECS_MemberProcedureCallContext) AllSubscripts() []ISubscriptsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem())
	var tst = make([]ISubscriptsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptsContext)
		}
	}

	return tst
}

func (s *ECS_MemberProcedureCallContext) Subscripts(i int) ISubscriptsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptsContext)
}

func (s *ECS_MemberProcedureCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ECS_MemberProcedureCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ECS_MemberProcedureCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterECS_MemberProcedureCall(s)
	}
}

func (s *ECS_MemberProcedureCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitECS_MemberProcedureCall(s)
	}
}

func (p *vbaParser) ECS_MemberProcedureCall() (localctx IECS_MemberProcedureCallContext) {
	this := p
	_ = this

	localctx = NewECS_MemberProcedureCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, vbaParserRULE_eCS_MemberProcedureCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2189)
		p.Match(vbaParserCALL)
	}
	{
		p.SetState(2190)
		p.Match(vbaParserWS)
	}
	p.SetState(2192)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 347, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2191)
			p.ImplicitCallStmt_InStmt()
		}

	}
	{
		p.SetState(2194)
		p.Match(vbaParserT__3)
	}
	{
		p.SetState(2195)
		p.AmbiguousIdentifier()
	}
	p.SetState(2197)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 348, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2196)
			p.TypeHint()
		}

	}
	p.SetState(2212)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 352, p.GetParserRuleContext()) == 1 {
		p.SetState(2200)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2199)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2202)
			p.Match(vbaParserLPAREN)
		}
		p.SetState(2204)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 350, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2203)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2206)
			p.ArgsCall()
		}
		p.SetState(2208)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2207)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2210)
			p.Match(vbaParserRPAREN)
		}

	}
	p.SetState(2223)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 354, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2215)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2214)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2217)
				p.Match(vbaParserLPAREN)
			}
			{
				p.SetState(2218)
				p.Subscripts()
			}
			{
				p.SetState(2219)
				p.Match(vbaParserRPAREN)
			}

		}
		p.SetState(2225)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 354, p.GetParserRuleContext())
	}

	return localctx
}

// IImplicitCallStmt_InBlockContext is an interface to support dynamic dispatch.
type IImplicitCallStmt_InBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplicitCallStmt_InBlockContext differentiates from other interfaces.
	IsImplicitCallStmt_InBlockContext()
}

type ImplicitCallStmt_InBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplicitCallStmt_InBlockContext() *ImplicitCallStmt_InBlockContext {
	var p = new(ImplicitCallStmt_InBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_implicitCallStmt_InBlock
	return p
}

func (*ImplicitCallStmt_InBlockContext) IsImplicitCallStmt_InBlockContext() {}

func NewImplicitCallStmt_InBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplicitCallStmt_InBlockContext {
	var p = new(ImplicitCallStmt_InBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_implicitCallStmt_InBlock

	return p
}

func (s *ImplicitCallStmt_InBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplicitCallStmt_InBlockContext) ICS_B_MemberProcedureCall() IICS_B_MemberProcedureCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IICS_B_MemberProcedureCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IICS_B_MemberProcedureCallContext)
}

func (s *ImplicitCallStmt_InBlockContext) ICS_B_ProcedureCall() IICS_B_ProcedureCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IICS_B_ProcedureCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IICS_B_ProcedureCallContext)
}

func (s *ImplicitCallStmt_InBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplicitCallStmt_InBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplicitCallStmt_InBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterImplicitCallStmt_InBlock(s)
	}
}

func (s *ImplicitCallStmt_InBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitImplicitCallStmt_InBlock(s)
	}
}

func (p *vbaParser) ImplicitCallStmt_InBlock() (localctx IImplicitCallStmt_InBlockContext) {
	this := p
	_ = this

	localctx = NewImplicitCallStmt_InBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, vbaParserRULE_implicitCallStmt_InBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2228)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 355, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2226)
			p.ICS_B_MemberProcedureCall()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2227)
			p.ICS_B_ProcedureCall()
		}

	}

	return localctx
}

// IICS_B_MemberProcedureCallContext is an interface to support dynamic dispatch.
type IICS_B_MemberProcedureCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsICS_B_MemberProcedureCallContext differentiates from other interfaces.
	IsICS_B_MemberProcedureCallContext()
}

type ICS_B_MemberProcedureCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyICS_B_MemberProcedureCallContext() *ICS_B_MemberProcedureCallContext {
	var p = new(ICS_B_MemberProcedureCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_iCS_B_MemberProcedureCall
	return p
}

func (*ICS_B_MemberProcedureCallContext) IsICS_B_MemberProcedureCallContext() {}

func NewICS_B_MemberProcedureCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ICS_B_MemberProcedureCallContext {
	var p = new(ICS_B_MemberProcedureCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_iCS_B_MemberProcedureCall

	return p
}

func (s *ICS_B_MemberProcedureCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ICS_B_MemberProcedureCallContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *ICS_B_MemberProcedureCallContext) ImplicitCallStmt_InStmt() IImplicitCallStmt_InStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitCallStmt_InStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitCallStmt_InStmtContext)
}

func (s *ICS_B_MemberProcedureCallContext) TypeHint() ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *ICS_B_MemberProcedureCallContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ICS_B_MemberProcedureCallContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ICS_B_MemberProcedureCallContext) ArgsCall() IArgsCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgsCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgsCallContext)
}

func (s *ICS_B_MemberProcedureCallContext) DictionaryCallStmt() IDictionaryCallStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryCallStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryCallStmtContext)
}

func (s *ICS_B_MemberProcedureCallContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(vbaParserLPAREN)
}

func (s *ICS_B_MemberProcedureCallContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, i)
}

func (s *ICS_B_MemberProcedureCallContext) AllSubscripts() []ISubscriptsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem())
	var tst = make([]ISubscriptsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptsContext)
		}
	}

	return tst
}

func (s *ICS_B_MemberProcedureCallContext) Subscripts(i int) ISubscriptsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptsContext)
}

func (s *ICS_B_MemberProcedureCallContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(vbaParserRPAREN)
}

func (s *ICS_B_MemberProcedureCallContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, i)
}

func (s *ICS_B_MemberProcedureCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ICS_B_MemberProcedureCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ICS_B_MemberProcedureCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterICS_B_MemberProcedureCall(s)
	}
}

func (s *ICS_B_MemberProcedureCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitICS_B_MemberProcedureCall(s)
	}
}

func (p *vbaParser) ICS_B_MemberProcedureCall() (localctx IICS_B_MemberProcedureCallContext) {
	this := p
	_ = this

	localctx = NewICS_B_MemberProcedureCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, vbaParserRULE_iCS_B_MemberProcedureCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2231)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 356, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2230)
			p.ImplicitCallStmt_InStmt()
		}

	}
	{
		p.SetState(2233)
		p.Match(vbaParserT__3)
	}
	{
		p.SetState(2234)
		p.AmbiguousIdentifier()
	}
	p.SetState(2236)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 357, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2235)
			p.TypeHint()
		}

	}
	p.SetState(2240)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 358, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2238)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(2239)
			p.ArgsCall()
		}

	}
	p.SetState(2243)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 359, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2242)
			p.DictionaryCallStmt()
		}

	}
	p.SetState(2254)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 361, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2246)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2245)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2248)
				p.Match(vbaParserLPAREN)
			}
			{
				p.SetState(2249)
				p.Subscripts()
			}
			{
				p.SetState(2250)
				p.Match(vbaParserRPAREN)
			}

		}
		p.SetState(2256)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 361, p.GetParserRuleContext())
	}

	return localctx
}

// IICS_B_ProcedureCallContext is an interface to support dynamic dispatch.
type IICS_B_ProcedureCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsICS_B_ProcedureCallContext differentiates from other interfaces.
	IsICS_B_ProcedureCallContext()
}

type ICS_B_ProcedureCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyICS_B_ProcedureCallContext() *ICS_B_ProcedureCallContext {
	var p = new(ICS_B_ProcedureCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_iCS_B_ProcedureCall
	return p
}

func (*ICS_B_ProcedureCallContext) IsICS_B_ProcedureCallContext() {}

func NewICS_B_ProcedureCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ICS_B_ProcedureCallContext {
	var p = new(ICS_B_ProcedureCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_iCS_B_ProcedureCall

	return p
}

func (s *ICS_B_ProcedureCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ICS_B_ProcedureCallContext) CertainIdentifier() ICertainIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICertainIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICertainIdentifierContext)
}

func (s *ICS_B_ProcedureCallContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ICS_B_ProcedureCallContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ICS_B_ProcedureCallContext) ArgsCall() IArgsCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgsCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgsCallContext)
}

func (s *ICS_B_ProcedureCallContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(vbaParserLPAREN)
}

func (s *ICS_B_ProcedureCallContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, i)
}

func (s *ICS_B_ProcedureCallContext) AllSubscripts() []ISubscriptsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem())
	var tst = make([]ISubscriptsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptsContext)
		}
	}

	return tst
}

func (s *ICS_B_ProcedureCallContext) Subscripts(i int) ISubscriptsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptsContext)
}

func (s *ICS_B_ProcedureCallContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(vbaParserRPAREN)
}

func (s *ICS_B_ProcedureCallContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, i)
}

func (s *ICS_B_ProcedureCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ICS_B_ProcedureCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ICS_B_ProcedureCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterICS_B_ProcedureCall(s)
	}
}

func (s *ICS_B_ProcedureCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitICS_B_ProcedureCall(s)
	}
}

func (p *vbaParser) ICS_B_ProcedureCall() (localctx IICS_B_ProcedureCallContext) {
	this := p
	_ = this

	localctx = NewICS_B_ProcedureCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, vbaParserRULE_iCS_B_ProcedureCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2257)
		p.CertainIdentifier()
	}
	p.SetState(2260)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 362, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2258)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(2259)
			p.ArgsCall()
		}

	}
	p.SetState(2271)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 364, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2263)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2262)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2265)
				p.Match(vbaParserLPAREN)
			}
			{
				p.SetState(2266)
				p.Subscripts()
			}
			{
				p.SetState(2267)
				p.Match(vbaParserRPAREN)
			}

		}
		p.SetState(2273)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 364, p.GetParserRuleContext())
	}

	return localctx
}

// IImplicitCallStmt_InStmtContext is an interface to support dynamic dispatch.
type IImplicitCallStmt_InStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplicitCallStmt_InStmtContext differentiates from other interfaces.
	IsImplicitCallStmt_InStmtContext()
}

type ImplicitCallStmt_InStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplicitCallStmt_InStmtContext() *ImplicitCallStmt_InStmtContext {
	var p = new(ImplicitCallStmt_InStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_implicitCallStmt_InStmt
	return p
}

func (*ImplicitCallStmt_InStmtContext) IsImplicitCallStmt_InStmtContext() {}

func NewImplicitCallStmt_InStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplicitCallStmt_InStmtContext {
	var p = new(ImplicitCallStmt_InStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_implicitCallStmt_InStmt

	return p
}

func (s *ImplicitCallStmt_InStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplicitCallStmt_InStmtContext) ICS_S_MembersCall() IICS_S_MembersCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IICS_S_MembersCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IICS_S_MembersCallContext)
}

func (s *ImplicitCallStmt_InStmtContext) ICS_S_VariableOrProcedureCall() IICS_S_VariableOrProcedureCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IICS_S_VariableOrProcedureCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IICS_S_VariableOrProcedureCallContext)
}

func (s *ImplicitCallStmt_InStmtContext) ICS_S_ProcedureOrArrayCall() IICS_S_ProcedureOrArrayCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IICS_S_ProcedureOrArrayCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IICS_S_ProcedureOrArrayCallContext)
}

func (s *ImplicitCallStmt_InStmtContext) ICS_S_DictionaryCall() IICS_S_DictionaryCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IICS_S_DictionaryCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IICS_S_DictionaryCallContext)
}

func (s *ImplicitCallStmt_InStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplicitCallStmt_InStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplicitCallStmt_InStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterImplicitCallStmt_InStmt(s)
	}
}

func (s *ImplicitCallStmt_InStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitImplicitCallStmt_InStmt(s)
	}
}

func (p *vbaParser) ImplicitCallStmt_InStmt() (localctx IImplicitCallStmt_InStmtContext) {
	this := p
	_ = this

	localctx = NewImplicitCallStmt_InStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, vbaParserRULE_implicitCallStmt_InStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2278)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 365, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2274)
			p.ICS_S_MembersCall()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2275)
			p.ICS_S_VariableOrProcedureCall()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2276)
			p.ICS_S_ProcedureOrArrayCall()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2277)
			p.ICS_S_DictionaryCall()
		}

	}

	return localctx
}

// IICS_S_VariableOrProcedureCallContext is an interface to support dynamic dispatch.
type IICS_S_VariableOrProcedureCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsICS_S_VariableOrProcedureCallContext differentiates from other interfaces.
	IsICS_S_VariableOrProcedureCallContext()
}

type ICS_S_VariableOrProcedureCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyICS_S_VariableOrProcedureCallContext() *ICS_S_VariableOrProcedureCallContext {
	var p = new(ICS_S_VariableOrProcedureCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_iCS_S_VariableOrProcedureCall
	return p
}

func (*ICS_S_VariableOrProcedureCallContext) IsICS_S_VariableOrProcedureCallContext() {}

func NewICS_S_VariableOrProcedureCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ICS_S_VariableOrProcedureCallContext {
	var p = new(ICS_S_VariableOrProcedureCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_iCS_S_VariableOrProcedureCall

	return p
}

func (s *ICS_S_VariableOrProcedureCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ICS_S_VariableOrProcedureCallContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *ICS_S_VariableOrProcedureCallContext) TypeHint() ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *ICS_S_VariableOrProcedureCallContext) DictionaryCallStmt() IDictionaryCallStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryCallStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryCallStmtContext)
}

func (s *ICS_S_VariableOrProcedureCallContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(vbaParserLPAREN)
}

func (s *ICS_S_VariableOrProcedureCallContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, i)
}

func (s *ICS_S_VariableOrProcedureCallContext) AllSubscripts() []ISubscriptsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem())
	var tst = make([]ISubscriptsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptsContext)
		}
	}

	return tst
}

func (s *ICS_S_VariableOrProcedureCallContext) Subscripts(i int) ISubscriptsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptsContext)
}

func (s *ICS_S_VariableOrProcedureCallContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(vbaParserRPAREN)
}

func (s *ICS_S_VariableOrProcedureCallContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, i)
}

func (s *ICS_S_VariableOrProcedureCallContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ICS_S_VariableOrProcedureCallContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ICS_S_VariableOrProcedureCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ICS_S_VariableOrProcedureCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ICS_S_VariableOrProcedureCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterICS_S_VariableOrProcedureCall(s)
	}
}

func (s *ICS_S_VariableOrProcedureCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitICS_S_VariableOrProcedureCall(s)
	}
}

func (p *vbaParser) ICS_S_VariableOrProcedureCall() (localctx IICS_S_VariableOrProcedureCallContext) {
	this := p
	_ = this

	localctx = NewICS_S_VariableOrProcedureCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, vbaParserRULE_iCS_S_VariableOrProcedureCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2280)
		p.AmbiguousIdentifier()
	}
	p.SetState(2282)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 366, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2281)
			p.TypeHint()
		}

	}
	p.SetState(2285)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 367, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2284)
			p.DictionaryCallStmt()
		}

	}
	p.SetState(2296)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 369, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2288)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2287)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2290)
				p.Match(vbaParserLPAREN)
			}
			{
				p.SetState(2291)
				p.Subscripts()
			}
			{
				p.SetState(2292)
				p.Match(vbaParserRPAREN)
			}

		}
		p.SetState(2298)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 369, p.GetParserRuleContext())
	}

	return localctx
}

// IICS_S_ProcedureOrArrayCallContext is an interface to support dynamic dispatch.
type IICS_S_ProcedureOrArrayCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsICS_S_ProcedureOrArrayCallContext differentiates from other interfaces.
	IsICS_S_ProcedureOrArrayCallContext()
}

type ICS_S_ProcedureOrArrayCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyICS_S_ProcedureOrArrayCallContext() *ICS_S_ProcedureOrArrayCallContext {
	var p = new(ICS_S_ProcedureOrArrayCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_iCS_S_ProcedureOrArrayCall
	return p
}

func (*ICS_S_ProcedureOrArrayCallContext) IsICS_S_ProcedureOrArrayCallContext() {}

func NewICS_S_ProcedureOrArrayCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ICS_S_ProcedureOrArrayCallContext {
	var p = new(ICS_S_ProcedureOrArrayCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_iCS_S_ProcedureOrArrayCall

	return p
}

func (s *ICS_S_ProcedureOrArrayCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ICS_S_ProcedureOrArrayCallContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(vbaParserLPAREN)
}

func (s *ICS_S_ProcedureOrArrayCallContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, i)
}

func (s *ICS_S_ProcedureOrArrayCallContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(vbaParserRPAREN)
}

func (s *ICS_S_ProcedureOrArrayCallContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, i)
}

func (s *ICS_S_ProcedureOrArrayCallContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *ICS_S_ProcedureOrArrayCallContext) BaseType() IBaseTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBaseTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *ICS_S_ProcedureOrArrayCallContext) TypeHint() ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *ICS_S_ProcedureOrArrayCallContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ICS_S_ProcedureOrArrayCallContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ICS_S_ProcedureOrArrayCallContext) ArgsCall() IArgsCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgsCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgsCallContext)
}

func (s *ICS_S_ProcedureOrArrayCallContext) DictionaryCallStmt() IDictionaryCallStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryCallStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryCallStmtContext)
}

func (s *ICS_S_ProcedureOrArrayCallContext) AllSubscripts() []ISubscriptsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem())
	var tst = make([]ISubscriptsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptsContext)
		}
	}

	return tst
}

func (s *ICS_S_ProcedureOrArrayCallContext) Subscripts(i int) ISubscriptsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptsContext)
}

func (s *ICS_S_ProcedureOrArrayCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ICS_S_ProcedureOrArrayCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ICS_S_ProcedureOrArrayCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterICS_S_ProcedureOrArrayCall(s)
	}
}

func (s *ICS_S_ProcedureOrArrayCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitICS_S_ProcedureOrArrayCall(s)
	}
}

func (p *vbaParser) ICS_S_ProcedureOrArrayCall() (localctx IICS_S_ProcedureOrArrayCallContext) {
	this := p
	_ = this

	localctx = NewICS_S_ProcedureOrArrayCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, vbaParserRULE_iCS_S_ProcedureOrArrayCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2301)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 370, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2299)
			p.AmbiguousIdentifier()
		}

	case 2:
		{
			p.SetState(2300)
			p.BaseType()
		}

	}
	p.SetState(2304)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__2)|(1<<vbaParserT__4)|(1<<vbaParserT__5)|(1<<vbaParserT__6)|(1<<vbaParserT__7))) != 0) || _la == vbaParserAMPERSAND {
		{
			p.SetState(2303)
			p.TypeHint()
		}

	}
	p.SetState(2307)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(2306)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(2309)
		p.Match(vbaParserLPAREN)
	}
	p.SetState(2311)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 373, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2310)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(2317)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 375, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2313)
			p.ArgsCall()
		}
		p.SetState(2315)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2314)
				p.Match(vbaParserWS)
			}

		}

	}
	{
		p.SetState(2319)
		p.Match(vbaParserRPAREN)
	}
	p.SetState(2321)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 376, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2320)
			p.DictionaryCallStmt()
		}

	}
	p.SetState(2332)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 378, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2324)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2323)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2326)
				p.Match(vbaParserLPAREN)
			}
			{
				p.SetState(2327)
				p.Subscripts()
			}
			{
				p.SetState(2328)
				p.Match(vbaParserRPAREN)
			}

		}
		p.SetState(2334)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 378, p.GetParserRuleContext())
	}

	return localctx
}

// IICS_S_MembersCallContext is an interface to support dynamic dispatch.
type IICS_S_MembersCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsICS_S_MembersCallContext differentiates from other interfaces.
	IsICS_S_MembersCallContext()
}

type ICS_S_MembersCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyICS_S_MembersCallContext() *ICS_S_MembersCallContext {
	var p = new(ICS_S_MembersCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_iCS_S_MembersCall
	return p
}

func (*ICS_S_MembersCallContext) IsICS_S_MembersCallContext() {}

func NewICS_S_MembersCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ICS_S_MembersCallContext {
	var p = new(ICS_S_MembersCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_iCS_S_MembersCall

	return p
}

func (s *ICS_S_MembersCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ICS_S_MembersCallContext) ICS_S_VariableOrProcedureCall() IICS_S_VariableOrProcedureCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IICS_S_VariableOrProcedureCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IICS_S_VariableOrProcedureCallContext)
}

func (s *ICS_S_MembersCallContext) ICS_S_ProcedureOrArrayCall() IICS_S_ProcedureOrArrayCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IICS_S_ProcedureOrArrayCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IICS_S_ProcedureOrArrayCallContext)
}

func (s *ICS_S_MembersCallContext) AllICS_S_MemberCall() []IICS_S_MemberCallContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IICS_S_MemberCallContext)(nil)).Elem())
	var tst = make([]IICS_S_MemberCallContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IICS_S_MemberCallContext)
		}
	}

	return tst
}

func (s *ICS_S_MembersCallContext) ICS_S_MemberCall(i int) IICS_S_MemberCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IICS_S_MemberCallContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IICS_S_MemberCallContext)
}

func (s *ICS_S_MembersCallContext) DictionaryCallStmt() IDictionaryCallStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryCallStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryCallStmtContext)
}

func (s *ICS_S_MembersCallContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(vbaParserLPAREN)
}

func (s *ICS_S_MembersCallContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, i)
}

func (s *ICS_S_MembersCallContext) AllSubscripts() []ISubscriptsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem())
	var tst = make([]ISubscriptsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptsContext)
		}
	}

	return tst
}

func (s *ICS_S_MembersCallContext) Subscripts(i int) ISubscriptsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptsContext)
}

func (s *ICS_S_MembersCallContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(vbaParserRPAREN)
}

func (s *ICS_S_MembersCallContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, i)
}

func (s *ICS_S_MembersCallContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ICS_S_MembersCallContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ICS_S_MembersCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ICS_S_MembersCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ICS_S_MembersCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterICS_S_MembersCall(s)
	}
}

func (s *ICS_S_MembersCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitICS_S_MembersCall(s)
	}
}

func (p *vbaParser) ICS_S_MembersCall() (localctx IICS_S_MembersCallContext) {
	this := p
	_ = this

	localctx = NewICS_S_MembersCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, vbaParserRULE_iCS_S_MembersCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2337)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 379, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2335)
			p.ICS_S_VariableOrProcedureCall()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 379, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2336)
			p.ICS_S_ProcedureOrArrayCall()
		}

	}
	p.SetState(2340)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2339)
				p.ICS_S_MemberCall()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2342)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 380, p.GetParserRuleContext())
	}
	p.SetState(2345)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 381, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2344)
			p.DictionaryCallStmt()
		}

	}
	p.SetState(2356)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 383, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2348)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2347)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2350)
				p.Match(vbaParserLPAREN)
			}
			{
				p.SetState(2351)
				p.Subscripts()
			}
			{
				p.SetState(2352)
				p.Match(vbaParserRPAREN)
			}

		}
		p.SetState(2358)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 383, p.GetParserRuleContext())
	}

	return localctx
}

// IICS_S_MemberCallContext is an interface to support dynamic dispatch.
type IICS_S_MemberCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsICS_S_MemberCallContext differentiates from other interfaces.
	IsICS_S_MemberCallContext()
}

type ICS_S_MemberCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyICS_S_MemberCallContext() *ICS_S_MemberCallContext {
	var p = new(ICS_S_MemberCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_iCS_S_MemberCall
	return p
}

func (*ICS_S_MemberCallContext) IsICS_S_MemberCallContext() {}

func NewICS_S_MemberCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ICS_S_MemberCallContext {
	var p = new(ICS_S_MemberCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_iCS_S_MemberCall

	return p
}

func (s *ICS_S_MemberCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ICS_S_MemberCallContext) ICS_S_VariableOrProcedureCall() IICS_S_VariableOrProcedureCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IICS_S_VariableOrProcedureCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IICS_S_VariableOrProcedureCallContext)
}

func (s *ICS_S_MemberCallContext) ICS_S_ProcedureOrArrayCall() IICS_S_ProcedureOrArrayCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IICS_S_ProcedureOrArrayCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IICS_S_ProcedureOrArrayCallContext)
}

func (s *ICS_S_MemberCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ICS_S_MemberCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ICS_S_MemberCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterICS_S_MemberCall(s)
	}
}

func (s *ICS_S_MemberCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitICS_S_MemberCall(s)
	}
}

func (p *vbaParser) ICS_S_MemberCall() (localctx IICS_S_MemberCallContext) {
	this := p
	_ = this

	localctx = NewICS_S_MemberCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, vbaParserRULE_iCS_S_MemberCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2359)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vbaParserT__3 || _la == vbaParserT__4) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2362)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 384, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2360)
			p.ICS_S_VariableOrProcedureCall()
		}

	case 2:
		{
			p.SetState(2361)
			p.ICS_S_ProcedureOrArrayCall()
		}

	}

	return localctx
}

// IICS_S_DictionaryCallContext is an interface to support dynamic dispatch.
type IICS_S_DictionaryCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsICS_S_DictionaryCallContext differentiates from other interfaces.
	IsICS_S_DictionaryCallContext()
}

type ICS_S_DictionaryCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyICS_S_DictionaryCallContext() *ICS_S_DictionaryCallContext {
	var p = new(ICS_S_DictionaryCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_iCS_S_DictionaryCall
	return p
}

func (*ICS_S_DictionaryCallContext) IsICS_S_DictionaryCallContext() {}

func NewICS_S_DictionaryCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ICS_S_DictionaryCallContext {
	var p = new(ICS_S_DictionaryCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_iCS_S_DictionaryCall

	return p
}

func (s *ICS_S_DictionaryCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ICS_S_DictionaryCallContext) DictionaryCallStmt() IDictionaryCallStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryCallStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryCallStmtContext)
}

func (s *ICS_S_DictionaryCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ICS_S_DictionaryCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ICS_S_DictionaryCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterICS_S_DictionaryCall(s)
	}
}

func (s *ICS_S_DictionaryCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitICS_S_DictionaryCall(s)
	}
}

func (p *vbaParser) ICS_S_DictionaryCall() (localctx IICS_S_DictionaryCallContext) {
	this := p
	_ = this

	localctx = NewICS_S_DictionaryCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, vbaParserRULE_iCS_S_DictionaryCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2364)
		p.DictionaryCallStmt()
	}

	return localctx
}

// IArgsCallContext is an interface to support dynamic dispatch.
type IArgsCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgsCallContext differentiates from other interfaces.
	IsArgsCallContext()
}

type ArgsCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgsCallContext() *ArgsCallContext {
	var p = new(ArgsCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_argsCall
	return p
}

func (*ArgsCallContext) IsArgsCallContext() {}

func NewArgsCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgsCallContext {
	var p = new(ArgsCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_argsCall

	return p
}

func (s *ArgsCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgsCallContext) AllArgCall() []IArgCallContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgCallContext)(nil)).Elem())
	var tst = make([]IArgCallContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgCallContext)
		}
	}

	return tst
}

func (s *ArgsCallContext) ArgCall(i int) IArgCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgCallContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgCallContext)
}

func (s *ArgsCallContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ArgsCallContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ArgsCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgsCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgsCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterArgsCall(s)
	}
}

func (s *ArgsCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitArgsCall(s)
	}
}

func (p *vbaParser) ArgsCall() (localctx IArgsCallContext) {
	this := p
	_ = this

	localctx = NewArgsCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, vbaParserRULE_argsCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2378)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 388, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2367)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__3)|(1<<vbaParserT__4)|(1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0) || (((_la-193)&-(0x1f+1)) == 0 && ((1<<uint((_la-193)))&((1<<(vbaParserLPAREN-193))|(1<<(vbaParserMINUS-193))|(1<<(vbaParserPLUS-193))|(1<<(vbaParserRPAREN-193))|(1<<(vbaParserSTRINGLITERAL-193))|(1<<(vbaParserOCTLITERAL-193))|(1<<(vbaParserHEXLITERAL-193))|(1<<(vbaParserSHORTLITERAL-193))|(1<<(vbaParserINTEGERLITERAL-193))|(1<<(vbaParserDOUBLELITERAL-193))|(1<<(vbaParserDATELITERAL-193))|(1<<(vbaParserIDENTIFIER-193)))) != 0) {
				{
					p.SetState(2366)
					p.ArgCall()
				}

			}
			p.SetState(2370)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2369)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2372)
				_la = p.GetTokenStream().LA(1)

				if !(_la == vbaParserT__0 || _la == vbaParserT__1) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(2374)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 387, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2373)
					p.Match(vbaParserWS)
				}

			}

		}
		p.SetState(2380)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 388, p.GetParserRuleContext())
	}
	{
		p.SetState(2381)
		p.ArgCall()
	}
	p.SetState(2394)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 392, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2383)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2382)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2385)
				_la = p.GetTokenStream().LA(1)

				if !(_la == vbaParserT__0 || _la == vbaParserT__1) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(2387)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 390, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2386)
					p.Match(vbaParserWS)
				}

			}
			p.SetState(2390)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 391, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2389)
					p.ArgCall()
				}

			}

		}
		p.SetState(2396)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 392, p.GetParserRuleContext())
	}

	return localctx
}

// IArgCallContext is an interface to support dynamic dispatch.
type IArgCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgCallContext differentiates from other interfaces.
	IsArgCallContext()
}

type ArgCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgCallContext() *ArgCallContext {
	var p = new(ArgCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_argCall
	return p
}

func (*ArgCallContext) IsArgCallContext() {}

func NewArgCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgCallContext {
	var p = new(ArgCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_argCall

	return p
}

func (s *ArgCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgCallContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *ArgCallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, 0)
}

func (s *ArgCallContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *ArgCallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, 0)
}

func (s *ArgCallContext) BYVAL() antlr.TerminalNode {
	return s.GetToken(vbaParserBYVAL, 0)
}

func (s *ArgCallContext) BYREF() antlr.TerminalNode {
	return s.GetToken(vbaParserBYREF, 0)
}

func (s *ArgCallContext) PARAMARRAY() antlr.TerminalNode {
	return s.GetToken(vbaParserPARAMARRAY, 0)
}

func (s *ArgCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterArgCall(s)
	}
}

func (s *ArgCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitArgCall(s)
	}
}

func (p *vbaParser) ArgCall() (localctx IArgCallContext) {
	this := p
	_ = this

	localctx = NewArgCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, vbaParserRULE_argCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2398)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 393, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2397)
			p.Match(vbaParserLPAREN)
		}

	}
	p.SetState(2402)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 394, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2400)
			_la = p.GetTokenStream().LA(1)

			if !(_la == vbaParserBYVAL || _la == vbaParserBYREF || _la == vbaParserPARAMARRAY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2401)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(2405)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserRPAREN {
		{
			p.SetState(2404)
			p.Match(vbaParserRPAREN)
		}

	}
	{
		p.SetState(2407)
		p.valueStmt(0)
	}

	return localctx
}

// IDictionaryCallStmtContext is an interface to support dynamic dispatch.
type IDictionaryCallStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryCallStmtContext differentiates from other interfaces.
	IsDictionaryCallStmtContext()
}

type DictionaryCallStmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryCallStmtContext() *DictionaryCallStmtContext {
	var p = new(DictionaryCallStmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_dictionaryCallStmt
	return p
}

func (*DictionaryCallStmtContext) IsDictionaryCallStmtContext() {}

func NewDictionaryCallStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryCallStmtContext {
	var p = new(DictionaryCallStmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_dictionaryCallStmt

	return p
}

func (s *DictionaryCallStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryCallStmtContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *DictionaryCallStmtContext) TypeHint() ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *DictionaryCallStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryCallStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryCallStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterDictionaryCallStmt(s)
	}
}

func (s *DictionaryCallStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitDictionaryCallStmt(s)
	}
}

func (p *vbaParser) DictionaryCallStmt() (localctx IDictionaryCallStmtContext) {
	this := p
	_ = this

	localctx = NewDictionaryCallStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, vbaParserRULE_dictionaryCallStmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2409)
		p.Match(vbaParserT__4)
	}
	{
		p.SetState(2410)
		p.AmbiguousIdentifier()
	}
	p.SetState(2412)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 396, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2411)
			p.TypeHint()
		}

	}

	return localctx
}

// IArgListContext is an interface to support dynamic dispatch.
type IArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgListContext differentiates from other interfaces.
	IsArgListContext()
}

type ArgListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgListContext() *ArgListContext {
	var p = new(ArgListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_argList
	return p
}

func (*ArgListContext) IsArgListContext() {}

func NewArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgListContext {
	var p = new(ArgListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_argList

	return p
}

func (s *ArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgListContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, 0)
}

func (s *ArgListContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, 0)
}

func (s *ArgListContext) AllArg() []IArgContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgContext)(nil)).Elem())
	var tst = make([]IArgContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgContext)
		}
	}

	return tst
}

func (s *ArgListContext) Arg(i int) IArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgContext)
}

func (s *ArgListContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ArgListContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterArgList(s)
	}
}

func (s *ArgListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitArgList(s)
	}
}

func (p *vbaParser) ArgList() (localctx IArgListContext) {
	this := p
	_ = this

	localctx = NewArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, vbaParserRULE_argList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2414)
		p.Match(vbaParserLPAREN)
	}
	p.SetState(2432)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 401, p.GetParserRuleContext()) == 1 {
		p.SetState(2416)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2415)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2418)
			p.Arg()
		}
		p.SetState(2429)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 400, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2420)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(2419)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(2422)
					p.Match(vbaParserT__0)
				}
				p.SetState(2424)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(2423)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(2426)
					p.Arg()
				}

			}
			p.SetState(2431)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 400, p.GetParserRuleContext())
		}

	}
	p.SetState(2435)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(2434)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(2437)
		p.Match(vbaParserRPAREN)
	}

	return localctx
}

// IArgContext is an interface to support dynamic dispatch.
type IArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgContext differentiates from other interfaces.
	IsArgContext()
}

type ArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgContext() *ArgContext {
	var p = new(ArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_arg
	return p
}

func (*ArgContext) IsArgContext() {}

func NewArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgContext {
	var p = new(ArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_arg

	return p
}

func (s *ArgContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *ArgContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(vbaParserOPTIONAL, 0)
}

func (s *ArgContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *ArgContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *ArgContext) PARAMARRAY() antlr.TerminalNode {
	return s.GetToken(vbaParserPARAMARRAY, 0)
}

func (s *ArgContext) TypeHint() ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *ArgContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, 0)
}

func (s *ArgContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, 0)
}

func (s *ArgContext) AsTypeClause() IAsTypeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsTypeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsTypeClauseContext)
}

func (s *ArgContext) ArgDefaultValue() IArgDefaultValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgDefaultValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgDefaultValueContext)
}

func (s *ArgContext) BYVAL() antlr.TerminalNode {
	return s.GetToken(vbaParserBYVAL, 0)
}

func (s *ArgContext) BYREF() antlr.TerminalNode {
	return s.GetToken(vbaParserBYREF, 0)
}

func (s *ArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterArg(s)
	}
}

func (s *ArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitArg(s)
	}
}

func (p *vbaParser) Arg() (localctx IArgContext) {
	this := p
	_ = this

	localctx = NewArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, vbaParserRULE_arg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2441)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 403, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2439)
			p.Match(vbaParserOPTIONAL)
		}
		{
			p.SetState(2440)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(2445)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 404, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2443)
			_la = p.GetTokenStream().LA(1)

			if !(_la == vbaParserBYVAL || _la == vbaParserBYREF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2444)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(2449)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 405, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2447)
			p.Match(vbaParserPARAMARRAY)
		}
		{
			p.SetState(2448)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(2451)
		p.AmbiguousIdentifier()
	}
	p.SetState(2453)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__2)|(1<<vbaParserT__4)|(1<<vbaParserT__5)|(1<<vbaParserT__6)|(1<<vbaParserT__7))) != 0) || _la == vbaParserAMPERSAND {
		{
			p.SetState(2452)
			p.TypeHint()
		}

	}
	p.SetState(2463)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 409, p.GetParserRuleContext()) == 1 {
		p.SetState(2456)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2455)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2458)
			p.Match(vbaParserLPAREN)
		}
		p.SetState(2460)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2459)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2462)
			p.Match(vbaParserRPAREN)
		}

	}
	p.SetState(2469)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 411, p.GetParserRuleContext()) == 1 {
		p.SetState(2466)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2465)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2468)
			p.AsTypeClause()
		}

	}
	p.SetState(2475)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 413, p.GetParserRuleContext()) == 1 {
		p.SetState(2472)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2471)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2474)
			p.ArgDefaultValue()
		}

	}

	return localctx
}

// IArgDefaultValueContext is an interface to support dynamic dispatch.
type IArgDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgDefaultValueContext differentiates from other interfaces.
	IsArgDefaultValueContext()
}

type ArgDefaultValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgDefaultValueContext() *ArgDefaultValueContext {
	var p = new(ArgDefaultValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_argDefaultValue
	return p
}

func (*ArgDefaultValueContext) IsArgDefaultValueContext() {}

func NewArgDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgDefaultValueContext {
	var p = new(ArgDefaultValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_argDefaultValue

	return p
}

func (s *ArgDefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgDefaultValueContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *ArgDefaultValueContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *ArgDefaultValueContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *ArgDefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgDefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgDefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterArgDefaultValue(s)
	}
}

func (s *ArgDefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitArgDefaultValue(s)
	}
}

func (p *vbaParser) ArgDefaultValue() (localctx IArgDefaultValueContext) {
	this := p
	_ = this

	localctx = NewArgDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, vbaParserRULE_argDefaultValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2477)
		p.Match(vbaParserEQ)
	}
	p.SetState(2479)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(2478)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(2481)
		p.valueStmt(0)
	}

	return localctx
}

// ISubscriptsContext is an interface to support dynamic dispatch.
type ISubscriptsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriptsContext differentiates from other interfaces.
	IsSubscriptsContext()
}

type SubscriptsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptsContext() *SubscriptsContext {
	var p = new(SubscriptsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_subscripts
	return p
}

func (*SubscriptsContext) IsSubscriptsContext() {}

func NewSubscriptsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptsContext {
	var p = new(SubscriptsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_subscripts

	return p
}

func (s *SubscriptsContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptsContext) AllSubscript_() []ISubscript_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscript_Context)(nil)).Elem())
	var tst = make([]ISubscript_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscript_Context)
		}
	}

	return tst
}

func (s *SubscriptsContext) Subscript_(i int) ISubscript_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscript_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscript_Context)
}

func (s *SubscriptsContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *SubscriptsContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *SubscriptsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriptsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterSubscripts(s)
	}
}

func (s *SubscriptsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitSubscripts(s)
	}
}

func (p *vbaParser) Subscripts() (localctx ISubscriptsContext) {
	this := p
	_ = this

	localctx = NewSubscriptsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, vbaParserRULE_subscripts)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2483)
		p.Subscript_()
	}
	p.SetState(2494)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 417, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2485)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2484)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2487)
				p.Match(vbaParserT__0)
			}
			p.SetState(2489)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2488)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2491)
				p.Subscript_()
			}

		}
		p.SetState(2496)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 417, p.GetParserRuleContext())
	}

	return localctx
}

// ISubscript_Context is an interface to support dynamic dispatch.
type ISubscript_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscript_Context differentiates from other interfaces.
	IsSubscript_Context()
}

type Subscript_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscript_Context() *Subscript_Context {
	var p = new(Subscript_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_subscript_
	return p
}

func (*Subscript_Context) IsSubscript_Context() {}

func NewSubscript_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subscript_Context {
	var p = new(Subscript_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_subscript_

	return p
}

func (s *Subscript_Context) GetParser() antlr.Parser { return s.parser }

func (s *Subscript_Context) AllValueStmt() []IValueStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueStmtContext)(nil)).Elem())
	var tst = make([]IValueStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueStmtContext)
		}
	}

	return tst
}

func (s *Subscript_Context) ValueStmt(i int) IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *Subscript_Context) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *Subscript_Context) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *Subscript_Context) TO() antlr.TerminalNode {
	return s.GetToken(vbaParserTO, 0)
}

func (s *Subscript_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subscript_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subscript_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterSubscript_(s)
	}
}

func (s *Subscript_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitSubscript_(s)
	}
}

func (p *vbaParser) Subscript_() (localctx ISubscript_Context) {
	this := p
	_ = this

	localctx = NewSubscript_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, vbaParserRULE_subscript_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2502)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 418, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2497)
			p.valueStmt(0)
		}
		{
			p.SetState(2498)
			p.Match(vbaParserWS)
		}
		{
			p.SetState(2499)
			p.Match(vbaParserTO)
		}
		{
			p.SetState(2500)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(2504)
		p.valueStmt(0)
	}

	return localctx
}

// IAmbiguousIdentifierContext is an interface to support dynamic dispatch.
type IAmbiguousIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAmbiguousIdentifierContext differentiates from other interfaces.
	IsAmbiguousIdentifierContext()
}

type AmbiguousIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAmbiguousIdentifierContext() *AmbiguousIdentifierContext {
	var p = new(AmbiguousIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_ambiguousIdentifier
	return p
}

func (*AmbiguousIdentifierContext) IsAmbiguousIdentifierContext() {}

func NewAmbiguousIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AmbiguousIdentifierContext {
	var p = new(AmbiguousIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_ambiguousIdentifier

	return p
}

func (s *AmbiguousIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AmbiguousIdentifierContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(vbaParserIDENTIFIER)
}

func (s *AmbiguousIdentifierContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserIDENTIFIER, i)
}

func (s *AmbiguousIdentifierContext) AllAmbiguousKeyword() []IAmbiguousKeywordContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAmbiguousKeywordContext)(nil)).Elem())
	var tst = make([]IAmbiguousKeywordContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAmbiguousKeywordContext)
		}
	}

	return tst
}

func (s *AmbiguousIdentifierContext) AmbiguousKeyword(i int) IAmbiguousKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousKeywordContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousKeywordContext)
}

func (s *AmbiguousIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AmbiguousIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AmbiguousIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterAmbiguousIdentifier(s)
	}
}

func (s *AmbiguousIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitAmbiguousIdentifier(s)
	}
}

func (p *vbaParser) AmbiguousIdentifier() (localctx IAmbiguousIdentifierContext) {
	this := p
	_ = this

	localctx = NewAmbiguousIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, vbaParserRULE_ambiguousIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2508)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(2508)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case vbaParserIDENTIFIER:
				{
					p.SetState(2506)
					p.Match(vbaParserIDENTIFIER)
				}

			case vbaParserACCESS, vbaParserADDRESSOF, vbaParserALIAS, vbaParserAND, vbaParserATTRIBUTE, vbaParserAPPACTIVATE, vbaParserAPPEND, vbaParserAS, vbaParserBEGIN, vbaParserBEEP, vbaParserBINARY, vbaParserBOOLEAN, vbaParserBYVAL, vbaParserBYREF, vbaParserBYTE, vbaParserCALL, vbaParserCASE, vbaParserCHDIR, vbaParserCHDRIVE, vbaParserCLASS, vbaParserCLOSE, vbaParserCOLLECTION, vbaParserCONST, vbaParserDATABASE, vbaParserDATE, vbaParserDECLARE, vbaParserDEFBOOL, vbaParserDEFBYTE, vbaParserDEFDATE, vbaParserDEFDBL, vbaParserDEFDEC, vbaParserDEFCUR, vbaParserDEFINT, vbaParserDEFLNG, vbaParserDEFOBJ, vbaParserDEFSNG, vbaParserDEFSTR, vbaParserDEFVAR, vbaParserDELETESETTING, vbaParserDIM, vbaParserDO, vbaParserDOUBLE, vbaParserEACH, vbaParserELSE, vbaParserELSEIF, vbaParserEND, vbaParserENUM, vbaParserEQV, vbaParserERASE, vbaParserERROR, vbaParserEVENT, vbaParserFALSE, vbaParserFILECOPY, vbaParserFRIEND, vbaParserFOR, vbaParserFUNCTION, vbaParserGET, vbaParserGLOBAL, vbaParserGOSUB, vbaParserGOTO, vbaParserIF, vbaParserIMP, vbaParserIMPLEMENTS, vbaParserIN, vbaParserINPUT, vbaParserIS, vbaParserINTEGER, vbaParserKILL, vbaParserLOAD, vbaParserLOCK, vbaParserLONG, vbaParserLOOP, vbaParserLEN, vbaParserLET, vbaParserLIB, vbaParserLIKE, vbaParserLSET, vbaParserME, vbaParserMID, vbaParserMKDIR, vbaParserMOD, vbaParserNAME, vbaParserNEXT, vbaParserNEW, vbaParserNOT, vbaParserNOTHING, vbaParserNULL_, vbaParserON, vbaParserOPEN, vbaParserOPTIONAL, vbaParserOR, vbaParserOUTPUT, vbaParserPARAMARRAY, vbaParserPRESERVE, vbaParserPRINT, vbaParserPRIVATE, vbaParserPUBLIC, vbaParserPUT, vbaParserRANDOM, vbaParserRANDOMIZE, vbaParserRAISEEVENT, vbaParserREAD, vbaParserREDIM, vbaParserREM, vbaParserRESET, vbaParserRESUME, vbaParserRETURN, vbaParserRMDIR, vbaParserRSET, vbaParserSAVEPICTURE, vbaParserSAVESETTING, vbaParserSEEK, vbaParserSELECT, vbaParserSENDKEYS, vbaParserSET, vbaParserSETATTR, vbaParserSHARED, vbaParserSINGLE, vbaParserSPC, vbaParserSTATIC, vbaParserSTEP, vbaParserSTOP, vbaParserSTRING, vbaParserSUB, vbaParserTAB, vbaParserTEXT, vbaParserTHEN, vbaParserTIME, vbaParserTO, vbaParserTRUE, vbaParserTYPE, vbaParserTYPEOF, vbaParserUNLOAD, vbaParserUNLOCK, vbaParserUNTIL, vbaParserVARIANT, vbaParserVERSION, vbaParserWEND, vbaParserWHILE, vbaParserWIDTH, vbaParserWITH, vbaParserWITHEVENTS, vbaParserWRITE, vbaParserXOR:
				{
					p.SetState(2507)
					p.AmbiguousKeyword()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2510)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 420, p.GetParserRuleContext())
	}

	return localctx
}

// IAsTypeClauseContext is an interface to support dynamic dispatch.
type IAsTypeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsTypeClauseContext differentiates from other interfaces.
	IsAsTypeClauseContext()
}

type AsTypeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsTypeClauseContext() *AsTypeClauseContext {
	var p = new(AsTypeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_asTypeClause
	return p
}

func (*AsTypeClauseContext) IsAsTypeClauseContext() {}

func NewAsTypeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsTypeClauseContext {
	var p = new(AsTypeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_asTypeClause

	return p
}

func (s *AsTypeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AsTypeClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(vbaParserAS, 0)
}

func (s *AsTypeClauseContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *AsTypeClauseContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *AsTypeClauseContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *AsTypeClauseContext) NEW() antlr.TerminalNode {
	return s.GetToken(vbaParserNEW, 0)
}

func (s *AsTypeClauseContext) FieldLength() IFieldLengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldLengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldLengthContext)
}

func (s *AsTypeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsTypeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsTypeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterAsTypeClause(s)
	}
}

func (s *AsTypeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitAsTypeClause(s)
	}
}

func (p *vbaParser) AsTypeClause() (localctx IAsTypeClauseContext) {
	this := p
	_ = this

	localctx = NewAsTypeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, vbaParserRULE_asTypeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2512)
		p.Match(vbaParserAS)
	}
	p.SetState(2514)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(2513)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(2518)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 422, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2516)
			p.Match(vbaParserNEW)
		}
		{
			p.SetState(2517)
			p.Match(vbaParserWS)
		}

	}
	{
		p.SetState(2520)
		p.Type_()
	}
	p.SetState(2525)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 424, p.GetParserRuleContext()) == 1 {
		p.SetState(2522)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2521)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2524)
			p.FieldLength()
		}

	}

	return localctx
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_baseType
	return p
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(vbaParserBOOLEAN, 0)
}

func (s *BaseTypeContext) BYTE() antlr.TerminalNode {
	return s.GetToken(vbaParserBYTE, 0)
}

func (s *BaseTypeContext) COLLECTION() antlr.TerminalNode {
	return s.GetToken(vbaParserCOLLECTION, 0)
}

func (s *BaseTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(vbaParserDATE, 0)
}

func (s *BaseTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(vbaParserDOUBLE, 0)
}

func (s *BaseTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(vbaParserINTEGER, 0)
}

func (s *BaseTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(vbaParserLONG, 0)
}

func (s *BaseTypeContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(vbaParserSINGLE, 0)
}

func (s *BaseTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(vbaParserSTRING, 0)
}

func (s *BaseTypeContext) MULT() antlr.TerminalNode {
	return s.GetToken(vbaParserMULT, 0)
}

func (s *BaseTypeContext) ValueStmt() IValueStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueStmtContext)
}

func (s *BaseTypeContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *BaseTypeContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *BaseTypeContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(vbaParserVARIANT, 0)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (p *vbaParser) BaseType() (localctx IBaseTypeContext) {
	this := p
	_ = this

	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, vbaParserRULE_baseType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2547)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vbaParserBOOLEAN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2527)
			p.Match(vbaParserBOOLEAN)
		}

	case vbaParserBYTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2528)
			p.Match(vbaParserBYTE)
		}

	case vbaParserCOLLECTION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2529)
			p.Match(vbaParserCOLLECTION)
		}

	case vbaParserDATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2530)
			p.Match(vbaParserDATE)
		}

	case vbaParserDOUBLE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2531)
			p.Match(vbaParserDOUBLE)
		}

	case vbaParserINTEGER:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2532)
			p.Match(vbaParserINTEGER)
		}

	case vbaParserLONG:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2533)
			p.Match(vbaParserLONG)
		}

	case vbaParserSINGLE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2534)
			p.Match(vbaParserSINGLE)
		}

	case vbaParserSTRING:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2535)
			p.Match(vbaParserSTRING)
		}
		p.SetState(2544)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 427, p.GetParserRuleContext()) == 1 {
			p.SetState(2537)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2536)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2539)
				p.Match(vbaParserMULT)
			}
			p.SetState(2541)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == vbaParserWS {
				{
					p.SetState(2540)
					p.Match(vbaParserWS)
				}

			}
			{
				p.SetState(2543)
				p.valueStmt(0)
			}

		}

	case vbaParserVARIANT:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2546)
			p.Match(vbaParserVARIANT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICertainIdentifierContext is an interface to support dynamic dispatch.
type ICertainIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCertainIdentifierContext differentiates from other interfaces.
	IsCertainIdentifierContext()
}

type CertainIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCertainIdentifierContext() *CertainIdentifierContext {
	var p = new(CertainIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_certainIdentifier
	return p
}

func (*CertainIdentifierContext) IsCertainIdentifierContext() {}

func NewCertainIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CertainIdentifierContext {
	var p = new(CertainIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_certainIdentifier

	return p
}

func (s *CertainIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *CertainIdentifierContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(vbaParserIDENTIFIER)
}

func (s *CertainIdentifierContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserIDENTIFIER, i)
}

func (s *CertainIdentifierContext) AllAmbiguousKeyword() []IAmbiguousKeywordContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAmbiguousKeywordContext)(nil)).Elem())
	var tst = make([]IAmbiguousKeywordContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAmbiguousKeywordContext)
		}
	}

	return tst
}

func (s *CertainIdentifierContext) AmbiguousKeyword(i int) IAmbiguousKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousKeywordContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousKeywordContext)
}

func (s *CertainIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CertainIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CertainIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterCertainIdentifier(s)
	}
}

func (s *CertainIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitCertainIdentifier(s)
	}
}

func (p *vbaParser) CertainIdentifier() (localctx ICertainIdentifierContext) {
	this := p
	_ = this

	localctx = NewCertainIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, vbaParserRULE_certainIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2564)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vbaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2549)
			p.Match(vbaParserIDENTIFIER)
		}
		p.SetState(2554)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 430, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2552)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case vbaParserACCESS, vbaParserADDRESSOF, vbaParserALIAS, vbaParserAND, vbaParserATTRIBUTE, vbaParserAPPACTIVATE, vbaParserAPPEND, vbaParserAS, vbaParserBEGIN, vbaParserBEEP, vbaParserBINARY, vbaParserBOOLEAN, vbaParserBYVAL, vbaParserBYREF, vbaParserBYTE, vbaParserCALL, vbaParserCASE, vbaParserCHDIR, vbaParserCHDRIVE, vbaParserCLASS, vbaParserCLOSE, vbaParserCOLLECTION, vbaParserCONST, vbaParserDATABASE, vbaParserDATE, vbaParserDECLARE, vbaParserDEFBOOL, vbaParserDEFBYTE, vbaParserDEFDATE, vbaParserDEFDBL, vbaParserDEFDEC, vbaParserDEFCUR, vbaParserDEFINT, vbaParserDEFLNG, vbaParserDEFOBJ, vbaParserDEFSNG, vbaParserDEFSTR, vbaParserDEFVAR, vbaParserDELETESETTING, vbaParserDIM, vbaParserDO, vbaParserDOUBLE, vbaParserEACH, vbaParserELSE, vbaParserELSEIF, vbaParserEND, vbaParserENUM, vbaParserEQV, vbaParserERASE, vbaParserERROR, vbaParserEVENT, vbaParserFALSE, vbaParserFILECOPY, vbaParserFRIEND, vbaParserFOR, vbaParserFUNCTION, vbaParserGET, vbaParserGLOBAL, vbaParserGOSUB, vbaParserGOTO, vbaParserIF, vbaParserIMP, vbaParserIMPLEMENTS, vbaParserIN, vbaParserINPUT, vbaParserIS, vbaParserINTEGER, vbaParserKILL, vbaParserLOAD, vbaParserLOCK, vbaParserLONG, vbaParserLOOP, vbaParserLEN, vbaParserLET, vbaParserLIB, vbaParserLIKE, vbaParserLSET, vbaParserME, vbaParserMID, vbaParserMKDIR, vbaParserMOD, vbaParserNAME, vbaParserNEXT, vbaParserNEW, vbaParserNOT, vbaParserNOTHING, vbaParserNULL_, vbaParserON, vbaParserOPEN, vbaParserOPTIONAL, vbaParserOR, vbaParserOUTPUT, vbaParserPARAMARRAY, vbaParserPRESERVE, vbaParserPRINT, vbaParserPRIVATE, vbaParserPUBLIC, vbaParserPUT, vbaParserRANDOM, vbaParserRANDOMIZE, vbaParserRAISEEVENT, vbaParserREAD, vbaParserREDIM, vbaParserREM, vbaParserRESET, vbaParserRESUME, vbaParserRETURN, vbaParserRMDIR, vbaParserRSET, vbaParserSAVEPICTURE, vbaParserSAVESETTING, vbaParserSEEK, vbaParserSELECT, vbaParserSENDKEYS, vbaParserSET, vbaParserSETATTR, vbaParserSHARED, vbaParserSINGLE, vbaParserSPC, vbaParserSTATIC, vbaParserSTEP, vbaParserSTOP, vbaParserSTRING, vbaParserSUB, vbaParserTAB, vbaParserTEXT, vbaParserTHEN, vbaParserTIME, vbaParserTO, vbaParserTRUE, vbaParserTYPE, vbaParserTYPEOF, vbaParserUNLOAD, vbaParserUNLOCK, vbaParserUNTIL, vbaParserVARIANT, vbaParserVERSION, vbaParserWEND, vbaParserWHILE, vbaParserWIDTH, vbaParserWITH, vbaParserWITHEVENTS, vbaParserWRITE, vbaParserXOR:
					{
						p.SetState(2550)
						p.AmbiguousKeyword()
					}

				case vbaParserIDENTIFIER:
					{
						p.SetState(2551)
						p.Match(vbaParserIDENTIFIER)
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

			}
			p.SetState(2556)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 430, p.GetParserRuleContext())
		}

	case vbaParserACCESS, vbaParserADDRESSOF, vbaParserALIAS, vbaParserAND, vbaParserATTRIBUTE, vbaParserAPPACTIVATE, vbaParserAPPEND, vbaParserAS, vbaParserBEGIN, vbaParserBEEP, vbaParserBINARY, vbaParserBOOLEAN, vbaParserBYVAL, vbaParserBYREF, vbaParserBYTE, vbaParserCALL, vbaParserCASE, vbaParserCHDIR, vbaParserCHDRIVE, vbaParserCLASS, vbaParserCLOSE, vbaParserCOLLECTION, vbaParserCONST, vbaParserDATABASE, vbaParserDATE, vbaParserDECLARE, vbaParserDEFBOOL, vbaParserDEFBYTE, vbaParserDEFDATE, vbaParserDEFDBL, vbaParserDEFDEC, vbaParserDEFCUR, vbaParserDEFINT, vbaParserDEFLNG, vbaParserDEFOBJ, vbaParserDEFSNG, vbaParserDEFSTR, vbaParserDEFVAR, vbaParserDELETESETTING, vbaParserDIM, vbaParserDO, vbaParserDOUBLE, vbaParserEACH, vbaParserELSE, vbaParserELSEIF, vbaParserEND, vbaParserENUM, vbaParserEQV, vbaParserERASE, vbaParserERROR, vbaParserEVENT, vbaParserFALSE, vbaParserFILECOPY, vbaParserFRIEND, vbaParserFOR, vbaParserFUNCTION, vbaParserGET, vbaParserGLOBAL, vbaParserGOSUB, vbaParserGOTO, vbaParserIF, vbaParserIMP, vbaParserIMPLEMENTS, vbaParserIN, vbaParserINPUT, vbaParserIS, vbaParserINTEGER, vbaParserKILL, vbaParserLOAD, vbaParserLOCK, vbaParserLONG, vbaParserLOOP, vbaParserLEN, vbaParserLET, vbaParserLIB, vbaParserLIKE, vbaParserLSET, vbaParserME, vbaParserMID, vbaParserMKDIR, vbaParserMOD, vbaParserNAME, vbaParserNEXT, vbaParserNEW, vbaParserNOT, vbaParserNOTHING, vbaParserNULL_, vbaParserON, vbaParserOPEN, vbaParserOPTIONAL, vbaParserOR, vbaParserOUTPUT, vbaParserPARAMARRAY, vbaParserPRESERVE, vbaParserPRINT, vbaParserPRIVATE, vbaParserPUBLIC, vbaParserPUT, vbaParserRANDOM, vbaParserRANDOMIZE, vbaParserRAISEEVENT, vbaParserREAD, vbaParserREDIM, vbaParserREM, vbaParserRESET, vbaParserRESUME, vbaParserRETURN, vbaParserRMDIR, vbaParserRSET, vbaParserSAVEPICTURE, vbaParserSAVESETTING, vbaParserSEEK, vbaParserSELECT, vbaParserSENDKEYS, vbaParserSET, vbaParserSETATTR, vbaParserSHARED, vbaParserSINGLE, vbaParserSPC, vbaParserSTATIC, vbaParserSTEP, vbaParserSTOP, vbaParserSTRING, vbaParserSUB, vbaParserTAB, vbaParserTEXT, vbaParserTHEN, vbaParserTIME, vbaParserTO, vbaParserTRUE, vbaParserTYPE, vbaParserTYPEOF, vbaParserUNLOAD, vbaParserUNLOCK, vbaParserUNTIL, vbaParserVARIANT, vbaParserVERSION, vbaParserWEND, vbaParserWHILE, vbaParserWIDTH, vbaParserWITH, vbaParserWITHEVENTS, vbaParserWRITE, vbaParserXOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2557)
			p.AmbiguousKeyword()
		}
		p.SetState(2560)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(2560)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case vbaParserACCESS, vbaParserADDRESSOF, vbaParserALIAS, vbaParserAND, vbaParserATTRIBUTE, vbaParserAPPACTIVATE, vbaParserAPPEND, vbaParserAS, vbaParserBEGIN, vbaParserBEEP, vbaParserBINARY, vbaParserBOOLEAN, vbaParserBYVAL, vbaParserBYREF, vbaParserBYTE, vbaParserCALL, vbaParserCASE, vbaParserCHDIR, vbaParserCHDRIVE, vbaParserCLASS, vbaParserCLOSE, vbaParserCOLLECTION, vbaParserCONST, vbaParserDATABASE, vbaParserDATE, vbaParserDECLARE, vbaParserDEFBOOL, vbaParserDEFBYTE, vbaParserDEFDATE, vbaParserDEFDBL, vbaParserDEFDEC, vbaParserDEFCUR, vbaParserDEFINT, vbaParserDEFLNG, vbaParserDEFOBJ, vbaParserDEFSNG, vbaParserDEFSTR, vbaParserDEFVAR, vbaParserDELETESETTING, vbaParserDIM, vbaParserDO, vbaParserDOUBLE, vbaParserEACH, vbaParserELSE, vbaParserELSEIF, vbaParserEND, vbaParserENUM, vbaParserEQV, vbaParserERASE, vbaParserERROR, vbaParserEVENT, vbaParserFALSE, vbaParserFILECOPY, vbaParserFRIEND, vbaParserFOR, vbaParserFUNCTION, vbaParserGET, vbaParserGLOBAL, vbaParserGOSUB, vbaParserGOTO, vbaParserIF, vbaParserIMP, vbaParserIMPLEMENTS, vbaParserIN, vbaParserINPUT, vbaParserIS, vbaParserINTEGER, vbaParserKILL, vbaParserLOAD, vbaParserLOCK, vbaParserLONG, vbaParserLOOP, vbaParserLEN, vbaParserLET, vbaParserLIB, vbaParserLIKE, vbaParserLSET, vbaParserME, vbaParserMID, vbaParserMKDIR, vbaParserMOD, vbaParserNAME, vbaParserNEXT, vbaParserNEW, vbaParserNOT, vbaParserNOTHING, vbaParserNULL_, vbaParserON, vbaParserOPEN, vbaParserOPTIONAL, vbaParserOR, vbaParserOUTPUT, vbaParserPARAMARRAY, vbaParserPRESERVE, vbaParserPRINT, vbaParserPRIVATE, vbaParserPUBLIC, vbaParserPUT, vbaParserRANDOM, vbaParserRANDOMIZE, vbaParserRAISEEVENT, vbaParserREAD, vbaParserREDIM, vbaParserREM, vbaParserRESET, vbaParserRESUME, vbaParserRETURN, vbaParserRMDIR, vbaParserRSET, vbaParserSAVEPICTURE, vbaParserSAVESETTING, vbaParserSEEK, vbaParserSELECT, vbaParserSENDKEYS, vbaParserSET, vbaParserSETATTR, vbaParserSHARED, vbaParserSINGLE, vbaParserSPC, vbaParserSTATIC, vbaParserSTEP, vbaParserSTOP, vbaParserSTRING, vbaParserSUB, vbaParserTAB, vbaParserTEXT, vbaParserTHEN, vbaParserTIME, vbaParserTO, vbaParserTRUE, vbaParserTYPE, vbaParserTYPEOF, vbaParserUNLOAD, vbaParserUNLOCK, vbaParserUNTIL, vbaParserVARIANT, vbaParserVERSION, vbaParserWEND, vbaParserWHILE, vbaParserWIDTH, vbaParserWITH, vbaParserWITHEVENTS, vbaParserWRITE, vbaParserXOR:
					{
						p.SetState(2558)
						p.AmbiguousKeyword()
					}

				case vbaParserIDENTIFIER:
					{
						p.SetState(2559)
						p.Match(vbaParserIDENTIFIER)
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(2562)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 432, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(vbaParserLT, 0)
}

func (s *ComparisonOperatorContext) LEQ() antlr.TerminalNode {
	return s.GetToken(vbaParserLEQ, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(vbaParserGT, 0)
}

func (s *ComparisonOperatorContext) GEQ() antlr.TerminalNode {
	return s.GetToken(vbaParserGEQ, 0)
}

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(vbaParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(vbaParserNEQ, 0)
}

func (s *ComparisonOperatorContext) IS() antlr.TerminalNode {
	return s.GetToken(vbaParserIS, 0)
}

func (s *ComparisonOperatorContext) LIKE() antlr.TerminalNode {
	return s.GetToken(vbaParserLIKE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *vbaParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	this := p
	_ = this

	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, vbaParserRULE_comparisonOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2566)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vbaParserIS || _la == vbaParserLIKE || (((_la-189)&-(0x1f+1)) == 0 && ((1<<uint((_la-189)))&((1<<(vbaParserEQ-189))|(1<<(vbaParserGEQ-189))|(1<<(vbaParserGT-189))|(1<<(vbaParserLEQ-189))|(1<<(vbaParserLT-189))|(1<<(vbaParserNEQ-189)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IComplexTypeContext is an interface to support dynamic dispatch.
type IComplexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComplexTypeContext differentiates from other interfaces.
	IsComplexTypeContext()
}

type ComplexTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplexTypeContext() *ComplexTypeContext {
	var p = new(ComplexTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_complexType
	return p
}

func (*ComplexTypeContext) IsComplexTypeContext() {}

func NewComplexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComplexTypeContext {
	var p = new(ComplexTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_complexType

	return p
}

func (s *ComplexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ComplexTypeContext) AllAmbiguousIdentifier() []IAmbiguousIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem())
	var tst = make([]IAmbiguousIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAmbiguousIdentifierContext)
		}
	}

	return tst
}

func (s *ComplexTypeContext) AmbiguousIdentifier(i int) IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *ComplexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComplexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterComplexType(s)
	}
}

func (s *ComplexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitComplexType(s)
	}
}

func (p *vbaParser) ComplexType() (localctx IComplexTypeContext) {
	this := p
	_ = this

	localctx = NewComplexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, vbaParserRULE_complexType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2568)
		p.AmbiguousIdentifier()
	}
	p.SetState(2573)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 434, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2569)
				_la = p.GetTokenStream().LA(1)

				if !(_la == vbaParserT__3 || _la == vbaParserT__4) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2570)
				p.AmbiguousIdentifier()
			}

		}
		p.SetState(2575)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 434, p.GetParserRuleContext())
	}

	return localctx
}

// IFieldLengthContext is an interface to support dynamic dispatch.
type IFieldLengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldLengthContext differentiates from other interfaces.
	IsFieldLengthContext()
}

type FieldLengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldLengthContext() *FieldLengthContext {
	var p = new(FieldLengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_fieldLength
	return p
}

func (*FieldLengthContext) IsFieldLengthContext() {}

func NewFieldLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldLengthContext {
	var p = new(FieldLengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_fieldLength

	return p
}

func (s *FieldLengthContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldLengthContext) MULT() antlr.TerminalNode {
	return s.GetToken(vbaParserMULT, 0)
}

func (s *FieldLengthContext) INTEGERLITERAL() antlr.TerminalNode {
	return s.GetToken(vbaParserINTEGERLITERAL, 0)
}

func (s *FieldLengthContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *FieldLengthContext) WS() antlr.TerminalNode {
	return s.GetToken(vbaParserWS, 0)
}

func (s *FieldLengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldLengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldLengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterFieldLength(s)
	}
}

func (s *FieldLengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitFieldLength(s)
	}
}

func (p *vbaParser) FieldLength() (localctx IFieldLengthContext) {
	this := p
	_ = this

	localctx = NewFieldLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, vbaParserRULE_fieldLength)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2576)
		p.Match(vbaParserMULT)
	}
	p.SetState(2578)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(2577)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(2582)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vbaParserINTEGERLITERAL:
		{
			p.SetState(2580)
			p.Match(vbaParserINTEGERLITERAL)
		}

	case vbaParserACCESS, vbaParserADDRESSOF, vbaParserALIAS, vbaParserAND, vbaParserATTRIBUTE, vbaParserAPPACTIVATE, vbaParserAPPEND, vbaParserAS, vbaParserBEGIN, vbaParserBEEP, vbaParserBINARY, vbaParserBOOLEAN, vbaParserBYVAL, vbaParserBYREF, vbaParserBYTE, vbaParserCALL, vbaParserCASE, vbaParserCHDIR, vbaParserCHDRIVE, vbaParserCLASS, vbaParserCLOSE, vbaParserCOLLECTION, vbaParserCONST, vbaParserDATABASE, vbaParserDATE, vbaParserDECLARE, vbaParserDEFBOOL, vbaParserDEFBYTE, vbaParserDEFDATE, vbaParserDEFDBL, vbaParserDEFDEC, vbaParserDEFCUR, vbaParserDEFINT, vbaParserDEFLNG, vbaParserDEFOBJ, vbaParserDEFSNG, vbaParserDEFSTR, vbaParserDEFVAR, vbaParserDELETESETTING, vbaParserDIM, vbaParserDO, vbaParserDOUBLE, vbaParserEACH, vbaParserELSE, vbaParserELSEIF, vbaParserEND, vbaParserENUM, vbaParserEQV, vbaParserERASE, vbaParserERROR, vbaParserEVENT, vbaParserFALSE, vbaParserFILECOPY, vbaParserFRIEND, vbaParserFOR, vbaParserFUNCTION, vbaParserGET, vbaParserGLOBAL, vbaParserGOSUB, vbaParserGOTO, vbaParserIF, vbaParserIMP, vbaParserIMPLEMENTS, vbaParserIN, vbaParserINPUT, vbaParserIS, vbaParserINTEGER, vbaParserKILL, vbaParserLOAD, vbaParserLOCK, vbaParserLONG, vbaParserLOOP, vbaParserLEN, vbaParserLET, vbaParserLIB, vbaParserLIKE, vbaParserLSET, vbaParserME, vbaParserMID, vbaParserMKDIR, vbaParserMOD, vbaParserNAME, vbaParserNEXT, vbaParserNEW, vbaParserNOT, vbaParserNOTHING, vbaParserNULL_, vbaParserON, vbaParserOPEN, vbaParserOPTIONAL, vbaParserOR, vbaParserOUTPUT, vbaParserPARAMARRAY, vbaParserPRESERVE, vbaParserPRINT, vbaParserPRIVATE, vbaParserPUBLIC, vbaParserPUT, vbaParserRANDOM, vbaParserRANDOMIZE, vbaParserRAISEEVENT, vbaParserREAD, vbaParserREDIM, vbaParserREM, vbaParserRESET, vbaParserRESUME, vbaParserRETURN, vbaParserRMDIR, vbaParserRSET, vbaParserSAVEPICTURE, vbaParserSAVESETTING, vbaParserSEEK, vbaParserSELECT, vbaParserSENDKEYS, vbaParserSET, vbaParserSETATTR, vbaParserSHARED, vbaParserSINGLE, vbaParserSPC, vbaParserSTATIC, vbaParserSTEP, vbaParserSTOP, vbaParserSTRING, vbaParserSUB, vbaParserTAB, vbaParserTEXT, vbaParserTHEN, vbaParserTIME, vbaParserTO, vbaParserTRUE, vbaParserTYPE, vbaParserTYPEOF, vbaParserUNLOAD, vbaParserUNLOCK, vbaParserUNTIL, vbaParserVARIANT, vbaParserVERSION, vbaParserWEND, vbaParserWHILE, vbaParserWIDTH, vbaParserWITH, vbaParserWITHEVENTS, vbaParserWRITE, vbaParserXOR, vbaParserIDENTIFIER:
		{
			p.SetState(2581)
			p.AmbiguousIdentifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILetterrangeContext is an interface to support dynamic dispatch.
type ILetterrangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLetterrangeContext differentiates from other interfaces.
	IsLetterrangeContext()
}

type LetterrangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetterrangeContext() *LetterrangeContext {
	var p = new(LetterrangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_letterrange
	return p
}

func (*LetterrangeContext) IsLetterrangeContext() {}

func NewLetterrangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetterrangeContext {
	var p = new(LetterrangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_letterrange

	return p
}

func (s *LetterrangeContext) GetParser() antlr.Parser { return s.parser }

func (s *LetterrangeContext) AllCertainIdentifier() []ICertainIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICertainIdentifierContext)(nil)).Elem())
	var tst = make([]ICertainIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICertainIdentifierContext)
		}
	}

	return tst
}

func (s *LetterrangeContext) CertainIdentifier(i int) ICertainIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICertainIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICertainIdentifierContext)
}

func (s *LetterrangeContext) MINUS() antlr.TerminalNode {
	return s.GetToken(vbaParserMINUS, 0)
}

func (s *LetterrangeContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *LetterrangeContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *LetterrangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetterrangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetterrangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterLetterrange(s)
	}
}

func (s *LetterrangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitLetterrange(s)
	}
}

func (p *vbaParser) Letterrange() (localctx ILetterrangeContext) {
	this := p
	_ = this

	localctx = NewLetterrangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, vbaParserRULE_letterrange)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2584)
		p.CertainIdentifier()
	}
	p.SetState(2593)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 439, p.GetParserRuleContext()) == 1 {
		p.SetState(2586)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2585)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2588)
			p.Match(vbaParserMINUS)
		}
		p.SetState(2590)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2589)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2592)
			p.CertainIdentifier()
		}

	}

	return localctx
}

// ILineLabelContext is an interface to support dynamic dispatch.
type ILineLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineLabelContext differentiates from other interfaces.
	IsLineLabelContext()
}

type LineLabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineLabelContext() *LineLabelContext {
	var p = new(LineLabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_lineLabel
	return p
}

func (*LineLabelContext) IsLineLabelContext() {}

func NewLineLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineLabelContext {
	var p = new(LineLabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_lineLabel

	return p
}

func (s *LineLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LineLabelContext) AmbiguousIdentifier() IAmbiguousIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAmbiguousIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAmbiguousIdentifierContext)
}

func (s *LineLabelContext) COLON() antlr.TerminalNode {
	return s.GetToken(vbaParserCOLON, 0)
}

func (s *LineLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterLineLabel(s)
	}
}

func (s *LineLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitLineLabel(s)
	}
}

func (p *vbaParser) LineLabel() (localctx ILineLabelContext) {
	this := p
	_ = this

	localctx = NewLineLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, vbaParserRULE_lineLabel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2595)
		p.AmbiguousIdentifier()
	}
	{
		p.SetState(2596)
		p.Match(vbaParserCOLON)
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) HEXLITERAL() antlr.TerminalNode {
	return s.GetToken(vbaParserHEXLITERAL, 0)
}

func (s *LiteralContext) OCTLITERAL() antlr.TerminalNode {
	return s.GetToken(vbaParserOCTLITERAL, 0)
}

func (s *LiteralContext) DATELITERAL() antlr.TerminalNode {
	return s.GetToken(vbaParserDATELITERAL, 0)
}

func (s *LiteralContext) DOUBLELITERAL() antlr.TerminalNode {
	return s.GetToken(vbaParserDOUBLELITERAL, 0)
}

func (s *LiteralContext) INTEGERLITERAL() antlr.TerminalNode {
	return s.GetToken(vbaParserINTEGERLITERAL, 0)
}

func (s *LiteralContext) SHORTLITERAL() antlr.TerminalNode {
	return s.GetToken(vbaParserSHORTLITERAL, 0)
}

func (s *LiteralContext) STRINGLITERAL() antlr.TerminalNode {
	return s.GetToken(vbaParserSTRINGLITERAL, 0)
}

func (s *LiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(vbaParserTRUE, 0)
}

func (s *LiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(vbaParserFALSE, 0)
}

func (s *LiteralContext) NOTHING() antlr.TerminalNode {
	return s.GetToken(vbaParserNOTHING, 0)
}

func (s *LiteralContext) NULL_() antlr.TerminalNode {
	return s.GetToken(vbaParserNULL_, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *vbaParser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, vbaParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2598)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vbaParserFALSE || _la == vbaParserNOTHING || _la == vbaParserNULL_ || _la == vbaParserTRUE || (((_la-205)&-(0x1f+1)) == 0 && ((1<<uint((_la-205)))&((1<<(vbaParserSTRINGLITERAL-205))|(1<<(vbaParserOCTLITERAL-205))|(1<<(vbaParserHEXLITERAL-205))|(1<<(vbaParserSHORTLITERAL-205))|(1<<(vbaParserINTEGERLITERAL-205))|(1<<(vbaParserDOUBLELITERAL-205))|(1<<(vbaParserDATELITERAL-205)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_type_
	return p
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) BaseType() IBaseTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBaseTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *Type_Context) ComplexType() IComplexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComplexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComplexTypeContext)
}

func (s *Type_Context) LPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserLPAREN, 0)
}

func (s *Type_Context) RPAREN() antlr.TerminalNode {
	return s.GetToken(vbaParserRPAREN, 0)
}

func (s *Type_Context) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *Type_Context) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitType_(s)
	}
}

func (p *vbaParser) Type_() (localctx IType_Context) {
	this := p
	_ = this

	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, vbaParserRULE_type_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2602)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 440, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2600)
			p.BaseType()
		}

	case 2:
		{
			p.SetState(2601)
			p.ComplexType()
		}

	}
	p.SetState(2612)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 443, p.GetParserRuleContext()) == 1 {
		p.SetState(2605)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2604)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2607)
			p.Match(vbaParserLPAREN)
		}
		p.SetState(2609)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vbaParserWS {
			{
				p.SetState(2608)
				p.Match(vbaParserWS)
			}

		}
		{
			p.SetState(2611)
			p.Match(vbaParserRPAREN)
		}

	}

	return localctx
}

// ITypeHintContext is an interface to support dynamic dispatch.
type ITypeHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeHintContext differentiates from other interfaces.
	IsTypeHintContext()
}

type TypeHintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeHintContext() *TypeHintContext {
	var p = new(TypeHintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_typeHint
	return p
}

func (*TypeHintContext) IsTypeHintContext() {}

func NewTypeHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeHintContext {
	var p = new(TypeHintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_typeHint

	return p
}

func (s *TypeHintContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeHintContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(vbaParserAMPERSAND, 0)
}

func (s *TypeHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterTypeHint(s)
	}
}

func (s *TypeHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitTypeHint(s)
	}
}

func (p *vbaParser) TypeHint() (localctx ITypeHintContext) {
	this := p
	_ = this

	localctx = NewTypeHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, vbaParserRULE_typeHint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2614)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserT__2)|(1<<vbaParserT__4)|(1<<vbaParserT__5)|(1<<vbaParserT__6)|(1<<vbaParserT__7))) != 0) || _la == vbaParserAMPERSAND) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IVisibilityContext is an interface to support dynamic dispatch.
type IVisibilityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVisibilityContext differentiates from other interfaces.
	IsVisibilityContext()
}

type VisibilityContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVisibilityContext() *VisibilityContext {
	var p = new(VisibilityContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_visibility
	return p
}

func (*VisibilityContext) IsVisibilityContext() {}

func NewVisibilityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VisibilityContext {
	var p = new(VisibilityContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_visibility

	return p
}

func (s *VisibilityContext) GetParser() antlr.Parser { return s.parser }

func (s *VisibilityContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(vbaParserPRIVATE, 0)
}

func (s *VisibilityContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(vbaParserPUBLIC, 0)
}

func (s *VisibilityContext) FRIEND() antlr.TerminalNode {
	return s.GetToken(vbaParserFRIEND, 0)
}

func (s *VisibilityContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(vbaParserGLOBAL, 0)
}

func (s *VisibilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VisibilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterVisibility(s)
	}
}

func (s *VisibilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitVisibility(s)
	}
}

func (p *vbaParser) Visibility() (localctx IVisibilityContext) {
	this := p
	_ = this

	localctx = NewVisibilityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, vbaParserRULE_visibility)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2616)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vbaParserFRIEND || _la == vbaParserGLOBAL || _la == vbaParserPRIVATE || _la == vbaParserPUBLIC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAmbiguousKeywordContext is an interface to support dynamic dispatch.
type IAmbiguousKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAmbiguousKeywordContext differentiates from other interfaces.
	IsAmbiguousKeywordContext()
}

type AmbiguousKeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAmbiguousKeywordContext() *AmbiguousKeywordContext {
	var p = new(AmbiguousKeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_ambiguousKeyword
	return p
}

func (*AmbiguousKeywordContext) IsAmbiguousKeywordContext() {}

func NewAmbiguousKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AmbiguousKeywordContext {
	var p = new(AmbiguousKeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_ambiguousKeyword

	return p
}

func (s *AmbiguousKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *AmbiguousKeywordContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(vbaParserACCESS, 0)
}

func (s *AmbiguousKeywordContext) ADDRESSOF() antlr.TerminalNode {
	return s.GetToken(vbaParserADDRESSOF, 0)
}

func (s *AmbiguousKeywordContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(vbaParserALIAS, 0)
}

func (s *AmbiguousKeywordContext) AND() antlr.TerminalNode {
	return s.GetToken(vbaParserAND, 0)
}

func (s *AmbiguousKeywordContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(vbaParserATTRIBUTE, 0)
}

func (s *AmbiguousKeywordContext) APPACTIVATE() antlr.TerminalNode {
	return s.GetToken(vbaParserAPPACTIVATE, 0)
}

func (s *AmbiguousKeywordContext) APPEND() antlr.TerminalNode {
	return s.GetToken(vbaParserAPPEND, 0)
}

func (s *AmbiguousKeywordContext) AS() antlr.TerminalNode {
	return s.GetToken(vbaParserAS, 0)
}

func (s *AmbiguousKeywordContext) BEEP() antlr.TerminalNode {
	return s.GetToken(vbaParserBEEP, 0)
}

func (s *AmbiguousKeywordContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vbaParserBEGIN, 0)
}

func (s *AmbiguousKeywordContext) BINARY() antlr.TerminalNode {
	return s.GetToken(vbaParserBINARY, 0)
}

func (s *AmbiguousKeywordContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(vbaParserBOOLEAN, 0)
}

func (s *AmbiguousKeywordContext) BYVAL() antlr.TerminalNode {
	return s.GetToken(vbaParserBYVAL, 0)
}

func (s *AmbiguousKeywordContext) BYREF() antlr.TerminalNode {
	return s.GetToken(vbaParserBYREF, 0)
}

func (s *AmbiguousKeywordContext) BYTE() antlr.TerminalNode {
	return s.GetToken(vbaParserBYTE, 0)
}

func (s *AmbiguousKeywordContext) CALL() antlr.TerminalNode {
	return s.GetToken(vbaParserCALL, 0)
}

func (s *AmbiguousKeywordContext) CASE() antlr.TerminalNode {
	return s.GetToken(vbaParserCASE, 0)
}

func (s *AmbiguousKeywordContext) CLASS() antlr.TerminalNode {
	return s.GetToken(vbaParserCLASS, 0)
}

func (s *AmbiguousKeywordContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(vbaParserCLOSE, 0)
}

func (s *AmbiguousKeywordContext) CHDIR() antlr.TerminalNode {
	return s.GetToken(vbaParserCHDIR, 0)
}

func (s *AmbiguousKeywordContext) CHDRIVE() antlr.TerminalNode {
	return s.GetToken(vbaParserCHDRIVE, 0)
}

func (s *AmbiguousKeywordContext) COLLECTION() antlr.TerminalNode {
	return s.GetToken(vbaParserCOLLECTION, 0)
}

func (s *AmbiguousKeywordContext) CONST() antlr.TerminalNode {
	return s.GetToken(vbaParserCONST, 0)
}

func (s *AmbiguousKeywordContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(vbaParserDATABASE, 0)
}

func (s *AmbiguousKeywordContext) DATE() antlr.TerminalNode {
	return s.GetToken(vbaParserDATE, 0)
}

func (s *AmbiguousKeywordContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(vbaParserDECLARE, 0)
}

func (s *AmbiguousKeywordContext) DEFBOOL() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFBOOL, 0)
}

func (s *AmbiguousKeywordContext) DEFBYTE() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFBYTE, 0)
}

func (s *AmbiguousKeywordContext) DEFCUR() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFCUR, 0)
}

func (s *AmbiguousKeywordContext) DEFDBL() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFDBL, 0)
}

func (s *AmbiguousKeywordContext) DEFDATE() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFDATE, 0)
}

func (s *AmbiguousKeywordContext) DEFDEC() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFDEC, 0)
}

func (s *AmbiguousKeywordContext) DEFINT() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFINT, 0)
}

func (s *AmbiguousKeywordContext) DEFLNG() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFLNG, 0)
}

func (s *AmbiguousKeywordContext) DEFOBJ() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFOBJ, 0)
}

func (s *AmbiguousKeywordContext) DEFSNG() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFSNG, 0)
}

func (s *AmbiguousKeywordContext) DEFSTR() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFSTR, 0)
}

func (s *AmbiguousKeywordContext) DEFVAR() antlr.TerminalNode {
	return s.GetToken(vbaParserDEFVAR, 0)
}

func (s *AmbiguousKeywordContext) DELETESETTING() antlr.TerminalNode {
	return s.GetToken(vbaParserDELETESETTING, 0)
}

func (s *AmbiguousKeywordContext) DIM() antlr.TerminalNode {
	return s.GetToken(vbaParserDIM, 0)
}

func (s *AmbiguousKeywordContext) DO() antlr.TerminalNode {
	return s.GetToken(vbaParserDO, 0)
}

func (s *AmbiguousKeywordContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(vbaParserDOUBLE, 0)
}

func (s *AmbiguousKeywordContext) EACH() antlr.TerminalNode {
	return s.GetToken(vbaParserEACH, 0)
}

func (s *AmbiguousKeywordContext) ELSE() antlr.TerminalNode {
	return s.GetToken(vbaParserELSE, 0)
}

func (s *AmbiguousKeywordContext) ELSEIF() antlr.TerminalNode {
	return s.GetToken(vbaParserELSEIF, 0)
}

func (s *AmbiguousKeywordContext) END() antlr.TerminalNode {
	return s.GetToken(vbaParserEND, 0)
}

func (s *AmbiguousKeywordContext) ENUM() antlr.TerminalNode {
	return s.GetToken(vbaParserENUM, 0)
}

func (s *AmbiguousKeywordContext) EQV() antlr.TerminalNode {
	return s.GetToken(vbaParserEQV, 0)
}

func (s *AmbiguousKeywordContext) ERASE() antlr.TerminalNode {
	return s.GetToken(vbaParserERASE, 0)
}

func (s *AmbiguousKeywordContext) ERROR() antlr.TerminalNode {
	return s.GetToken(vbaParserERROR, 0)
}

func (s *AmbiguousKeywordContext) EVENT() antlr.TerminalNode {
	return s.GetToken(vbaParserEVENT, 0)
}

func (s *AmbiguousKeywordContext) FALSE() antlr.TerminalNode {
	return s.GetToken(vbaParserFALSE, 0)
}

func (s *AmbiguousKeywordContext) FILECOPY() antlr.TerminalNode {
	return s.GetToken(vbaParserFILECOPY, 0)
}

func (s *AmbiguousKeywordContext) FRIEND() antlr.TerminalNode {
	return s.GetToken(vbaParserFRIEND, 0)
}

func (s *AmbiguousKeywordContext) FOR() antlr.TerminalNode {
	return s.GetToken(vbaParserFOR, 0)
}

func (s *AmbiguousKeywordContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(vbaParserFUNCTION, 0)
}

func (s *AmbiguousKeywordContext) GET() antlr.TerminalNode {
	return s.GetToken(vbaParserGET, 0)
}

func (s *AmbiguousKeywordContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(vbaParserGLOBAL, 0)
}

func (s *AmbiguousKeywordContext) GOSUB() antlr.TerminalNode {
	return s.GetToken(vbaParserGOSUB, 0)
}

func (s *AmbiguousKeywordContext) GOTO() antlr.TerminalNode {
	return s.GetToken(vbaParserGOTO, 0)
}

func (s *AmbiguousKeywordContext) IF() antlr.TerminalNode {
	return s.GetToken(vbaParserIF, 0)
}

func (s *AmbiguousKeywordContext) IMP() antlr.TerminalNode {
	return s.GetToken(vbaParserIMP, 0)
}

func (s *AmbiguousKeywordContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(vbaParserIMPLEMENTS, 0)
}

func (s *AmbiguousKeywordContext) IN() antlr.TerminalNode {
	return s.GetToken(vbaParserIN, 0)
}

func (s *AmbiguousKeywordContext) INPUT() antlr.TerminalNode {
	return s.GetToken(vbaParserINPUT, 0)
}

func (s *AmbiguousKeywordContext) IS() antlr.TerminalNode {
	return s.GetToken(vbaParserIS, 0)
}

func (s *AmbiguousKeywordContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(vbaParserINTEGER, 0)
}

func (s *AmbiguousKeywordContext) KILL() antlr.TerminalNode {
	return s.GetToken(vbaParserKILL, 0)
}

func (s *AmbiguousKeywordContext) LOAD() antlr.TerminalNode {
	return s.GetToken(vbaParserLOAD, 0)
}

func (s *AmbiguousKeywordContext) LOCK() antlr.TerminalNode {
	return s.GetToken(vbaParserLOCK, 0)
}

func (s *AmbiguousKeywordContext) LONG() antlr.TerminalNode {
	return s.GetToken(vbaParserLONG, 0)
}

func (s *AmbiguousKeywordContext) LOOP() antlr.TerminalNode {
	return s.GetToken(vbaParserLOOP, 0)
}

func (s *AmbiguousKeywordContext) LEN() antlr.TerminalNode {
	return s.GetToken(vbaParserLEN, 0)
}

func (s *AmbiguousKeywordContext) LET() antlr.TerminalNode {
	return s.GetToken(vbaParserLET, 0)
}

func (s *AmbiguousKeywordContext) LIB() antlr.TerminalNode {
	return s.GetToken(vbaParserLIB, 0)
}

func (s *AmbiguousKeywordContext) LIKE() antlr.TerminalNode {
	return s.GetToken(vbaParserLIKE, 0)
}

func (s *AmbiguousKeywordContext) LSET() antlr.TerminalNode {
	return s.GetToken(vbaParserLSET, 0)
}

func (s *AmbiguousKeywordContext) ME() antlr.TerminalNode {
	return s.GetToken(vbaParserME, 0)
}

func (s *AmbiguousKeywordContext) MID() antlr.TerminalNode {
	return s.GetToken(vbaParserMID, 0)
}

func (s *AmbiguousKeywordContext) MKDIR() antlr.TerminalNode {
	return s.GetToken(vbaParserMKDIR, 0)
}

func (s *AmbiguousKeywordContext) MOD() antlr.TerminalNode {
	return s.GetToken(vbaParserMOD, 0)
}

func (s *AmbiguousKeywordContext) NAME() antlr.TerminalNode {
	return s.GetToken(vbaParserNAME, 0)
}

func (s *AmbiguousKeywordContext) NEXT() antlr.TerminalNode {
	return s.GetToken(vbaParserNEXT, 0)
}

func (s *AmbiguousKeywordContext) NEW() antlr.TerminalNode {
	return s.GetToken(vbaParserNEW, 0)
}

func (s *AmbiguousKeywordContext) NOT() antlr.TerminalNode {
	return s.GetToken(vbaParserNOT, 0)
}

func (s *AmbiguousKeywordContext) NOTHING() antlr.TerminalNode {
	return s.GetToken(vbaParserNOTHING, 0)
}

func (s *AmbiguousKeywordContext) NULL_() antlr.TerminalNode {
	return s.GetToken(vbaParserNULL_, 0)
}

func (s *AmbiguousKeywordContext) ON() antlr.TerminalNode {
	return s.GetToken(vbaParserON, 0)
}

func (s *AmbiguousKeywordContext) OPEN() antlr.TerminalNode {
	return s.GetToken(vbaParserOPEN, 0)
}

func (s *AmbiguousKeywordContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(vbaParserOPTIONAL, 0)
}

func (s *AmbiguousKeywordContext) OR() antlr.TerminalNode {
	return s.GetToken(vbaParserOR, 0)
}

func (s *AmbiguousKeywordContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(vbaParserOUTPUT, 0)
}

func (s *AmbiguousKeywordContext) PARAMARRAY() antlr.TerminalNode {
	return s.GetToken(vbaParserPARAMARRAY, 0)
}

func (s *AmbiguousKeywordContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(vbaParserPRESERVE, 0)
}

func (s *AmbiguousKeywordContext) PRINT() antlr.TerminalNode {
	return s.GetToken(vbaParserPRINT, 0)
}

func (s *AmbiguousKeywordContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(vbaParserPRIVATE, 0)
}

func (s *AmbiguousKeywordContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(vbaParserPUBLIC, 0)
}

func (s *AmbiguousKeywordContext) PUT() antlr.TerminalNode {
	return s.GetToken(vbaParserPUT, 0)
}

func (s *AmbiguousKeywordContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(vbaParserRANDOM, 0)
}

func (s *AmbiguousKeywordContext) RANDOMIZE() antlr.TerminalNode {
	return s.GetToken(vbaParserRANDOMIZE, 0)
}

func (s *AmbiguousKeywordContext) RAISEEVENT() antlr.TerminalNode {
	return s.GetToken(vbaParserRAISEEVENT, 0)
}

func (s *AmbiguousKeywordContext) READ() antlr.TerminalNode {
	return s.GetToken(vbaParserREAD, 0)
}

func (s *AmbiguousKeywordContext) REDIM() antlr.TerminalNode {
	return s.GetToken(vbaParserREDIM, 0)
}

func (s *AmbiguousKeywordContext) REM() antlr.TerminalNode {
	return s.GetToken(vbaParserREM, 0)
}

func (s *AmbiguousKeywordContext) RESET() antlr.TerminalNode {
	return s.GetToken(vbaParserRESET, 0)
}

func (s *AmbiguousKeywordContext) RESUME() antlr.TerminalNode {
	return s.GetToken(vbaParserRESUME, 0)
}

func (s *AmbiguousKeywordContext) RETURN() antlr.TerminalNode {
	return s.GetToken(vbaParserRETURN, 0)
}

func (s *AmbiguousKeywordContext) RMDIR() antlr.TerminalNode {
	return s.GetToken(vbaParserRMDIR, 0)
}

func (s *AmbiguousKeywordContext) RSET() antlr.TerminalNode {
	return s.GetToken(vbaParserRSET, 0)
}

func (s *AmbiguousKeywordContext) SAVEPICTURE() antlr.TerminalNode {
	return s.GetToken(vbaParserSAVEPICTURE, 0)
}

func (s *AmbiguousKeywordContext) SAVESETTING() antlr.TerminalNode {
	return s.GetToken(vbaParserSAVESETTING, 0)
}

func (s *AmbiguousKeywordContext) SEEK() antlr.TerminalNode {
	return s.GetToken(vbaParserSEEK, 0)
}

func (s *AmbiguousKeywordContext) SELECT() antlr.TerminalNode {
	return s.GetToken(vbaParserSELECT, 0)
}

func (s *AmbiguousKeywordContext) SENDKEYS() antlr.TerminalNode {
	return s.GetToken(vbaParserSENDKEYS, 0)
}

func (s *AmbiguousKeywordContext) SET() antlr.TerminalNode {
	return s.GetToken(vbaParserSET, 0)
}

func (s *AmbiguousKeywordContext) SETATTR() antlr.TerminalNode {
	return s.GetToken(vbaParserSETATTR, 0)
}

func (s *AmbiguousKeywordContext) SHARED() antlr.TerminalNode {
	return s.GetToken(vbaParserSHARED, 0)
}

func (s *AmbiguousKeywordContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(vbaParserSINGLE, 0)
}

func (s *AmbiguousKeywordContext) SPC() antlr.TerminalNode {
	return s.GetToken(vbaParserSPC, 0)
}

func (s *AmbiguousKeywordContext) STATIC() antlr.TerminalNode {
	return s.GetToken(vbaParserSTATIC, 0)
}

func (s *AmbiguousKeywordContext) STEP() antlr.TerminalNode {
	return s.GetToken(vbaParserSTEP, 0)
}

func (s *AmbiguousKeywordContext) STOP() antlr.TerminalNode {
	return s.GetToken(vbaParserSTOP, 0)
}

func (s *AmbiguousKeywordContext) STRING() antlr.TerminalNode {
	return s.GetToken(vbaParserSTRING, 0)
}

func (s *AmbiguousKeywordContext) SUB() antlr.TerminalNode {
	return s.GetToken(vbaParserSUB, 0)
}

func (s *AmbiguousKeywordContext) TAB() antlr.TerminalNode {
	return s.GetToken(vbaParserTAB, 0)
}

func (s *AmbiguousKeywordContext) TEXT() antlr.TerminalNode {
	return s.GetToken(vbaParserTEXT, 0)
}

func (s *AmbiguousKeywordContext) THEN() antlr.TerminalNode {
	return s.GetToken(vbaParserTHEN, 0)
}

func (s *AmbiguousKeywordContext) TIME() antlr.TerminalNode {
	return s.GetToken(vbaParserTIME, 0)
}

func (s *AmbiguousKeywordContext) TO() antlr.TerminalNode {
	return s.GetToken(vbaParserTO, 0)
}

func (s *AmbiguousKeywordContext) TRUE() antlr.TerminalNode {
	return s.GetToken(vbaParserTRUE, 0)
}

func (s *AmbiguousKeywordContext) TYPE() antlr.TerminalNode {
	return s.GetToken(vbaParserTYPE, 0)
}

func (s *AmbiguousKeywordContext) TYPEOF() antlr.TerminalNode {
	return s.GetToken(vbaParserTYPEOF, 0)
}

func (s *AmbiguousKeywordContext) UNLOAD() antlr.TerminalNode {
	return s.GetToken(vbaParserUNLOAD, 0)
}

func (s *AmbiguousKeywordContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(vbaParserUNLOCK, 0)
}

func (s *AmbiguousKeywordContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(vbaParserUNTIL, 0)
}

func (s *AmbiguousKeywordContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(vbaParserVARIANT, 0)
}

func (s *AmbiguousKeywordContext) VERSION() antlr.TerminalNode {
	return s.GetToken(vbaParserVERSION, 0)
}

func (s *AmbiguousKeywordContext) WEND() antlr.TerminalNode {
	return s.GetToken(vbaParserWEND, 0)
}

func (s *AmbiguousKeywordContext) WHILE() antlr.TerminalNode {
	return s.GetToken(vbaParserWHILE, 0)
}

func (s *AmbiguousKeywordContext) WIDTH() antlr.TerminalNode {
	return s.GetToken(vbaParserWIDTH, 0)
}

func (s *AmbiguousKeywordContext) WITH() antlr.TerminalNode {
	return s.GetToken(vbaParserWITH, 0)
}

func (s *AmbiguousKeywordContext) WITHEVENTS() antlr.TerminalNode {
	return s.GetToken(vbaParserWITHEVENTS, 0)
}

func (s *AmbiguousKeywordContext) WRITE() antlr.TerminalNode {
	return s.GetToken(vbaParserWRITE, 0)
}

func (s *AmbiguousKeywordContext) XOR() antlr.TerminalNode {
	return s.GetToken(vbaParserXOR, 0)
}

func (s *AmbiguousKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AmbiguousKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AmbiguousKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterAmbiguousKeyword(s)
	}
}

func (s *AmbiguousKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitAmbiguousKeyword(s)
	}
}

func (p *vbaParser) AmbiguousKeyword() (localctx IAmbiguousKeywordContext) {
	this := p
	_ = this

	localctx = NewAmbiguousKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, vbaParserRULE_ambiguousKeyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2618)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vbaParserACCESS)|(1<<vbaParserADDRESSOF)|(1<<vbaParserALIAS)|(1<<vbaParserAND)|(1<<vbaParserATTRIBUTE)|(1<<vbaParserAPPACTIVATE)|(1<<vbaParserAPPEND)|(1<<vbaParserAS)|(1<<vbaParserBEGIN)|(1<<vbaParserBEEP)|(1<<vbaParserBINARY)|(1<<vbaParserBOOLEAN)|(1<<vbaParserBYVAL)|(1<<vbaParserBYREF)|(1<<vbaParserBYTE)|(1<<vbaParserCALL)|(1<<vbaParserCASE)|(1<<vbaParserCHDIR)|(1<<vbaParserCHDRIVE)|(1<<vbaParserCLASS)|(1<<vbaParserCLOSE)|(1<<vbaParserCOLLECTION)|(1<<vbaParserCONST))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(vbaParserDATABASE-32))|(1<<(vbaParserDATE-32))|(1<<(vbaParserDECLARE-32))|(1<<(vbaParserDEFBOOL-32))|(1<<(vbaParserDEFBYTE-32))|(1<<(vbaParserDEFDATE-32))|(1<<(vbaParserDEFDBL-32))|(1<<(vbaParserDEFDEC-32))|(1<<(vbaParserDEFCUR-32))|(1<<(vbaParserDEFINT-32))|(1<<(vbaParserDEFLNG-32))|(1<<(vbaParserDEFOBJ-32))|(1<<(vbaParserDEFSNG-32))|(1<<(vbaParserDEFSTR-32))|(1<<(vbaParserDEFVAR-32))|(1<<(vbaParserDELETESETTING-32))|(1<<(vbaParserDIM-32))|(1<<(vbaParserDO-32))|(1<<(vbaParserDOUBLE-32))|(1<<(vbaParserEACH-32))|(1<<(vbaParserELSE-32))|(1<<(vbaParserELSEIF-32))|(1<<(vbaParserEND-32))|(1<<(vbaParserENUM-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(vbaParserEQV-64))|(1<<(vbaParserERASE-64))|(1<<(vbaParserERROR-64))|(1<<(vbaParserEVENT-64))|(1<<(vbaParserFALSE-64))|(1<<(vbaParserFILECOPY-64))|(1<<(vbaParserFRIEND-64))|(1<<(vbaParserFOR-64))|(1<<(vbaParserFUNCTION-64))|(1<<(vbaParserGET-64))|(1<<(vbaParserGLOBAL-64))|(1<<(vbaParserGOSUB-64))|(1<<(vbaParserGOTO-64))|(1<<(vbaParserIF-64))|(1<<(vbaParserIMP-64))|(1<<(vbaParserIMPLEMENTS-64))|(1<<(vbaParserIN-64))|(1<<(vbaParserINPUT-64))|(1<<(vbaParserIS-64))|(1<<(vbaParserINTEGER-64))|(1<<(vbaParserKILL-64))|(1<<(vbaParserLOAD-64))|(1<<(vbaParserLOCK-64))|(1<<(vbaParserLONG-64))|(1<<(vbaParserLOOP-64))|(1<<(vbaParserLEN-64))|(1<<(vbaParserLET-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(vbaParserLIB-96))|(1<<(vbaParserLIKE-96))|(1<<(vbaParserLSET-96))|(1<<(vbaParserME-96))|(1<<(vbaParserMID-96))|(1<<(vbaParserMKDIR-96))|(1<<(vbaParserMOD-96))|(1<<(vbaParserNAME-96))|(1<<(vbaParserNEXT-96))|(1<<(vbaParserNEW-96))|(1<<(vbaParserNOT-96))|(1<<(vbaParserNOTHING-96))|(1<<(vbaParserNULL_-96))|(1<<(vbaParserON-96))|(1<<(vbaParserOPEN-96))|(1<<(vbaParserOPTIONAL-96))|(1<<(vbaParserOR-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(vbaParserOUTPUT-128))|(1<<(vbaParserPARAMARRAY-128))|(1<<(vbaParserPRESERVE-128))|(1<<(vbaParserPRINT-128))|(1<<(vbaParserPRIVATE-128))|(1<<(vbaParserPUBLIC-128))|(1<<(vbaParserPUT-128))|(1<<(vbaParserRANDOM-128))|(1<<(vbaParserRANDOMIZE-128))|(1<<(vbaParserRAISEEVENT-128))|(1<<(vbaParserREAD-128))|(1<<(vbaParserREDIM-128))|(1<<(vbaParserREM-128))|(1<<(vbaParserRESET-128))|(1<<(vbaParserRESUME-128))|(1<<(vbaParserRETURN-128))|(1<<(vbaParserRMDIR-128))|(1<<(vbaParserRSET-128))|(1<<(vbaParserSAVEPICTURE-128))|(1<<(vbaParserSAVESETTING-128))|(1<<(vbaParserSEEK-128))|(1<<(vbaParserSELECT-128))|(1<<(vbaParserSENDKEYS-128))|(1<<(vbaParserSET-128))|(1<<(vbaParserSETATTR-128))|(1<<(vbaParserSHARED-128))|(1<<(vbaParserSINGLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(vbaParserSPC-160))|(1<<(vbaParserSTATIC-160))|(1<<(vbaParserSTEP-160))|(1<<(vbaParserSTOP-160))|(1<<(vbaParserSTRING-160))|(1<<(vbaParserSUB-160))|(1<<(vbaParserTAB-160))|(1<<(vbaParserTEXT-160))|(1<<(vbaParserTHEN-160))|(1<<(vbaParserTIME-160))|(1<<(vbaParserTO-160))|(1<<(vbaParserTRUE-160))|(1<<(vbaParserTYPE-160))|(1<<(vbaParserTYPEOF-160))|(1<<(vbaParserUNLOAD-160))|(1<<(vbaParserUNLOCK-160))|(1<<(vbaParserUNTIL-160))|(1<<(vbaParserVARIANT-160))|(1<<(vbaParserVERSION-160))|(1<<(vbaParserWEND-160))|(1<<(vbaParserWHILE-160))|(1<<(vbaParserWIDTH-160))|(1<<(vbaParserWITH-160))|(1<<(vbaParserWITHEVENTS-160))|(1<<(vbaParserWRITE-160))|(1<<(vbaParserXOR-160)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRemCommentContext is an interface to support dynamic dispatch.
type IRemCommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRemCommentContext differentiates from other interfaces.
	IsRemCommentContext()
}

type RemCommentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemCommentContext() *RemCommentContext {
	var p = new(RemCommentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_remComment
	return p
}

func (*RemCommentContext) IsRemCommentContext() {}

func NewRemCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemCommentContext {
	var p = new(RemCommentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_remComment

	return p
}

func (s *RemCommentContext) GetParser() antlr.Parser { return s.parser }

func (s *RemCommentContext) REMCOMMENT() antlr.TerminalNode {
	return s.GetToken(vbaParserREMCOMMENT, 0)
}

func (s *RemCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemCommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterRemComment(s)
	}
}

func (s *RemCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitRemComment(s)
	}
}

func (p *vbaParser) RemComment() (localctx IRemCommentContext) {
	this := p
	_ = this

	localctx = NewRemCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, vbaParserRULE_remComment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2620)
		p.Match(vbaParserREMCOMMENT)
	}

	return localctx
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_comment
	return p
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(vbaParserCOMMENT, 0)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterComment(s)
	}
}

func (s *CommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitComment(s)
	}
}

func (p *vbaParser) Comment() (localctx ICommentContext) {
	this := p
	_ = this

	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, vbaParserRULE_comment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2622)
		p.Match(vbaParserCOMMENT)
	}

	return localctx
}

// IEndOfLineContext is an interface to support dynamic dispatch.
type IEndOfLineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndOfLineContext differentiates from other interfaces.
	IsEndOfLineContext()
}

type EndOfLineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndOfLineContext() *EndOfLineContext {
	var p = new(EndOfLineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_endOfLine
	return p
}

func (*EndOfLineContext) IsEndOfLineContext() {}

func NewEndOfLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndOfLineContext {
	var p = new(EndOfLineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_endOfLine

	return p
}

func (s *EndOfLineContext) GetParser() antlr.Parser { return s.parser }

func (s *EndOfLineContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(vbaParserNEWLINE, 0)
}

func (s *EndOfLineContext) Comment() ICommentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *EndOfLineContext) RemComment() IRemCommentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRemCommentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRemCommentContext)
}

func (s *EndOfLineContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *EndOfLineContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *EndOfLineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndOfLineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndOfLineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterEndOfLine(s)
	}
}

func (s *EndOfLineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitEndOfLine(s)
	}
}

func (p *vbaParser) EndOfLine() (localctx IEndOfLineContext) {
	this := p
	_ = this

	localctx = NewEndOfLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, vbaParserRULE_endOfLine)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2625)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vbaParserWS {
		{
			p.SetState(2624)
			p.Match(vbaParserWS)
		}

	}
	p.SetState(2630)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vbaParserNEWLINE:
		{
			p.SetState(2627)
			p.Match(vbaParserNEWLINE)
		}

	case vbaParserCOMMENT:
		{
			p.SetState(2628)
			p.Comment()
		}

	case vbaParserREMCOMMENT:
		{
			p.SetState(2629)
			p.RemComment()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2633)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 446, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2632)
			p.Match(vbaParserWS)
		}

	}

	return localctx
}

// IEndOfStatementContext is an interface to support dynamic dispatch.
type IEndOfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndOfStatementContext differentiates from other interfaces.
	IsEndOfStatementContext()
}

type EndOfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndOfStatementContext() *EndOfStatementContext {
	var p = new(EndOfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vbaParserRULE_endOfStatement
	return p
}

func (*EndOfStatementContext) IsEndOfStatementContext() {}

func NewEndOfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndOfStatementContext {
	var p = new(EndOfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vbaParserRULE_endOfStatement

	return p
}

func (s *EndOfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EndOfStatementContext) AllEndOfLine() []IEndOfLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEndOfLineContext)(nil)).Elem())
	var tst = make([]IEndOfLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEndOfLineContext)
		}
	}

	return tst
}

func (s *EndOfStatementContext) EndOfLine(i int) IEndOfLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndOfLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEndOfLineContext)
}

func (s *EndOfStatementContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(vbaParserCOLON)
}

func (s *EndOfStatementContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserCOLON, i)
}

func (s *EndOfStatementContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(vbaParserWS)
}

func (s *EndOfStatementContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(vbaParserWS, i)
}

func (s *EndOfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndOfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndOfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.EnterEndOfStatement(s)
	}
}

func (s *EndOfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vbaListener); ok {
		listenerT.ExitEndOfStatement(s)
	}
}

func (p *vbaParser) EndOfStatement() (localctx IEndOfStatementContext) {
	this := p
	_ = this

	localctx = NewEndOfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, vbaParserRULE_endOfStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2645)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 450, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2643)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 449, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(2635)
					p.EndOfLine()
				}

			case 2:
				p.SetState(2637)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == vbaParserWS {
					{
						p.SetState(2636)
						p.Match(vbaParserWS)
					}

				}
				{
					p.SetState(2639)
					p.Match(vbaParserCOLON)
				}
				p.SetState(2641)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 448, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(2640)
						p.Match(vbaParserWS)
					}

				}

			}

		}
		p.SetState(2647)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 450, p.GetParserRuleContext())
	}

	return localctx
}

func (p *vbaParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 100:
		var t *ValueStmtContext = nil
		if localctx != nil {
			t = localctx.(*ValueStmtContext)
		}
		return p.ValueStmt_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *vbaParser) ValueStmt_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
