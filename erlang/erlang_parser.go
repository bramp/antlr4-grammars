// Code generated from Erlang.g4 by ANTLR 4.9.3. DO NOT EDIT.

package erlang // Erlang
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 75, 1205,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 3, 2, 6, 2, 248,
	10, 2, 13, 2, 14, 2, 249, 3, 2, 3, 2, 3, 3, 3, 3, 5, 3, 256, 10, 3, 3,
	3, 3, 3, 3, 4, 3, 4, 3, 5, 3, 5, 3, 6, 3, 6, 3, 7, 3, 7, 3, 8, 3, 8, 3,
	9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10,
	3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 288, 10, 10, 3,
	11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 298, 10, 11,
	3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 305, 10, 12, 3, 13, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 315, 10, 13, 3, 14, 3, 14,
	3, 14, 3, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3,
	15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 334, 10, 15, 3, 16, 3, 16, 3, 16,
	3, 16, 3, 17, 3, 17, 3, 17, 7, 17, 343, 10, 17, 12, 17, 14, 17, 346, 11,
	17, 3, 18, 3, 18, 3, 18, 5, 18, 351, 10, 18, 3, 19, 3, 19, 3, 19, 7, 19,
	356, 10, 19, 12, 19, 14, 19, 359, 11, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 370, 10, 20, 3, 21, 3, 21, 3, 21,
	7, 21, 375, 10, 21, 12, 21, 14, 21, 378, 11, 21, 3, 22, 3, 22, 3, 22, 5,
	22, 383, 10, 22, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 5, 23, 390, 10, 23,
	3, 24, 3, 24, 3, 24, 5, 24, 395, 10, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3,
	25, 3, 25, 3, 25, 7, 25, 404, 10, 25, 12, 25, 14, 25, 407, 11, 25, 3, 26,
	3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 7, 26, 416, 10, 26, 12, 26, 14,
	26, 419, 11, 26, 3, 27, 5, 27, 422, 10, 27, 3, 27, 3, 27, 3, 28, 3, 28,
	3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3,
	28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28,
	3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3,
	28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28,
	3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3,
	28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28,
	3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3,
	28, 5, 28, 502, 10, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29,
	510, 10, 29, 3, 30, 3, 30, 5, 30, 514, 10, 30, 3, 30, 3, 30, 3, 30, 3,
	30, 3, 31, 3, 31, 3, 31, 7, 31, 523, 10, 31, 12, 31, 14, 31, 526, 11, 31,
	3, 32, 3, 32, 3, 32, 3, 32, 3, 33, 3, 33, 3, 33, 7, 33, 535, 10, 33, 12,
	33, 14, 33, 538, 11, 33, 3, 34, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3,
	35, 3, 35, 3, 35, 5, 35, 560, 10, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 37,
	3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3,
	38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 5, 38,
	587, 10, 38, 3, 39, 3, 39, 3, 39, 7, 39, 592, 10, 39, 12, 39, 14, 39, 595,
	11, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 3, 42, 3, 42,
	5, 42, 606, 10, 42, 3, 43, 3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 5, 44, 614,
	10, 44, 3, 45, 3, 45, 3, 45, 7, 45, 619, 10, 45, 12, 45, 14, 45, 622, 11,
	45, 3, 46, 3, 46, 3, 46, 7, 46, 627, 10, 46, 12, 46, 14, 46, 630, 11, 46,
	3, 47, 3, 47, 3, 47, 7, 47, 635, 10, 47, 12, 47, 14, 47, 638, 11, 47, 3,
	48, 3, 48, 3, 48, 3, 48, 5, 48, 644, 10, 48, 3, 49, 3, 49, 3, 49, 3, 49,
	7, 49, 650, 10, 49, 12, 49, 14, 49, 653, 11, 49, 3, 50, 3, 50, 3, 50, 3,
	50, 7, 50, 659, 10, 50, 12, 50, 14, 50, 662, 11, 50, 3, 51, 3, 51, 3, 51,
	3, 51, 7, 51, 668, 10, 51, 12, 51, 14, 51, 671, 11, 51, 3, 52, 3, 52, 3,
	52, 3, 52, 5, 52, 677, 10, 52, 3, 53, 3, 53, 5, 53, 681, 10, 53, 3, 54,
	3, 54, 3, 54, 5, 54, 686, 10, 54, 3, 55, 3, 55, 3, 55, 5, 55, 691, 10,
	55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56,
	3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 5,
	56, 713, 10, 56, 3, 57, 3, 57, 3, 57, 5, 57, 718, 10, 57, 3, 58, 3, 58,
	3, 58, 3, 58, 5, 58, 724, 10, 58, 3, 59, 3, 59, 3, 59, 3, 59, 5, 59, 730,
	10, 59, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 7, 60, 739, 10,
	60, 12, 60, 14, 60, 742, 11, 60, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3,
	61, 3, 61, 7, 61, 751, 10, 61, 12, 61, 14, 61, 754, 11, 61, 3, 62, 3, 62,
	3, 62, 3, 62, 5, 62, 760, 10, 62, 3, 63, 3, 63, 5, 63, 764, 10, 63, 3,
	64, 3, 64, 5, 64, 768, 10, 64, 3, 65, 3, 65, 3, 66, 3, 66, 3, 66, 3, 66,
	3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 781, 10, 66, 3, 67, 3, 67, 5,
	67, 785, 10, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 7, 67, 793,
	10, 67, 12, 67, 14, 67, 796, 11, 67, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68,
	5, 68, 803, 10, 68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 811,
	10, 69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70,
	5, 70, 822, 10, 70, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 5, 71, 830,
	10, 71, 3, 72, 3, 72, 3, 72, 7, 72, 835, 10, 72, 12, 72, 14, 72, 838, 11,
	72, 3, 73, 3, 73, 3, 73, 3, 73, 3, 74, 5, 74, 845, 10, 74, 3, 74, 3, 74,
	3, 75, 3, 75, 5, 75, 851, 10, 75, 3, 76, 3, 76, 5, 76, 855, 10, 76, 3,
	77, 3, 77, 3, 77, 7, 77, 860, 10, 77, 12, 77, 14, 77, 863, 11, 77, 3, 78,
	3, 78, 3, 78, 5, 78, 868, 10, 78, 3, 79, 3, 79, 3, 80, 3, 80, 3, 80, 3,
	80, 3, 80, 3, 80, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 82, 3, 82,
	3, 82, 7, 82, 887, 10, 82, 12, 82, 14, 82, 890, 11, 82, 3, 83, 3, 83, 3,
	83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 5, 83, 901, 10, 83, 3, 84,
	3, 84, 5, 84, 905, 10, 84, 3, 84, 3, 84, 3, 85, 3, 85, 5, 85, 911, 10,
	85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 7, 85, 919, 10, 85, 12, 85,
	14, 85, 922, 11, 85, 3, 86, 3, 86, 3, 86, 3, 86, 7, 86, 928, 10, 86, 12,
	86, 14, 86, 931, 11, 86, 5, 86, 933, 10, 86, 3, 86, 3, 86, 3, 87, 3, 87,
	5, 87, 939, 10, 87, 3, 88, 3, 88, 3, 88, 3, 88, 3, 89, 3, 89, 3, 89, 3,
	89, 3, 90, 3, 90, 3, 91, 3, 91, 5, 91, 953, 10, 91, 3, 91, 3, 91, 3, 91,
	3, 91, 3, 91, 5, 91, 960, 10, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3,
	91, 5, 91, 968, 10, 91, 7, 91, 970, 10, 91, 12, 91, 14, 91, 973, 11, 91,
	3, 92, 3, 92, 5, 92, 977, 10, 92, 3, 92, 3, 92, 3, 93, 3, 93, 3, 93, 7,
	93, 984, 10, 93, 12, 93, 14, 93, 987, 11, 93, 3, 94, 3, 94, 5, 94, 991,
	10, 94, 3, 94, 3, 94, 3, 94, 3, 95, 3, 95, 3, 95, 3, 96, 3, 96, 3, 96,
	3, 96, 3, 97, 3, 97, 3, 97, 7, 97, 1006, 10, 97, 12, 97, 14, 97, 1009,
	11, 97, 3, 98, 3, 98, 3, 98, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99,
	3, 100, 3, 100, 3, 100, 7, 100, 1023, 10, 100, 12, 100, 14, 100, 1026,
	11, 100, 3, 101, 3, 101, 3, 101, 3, 101, 3, 102, 3, 102, 3, 102, 3, 102,
	3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102,
	3, 102, 3, 102, 3, 102, 3, 102, 5, 102, 1049, 10, 102, 3, 103, 3, 103,
	3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103,
	3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 5, 103, 1067, 10, 103, 3, 104,
	3, 104, 5, 104, 1071, 10, 104, 3, 105, 3, 105, 5, 105, 1075, 10, 105, 3,
	106, 3, 106, 3, 106, 7, 106, 1080, 10, 106, 12, 106, 14, 106, 1083, 11,
	106, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3,
	107, 5, 107, 1094, 10, 107, 3, 108, 3, 108, 3, 108, 3, 108, 5, 108, 1100,
	10, 108, 3, 108, 3, 108, 3, 109, 3, 109, 3, 109, 3, 109, 3, 109, 3, 109,
	3, 109, 3, 109, 3, 109, 3, 109, 3, 109, 3, 109, 3, 109, 3, 109, 5, 109,
	1118, 10, 109, 3, 110, 3, 110, 3, 110, 7, 110, 1123, 10, 110, 12, 110,
	14, 110, 1126, 11, 110, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111,
	3, 111, 5, 111, 1135, 10, 111, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111,
	5, 111, 1142, 10, 111, 3, 112, 3, 112, 5, 112, 1146, 10, 112, 3, 113, 3,
	113, 5, 113, 1150, 10, 113, 3, 113, 3, 113, 3, 114, 3, 114, 5, 114, 1156,
	10, 114, 3, 114, 3, 114, 3, 115, 3, 115, 3, 115, 7, 115, 1163, 10, 115,
	12, 115, 14, 115, 1166, 11, 115, 3, 116, 3, 116, 3, 116, 7, 116, 1171,
	10, 116, 12, 116, 14, 116, 1174, 11, 116, 3, 117, 3, 117, 3, 117, 7, 117,
	1179, 10, 117, 12, 117, 14, 117, 1182, 11, 117, 3, 118, 3, 118, 3, 118,
	3, 118, 3, 118, 6, 118, 1189, 10, 118, 13, 118, 14, 118, 1190, 5, 118,
	1193, 10, 118, 3, 119, 3, 119, 3, 120, 3, 120, 3, 121, 3, 121, 3, 122,
	3, 122, 3, 123, 3, 123, 3, 123, 2, 9, 48, 50, 118, 120, 132, 168, 180,
	124, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36,
	38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72,
	74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106,
	108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136,
	138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166,
	168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196,
	198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226,
	228, 230, 232, 234, 236, 238, 240, 242, 244, 2, 9, 3, 2, 22, 23, 3, 2,
	28, 29, 4, 2, 4, 4, 44, 46, 5, 2, 26, 26, 34, 34, 47, 50, 5, 2, 4, 4, 44,
	44, 51, 56, 3, 2, 57, 58, 3, 2, 59, 66, 2, 1231, 2, 247, 3, 2, 2, 2, 4,
	255, 3, 2, 2, 2, 6, 259, 3, 2, 2, 2, 8, 261, 3, 2, 2, 2, 10, 263, 3, 2,
	2, 2, 12, 265, 3, 2, 2, 2, 14, 267, 3, 2, 2, 2, 16, 269, 3, 2, 2, 2, 18,
	287, 3, 2, 2, 2, 20, 297, 3, 2, 2, 2, 22, 304, 3, 2, 2, 2, 24, 314, 3,
	2, 2, 2, 26, 316, 3, 2, 2, 2, 28, 333, 3, 2, 2, 2, 30, 335, 3, 2, 2, 2,
	32, 339, 3, 2, 2, 2, 34, 347, 3, 2, 2, 2, 36, 352, 3, 2, 2, 2, 38, 369,
	3, 2, 2, 2, 40, 371, 3, 2, 2, 2, 42, 382, 3, 2, 2, 2, 44, 386, 3, 2, 2,
	2, 46, 391, 3, 2, 2, 2, 48, 396, 3, 2, 2, 2, 50, 408, 3, 2, 2, 2, 52, 421,
	3, 2, 2, 2, 54, 501, 3, 2, 2, 2, 56, 509, 3, 2, 2, 2, 58, 511, 3, 2, 2,
	2, 60, 519, 3, 2, 2, 2, 62, 527, 3, 2, 2, 2, 64, 531, 3, 2, 2, 2, 66, 539,
	3, 2, 2, 2, 68, 559, 3, 2, 2, 2, 70, 561, 3, 2, 2, 2, 72, 565, 3, 2, 2,
	2, 74, 586, 3, 2, 2, 2, 76, 588, 3, 2, 2, 2, 78, 596, 3, 2, 2, 2, 80, 601,
	3, 2, 2, 2, 82, 605, 3, 2, 2, 2, 84, 607, 3, 2, 2, 2, 86, 613, 3, 2, 2,
	2, 88, 615, 3, 2, 2, 2, 90, 623, 3, 2, 2, 2, 92, 631, 3, 2, 2, 2, 94, 639,
	3, 2, 2, 2, 96, 645, 3, 2, 2, 2, 98, 654, 3, 2, 2, 2, 100, 663, 3, 2, 2,
	2, 102, 676, 3, 2, 2, 2, 104, 680, 3, 2, 2, 2, 106, 685, 3, 2, 2, 2, 108,
	687, 3, 2, 2, 2, 110, 712, 3, 2, 2, 2, 112, 714, 3, 2, 2, 2, 114, 719,
	3, 2, 2, 2, 116, 725, 3, 2, 2, 2, 118, 731, 3, 2, 2, 2, 120, 743, 3, 2,
	2, 2, 122, 759, 3, 2, 2, 2, 124, 763, 3, 2, 2, 2, 126, 767, 3, 2, 2, 2,
	128, 769, 3, 2, 2, 2, 130, 780, 3, 2, 2, 2, 132, 782, 3, 2, 2, 2, 134,
	797, 3, 2, 2, 2, 136, 810, 3, 2, 2, 2, 138, 821, 3, 2, 2, 2, 140, 829,
	3, 2, 2, 2, 142, 831, 3, 2, 2, 2, 144, 839, 3, 2, 2, 2, 146, 844, 3, 2,
	2, 2, 148, 850, 3, 2, 2, 2, 150, 854, 3, 2, 2, 2, 152, 856, 3, 2, 2, 2,
	154, 864, 3, 2, 2, 2, 156, 869, 3, 2, 2, 2, 158, 871, 3, 2, 2, 2, 160,
	877, 3, 2, 2, 2, 162, 883, 3, 2, 2, 2, 164, 900, 3, 2, 2, 2, 166, 902,
	3, 2, 2, 2, 168, 908, 3, 2, 2, 2, 170, 923, 3, 2, 2, 2, 172, 938, 3, 2,
	2, 2, 174, 940, 3, 2, 2, 2, 176, 944, 3, 2, 2, 2, 178, 948, 3, 2, 2, 2,
	180, 950, 3, 2, 2, 2, 182, 974, 3, 2, 2, 2, 184, 980, 3, 2, 2, 2, 186,
	990, 3, 2, 2, 2, 188, 995, 3, 2, 2, 2, 190, 998, 3, 2, 2, 2, 192, 1002,
	3, 2, 2, 2, 194, 1010, 3, 2, 2, 2, 196, 1013, 3, 2, 2, 2, 198, 1019, 3,
	2, 2, 2, 200, 1027, 3, 2, 2, 2, 202, 1048, 3, 2, 2, 2, 204, 1066, 3, 2,
	2, 2, 206, 1070, 3, 2, 2, 2, 208, 1074, 3, 2, 2, 2, 210, 1076, 3, 2, 2,
	2, 212, 1093, 3, 2, 2, 2, 214, 1095, 3, 2, 2, 2, 216, 1117, 3, 2, 2, 2,
	218, 1119, 3, 2, 2, 2, 220, 1141, 3, 2, 2, 2, 222, 1145, 3, 2, 2, 2, 224,
	1147, 3, 2, 2, 2, 226, 1153, 3, 2, 2, 2, 228, 1159, 3, 2, 2, 2, 230, 1167,
	3, 2, 2, 2, 232, 1175, 3, 2, 2, 2, 234, 1192, 3, 2, 2, 2, 236, 1194, 3,
	2, 2, 2, 238, 1196, 3, 2, 2, 2, 240, 1198, 3, 2, 2, 2, 242, 1200, 3, 2,
	2, 2, 244, 1202, 3, 2, 2, 2, 246, 248, 5, 4, 3, 2, 247, 246, 3, 2, 2, 2,
	248, 249, 3, 2, 2, 2, 249, 247, 3, 2, 2, 2, 249, 250, 3, 2, 2, 2, 250,
	251, 3, 2, 2, 2, 251, 252, 7, 2, 2, 3, 252, 3, 3, 2, 2, 2, 253, 256, 5,
	18, 10, 2, 254, 256, 5, 76, 39, 2, 255, 253, 3, 2, 2, 2, 255, 254, 3, 2,
	2, 2, 256, 257, 3, 2, 2, 2, 257, 258, 7, 3, 2, 2, 258, 5, 3, 2, 2, 2, 259,
	260, 7, 67, 2, 2, 260, 7, 3, 2, 2, 2, 261, 262, 7, 68, 2, 2, 262, 9, 3,
	2, 2, 2, 263, 264, 7, 69, 2, 2, 264, 11, 3, 2, 2, 2, 265, 266, 7, 70, 2,
	2, 266, 13, 3, 2, 2, 2, 267, 268, 7, 71, 2, 2, 268, 15, 3, 2, 2, 2, 269,
	270, 7, 72, 2, 2, 270, 17, 3, 2, 2, 2, 271, 272, 7, 4, 2, 2, 272, 273,
	5, 6, 4, 2, 273, 274, 5, 74, 38, 2, 274, 288, 3, 2, 2, 2, 275, 276, 7,
	4, 2, 2, 276, 277, 5, 6, 4, 2, 277, 278, 5, 24, 13, 2, 278, 288, 3, 2,
	2, 2, 279, 280, 7, 4, 2, 2, 280, 281, 5, 6, 4, 2, 281, 282, 7, 5, 2, 2,
	282, 283, 5, 24, 13, 2, 283, 284, 7, 6, 2, 2, 284, 288, 3, 2, 2, 2, 285,
	286, 7, 73, 2, 2, 286, 288, 5, 20, 11, 2, 287, 271, 3, 2, 2, 2, 287, 275,
	3, 2, 2, 2, 287, 279, 3, 2, 2, 2, 287, 285, 3, 2, 2, 2, 288, 19, 3, 2,
	2, 2, 289, 290, 5, 22, 12, 2, 290, 291, 5, 32, 17, 2, 291, 298, 3, 2, 2,
	2, 292, 293, 7, 5, 2, 2, 293, 294, 5, 22, 12, 2, 294, 295, 5, 32, 17, 2,
	295, 296, 7, 6, 2, 2, 296, 298, 3, 2, 2, 2, 297, 289, 3, 2, 2, 2, 297,
	292, 3, 2, 2, 2, 298, 21, 3, 2, 2, 2, 299, 305, 5, 6, 4, 2, 300, 301, 5,
	6, 4, 2, 301, 302, 7, 7, 2, 2, 302, 303, 5, 6, 4, 2, 303, 305, 3, 2, 2,
	2, 304, 299, 3, 2, 2, 2, 304, 300, 3, 2, 2, 2, 305, 23, 3, 2, 2, 2, 306,
	307, 5, 86, 44, 2, 307, 308, 7, 8, 2, 2, 308, 309, 5, 26, 14, 2, 309, 315,
	3, 2, 2, 2, 310, 311, 5, 86, 44, 2, 311, 312, 7, 9, 2, 2, 312, 313, 5,
	42, 22, 2, 313, 315, 3, 2, 2, 2, 314, 306, 3, 2, 2, 2, 314, 310, 3, 2,
	2, 2, 315, 25, 3, 2, 2, 2, 316, 317, 7, 10, 2, 2, 317, 318, 5, 28, 15,
	2, 318, 319, 7, 11, 2, 2, 319, 27, 3, 2, 2, 2, 320, 334, 5, 30, 16, 2,
	321, 322, 5, 30, 16, 2, 322, 323, 7, 8, 2, 2, 323, 324, 5, 28, 15, 2, 324,
	334, 3, 2, 2, 2, 325, 326, 5, 86, 44, 2, 326, 327, 7, 8, 2, 2, 327, 328,
	5, 28, 15, 2, 328, 334, 3, 2, 2, 2, 329, 330, 5, 30, 16, 2, 330, 331, 7,
	8, 2, 2, 331, 332, 5, 228, 115, 2, 332, 334, 3, 2, 2, 2, 333, 320, 3, 2,
	2, 2, 333, 321, 3, 2, 2, 2, 333, 325, 3, 2, 2, 2, 333, 329, 3, 2, 2, 2,
	334, 29, 3, 2, 2, 2, 335, 336, 5, 86, 44, 2, 336, 337, 7, 9, 2, 2, 337,
	338, 5, 42, 22, 2, 338, 31, 3, 2, 2, 2, 339, 344, 5, 34, 18, 2, 340, 341,
	7, 12, 2, 2, 341, 343, 5, 34, 18, 2, 342, 340, 3, 2, 2, 2, 343, 346, 3,
	2, 2, 2, 344, 342, 3, 2, 2, 2, 344, 345, 3, 2, 2, 2, 345, 33, 3, 2, 2,
	2, 346, 344, 3, 2, 2, 2, 347, 350, 5, 58, 30, 2, 348, 349, 7, 13, 2, 2,
	349, 351, 5, 36, 19, 2, 350, 348, 3, 2, 2, 2, 350, 351, 3, 2, 2, 2, 351,
	35, 3, 2, 2, 2, 352, 357, 5, 38, 20, 2, 353, 354, 7, 8, 2, 2, 354, 356,
	5, 38, 20, 2, 355, 353, 3, 2, 2, 2, 356, 359, 3, 2, 2, 2, 357, 355, 3,
	2, 2, 2, 357, 358, 3, 2, 2, 2, 358, 37, 3, 2, 2, 2, 359, 357, 3, 2, 2,
	2, 360, 361, 5, 6, 4, 2, 361, 362, 7, 5, 2, 2, 362, 363, 5, 40, 21, 2,
	363, 364, 7, 6, 2, 2, 364, 370, 3, 2, 2, 2, 365, 366, 5, 8, 5, 2, 366,
	367, 7, 9, 2, 2, 367, 368, 5, 42, 22, 2, 368, 370, 3, 2, 2, 2, 369, 360,
	3, 2, 2, 2, 369, 365, 3, 2, 2, 2, 370, 39, 3, 2, 2, 2, 371, 376, 5, 42,
	22, 2, 372, 373, 7, 8, 2, 2, 373, 375, 5, 42, 22, 2, 374, 372, 3, 2, 2,
	2, 375, 378, 3, 2, 2, 2, 376, 374, 3, 2, 2, 2, 376, 377, 3, 2, 2, 2, 377,
	41, 3, 2, 2, 2, 378, 376, 3, 2, 2, 2, 379, 380, 5, 8, 5, 2, 380, 381, 7,
	9, 2, 2, 381, 383, 3, 2, 2, 2, 382, 379, 3, 2, 2, 2, 382, 383, 3, 2, 2,
	2, 383, 384, 3, 2, 2, 2, 384, 385, 5, 44, 23, 2, 385, 43, 3, 2, 2, 2, 386,
	389, 5, 46, 24, 2, 387, 388, 7, 14, 2, 2, 388, 390, 5, 44, 23, 2, 389,
	387, 3, 2, 2, 2, 389, 390, 3, 2, 2, 2, 390, 45, 3, 2, 2, 2, 391, 394, 5,
	48, 25, 2, 392, 393, 7, 15, 2, 2, 393, 395, 5, 48, 25, 2, 394, 392, 3,
	2, 2, 2, 394, 395, 3, 2, 2, 2, 395, 47, 3, 2, 2, 2, 396, 397, 8, 25, 1,
	2, 397, 398, 5, 50, 26, 2, 398, 405, 3, 2, 2, 2, 399, 400, 12, 4, 2, 2,
	400, 401, 5, 240, 121, 2, 401, 402, 5, 50, 26, 2, 402, 404, 3, 2, 2, 2,
	403, 399, 3, 2, 2, 2, 404, 407, 3, 2, 2, 2, 405, 403, 3, 2, 2, 2, 405,
	406, 3, 2, 2, 2, 406, 49, 3, 2, 2, 2, 407, 405, 3, 2, 2, 2, 408, 409, 8,
	26, 1, 2, 409, 410, 5, 52, 27, 2, 410, 417, 3, 2, 2, 2, 411, 412, 12, 4,
	2, 2, 412, 413, 5, 238, 120, 2, 413, 414, 5, 52, 27, 2, 414, 416, 3, 2,
	2, 2, 415, 411, 3, 2, 2, 2, 416, 419, 3, 2, 2, 2, 417, 415, 3, 2, 2, 2,
	417, 418, 3, 2, 2, 2, 418, 51, 3, 2, 2, 2, 419, 417, 3, 2, 2, 2, 420, 422,
	5, 236, 119, 2, 421, 420, 3, 2, 2, 2, 421, 422, 3, 2, 2, 2, 422, 423, 3,
	2, 2, 2, 423, 424, 5, 54, 28, 2, 424, 53, 3, 2, 2, 2, 425, 426, 7, 5, 2,
	2, 426, 427, 5, 42, 22, 2, 427, 428, 7, 6, 2, 2, 428, 502, 3, 2, 2, 2,
	429, 502, 5, 8, 5, 2, 430, 502, 5, 6, 4, 2, 431, 432, 5, 6, 4, 2, 432,
	433, 7, 5, 2, 2, 433, 434, 7, 6, 2, 2, 434, 502, 3, 2, 2, 2, 435, 436,
	5, 6, 4, 2, 436, 437, 7, 5, 2, 2, 437, 438, 5, 40, 21, 2, 438, 439, 7,
	6, 2, 2, 439, 502, 3, 2, 2, 2, 440, 441, 5, 6, 4, 2, 441, 442, 7, 7, 2,
	2, 442, 443, 5, 6, 4, 2, 443, 444, 7, 5, 2, 2, 444, 445, 7, 6, 2, 2, 445,
	502, 3, 2, 2, 2, 446, 447, 5, 6, 4, 2, 447, 448, 7, 7, 2, 2, 448, 449,
	5, 6, 4, 2, 449, 450, 7, 5, 2, 2, 450, 451, 5, 40, 21, 2, 451, 452, 7,
	6, 2, 2, 452, 502, 3, 2, 2, 2, 453, 454, 7, 16, 2, 2, 454, 502, 7, 17,
	2, 2, 455, 456, 7, 16, 2, 2, 456, 457, 5, 42, 22, 2, 457, 458, 7, 17, 2,
	2, 458, 502, 3, 2, 2, 2, 459, 460, 7, 16, 2, 2, 460, 461, 5, 42, 22, 2,
	461, 462, 7, 8, 2, 2, 462, 463, 7, 18, 2, 2, 463, 464, 7, 17, 2, 2, 464,
	502, 3, 2, 2, 2, 465, 466, 7, 19, 2, 2, 466, 467, 7, 10, 2, 2, 467, 502,
	7, 11, 2, 2, 468, 469, 7, 19, 2, 2, 469, 470, 7, 10, 2, 2, 470, 471, 5,
	60, 31, 2, 471, 472, 7, 11, 2, 2, 472, 502, 3, 2, 2, 2, 473, 474, 7, 10,
	2, 2, 474, 502, 7, 11, 2, 2, 475, 476, 7, 10, 2, 2, 476, 477, 5, 40, 21,
	2, 477, 478, 7, 11, 2, 2, 478, 502, 3, 2, 2, 2, 479, 480, 7, 19, 2, 2,
	480, 481, 5, 6, 4, 2, 481, 482, 7, 10, 2, 2, 482, 483, 7, 11, 2, 2, 483,
	502, 3, 2, 2, 2, 484, 485, 7, 19, 2, 2, 485, 486, 5, 6, 4, 2, 486, 487,
	7, 10, 2, 2, 487, 488, 5, 64, 33, 2, 488, 489, 7, 11, 2, 2, 489, 502, 3,
	2, 2, 2, 490, 502, 5, 68, 35, 2, 491, 502, 5, 12, 7, 2, 492, 502, 5, 14,
	8, 2, 493, 494, 7, 20, 2, 2, 494, 495, 7, 5, 2, 2, 495, 502, 7, 6, 2, 2,
	496, 497, 7, 20, 2, 2, 497, 498, 7, 5, 2, 2, 498, 499, 5, 56, 29, 2, 499,
	500, 7, 6, 2, 2, 500, 502, 3, 2, 2, 2, 501, 425, 3, 2, 2, 2, 501, 429,
	3, 2, 2, 2, 501, 430, 3, 2, 2, 2, 501, 431, 3, 2, 2, 2, 501, 435, 3, 2,
	2, 2, 501, 440, 3, 2, 2, 2, 501, 446, 3, 2, 2, 2, 501, 453, 3, 2, 2, 2,
	501, 455, 3, 2, 2, 2, 501, 459, 3, 2, 2, 2, 501, 465, 3, 2, 2, 2, 501,
	468, 3, 2, 2, 2, 501, 473, 3, 2, 2, 2, 501, 475, 3, 2, 2, 2, 501, 479,
	3, 2, 2, 2, 501, 484, 3, 2, 2, 2, 501, 490, 3, 2, 2, 2, 501, 491, 3, 2,
	2, 2, 501, 492, 3, 2, 2, 2, 501, 493, 3, 2, 2, 2, 501, 496, 3, 2, 2, 2,
	502, 55, 3, 2, 2, 2, 503, 504, 7, 5, 2, 2, 504, 505, 7, 18, 2, 2, 505,
	506, 7, 6, 2, 2, 506, 507, 7, 21, 2, 2, 507, 510, 5, 42, 22, 2, 508, 510,
	5, 58, 30, 2, 509, 503, 3, 2, 2, 2, 509, 508, 3, 2, 2, 2, 510, 57, 3, 2,
	2, 2, 511, 513, 7, 5, 2, 2, 512, 514, 5, 40, 21, 2, 513, 512, 3, 2, 2,
	2, 513, 514, 3, 2, 2, 2, 514, 515, 3, 2, 2, 2, 515, 516, 7, 6, 2, 2, 516,
	517, 7, 21, 2, 2, 517, 518, 5, 42, 22, 2, 518, 59, 3, 2, 2, 2, 519, 524,
	5, 62, 32, 2, 520, 521, 7, 8, 2, 2, 521, 523, 5, 62, 32, 2, 522, 520, 3,
	2, 2, 2, 523, 526, 3, 2, 2, 2, 524, 522, 3, 2, 2, 2, 524, 525, 3, 2, 2,
	2, 525, 61, 3, 2, 2, 2, 526, 524, 3, 2, 2, 2, 527, 528, 5, 42, 22, 2, 528,
	529, 9, 2, 2, 2, 529, 530, 5, 42, 22, 2, 530, 63, 3, 2, 2, 2, 531, 536,
	5, 66, 34, 2, 532, 533, 7, 8, 2, 2, 533, 535, 5, 66, 34, 2, 534, 532, 3,
	2, 2, 2, 535, 538, 3, 2, 2, 2, 536, 534, 3, 2, 2, 2, 536, 537, 3, 2, 2,
	2, 537, 65, 3, 2, 2, 2, 538, 536, 3, 2, 2, 2, 539, 540, 5, 6, 4, 2, 540,
	541, 7, 9, 2, 2, 541, 542, 5, 42, 22, 2, 542, 67, 3, 2, 2, 2, 543, 544,
	7, 24, 2, 2, 544, 560, 7, 25, 2, 2, 545, 546, 7, 24, 2, 2, 546, 547, 5,
	70, 36, 2, 547, 548, 7, 25, 2, 2, 548, 560, 3, 2, 2, 2, 549, 550, 7, 24,
	2, 2, 550, 551, 5, 72, 37, 2, 551, 552, 7, 25, 2, 2, 552, 560, 3, 2, 2,
	2, 553, 554, 7, 24, 2, 2, 554, 555, 5, 70, 36, 2, 555, 556, 7, 8, 2, 2,
	556, 557, 5, 72, 37, 2, 557, 558, 7, 25, 2, 2, 558, 560, 3, 2, 2, 2, 559,
	543, 3, 2, 2, 2, 559, 545, 3, 2, 2, 2, 559, 549, 3, 2, 2, 2, 559, 553,
	3, 2, 2, 2, 560, 69, 3, 2, 2, 2, 561, 562, 5, 8, 5, 2, 562, 563, 7, 7,
	2, 2, 563, 564, 5, 54, 28, 2, 564, 71, 3, 2, 2, 2, 565, 566, 5, 8, 5, 2,
	566, 567, 7, 7, 2, 2, 567, 568, 5, 8, 5, 2, 568, 569, 7, 26, 2, 2, 569,
	570, 5, 54, 28, 2, 570, 73, 3, 2, 2, 2, 571, 587, 5, 86, 44, 2, 572, 573,
	7, 5, 2, 2, 573, 574, 5, 86, 44, 2, 574, 575, 7, 6, 2, 2, 575, 587, 3,
	2, 2, 2, 576, 577, 5, 86, 44, 2, 577, 578, 7, 8, 2, 2, 578, 579, 5, 228,
	115, 2, 579, 587, 3, 2, 2, 2, 580, 581, 7, 5, 2, 2, 581, 582, 5, 86, 44,
	2, 582, 583, 7, 8, 2, 2, 583, 584, 5, 228, 115, 2, 584, 585, 7, 6, 2, 2,
	585, 587, 3, 2, 2, 2, 586, 571, 3, 2, 2, 2, 586, 572, 3, 2, 2, 2, 586,
	576, 3, 2, 2, 2, 586, 580, 3, 2, 2, 2, 587, 75, 3, 2, 2, 2, 588, 593, 5,
	78, 40, 2, 589, 590, 7, 12, 2, 2, 590, 592, 5, 78, 40, 2, 591, 589, 3,
	2, 2, 2, 592, 595, 3, 2, 2, 2, 593, 591, 3, 2, 2, 2, 593, 594, 3, 2, 2,
	2, 594, 77, 3, 2, 2, 2, 595, 593, 3, 2, 2, 2, 596, 597, 5, 6, 4, 2, 597,
	598, 5, 80, 41, 2, 598, 599, 5, 82, 42, 2, 599, 600, 5, 84, 43, 2, 600,
	79, 3, 2, 2, 2, 601, 602, 5, 226, 114, 2, 602, 81, 3, 2, 2, 2, 603, 604,
	7, 13, 2, 2, 604, 606, 5, 232, 117, 2, 605, 603, 3, 2, 2, 2, 605, 606,
	3, 2, 2, 2, 606, 83, 3, 2, 2, 2, 607, 608, 7, 21, 2, 2, 608, 609, 5, 228,
	115, 2, 609, 85, 3, 2, 2, 2, 610, 611, 7, 27, 2, 2, 611, 614, 5, 86, 44,
	2, 612, 614, 5, 88, 45, 2, 613, 610, 3, 2, 2, 2, 613, 612, 3, 2, 2, 2,
	614, 87, 3, 2, 2, 2, 615, 620, 5, 90, 46, 2, 616, 617, 9, 3, 2, 2, 617,
	619, 5, 90, 46, 2, 618, 616, 3, 2, 2, 2, 619, 622, 3, 2, 2, 2, 620, 618,
	3, 2, 2, 2, 620, 621, 3, 2, 2, 2, 621, 89, 3, 2, 2, 2, 622, 620, 3, 2,
	2, 2, 623, 628, 5, 92, 47, 2, 624, 625, 7, 30, 2, 2, 625, 627, 5, 92, 47,
	2, 626, 624, 3, 2, 2, 2, 627, 630, 3, 2, 2, 2, 628, 626, 3, 2, 2, 2, 628,
	629, 3, 2, 2, 2, 629, 91, 3, 2, 2, 2, 630, 628, 3, 2, 2, 2, 631, 636, 5,
	94, 48, 2, 632, 633, 7, 31, 2, 2, 633, 635, 5, 94, 48, 2, 634, 632, 3,
	2, 2, 2, 635, 638, 3, 2, 2, 2, 636, 634, 3, 2, 2, 2, 636, 637, 3, 2, 2,
	2, 637, 93, 3, 2, 2, 2, 638, 636, 3, 2, 2, 2, 639, 643, 5, 96, 49, 2, 640,
	641, 5, 244, 123, 2, 641, 642, 5, 96, 49, 2, 642, 644, 3, 2, 2, 2, 643,
	640, 3, 2, 2, 2, 643, 644, 3, 2, 2, 2, 644, 95, 3, 2, 2, 2, 645, 651, 5,
	98, 50, 2, 646, 647, 5, 242, 122, 2, 647, 648, 5, 98, 50, 2, 648, 650,
	3, 2, 2, 2, 649, 646, 3, 2, 2, 2, 650, 653, 3, 2, 2, 2, 651, 649, 3, 2,
	2, 2, 651, 652, 3, 2, 2, 2, 652, 97, 3, 2, 2, 2, 653, 651, 3, 2, 2, 2,
	654, 660, 5, 100, 51, 2, 655, 656, 5, 240, 121, 2, 656, 657, 5, 100, 51,
	2, 657, 659, 3, 2, 2, 2, 658, 655, 3, 2, 2, 2, 659, 662, 3, 2, 2, 2, 660,
	658, 3, 2, 2, 2, 660, 661, 3, 2, 2, 2, 661, 99, 3, 2, 2, 2, 662, 660, 3,
	2, 2, 2, 663, 669, 5, 102, 52, 2, 664, 665, 5, 238, 120, 2, 665, 666, 5,
	102, 52, 2, 666, 668, 3, 2, 2, 2, 667, 664, 3, 2, 2, 2, 668, 671, 3, 2,
	2, 2, 669, 667, 3, 2, 2, 2, 669, 670, 3, 2, 2, 2, 670, 101, 3, 2, 2, 2,
	671, 669, 3, 2, 2, 2, 672, 673, 5, 236, 119, 2, 673, 674, 5, 102, 52, 2,
	674, 677, 3, 2, 2, 2, 675, 677, 5, 104, 53, 2, 676, 672, 3, 2, 2, 2, 676,
	675, 3, 2, 2, 2, 677, 103, 3, 2, 2, 2, 678, 681, 5, 168, 85, 2, 679, 681,
	5, 106, 54, 2, 680, 678, 3, 2, 2, 2, 680, 679, 3, 2, 2, 2, 681, 105, 3,
	2, 2, 2, 682, 686, 5, 188, 95, 2, 683, 686, 5, 180, 91, 2, 684, 686, 5,
	108, 55, 2, 685, 682, 3, 2, 2, 2, 685, 683, 3, 2, 2, 2, 685, 684, 3, 2,
	2, 2, 686, 107, 3, 2, 2, 2, 687, 690, 5, 110, 56, 2, 688, 689, 7, 7, 2,
	2, 689, 691, 5, 110, 56, 2, 690, 688, 3, 2, 2, 2, 690, 691, 3, 2, 2, 2,
	691, 109, 3, 2, 2, 2, 692, 713, 5, 8, 5, 2, 693, 713, 5, 234, 118, 2, 694,
	713, 5, 136, 69, 2, 695, 713, 5, 140, 71, 2, 696, 713, 5, 158, 80, 2, 697,
	713, 5, 160, 81, 2, 698, 713, 5, 166, 84, 2, 699, 700, 7, 5, 2, 2, 700,
	701, 5, 86, 44, 2, 701, 702, 7, 6, 2, 2, 702, 713, 3, 2, 2, 2, 703, 704,
	7, 32, 2, 2, 704, 705, 5, 228, 115, 2, 705, 706, 7, 33, 2, 2, 706, 713,
	3, 2, 2, 2, 707, 713, 5, 190, 96, 2, 708, 713, 5, 196, 99, 2, 709, 713,
	5, 202, 102, 2, 710, 713, 5, 204, 103, 2, 711, 713, 5, 214, 108, 2, 712,
	692, 3, 2, 2, 2, 712, 693, 3, 2, 2, 2, 712, 694, 3, 2, 2, 2, 712, 695,
	3, 2, 2, 2, 712, 696, 3, 2, 2, 2, 712, 697, 3, 2, 2, 2, 712, 698, 3, 2,
	2, 2, 712, 699, 3, 2, 2, 2, 712, 703, 3, 2, 2, 2, 712, 707, 3, 2, 2, 2,
	712, 708, 3, 2, 2, 2, 712, 709, 3, 2, 2, 2, 712, 710, 3, 2, 2, 2, 712,
	711, 3, 2, 2, 2, 713, 111, 3, 2, 2, 2, 714, 717, 5, 114, 58, 2, 715, 716,
	7, 28, 2, 2, 716, 718, 5, 112, 57, 2, 717, 715, 3, 2, 2, 2, 717, 718, 3,
	2, 2, 2, 718, 113, 3, 2, 2, 2, 719, 723, 5, 116, 59, 2, 720, 721, 5, 244,
	123, 2, 721, 722, 5, 116, 59, 2, 722, 724, 3, 2, 2, 2, 723, 720, 3, 2,
	2, 2, 723, 724, 3, 2, 2, 2, 724, 115, 3, 2, 2, 2, 725, 729, 5, 118, 60,
	2, 726, 727, 5, 242, 122, 2, 727, 728, 5, 116, 59, 2, 728, 730, 3, 2, 2,
	2, 729, 726, 3, 2, 2, 2, 729, 730, 3, 2, 2, 2, 730, 117, 3, 2, 2, 2, 731,
	732, 8, 60, 1, 2, 732, 733, 5, 120, 61, 2, 733, 740, 3, 2, 2, 2, 734, 735,
	12, 4, 2, 2, 735, 736, 5, 240, 121, 2, 736, 737, 5, 120, 61, 2, 737, 739,
	3, 2, 2, 2, 738, 734, 3, 2, 2, 2, 739, 742, 3, 2, 2, 2, 740, 738, 3, 2,
	2, 2, 740, 741, 3, 2, 2, 2, 741, 119, 3, 2, 2, 2, 742, 740, 3, 2, 2, 2,
	743, 744, 8, 61, 1, 2, 744, 745, 5, 122, 62, 2, 745, 752, 3, 2, 2, 2, 746,
	747, 12, 4, 2, 2, 747, 748, 5, 238, 120, 2, 748, 749, 5, 122, 62, 2, 749,
	751, 3, 2, 2, 2, 750, 746, 3, 2, 2, 2, 751, 754, 3, 2, 2, 2, 752, 750,
	3, 2, 2, 2, 752, 753, 3, 2, 2, 2, 753, 121, 3, 2, 2, 2, 754, 752, 3, 2,
	2, 2, 755, 756, 5, 236, 119, 2, 756, 757, 5, 122, 62, 2, 757, 760, 3, 2,
	2, 2, 758, 760, 5, 124, 63, 2, 759, 755, 3, 2, 2, 2, 759, 758, 3, 2, 2,
	2, 760, 123, 3, 2, 2, 2, 761, 764, 5, 132, 67, 2, 762, 764, 5, 126, 64,
	2, 763, 761, 3, 2, 2, 2, 763, 762, 3, 2, 2, 2, 764, 125, 3, 2, 2, 2, 765,
	768, 5, 134, 68, 2, 766, 768, 5, 128, 65, 2, 767, 765, 3, 2, 2, 2, 767,
	766, 3, 2, 2, 2, 768, 127, 3, 2, 2, 2, 769, 770, 5, 130, 66, 2, 770, 129,
	3, 2, 2, 2, 771, 781, 5, 8, 5, 2, 772, 781, 5, 234, 118, 2, 773, 781, 5,
	136, 69, 2, 774, 781, 5, 140, 71, 2, 775, 781, 5, 166, 84, 2, 776, 777,
	7, 5, 2, 2, 777, 778, 5, 112, 57, 2, 778, 779, 7, 6, 2, 2, 779, 781, 3,
	2, 2, 2, 780, 771, 3, 2, 2, 2, 780, 772, 3, 2, 2, 2, 780, 773, 3, 2, 2,
	2, 780, 774, 3, 2, 2, 2, 780, 775, 3, 2, 2, 2, 780, 776, 3, 2, 2, 2, 781,
	131, 3, 2, 2, 2, 782, 784, 8, 67, 1, 2, 783, 785, 5, 130, 66, 2, 784, 783,
	3, 2, 2, 2, 784, 785, 3, 2, 2, 2, 785, 786, 3, 2, 2, 2, 786, 787, 7, 19,
	2, 2, 787, 788, 5, 170, 86, 2, 788, 794, 3, 2, 2, 2, 789, 790, 12, 3, 2,
	2, 790, 791, 7, 19, 2, 2, 791, 793, 5, 170, 86, 2, 792, 789, 3, 2, 2, 2,
	793, 796, 3, 2, 2, 2, 794, 792, 3, 2, 2, 2, 794, 795, 3, 2, 2, 2, 795,
	133, 3, 2, 2, 2, 796, 794, 3, 2, 2, 2, 797, 798, 7, 19, 2, 2, 798, 802,
	5, 6, 4, 2, 799, 800, 7, 3, 2, 2, 800, 803, 5, 6, 4, 2, 801, 803, 5, 182,
	92, 2, 802, 799, 3, 2, 2, 2, 802, 801, 3, 2, 2, 2, 803, 135, 3, 2, 2, 2,
	804, 805, 7, 16, 2, 2, 805, 811, 7, 17, 2, 2, 806, 807, 7, 16, 2, 2, 807,
	808, 5, 86, 44, 2, 808, 809, 5, 138, 70, 2, 809, 811, 3, 2, 2, 2, 810,
	804, 3, 2, 2, 2, 810, 806, 3, 2, 2, 2, 811, 137, 3, 2, 2, 2, 812, 822,
	7, 17, 2, 2, 813, 814, 7, 14, 2, 2, 814, 815, 5, 86, 44, 2, 815, 816, 7,
	17, 2, 2, 816, 822, 3, 2, 2, 2, 817, 818, 7, 8, 2, 2, 818, 819, 5, 86,
	44, 2, 819, 820, 5, 138, 70, 2, 820, 822, 3, 2, 2, 2, 821, 812, 3, 2, 2,
	2, 821, 813, 3, 2, 2, 2, 821, 817, 3, 2, 2, 2, 822, 139, 3, 2, 2, 2, 823,
	824, 7, 24, 2, 2, 824, 830, 7, 25, 2, 2, 825, 826, 7, 24, 2, 2, 826, 827,
	5, 142, 72, 2, 827, 828, 7, 25, 2, 2, 828, 830, 3, 2, 2, 2, 829, 823, 3,
	2, 2, 2, 829, 825, 3, 2, 2, 2, 830, 141, 3, 2, 2, 2, 831, 836, 5, 144,
	73, 2, 832, 833, 7, 8, 2, 2, 833, 835, 5, 144, 73, 2, 834, 832, 3, 2, 2,
	2, 835, 838, 3, 2, 2, 2, 836, 834, 3, 2, 2, 2, 836, 837, 3, 2, 2, 2, 837,
	143, 3, 2, 2, 2, 838, 836, 3, 2, 2, 2, 839, 840, 5, 146, 74, 2, 840, 841,
	5, 148, 75, 2, 841, 842, 5, 150, 76, 2, 842, 145, 3, 2, 2, 2, 843, 845,
	5, 236, 119, 2, 844, 843, 3, 2, 2, 2, 844, 845, 3, 2, 2, 2, 845, 846, 3,
	2, 2, 2, 846, 847, 5, 110, 56, 2, 847, 147, 3, 2, 2, 2, 848, 849, 7, 7,
	2, 2, 849, 851, 5, 156, 79, 2, 850, 848, 3, 2, 2, 2, 850, 851, 3, 2, 2,
	2, 851, 149, 3, 2, 2, 2, 852, 853, 7, 34, 2, 2, 853, 855, 5, 152, 77, 2,
	854, 852, 3, 2, 2, 2, 854, 855, 3, 2, 2, 2, 855, 151, 3, 2, 2, 2, 856,
	861, 5, 154, 78, 2, 857, 858, 7, 4, 2, 2, 858, 860, 5, 154, 78, 2, 859,
	857, 3, 2, 2, 2, 860, 863, 3, 2, 2, 2, 861, 859, 3, 2, 2, 2, 861, 862,
	3, 2, 2, 2, 862, 153, 3, 2, 2, 2, 863, 861, 3, 2, 2, 2, 864, 867, 5, 6,
	4, 2, 865, 866, 7, 7, 2, 2, 866, 868, 5, 12, 7, 2, 867, 865, 3, 2, 2, 2,
	867, 868, 3, 2, 2, 2, 868, 155, 3, 2, 2, 2, 869, 870, 5, 110, 56, 2, 870,
	157, 3, 2, 2, 2, 871, 872, 7, 16, 2, 2, 872, 873, 5, 86, 44, 2, 873, 874,
	7, 35, 2, 2, 874, 875, 5, 162, 82, 2, 875, 876, 7, 17, 2, 2, 876, 159,
	3, 2, 2, 2, 877, 878, 7, 24, 2, 2, 878, 879, 5, 110, 56, 2, 879, 880, 7,
	35, 2, 2, 880, 881, 5, 162, 82, 2, 881, 882, 7, 25, 2, 2, 882, 161, 3,
	2, 2, 2, 883, 888, 5, 164, 83, 2, 884, 885, 7, 8, 2, 2, 885, 887, 5, 164,
	83, 2, 886, 884, 3, 2, 2, 2, 887, 890, 3, 2, 2, 2, 888, 886, 3, 2, 2, 2,
	888, 889, 3, 2, 2, 2, 889, 163, 3, 2, 2, 2, 890, 888, 3, 2, 2, 2, 891,
	901, 5, 86, 44, 2, 892, 893, 5, 86, 44, 2, 893, 894, 7, 36, 2, 2, 894,
	895, 5, 86, 44, 2, 895, 901, 3, 2, 2, 2, 896, 897, 5, 140, 71, 2, 897,
	898, 7, 37, 2, 2, 898, 899, 5, 86, 44, 2, 899, 901, 3, 2, 2, 2, 900, 891,
	3, 2, 2, 2, 900, 892, 3, 2, 2, 2, 900, 896, 3, 2, 2, 2, 901, 165, 3, 2,
	2, 2, 902, 904, 7, 10, 2, 2, 903, 905, 5, 228, 115, 2, 904, 903, 3, 2,
	2, 2, 904, 905, 3, 2, 2, 2, 905, 906, 3, 2, 2, 2, 906, 907, 7, 11, 2, 2,
	907, 167, 3, 2, 2, 2, 908, 910, 8, 85, 1, 2, 909, 911, 5, 110, 56, 2, 910,
	909, 3, 2, 2, 2, 910, 911, 3, 2, 2, 2, 911, 912, 3, 2, 2, 2, 912, 913,
	7, 19, 2, 2, 913, 914, 5, 170, 86, 2, 914, 920, 3, 2, 2, 2, 915, 916, 12,
	3, 2, 2, 916, 917, 7, 19, 2, 2, 917, 919, 5, 170, 86, 2, 918, 915, 3, 2,
	2, 2, 919, 922, 3, 2, 2, 2, 920, 918, 3, 2, 2, 2, 920, 921, 3, 2, 2, 2,
	921, 169, 3, 2, 2, 2, 922, 920, 3, 2, 2, 2, 923, 932, 7, 10, 2, 2, 924,
	929, 5, 172, 87, 2, 925, 926, 7, 8, 2, 2, 926, 928, 5, 172, 87, 2, 927,
	925, 3, 2, 2, 2, 928, 931, 3, 2, 2, 2, 929, 927, 3, 2, 2, 2, 929, 930,
	3, 2, 2, 2, 930, 933, 3, 2, 2, 2, 931, 929, 3, 2, 2, 2, 932, 924, 3, 2,
	2, 2, 932, 933, 3, 2, 2, 2, 933, 934, 3, 2, 2, 2, 934, 935, 7, 11, 2, 2,
	935, 171, 3, 2, 2, 2, 936, 939, 5, 174, 88, 2, 937, 939, 5, 176, 89, 2,
	938, 936, 3, 2, 2, 2, 938, 937, 3, 2, 2, 2, 939, 173, 3, 2, 2, 2, 940,
	941, 5, 178, 90, 2, 941, 942, 7, 22, 2, 2, 942, 943, 5, 86, 44, 2, 943,
	175, 3, 2, 2, 2, 944, 945, 5, 178, 90, 2, 945, 946, 7, 23, 2, 2, 946, 947,
	5, 86, 44, 2, 947, 177, 3, 2, 2, 2, 948, 949, 5, 86, 44, 2, 949, 179, 3,
	2, 2, 2, 950, 952, 8, 91, 1, 2, 951, 953, 5, 110, 56, 2, 952, 951, 3, 2,
	2, 2, 952, 953, 3, 2, 2, 2, 953, 954, 3, 2, 2, 2, 954, 955, 7, 19, 2, 2,
	955, 959, 5, 6, 4, 2, 956, 957, 7, 3, 2, 2, 957, 960, 5, 6, 4, 2, 958,
	960, 5, 182, 92, 2, 959, 956, 3, 2, 2, 2, 959, 958, 3, 2, 2, 2, 960, 971,
	3, 2, 2, 2, 961, 962, 12, 3, 2, 2, 962, 963, 7, 19, 2, 2, 963, 967, 5,
	6, 4, 2, 964, 965, 7, 3, 2, 2, 965, 968, 5, 6, 4, 2, 966, 968, 5, 182,
	92, 2, 967, 964, 3, 2, 2, 2, 967, 966, 3, 2, 2, 2, 968, 970, 3, 2, 2, 2,
	969, 961, 3, 2, 2, 2, 970, 973, 3, 2, 2, 2, 971, 969, 3, 2, 2, 2, 971,
	972, 3, 2, 2, 2, 972, 181, 3, 2, 2, 2, 973, 971, 3, 2, 2, 2, 974, 976,
	7, 10, 2, 2, 975, 977, 5, 184, 93, 2, 976, 975, 3, 2, 2, 2, 976, 977, 3,
	2, 2, 2, 977, 978, 3, 2, 2, 2, 978, 979, 7, 11, 2, 2, 979, 183, 3, 2, 2,
	2, 980, 985, 5, 186, 94, 2, 981, 982, 7, 8, 2, 2, 982, 984, 5, 186, 94,
	2, 983, 981, 3, 2, 2, 2, 984, 987, 3, 2, 2, 2, 985, 983, 3, 2, 2, 2, 985,
	986, 3, 2, 2, 2, 986, 185, 3, 2, 2, 2, 987, 985, 3, 2, 2, 2, 988, 991,
	5, 8, 5, 2, 989, 991, 5, 6, 4, 2, 990, 988, 3, 2, 2, 2, 990, 989, 3, 2,
	2, 2, 991, 992, 3, 2, 2, 2, 992, 993, 7, 28, 2, 2, 993, 994, 5, 86, 44,
	2, 994, 187, 3, 2, 2, 2, 995, 996, 5, 108, 55, 2, 996, 997, 5, 224, 113,
	2, 997, 189, 3, 2, 2, 2, 998, 999, 7, 38, 2, 2, 999, 1000, 5, 192, 97,
	2, 1000, 1001, 7, 33, 2, 2, 1001, 191, 3, 2, 2, 2, 1002, 1007, 5, 194,
	98, 2, 1003, 1004, 7, 12, 2, 2, 1004, 1006, 5, 194, 98, 2, 1005, 1003,
	3, 2, 2, 2, 1006, 1009, 3, 2, 2, 2, 1007, 1005, 3, 2, 2, 2, 1007, 1008,
	3, 2, 2, 2, 1008, 193, 3, 2, 2, 2, 1009, 1007, 3, 2, 2, 2, 1010, 1011,
	5, 232, 117, 2, 1011, 1012, 5, 84, 43, 2, 1012, 195, 3, 2, 2, 2, 1013,
	1014, 7, 39, 2, 2, 1014, 1015, 5, 86, 44, 2, 1015, 1016, 7, 40, 2, 2, 1016,
	1017, 5, 198, 100, 2, 1017, 1018, 7, 33, 2, 2, 1018, 197, 3, 2, 2, 2, 1019,
	1024, 5, 200, 101, 2, 1020, 1021, 7, 12, 2, 2, 1021, 1023, 5, 200, 101,
	2, 1022, 1020, 3, 2, 2, 2, 1023, 1026, 3, 2, 2, 2, 1024, 1022, 3, 2, 2,
	2, 1024, 1025, 3, 2, 2, 2, 1025, 199, 3, 2, 2, 2, 1026, 1024, 3, 2, 2,
	2, 1027, 1028, 5, 86, 44, 2, 1028, 1029, 5, 82, 42, 2, 1029, 1030, 5, 84,
	43, 2, 1030, 201, 3, 2, 2, 2, 1031, 1032, 7, 41, 2, 2, 1032, 1033, 5, 198,
	100, 2, 1033, 1034, 7, 33, 2, 2, 1034, 1049, 3, 2, 2, 2, 1035, 1036, 7,
	41, 2, 2, 1036, 1037, 7, 42, 2, 2, 1037, 1038, 5, 86, 44, 2, 1038, 1039,
	5, 84, 43, 2, 1039, 1040, 7, 33, 2, 2, 1040, 1049, 3, 2, 2, 2, 1041, 1042,
	7, 41, 2, 2, 1042, 1043, 5, 198, 100, 2, 1043, 1044, 7, 42, 2, 2, 1044,
	1045, 5, 86, 44, 2, 1045, 1046, 5, 84, 43, 2, 1046, 1047, 7, 33, 2, 2,
	1047, 1049, 3, 2, 2, 2, 1048, 1031, 3, 2, 2, 2, 1048, 1035, 3, 2, 2, 2,
	1048, 1041, 3, 2, 2, 2, 1049, 203, 3, 2, 2, 2, 1050, 1051, 7, 20, 2, 2,
	1051, 1052, 5, 6, 4, 2, 1052, 1053, 7, 34, 2, 2, 1053, 1054, 5, 12, 7,
	2, 1054, 1067, 3, 2, 2, 2, 1055, 1056, 7, 20, 2, 2, 1056, 1057, 5, 206,
	104, 2, 1057, 1058, 7, 7, 2, 2, 1058, 1059, 5, 206, 104, 2, 1059, 1060,
	7, 34, 2, 2, 1060, 1061, 5, 208, 105, 2, 1061, 1067, 3, 2, 2, 2, 1062,
	1063, 7, 20, 2, 2, 1063, 1064, 5, 210, 106, 2, 1064, 1065, 7, 33, 2, 2,
	1065, 1067, 3, 2, 2, 2, 1066, 1050, 3, 2, 2, 2, 1066, 1055, 3, 2, 2, 2,
	1066, 1062, 3, 2, 2, 2, 1067, 205, 3, 2, 2, 2, 1068, 1071, 5, 6, 4, 2,
	1069, 1071, 5, 8, 5, 2, 1070, 1068, 3, 2, 2, 2, 1070, 1069, 3, 2, 2, 2,
	1071, 207, 3, 2, 2, 2, 1072, 1075, 5, 12, 7, 2, 1073, 1075, 5, 8, 5, 2,
	1074, 1072, 3, 2, 2, 2, 1074, 1073, 3, 2, 2, 2, 1075, 209, 3, 2, 2, 2,
	1076, 1081, 5, 212, 107, 2, 1077, 1078, 7, 12, 2, 2, 1078, 1080, 5, 212,
	107, 2, 1079, 1077, 3, 2, 2, 2, 1080, 1083, 3, 2, 2, 2, 1081, 1079, 3,
	2, 2, 2, 1081, 1082, 3, 2, 2, 2, 1082, 211, 3, 2, 2, 2, 1083, 1081, 3,
	2, 2, 2, 1084, 1085, 5, 226, 114, 2, 1085, 1086, 5, 82, 42, 2, 1086, 1087,
	5, 84, 43, 2, 1087, 1094, 3, 2, 2, 2, 1088, 1089, 5, 8, 5, 2, 1089, 1090,
	5, 226, 114, 2, 1090, 1091, 5, 82, 42, 2, 1091, 1092, 5, 84, 43, 2, 1092,
	1094, 3, 2, 2, 2, 1093, 1084, 3, 2, 2, 2, 1093, 1088, 3, 2, 2, 2, 1094,
	213, 3, 2, 2, 2, 1095, 1096, 7, 43, 2, 2, 1096, 1099, 5, 228, 115, 2, 1097,
	1098, 7, 40, 2, 2, 1098, 1100, 5, 198, 100, 2, 1099, 1097, 3, 2, 2, 2,
	1099, 1100, 3, 2, 2, 2, 1100, 1101, 3, 2, 2, 2, 1101, 1102, 5, 216, 109,
	2, 1102, 215, 3, 2, 2, 2, 1103, 1104, 7, 27, 2, 2, 1104, 1105, 5, 218,
	110, 2, 1105, 1106, 7, 33, 2, 2, 1106, 1118, 3, 2, 2, 2, 1107, 1108, 7,
	27, 2, 2, 1108, 1109, 5, 218, 110, 2, 1109, 1110, 7, 42, 2, 2, 1110, 1111,
	5, 228, 115, 2, 1111, 1112, 7, 33, 2, 2, 1112, 1118, 3, 2, 2, 2, 1113,
	1114, 7, 42, 2, 2, 1114, 1115, 5, 228, 115, 2, 1115, 1116, 7, 33, 2, 2,
	1116, 1118, 3, 2, 2, 2, 1117, 1103, 3, 2, 2, 2, 1117, 1107, 3, 2, 2, 2,
	1117, 1113, 3, 2, 2, 2, 1118, 217, 3, 2, 2, 2, 1119, 1124, 5, 220, 111,
	2, 1120, 1121, 7, 12, 2, 2, 1121, 1123, 5, 220, 111, 2, 1122, 1120, 3,
	2, 2, 2, 1123, 1126, 3, 2, 2, 2, 1124, 1122, 3, 2, 2, 2, 1124, 1125, 3,
	2, 2, 2, 1125, 219, 3, 2, 2, 2, 1126, 1124, 3, 2, 2, 2, 1127, 1128, 5,
	86, 44, 2, 1128, 1129, 5, 82, 42, 2, 1129, 1130, 5, 84, 43, 2, 1130, 1142,
	3, 2, 2, 2, 1131, 1132, 5, 206, 104, 2, 1132, 1133, 7, 7, 2, 2, 1133, 1135,
	3, 2, 2, 2, 1134, 1131, 3, 2, 2, 2, 1134, 1135, 3, 2, 2, 2, 1135, 1136,
	3, 2, 2, 2, 1136, 1137, 5, 112, 57, 2, 1137, 1138, 5, 222, 112, 2, 1138,
	1139, 5, 82, 42, 2, 1139, 1140, 5, 84, 43, 2, 1140, 1142, 3, 2, 2, 2, 1141,
	1127, 3, 2, 2, 2, 1141, 1134, 3, 2, 2, 2, 1142, 221, 3, 2, 2, 2, 1143,
	1144, 7, 7, 2, 2, 1144, 1146, 5, 8, 5, 2, 1145, 1143, 3, 2, 2, 2, 1145,
	1146, 3, 2, 2, 2, 1146, 223, 3, 2, 2, 2, 1147, 1149, 7, 5, 2, 2, 1148,
	1150, 5, 228, 115, 2, 1149, 1148, 3, 2, 2, 2, 1149, 1150, 3, 2, 2, 2, 1150,
	1151, 3, 2, 2, 2, 1151, 1152, 7, 6, 2, 2, 1152, 225, 3, 2, 2, 2, 1153,
	1155, 7, 5, 2, 2, 1154, 1156, 5, 230, 116, 2, 1155, 1154, 3, 2, 2, 2, 1155,
	1156, 3, 2, 2, 2, 1156, 1157, 3, 2, 2, 2, 1157, 1158, 7, 6, 2, 2, 1158,
	227, 3, 2, 2, 2, 1159, 1164, 5, 86, 44, 2, 1160, 1161, 7, 8, 2, 2, 1161,
	1163, 5, 86, 44, 2, 1162, 1160, 3, 2, 2, 2, 1163, 1166, 3, 2, 2, 2, 1164,
	1162, 3, 2, 2, 2, 1164, 1165, 3, 2, 2, 2, 1165, 229, 3, 2, 2, 2, 1166,
	1164, 3, 2, 2, 2, 1167, 1172, 5, 112, 57, 2, 1168, 1169, 7, 8, 2, 2, 1169,
	1171, 5, 112, 57, 2, 1170, 1168, 3, 2, 2, 2, 1171, 1174, 3, 2, 2, 2, 1172,
	1170, 3, 2, 2, 2, 1172, 1173, 3, 2, 2, 2, 1173, 231, 3, 2, 2, 2, 1174,
	1172, 3, 2, 2, 2, 1175, 1180, 5, 228, 115, 2, 1176, 1177, 7, 12, 2, 2,
	1177, 1179, 5, 228, 115, 2, 1178, 1176, 3, 2, 2, 2, 1179, 1182, 3, 2, 2,
	2, 1180, 1178, 3, 2, 2, 2, 1180, 1181, 3, 2, 2, 2, 1181, 233, 3, 2, 2,
	2, 1182, 1180, 3, 2, 2, 2, 1183, 1193, 5, 14, 8, 2, 1184, 1193, 5, 12,
	7, 2, 1185, 1193, 5, 10, 6, 2, 1186, 1193, 5, 6, 4, 2, 1187, 1189, 5, 16,
	9, 2, 1188, 1187, 3, 2, 2, 2, 1189, 1190, 3, 2, 2, 2, 1190, 1188, 3, 2,
	2, 2, 1190, 1191, 3, 2, 2, 2, 1191, 1193, 3, 2, 2, 2, 1192, 1183, 3, 2,
	2, 2, 1192, 1184, 3, 2, 2, 2, 1192, 1185, 3, 2, 2, 2, 1192, 1186, 3, 2,
	2, 2, 1192, 1188, 3, 2, 2, 2, 1193, 235, 3, 2, 2, 2, 1194, 1195, 9, 4,
	2, 2, 1195, 237, 3, 2, 2, 2, 1196, 1197, 9, 5, 2, 2, 1197, 239, 3, 2, 2,
	2, 1198, 1199, 9, 6, 2, 2, 1199, 241, 3, 2, 2, 2, 1200, 1201, 9, 7, 2,
	2, 1201, 243, 3, 2, 2, 2, 1202, 1203, 9, 8, 2, 2, 1203, 245, 3, 2, 2, 2,
	99, 249, 255, 287, 297, 304, 314, 333, 344, 350, 357, 369, 376, 382, 389,
	394, 405, 417, 421, 501, 509, 513, 524, 536, 559, 586, 593, 605, 613, 620,
	628, 636, 643, 651, 660, 669, 676, 680, 685, 690, 712, 717, 723, 729, 740,
	752, 759, 763, 767, 780, 784, 794, 802, 810, 821, 829, 836, 844, 850, 854,
	861, 867, 888, 900, 904, 910, 920, 929, 932, 938, 952, 959, 967, 971, 976,
	985, 990, 1007, 1024, 1048, 1066, 1070, 1074, 1081, 1093, 1099, 1117, 1124,
	1134, 1141, 1145, 1149, 1155, 1164, 1172, 1180, 1190, 1192,
}
var literalNames = []string{
	"", "'.'", "'-'", "'('", "')'", "':'", "','", "'::'", "'{'", "'}'", "';'",
	"'when'", "'|'", "'..'", "'['", "']'", "'...'", "'#'", "'fun'", "'->'",
	"'=>'", "':='", "'<<'", "'>>'", "'*'", "'catch'", "'='", "'!'", "'orelse'",
	"'andalso'", "'begin'", "'end'", "'/'", "'||'", "'<-'", "'<='", "'if'",
	"'case'", "'of'", "'receive'", "'after'", "'try'", "'+'", "'bnot'", "'not'",
	"'div'", "'rem'", "'band'", "'and'", "'bor'", "'bxor'", "'bsl'", "'bsr'",
	"'or'", "'xor'", "'++'", "'--'", "'=='", "'/='", "'=<'", "'<'", "'>='",
	"'>'", "'=:='", "'=/='",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "TokAtom", "TokVar", "TokFloat",
	"TokInteger", "TokChar", "TokString", "AttrName", "Comment", "WS",
}

var ruleNames = []string{
	"forms", "form", "tokAtom", "tokVar", "tokFloat", "tokInteger", "tokChar",
	"tokString", "attribute", "typeSpec", "specFun", "typedAttrVal", "typedRecordFields",
	"typedExprs", "typedExpr", "typeSigs", "typeSig", "typeGuards", "typeGuard",
	"topTypes", "topType", "topType100", "type200", "type300", "type400", "type500",
	"type_", "funType100", "funType", "mapPairTypes", "mapPairType", "fieldTypes",
	"fieldType", "binaryType", "binBaseType", "binUnitType", "attrVal", "function_",
	"functionClause", "clauseArgs", "clauseGuard", "clauseBody", "expr", "expr100",
	"expr150", "expr160", "expr200", "expr300", "expr400", "expr500", "expr600",
	"expr650", "expr700", "expr800", "exprMax", "patExpr", "patExpr200", "patExpr300",
	"patExpr400", "patExpr500", "patExpr600", "patExpr650", "patExpr700", "patExpr800",
	"patExprMax", "mapPatExpr", "recordPatExpr", "list_", "tail", "binary",
	"binElements", "binElement", "bitExpr", "optBitSizeExpr", "optBitTypeList",
	"bitTypeList", "bitType", "bitSizeExpr", "listComprehension", "binaryComprehension",
	"lcExprs", "lcExpr", "tuple_", "mapExpr", "mapTuple", "mapField", "mapFieldAssoc",
	"mapFieldExact", "mapKey", "recordExpr", "recordTuple", "recordFields",
	"recordField", "functionCall", "ifExpr", "ifClauses", "ifClause", "caseExpr",
	"crClauses", "crClause", "receiveExpr", "funExpr", "atomOrVar", "integerOrVar",
	"funClauses", "funClause", "tryExpr", "tryCatch", "tryClauses", "tryClause",
	"tryOptStackTrace", "argumentList", "patArgumentList", "exprs", "patExprs",
	"guard_", "atomic", "prefixOp", "multOp", "addOp", "listOp", "compOp",
}

type ErlangParser struct {
	*antlr.BaseParser
}

// NewErlangParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *ErlangParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewErlangParser(input antlr.TokenStream) *ErlangParser {
	this := new(ErlangParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Erlang.g4"

	return this
}

// ErlangParser tokens.
const (
	ErlangParserEOF        = antlr.TokenEOF
	ErlangParserT__0       = 1
	ErlangParserT__1       = 2
	ErlangParserT__2       = 3
	ErlangParserT__3       = 4
	ErlangParserT__4       = 5
	ErlangParserT__5       = 6
	ErlangParserT__6       = 7
	ErlangParserT__7       = 8
	ErlangParserT__8       = 9
	ErlangParserT__9       = 10
	ErlangParserT__10      = 11
	ErlangParserT__11      = 12
	ErlangParserT__12      = 13
	ErlangParserT__13      = 14
	ErlangParserT__14      = 15
	ErlangParserT__15      = 16
	ErlangParserT__16      = 17
	ErlangParserT__17      = 18
	ErlangParserT__18      = 19
	ErlangParserT__19      = 20
	ErlangParserT__20      = 21
	ErlangParserT__21      = 22
	ErlangParserT__22      = 23
	ErlangParserT__23      = 24
	ErlangParserT__24      = 25
	ErlangParserT__25      = 26
	ErlangParserT__26      = 27
	ErlangParserT__27      = 28
	ErlangParserT__28      = 29
	ErlangParserT__29      = 30
	ErlangParserT__30      = 31
	ErlangParserT__31      = 32
	ErlangParserT__32      = 33
	ErlangParserT__33      = 34
	ErlangParserT__34      = 35
	ErlangParserT__35      = 36
	ErlangParserT__36      = 37
	ErlangParserT__37      = 38
	ErlangParserT__38      = 39
	ErlangParserT__39      = 40
	ErlangParserT__40      = 41
	ErlangParserT__41      = 42
	ErlangParserT__42      = 43
	ErlangParserT__43      = 44
	ErlangParserT__44      = 45
	ErlangParserT__45      = 46
	ErlangParserT__46      = 47
	ErlangParserT__47      = 48
	ErlangParserT__48      = 49
	ErlangParserT__49      = 50
	ErlangParserT__50      = 51
	ErlangParserT__51      = 52
	ErlangParserT__52      = 53
	ErlangParserT__53      = 54
	ErlangParserT__54      = 55
	ErlangParserT__55      = 56
	ErlangParserT__56      = 57
	ErlangParserT__57      = 58
	ErlangParserT__58      = 59
	ErlangParserT__59      = 60
	ErlangParserT__60      = 61
	ErlangParserT__61      = 62
	ErlangParserT__62      = 63
	ErlangParserT__63      = 64
	ErlangParserTokAtom    = 65
	ErlangParserTokVar     = 66
	ErlangParserTokFloat   = 67
	ErlangParserTokInteger = 68
	ErlangParserTokChar    = 69
	ErlangParserTokString  = 70
	ErlangParserAttrName   = 71
	ErlangParserComment    = 72
	ErlangParserWS         = 73
)

// ErlangParser rules.
const (
	ErlangParserRULE_forms               = 0
	ErlangParserRULE_form                = 1
	ErlangParserRULE_tokAtom             = 2
	ErlangParserRULE_tokVar              = 3
	ErlangParserRULE_tokFloat            = 4
	ErlangParserRULE_tokInteger          = 5
	ErlangParserRULE_tokChar             = 6
	ErlangParserRULE_tokString           = 7
	ErlangParserRULE_attribute           = 8
	ErlangParserRULE_typeSpec            = 9
	ErlangParserRULE_specFun             = 10
	ErlangParserRULE_typedAttrVal        = 11
	ErlangParserRULE_typedRecordFields   = 12
	ErlangParserRULE_typedExprs          = 13
	ErlangParserRULE_typedExpr           = 14
	ErlangParserRULE_typeSigs            = 15
	ErlangParserRULE_typeSig             = 16
	ErlangParserRULE_typeGuards          = 17
	ErlangParserRULE_typeGuard           = 18
	ErlangParserRULE_topTypes            = 19
	ErlangParserRULE_topType             = 20
	ErlangParserRULE_topType100          = 21
	ErlangParserRULE_type200             = 22
	ErlangParserRULE_type300             = 23
	ErlangParserRULE_type400             = 24
	ErlangParserRULE_type500             = 25
	ErlangParserRULE_type_               = 26
	ErlangParserRULE_funType100          = 27
	ErlangParserRULE_funType             = 28
	ErlangParserRULE_mapPairTypes        = 29
	ErlangParserRULE_mapPairType         = 30
	ErlangParserRULE_fieldTypes          = 31
	ErlangParserRULE_fieldType           = 32
	ErlangParserRULE_binaryType          = 33
	ErlangParserRULE_binBaseType         = 34
	ErlangParserRULE_binUnitType         = 35
	ErlangParserRULE_attrVal             = 36
	ErlangParserRULE_function_           = 37
	ErlangParserRULE_functionClause      = 38
	ErlangParserRULE_clauseArgs          = 39
	ErlangParserRULE_clauseGuard         = 40
	ErlangParserRULE_clauseBody          = 41
	ErlangParserRULE_expr                = 42
	ErlangParserRULE_expr100             = 43
	ErlangParserRULE_expr150             = 44
	ErlangParserRULE_expr160             = 45
	ErlangParserRULE_expr200             = 46
	ErlangParserRULE_expr300             = 47
	ErlangParserRULE_expr400             = 48
	ErlangParserRULE_expr500             = 49
	ErlangParserRULE_expr600             = 50
	ErlangParserRULE_expr650             = 51
	ErlangParserRULE_expr700             = 52
	ErlangParserRULE_expr800             = 53
	ErlangParserRULE_exprMax             = 54
	ErlangParserRULE_patExpr             = 55
	ErlangParserRULE_patExpr200          = 56
	ErlangParserRULE_patExpr300          = 57
	ErlangParserRULE_patExpr400          = 58
	ErlangParserRULE_patExpr500          = 59
	ErlangParserRULE_patExpr600          = 60
	ErlangParserRULE_patExpr650          = 61
	ErlangParserRULE_patExpr700          = 62
	ErlangParserRULE_patExpr800          = 63
	ErlangParserRULE_patExprMax          = 64
	ErlangParserRULE_mapPatExpr          = 65
	ErlangParserRULE_recordPatExpr       = 66
	ErlangParserRULE_list_               = 67
	ErlangParserRULE_tail                = 68
	ErlangParserRULE_binary              = 69
	ErlangParserRULE_binElements         = 70
	ErlangParserRULE_binElement          = 71
	ErlangParserRULE_bitExpr             = 72
	ErlangParserRULE_optBitSizeExpr      = 73
	ErlangParserRULE_optBitTypeList      = 74
	ErlangParserRULE_bitTypeList         = 75
	ErlangParserRULE_bitType             = 76
	ErlangParserRULE_bitSizeExpr         = 77
	ErlangParserRULE_listComprehension   = 78
	ErlangParserRULE_binaryComprehension = 79
	ErlangParserRULE_lcExprs             = 80
	ErlangParserRULE_lcExpr              = 81
	ErlangParserRULE_tuple_              = 82
	ErlangParserRULE_mapExpr             = 83
	ErlangParserRULE_mapTuple            = 84
	ErlangParserRULE_mapField            = 85
	ErlangParserRULE_mapFieldAssoc       = 86
	ErlangParserRULE_mapFieldExact       = 87
	ErlangParserRULE_mapKey              = 88
	ErlangParserRULE_recordExpr          = 89
	ErlangParserRULE_recordTuple         = 90
	ErlangParserRULE_recordFields        = 91
	ErlangParserRULE_recordField         = 92
	ErlangParserRULE_functionCall        = 93
	ErlangParserRULE_ifExpr              = 94
	ErlangParserRULE_ifClauses           = 95
	ErlangParserRULE_ifClause            = 96
	ErlangParserRULE_caseExpr            = 97
	ErlangParserRULE_crClauses           = 98
	ErlangParserRULE_crClause            = 99
	ErlangParserRULE_receiveExpr         = 100
	ErlangParserRULE_funExpr             = 101
	ErlangParserRULE_atomOrVar           = 102
	ErlangParserRULE_integerOrVar        = 103
	ErlangParserRULE_funClauses          = 104
	ErlangParserRULE_funClause           = 105
	ErlangParserRULE_tryExpr             = 106
	ErlangParserRULE_tryCatch            = 107
	ErlangParserRULE_tryClauses          = 108
	ErlangParserRULE_tryClause           = 109
	ErlangParserRULE_tryOptStackTrace    = 110
	ErlangParserRULE_argumentList        = 111
	ErlangParserRULE_patArgumentList     = 112
	ErlangParserRULE_exprs               = 113
	ErlangParserRULE_patExprs            = 114
	ErlangParserRULE_guard_              = 115
	ErlangParserRULE_atomic              = 116
	ErlangParserRULE_prefixOp            = 117
	ErlangParserRULE_multOp              = 118
	ErlangParserRULE_addOp               = 119
	ErlangParserRULE_listOp              = 120
	ErlangParserRULE_compOp              = 121
)

// IFormsContext is an interface to support dynamic dispatch.
type IFormsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormsContext differentiates from other interfaces.
	IsFormsContext()
}

type FormsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormsContext() *FormsContext {
	var p = new(FormsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_forms
	return p
}

func (*FormsContext) IsFormsContext() {}

func NewFormsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormsContext {
	var p = new(FormsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_forms

	return p
}

func (s *FormsContext) GetParser() antlr.Parser { return s.parser }

func (s *FormsContext) EOF() antlr.TerminalNode {
	return s.GetToken(ErlangParserEOF, 0)
}

func (s *FormsContext) AllForm() []IFormContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFormContext)(nil)).Elem())
	var tst = make([]IFormContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFormContext)
		}
	}

	return tst
}

func (s *FormsContext) Form(i int) IFormContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFormContext)
}

func (s *FormsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterForms(s)
	}
}

func (s *FormsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitForms(s)
	}
}

func (p *ErlangParser) Forms() (localctx IFormsContext) {
	this := p
	_ = this

	localctx = NewFormsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ErlangParserRULE_forms)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(245)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ErlangParserT__1 || _la == ErlangParserTokAtom || _la == ErlangParserAttrName {
		{
			p.SetState(244)
			p.Form()
		}

		p.SetState(247)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(249)
		p.Match(ErlangParserEOF)
	}

	return localctx
}

// IFormContext is an interface to support dynamic dispatch.
type IFormContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormContext differentiates from other interfaces.
	IsFormContext()
}

type FormContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormContext() *FormContext {
	var p = new(FormContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_form
	return p
}

func (*FormContext) IsFormContext() {}

func NewFormContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormContext {
	var p = new(FormContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_form

	return p
}

func (s *FormContext) GetParser() antlr.Parser { return s.parser }

func (s *FormContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *FormContext) Function_() IFunction_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_Context)
}

func (s *FormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterForm(s)
	}
}

func (s *FormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitForm(s)
	}
}

func (p *ErlangParser) Form() (localctx IFormContext) {
	this := p
	_ = this

	localctx = NewFormContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ErlangParserRULE_form)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(253)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserT__1, ErlangParserAttrName:
		{
			p.SetState(251)
			p.Attribute()
		}

	case ErlangParserTokAtom:
		{
			p.SetState(252)
			p.Function_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(255)
		p.Match(ErlangParserT__0)
	}

	return localctx
}

// ITokAtomContext is an interface to support dynamic dispatch.
type ITokAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTokAtomContext differentiates from other interfaces.
	IsTokAtomContext()
}

type TokAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTokAtomContext() *TokAtomContext {
	var p = new(TokAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_tokAtom
	return p
}

func (*TokAtomContext) IsTokAtomContext() {}

func NewTokAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TokAtomContext {
	var p = new(TokAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_tokAtom

	return p
}

func (s *TokAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *TokAtomContext) TokAtom() antlr.TerminalNode {
	return s.GetToken(ErlangParserTokAtom, 0)
}

func (s *TokAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TokAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TokAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTokAtom(s)
	}
}

func (s *TokAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTokAtom(s)
	}
}

func (p *ErlangParser) TokAtom() (localctx ITokAtomContext) {
	this := p
	_ = this

	localctx = NewTokAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ErlangParserRULE_tokAtom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(257)
		p.Match(ErlangParserTokAtom)
	}

	return localctx
}

// ITokVarContext is an interface to support dynamic dispatch.
type ITokVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTokVarContext differentiates from other interfaces.
	IsTokVarContext()
}

type TokVarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTokVarContext() *TokVarContext {
	var p = new(TokVarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_tokVar
	return p
}

func (*TokVarContext) IsTokVarContext() {}

func NewTokVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TokVarContext {
	var p = new(TokVarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_tokVar

	return p
}

func (s *TokVarContext) GetParser() antlr.Parser { return s.parser }

func (s *TokVarContext) TokVar() antlr.TerminalNode {
	return s.GetToken(ErlangParserTokVar, 0)
}

func (s *TokVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TokVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TokVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTokVar(s)
	}
}

func (s *TokVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTokVar(s)
	}
}

func (p *ErlangParser) TokVar() (localctx ITokVarContext) {
	this := p
	_ = this

	localctx = NewTokVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ErlangParserRULE_tokVar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(259)
		p.Match(ErlangParserTokVar)
	}

	return localctx
}

// ITokFloatContext is an interface to support dynamic dispatch.
type ITokFloatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTokFloatContext differentiates from other interfaces.
	IsTokFloatContext()
}

type TokFloatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTokFloatContext() *TokFloatContext {
	var p = new(TokFloatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_tokFloat
	return p
}

func (*TokFloatContext) IsTokFloatContext() {}

func NewTokFloatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TokFloatContext {
	var p = new(TokFloatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_tokFloat

	return p
}

func (s *TokFloatContext) GetParser() antlr.Parser { return s.parser }

func (s *TokFloatContext) TokFloat() antlr.TerminalNode {
	return s.GetToken(ErlangParserTokFloat, 0)
}

func (s *TokFloatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TokFloatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TokFloatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTokFloat(s)
	}
}

func (s *TokFloatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTokFloat(s)
	}
}

func (p *ErlangParser) TokFloat() (localctx ITokFloatContext) {
	this := p
	_ = this

	localctx = NewTokFloatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ErlangParserRULE_tokFloat)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(261)
		p.Match(ErlangParserTokFloat)
	}

	return localctx
}

// ITokIntegerContext is an interface to support dynamic dispatch.
type ITokIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTokIntegerContext differentiates from other interfaces.
	IsTokIntegerContext()
}

type TokIntegerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTokIntegerContext() *TokIntegerContext {
	var p = new(TokIntegerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_tokInteger
	return p
}

func (*TokIntegerContext) IsTokIntegerContext() {}

func NewTokIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TokIntegerContext {
	var p = new(TokIntegerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_tokInteger

	return p
}

func (s *TokIntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *TokIntegerContext) TokInteger() antlr.TerminalNode {
	return s.GetToken(ErlangParserTokInteger, 0)
}

func (s *TokIntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TokIntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TokIntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTokInteger(s)
	}
}

func (s *TokIntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTokInteger(s)
	}
}

func (p *ErlangParser) TokInteger() (localctx ITokIntegerContext) {
	this := p
	_ = this

	localctx = NewTokIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ErlangParserRULE_tokInteger)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(263)
		p.Match(ErlangParserTokInteger)
	}

	return localctx
}

// ITokCharContext is an interface to support dynamic dispatch.
type ITokCharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTokCharContext differentiates from other interfaces.
	IsTokCharContext()
}

type TokCharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTokCharContext() *TokCharContext {
	var p = new(TokCharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_tokChar
	return p
}

func (*TokCharContext) IsTokCharContext() {}

func NewTokCharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TokCharContext {
	var p = new(TokCharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_tokChar

	return p
}

func (s *TokCharContext) GetParser() antlr.Parser { return s.parser }

func (s *TokCharContext) TokChar() antlr.TerminalNode {
	return s.GetToken(ErlangParserTokChar, 0)
}

func (s *TokCharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TokCharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TokCharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTokChar(s)
	}
}

func (s *TokCharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTokChar(s)
	}
}

func (p *ErlangParser) TokChar() (localctx ITokCharContext) {
	this := p
	_ = this

	localctx = NewTokCharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ErlangParserRULE_tokChar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(265)
		p.Match(ErlangParserTokChar)
	}

	return localctx
}

// ITokStringContext is an interface to support dynamic dispatch.
type ITokStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTokStringContext differentiates from other interfaces.
	IsTokStringContext()
}

type TokStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTokStringContext() *TokStringContext {
	var p = new(TokStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_tokString
	return p
}

func (*TokStringContext) IsTokStringContext() {}

func NewTokStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TokStringContext {
	var p = new(TokStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_tokString

	return p
}

func (s *TokStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TokStringContext) TokString() antlr.TerminalNode {
	return s.GetToken(ErlangParserTokString, 0)
}

func (s *TokStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TokStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TokStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTokString(s)
	}
}

func (s *TokStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTokString(s)
	}
}

func (p *ErlangParser) TokString() (localctx ITokStringContext) {
	this := p
	_ = this

	localctx = NewTokStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ErlangParserRULE_tokString)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(267)
		p.Match(ErlangParserTokString)
	}

	return localctx
}

// IAttributeContext is an interface to support dynamic dispatch.
type IAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeContext differentiates from other interfaces.
	IsAttributeContext()
}

type AttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeContext() *AttributeContext {
	var p = new(AttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_attribute
	return p
}

func (*AttributeContext) IsAttributeContext() {}

func NewAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeContext {
	var p = new(AttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_attribute

	return p
}

func (s *AttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeContext) TokAtom() ITokAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokAtomContext)
}

func (s *AttributeContext) AttrVal() IAttrValContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttrValContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttrValContext)
}

func (s *AttributeContext) TypedAttrVal() ITypedAttrValContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedAttrValContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedAttrValContext)
}

func (s *AttributeContext) AttrName() antlr.TerminalNode {
	return s.GetToken(ErlangParserAttrName, 0)
}

func (s *AttributeContext) TypeSpec() ITypeSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeSpecContext)
}

func (s *AttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterAttribute(s)
	}
}

func (s *AttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitAttribute(s)
	}
}

func (p *ErlangParser) Attribute() (localctx IAttributeContext) {
	this := p
	_ = this

	localctx = NewAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ErlangParserRULE_attribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(285)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(269)
			p.Match(ErlangParserT__1)
		}
		{
			p.SetState(270)
			p.TokAtom()
		}
		{
			p.SetState(271)
			p.AttrVal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(273)
			p.Match(ErlangParserT__1)
		}
		{
			p.SetState(274)
			p.TokAtom()
		}
		{
			p.SetState(275)
			p.TypedAttrVal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(277)
			p.Match(ErlangParserT__1)
		}
		{
			p.SetState(278)
			p.TokAtom()
		}
		{
			p.SetState(279)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(280)
			p.TypedAttrVal()
		}
		{
			p.SetState(281)
			p.Match(ErlangParserT__3)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(283)
			p.Match(ErlangParserAttrName)
		}
		{
			p.SetState(284)
			p.TypeSpec()
		}

	}

	return localctx
}

// ITypeSpecContext is an interface to support dynamic dispatch.
type ITypeSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeSpecContext differentiates from other interfaces.
	IsTypeSpecContext()
}

type TypeSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSpecContext() *TypeSpecContext {
	var p = new(TypeSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_typeSpec
	return p
}

func (*TypeSpecContext) IsTypeSpecContext() {}

func NewTypeSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSpecContext {
	var p = new(TypeSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_typeSpec

	return p
}

func (s *TypeSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSpecContext) SpecFun() ISpecFunContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecFunContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecFunContext)
}

func (s *TypeSpecContext) TypeSigs() ITypeSigsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSigsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeSigsContext)
}

func (s *TypeSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTypeSpec(s)
	}
}

func (s *TypeSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTypeSpec(s)
	}
}

func (p *ErlangParser) TypeSpec() (localctx ITypeSpecContext) {
	this := p
	_ = this

	localctx = NewTypeSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ErlangParserRULE_typeSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(295)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserTokAtom:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(287)
			p.SpecFun()
		}
		{
			p.SetState(288)
			p.TypeSigs()
		}

	case ErlangParserT__2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(290)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(291)
			p.SpecFun()
		}
		{
			p.SetState(292)
			p.TypeSigs()
		}
		{
			p.SetState(293)
			p.Match(ErlangParserT__3)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISpecFunContext is an interface to support dynamic dispatch.
type ISpecFunContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecFunContext differentiates from other interfaces.
	IsSpecFunContext()
}

type SpecFunContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecFunContext() *SpecFunContext {
	var p = new(SpecFunContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_specFun
	return p
}

func (*SpecFunContext) IsSpecFunContext() {}

func NewSpecFunContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecFunContext {
	var p = new(SpecFunContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_specFun

	return p
}

func (s *SpecFunContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecFunContext) AllTokAtom() []ITokAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITokAtomContext)(nil)).Elem())
	var tst = make([]ITokAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITokAtomContext)
		}
	}

	return tst
}

func (s *SpecFunContext) TokAtom(i int) ITokAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITokAtomContext)
}

func (s *SpecFunContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecFunContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecFunContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterSpecFun(s)
	}
}

func (s *SpecFunContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitSpecFun(s)
	}
}

func (p *ErlangParser) SpecFun() (localctx ISpecFunContext) {
	this := p
	_ = this

	localctx = NewSpecFunContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ErlangParserRULE_specFun)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(302)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(297)
			p.TokAtom()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(298)
			p.TokAtom()
		}
		{
			p.SetState(299)
			p.Match(ErlangParserT__4)
		}
		{
			p.SetState(300)
			p.TokAtom()
		}

	}

	return localctx
}

// ITypedAttrValContext is an interface to support dynamic dispatch.
type ITypedAttrValContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedAttrValContext differentiates from other interfaces.
	IsTypedAttrValContext()
}

type TypedAttrValContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedAttrValContext() *TypedAttrValContext {
	var p = new(TypedAttrValContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_typedAttrVal
	return p
}

func (*TypedAttrValContext) IsTypedAttrValContext() {}

func NewTypedAttrValContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedAttrValContext {
	var p = new(TypedAttrValContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_typedAttrVal

	return p
}

func (s *TypedAttrValContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedAttrValContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TypedAttrValContext) TypedRecordFields() ITypedRecordFieldsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedRecordFieldsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedRecordFieldsContext)
}

func (s *TypedAttrValContext) TopType() ITopTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopTypeContext)
}

func (s *TypedAttrValContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedAttrValContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedAttrValContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTypedAttrVal(s)
	}
}

func (s *TypedAttrValContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTypedAttrVal(s)
	}
}

func (p *ErlangParser) TypedAttrVal() (localctx ITypedAttrValContext) {
	this := p
	_ = this

	localctx = NewTypedAttrValContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ErlangParserRULE_typedAttrVal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(312)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(304)
			p.Expr()
		}
		{
			p.SetState(305)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(306)
			p.TypedRecordFields()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(308)
			p.Expr()
		}
		{
			p.SetState(309)
			p.Match(ErlangParserT__6)
		}
		{
			p.SetState(310)
			p.TopType()
		}

	}

	return localctx
}

// ITypedRecordFieldsContext is an interface to support dynamic dispatch.
type ITypedRecordFieldsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedRecordFieldsContext differentiates from other interfaces.
	IsTypedRecordFieldsContext()
}

type TypedRecordFieldsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedRecordFieldsContext() *TypedRecordFieldsContext {
	var p = new(TypedRecordFieldsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_typedRecordFields
	return p
}

func (*TypedRecordFieldsContext) IsTypedRecordFieldsContext() {}

func NewTypedRecordFieldsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedRecordFieldsContext {
	var p = new(TypedRecordFieldsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_typedRecordFields

	return p
}

func (s *TypedRecordFieldsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedRecordFieldsContext) TypedExprs() ITypedExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedExprsContext)
}

func (s *TypedRecordFieldsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedRecordFieldsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedRecordFieldsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTypedRecordFields(s)
	}
}

func (s *TypedRecordFieldsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTypedRecordFields(s)
	}
}

func (p *ErlangParser) TypedRecordFields() (localctx ITypedRecordFieldsContext) {
	this := p
	_ = this

	localctx = NewTypedRecordFieldsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ErlangParserRULE_typedRecordFields)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(314)
		p.Match(ErlangParserT__7)
	}
	{
		p.SetState(315)
		p.TypedExprs()
	}
	{
		p.SetState(316)
		p.Match(ErlangParserT__8)
	}

	return localctx
}

// ITypedExprsContext is an interface to support dynamic dispatch.
type ITypedExprsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedExprsContext differentiates from other interfaces.
	IsTypedExprsContext()
}

type TypedExprsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedExprsContext() *TypedExprsContext {
	var p = new(TypedExprsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_typedExprs
	return p
}

func (*TypedExprsContext) IsTypedExprsContext() {}

func NewTypedExprsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedExprsContext {
	var p = new(TypedExprsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_typedExprs

	return p
}

func (s *TypedExprsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedExprsContext) TypedExpr() ITypedExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedExprContext)
}

func (s *TypedExprsContext) TypedExprs() ITypedExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedExprsContext)
}

func (s *TypedExprsContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TypedExprsContext) Exprs() IExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsContext)
}

func (s *TypedExprsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedExprsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedExprsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTypedExprs(s)
	}
}

func (s *TypedExprsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTypedExprs(s)
	}
}

func (p *ErlangParser) TypedExprs() (localctx ITypedExprsContext) {
	this := p
	_ = this

	localctx = NewTypedExprsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ErlangParserRULE_typedExprs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(331)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(318)
			p.TypedExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(319)
			p.TypedExpr()
		}
		{
			p.SetState(320)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(321)
			p.TypedExprs()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(323)
			p.Expr()
		}
		{
			p.SetState(324)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(325)
			p.TypedExprs()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(327)
			p.TypedExpr()
		}
		{
			p.SetState(328)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(329)
			p.Exprs()
		}

	}

	return localctx
}

// ITypedExprContext is an interface to support dynamic dispatch.
type ITypedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedExprContext differentiates from other interfaces.
	IsTypedExprContext()
}

type TypedExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedExprContext() *TypedExprContext {
	var p = new(TypedExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_typedExpr
	return p
}

func (*TypedExprContext) IsTypedExprContext() {}

func NewTypedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedExprContext {
	var p = new(TypedExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_typedExpr

	return p
}

func (s *TypedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TypedExprContext) TopType() ITopTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopTypeContext)
}

func (s *TypedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTypedExpr(s)
	}
}

func (s *TypedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTypedExpr(s)
	}
}

func (p *ErlangParser) TypedExpr() (localctx ITypedExprContext) {
	this := p
	_ = this

	localctx = NewTypedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ErlangParserRULE_typedExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(333)
		p.Expr()
	}
	{
		p.SetState(334)
		p.Match(ErlangParserT__6)
	}
	{
		p.SetState(335)
		p.TopType()
	}

	return localctx
}

// ITypeSigsContext is an interface to support dynamic dispatch.
type ITypeSigsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeSigsContext differentiates from other interfaces.
	IsTypeSigsContext()
}

type TypeSigsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSigsContext() *TypeSigsContext {
	var p = new(TypeSigsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_typeSigs
	return p
}

func (*TypeSigsContext) IsTypeSigsContext() {}

func NewTypeSigsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSigsContext {
	var p = new(TypeSigsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_typeSigs

	return p
}

func (s *TypeSigsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSigsContext) AllTypeSig() []ITypeSigContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeSigContext)(nil)).Elem())
	var tst = make([]ITypeSigContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeSigContext)
		}
	}

	return tst
}

func (s *TypeSigsContext) TypeSig(i int) ITypeSigContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSigContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeSigContext)
}

func (s *TypeSigsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSigsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSigsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTypeSigs(s)
	}
}

func (s *TypeSigsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTypeSigs(s)
	}
}

func (p *ErlangParser) TypeSigs() (localctx ITypeSigsContext) {
	this := p
	_ = this

	localctx = NewTypeSigsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ErlangParserRULE_typeSigs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(337)
		p.TypeSig()
	}
	p.SetState(342)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__9 {
		{
			p.SetState(338)
			p.Match(ErlangParserT__9)
		}
		{
			p.SetState(339)
			p.TypeSig()
		}

		p.SetState(344)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeSigContext is an interface to support dynamic dispatch.
type ITypeSigContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeSigContext differentiates from other interfaces.
	IsTypeSigContext()
}

type TypeSigContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSigContext() *TypeSigContext {
	var p = new(TypeSigContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_typeSig
	return p
}

func (*TypeSigContext) IsTypeSigContext() {}

func NewTypeSigContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSigContext {
	var p = new(TypeSigContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_typeSig

	return p
}

func (s *TypeSigContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSigContext) FunType() IFunTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunTypeContext)
}

func (s *TypeSigContext) TypeGuards() ITypeGuardsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeGuardsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeGuardsContext)
}

func (s *TypeSigContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSigContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSigContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTypeSig(s)
	}
}

func (s *TypeSigContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTypeSig(s)
	}
}

func (p *ErlangParser) TypeSig() (localctx ITypeSigContext) {
	this := p
	_ = this

	localctx = NewTypeSigContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ErlangParserRULE_typeSig)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(345)
		p.FunType()
	}
	p.SetState(348)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserT__10 {
		{
			p.SetState(346)
			p.Match(ErlangParserT__10)
		}
		{
			p.SetState(347)
			p.TypeGuards()
		}

	}

	return localctx
}

// ITypeGuardsContext is an interface to support dynamic dispatch.
type ITypeGuardsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeGuardsContext differentiates from other interfaces.
	IsTypeGuardsContext()
}

type TypeGuardsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeGuardsContext() *TypeGuardsContext {
	var p = new(TypeGuardsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_typeGuards
	return p
}

func (*TypeGuardsContext) IsTypeGuardsContext() {}

func NewTypeGuardsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeGuardsContext {
	var p = new(TypeGuardsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_typeGuards

	return p
}

func (s *TypeGuardsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeGuardsContext) AllTypeGuard() []ITypeGuardContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeGuardContext)(nil)).Elem())
	var tst = make([]ITypeGuardContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeGuardContext)
		}
	}

	return tst
}

func (s *TypeGuardsContext) TypeGuard(i int) ITypeGuardContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeGuardContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeGuardContext)
}

func (s *TypeGuardsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeGuardsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeGuardsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTypeGuards(s)
	}
}

func (s *TypeGuardsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTypeGuards(s)
	}
}

func (p *ErlangParser) TypeGuards() (localctx ITypeGuardsContext) {
	this := p
	_ = this

	localctx = NewTypeGuardsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ErlangParserRULE_typeGuards)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(350)
		p.TypeGuard()
	}
	p.SetState(355)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__5 {
		{
			p.SetState(351)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(352)
			p.TypeGuard()
		}

		p.SetState(357)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeGuardContext is an interface to support dynamic dispatch.
type ITypeGuardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeGuardContext differentiates from other interfaces.
	IsTypeGuardContext()
}

type TypeGuardContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeGuardContext() *TypeGuardContext {
	var p = new(TypeGuardContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_typeGuard
	return p
}

func (*TypeGuardContext) IsTypeGuardContext() {}

func NewTypeGuardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeGuardContext {
	var p = new(TypeGuardContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_typeGuard

	return p
}

func (s *TypeGuardContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeGuardContext) TokAtom() ITokAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokAtomContext)
}

func (s *TypeGuardContext) TopTypes() ITopTypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopTypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopTypesContext)
}

func (s *TypeGuardContext) TokVar() ITokVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokVarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokVarContext)
}

func (s *TypeGuardContext) TopType() ITopTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopTypeContext)
}

func (s *TypeGuardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeGuardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeGuardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTypeGuard(s)
	}
}

func (s *TypeGuardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTypeGuard(s)
	}
}

func (p *ErlangParser) TypeGuard() (localctx ITypeGuardContext) {
	this := p
	_ = this

	localctx = NewTypeGuardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ErlangParserRULE_typeGuard)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(367)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserTokAtom:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(358)
			p.TokAtom()
		}
		{
			p.SetState(359)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(360)
			p.TopTypes()
		}
		{
			p.SetState(361)
			p.Match(ErlangParserT__3)
		}

	case ErlangParserTokVar:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(363)
			p.TokVar()
		}
		{
			p.SetState(364)
			p.Match(ErlangParserT__6)
		}
		{
			p.SetState(365)
			p.TopType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITopTypesContext is an interface to support dynamic dispatch.
type ITopTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopTypesContext differentiates from other interfaces.
	IsTopTypesContext()
}

type TopTypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopTypesContext() *TopTypesContext {
	var p = new(TopTypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_topTypes
	return p
}

func (*TopTypesContext) IsTopTypesContext() {}

func NewTopTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopTypesContext {
	var p = new(TopTypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_topTypes

	return p
}

func (s *TopTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *TopTypesContext) AllTopType() []ITopTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITopTypeContext)(nil)).Elem())
	var tst = make([]ITopTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITopTypeContext)
		}
	}

	return tst
}

func (s *TopTypesContext) TopType(i int) ITopTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITopTypeContext)
}

func (s *TopTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTopTypes(s)
	}
}

func (s *TopTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTopTypes(s)
	}
}

func (p *ErlangParser) TopTypes() (localctx ITopTypesContext) {
	this := p
	_ = this

	localctx = NewTopTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ErlangParserRULE_topTypes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(369)
		p.TopType()
	}
	p.SetState(374)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__5 {
		{
			p.SetState(370)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(371)
			p.TopType()
		}

		p.SetState(376)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITopTypeContext is an interface to support dynamic dispatch.
type ITopTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopTypeContext differentiates from other interfaces.
	IsTopTypeContext()
}

type TopTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopTypeContext() *TopTypeContext {
	var p = new(TopTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_topType
	return p
}

func (*TopTypeContext) IsTopTypeContext() {}

func NewTopTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopTypeContext {
	var p = new(TopTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_topType

	return p
}

func (s *TopTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TopTypeContext) TopType100() ITopType100Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopType100Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopType100Context)
}

func (s *TopTypeContext) TokVar() ITokVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokVarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokVarContext)
}

func (s *TopTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTopType(s)
	}
}

func (s *TopTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTopType(s)
	}
}

func (p *ErlangParser) TopType() (localctx ITopTypeContext) {
	this := p
	_ = this

	localctx = NewTopTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ErlangParserRULE_topType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(380)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(377)
			p.TokVar()
		}
		{
			p.SetState(378)
			p.Match(ErlangParserT__6)
		}

	}
	{
		p.SetState(382)
		p.TopType100()
	}

	return localctx
}

// ITopType100Context is an interface to support dynamic dispatch.
type ITopType100Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopType100Context differentiates from other interfaces.
	IsTopType100Context()
}

type TopType100Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopType100Context() *TopType100Context {
	var p = new(TopType100Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_topType100
	return p
}

func (*TopType100Context) IsTopType100Context() {}

func NewTopType100Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopType100Context {
	var p = new(TopType100Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_topType100

	return p
}

func (s *TopType100Context) GetParser() antlr.Parser { return s.parser }

func (s *TopType100Context) Type200() IType200Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType200Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType200Context)
}

func (s *TopType100Context) TopType100() ITopType100Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopType100Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopType100Context)
}

func (s *TopType100Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopType100Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopType100Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTopType100(s)
	}
}

func (s *TopType100Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTopType100(s)
	}
}

func (p *ErlangParser) TopType100() (localctx ITopType100Context) {
	this := p
	_ = this

	localctx = NewTopType100Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ErlangParserRULE_topType100)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(384)
		p.Type200()
	}
	p.SetState(387)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserT__11 {
		{
			p.SetState(385)
			p.Match(ErlangParserT__11)
		}
		{
			p.SetState(386)
			p.TopType100()
		}

	}

	return localctx
}

// IType200Context is an interface to support dynamic dispatch.
type IType200Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType200Context differentiates from other interfaces.
	IsType200Context()
}

type Type200Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType200Context() *Type200Context {
	var p = new(Type200Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_type200
	return p
}

func (*Type200Context) IsType200Context() {}

func NewType200Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type200Context {
	var p = new(Type200Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_type200

	return p
}

func (s *Type200Context) GetParser() antlr.Parser { return s.parser }

func (s *Type200Context) AllType300() []IType300Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType300Context)(nil)).Elem())
	var tst = make([]IType300Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType300Context)
		}
	}

	return tst
}

func (s *Type200Context) Type300(i int) IType300Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType300Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType300Context)
}

func (s *Type200Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type200Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type200Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterType200(s)
	}
}

func (s *Type200Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitType200(s)
	}
}

func (p *ErlangParser) Type200() (localctx IType200Context) {
	this := p
	_ = this

	localctx = NewType200Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ErlangParserRULE_type200)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.type300(0)
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserT__12 {
		{
			p.SetState(390)
			p.Match(ErlangParserT__12)
		}
		{
			p.SetState(391)
			p.type300(0)
		}

	}

	return localctx
}

// IType300Context is an interface to support dynamic dispatch.
type IType300Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType300Context differentiates from other interfaces.
	IsType300Context()
}

type Type300Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType300Context() *Type300Context {
	var p = new(Type300Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_type300
	return p
}

func (*Type300Context) IsType300Context() {}

func NewType300Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type300Context {
	var p = new(Type300Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_type300

	return p
}

func (s *Type300Context) GetParser() antlr.Parser { return s.parser }

func (s *Type300Context) Type400() IType400Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType400Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType400Context)
}

func (s *Type300Context) Type300() IType300Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType300Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType300Context)
}

func (s *Type300Context) AddOp() IAddOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddOpContext)
}

func (s *Type300Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type300Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type300Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterType300(s)
	}
}

func (s *Type300Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitType300(s)
	}
}

func (p *ErlangParser) Type300() (localctx IType300Context) {
	return p.type300(0)
}

func (p *ErlangParser) type300(_p int) (localctx IType300Context) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewType300Context(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IType300Context = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 46
	p.EnterRecursionRule(localctx, 46, ErlangParserRULE_type300, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(395)
		p.type400(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(403)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewType300Context(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ErlangParserRULE_type300)
			p.SetState(397)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(398)
				p.AddOp()
			}
			{
				p.SetState(399)
				p.type400(0)
			}

		}
		p.SetState(405)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())
	}

	return localctx
}

// IType400Context is an interface to support dynamic dispatch.
type IType400Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType400Context differentiates from other interfaces.
	IsType400Context()
}

type Type400Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType400Context() *Type400Context {
	var p = new(Type400Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_type400
	return p
}

func (*Type400Context) IsType400Context() {}

func NewType400Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type400Context {
	var p = new(Type400Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_type400

	return p
}

func (s *Type400Context) GetParser() antlr.Parser { return s.parser }

func (s *Type400Context) Type500() IType500Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType500Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType500Context)
}

func (s *Type400Context) Type400() IType400Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType400Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType400Context)
}

func (s *Type400Context) MultOp() IMultOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultOpContext)
}

func (s *Type400Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type400Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type400Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterType400(s)
	}
}

func (s *Type400Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitType400(s)
	}
}

func (p *ErlangParser) Type400() (localctx IType400Context) {
	return p.type400(0)
}

func (p *ErlangParser) type400(_p int) (localctx IType400Context) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewType400Context(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IType400Context = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 48
	p.EnterRecursionRule(localctx, 48, ErlangParserRULE_type400, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(407)
		p.Type500()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(415)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewType400Context(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ErlangParserRULE_type400)
			p.SetState(409)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(410)
				p.MultOp()
			}
			{
				p.SetState(411)
				p.Type500()
			}

		}
		p.SetState(417)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
	}

	return localctx
}

// IType500Context is an interface to support dynamic dispatch.
type IType500Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType500Context differentiates from other interfaces.
	IsType500Context()
}

type Type500Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType500Context() *Type500Context {
	var p = new(Type500Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_type500
	return p
}

func (*Type500Context) IsType500Context() {}

func NewType500Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type500Context {
	var p = new(Type500Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_type500

	return p
}

func (s *Type500Context) GetParser() antlr.Parser { return s.parser }

func (s *Type500Context) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *Type500Context) PrefixOp() IPrefixOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefixOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefixOpContext)
}

func (s *Type500Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type500Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type500Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterType500(s)
	}
}

func (s *Type500Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitType500(s)
	}
}

func (p *ErlangParser) Type500() (localctx IType500Context) {
	this := p
	_ = this

	localctx = NewType500Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ErlangParserRULE_type500)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserT__1 || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(ErlangParserT__41-42))|(1<<(ErlangParserT__42-42))|(1<<(ErlangParserT__43-42)))) != 0) {
		{
			p.SetState(418)
			p.PrefixOp()
		}

	}
	{
		p.SetState(421)
		p.Type_()
	}

	return localctx
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_type_
	return p
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) TopType() ITopTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopTypeContext)
}

func (s *Type_Context) TokVar() ITokVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokVarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokVarContext)
}

func (s *Type_Context) AllTokAtom() []ITokAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITokAtomContext)(nil)).Elem())
	var tst = make([]ITokAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITokAtomContext)
		}
	}

	return tst
}

func (s *Type_Context) TokAtom(i int) ITokAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITokAtomContext)
}

func (s *Type_Context) TopTypes() ITopTypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopTypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopTypesContext)
}

func (s *Type_Context) MapPairTypes() IMapPairTypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapPairTypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapPairTypesContext)
}

func (s *Type_Context) FieldTypes() IFieldTypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldTypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldTypesContext)
}

func (s *Type_Context) BinaryType() IBinaryTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinaryTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinaryTypeContext)
}

func (s *Type_Context) TokInteger() ITokIntegerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokIntegerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokIntegerContext)
}

func (s *Type_Context) TokChar() ITokCharContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokCharContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokCharContext)
}

func (s *Type_Context) FunType100() IFunType100Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunType100Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunType100Context)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitType_(s)
	}
}

func (p *ErlangParser) Type_() (localctx IType_Context) {
	this := p
	_ = this

	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ErlangParserRULE_type_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(499)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(423)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(424)
			p.TopType()
		}
		{
			p.SetState(425)
			p.Match(ErlangParserT__3)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(427)
			p.TokVar()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(428)
			p.TokAtom()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(429)
			p.TokAtom()
		}
		{
			p.SetState(430)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(431)
			p.Match(ErlangParserT__3)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(433)
			p.TokAtom()
		}
		{
			p.SetState(434)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(435)
			p.TopTypes()
		}
		{
			p.SetState(436)
			p.Match(ErlangParserT__3)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(438)
			p.TokAtom()
		}
		{
			p.SetState(439)
			p.Match(ErlangParserT__4)
		}
		{
			p.SetState(440)
			p.TokAtom()
		}
		{
			p.SetState(441)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(442)
			p.Match(ErlangParserT__3)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(444)
			p.TokAtom()
		}
		{
			p.SetState(445)
			p.Match(ErlangParserT__4)
		}
		{
			p.SetState(446)
			p.TokAtom()
		}
		{
			p.SetState(447)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(448)
			p.TopTypes()
		}
		{
			p.SetState(449)
			p.Match(ErlangParserT__3)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(451)
			p.Match(ErlangParserT__13)
		}
		{
			p.SetState(452)
			p.Match(ErlangParserT__14)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(453)
			p.Match(ErlangParserT__13)
		}
		{
			p.SetState(454)
			p.TopType()
		}
		{
			p.SetState(455)
			p.Match(ErlangParserT__14)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(457)
			p.Match(ErlangParserT__13)
		}
		{
			p.SetState(458)
			p.TopType()
		}
		{
			p.SetState(459)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(460)
			p.Match(ErlangParserT__15)
		}
		{
			p.SetState(461)
			p.Match(ErlangParserT__14)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(463)
			p.Match(ErlangParserT__16)
		}
		{
			p.SetState(464)
			p.Match(ErlangParserT__7)
		}
		{
			p.SetState(465)
			p.Match(ErlangParserT__8)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(466)
			p.Match(ErlangParserT__16)
		}
		{
			p.SetState(467)
			p.Match(ErlangParserT__7)
		}
		{
			p.SetState(468)
			p.MapPairTypes()
		}
		{
			p.SetState(469)
			p.Match(ErlangParserT__8)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(471)
			p.Match(ErlangParserT__7)
		}
		{
			p.SetState(472)
			p.Match(ErlangParserT__8)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(473)
			p.Match(ErlangParserT__7)
		}
		{
			p.SetState(474)
			p.TopTypes()
		}
		{
			p.SetState(475)
			p.Match(ErlangParserT__8)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(477)
			p.Match(ErlangParserT__16)
		}
		{
			p.SetState(478)
			p.TokAtom()
		}
		{
			p.SetState(479)
			p.Match(ErlangParserT__7)
		}
		{
			p.SetState(480)
			p.Match(ErlangParserT__8)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(482)
			p.Match(ErlangParserT__16)
		}
		{
			p.SetState(483)
			p.TokAtom()
		}
		{
			p.SetState(484)
			p.Match(ErlangParserT__7)
		}
		{
			p.SetState(485)
			p.FieldTypes()
		}
		{
			p.SetState(486)
			p.Match(ErlangParserT__8)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(488)
			p.BinaryType()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(489)
			p.TokInteger()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(490)
			p.TokChar()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(491)
			p.Match(ErlangParserT__17)
		}
		{
			p.SetState(492)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(493)
			p.Match(ErlangParserT__3)
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(494)
			p.Match(ErlangParserT__17)
		}
		{
			p.SetState(495)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(496)
			p.FunType100()
		}
		{
			p.SetState(497)
			p.Match(ErlangParserT__3)
		}

	}

	return localctx
}

// IFunType100Context is an interface to support dynamic dispatch.
type IFunType100Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunType100Context differentiates from other interfaces.
	IsFunType100Context()
}

type FunType100Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunType100Context() *FunType100Context {
	var p = new(FunType100Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_funType100
	return p
}

func (*FunType100Context) IsFunType100Context() {}

func NewFunType100Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunType100Context {
	var p = new(FunType100Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_funType100

	return p
}

func (s *FunType100Context) GetParser() antlr.Parser { return s.parser }

func (s *FunType100Context) TopType() ITopTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopTypeContext)
}

func (s *FunType100Context) FunType() IFunTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunTypeContext)
}

func (s *FunType100Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunType100Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunType100Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterFunType100(s)
	}
}

func (s *FunType100Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitFunType100(s)
	}
}

func (p *ErlangParser) FunType100() (localctx IFunType100Context) {
	this := p
	_ = this

	localctx = NewFunType100Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ErlangParserRULE_funType100)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(501)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(502)
			p.Match(ErlangParserT__15)
		}
		{
			p.SetState(503)
			p.Match(ErlangParserT__3)
		}
		{
			p.SetState(504)
			p.Match(ErlangParserT__18)
		}
		{
			p.SetState(505)
			p.TopType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(506)
			p.FunType()
		}

	}

	return localctx
}

// IFunTypeContext is an interface to support dynamic dispatch.
type IFunTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunTypeContext differentiates from other interfaces.
	IsFunTypeContext()
}

type FunTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunTypeContext() *FunTypeContext {
	var p = new(FunTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_funType
	return p
}

func (*FunTypeContext) IsFunTypeContext() {}

func NewFunTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunTypeContext {
	var p = new(FunTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_funType

	return p
}

func (s *FunTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunTypeContext) TopType() ITopTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopTypeContext)
}

func (s *FunTypeContext) TopTypes() ITopTypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopTypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopTypesContext)
}

func (s *FunTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterFunType(s)
	}
}

func (s *FunTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitFunType(s)
	}
}

func (p *ErlangParser) FunType() (localctx IFunTypeContext) {
	this := p
	_ = this

	localctx = NewFunTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ErlangParserRULE_funType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(509)
		p.Match(ErlangParserT__2)
	}
	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ErlangParserT__1)|(1<<ErlangParserT__2)|(1<<ErlangParserT__7)|(1<<ErlangParserT__13)|(1<<ErlangParserT__16)|(1<<ErlangParserT__17)|(1<<ErlangParserT__21))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(ErlangParserT__41-42))|(1<<(ErlangParserT__42-42))|(1<<(ErlangParserT__43-42))|(1<<(ErlangParserTokAtom-42))|(1<<(ErlangParserTokVar-42))|(1<<(ErlangParserTokInteger-42))|(1<<(ErlangParserTokChar-42)))) != 0) {
		{
			p.SetState(510)
			p.TopTypes()
		}

	}
	{
		p.SetState(513)
		p.Match(ErlangParserT__3)
	}
	{
		p.SetState(514)
		p.Match(ErlangParserT__18)
	}
	{
		p.SetState(515)
		p.TopType()
	}

	return localctx
}

// IMapPairTypesContext is an interface to support dynamic dispatch.
type IMapPairTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapPairTypesContext differentiates from other interfaces.
	IsMapPairTypesContext()
}

type MapPairTypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapPairTypesContext() *MapPairTypesContext {
	var p = new(MapPairTypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_mapPairTypes
	return p
}

func (*MapPairTypesContext) IsMapPairTypesContext() {}

func NewMapPairTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapPairTypesContext {
	var p = new(MapPairTypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_mapPairTypes

	return p
}

func (s *MapPairTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *MapPairTypesContext) AllMapPairType() []IMapPairTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMapPairTypeContext)(nil)).Elem())
	var tst = make([]IMapPairTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMapPairTypeContext)
		}
	}

	return tst
}

func (s *MapPairTypesContext) MapPairType(i int) IMapPairTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapPairTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMapPairTypeContext)
}

func (s *MapPairTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapPairTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapPairTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterMapPairTypes(s)
	}
}

func (s *MapPairTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitMapPairTypes(s)
	}
}

func (p *ErlangParser) MapPairTypes() (localctx IMapPairTypesContext) {
	this := p
	_ = this

	localctx = NewMapPairTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ErlangParserRULE_mapPairTypes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(517)
		p.MapPairType()
	}
	p.SetState(522)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__5 {
		{
			p.SetState(518)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(519)
			p.MapPairType()
		}

		p.SetState(524)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMapPairTypeContext is an interface to support dynamic dispatch.
type IMapPairTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapPairTypeContext differentiates from other interfaces.
	IsMapPairTypeContext()
}

type MapPairTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapPairTypeContext() *MapPairTypeContext {
	var p = new(MapPairTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_mapPairType
	return p
}

func (*MapPairTypeContext) IsMapPairTypeContext() {}

func NewMapPairTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapPairTypeContext {
	var p = new(MapPairTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_mapPairType

	return p
}

func (s *MapPairTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MapPairTypeContext) AllTopType() []ITopTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITopTypeContext)(nil)).Elem())
	var tst = make([]ITopTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITopTypeContext)
		}
	}

	return tst
}

func (s *MapPairTypeContext) TopType(i int) ITopTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITopTypeContext)
}

func (s *MapPairTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapPairTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapPairTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterMapPairType(s)
	}
}

func (s *MapPairTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitMapPairType(s)
	}
}

func (p *ErlangParser) MapPairType() (localctx IMapPairTypeContext) {
	this := p
	_ = this

	localctx = NewMapPairTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ErlangParserRULE_mapPairType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(525)
		p.TopType()
	}
	{
		p.SetState(526)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ErlangParserT__19 || _la == ErlangParserT__20) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(527)
		p.TopType()
	}

	return localctx
}

// IFieldTypesContext is an interface to support dynamic dispatch.
type IFieldTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldTypesContext differentiates from other interfaces.
	IsFieldTypesContext()
}

type FieldTypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldTypesContext() *FieldTypesContext {
	var p = new(FieldTypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_fieldTypes
	return p
}

func (*FieldTypesContext) IsFieldTypesContext() {}

func NewFieldTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldTypesContext {
	var p = new(FieldTypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_fieldTypes

	return p
}

func (s *FieldTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldTypesContext) AllFieldType() []IFieldTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldTypeContext)(nil)).Elem())
	var tst = make([]IFieldTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldTypeContext)
		}
	}

	return tst
}

func (s *FieldTypesContext) FieldType(i int) IFieldTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldTypeContext)
}

func (s *FieldTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterFieldTypes(s)
	}
}

func (s *FieldTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitFieldTypes(s)
	}
}

func (p *ErlangParser) FieldTypes() (localctx IFieldTypesContext) {
	this := p
	_ = this

	localctx = NewFieldTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ErlangParserRULE_fieldTypes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(529)
		p.FieldType()
	}
	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__5 {
		{
			p.SetState(530)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(531)
			p.FieldType()
		}

		p.SetState(536)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFieldTypeContext is an interface to support dynamic dispatch.
type IFieldTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldTypeContext differentiates from other interfaces.
	IsFieldTypeContext()
}

type FieldTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldTypeContext() *FieldTypeContext {
	var p = new(FieldTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_fieldType
	return p
}

func (*FieldTypeContext) IsFieldTypeContext() {}

func NewFieldTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldTypeContext {
	var p = new(FieldTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_fieldType

	return p
}

func (s *FieldTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldTypeContext) TokAtom() ITokAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokAtomContext)
}

func (s *FieldTypeContext) TopType() ITopTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopTypeContext)
}

func (s *FieldTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterFieldType(s)
	}
}

func (s *FieldTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitFieldType(s)
	}
}

func (p *ErlangParser) FieldType() (localctx IFieldTypeContext) {
	this := p
	_ = this

	localctx = NewFieldTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ErlangParserRULE_fieldType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(537)
		p.TokAtom()
	}
	{
		p.SetState(538)
		p.Match(ErlangParserT__6)
	}
	{
		p.SetState(539)
		p.TopType()
	}

	return localctx
}

// IBinaryTypeContext is an interface to support dynamic dispatch.
type IBinaryTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinaryTypeContext differentiates from other interfaces.
	IsBinaryTypeContext()
}

type BinaryTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryTypeContext() *BinaryTypeContext {
	var p = new(BinaryTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_binaryType
	return p
}

func (*BinaryTypeContext) IsBinaryTypeContext() {}

func NewBinaryTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryTypeContext {
	var p = new(BinaryTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_binaryType

	return p
}

func (s *BinaryTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryTypeContext) BinBaseType() IBinBaseTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinBaseTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinBaseTypeContext)
}

func (s *BinaryTypeContext) BinUnitType() IBinUnitTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinUnitTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinUnitTypeContext)
}

func (s *BinaryTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterBinaryType(s)
	}
}

func (s *BinaryTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitBinaryType(s)
	}
}

func (p *ErlangParser) BinaryType() (localctx IBinaryTypeContext) {
	this := p
	_ = this

	localctx = NewBinaryTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ErlangParserRULE_binaryType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(557)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(541)
			p.Match(ErlangParserT__21)
		}
		{
			p.SetState(542)
			p.Match(ErlangParserT__22)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(543)
			p.Match(ErlangParserT__21)
		}
		{
			p.SetState(544)
			p.BinBaseType()
		}
		{
			p.SetState(545)
			p.Match(ErlangParserT__22)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(547)
			p.Match(ErlangParserT__21)
		}
		{
			p.SetState(548)
			p.BinUnitType()
		}
		{
			p.SetState(549)
			p.Match(ErlangParserT__22)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(551)
			p.Match(ErlangParserT__21)
		}
		{
			p.SetState(552)
			p.BinBaseType()
		}
		{
			p.SetState(553)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(554)
			p.BinUnitType()
		}
		{
			p.SetState(555)
			p.Match(ErlangParserT__22)
		}

	}

	return localctx
}

// IBinBaseTypeContext is an interface to support dynamic dispatch.
type IBinBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinBaseTypeContext differentiates from other interfaces.
	IsBinBaseTypeContext()
}

type BinBaseTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinBaseTypeContext() *BinBaseTypeContext {
	var p = new(BinBaseTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_binBaseType
	return p
}

func (*BinBaseTypeContext) IsBinBaseTypeContext() {}

func NewBinBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinBaseTypeContext {
	var p = new(BinBaseTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_binBaseType

	return p
}

func (s *BinBaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BinBaseTypeContext) TokVar() ITokVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokVarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokVarContext)
}

func (s *BinBaseTypeContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *BinBaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinBaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinBaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterBinBaseType(s)
	}
}

func (s *BinBaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitBinBaseType(s)
	}
}

func (p *ErlangParser) BinBaseType() (localctx IBinBaseTypeContext) {
	this := p
	_ = this

	localctx = NewBinBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ErlangParserRULE_binBaseType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.TokVar()
	}
	{
		p.SetState(560)
		p.Match(ErlangParserT__4)
	}
	{
		p.SetState(561)
		p.Type_()
	}

	return localctx
}

// IBinUnitTypeContext is an interface to support dynamic dispatch.
type IBinUnitTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinUnitTypeContext differentiates from other interfaces.
	IsBinUnitTypeContext()
}

type BinUnitTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinUnitTypeContext() *BinUnitTypeContext {
	var p = new(BinUnitTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_binUnitType
	return p
}

func (*BinUnitTypeContext) IsBinUnitTypeContext() {}

func NewBinUnitTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinUnitTypeContext {
	var p = new(BinUnitTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_binUnitType

	return p
}

func (s *BinUnitTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BinUnitTypeContext) AllTokVar() []ITokVarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITokVarContext)(nil)).Elem())
	var tst = make([]ITokVarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITokVarContext)
		}
	}

	return tst
}

func (s *BinUnitTypeContext) TokVar(i int) ITokVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokVarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITokVarContext)
}

func (s *BinUnitTypeContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *BinUnitTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinUnitTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinUnitTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterBinUnitType(s)
	}
}

func (s *BinUnitTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitBinUnitType(s)
	}
}

func (p *ErlangParser) BinUnitType() (localctx IBinUnitTypeContext) {
	this := p
	_ = this

	localctx = NewBinUnitTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ErlangParserRULE_binUnitType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(563)
		p.TokVar()
	}
	{
		p.SetState(564)
		p.Match(ErlangParserT__4)
	}
	{
		p.SetState(565)
		p.TokVar()
	}
	{
		p.SetState(566)
		p.Match(ErlangParserT__23)
	}
	{
		p.SetState(567)
		p.Type_()
	}

	return localctx
}

// IAttrValContext is an interface to support dynamic dispatch.
type IAttrValContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttrValContext differentiates from other interfaces.
	IsAttrValContext()
}

type AttrValContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttrValContext() *AttrValContext {
	var p = new(AttrValContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_attrVal
	return p
}

func (*AttrValContext) IsAttrValContext() {}

func NewAttrValContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttrValContext {
	var p = new(AttrValContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_attrVal

	return p
}

func (s *AttrValContext) GetParser() antlr.Parser { return s.parser }

func (s *AttrValContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AttrValContext) Exprs() IExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsContext)
}

func (s *AttrValContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttrValContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttrValContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterAttrVal(s)
	}
}

func (s *AttrValContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitAttrVal(s)
	}
}

func (p *ErlangParser) AttrVal() (localctx IAttrValContext) {
	this := p
	_ = this

	localctx = NewAttrValContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ErlangParserRULE_attrVal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(584)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(569)
			p.Expr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(570)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(571)
			p.Expr()
		}
		{
			p.SetState(572)
			p.Match(ErlangParserT__3)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(574)
			p.Expr()
		}
		{
			p.SetState(575)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(576)
			p.Exprs()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(578)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(579)
			p.Expr()
		}
		{
			p.SetState(580)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(581)
			p.Exprs()
		}
		{
			p.SetState(582)
			p.Match(ErlangParserT__3)
		}

	}

	return localctx
}

// IFunction_Context is an interface to support dynamic dispatch.
type IFunction_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_Context differentiates from other interfaces.
	IsFunction_Context()
}

type Function_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_Context() *Function_Context {
	var p = new(Function_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_function_
	return p
}

func (*Function_Context) IsFunction_Context() {}

func NewFunction_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_Context {
	var p = new(Function_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_function_

	return p
}

func (s *Function_Context) GetParser() antlr.Parser { return s.parser }

func (s *Function_Context) AllFunctionClause() []IFunctionClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionClauseContext)(nil)).Elem())
	var tst = make([]IFunctionClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionClauseContext)
		}
	}

	return tst
}

func (s *Function_Context) FunctionClause(i int) IFunctionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionClauseContext)
}

func (s *Function_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterFunction_(s)
	}
}

func (s *Function_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitFunction_(s)
	}
}

func (p *ErlangParser) Function_() (localctx IFunction_Context) {
	this := p
	_ = this

	localctx = NewFunction_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ErlangParserRULE_function_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(586)
		p.FunctionClause()
	}
	p.SetState(591)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__9 {
		{
			p.SetState(587)
			p.Match(ErlangParserT__9)
		}
		{
			p.SetState(588)
			p.FunctionClause()
		}

		p.SetState(593)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFunctionClauseContext is an interface to support dynamic dispatch.
type IFunctionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionClauseContext differentiates from other interfaces.
	IsFunctionClauseContext()
}

type FunctionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionClauseContext() *FunctionClauseContext {
	var p = new(FunctionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_functionClause
	return p
}

func (*FunctionClauseContext) IsFunctionClauseContext() {}

func NewFunctionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionClauseContext {
	var p = new(FunctionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_functionClause

	return p
}

func (s *FunctionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionClauseContext) TokAtom() ITokAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokAtomContext)
}

func (s *FunctionClauseContext) ClauseArgs() IClauseArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClauseArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClauseArgsContext)
}

func (s *FunctionClauseContext) ClauseGuard() IClauseGuardContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClauseGuardContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClauseGuardContext)
}

func (s *FunctionClauseContext) ClauseBody() IClauseBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClauseBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClauseBodyContext)
}

func (s *FunctionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterFunctionClause(s)
	}
}

func (s *FunctionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitFunctionClause(s)
	}
}

func (p *ErlangParser) FunctionClause() (localctx IFunctionClauseContext) {
	this := p
	_ = this

	localctx = NewFunctionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ErlangParserRULE_functionClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(594)
		p.TokAtom()
	}
	{
		p.SetState(595)
		p.ClauseArgs()
	}
	{
		p.SetState(596)
		p.ClauseGuard()
	}
	{
		p.SetState(597)
		p.ClauseBody()
	}

	return localctx
}

// IClauseArgsContext is an interface to support dynamic dispatch.
type IClauseArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClauseArgsContext differentiates from other interfaces.
	IsClauseArgsContext()
}

type ClauseArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClauseArgsContext() *ClauseArgsContext {
	var p = new(ClauseArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_clauseArgs
	return p
}

func (*ClauseArgsContext) IsClauseArgsContext() {}

func NewClauseArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClauseArgsContext {
	var p = new(ClauseArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_clauseArgs

	return p
}

func (s *ClauseArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *ClauseArgsContext) PatArgumentList() IPatArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatArgumentListContext)
}

func (s *ClauseArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClauseArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClauseArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterClauseArgs(s)
	}
}

func (s *ClauseArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitClauseArgs(s)
	}
}

func (p *ErlangParser) ClauseArgs() (localctx IClauseArgsContext) {
	this := p
	_ = this

	localctx = NewClauseArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ErlangParserRULE_clauseArgs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(599)
		p.PatArgumentList()
	}

	return localctx
}

// IClauseGuardContext is an interface to support dynamic dispatch.
type IClauseGuardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClauseGuardContext differentiates from other interfaces.
	IsClauseGuardContext()
}

type ClauseGuardContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClauseGuardContext() *ClauseGuardContext {
	var p = new(ClauseGuardContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_clauseGuard
	return p
}

func (*ClauseGuardContext) IsClauseGuardContext() {}

func NewClauseGuardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClauseGuardContext {
	var p = new(ClauseGuardContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_clauseGuard

	return p
}

func (s *ClauseGuardContext) GetParser() antlr.Parser { return s.parser }

func (s *ClauseGuardContext) Guard_() IGuard_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGuard_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGuard_Context)
}

func (s *ClauseGuardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClauseGuardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClauseGuardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterClauseGuard(s)
	}
}

func (s *ClauseGuardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitClauseGuard(s)
	}
}

func (p *ErlangParser) ClauseGuard() (localctx IClauseGuardContext) {
	this := p
	_ = this

	localctx = NewClauseGuardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ErlangParserRULE_clauseGuard)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserT__10 {
		{
			p.SetState(601)
			p.Match(ErlangParserT__10)
		}
		{
			p.SetState(602)
			p.Guard_()
		}

	}

	return localctx
}

// IClauseBodyContext is an interface to support dynamic dispatch.
type IClauseBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClauseBodyContext differentiates from other interfaces.
	IsClauseBodyContext()
}

type ClauseBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClauseBodyContext() *ClauseBodyContext {
	var p = new(ClauseBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_clauseBody
	return p
}

func (*ClauseBodyContext) IsClauseBodyContext() {}

func NewClauseBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClauseBodyContext {
	var p = new(ClauseBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_clauseBody

	return p
}

func (s *ClauseBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClauseBodyContext) Exprs() IExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsContext)
}

func (s *ClauseBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClauseBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClauseBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterClauseBody(s)
	}
}

func (s *ClauseBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitClauseBody(s)
	}
}

func (p *ErlangParser) ClauseBody() (localctx IClauseBodyContext) {
	this := p
	_ = this

	localctx = NewClauseBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ErlangParserRULE_clauseBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(605)
		p.Match(ErlangParserT__18)
	}
	{
		p.SetState(606)
		p.Exprs()
	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprContext) Expr100() IExpr100Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr100Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr100Context)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *ErlangParser) Expr() (localctx IExprContext) {
	this := p
	_ = this

	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ErlangParserRULE_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(611)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserT__24:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(608)
			p.Match(ErlangParserT__24)
		}
		{
			p.SetState(609)
			p.Expr()
		}

	case ErlangParserT__1, ErlangParserT__2, ErlangParserT__7, ErlangParserT__13, ErlangParserT__16, ErlangParserT__17, ErlangParserT__21, ErlangParserT__29, ErlangParserT__35, ErlangParserT__36, ErlangParserT__38, ErlangParserT__40, ErlangParserT__41, ErlangParserT__42, ErlangParserT__43, ErlangParserTokAtom, ErlangParserTokVar, ErlangParserTokFloat, ErlangParserTokInteger, ErlangParserTokChar, ErlangParserTokString:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(610)
			p.Expr100()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpr100Context is an interface to support dynamic dispatch.
type IExpr100Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr100Context differentiates from other interfaces.
	IsExpr100Context()
}

type Expr100Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr100Context() *Expr100Context {
	var p = new(Expr100Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_expr100
	return p
}

func (*Expr100Context) IsExpr100Context() {}

func NewExpr100Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr100Context {
	var p = new(Expr100Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_expr100

	return p
}

func (s *Expr100Context) GetParser() antlr.Parser { return s.parser }

func (s *Expr100Context) AllExpr150() []IExpr150Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr150Context)(nil)).Elem())
	var tst = make([]IExpr150Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr150Context)
		}
	}

	return tst
}

func (s *Expr100Context) Expr150(i int) IExpr150Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr150Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr150Context)
}

func (s *Expr100Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr100Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr100Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterExpr100(s)
	}
}

func (s *Expr100Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitExpr100(s)
	}
}

func (p *ErlangParser) Expr100() (localctx IExpr100Context) {
	this := p
	_ = this

	localctx = NewExpr100Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ErlangParserRULE_expr100)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(613)
		p.Expr150()
	}
	p.SetState(618)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__25 || _la == ErlangParserT__26 {
		{
			p.SetState(614)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ErlangParserT__25 || _la == ErlangParserT__26) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(615)
			p.Expr150()
		}

		p.SetState(620)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr150Context is an interface to support dynamic dispatch.
type IExpr150Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr150Context differentiates from other interfaces.
	IsExpr150Context()
}

type Expr150Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr150Context() *Expr150Context {
	var p = new(Expr150Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_expr150
	return p
}

func (*Expr150Context) IsExpr150Context() {}

func NewExpr150Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr150Context {
	var p = new(Expr150Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_expr150

	return p
}

func (s *Expr150Context) GetParser() antlr.Parser { return s.parser }

func (s *Expr150Context) AllExpr160() []IExpr160Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr160Context)(nil)).Elem())
	var tst = make([]IExpr160Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr160Context)
		}
	}

	return tst
}

func (s *Expr150Context) Expr160(i int) IExpr160Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr160Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr160Context)
}

func (s *Expr150Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr150Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr150Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterExpr150(s)
	}
}

func (s *Expr150Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitExpr150(s)
	}
}

func (p *ErlangParser) Expr150() (localctx IExpr150Context) {
	this := p
	_ = this

	localctx = NewExpr150Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ErlangParserRULE_expr150)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		p.Expr160()
	}
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__27 {
		{
			p.SetState(622)
			p.Match(ErlangParserT__27)
		}
		{
			p.SetState(623)
			p.Expr160()
		}

		p.SetState(628)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr160Context is an interface to support dynamic dispatch.
type IExpr160Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr160Context differentiates from other interfaces.
	IsExpr160Context()
}

type Expr160Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr160Context() *Expr160Context {
	var p = new(Expr160Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_expr160
	return p
}

func (*Expr160Context) IsExpr160Context() {}

func NewExpr160Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr160Context {
	var p = new(Expr160Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_expr160

	return p
}

func (s *Expr160Context) GetParser() antlr.Parser { return s.parser }

func (s *Expr160Context) AllExpr200() []IExpr200Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr200Context)(nil)).Elem())
	var tst = make([]IExpr200Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr200Context)
		}
	}

	return tst
}

func (s *Expr160Context) Expr200(i int) IExpr200Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr200Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr200Context)
}

func (s *Expr160Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr160Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr160Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterExpr160(s)
	}
}

func (s *Expr160Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitExpr160(s)
	}
}

func (p *ErlangParser) Expr160() (localctx IExpr160Context) {
	this := p
	_ = this

	localctx = NewExpr160Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ErlangParserRULE_expr160)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(629)
		p.Expr200()
	}
	p.SetState(634)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__28 {
		{
			p.SetState(630)
			p.Match(ErlangParserT__28)
		}
		{
			p.SetState(631)
			p.Expr200()
		}

		p.SetState(636)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr200Context is an interface to support dynamic dispatch.
type IExpr200Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr200Context differentiates from other interfaces.
	IsExpr200Context()
}

type Expr200Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr200Context() *Expr200Context {
	var p = new(Expr200Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_expr200
	return p
}

func (*Expr200Context) IsExpr200Context() {}

func NewExpr200Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr200Context {
	var p = new(Expr200Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_expr200

	return p
}

func (s *Expr200Context) GetParser() antlr.Parser { return s.parser }

func (s *Expr200Context) AllExpr300() []IExpr300Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr300Context)(nil)).Elem())
	var tst = make([]IExpr300Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr300Context)
		}
	}

	return tst
}

func (s *Expr200Context) Expr300(i int) IExpr300Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr300Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr300Context)
}

func (s *Expr200Context) CompOp() ICompOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompOpContext)
}

func (s *Expr200Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr200Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr200Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterExpr200(s)
	}
}

func (s *Expr200Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitExpr200(s)
	}
}

func (p *ErlangParser) Expr200() (localctx IExpr200Context) {
	this := p
	_ = this

	localctx = NewExpr200Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ErlangParserRULE_expr200)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(637)
		p.Expr300()
	}
	p.SetState(641)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(ErlangParserT__56-57))|(1<<(ErlangParserT__57-57))|(1<<(ErlangParserT__58-57))|(1<<(ErlangParserT__59-57))|(1<<(ErlangParserT__60-57))|(1<<(ErlangParserT__61-57))|(1<<(ErlangParserT__62-57))|(1<<(ErlangParserT__63-57)))) != 0 {
		{
			p.SetState(638)
			p.CompOp()
		}
		{
			p.SetState(639)
			p.Expr300()
		}

	}

	return localctx
}

// IExpr300Context is an interface to support dynamic dispatch.
type IExpr300Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr300Context differentiates from other interfaces.
	IsExpr300Context()
}

type Expr300Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr300Context() *Expr300Context {
	var p = new(Expr300Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_expr300
	return p
}

func (*Expr300Context) IsExpr300Context() {}

func NewExpr300Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr300Context {
	var p = new(Expr300Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_expr300

	return p
}

func (s *Expr300Context) GetParser() antlr.Parser { return s.parser }

func (s *Expr300Context) AllExpr400() []IExpr400Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr400Context)(nil)).Elem())
	var tst = make([]IExpr400Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr400Context)
		}
	}

	return tst
}

func (s *Expr300Context) Expr400(i int) IExpr400Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr400Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr400Context)
}

func (s *Expr300Context) AllListOp() []IListOpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IListOpContext)(nil)).Elem())
	var tst = make([]IListOpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IListOpContext)
		}
	}

	return tst
}

func (s *Expr300Context) ListOp(i int) IListOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListOpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IListOpContext)
}

func (s *Expr300Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr300Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr300Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterExpr300(s)
	}
}

func (s *Expr300Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitExpr300(s)
	}
}

func (p *ErlangParser) Expr300() (localctx IExpr300Context) {
	this := p
	_ = this

	localctx = NewExpr300Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ErlangParserRULE_expr300)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(643)
		p.Expr400()
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__54 || _la == ErlangParserT__55 {
		{
			p.SetState(644)
			p.ListOp()
		}
		{
			p.SetState(645)
			p.Expr400()
		}

		p.SetState(651)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr400Context is an interface to support dynamic dispatch.
type IExpr400Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr400Context differentiates from other interfaces.
	IsExpr400Context()
}

type Expr400Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr400Context() *Expr400Context {
	var p = new(Expr400Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_expr400
	return p
}

func (*Expr400Context) IsExpr400Context() {}

func NewExpr400Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr400Context {
	var p = new(Expr400Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_expr400

	return p
}

func (s *Expr400Context) GetParser() antlr.Parser { return s.parser }

func (s *Expr400Context) AllExpr500() []IExpr500Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr500Context)(nil)).Elem())
	var tst = make([]IExpr500Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr500Context)
		}
	}

	return tst
}

func (s *Expr400Context) Expr500(i int) IExpr500Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr500Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr500Context)
}

func (s *Expr400Context) AllAddOp() []IAddOpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddOpContext)(nil)).Elem())
	var tst = make([]IAddOpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddOpContext)
		}
	}

	return tst
}

func (s *Expr400Context) AddOp(i int) IAddOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddOpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddOpContext)
}

func (s *Expr400Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr400Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr400Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterExpr400(s)
	}
}

func (s *Expr400Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitExpr400(s)
	}
}

func (p *ErlangParser) Expr400() (localctx IExpr400Context) {
	this := p
	_ = this

	localctx = NewExpr400Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ErlangParserRULE_expr400)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(652)
		p.Expr500()
	}
	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__1 || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(ErlangParserT__41-42))|(1<<(ErlangParserT__48-42))|(1<<(ErlangParserT__49-42))|(1<<(ErlangParserT__50-42))|(1<<(ErlangParserT__51-42))|(1<<(ErlangParserT__52-42))|(1<<(ErlangParserT__53-42)))) != 0) {
		{
			p.SetState(653)
			p.AddOp()
		}
		{
			p.SetState(654)
			p.Expr500()
		}

		p.SetState(660)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr500Context is an interface to support dynamic dispatch.
type IExpr500Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr500Context differentiates from other interfaces.
	IsExpr500Context()
}

type Expr500Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr500Context() *Expr500Context {
	var p = new(Expr500Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_expr500
	return p
}

func (*Expr500Context) IsExpr500Context() {}

func NewExpr500Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr500Context {
	var p = new(Expr500Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_expr500

	return p
}

func (s *Expr500Context) GetParser() antlr.Parser { return s.parser }

func (s *Expr500Context) AllExpr600() []IExpr600Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr600Context)(nil)).Elem())
	var tst = make([]IExpr600Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr600Context)
		}
	}

	return tst
}

func (s *Expr500Context) Expr600(i int) IExpr600Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr600Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr600Context)
}

func (s *Expr500Context) AllMultOp() []IMultOpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultOpContext)(nil)).Elem())
	var tst = make([]IMultOpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultOpContext)
		}
	}

	return tst
}

func (s *Expr500Context) MultOp(i int) IMultOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultOpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultOpContext)
}

func (s *Expr500Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr500Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr500Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterExpr500(s)
	}
}

func (s *Expr500Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitExpr500(s)
	}
}

func (p *ErlangParser) Expr500() (localctx IExpr500Context) {
	this := p
	_ = this

	localctx = NewExpr500Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ErlangParserRULE_expr500)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(661)
		p.Expr600()
	}
	p.SetState(667)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-24)&-(0x1f+1)) == 0 && ((1<<uint((_la-24)))&((1<<(ErlangParserT__23-24))|(1<<(ErlangParserT__31-24))|(1<<(ErlangParserT__44-24))|(1<<(ErlangParserT__45-24))|(1<<(ErlangParserT__46-24))|(1<<(ErlangParserT__47-24)))) != 0 {
		{
			p.SetState(662)
			p.MultOp()
		}
		{
			p.SetState(663)
			p.Expr600()
		}

		p.SetState(669)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr600Context is an interface to support dynamic dispatch.
type IExpr600Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr600Context differentiates from other interfaces.
	IsExpr600Context()
}

type Expr600Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr600Context() *Expr600Context {
	var p = new(Expr600Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_expr600
	return p
}

func (*Expr600Context) IsExpr600Context() {}

func NewExpr600Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr600Context {
	var p = new(Expr600Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_expr600

	return p
}

func (s *Expr600Context) GetParser() antlr.Parser { return s.parser }

func (s *Expr600Context) PrefixOp() IPrefixOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefixOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefixOpContext)
}

func (s *Expr600Context) Expr600() IExpr600Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr600Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr600Context)
}

func (s *Expr600Context) Expr650() IExpr650Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr650Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr650Context)
}

func (s *Expr600Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr600Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr600Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterExpr600(s)
	}
}

func (s *Expr600Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitExpr600(s)
	}
}

func (p *ErlangParser) Expr600() (localctx IExpr600Context) {
	this := p
	_ = this

	localctx = NewExpr600Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ErlangParserRULE_expr600)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(674)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserT__1, ErlangParserT__41, ErlangParserT__42, ErlangParserT__43:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(670)
			p.PrefixOp()
		}
		{
			p.SetState(671)
			p.Expr600()
		}

	case ErlangParserT__2, ErlangParserT__7, ErlangParserT__13, ErlangParserT__16, ErlangParserT__17, ErlangParserT__21, ErlangParserT__29, ErlangParserT__35, ErlangParserT__36, ErlangParserT__38, ErlangParserT__40, ErlangParserTokAtom, ErlangParserTokVar, ErlangParserTokFloat, ErlangParserTokInteger, ErlangParserTokChar, ErlangParserTokString:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(673)
			p.Expr650()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpr650Context is an interface to support dynamic dispatch.
type IExpr650Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr650Context differentiates from other interfaces.
	IsExpr650Context()
}

type Expr650Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr650Context() *Expr650Context {
	var p = new(Expr650Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_expr650
	return p
}

func (*Expr650Context) IsExpr650Context() {}

func NewExpr650Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr650Context {
	var p = new(Expr650Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_expr650

	return p
}

func (s *Expr650Context) GetParser() antlr.Parser { return s.parser }

func (s *Expr650Context) MapExpr() IMapExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapExprContext)
}

func (s *Expr650Context) Expr700() IExpr700Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr700Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr700Context)
}

func (s *Expr650Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr650Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr650Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterExpr650(s)
	}
}

func (s *Expr650Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitExpr650(s)
	}
}

func (p *ErlangParser) Expr650() (localctx IExpr650Context) {
	this := p
	_ = this

	localctx = NewExpr650Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ErlangParserRULE_expr650)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(678)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(676)
			p.mapExpr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(677)
			p.Expr700()
		}

	}

	return localctx
}

// IExpr700Context is an interface to support dynamic dispatch.
type IExpr700Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr700Context differentiates from other interfaces.
	IsExpr700Context()
}

type Expr700Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr700Context() *Expr700Context {
	var p = new(Expr700Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_expr700
	return p
}

func (*Expr700Context) IsExpr700Context() {}

func NewExpr700Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr700Context {
	var p = new(Expr700Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_expr700

	return p
}

func (s *Expr700Context) GetParser() antlr.Parser { return s.parser }

func (s *Expr700Context) FunctionCall() IFunctionCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *Expr700Context) RecordExpr() IRecordExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordExprContext)
}

func (s *Expr700Context) Expr800() IExpr800Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr800Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr800Context)
}

func (s *Expr700Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr700Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr700Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterExpr700(s)
	}
}

func (s *Expr700Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitExpr700(s)
	}
}

func (p *ErlangParser) Expr700() (localctx IExpr700Context) {
	this := p
	_ = this

	localctx = NewExpr700Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ErlangParserRULE_expr700)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(680)
			p.FunctionCall()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(681)
			p.recordExpr(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(682)
			p.Expr800()
		}

	}

	return localctx
}

// IExpr800Context is an interface to support dynamic dispatch.
type IExpr800Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr800Context differentiates from other interfaces.
	IsExpr800Context()
}

type Expr800Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr800Context() *Expr800Context {
	var p = new(Expr800Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_expr800
	return p
}

func (*Expr800Context) IsExpr800Context() {}

func NewExpr800Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr800Context {
	var p = new(Expr800Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_expr800

	return p
}

func (s *Expr800Context) GetParser() antlr.Parser { return s.parser }

func (s *Expr800Context) AllExprMax() []IExprMaxContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprMaxContext)(nil)).Elem())
	var tst = make([]IExprMaxContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprMaxContext)
		}
	}

	return tst
}

func (s *Expr800Context) ExprMax(i int) IExprMaxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprMaxContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprMaxContext)
}

func (s *Expr800Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr800Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr800Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterExpr800(s)
	}
}

func (s *Expr800Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitExpr800(s)
	}
}

func (p *ErlangParser) Expr800() (localctx IExpr800Context) {
	this := p
	_ = this

	localctx = NewExpr800Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ErlangParserRULE_expr800)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.ExprMax()
	}
	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserT__4 {
		{
			p.SetState(686)
			p.Match(ErlangParserT__4)
		}
		{
			p.SetState(687)
			p.ExprMax()
		}

	}

	return localctx
}

// IExprMaxContext is an interface to support dynamic dispatch.
type IExprMaxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprMaxContext differentiates from other interfaces.
	IsExprMaxContext()
}

type ExprMaxContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprMaxContext() *ExprMaxContext {
	var p = new(ExprMaxContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_exprMax
	return p
}

func (*ExprMaxContext) IsExprMaxContext() {}

func NewExprMaxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprMaxContext {
	var p = new(ExprMaxContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_exprMax

	return p
}

func (s *ExprMaxContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprMaxContext) TokVar() ITokVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokVarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokVarContext)
}

func (s *ExprMaxContext) Atomic() IAtomicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomicContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomicContext)
}

func (s *ExprMaxContext) List_() IList_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_Context)
}

func (s *ExprMaxContext) Binary() IBinaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinaryContext)
}

func (s *ExprMaxContext) ListComprehension() IListComprehensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListComprehensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListComprehensionContext)
}

func (s *ExprMaxContext) BinaryComprehension() IBinaryComprehensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinaryComprehensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinaryComprehensionContext)
}

func (s *ExprMaxContext) Tuple_() ITuple_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITuple_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITuple_Context)
}

func (s *ExprMaxContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprMaxContext) Exprs() IExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsContext)
}

func (s *ExprMaxContext) IfExpr() IIfExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExprContext)
}

func (s *ExprMaxContext) CaseExpr() ICaseExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICaseExprContext)
}

func (s *ExprMaxContext) ReceiveExpr() IReceiveExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiveExprContext)
}

func (s *ExprMaxContext) FunExpr() IFunExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunExprContext)
}

func (s *ExprMaxContext) TryExpr() ITryExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryExprContext)
}

func (s *ExprMaxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprMaxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprMaxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterExprMax(s)
	}
}

func (s *ExprMaxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitExprMax(s)
	}
}

func (p *ErlangParser) ExprMax() (localctx IExprMaxContext) {
	this := p
	_ = this

	localctx = NewExprMaxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ErlangParserRULE_exprMax)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(690)
			p.TokVar()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(691)
			p.Atomic()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(692)
			p.List_()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(693)
			p.Binary()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(694)
			p.ListComprehension()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(695)
			p.BinaryComprehension()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(696)
			p.Tuple_()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(697)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(698)
			p.Expr()
		}
		{
			p.SetState(699)
			p.Match(ErlangParserT__3)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(701)
			p.Match(ErlangParserT__29)
		}
		{
			p.SetState(702)
			p.Exprs()
		}
		{
			p.SetState(703)
			p.Match(ErlangParserT__30)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(705)
			p.IfExpr()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(706)
			p.CaseExpr()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(707)
			p.ReceiveExpr()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(708)
			p.FunExpr()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(709)
			p.TryExpr()
		}

	}

	return localctx
}

// IPatExprContext is an interface to support dynamic dispatch.
type IPatExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatExprContext differentiates from other interfaces.
	IsPatExprContext()
}

type PatExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatExprContext() *PatExprContext {
	var p = new(PatExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_patExpr
	return p
}

func (*PatExprContext) IsPatExprContext() {}

func NewPatExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatExprContext {
	var p = new(PatExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_patExpr

	return p
}

func (s *PatExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PatExprContext) PatExpr200() IPatExpr200Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExpr200Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExpr200Context)
}

func (s *PatExprContext) PatExpr() IPatExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExprContext)
}

func (s *PatExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterPatExpr(s)
	}
}

func (s *PatExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitPatExpr(s)
	}
}

func (p *ErlangParser) PatExpr() (localctx IPatExprContext) {
	this := p
	_ = this

	localctx = NewPatExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ErlangParserRULE_patExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		p.PatExpr200()
	}
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserT__25 {
		{
			p.SetState(713)
			p.Match(ErlangParserT__25)
		}
		{
			p.SetState(714)
			p.PatExpr()
		}

	}

	return localctx
}

// IPatExpr200Context is an interface to support dynamic dispatch.
type IPatExpr200Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatExpr200Context differentiates from other interfaces.
	IsPatExpr200Context()
}

type PatExpr200Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatExpr200Context() *PatExpr200Context {
	var p = new(PatExpr200Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_patExpr200
	return p
}

func (*PatExpr200Context) IsPatExpr200Context() {}

func NewPatExpr200Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatExpr200Context {
	var p = new(PatExpr200Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_patExpr200

	return p
}

func (s *PatExpr200Context) GetParser() antlr.Parser { return s.parser }

func (s *PatExpr200Context) AllPatExpr300() []IPatExpr300Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPatExpr300Context)(nil)).Elem())
	var tst = make([]IPatExpr300Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPatExpr300Context)
		}
	}

	return tst
}

func (s *PatExpr200Context) PatExpr300(i int) IPatExpr300Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExpr300Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPatExpr300Context)
}

func (s *PatExpr200Context) CompOp() ICompOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompOpContext)
}

func (s *PatExpr200Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatExpr200Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatExpr200Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterPatExpr200(s)
	}
}

func (s *PatExpr200Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitPatExpr200(s)
	}
}

func (p *ErlangParser) PatExpr200() (localctx IPatExpr200Context) {
	this := p
	_ = this

	localctx = NewPatExpr200Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ErlangParserRULE_patExpr200)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(717)
		p.PatExpr300()
	}
	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(ErlangParserT__56-57))|(1<<(ErlangParserT__57-57))|(1<<(ErlangParserT__58-57))|(1<<(ErlangParserT__59-57))|(1<<(ErlangParserT__60-57))|(1<<(ErlangParserT__61-57))|(1<<(ErlangParserT__62-57))|(1<<(ErlangParserT__63-57)))) != 0 {
		{
			p.SetState(718)
			p.CompOp()
		}
		{
			p.SetState(719)
			p.PatExpr300()
		}

	}

	return localctx
}

// IPatExpr300Context is an interface to support dynamic dispatch.
type IPatExpr300Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatExpr300Context differentiates from other interfaces.
	IsPatExpr300Context()
}

type PatExpr300Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatExpr300Context() *PatExpr300Context {
	var p = new(PatExpr300Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_patExpr300
	return p
}

func (*PatExpr300Context) IsPatExpr300Context() {}

func NewPatExpr300Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatExpr300Context {
	var p = new(PatExpr300Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_patExpr300

	return p
}

func (s *PatExpr300Context) GetParser() antlr.Parser { return s.parser }

func (s *PatExpr300Context) PatExpr400() IPatExpr400Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExpr400Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExpr400Context)
}

func (s *PatExpr300Context) ListOp() IListOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListOpContext)
}

func (s *PatExpr300Context) PatExpr300() IPatExpr300Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExpr300Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExpr300Context)
}

func (s *PatExpr300Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatExpr300Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatExpr300Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterPatExpr300(s)
	}
}

func (s *PatExpr300Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitPatExpr300(s)
	}
}

func (p *ErlangParser) PatExpr300() (localctx IPatExpr300Context) {
	this := p
	_ = this

	localctx = NewPatExpr300Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ErlangParserRULE_patExpr300)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(723)
		p.patExpr400(0)
	}
	p.SetState(727)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserT__54 || _la == ErlangParserT__55 {
		{
			p.SetState(724)
			p.ListOp()
		}
		{
			p.SetState(725)
			p.PatExpr300()
		}

	}

	return localctx
}

// IPatExpr400Context is an interface to support dynamic dispatch.
type IPatExpr400Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatExpr400Context differentiates from other interfaces.
	IsPatExpr400Context()
}

type PatExpr400Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatExpr400Context() *PatExpr400Context {
	var p = new(PatExpr400Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_patExpr400
	return p
}

func (*PatExpr400Context) IsPatExpr400Context() {}

func NewPatExpr400Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatExpr400Context {
	var p = new(PatExpr400Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_patExpr400

	return p
}

func (s *PatExpr400Context) GetParser() antlr.Parser { return s.parser }

func (s *PatExpr400Context) PatExpr500() IPatExpr500Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExpr500Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExpr500Context)
}

func (s *PatExpr400Context) PatExpr400() IPatExpr400Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExpr400Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExpr400Context)
}

func (s *PatExpr400Context) AddOp() IAddOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddOpContext)
}

func (s *PatExpr400Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatExpr400Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatExpr400Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterPatExpr400(s)
	}
}

func (s *PatExpr400Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitPatExpr400(s)
	}
}

func (p *ErlangParser) PatExpr400() (localctx IPatExpr400Context) {
	return p.patExpr400(0)
}

func (p *ErlangParser) patExpr400(_p int) (localctx IPatExpr400Context) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPatExpr400Context(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPatExpr400Context = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 116
	p.EnterRecursionRule(localctx, 116, ErlangParserRULE_patExpr400, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(730)
		p.patExpr500(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(738)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewPatExpr400Context(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ErlangParserRULE_patExpr400)
			p.SetState(732)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(733)
				p.AddOp()
			}
			{
				p.SetState(734)
				p.patExpr500(0)
			}

		}
		p.SetState(740)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())
	}

	return localctx
}

// IPatExpr500Context is an interface to support dynamic dispatch.
type IPatExpr500Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatExpr500Context differentiates from other interfaces.
	IsPatExpr500Context()
}

type PatExpr500Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatExpr500Context() *PatExpr500Context {
	var p = new(PatExpr500Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_patExpr500
	return p
}

func (*PatExpr500Context) IsPatExpr500Context() {}

func NewPatExpr500Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatExpr500Context {
	var p = new(PatExpr500Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_patExpr500

	return p
}

func (s *PatExpr500Context) GetParser() antlr.Parser { return s.parser }

func (s *PatExpr500Context) PatExpr600() IPatExpr600Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExpr600Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExpr600Context)
}

func (s *PatExpr500Context) PatExpr500() IPatExpr500Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExpr500Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExpr500Context)
}

func (s *PatExpr500Context) MultOp() IMultOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultOpContext)
}

func (s *PatExpr500Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatExpr500Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatExpr500Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterPatExpr500(s)
	}
}

func (s *PatExpr500Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitPatExpr500(s)
	}
}

func (p *ErlangParser) PatExpr500() (localctx IPatExpr500Context) {
	return p.patExpr500(0)
}

func (p *ErlangParser) patExpr500(_p int) (localctx IPatExpr500Context) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPatExpr500Context(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPatExpr500Context = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 118
	p.EnterRecursionRule(localctx, 118, ErlangParserRULE_patExpr500, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(742)
		p.PatExpr600()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(750)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewPatExpr500Context(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ErlangParserRULE_patExpr500)
			p.SetState(744)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(745)
				p.MultOp()
			}
			{
				p.SetState(746)
				p.PatExpr600()
			}

		}
		p.SetState(752)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext())
	}

	return localctx
}

// IPatExpr600Context is an interface to support dynamic dispatch.
type IPatExpr600Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatExpr600Context differentiates from other interfaces.
	IsPatExpr600Context()
}

type PatExpr600Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatExpr600Context() *PatExpr600Context {
	var p = new(PatExpr600Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_patExpr600
	return p
}

func (*PatExpr600Context) IsPatExpr600Context() {}

func NewPatExpr600Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatExpr600Context {
	var p = new(PatExpr600Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_patExpr600

	return p
}

func (s *PatExpr600Context) GetParser() antlr.Parser { return s.parser }

func (s *PatExpr600Context) PrefixOp() IPrefixOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefixOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefixOpContext)
}

func (s *PatExpr600Context) PatExpr600() IPatExpr600Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExpr600Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExpr600Context)
}

func (s *PatExpr600Context) PatExpr650() IPatExpr650Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExpr650Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExpr650Context)
}

func (s *PatExpr600Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatExpr600Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatExpr600Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterPatExpr600(s)
	}
}

func (s *PatExpr600Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitPatExpr600(s)
	}
}

func (p *ErlangParser) PatExpr600() (localctx IPatExpr600Context) {
	this := p
	_ = this

	localctx = NewPatExpr600Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ErlangParserRULE_patExpr600)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(757)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserT__1, ErlangParserT__41, ErlangParserT__42, ErlangParserT__43:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(753)
			p.PrefixOp()
		}
		{
			p.SetState(754)
			p.PatExpr600()
		}

	case ErlangParserT__2, ErlangParserT__7, ErlangParserT__13, ErlangParserT__16, ErlangParserT__21, ErlangParserTokAtom, ErlangParserTokVar, ErlangParserTokFloat, ErlangParserTokInteger, ErlangParserTokChar, ErlangParserTokString:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(756)
			p.PatExpr650()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPatExpr650Context is an interface to support dynamic dispatch.
type IPatExpr650Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatExpr650Context differentiates from other interfaces.
	IsPatExpr650Context()
}

type PatExpr650Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatExpr650Context() *PatExpr650Context {
	var p = new(PatExpr650Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_patExpr650
	return p
}

func (*PatExpr650Context) IsPatExpr650Context() {}

func NewPatExpr650Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatExpr650Context {
	var p = new(PatExpr650Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_patExpr650

	return p
}

func (s *PatExpr650Context) GetParser() antlr.Parser { return s.parser }

func (s *PatExpr650Context) MapPatExpr() IMapPatExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapPatExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapPatExprContext)
}

func (s *PatExpr650Context) PatExpr700() IPatExpr700Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExpr700Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExpr700Context)
}

func (s *PatExpr650Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatExpr650Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatExpr650Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterPatExpr650(s)
	}
}

func (s *PatExpr650Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitPatExpr650(s)
	}
}

func (p *ErlangParser) PatExpr650() (localctx IPatExpr650Context) {
	this := p
	_ = this

	localctx = NewPatExpr650Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ErlangParserRULE_patExpr650)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(761)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(759)
			p.mapPatExpr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(760)
			p.PatExpr700()
		}

	}

	return localctx
}

// IPatExpr700Context is an interface to support dynamic dispatch.
type IPatExpr700Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatExpr700Context differentiates from other interfaces.
	IsPatExpr700Context()
}

type PatExpr700Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatExpr700Context() *PatExpr700Context {
	var p = new(PatExpr700Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_patExpr700
	return p
}

func (*PatExpr700Context) IsPatExpr700Context() {}

func NewPatExpr700Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatExpr700Context {
	var p = new(PatExpr700Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_patExpr700

	return p
}

func (s *PatExpr700Context) GetParser() antlr.Parser { return s.parser }

func (s *PatExpr700Context) RecordPatExpr() IRecordPatExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordPatExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordPatExprContext)
}

func (s *PatExpr700Context) PatExpr800() IPatExpr800Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExpr800Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExpr800Context)
}

func (s *PatExpr700Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatExpr700Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatExpr700Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterPatExpr700(s)
	}
}

func (s *PatExpr700Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitPatExpr700(s)
	}
}

func (p *ErlangParser) PatExpr700() (localctx IPatExpr700Context) {
	this := p
	_ = this

	localctx = NewPatExpr700Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ErlangParserRULE_patExpr700)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(765)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserT__16:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(763)
			p.RecordPatExpr()
		}

	case ErlangParserT__2, ErlangParserT__7, ErlangParserT__13, ErlangParserT__21, ErlangParserTokAtom, ErlangParserTokVar, ErlangParserTokFloat, ErlangParserTokInteger, ErlangParserTokChar, ErlangParserTokString:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(764)
			p.PatExpr800()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPatExpr800Context is an interface to support dynamic dispatch.
type IPatExpr800Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatExpr800Context differentiates from other interfaces.
	IsPatExpr800Context()
}

type PatExpr800Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatExpr800Context() *PatExpr800Context {
	var p = new(PatExpr800Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_patExpr800
	return p
}

func (*PatExpr800Context) IsPatExpr800Context() {}

func NewPatExpr800Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatExpr800Context {
	var p = new(PatExpr800Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_patExpr800

	return p
}

func (s *PatExpr800Context) GetParser() antlr.Parser { return s.parser }

func (s *PatExpr800Context) PatExprMax() IPatExprMaxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExprMaxContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExprMaxContext)
}

func (s *PatExpr800Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatExpr800Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatExpr800Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterPatExpr800(s)
	}
}

func (s *PatExpr800Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitPatExpr800(s)
	}
}

func (p *ErlangParser) PatExpr800() (localctx IPatExpr800Context) {
	this := p
	_ = this

	localctx = NewPatExpr800Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ErlangParserRULE_patExpr800)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(767)
		p.PatExprMax()
	}

	return localctx
}

// IPatExprMaxContext is an interface to support dynamic dispatch.
type IPatExprMaxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatExprMaxContext differentiates from other interfaces.
	IsPatExprMaxContext()
}

type PatExprMaxContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatExprMaxContext() *PatExprMaxContext {
	var p = new(PatExprMaxContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_patExprMax
	return p
}

func (*PatExprMaxContext) IsPatExprMaxContext() {}

func NewPatExprMaxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatExprMaxContext {
	var p = new(PatExprMaxContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_patExprMax

	return p
}

func (s *PatExprMaxContext) GetParser() antlr.Parser { return s.parser }

func (s *PatExprMaxContext) TokVar() ITokVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokVarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokVarContext)
}

func (s *PatExprMaxContext) Atomic() IAtomicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomicContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomicContext)
}

func (s *PatExprMaxContext) List_() IList_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_Context)
}

func (s *PatExprMaxContext) Binary() IBinaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinaryContext)
}

func (s *PatExprMaxContext) Tuple_() ITuple_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITuple_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITuple_Context)
}

func (s *PatExprMaxContext) PatExpr() IPatExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExprContext)
}

func (s *PatExprMaxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatExprMaxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatExprMaxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterPatExprMax(s)
	}
}

func (s *PatExprMaxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitPatExprMax(s)
	}
}

func (p *ErlangParser) PatExprMax() (localctx IPatExprMaxContext) {
	this := p
	_ = this

	localctx = NewPatExprMaxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ErlangParserRULE_patExprMax)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(778)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserTokVar:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(769)
			p.TokVar()
		}

	case ErlangParserTokAtom, ErlangParserTokFloat, ErlangParserTokInteger, ErlangParserTokChar, ErlangParserTokString:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(770)
			p.Atomic()
		}

	case ErlangParserT__13:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(771)
			p.List_()
		}

	case ErlangParserT__21:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(772)
			p.Binary()
		}

	case ErlangParserT__7:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(773)
			p.Tuple_()
		}

	case ErlangParserT__2:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(774)
			p.Match(ErlangParserT__2)
		}
		{
			p.SetState(775)
			p.PatExpr()
		}
		{
			p.SetState(776)
			p.Match(ErlangParserT__3)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMapPatExprContext is an interface to support dynamic dispatch.
type IMapPatExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapPatExprContext differentiates from other interfaces.
	IsMapPatExprContext()
}

type MapPatExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapPatExprContext() *MapPatExprContext {
	var p = new(MapPatExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_mapPatExpr
	return p
}

func (*MapPatExprContext) IsMapPatExprContext() {}

func NewMapPatExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapPatExprContext {
	var p = new(MapPatExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_mapPatExpr

	return p
}

func (s *MapPatExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MapPatExprContext) MapTuple() IMapTupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapTupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapTupleContext)
}

func (s *MapPatExprContext) PatExprMax() IPatExprMaxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExprMaxContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExprMaxContext)
}

func (s *MapPatExprContext) MapPatExpr() IMapPatExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapPatExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapPatExprContext)
}

func (s *MapPatExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapPatExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapPatExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterMapPatExpr(s)
	}
}

func (s *MapPatExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitMapPatExpr(s)
	}
}

func (p *ErlangParser) MapPatExpr() (localctx IMapPatExprContext) {
	return p.mapPatExpr(0)
}

func (p *ErlangParser) mapPatExpr(_p int) (localctx IMapPatExprContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewMapPatExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMapPatExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 130
	p.EnterRecursionRule(localctx, 130, ErlangParserRULE_mapPatExpr, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(782)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ErlangParserT__2)|(1<<ErlangParserT__7)|(1<<ErlangParserT__13)|(1<<ErlangParserT__21))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(ErlangParserTokAtom-65))|(1<<(ErlangParserTokVar-65))|(1<<(ErlangParserTokFloat-65))|(1<<(ErlangParserTokInteger-65))|(1<<(ErlangParserTokChar-65))|(1<<(ErlangParserTokString-65)))) != 0) {
		{
			p.SetState(781)
			p.PatExprMax()
		}

	}
	{
		p.SetState(784)
		p.Match(ErlangParserT__16)
	}
	{
		p.SetState(785)
		p.MapTuple()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(792)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewMapPatExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ErlangParserRULE_mapPatExpr)
			p.SetState(787)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(788)
				p.Match(ErlangParserT__16)
			}
			{
				p.SetState(789)
				p.MapTuple()
			}

		}
		p.SetState(794)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())
	}

	return localctx
}

// IRecordPatExprContext is an interface to support dynamic dispatch.
type IRecordPatExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordPatExprContext differentiates from other interfaces.
	IsRecordPatExprContext()
}

type RecordPatExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordPatExprContext() *RecordPatExprContext {
	var p = new(RecordPatExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_recordPatExpr
	return p
}

func (*RecordPatExprContext) IsRecordPatExprContext() {}

func NewRecordPatExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordPatExprContext {
	var p = new(RecordPatExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_recordPatExpr

	return p
}

func (s *RecordPatExprContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordPatExprContext) AllTokAtom() []ITokAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITokAtomContext)(nil)).Elem())
	var tst = make([]ITokAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITokAtomContext)
		}
	}

	return tst
}

func (s *RecordPatExprContext) TokAtom(i int) ITokAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITokAtomContext)
}

func (s *RecordPatExprContext) RecordTuple() IRecordTupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordTupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordTupleContext)
}

func (s *RecordPatExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordPatExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordPatExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterRecordPatExpr(s)
	}
}

func (s *RecordPatExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitRecordPatExpr(s)
	}
}

func (p *ErlangParser) RecordPatExpr() (localctx IRecordPatExprContext) {
	this := p
	_ = this

	localctx = NewRecordPatExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ErlangParserRULE_recordPatExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(795)
		p.Match(ErlangParserT__16)
	}
	{
		p.SetState(796)
		p.TokAtom()
	}
	p.SetState(800)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserT__0:
		{
			p.SetState(797)
			p.Match(ErlangParserT__0)
		}
		{
			p.SetState(798)
			p.TokAtom()
		}

	case ErlangParserT__7:
		{
			p.SetState(799)
			p.RecordTuple()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_Context is an interface to support dynamic dispatch.
type IList_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_Context differentiates from other interfaces.
	IsList_Context()
}

type List_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_Context() *List_Context {
	var p = new(List_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_list_
	return p
}

func (*List_Context) IsList_Context() {}

func NewList_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_Context {
	var p = new(List_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_list_

	return p
}

func (s *List_Context) GetParser() antlr.Parser { return s.parser }

func (s *List_Context) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *List_Context) Tail() ITailContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITailContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITailContext)
}

func (s *List_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterList_(s)
	}
}

func (s *List_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitList_(s)
	}
}

func (p *ErlangParser) List_() (localctx IList_Context) {
	this := p
	_ = this

	localctx = NewList_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ErlangParserRULE_list_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(808)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(802)
			p.Match(ErlangParserT__13)
		}
		{
			p.SetState(803)
			p.Match(ErlangParserT__14)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(804)
			p.Match(ErlangParserT__13)
		}
		{
			p.SetState(805)
			p.Expr()
		}
		{
			p.SetState(806)
			p.Tail()
		}

	}

	return localctx
}

// ITailContext is an interface to support dynamic dispatch.
type ITailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTailContext differentiates from other interfaces.
	IsTailContext()
}

type TailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTailContext() *TailContext {
	var p = new(TailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_tail
	return p
}

func (*TailContext) IsTailContext() {}

func NewTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TailContext {
	var p = new(TailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_tail

	return p
}

func (s *TailContext) GetParser() antlr.Parser { return s.parser }

func (s *TailContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TailContext) Tail() ITailContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITailContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITailContext)
}

func (s *TailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTail(s)
	}
}

func (s *TailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTail(s)
	}
}

func (p *ErlangParser) Tail() (localctx ITailContext) {
	this := p
	_ = this

	localctx = NewTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ErlangParserRULE_tail)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(819)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserT__14:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(810)
			p.Match(ErlangParserT__14)
		}

	case ErlangParserT__11:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(811)
			p.Match(ErlangParserT__11)
		}
		{
			p.SetState(812)
			p.Expr()
		}
		{
			p.SetState(813)
			p.Match(ErlangParserT__14)
		}

	case ErlangParserT__5:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(815)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(816)
			p.Expr()
		}
		{
			p.SetState(817)
			p.Tail()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBinaryContext is an interface to support dynamic dispatch.
type IBinaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinaryContext differentiates from other interfaces.
	IsBinaryContext()
}

type BinaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryContext() *BinaryContext {
	var p = new(BinaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_binary
	return p
}

func (*BinaryContext) IsBinaryContext() {}

func NewBinaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryContext {
	var p = new(BinaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_binary

	return p
}

func (s *BinaryContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryContext) BinElements() IBinElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinElementsContext)
}

func (s *BinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterBinary(s)
	}
}

func (s *BinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitBinary(s)
	}
}

func (p *ErlangParser) Binary() (localctx IBinaryContext) {
	this := p
	_ = this

	localctx = NewBinaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ErlangParserRULE_binary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(827)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(821)
			p.Match(ErlangParserT__21)
		}
		{
			p.SetState(822)
			p.Match(ErlangParserT__22)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(823)
			p.Match(ErlangParserT__21)
		}
		{
			p.SetState(824)
			p.BinElements()
		}
		{
			p.SetState(825)
			p.Match(ErlangParserT__22)
		}

	}

	return localctx
}

// IBinElementsContext is an interface to support dynamic dispatch.
type IBinElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinElementsContext differentiates from other interfaces.
	IsBinElementsContext()
}

type BinElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinElementsContext() *BinElementsContext {
	var p = new(BinElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_binElements
	return p
}

func (*BinElementsContext) IsBinElementsContext() {}

func NewBinElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinElementsContext {
	var p = new(BinElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_binElements

	return p
}

func (s *BinElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *BinElementsContext) AllBinElement() []IBinElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinElementContext)(nil)).Elem())
	var tst = make([]IBinElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinElementContext)
		}
	}

	return tst
}

func (s *BinElementsContext) BinElement(i int) IBinElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinElementContext)
}

func (s *BinElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterBinElements(s)
	}
}

func (s *BinElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitBinElements(s)
	}
}

func (p *ErlangParser) BinElements() (localctx IBinElementsContext) {
	this := p
	_ = this

	localctx = NewBinElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ErlangParserRULE_binElements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(829)
		p.BinElement()
	}
	p.SetState(834)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__5 {
		{
			p.SetState(830)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(831)
			p.BinElement()
		}

		p.SetState(836)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBinElementContext is an interface to support dynamic dispatch.
type IBinElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinElementContext differentiates from other interfaces.
	IsBinElementContext()
}

type BinElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinElementContext() *BinElementContext {
	var p = new(BinElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_binElement
	return p
}

func (*BinElementContext) IsBinElementContext() {}

func NewBinElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinElementContext {
	var p = new(BinElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_binElement

	return p
}

func (s *BinElementContext) GetParser() antlr.Parser { return s.parser }

func (s *BinElementContext) BitExpr() IBitExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *BinElementContext) OptBitSizeExpr() IOptBitSizeExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptBitSizeExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptBitSizeExprContext)
}

func (s *BinElementContext) OptBitTypeList() IOptBitTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptBitTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptBitTypeListContext)
}

func (s *BinElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterBinElement(s)
	}
}

func (s *BinElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitBinElement(s)
	}
}

func (p *ErlangParser) BinElement() (localctx IBinElementContext) {
	this := p
	_ = this

	localctx = NewBinElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ErlangParserRULE_binElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(837)
		p.BitExpr()
	}
	{
		p.SetState(838)
		p.OptBitSizeExpr()
	}
	{
		p.SetState(839)
		p.OptBitTypeList()
	}

	return localctx
}

// IBitExprContext is an interface to support dynamic dispatch.
type IBitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitExprContext differentiates from other interfaces.
	IsBitExprContext()
}

type BitExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitExprContext() *BitExprContext {
	var p = new(BitExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_bitExpr
	return p
}

func (*BitExprContext) IsBitExprContext() {}

func NewBitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitExprContext {
	var p = new(BitExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_bitExpr

	return p
}

func (s *BitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitExprContext) ExprMax() IExprMaxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprMaxContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprMaxContext)
}

func (s *BitExprContext) PrefixOp() IPrefixOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefixOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefixOpContext)
}

func (s *BitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterBitExpr(s)
	}
}

func (s *BitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitBitExpr(s)
	}
}

func (p *ErlangParser) BitExpr() (localctx IBitExprContext) {
	this := p
	_ = this

	localctx = NewBitExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ErlangParserRULE_bitExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(842)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserT__1 || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(ErlangParserT__41-42))|(1<<(ErlangParserT__42-42))|(1<<(ErlangParserT__43-42)))) != 0) {
		{
			p.SetState(841)
			p.PrefixOp()
		}

	}
	{
		p.SetState(844)
		p.ExprMax()
	}

	return localctx
}

// IOptBitSizeExprContext is an interface to support dynamic dispatch.
type IOptBitSizeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptBitSizeExprContext differentiates from other interfaces.
	IsOptBitSizeExprContext()
}

type OptBitSizeExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptBitSizeExprContext() *OptBitSizeExprContext {
	var p = new(OptBitSizeExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_optBitSizeExpr
	return p
}

func (*OptBitSizeExprContext) IsOptBitSizeExprContext() {}

func NewOptBitSizeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptBitSizeExprContext {
	var p = new(OptBitSizeExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_optBitSizeExpr

	return p
}

func (s *OptBitSizeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *OptBitSizeExprContext) BitSizeExpr() IBitSizeExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitSizeExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitSizeExprContext)
}

func (s *OptBitSizeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptBitSizeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptBitSizeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterOptBitSizeExpr(s)
	}
}

func (s *OptBitSizeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitOptBitSizeExpr(s)
	}
}

func (p *ErlangParser) OptBitSizeExpr() (localctx IOptBitSizeExprContext) {
	this := p
	_ = this

	localctx = NewOptBitSizeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ErlangParserRULE_optBitSizeExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(848)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserT__4 {
		{
			p.SetState(846)
			p.Match(ErlangParserT__4)
		}
		{
			p.SetState(847)
			p.BitSizeExpr()
		}

	}

	return localctx
}

// IOptBitTypeListContext is an interface to support dynamic dispatch.
type IOptBitTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptBitTypeListContext differentiates from other interfaces.
	IsOptBitTypeListContext()
}

type OptBitTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptBitTypeListContext() *OptBitTypeListContext {
	var p = new(OptBitTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_optBitTypeList
	return p
}

func (*OptBitTypeListContext) IsOptBitTypeListContext() {}

func NewOptBitTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptBitTypeListContext {
	var p = new(OptBitTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_optBitTypeList

	return p
}

func (s *OptBitTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *OptBitTypeListContext) BitTypeList() IBitTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitTypeListContext)
}

func (s *OptBitTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptBitTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptBitTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterOptBitTypeList(s)
	}
}

func (s *OptBitTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitOptBitTypeList(s)
	}
}

func (p *ErlangParser) OptBitTypeList() (localctx IOptBitTypeListContext) {
	this := p
	_ = this

	localctx = NewOptBitTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ErlangParserRULE_optBitTypeList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(852)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserT__31 {
		{
			p.SetState(850)
			p.Match(ErlangParserT__31)
		}
		{
			p.SetState(851)
			p.BitTypeList()
		}

	}

	return localctx
}

// IBitTypeListContext is an interface to support dynamic dispatch.
type IBitTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitTypeListContext differentiates from other interfaces.
	IsBitTypeListContext()
}

type BitTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitTypeListContext() *BitTypeListContext {
	var p = new(BitTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_bitTypeList
	return p
}

func (*BitTypeListContext) IsBitTypeListContext() {}

func NewBitTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitTypeListContext {
	var p = new(BitTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_bitTypeList

	return p
}

func (s *BitTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *BitTypeListContext) AllBitType() []IBitTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBitTypeContext)(nil)).Elem())
	var tst = make([]IBitTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBitTypeContext)
		}
	}

	return tst
}

func (s *BitTypeListContext) BitType(i int) IBitTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBitTypeContext)
}

func (s *BitTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterBitTypeList(s)
	}
}

func (s *BitTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitBitTypeList(s)
	}
}

func (p *ErlangParser) BitTypeList() (localctx IBitTypeListContext) {
	this := p
	_ = this

	localctx = NewBitTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ErlangParserRULE_bitTypeList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(854)
		p.BitType()
	}
	p.SetState(859)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__1 {
		{
			p.SetState(855)
			p.Match(ErlangParserT__1)
		}
		{
			p.SetState(856)
			p.BitType()
		}

		p.SetState(861)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBitTypeContext is an interface to support dynamic dispatch.
type IBitTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitTypeContext differentiates from other interfaces.
	IsBitTypeContext()
}

type BitTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitTypeContext() *BitTypeContext {
	var p = new(BitTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_bitType
	return p
}

func (*BitTypeContext) IsBitTypeContext() {}

func NewBitTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitTypeContext {
	var p = new(BitTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_bitType

	return p
}

func (s *BitTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BitTypeContext) TokAtom() ITokAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokAtomContext)
}

func (s *BitTypeContext) TokInteger() ITokIntegerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokIntegerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokIntegerContext)
}

func (s *BitTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterBitType(s)
	}
}

func (s *BitTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitBitType(s)
	}
}

func (p *ErlangParser) BitType() (localctx IBitTypeContext) {
	this := p
	_ = this

	localctx = NewBitTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ErlangParserRULE_bitType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(862)
		p.TokAtom()
	}
	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserT__4 {
		{
			p.SetState(863)
			p.Match(ErlangParserT__4)
		}
		{
			p.SetState(864)
			p.TokInteger()
		}

	}

	return localctx
}

// IBitSizeExprContext is an interface to support dynamic dispatch.
type IBitSizeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitSizeExprContext differentiates from other interfaces.
	IsBitSizeExprContext()
}

type BitSizeExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitSizeExprContext() *BitSizeExprContext {
	var p = new(BitSizeExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_bitSizeExpr
	return p
}

func (*BitSizeExprContext) IsBitSizeExprContext() {}

func NewBitSizeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitSizeExprContext {
	var p = new(BitSizeExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_bitSizeExpr

	return p
}

func (s *BitSizeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitSizeExprContext) ExprMax() IExprMaxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprMaxContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprMaxContext)
}

func (s *BitSizeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitSizeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitSizeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterBitSizeExpr(s)
	}
}

func (s *BitSizeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitBitSizeExpr(s)
	}
}

func (p *ErlangParser) BitSizeExpr() (localctx IBitSizeExprContext) {
	this := p
	_ = this

	localctx = NewBitSizeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ErlangParserRULE_bitSizeExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(867)
		p.ExprMax()
	}

	return localctx
}

// IListComprehensionContext is an interface to support dynamic dispatch.
type IListComprehensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListComprehensionContext differentiates from other interfaces.
	IsListComprehensionContext()
}

type ListComprehensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListComprehensionContext() *ListComprehensionContext {
	var p = new(ListComprehensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_listComprehension
	return p
}

func (*ListComprehensionContext) IsListComprehensionContext() {}

func NewListComprehensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListComprehensionContext {
	var p = new(ListComprehensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_listComprehension

	return p
}

func (s *ListComprehensionContext) GetParser() antlr.Parser { return s.parser }

func (s *ListComprehensionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ListComprehensionContext) LcExprs() ILcExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILcExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILcExprsContext)
}

func (s *ListComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListComprehensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListComprehensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterListComprehension(s)
	}
}

func (s *ListComprehensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitListComprehension(s)
	}
}

func (p *ErlangParser) ListComprehension() (localctx IListComprehensionContext) {
	this := p
	_ = this

	localctx = NewListComprehensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ErlangParserRULE_listComprehension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(869)
		p.Match(ErlangParserT__13)
	}
	{
		p.SetState(870)
		p.Expr()
	}
	{
		p.SetState(871)
		p.Match(ErlangParserT__32)
	}
	{
		p.SetState(872)
		p.LcExprs()
	}
	{
		p.SetState(873)
		p.Match(ErlangParserT__14)
	}

	return localctx
}

// IBinaryComprehensionContext is an interface to support dynamic dispatch.
type IBinaryComprehensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinaryComprehensionContext differentiates from other interfaces.
	IsBinaryComprehensionContext()
}

type BinaryComprehensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryComprehensionContext() *BinaryComprehensionContext {
	var p = new(BinaryComprehensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_binaryComprehension
	return p
}

func (*BinaryComprehensionContext) IsBinaryComprehensionContext() {}

func NewBinaryComprehensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryComprehensionContext {
	var p = new(BinaryComprehensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_binaryComprehension

	return p
}

func (s *BinaryComprehensionContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryComprehensionContext) ExprMax() IExprMaxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprMaxContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprMaxContext)
}

func (s *BinaryComprehensionContext) LcExprs() ILcExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILcExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILcExprsContext)
}

func (s *BinaryComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryComprehensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryComprehensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterBinaryComprehension(s)
	}
}

func (s *BinaryComprehensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitBinaryComprehension(s)
	}
}

func (p *ErlangParser) BinaryComprehension() (localctx IBinaryComprehensionContext) {
	this := p
	_ = this

	localctx = NewBinaryComprehensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ErlangParserRULE_binaryComprehension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(875)
		p.Match(ErlangParserT__21)
	}
	{
		p.SetState(876)
		p.ExprMax()
	}
	{
		p.SetState(877)
		p.Match(ErlangParserT__32)
	}
	{
		p.SetState(878)
		p.LcExprs()
	}
	{
		p.SetState(879)
		p.Match(ErlangParserT__22)
	}

	return localctx
}

// ILcExprsContext is an interface to support dynamic dispatch.
type ILcExprsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLcExprsContext differentiates from other interfaces.
	IsLcExprsContext()
}

type LcExprsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLcExprsContext() *LcExprsContext {
	var p = new(LcExprsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_lcExprs
	return p
}

func (*LcExprsContext) IsLcExprsContext() {}

func NewLcExprsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LcExprsContext {
	var p = new(LcExprsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_lcExprs

	return p
}

func (s *LcExprsContext) GetParser() antlr.Parser { return s.parser }

func (s *LcExprsContext) AllLcExpr() []ILcExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILcExprContext)(nil)).Elem())
	var tst = make([]ILcExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILcExprContext)
		}
	}

	return tst
}

func (s *LcExprsContext) LcExpr(i int) ILcExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILcExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILcExprContext)
}

func (s *LcExprsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LcExprsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LcExprsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterLcExprs(s)
	}
}

func (s *LcExprsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitLcExprs(s)
	}
}

func (p *ErlangParser) LcExprs() (localctx ILcExprsContext) {
	this := p
	_ = this

	localctx = NewLcExprsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ErlangParserRULE_lcExprs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(881)
		p.LcExpr()
	}
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__5 {
		{
			p.SetState(882)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(883)
			p.LcExpr()
		}

		p.SetState(888)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILcExprContext is an interface to support dynamic dispatch.
type ILcExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLcExprContext differentiates from other interfaces.
	IsLcExprContext()
}

type LcExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLcExprContext() *LcExprContext {
	var p = new(LcExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_lcExpr
	return p
}

func (*LcExprContext) IsLcExprContext() {}

func NewLcExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LcExprContext {
	var p = new(LcExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_lcExpr

	return p
}

func (s *LcExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LcExprContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *LcExprContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LcExprContext) Binary() IBinaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinaryContext)
}

func (s *LcExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LcExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LcExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterLcExpr(s)
	}
}

func (s *LcExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitLcExpr(s)
	}
}

func (p *ErlangParser) LcExpr() (localctx ILcExprContext) {
	this := p
	_ = this

	localctx = NewLcExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ErlangParserRULE_lcExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(898)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(889)
			p.Expr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(890)
			p.Expr()
		}
		{
			p.SetState(891)
			p.Match(ErlangParserT__33)
		}
		{
			p.SetState(892)
			p.Expr()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(894)
			p.Binary()
		}
		{
			p.SetState(895)
			p.Match(ErlangParserT__34)
		}
		{
			p.SetState(896)
			p.Expr()
		}

	}

	return localctx
}

// ITuple_Context is an interface to support dynamic dispatch.
type ITuple_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTuple_Context differentiates from other interfaces.
	IsTuple_Context()
}

type Tuple_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTuple_Context() *Tuple_Context {
	var p = new(Tuple_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_tuple_
	return p
}

func (*Tuple_Context) IsTuple_Context() {}

func NewTuple_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tuple_Context {
	var p = new(Tuple_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_tuple_

	return p
}

func (s *Tuple_Context) GetParser() antlr.Parser { return s.parser }

func (s *Tuple_Context) Exprs() IExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsContext)
}

func (s *Tuple_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tuple_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tuple_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTuple_(s)
	}
}

func (s *Tuple_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTuple_(s)
	}
}

func (p *ErlangParser) Tuple_() (localctx ITuple_Context) {
	this := p
	_ = this

	localctx = NewTuple_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ErlangParserRULE_tuple_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(900)
		p.Match(ErlangParserT__7)
	}
	p.SetState(902)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ErlangParserT__1)|(1<<ErlangParserT__2)|(1<<ErlangParserT__7)|(1<<ErlangParserT__13)|(1<<ErlangParserT__16)|(1<<ErlangParserT__17)|(1<<ErlangParserT__21)|(1<<ErlangParserT__24)|(1<<ErlangParserT__29))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ErlangParserT__35-36))|(1<<(ErlangParserT__36-36))|(1<<(ErlangParserT__38-36))|(1<<(ErlangParserT__40-36))|(1<<(ErlangParserT__41-36))|(1<<(ErlangParserT__42-36))|(1<<(ErlangParserT__43-36))|(1<<(ErlangParserTokAtom-36))|(1<<(ErlangParserTokVar-36))|(1<<(ErlangParserTokFloat-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(ErlangParserTokInteger-68))|(1<<(ErlangParserTokChar-68))|(1<<(ErlangParserTokString-68)))) != 0) {
		{
			p.SetState(901)
			p.Exprs()
		}

	}
	{
		p.SetState(904)
		p.Match(ErlangParserT__8)
	}

	return localctx
}

// IMapExprContext is an interface to support dynamic dispatch.
type IMapExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapExprContext differentiates from other interfaces.
	IsMapExprContext()
}

type MapExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapExprContext() *MapExprContext {
	var p = new(MapExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_mapExpr
	return p
}

func (*MapExprContext) IsMapExprContext() {}

func NewMapExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapExprContext {
	var p = new(MapExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_mapExpr

	return p
}

func (s *MapExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MapExprContext) MapTuple() IMapTupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapTupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapTupleContext)
}

func (s *MapExprContext) ExprMax() IExprMaxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprMaxContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprMaxContext)
}

func (s *MapExprContext) MapExpr() IMapExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapExprContext)
}

func (s *MapExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterMapExpr(s)
	}
}

func (s *MapExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitMapExpr(s)
	}
}

func (p *ErlangParser) MapExpr() (localctx IMapExprContext) {
	return p.mapExpr(0)
}

func (p *ErlangParser) mapExpr(_p int) (localctx IMapExprContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewMapExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMapExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 166
	p.EnterRecursionRule(localctx, 166, ErlangParserRULE_mapExpr, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(908)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ErlangParserT__2)|(1<<ErlangParserT__7)|(1<<ErlangParserT__13)|(1<<ErlangParserT__17)|(1<<ErlangParserT__21)|(1<<ErlangParserT__29))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ErlangParserT__35-36))|(1<<(ErlangParserT__36-36))|(1<<(ErlangParserT__38-36))|(1<<(ErlangParserT__40-36))|(1<<(ErlangParserTokAtom-36))|(1<<(ErlangParserTokVar-36))|(1<<(ErlangParserTokFloat-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(ErlangParserTokInteger-68))|(1<<(ErlangParserTokChar-68))|(1<<(ErlangParserTokString-68)))) != 0) {
		{
			p.SetState(907)
			p.ExprMax()
		}

	}
	{
		p.SetState(910)
		p.Match(ErlangParserT__16)
	}
	{
		p.SetState(911)
		p.MapTuple()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(918)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewMapExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ErlangParserRULE_mapExpr)
			p.SetState(913)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(914)
				p.Match(ErlangParserT__16)
			}
			{
				p.SetState(915)
				p.MapTuple()
			}

		}
		p.SetState(920)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())
	}

	return localctx
}

// IMapTupleContext is an interface to support dynamic dispatch.
type IMapTupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapTupleContext differentiates from other interfaces.
	IsMapTupleContext()
}

type MapTupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapTupleContext() *MapTupleContext {
	var p = new(MapTupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_mapTuple
	return p
}

func (*MapTupleContext) IsMapTupleContext() {}

func NewMapTupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapTupleContext {
	var p = new(MapTupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_mapTuple

	return p
}

func (s *MapTupleContext) GetParser() antlr.Parser { return s.parser }

func (s *MapTupleContext) AllMapField() []IMapFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMapFieldContext)(nil)).Elem())
	var tst = make([]IMapFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMapFieldContext)
		}
	}

	return tst
}

func (s *MapTupleContext) MapField(i int) IMapFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMapFieldContext)
}

func (s *MapTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapTupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapTupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterMapTuple(s)
	}
}

func (s *MapTupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitMapTuple(s)
	}
}

func (p *ErlangParser) MapTuple() (localctx IMapTupleContext) {
	this := p
	_ = this

	localctx = NewMapTupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ErlangParserRULE_mapTuple)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(921)
		p.Match(ErlangParserT__7)
	}
	p.SetState(930)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ErlangParserT__1)|(1<<ErlangParserT__2)|(1<<ErlangParserT__7)|(1<<ErlangParserT__13)|(1<<ErlangParserT__16)|(1<<ErlangParserT__17)|(1<<ErlangParserT__21)|(1<<ErlangParserT__24)|(1<<ErlangParserT__29))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ErlangParserT__35-36))|(1<<(ErlangParserT__36-36))|(1<<(ErlangParserT__38-36))|(1<<(ErlangParserT__40-36))|(1<<(ErlangParserT__41-36))|(1<<(ErlangParserT__42-36))|(1<<(ErlangParserT__43-36))|(1<<(ErlangParserTokAtom-36))|(1<<(ErlangParserTokVar-36))|(1<<(ErlangParserTokFloat-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(ErlangParserTokInteger-68))|(1<<(ErlangParserTokChar-68))|(1<<(ErlangParserTokString-68)))) != 0) {
		{
			p.SetState(922)
			p.MapField()
		}
		p.SetState(927)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ErlangParserT__5 {
			{
				p.SetState(923)
				p.Match(ErlangParserT__5)
			}
			{
				p.SetState(924)
				p.MapField()
			}

			p.SetState(929)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(932)
		p.Match(ErlangParserT__8)
	}

	return localctx
}

// IMapFieldContext is an interface to support dynamic dispatch.
type IMapFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapFieldContext differentiates from other interfaces.
	IsMapFieldContext()
}

type MapFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapFieldContext() *MapFieldContext {
	var p = new(MapFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_mapField
	return p
}

func (*MapFieldContext) IsMapFieldContext() {}

func NewMapFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapFieldContext {
	var p = new(MapFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_mapField

	return p
}

func (s *MapFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *MapFieldContext) MapFieldAssoc() IMapFieldAssocContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapFieldAssocContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapFieldAssocContext)
}

func (s *MapFieldContext) MapFieldExact() IMapFieldExactContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapFieldExactContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapFieldExactContext)
}

func (s *MapFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterMapField(s)
	}
}

func (s *MapFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitMapField(s)
	}
}

func (p *ErlangParser) MapField() (localctx IMapFieldContext) {
	this := p
	_ = this

	localctx = NewMapFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ErlangParserRULE_mapField)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(936)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(934)
			p.MapFieldAssoc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(935)
			p.MapFieldExact()
		}

	}

	return localctx
}

// IMapFieldAssocContext is an interface to support dynamic dispatch.
type IMapFieldAssocContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapFieldAssocContext differentiates from other interfaces.
	IsMapFieldAssocContext()
}

type MapFieldAssocContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapFieldAssocContext() *MapFieldAssocContext {
	var p = new(MapFieldAssocContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_mapFieldAssoc
	return p
}

func (*MapFieldAssocContext) IsMapFieldAssocContext() {}

func NewMapFieldAssocContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapFieldAssocContext {
	var p = new(MapFieldAssocContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_mapFieldAssoc

	return p
}

func (s *MapFieldAssocContext) GetParser() antlr.Parser { return s.parser }

func (s *MapFieldAssocContext) MapKey() IMapKeyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapKeyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapKeyContext)
}

func (s *MapFieldAssocContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MapFieldAssocContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapFieldAssocContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapFieldAssocContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterMapFieldAssoc(s)
	}
}

func (s *MapFieldAssocContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitMapFieldAssoc(s)
	}
}

func (p *ErlangParser) MapFieldAssoc() (localctx IMapFieldAssocContext) {
	this := p
	_ = this

	localctx = NewMapFieldAssocContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ErlangParserRULE_mapFieldAssoc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(938)
		p.MapKey()
	}
	{
		p.SetState(939)
		p.Match(ErlangParserT__19)
	}
	{
		p.SetState(940)
		p.Expr()
	}

	return localctx
}

// IMapFieldExactContext is an interface to support dynamic dispatch.
type IMapFieldExactContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapFieldExactContext differentiates from other interfaces.
	IsMapFieldExactContext()
}

type MapFieldExactContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapFieldExactContext() *MapFieldExactContext {
	var p = new(MapFieldExactContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_mapFieldExact
	return p
}

func (*MapFieldExactContext) IsMapFieldExactContext() {}

func NewMapFieldExactContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapFieldExactContext {
	var p = new(MapFieldExactContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_mapFieldExact

	return p
}

func (s *MapFieldExactContext) GetParser() antlr.Parser { return s.parser }

func (s *MapFieldExactContext) MapKey() IMapKeyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapKeyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapKeyContext)
}

func (s *MapFieldExactContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MapFieldExactContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapFieldExactContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapFieldExactContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterMapFieldExact(s)
	}
}

func (s *MapFieldExactContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitMapFieldExact(s)
	}
}

func (p *ErlangParser) MapFieldExact() (localctx IMapFieldExactContext) {
	this := p
	_ = this

	localctx = NewMapFieldExactContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ErlangParserRULE_mapFieldExact)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(942)
		p.MapKey()
	}
	{
		p.SetState(943)
		p.Match(ErlangParserT__20)
	}
	{
		p.SetState(944)
		p.Expr()
	}

	return localctx
}

// IMapKeyContext is an interface to support dynamic dispatch.
type IMapKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapKeyContext differentiates from other interfaces.
	IsMapKeyContext()
}

type MapKeyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapKeyContext() *MapKeyContext {
	var p = new(MapKeyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_mapKey
	return p
}

func (*MapKeyContext) IsMapKeyContext() {}

func NewMapKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapKeyContext {
	var p = new(MapKeyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_mapKey

	return p
}

func (s *MapKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *MapKeyContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MapKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterMapKey(s)
	}
}

func (s *MapKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitMapKey(s)
	}
}

func (p *ErlangParser) MapKey() (localctx IMapKeyContext) {
	this := p
	_ = this

	localctx = NewMapKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ErlangParserRULE_mapKey)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(946)
		p.Expr()
	}

	return localctx
}

// IRecordExprContext is an interface to support dynamic dispatch.
type IRecordExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordExprContext differentiates from other interfaces.
	IsRecordExprContext()
}

type RecordExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordExprContext() *RecordExprContext {
	var p = new(RecordExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_recordExpr
	return p
}

func (*RecordExprContext) IsRecordExprContext() {}

func NewRecordExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordExprContext {
	var p = new(RecordExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_recordExpr

	return p
}

func (s *RecordExprContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordExprContext) AllTokAtom() []ITokAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITokAtomContext)(nil)).Elem())
	var tst = make([]ITokAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITokAtomContext)
		}
	}

	return tst
}

func (s *RecordExprContext) TokAtom(i int) ITokAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITokAtomContext)
}

func (s *RecordExprContext) RecordTuple() IRecordTupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordTupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordTupleContext)
}

func (s *RecordExprContext) ExprMax() IExprMaxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprMaxContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprMaxContext)
}

func (s *RecordExprContext) RecordExpr() IRecordExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordExprContext)
}

func (s *RecordExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterRecordExpr(s)
	}
}

func (s *RecordExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitRecordExpr(s)
	}
}

func (p *ErlangParser) RecordExpr() (localctx IRecordExprContext) {
	return p.recordExpr(0)
}

func (p *ErlangParser) recordExpr(_p int) (localctx IRecordExprContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRecordExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRecordExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 178
	p.EnterRecursionRule(localctx, 178, ErlangParserRULE_recordExpr, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(950)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ErlangParserT__2)|(1<<ErlangParserT__7)|(1<<ErlangParserT__13)|(1<<ErlangParserT__17)|(1<<ErlangParserT__21)|(1<<ErlangParserT__29))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ErlangParserT__35-36))|(1<<(ErlangParserT__36-36))|(1<<(ErlangParserT__38-36))|(1<<(ErlangParserT__40-36))|(1<<(ErlangParserTokAtom-36))|(1<<(ErlangParserTokVar-36))|(1<<(ErlangParserTokFloat-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(ErlangParserTokInteger-68))|(1<<(ErlangParserTokChar-68))|(1<<(ErlangParserTokString-68)))) != 0) {
		{
			p.SetState(949)
			p.ExprMax()
		}

	}
	{
		p.SetState(952)
		p.Match(ErlangParserT__16)
	}
	{
		p.SetState(953)
		p.TokAtom()
	}
	p.SetState(957)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserT__0:
		{
			p.SetState(954)
			p.Match(ErlangParserT__0)
		}
		{
			p.SetState(955)
			p.TokAtom()
		}

	case ErlangParserT__7:
		{
			p.SetState(956)
			p.RecordTuple()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRecordExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ErlangParserRULE_recordExpr)
			p.SetState(959)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(960)
				p.Match(ErlangParserT__16)
			}
			{
				p.SetState(961)
				p.TokAtom()
			}
			p.SetState(965)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ErlangParserT__0:
				{
					p.SetState(962)
					p.Match(ErlangParserT__0)
				}
				{
					p.SetState(963)
					p.TokAtom()
				}

			case ErlangParserT__7:
				{
					p.SetState(964)
					p.RecordTuple()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(971)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())
	}

	return localctx
}

// IRecordTupleContext is an interface to support dynamic dispatch.
type IRecordTupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordTupleContext differentiates from other interfaces.
	IsRecordTupleContext()
}

type RecordTupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordTupleContext() *RecordTupleContext {
	var p = new(RecordTupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_recordTuple
	return p
}

func (*RecordTupleContext) IsRecordTupleContext() {}

func NewRecordTupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordTupleContext {
	var p = new(RecordTupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_recordTuple

	return p
}

func (s *RecordTupleContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordTupleContext) RecordFields() IRecordFieldsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordFieldsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordFieldsContext)
}

func (s *RecordTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordTupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordTupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterRecordTuple(s)
	}
}

func (s *RecordTupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitRecordTuple(s)
	}
}

func (p *ErlangParser) RecordTuple() (localctx IRecordTupleContext) {
	this := p
	_ = this

	localctx = NewRecordTupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ErlangParserRULE_recordTuple)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(972)
		p.Match(ErlangParserT__7)
	}
	p.SetState(974)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserTokAtom || _la == ErlangParserTokVar {
		{
			p.SetState(973)
			p.RecordFields()
		}

	}
	{
		p.SetState(976)
		p.Match(ErlangParserT__8)
	}

	return localctx
}

// IRecordFieldsContext is an interface to support dynamic dispatch.
type IRecordFieldsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordFieldsContext differentiates from other interfaces.
	IsRecordFieldsContext()
}

type RecordFieldsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordFieldsContext() *RecordFieldsContext {
	var p = new(RecordFieldsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_recordFields
	return p
}

func (*RecordFieldsContext) IsRecordFieldsContext() {}

func NewRecordFieldsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordFieldsContext {
	var p = new(RecordFieldsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_recordFields

	return p
}

func (s *RecordFieldsContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordFieldsContext) AllRecordField() []IRecordFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRecordFieldContext)(nil)).Elem())
	var tst = make([]IRecordFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRecordFieldContext)
		}
	}

	return tst
}

func (s *RecordFieldsContext) RecordField(i int) IRecordFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRecordFieldContext)
}

func (s *RecordFieldsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordFieldsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordFieldsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterRecordFields(s)
	}
}

func (s *RecordFieldsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitRecordFields(s)
	}
}

func (p *ErlangParser) RecordFields() (localctx IRecordFieldsContext) {
	this := p
	_ = this

	localctx = NewRecordFieldsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ErlangParserRULE_recordFields)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(978)
		p.RecordField()
	}
	p.SetState(983)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__5 {
		{
			p.SetState(979)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(980)
			p.RecordField()
		}

		p.SetState(985)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRecordFieldContext is an interface to support dynamic dispatch.
type IRecordFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordFieldContext differentiates from other interfaces.
	IsRecordFieldContext()
}

type RecordFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordFieldContext() *RecordFieldContext {
	var p = new(RecordFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_recordField
	return p
}

func (*RecordFieldContext) IsRecordFieldContext() {}

func NewRecordFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordFieldContext {
	var p = new(RecordFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_recordField

	return p
}

func (s *RecordFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordFieldContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *RecordFieldContext) TokVar() ITokVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokVarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokVarContext)
}

func (s *RecordFieldContext) TokAtom() ITokAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokAtomContext)
}

func (s *RecordFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterRecordField(s)
	}
}

func (s *RecordFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitRecordField(s)
	}
}

func (p *ErlangParser) RecordField() (localctx IRecordFieldContext) {
	this := p
	_ = this

	localctx = NewRecordFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ErlangParserRULE_recordField)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(988)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserTokVar:
		{
			p.SetState(986)
			p.TokVar()
		}

	case ErlangParserTokAtom:
		{
			p.SetState(987)
			p.TokAtom()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(990)
		p.Match(ErlangParserT__25)
	}
	{
		p.SetState(991)
		p.Expr()
	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) Expr800() IExpr800Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr800Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr800Context)
}

func (s *FunctionCallContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (p *ErlangParser) FunctionCall() (localctx IFunctionCallContext) {
	this := p
	_ = this

	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ErlangParserRULE_functionCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(993)
		p.Expr800()
	}
	{
		p.SetState(994)
		p.ArgumentList()
	}

	return localctx
}

// IIfExprContext is an interface to support dynamic dispatch.
type IIfExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfExprContext differentiates from other interfaces.
	IsIfExprContext()
}

type IfExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExprContext() *IfExprContext {
	var p = new(IfExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_ifExpr
	return p
}

func (*IfExprContext) IsIfExprContext() {}

func NewIfExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExprContext {
	var p = new(IfExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_ifExpr

	return p
}

func (s *IfExprContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExprContext) IfClauses() IIfClausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfClausesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfClausesContext)
}

func (s *IfExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterIfExpr(s)
	}
}

func (s *IfExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitIfExpr(s)
	}
}

func (p *ErlangParser) IfExpr() (localctx IIfExprContext) {
	this := p
	_ = this

	localctx = NewIfExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ErlangParserRULE_ifExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(996)
		p.Match(ErlangParserT__35)
	}
	{
		p.SetState(997)
		p.IfClauses()
	}
	{
		p.SetState(998)
		p.Match(ErlangParserT__30)
	}

	return localctx
}

// IIfClausesContext is an interface to support dynamic dispatch.
type IIfClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfClausesContext differentiates from other interfaces.
	IsIfClausesContext()
}

type IfClausesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfClausesContext() *IfClausesContext {
	var p = new(IfClausesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_ifClauses
	return p
}

func (*IfClausesContext) IsIfClausesContext() {}

func NewIfClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfClausesContext {
	var p = new(IfClausesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_ifClauses

	return p
}

func (s *IfClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *IfClausesContext) AllIfClause() []IIfClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIfClauseContext)(nil)).Elem())
	var tst = make([]IIfClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIfClauseContext)
		}
	}

	return tst
}

func (s *IfClausesContext) IfClause(i int) IIfClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIfClauseContext)
}

func (s *IfClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterIfClauses(s)
	}
}

func (s *IfClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitIfClauses(s)
	}
}

func (p *ErlangParser) IfClauses() (localctx IIfClausesContext) {
	this := p
	_ = this

	localctx = NewIfClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ErlangParserRULE_ifClauses)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1000)
		p.IfClause()
	}
	p.SetState(1005)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__9 {
		{
			p.SetState(1001)
			p.Match(ErlangParserT__9)
		}
		{
			p.SetState(1002)
			p.IfClause()
		}

		p.SetState(1007)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIfClauseContext is an interface to support dynamic dispatch.
type IIfClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfClauseContext differentiates from other interfaces.
	IsIfClauseContext()
}

type IfClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfClauseContext() *IfClauseContext {
	var p = new(IfClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_ifClause
	return p
}

func (*IfClauseContext) IsIfClauseContext() {}

func NewIfClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfClauseContext {
	var p = new(IfClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_ifClause

	return p
}

func (s *IfClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IfClauseContext) Guard_() IGuard_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGuard_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGuard_Context)
}

func (s *IfClauseContext) ClauseBody() IClauseBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClauseBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClauseBodyContext)
}

func (s *IfClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterIfClause(s)
	}
}

func (s *IfClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitIfClause(s)
	}
}

func (p *ErlangParser) IfClause() (localctx IIfClauseContext) {
	this := p
	_ = this

	localctx = NewIfClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ErlangParserRULE_ifClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1008)
		p.Guard_()
	}
	{
		p.SetState(1009)
		p.ClauseBody()
	}

	return localctx
}

// ICaseExprContext is an interface to support dynamic dispatch.
type ICaseExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseExprContext differentiates from other interfaces.
	IsCaseExprContext()
}

type CaseExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExprContext() *CaseExprContext {
	var p = new(CaseExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_caseExpr
	return p
}

func (*CaseExprContext) IsCaseExprContext() {}

func NewCaseExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExprContext {
	var p = new(CaseExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_caseExpr

	return p
}

func (s *CaseExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CaseExprContext) CrClauses() ICrClausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrClausesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrClausesContext)
}

func (s *CaseExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterCaseExpr(s)
	}
}

func (s *CaseExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitCaseExpr(s)
	}
}

func (p *ErlangParser) CaseExpr() (localctx ICaseExprContext) {
	this := p
	_ = this

	localctx = NewCaseExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ErlangParserRULE_caseExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1011)
		p.Match(ErlangParserT__36)
	}
	{
		p.SetState(1012)
		p.Expr()
	}
	{
		p.SetState(1013)
		p.Match(ErlangParserT__37)
	}
	{
		p.SetState(1014)
		p.CrClauses()
	}
	{
		p.SetState(1015)
		p.Match(ErlangParserT__30)
	}

	return localctx
}

// ICrClausesContext is an interface to support dynamic dispatch.
type ICrClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCrClausesContext differentiates from other interfaces.
	IsCrClausesContext()
}

type CrClausesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrClausesContext() *CrClausesContext {
	var p = new(CrClausesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_crClauses
	return p
}

func (*CrClausesContext) IsCrClausesContext() {}

func NewCrClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrClausesContext {
	var p = new(CrClausesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_crClauses

	return p
}

func (s *CrClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *CrClausesContext) AllCrClause() []ICrClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICrClauseContext)(nil)).Elem())
	var tst = make([]ICrClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICrClauseContext)
		}
	}

	return tst
}

func (s *CrClausesContext) CrClause(i int) ICrClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICrClauseContext)
}

func (s *CrClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterCrClauses(s)
	}
}

func (s *CrClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitCrClauses(s)
	}
}

func (p *ErlangParser) CrClauses() (localctx ICrClausesContext) {
	this := p
	_ = this

	localctx = NewCrClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ErlangParserRULE_crClauses)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1017)
		p.CrClause()
	}
	p.SetState(1022)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__9 {
		{
			p.SetState(1018)
			p.Match(ErlangParserT__9)
		}
		{
			p.SetState(1019)
			p.CrClause()
		}

		p.SetState(1024)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICrClauseContext is an interface to support dynamic dispatch.
type ICrClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCrClauseContext differentiates from other interfaces.
	IsCrClauseContext()
}

type CrClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrClauseContext() *CrClauseContext {
	var p = new(CrClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_crClause
	return p
}

func (*CrClauseContext) IsCrClauseContext() {}

func NewCrClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrClauseContext {
	var p = new(CrClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_crClause

	return p
}

func (s *CrClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CrClauseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CrClauseContext) ClauseGuard() IClauseGuardContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClauseGuardContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClauseGuardContext)
}

func (s *CrClauseContext) ClauseBody() IClauseBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClauseBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClauseBodyContext)
}

func (s *CrClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterCrClause(s)
	}
}

func (s *CrClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitCrClause(s)
	}
}

func (p *ErlangParser) CrClause() (localctx ICrClauseContext) {
	this := p
	_ = this

	localctx = NewCrClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ErlangParserRULE_crClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1025)
		p.Expr()
	}
	{
		p.SetState(1026)
		p.ClauseGuard()
	}
	{
		p.SetState(1027)
		p.ClauseBody()
	}

	return localctx
}

// IReceiveExprContext is an interface to support dynamic dispatch.
type IReceiveExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveExprContext differentiates from other interfaces.
	IsReceiveExprContext()
}

type ReceiveExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveExprContext() *ReceiveExprContext {
	var p = new(ReceiveExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_receiveExpr
	return p
}

func (*ReceiveExprContext) IsReceiveExprContext() {}

func NewReceiveExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveExprContext {
	var p = new(ReceiveExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_receiveExpr

	return p
}

func (s *ReceiveExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveExprContext) CrClauses() ICrClausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrClausesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrClausesContext)
}

func (s *ReceiveExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ReceiveExprContext) ClauseBody() IClauseBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClauseBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClauseBodyContext)
}

func (s *ReceiveExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterReceiveExpr(s)
	}
}

func (s *ReceiveExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitReceiveExpr(s)
	}
}

func (p *ErlangParser) ReceiveExpr() (localctx IReceiveExprContext) {
	this := p
	_ = this

	localctx = NewReceiveExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ErlangParserRULE_receiveExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1046)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1029)
			p.Match(ErlangParserT__38)
		}
		{
			p.SetState(1030)
			p.CrClauses()
		}
		{
			p.SetState(1031)
			p.Match(ErlangParserT__30)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1033)
			p.Match(ErlangParserT__38)
		}
		{
			p.SetState(1034)
			p.Match(ErlangParserT__39)
		}
		{
			p.SetState(1035)
			p.Expr()
		}
		{
			p.SetState(1036)
			p.ClauseBody()
		}
		{
			p.SetState(1037)
			p.Match(ErlangParserT__30)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1039)
			p.Match(ErlangParserT__38)
		}
		{
			p.SetState(1040)
			p.CrClauses()
		}
		{
			p.SetState(1041)
			p.Match(ErlangParserT__39)
		}
		{
			p.SetState(1042)
			p.Expr()
		}
		{
			p.SetState(1043)
			p.ClauseBody()
		}
		{
			p.SetState(1044)
			p.Match(ErlangParserT__30)
		}

	}

	return localctx
}

// IFunExprContext is an interface to support dynamic dispatch.
type IFunExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunExprContext differentiates from other interfaces.
	IsFunExprContext()
}

type FunExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunExprContext() *FunExprContext {
	var p = new(FunExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_funExpr
	return p
}

func (*FunExprContext) IsFunExprContext() {}

func NewFunExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunExprContext {
	var p = new(FunExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_funExpr

	return p
}

func (s *FunExprContext) GetParser() antlr.Parser { return s.parser }

func (s *FunExprContext) TokAtom() ITokAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokAtomContext)
}

func (s *FunExprContext) TokInteger() ITokIntegerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokIntegerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokIntegerContext)
}

func (s *FunExprContext) AllAtomOrVar() []IAtomOrVarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtomOrVarContext)(nil)).Elem())
	var tst = make([]IAtomOrVarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtomOrVarContext)
		}
	}

	return tst
}

func (s *FunExprContext) AtomOrVar(i int) IAtomOrVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomOrVarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtomOrVarContext)
}

func (s *FunExprContext) IntegerOrVar() IIntegerOrVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerOrVarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerOrVarContext)
}

func (s *FunExprContext) FunClauses() IFunClausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunClausesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunClausesContext)
}

func (s *FunExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterFunExpr(s)
	}
}

func (s *FunExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitFunExpr(s)
	}
}

func (p *ErlangParser) FunExpr() (localctx IFunExprContext) {
	this := p
	_ = this

	localctx = NewFunExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ErlangParserRULE_funExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1064)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1048)
			p.Match(ErlangParserT__17)
		}
		{
			p.SetState(1049)
			p.TokAtom()
		}
		{
			p.SetState(1050)
			p.Match(ErlangParserT__31)
		}
		{
			p.SetState(1051)
			p.TokInteger()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1053)
			p.Match(ErlangParserT__17)
		}
		{
			p.SetState(1054)
			p.AtomOrVar()
		}
		{
			p.SetState(1055)
			p.Match(ErlangParserT__4)
		}
		{
			p.SetState(1056)
			p.AtomOrVar()
		}
		{
			p.SetState(1057)
			p.Match(ErlangParserT__31)
		}
		{
			p.SetState(1058)
			p.IntegerOrVar()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1060)
			p.Match(ErlangParserT__17)
		}
		{
			p.SetState(1061)
			p.FunClauses()
		}
		{
			p.SetState(1062)
			p.Match(ErlangParserT__30)
		}

	}

	return localctx
}

// IAtomOrVarContext is an interface to support dynamic dispatch.
type IAtomOrVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomOrVarContext differentiates from other interfaces.
	IsAtomOrVarContext()
}

type AtomOrVarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomOrVarContext() *AtomOrVarContext {
	var p = new(AtomOrVarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_atomOrVar
	return p
}

func (*AtomOrVarContext) IsAtomOrVarContext() {}

func NewAtomOrVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomOrVarContext {
	var p = new(AtomOrVarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_atomOrVar

	return p
}

func (s *AtomOrVarContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomOrVarContext) TokAtom() ITokAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokAtomContext)
}

func (s *AtomOrVarContext) TokVar() ITokVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokVarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokVarContext)
}

func (s *AtomOrVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomOrVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomOrVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterAtomOrVar(s)
	}
}

func (s *AtomOrVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitAtomOrVar(s)
	}
}

func (p *ErlangParser) AtomOrVar() (localctx IAtomOrVarContext) {
	this := p
	_ = this

	localctx = NewAtomOrVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ErlangParserRULE_atomOrVar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1068)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserTokAtom:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1066)
			p.TokAtom()
		}

	case ErlangParserTokVar:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1067)
			p.TokVar()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIntegerOrVarContext is an interface to support dynamic dispatch.
type IIntegerOrVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerOrVarContext differentiates from other interfaces.
	IsIntegerOrVarContext()
}

type IntegerOrVarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerOrVarContext() *IntegerOrVarContext {
	var p = new(IntegerOrVarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_integerOrVar
	return p
}

func (*IntegerOrVarContext) IsIntegerOrVarContext() {}

func NewIntegerOrVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerOrVarContext {
	var p = new(IntegerOrVarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_integerOrVar

	return p
}

func (s *IntegerOrVarContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerOrVarContext) TokInteger() ITokIntegerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokIntegerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokIntegerContext)
}

func (s *IntegerOrVarContext) TokVar() ITokVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokVarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokVarContext)
}

func (s *IntegerOrVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerOrVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerOrVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterIntegerOrVar(s)
	}
}

func (s *IntegerOrVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitIntegerOrVar(s)
	}
}

func (p *ErlangParser) IntegerOrVar() (localctx IIntegerOrVarContext) {
	this := p
	_ = this

	localctx = NewIntegerOrVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ErlangParserRULE_integerOrVar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1072)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserTokInteger:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1070)
			p.TokInteger()
		}

	case ErlangParserTokVar:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1071)
			p.TokVar()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunClausesContext is an interface to support dynamic dispatch.
type IFunClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunClausesContext differentiates from other interfaces.
	IsFunClausesContext()
}

type FunClausesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunClausesContext() *FunClausesContext {
	var p = new(FunClausesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_funClauses
	return p
}

func (*FunClausesContext) IsFunClausesContext() {}

func NewFunClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunClausesContext {
	var p = new(FunClausesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_funClauses

	return p
}

func (s *FunClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *FunClausesContext) AllFunClause() []IFunClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunClauseContext)(nil)).Elem())
	var tst = make([]IFunClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunClauseContext)
		}
	}

	return tst
}

func (s *FunClausesContext) FunClause(i int) IFunClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunClauseContext)
}

func (s *FunClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterFunClauses(s)
	}
}

func (s *FunClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitFunClauses(s)
	}
}

func (p *ErlangParser) FunClauses() (localctx IFunClausesContext) {
	this := p
	_ = this

	localctx = NewFunClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ErlangParserRULE_funClauses)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1074)
		p.FunClause()
	}
	p.SetState(1079)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__9 {
		{
			p.SetState(1075)
			p.Match(ErlangParserT__9)
		}
		{
			p.SetState(1076)
			p.FunClause()
		}

		p.SetState(1081)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFunClauseContext is an interface to support dynamic dispatch.
type IFunClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunClauseContext differentiates from other interfaces.
	IsFunClauseContext()
}

type FunClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunClauseContext() *FunClauseContext {
	var p = new(FunClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_funClause
	return p
}

func (*FunClauseContext) IsFunClauseContext() {}

func NewFunClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunClauseContext {
	var p = new(FunClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_funClause

	return p
}

func (s *FunClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FunClauseContext) PatArgumentList() IPatArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatArgumentListContext)
}

func (s *FunClauseContext) ClauseGuard() IClauseGuardContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClauseGuardContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClauseGuardContext)
}

func (s *FunClauseContext) ClauseBody() IClauseBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClauseBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClauseBodyContext)
}

func (s *FunClauseContext) TokVar() ITokVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokVarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokVarContext)
}

func (s *FunClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterFunClause(s)
	}
}

func (s *FunClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitFunClause(s)
	}
}

func (p *ErlangParser) FunClause() (localctx IFunClauseContext) {
	this := p
	_ = this

	localctx = NewFunClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ErlangParserRULE_funClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1091)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserT__2:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1082)
			p.PatArgumentList()
		}
		{
			p.SetState(1083)
			p.ClauseGuard()
		}
		{
			p.SetState(1084)
			p.ClauseBody()
		}

	case ErlangParserTokVar:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1086)
			p.TokVar()
		}
		{
			p.SetState(1087)
			p.PatArgumentList()
		}
		{
			p.SetState(1088)
			p.ClauseGuard()
		}
		{
			p.SetState(1089)
			p.ClauseBody()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITryExprContext is an interface to support dynamic dispatch.
type ITryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryExprContext differentiates from other interfaces.
	IsTryExprContext()
}

type TryExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryExprContext() *TryExprContext {
	var p = new(TryExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_tryExpr
	return p
}

func (*TryExprContext) IsTryExprContext() {}

func NewTryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryExprContext {
	var p = new(TryExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_tryExpr

	return p
}

func (s *TryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TryExprContext) Exprs() IExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsContext)
}

func (s *TryExprContext) TryCatch() ITryCatchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryCatchContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryCatchContext)
}

func (s *TryExprContext) CrClauses() ICrClausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrClausesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrClausesContext)
}

func (s *TryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTryExpr(s)
	}
}

func (s *TryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTryExpr(s)
	}
}

func (p *ErlangParser) TryExpr() (localctx ITryExprContext) {
	this := p
	_ = this

	localctx = NewTryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ErlangParserRULE_tryExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1093)
		p.Match(ErlangParserT__40)
	}
	{
		p.SetState(1094)
		p.Exprs()
	}
	p.SetState(1097)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserT__37 {
		{
			p.SetState(1095)
			p.Match(ErlangParserT__37)
		}
		{
			p.SetState(1096)
			p.CrClauses()
		}

	}
	{
		p.SetState(1099)
		p.TryCatch()
	}

	return localctx
}

// ITryCatchContext is an interface to support dynamic dispatch.
type ITryCatchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryCatchContext differentiates from other interfaces.
	IsTryCatchContext()
}

type TryCatchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryCatchContext() *TryCatchContext {
	var p = new(TryCatchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_tryCatch
	return p
}

func (*TryCatchContext) IsTryCatchContext() {}

func NewTryCatchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryCatchContext {
	var p = new(TryCatchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_tryCatch

	return p
}

func (s *TryCatchContext) GetParser() antlr.Parser { return s.parser }

func (s *TryCatchContext) TryClauses() ITryClausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryClausesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryClausesContext)
}

func (s *TryCatchContext) Exprs() IExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsContext)
}

func (s *TryCatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryCatchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryCatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTryCatch(s)
	}
}

func (s *TryCatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTryCatch(s)
	}
}

func (p *ErlangParser) TryCatch() (localctx ITryCatchContext) {
	this := p
	_ = this

	localctx = NewTryCatchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, ErlangParserRULE_tryCatch)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1115)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1101)
			p.Match(ErlangParserT__24)
		}
		{
			p.SetState(1102)
			p.TryClauses()
		}
		{
			p.SetState(1103)
			p.Match(ErlangParserT__30)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1105)
			p.Match(ErlangParserT__24)
		}
		{
			p.SetState(1106)
			p.TryClauses()
		}
		{
			p.SetState(1107)
			p.Match(ErlangParserT__39)
		}
		{
			p.SetState(1108)
			p.Exprs()
		}
		{
			p.SetState(1109)
			p.Match(ErlangParserT__30)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1111)
			p.Match(ErlangParserT__39)
		}
		{
			p.SetState(1112)
			p.Exprs()
		}
		{
			p.SetState(1113)
			p.Match(ErlangParserT__30)
		}

	}

	return localctx
}

// ITryClausesContext is an interface to support dynamic dispatch.
type ITryClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryClausesContext differentiates from other interfaces.
	IsTryClausesContext()
}

type TryClausesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryClausesContext() *TryClausesContext {
	var p = new(TryClausesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_tryClauses
	return p
}

func (*TryClausesContext) IsTryClausesContext() {}

func NewTryClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryClausesContext {
	var p = new(TryClausesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_tryClauses

	return p
}

func (s *TryClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *TryClausesContext) AllTryClause() []ITryClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITryClauseContext)(nil)).Elem())
	var tst = make([]ITryClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITryClauseContext)
		}
	}

	return tst
}

func (s *TryClausesContext) TryClause(i int) ITryClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITryClauseContext)
}

func (s *TryClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTryClauses(s)
	}
}

func (s *TryClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTryClauses(s)
	}
}

func (p *ErlangParser) TryClauses() (localctx ITryClausesContext) {
	this := p
	_ = this

	localctx = NewTryClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, ErlangParserRULE_tryClauses)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1117)
		p.TryClause()
	}
	p.SetState(1122)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__9 {
		{
			p.SetState(1118)
			p.Match(ErlangParserT__9)
		}
		{
			p.SetState(1119)
			p.TryClause()
		}

		p.SetState(1124)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITryClauseContext is an interface to support dynamic dispatch.
type ITryClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryClauseContext differentiates from other interfaces.
	IsTryClauseContext()
}

type TryClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryClauseContext() *TryClauseContext {
	var p = new(TryClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_tryClause
	return p
}

func (*TryClauseContext) IsTryClauseContext() {}

func NewTryClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryClauseContext {
	var p = new(TryClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_tryClause

	return p
}

func (s *TryClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TryClauseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TryClauseContext) ClauseGuard() IClauseGuardContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClauseGuardContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClauseGuardContext)
}

func (s *TryClauseContext) ClauseBody() IClauseBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClauseBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClauseBodyContext)
}

func (s *TryClauseContext) PatExpr() IPatExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExprContext)
}

func (s *TryClauseContext) TryOptStackTrace() ITryOptStackTraceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryOptStackTraceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryOptStackTraceContext)
}

func (s *TryClauseContext) AtomOrVar() IAtomOrVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomOrVarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomOrVarContext)
}

func (s *TryClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTryClause(s)
	}
}

func (s *TryClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTryClause(s)
	}
}

func (p *ErlangParser) TryClause() (localctx ITryClauseContext) {
	this := p
	_ = this

	localctx = NewTryClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, ErlangParserRULE_tryClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1139)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1125)
			p.Expr()
		}
		{
			p.SetState(1126)
			p.ClauseGuard()
		}
		{
			p.SetState(1127)
			p.ClauseBody()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1132)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1129)
				p.AtomOrVar()
			}
			{
				p.SetState(1130)
				p.Match(ErlangParserT__4)
			}

		}
		{
			p.SetState(1134)
			p.PatExpr()
		}
		{
			p.SetState(1135)
			p.TryOptStackTrace()
		}
		{
			p.SetState(1136)
			p.ClauseGuard()
		}
		{
			p.SetState(1137)
			p.ClauseBody()
		}

	}

	return localctx
}

// ITryOptStackTraceContext is an interface to support dynamic dispatch.
type ITryOptStackTraceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryOptStackTraceContext differentiates from other interfaces.
	IsTryOptStackTraceContext()
}

type TryOptStackTraceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryOptStackTraceContext() *TryOptStackTraceContext {
	var p = new(TryOptStackTraceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_tryOptStackTrace
	return p
}

func (*TryOptStackTraceContext) IsTryOptStackTraceContext() {}

func NewTryOptStackTraceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryOptStackTraceContext {
	var p = new(TryOptStackTraceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_tryOptStackTrace

	return p
}

func (s *TryOptStackTraceContext) GetParser() antlr.Parser { return s.parser }

func (s *TryOptStackTraceContext) TokVar() ITokVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokVarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokVarContext)
}

func (s *TryOptStackTraceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryOptStackTraceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryOptStackTraceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterTryOptStackTrace(s)
	}
}

func (s *TryOptStackTraceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitTryOptStackTrace(s)
	}
}

func (p *ErlangParser) TryOptStackTrace() (localctx ITryOptStackTraceContext) {
	this := p
	_ = this

	localctx = NewTryOptStackTraceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, ErlangParserRULE_tryOptStackTrace)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1143)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ErlangParserT__4 {
		{
			p.SetState(1141)
			p.Match(ErlangParserT__4)
		}
		{
			p.SetState(1142)
			p.TokVar()
		}

	}

	return localctx
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_argumentList
	return p
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) Exprs() IExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *ErlangParser) ArgumentList() (localctx IArgumentListContext) {
	this := p
	_ = this

	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, ErlangParserRULE_argumentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1145)
		p.Match(ErlangParserT__2)
	}
	p.SetState(1147)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ErlangParserT__1)|(1<<ErlangParserT__2)|(1<<ErlangParserT__7)|(1<<ErlangParserT__13)|(1<<ErlangParserT__16)|(1<<ErlangParserT__17)|(1<<ErlangParserT__21)|(1<<ErlangParserT__24)|(1<<ErlangParserT__29))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ErlangParserT__35-36))|(1<<(ErlangParserT__36-36))|(1<<(ErlangParserT__38-36))|(1<<(ErlangParserT__40-36))|(1<<(ErlangParserT__41-36))|(1<<(ErlangParserT__42-36))|(1<<(ErlangParserT__43-36))|(1<<(ErlangParserTokAtom-36))|(1<<(ErlangParserTokVar-36))|(1<<(ErlangParserTokFloat-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(ErlangParserTokInteger-68))|(1<<(ErlangParserTokChar-68))|(1<<(ErlangParserTokString-68)))) != 0) {
		{
			p.SetState(1146)
			p.Exprs()
		}

	}
	{
		p.SetState(1149)
		p.Match(ErlangParserT__3)
	}

	return localctx
}

// IPatArgumentListContext is an interface to support dynamic dispatch.
type IPatArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatArgumentListContext differentiates from other interfaces.
	IsPatArgumentListContext()
}

type PatArgumentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatArgumentListContext() *PatArgumentListContext {
	var p = new(PatArgumentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_patArgumentList
	return p
}

func (*PatArgumentListContext) IsPatArgumentListContext() {}

func NewPatArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatArgumentListContext {
	var p = new(PatArgumentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_patArgumentList

	return p
}

func (s *PatArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *PatArgumentListContext) PatExprs() IPatExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatExprsContext)
}

func (s *PatArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterPatArgumentList(s)
	}
}

func (s *PatArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitPatArgumentList(s)
	}
}

func (p *ErlangParser) PatArgumentList() (localctx IPatArgumentListContext) {
	this := p
	_ = this

	localctx = NewPatArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, ErlangParserRULE_patArgumentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1151)
		p.Match(ErlangParserT__2)
	}
	p.SetState(1153)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ErlangParserT__1)|(1<<ErlangParserT__2)|(1<<ErlangParserT__7)|(1<<ErlangParserT__13)|(1<<ErlangParserT__16)|(1<<ErlangParserT__21))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(ErlangParserT__41-42))|(1<<(ErlangParserT__42-42))|(1<<(ErlangParserT__43-42))|(1<<(ErlangParserTokAtom-42))|(1<<(ErlangParserTokVar-42))|(1<<(ErlangParserTokFloat-42))|(1<<(ErlangParserTokInteger-42))|(1<<(ErlangParserTokChar-42))|(1<<(ErlangParserTokString-42)))) != 0) {
		{
			p.SetState(1152)
			p.PatExprs()
		}

	}
	{
		p.SetState(1155)
		p.Match(ErlangParserT__3)
	}

	return localctx
}

// IExprsContext is an interface to support dynamic dispatch.
type IExprsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprsContext differentiates from other interfaces.
	IsExprsContext()
}

type ExprsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprsContext() *ExprsContext {
	var p = new(ExprsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_exprs
	return p
}

func (*ExprsContext) IsExprsContext() {}

func NewExprsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprsContext {
	var p = new(ExprsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_exprs

	return p
}

func (s *ExprsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprsContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprsContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterExprs(s)
	}
}

func (s *ExprsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitExprs(s)
	}
}

func (p *ErlangParser) Exprs() (localctx IExprsContext) {
	this := p
	_ = this

	localctx = NewExprsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, ErlangParserRULE_exprs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1157)
		p.Expr()
	}
	p.SetState(1162)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__5 {
		{
			p.SetState(1158)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(1159)
			p.Expr()
		}

		p.SetState(1164)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPatExprsContext is an interface to support dynamic dispatch.
type IPatExprsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatExprsContext differentiates from other interfaces.
	IsPatExprsContext()
}

type PatExprsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatExprsContext() *PatExprsContext {
	var p = new(PatExprsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_patExprs
	return p
}

func (*PatExprsContext) IsPatExprsContext() {}

func NewPatExprsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatExprsContext {
	var p = new(PatExprsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_patExprs

	return p
}

func (s *PatExprsContext) GetParser() antlr.Parser { return s.parser }

func (s *PatExprsContext) AllPatExpr() []IPatExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPatExprContext)(nil)).Elem())
	var tst = make([]IPatExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPatExprContext)
		}
	}

	return tst
}

func (s *PatExprsContext) PatExpr(i int) IPatExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPatExprContext)
}

func (s *PatExprsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatExprsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatExprsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterPatExprs(s)
	}
}

func (s *PatExprsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitPatExprs(s)
	}
}

func (p *ErlangParser) PatExprs() (localctx IPatExprsContext) {
	this := p
	_ = this

	localctx = NewPatExprsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, ErlangParserRULE_patExprs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1165)
		p.PatExpr()
	}
	p.SetState(1170)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__5 {
		{
			p.SetState(1166)
			p.Match(ErlangParserT__5)
		}
		{
			p.SetState(1167)
			p.PatExpr()
		}

		p.SetState(1172)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGuard_Context is an interface to support dynamic dispatch.
type IGuard_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGuard_Context differentiates from other interfaces.
	IsGuard_Context()
}

type Guard_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGuard_Context() *Guard_Context {
	var p = new(Guard_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_guard_
	return p
}

func (*Guard_Context) IsGuard_Context() {}

func NewGuard_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Guard_Context {
	var p = new(Guard_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_guard_

	return p
}

func (s *Guard_Context) GetParser() antlr.Parser { return s.parser }

func (s *Guard_Context) AllExprs() []IExprsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprsContext)(nil)).Elem())
	var tst = make([]IExprsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprsContext)
		}
	}

	return tst
}

func (s *Guard_Context) Exprs(i int) IExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprsContext)
}

func (s *Guard_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Guard_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Guard_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterGuard_(s)
	}
}

func (s *Guard_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitGuard_(s)
	}
}

func (p *ErlangParser) Guard_() (localctx IGuard_Context) {
	this := p
	_ = this

	localctx = NewGuard_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, ErlangParserRULE_guard_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1173)
		p.Exprs()
	}
	p.SetState(1178)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ErlangParserT__9 {
		{
			p.SetState(1174)
			p.Match(ErlangParserT__9)
		}
		{
			p.SetState(1175)
			p.Exprs()
		}

		p.SetState(1180)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAtomicContext is an interface to support dynamic dispatch.
type IAtomicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomicContext differentiates from other interfaces.
	IsAtomicContext()
}

type AtomicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomicContext() *AtomicContext {
	var p = new(AtomicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_atomic
	return p
}

func (*AtomicContext) IsAtomicContext() {}

func NewAtomicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomicContext {
	var p = new(AtomicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_atomic

	return p
}

func (s *AtomicContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomicContext) TokChar() ITokCharContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokCharContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokCharContext)
}

func (s *AtomicContext) TokInteger() ITokIntegerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokIntegerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokIntegerContext)
}

func (s *AtomicContext) TokFloat() ITokFloatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokFloatContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokFloatContext)
}

func (s *AtomicContext) TokAtom() ITokAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokAtomContext)
}

func (s *AtomicContext) AllTokString() []ITokStringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITokStringContext)(nil)).Elem())
	var tst = make([]ITokStringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITokStringContext)
		}
	}

	return tst
}

func (s *AtomicContext) TokString(i int) ITokStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokStringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITokStringContext)
}

func (s *AtomicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterAtomic(s)
	}
}

func (s *AtomicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitAtomic(s)
	}
}

func (p *ErlangParser) Atomic() (localctx IAtomicContext) {
	this := p
	_ = this

	localctx = NewAtomicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, ErlangParserRULE_atomic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1190)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ErlangParserTokChar:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1181)
			p.TokChar()
		}

	case ErlangParserTokInteger:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1182)
			p.TokInteger()
		}

	case ErlangParserTokFloat:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1183)
			p.TokFloat()
		}

	case ErlangParserTokAtom:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1184)
			p.TokAtom()
		}

	case ErlangParserTokString:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1186)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1185)
					p.TokString()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1188)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPrefixOpContext is an interface to support dynamic dispatch.
type IPrefixOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrefixOpContext differentiates from other interfaces.
	IsPrefixOpContext()
}

type PrefixOpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixOpContext() *PrefixOpContext {
	var p = new(PrefixOpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_prefixOp
	return p
}

func (*PrefixOpContext) IsPrefixOpContext() {}

func NewPrefixOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixOpContext {
	var p = new(PrefixOpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_prefixOp

	return p
}

func (s *PrefixOpContext) GetParser() antlr.Parser { return s.parser }
func (s *PrefixOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterPrefixOp(s)
	}
}

func (s *PrefixOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitPrefixOp(s)
	}
}

func (p *ErlangParser) PrefixOp() (localctx IPrefixOpContext) {
	this := p
	_ = this

	localctx = NewPrefixOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, ErlangParserRULE_prefixOp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1192)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ErlangParserT__1 || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(ErlangParserT__41-42))|(1<<(ErlangParserT__42-42))|(1<<(ErlangParserT__43-42)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMultOpContext is an interface to support dynamic dispatch.
type IMultOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultOpContext differentiates from other interfaces.
	IsMultOpContext()
}

type MultOpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultOpContext() *MultOpContext {
	var p = new(MultOpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_multOp
	return p
}

func (*MultOpContext) IsMultOpContext() {}

func NewMultOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultOpContext {
	var p = new(MultOpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_multOp

	return p
}

func (s *MultOpContext) GetParser() antlr.Parser { return s.parser }
func (s *MultOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterMultOp(s)
	}
}

func (s *MultOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitMultOp(s)
	}
}

func (p *ErlangParser) MultOp() (localctx IMultOpContext) {
	this := p
	_ = this

	localctx = NewMultOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, ErlangParserRULE_multOp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1194)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-24)&-(0x1f+1)) == 0 && ((1<<uint((_la-24)))&((1<<(ErlangParserT__23-24))|(1<<(ErlangParserT__31-24))|(1<<(ErlangParserT__44-24))|(1<<(ErlangParserT__45-24))|(1<<(ErlangParserT__46-24))|(1<<(ErlangParserT__47-24)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAddOpContext is an interface to support dynamic dispatch.
type IAddOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddOpContext differentiates from other interfaces.
	IsAddOpContext()
}

type AddOpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddOpContext() *AddOpContext {
	var p = new(AddOpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_addOp
	return p
}

func (*AddOpContext) IsAddOpContext() {}

func NewAddOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddOpContext {
	var p = new(AddOpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_addOp

	return p
}

func (s *AddOpContext) GetParser() antlr.Parser { return s.parser }
func (s *AddOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterAddOp(s)
	}
}

func (s *AddOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitAddOp(s)
	}
}

func (p *ErlangParser) AddOp() (localctx IAddOpContext) {
	this := p
	_ = this

	localctx = NewAddOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, ErlangParserRULE_addOp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1196)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ErlangParserT__1 || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(ErlangParserT__41-42))|(1<<(ErlangParserT__48-42))|(1<<(ErlangParserT__49-42))|(1<<(ErlangParserT__50-42))|(1<<(ErlangParserT__51-42))|(1<<(ErlangParserT__52-42))|(1<<(ErlangParserT__53-42)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IListOpContext is an interface to support dynamic dispatch.
type IListOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListOpContext differentiates from other interfaces.
	IsListOpContext()
}

type ListOpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListOpContext() *ListOpContext {
	var p = new(ListOpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_listOp
	return p
}

func (*ListOpContext) IsListOpContext() {}

func NewListOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListOpContext {
	var p = new(ListOpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_listOp

	return p
}

func (s *ListOpContext) GetParser() antlr.Parser { return s.parser }
func (s *ListOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterListOp(s)
	}
}

func (s *ListOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitListOp(s)
	}
}

func (p *ErlangParser) ListOp() (localctx IListOpContext) {
	this := p
	_ = this

	localctx = NewListOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, ErlangParserRULE_listOp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1198)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ErlangParserT__54 || _la == ErlangParserT__55) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICompOpContext is an interface to support dynamic dispatch.
type ICompOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompOpContext differentiates from other interfaces.
	IsCompOpContext()
}

type CompOpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompOpContext() *CompOpContext {
	var p = new(CompOpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ErlangParserRULE_compOp
	return p
}

func (*CompOpContext) IsCompOpContext() {}

func NewCompOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompOpContext {
	var p = new(CompOpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ErlangParserRULE_compOp

	return p
}

func (s *CompOpContext) GetParser() antlr.Parser { return s.parser }
func (s *CompOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.EnterCompOp(s)
	}
}

func (s *CompOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ErlangListener); ok {
		listenerT.ExitCompOp(s)
	}
}

func (p *ErlangParser) CompOp() (localctx ICompOpContext) {
	this := p
	_ = this

	localctx = NewCompOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, ErlangParserRULE_compOp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1200)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(ErlangParserT__56-57))|(1<<(ErlangParserT__57-57))|(1<<(ErlangParserT__58-57))|(1<<(ErlangParserT__59-57))|(1<<(ErlangParserT__60-57))|(1<<(ErlangParserT__61-57))|(1<<(ErlangParserT__62-57))|(1<<(ErlangParserT__63-57)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *ErlangParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 23:
		var t *Type300Context = nil
		if localctx != nil {
			t = localctx.(*Type300Context)
		}
		return p.Type300_Sempred(t, predIndex)

	case 24:
		var t *Type400Context = nil
		if localctx != nil {
			t = localctx.(*Type400Context)
		}
		return p.Type400_Sempred(t, predIndex)

	case 58:
		var t *PatExpr400Context = nil
		if localctx != nil {
			t = localctx.(*PatExpr400Context)
		}
		return p.PatExpr400_Sempred(t, predIndex)

	case 59:
		var t *PatExpr500Context = nil
		if localctx != nil {
			t = localctx.(*PatExpr500Context)
		}
		return p.PatExpr500_Sempred(t, predIndex)

	case 65:
		var t *MapPatExprContext = nil
		if localctx != nil {
			t = localctx.(*MapPatExprContext)
		}
		return p.MapPatExpr_Sempred(t, predIndex)

	case 83:
		var t *MapExprContext = nil
		if localctx != nil {
			t = localctx.(*MapExprContext)
		}
		return p.MapExpr_Sempred(t, predIndex)

	case 89:
		var t *RecordExprContext = nil
		if localctx != nil {
			t = localctx.(*RecordExprContext)
		}
		return p.RecordExpr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ErlangParser) Type300_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ErlangParser) Type400_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ErlangParser) PatExpr400_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ErlangParser) PatExpr500_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ErlangParser) MapPatExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ErlangParser) MapExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ErlangParser) RecordExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
